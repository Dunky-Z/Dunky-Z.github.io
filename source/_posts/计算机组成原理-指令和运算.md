---
title: 计算机组成原理-指令和运算
date: 2022-02-28 21:28:56
updated:
tags: [计算机组成原理]
categories: [计算机组成原理]
---

## 计算机指令
上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0表示不打孔，1表示打孔），送入特殊的计算机中执行。

从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。

从软件的角度来看，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作**机器语言**（Machine Language）。

不同的 CPU 能够听懂的语言不太一样。也就是CPU支持的语言不一样，这里的语言叫**指令集**（Instruction Set）。

一个计算机程序由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作**存储程序型计算机**（Stored-program Computer）。

了解了计算机指令和计算机指令集，接下来我们来看看，平时编写的代码，到底是怎么变成一条条计算机指令，最后被 CPU 执行的呢？我们拿一小段真实的 C 语言程序来看看。
```c
// test.c
int main()
{
  int a = 1; 
  int b = 2;
  a = a + b;
}
```

通过编译器，可以将上述代码编译成汇编代码，再通过汇编器，将汇编代码编译成机器码，最后通过 CPU 执行。

在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。
```bash
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o

test.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
int main()
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int a = 1; 
   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
  int b = 2;
   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  a = a + b;
  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  15:   01 45 fc                add    DWORD PTR [rbp-0x4],eax
}
  18:   5d                      pop    rbp
  19:   c3                      ret    
```
左侧有一堆数字，这些就是一条条机器码；右边有一系列的` push`、`mov`、`add`、`pop` 等，这些就是对应的汇编代码。

了解了这个过程，下面我们放大局部，来看看这一行行的汇编代码和机器指令，到底是什么意思。

常见的指令可以分成五大类。

第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。

第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。

第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。

第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。

最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。


## 指令跳转
### CPU如何执行指令的
代码经过软件层面的编译后就是一条条二进制指令，指令交由CPU中几百亿个晶体管去执行。我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。而寄存器就是 CPU 内部，由多个**触发器**（Flip-Flop）或者**锁存器**（Latches）组成的简单电路。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。

`N` 个触发器或者锁存器，就可以组成一个` N `位（Bit）的寄存器，能够保存 `N `位的数据。比方说，我们用的` 64 `位 `Intel `服务器，寄存器就是` 64` 位的。


一个 CPU 里面会有很多种不同功能的寄存器。这里介绍三种比较特殊的。

- PC 寄存器（Program Counter Register），我们也叫**指令地址寄存器**（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。

- 指令寄存器（Instruction Register），用来存放当前正在执行的指令。

- 条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。

除此之外还有**整数寄存器**、**浮点数寄存器**、**向量寄存器**和**地址寄存器**等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。


实际上，一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。

而有些特殊指令，比如上一讲我们讲到 `J` 类指令，也就是跳转指令，会修改 PC 寄存器里面的地址值。
### 从 if…else 来看程序的执行和跳转

首先看如下的例程，
```C
// test.c
#include <time.h>
#include <stdlib.h>
 
int main()
{
  srand(time(NULL));
  int r = rand() % 2;
  int a = 10;
  if (r == 0)
  {
    a = 1;
  } else {
    a = 2;
  } 
```

```bash
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o 
```
编译后打印出汇编代码如下：
```
 if (r == 0)
  3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0
  3f:   75 09                   jne    4a <main+0x4a>
    {
        a = 1;
  41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1
  48:   eb 07                   jmp    51 <main+0x51>
    }
    else
    {
        a = 2;
  4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  51:   b8 00 00 00 00          mov    eax,0x0
    } 
```

可以看到，这里对于 `r == 0 `的条件判断，被编译成了 cmp 和 jne 这两条指令。

`cmp` 指令比较了前后两个操作数的值，这里的` DWORD PTR` 代表操作的数据类型是 `32 `位的整数，而 `[rbp-0x4]` 则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量 `r` 的值。第二个操作数 `0x0` 就是我们设定的常量` 0 `的 `16` 进制表示。`cmp` 指令的比较结果，会存入到条件码寄存器当中去。

在这里，如果比较的结果是 `True`，也就是 `r == 0`，就把零标志条件码（对应的条件码是 `ZF`，`Zero Flag`）设置为 `1`。除了零标志之外，`Intel` 的 `CPU` 下还有进位标志（`CF`，`Carry Flag`）、符号标志（`SF`，`Sign Flag`）以及溢出标志（`OF`，`Overflow Flag`），用在不同的判断条件下。

`cmp` 指令执行完成之后，`PC` 寄存器会自动自增，开始执行下一条 `jne` 的指令。

跟着的 `jne` 指令，是 `jump if not equal` 的意思，它会查看对应的零标志位。如果为` 0`，会跳转到后面跟着的操作数 `4a` 的位置。这个 `4a`，对应这里汇编代码的行号，也就是上面设置的 `else` 条件里的第一条指令。当跳转发生的时候，`PC` 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 `4a` 这个地址。这个时候，`CPU` 再把 `4a` 地址里的指令加载到指令寄存器中来执行。

跳转到执行地址为 `4a` 的指令，实际是一条 `mov` 指令，第一个操作数和前面的 `cmp` 指令一样，是另一个 `32` 位整型的寄存器地址，以及对应的 `2` 的` 16` 进制值 `0x2`。`mov` 指令把 `2` 设置到对应的寄存器里去，相当于一个赋值操作。然后，`PC `寄存器里的值继续自增，执行下一条 `mov` 指令。

这条 `mov` 指令的第一个操作数` eax`，代表累加寄存器，第二个操作数` 0x0 `则是 `16` 进制的` 0 `的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的 `if` 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 `jmp` 的无条件跳转指令。跳转的地址就是这一行的地址` 51`。我们的 `main` 函数没有设定返回值，而` mov eax`, `0x0` 其实就是给 `main` 函数生成了一个默认的为 `0` 的返回值到累加器里面。`if` 条件里面的内容执行完成之后也会跳转到这里，和 `else` 里的内容结束之后的位置是一样的。

## 函数调用：为什么会发生Stack Overflow
## 静态链接
既然我们的程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在 Linux 下可以运行，而在 Windows 下却不行呢？反过来，Windows 上的程序在 Linux 上也是一样不能执行的。可是我们的 CPU 并没有换掉，它应该可以识别同样的指令呀？

将以下两个例程编译，然后通过 objdump 命令看看它们的汇编代码。
```C
// add_lib.c
int add(int a, int b)
{
    return a+b;
}

// link_example.c
#include <stdio.h>
int main()
{
    int a = 10;
    int b = 5;
    int c = add(a, b);
    printf("c = %d\n", c);
}
```

```bash
$ gcc -g -c add_lib.c link_example.c
$ objdump -d -M intel -S add_lib.o
$ objdump -d -M intel -S link_example.o
```


```
add_lib.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <add>:
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  10:   01 d0                   add    eax,edx
  12:   5d                      pop    rbp
  13:   c3                      ret    
```

```
link_example.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   48 83 ec 10             sub    rsp,0x10
   8:   c7 45 fc 0a 00 00 00    mov    DWORD PTR [rbp-0x4],0xa
   f:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5
  16:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
  19:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  1c:   89 d6                   mov    esi,edx
  1e:   89 c7                   mov    edi,eax
  20:   b8 00 00 00 00          mov    eax,0x0
  25:   e8 00 00 00 00          call   2a <main+0x2a>
  2a:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
  2d:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]
  30:   89 c6                   mov    esi,eax
  32:   48 8d 3d 00 00 00 00    lea    rdi,[rip+0x0]        # 39 <main+0x39>
  39:   b8 00 00 00 00          mov    eax,0x0
  3e:   e8 00 00 00 00          call   43 <main+0x43>
  43:   b8 00 00 00 00          mov    eax,0x0
  48:   c9                      leave  
  49:   c3                      ret    
```

既然代码已经被我们“编译”成了指令，我们不妨尝试运行一下 `./link_example.o`。

然而我们并不能成功运行，会得到一条` cannot execute binary file: Exec format error` 的错误。

我们再仔细看一下 objdump 出来的两个文件的代码，**会发现两个程序的地址都是从 0 开始的**。如果地址是一样的，程序如果需要通过 `call` 指令调用函数的话，**它怎么知道应该跳转到哪一个文件里呢？**

无论是这里的运行报错，还是 `objdump` 出来的汇编代码里面的重复地址，都是因为` add_lib.o `以及 `link_example.o` 并不是一个可执行文件（Executable Program），而是目标文件（Object File）。**只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。**

通过 `gcc` 的` -o `参数，可以生成对应的可执行文件。
```
$ gcc -o link-example add_lib.o link_example.o
$ ./link_example
c = 15
```

ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/202203032207712.png)

链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/202203032209801.png)

在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。


为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。其中一个非常重要的原因就是，**两个操作系统下可执行文件的格式不一样**。

我们今天讲的是 Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作PE（Portable Executable Format）的文件格式。**Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。**

如果我们有一个可以能够解析 PE 格式的装载器，我们就有可能在 Linux 下运行 Windows 程序了。这样的程序真的存在吗？没错，Linux 下著名的开源项目 Wine，就是通过兼容 PE 格式的装载器，使得我们能直接在 Linux 下运行 Windows 程序的。而现在微软的 Windows 里面也提供了 WSL，也就是 Windows Subsystem for Linux，可以解析和加载 ELF 格式的文件。

## 程序装载
#### 程序装载面临的挑战
- 可执行程序加载后占用的内存空间应该是连续的。
- 我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。
## 动态链接
## 二进制编码
## 理解电路
## 加法器
## 乘法器
## 浮点数和定点数
