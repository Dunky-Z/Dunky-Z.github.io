---
title: 计算机组成原理-指令和运算
date: 2022-02-28 21:28:56
updated:
tags: [计算机组成原理]
categories: [计算机组成原理]
---

## 计算机指令
上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0表示不打孔，1表示打孔），送入特殊的计算机中执行。

从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。

从软件的角度来看，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作**机器语言**（Machine Language）。

不同的 CPU 能够听懂的语言不太一样。也就是CPU支持的语言不一样，这里的语言叫**指令集**（Instruction Set）。

一个计算机程序由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作**存储程序型计算机**（Stored-program Computer）。

了解了计算机指令和计算机指令集，接下来我们来看看，平时编写的代码，到底是怎么变成一条条计算机指令，最后被 CPU 执行的呢？我们拿一小段真实的 C 语言程序来看看。
```c
// test.c
int main()
{
  int a = 1; 
  int b = 2;
  a = a + b;
}
```

通过编译器，可以将上述代码编译成汇编代码，再通过汇编器，将汇编代码编译成机器码，最后通过 CPU 执行。

在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。
```bash
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o

test.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
int main()
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int a = 1; 
   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
  int b = 2;
   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  a = a + b;
  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  15:   01 45 fc                add    DWORD PTR [rbp-0x4],eax
}
  18:   5d                      pop    rbp
  19:   c3                      ret    
```
左侧有一堆数字，这些就是一条条机器码；右边有一系列的` push`、`mov`、`add`、`pop` 等，这些就是对应的汇编代码。

了解了这个过程，下面我们放大局部，来看看这一行行的汇编代码和机器指令，到底是什么意思。

常见的指令可以分成五大类。

第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。

第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。

第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。

第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。

最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。


## 指令跳转
### CPU如何执行指令的
代码经过软件层面的编译后就是一条条二进制指令，指令交由CPU中几百亿个晶体管去执行。我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。而寄存器就是 CPU 内部，由多个**触发器**（Flip-Flop）或者**锁存器**（Latches）组成的简单电路。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。

`N` 个触发器或者锁存器，就可以组成一个` N `位（Bit）的寄存器，能够保存 `N `位的数据。比方说，我们用的` 64 `位 `Intel `服务器，寄存器就是` 64` 位的。


一个 CPU 里面会有很多种不同功能的寄存器。这里介绍三种比较特殊的。

- PC 寄存器（Program Counter Register），我们也叫**指令地址寄存器**（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。

- 指令寄存器（Instruction Register），用来存放当前正在执行的指令。

- 条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。

除此之外还有**整数寄存器**、**浮点数寄存器**、**向量寄存器**和**地址寄存器**等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。


实际上，一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。

而有些特殊指令，比如上一讲我们讲到 `J` 类指令，也就是跳转指令，会修改 PC 寄存器里面的地址值。
### 从 if…else 来看程序的执行和跳转

首先看如下的例程，
```C
// test.c
#include <time.h>
#include <stdlib.h>
 
int main()
{
  srand(time(NULL));
  int r = rand() % 2;
  int a = 10;
  if (r == 0)
  {
    a = 1;
  } else {
    a = 2;
  } 
```

```bash
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o 
```
编译后打印出汇编代码如下：
```
 if (r == 0)
  3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0
  3f:   75 09                   jne    4a <main+0x4a>
    {
        a = 1;
  41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1
  48:   eb 07                   jmp    51 <main+0x51>
    }
    else
    {
        a = 2;
  4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  51:   b8 00 00 00 00          mov    eax,0x0
    } 
```

可以看到，这里对于 `r == 0 `的条件判断，被编译成了 cmp 和 jne 这两条指令。

`cmp` 指令比较了前后两个操作数的值，这里的` DWORD PTR` 代表操作的数据类型是 `32 `位的整数，而 `[rbp-0x4]` 则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量 `r` 的值。第二个操作数 `0x0` 就是我们设定的常量` 0 `的 `16` 进制表示。`cmp` 指令的比较结果，会存入到条件码寄存器当中去。

在这里，如果比较的结果是 `True`，也就是 `r == 0`，就把零标志条件码（对应的条件码是 `ZF`，`Zero Flag`）设置为 `1`。除了零标志之外，`Intel` 的 `CPU` 下还有进位标志（`CF`，`Carry Flag`）、符号标志（`SF`，`Sign Flag`）以及溢出标志（`OF`，`Overflow Flag`），用在不同的判断条件下。

`cmp` 指令执行完成之后，`PC` 寄存器会自动自增，开始执行下一条 `jne` 的指令。

跟着的 `jne` 指令，是 `jump if not equal` 的意思，它会查看对应的零标志位。如果为` 0`，会跳转到后面跟着的操作数 `4a` 的位置。这个 `4a`，对应这里汇编代码的行号，也就是上面设置的 `else` 条件里的第一条指令。当跳转发生的时候，`PC` 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 `4a` 这个地址。这个时候，`CPU` 再把 `4a` 地址里的指令加载到指令寄存器中来执行。

跳转到执行地址为 `4a` 的指令，实际是一条 `mov` 指令，第一个操作数和前面的 `cmp` 指令一样，是另一个 `32` 位整型的寄存器地址，以及对应的 `2` 的` 16` 进制值 `0x2`。`mov` 指令把 `2` 设置到对应的寄存器里去，相当于一个赋值操作。然后，`PC `寄存器里的值继续自增，执行下一条 `mov` 指令。

这条 `mov` 指令的第一个操作数` eax`，代表累加寄存器，第二个操作数` 0x0 `则是 `16` 进制的` 0 `的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的 `if` 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 `jmp` 的无条件跳转指令。跳转的地址就是这一行的地址` 51`。我们的 `main` 函数没有设定返回值，而` mov eax`, `0x0` 其实就是给 `main` 函数生成了一个默认的为 `0` 的返回值到累加器里面。`if` 条件里面的内容执行完成之后也会跳转到这里，和 `else` 里的内容结束之后的位置是一样的。

## 函数调用：为什么会发生Stack Overflow
## 静态链接
既然我们的程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在 Linux 下可以运行，而在 Windows 下却不行呢？反过来，Windows 上的程序在 Linux 上也是一样不能执行的。可是我们的 CPU 并没有换掉，它应该可以识别同样的指令呀？

## 程序装载
## 动态链接
## 二进制编码
## 理解电路
## 加法器
## 乘法器
## 浮点数和定点数
