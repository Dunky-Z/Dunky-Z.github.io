---
title: 计算机组成原理-指令和运算
date: 2022-02-28 21:28:56
updated:
tags: [计算机组成原理]
categories: [计算机组成原理]
---

## 计算机指令
上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0表示不打孔，1表示打孔），送入特殊的计算机中执行。

从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。

从软件的角度来看，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作**机器语言**（Machine Language）。

不同的 CPU 能够听懂的语言不太一样。也就是CPU支持的语言不一样，这里的语言叫**指令集**（Instruction Set）。

一个计算机程序由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作**存储程序型计算机**（Stored-program Computer）。

了解了计算机指令和计算机指令集，接下来我们来看看，平时编写的代码，到底是怎么变成一条条计算机指令，最后被 CPU 执行的呢？我们拿一小段真实的 C 语言程序来看看。
```c
// test.c
int main()
{
  int a = 1; 
  int b = 2;
  a = a + b;
}
```

通过编译器，可以将上述代码编译成汇编代码，再通过汇编器，将汇编代码编译成机器码，最后通过 CPU 执行。

在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。
```bash
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o

test.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
int main()
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int a = 1; 
   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
  int b = 2;
   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  a = a + b;
  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  15:   01 45 fc                add    DWORD PTR [rbp-0x4],eax
}
  18:   5d                      pop    rbp
  19:   c3                      ret    
```
左侧有一堆数字，这些就是一条条机器码；右边有一系列的` push`、`mov`、`add`、`pop` 等，这些就是对应的汇编代码。

了解了这个过程，下面我们放大局部，来看看这一行行的汇编代码和机器指令，到底是什么意思。

常见的指令可以分成五大类。

第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。

第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。

第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。

第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。

最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。


## 指令跳转
## 函数调用：为什么会发生Stack Overflow
## 静态链接
## 程序装载
## 动态链接
## 二进制编码
## 理解电路
## 加法器
## 乘法器
## 浮点数和定点数
