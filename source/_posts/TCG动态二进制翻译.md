---
title: TCG动态二进制翻译
date: 2021-07-29 17:59:24
tags: [QEMU,TCG,Linux]
---

从之前的学习可以知道，QEMU可以在不同架构的host上模拟不同架构的机器。而能够完成这项任务的最主要技术就是二进制动态翻译技术。

## 二进制翻译概述

二进制翻译是一种可直接翻译执行二进制代码的技术，它能够把一种体系结构(源体系结构)的二进制代码直接翻译到另一种体系结构(目标体系结构)上执行。二进制翻译是一种广义上的**中间件技术**，它很好地降低了应用程序对底层硬件的依赖，使得二者可以相对独立地发展和变化。

一个最简单的二进制翻译系统其工作流程如下：
1. 系统读入源体系的二进制程序，找到程序入口地址；
2. 从程序入口地址开始，读入指令进行翻译。每条指令需要经过指令解析、指令映射和指令执行三个阶段。
   1. 指令解析阶段通过译码识别指令功能，其过程类型反汇编；
   2. 指令映射阶段，系统根据源体系指令功能将指令映射到能够完成相同功能的目标体系指令；
   3. 指令执行阶段，执行目标体系指令完成源体系指令的语义功能。

>什么是译码识别；如何指令映射；如何执行指令

二进制翻译系统按照实现方式不同可以分为三类：解释执行，静态翻译，动态翻译。
### 解释执行
解释执行是指目标体系对源体系代码逐条进行解释并执行，而不对解释结果进行任何保存。该方法实现简单，不需要用户干涉，但效率较低。
>什么是解释？
### 静态翻译
静态翻译(Static Binary Translator， SBT)是指在离线状态下，对源体系二进制代码进行整体翻译并优化，最后产生目标体系代码。一次翻译，可多次执行。该方法效率很高，但由于离线状态下无法获得整个程序的完整执行细节，无法对自修改代码、自引用代码等进行支持，需要在进行时利用解释器对这些情况进行处理,无法摆脱对解释器的依赖。
>离线状态什么意思；什么是自修改代码，自引用代码；
### 动态翻译
动态翻译(Dynamic Binary Translator， DBT) 是在程序运行时进行翻译，边翻译边执行。大部分动态二进制翻译系统采用**基本块**作为翻译的基本单位，基本块是以跳转指令为结束的一个指令序列。以基本块举例，系统翻译一个基本块前，首先查找代码Cache确定当前基本块是否翻译，若已经翻译(命中)，则直接从代码Cache中取出相应的目标体系指令进行执行；若没有翻译(未命中)，则翻译当前指令，直至遇到基本块结束指令，则将当前翻译结果缓存至代码Cache，并将翻译结果执行。动态翻译中，只有代码被执行到时才进行翻译，能够很好地克服静态翻译的先天缺陷。

## QEMU动态二进制翻译
QEMU动态二进制翻译系统采用微指令作为中间代码层，并将临时变量作为微指令的操作数。因此，在介绍QEMU动态二进制翻译前有必要对微指令和中间变量这两个重要概念进行说明。

### 微指令
QEMU早期采用Dyngen机制实现二进制翻译。从QEMU-0.10.0开始， TCG成为QEMU新的翻译引擎，QEMU不再依赖于GCC3.x版本，并且做到了“真正”的动态翻译。TCG的全称为"Tiny Code Generator"，即微指令生成器。进行指令翻译时， QEMU翻译前端将每条源体系结构的指令分解为一条或多条类似RISC指令的微指令，并进行一些优化工作，如去除死代码等，之后微指令在后端生成目标体系结构代码，其生成过程采用硬编码。

QEMU定义了100多条微指令，同CPU的指令集一样，这些微指令也包括数据传送、算术运算、逻辑运算、程序控制、函数调用等几大类型，同时还包括一些QEMU用于控制翻译的特殊微指令。微指令支持两种数据类型， 32 bit整型和64 bit整型，表示源体系的机器长度。
>什么是指令；Dyngen机制又是怎样的，为什么要换；在后端如何生成目标提醒结构代码；硬编码什么；
### 临时变量
微指令的操作数称为临时变量(temporary) ，如上文提到的`neg_i32 t0，t1`微指令中， `t0，t1`即为临时变量。根据临时变量的作用域不同，可将其划分为三种类型：普通变量(temporary)，本地变量(local temorary)和全局变量(global emporary)。

临时变量(temporary)的生命周期为`tcg`的一个基本块， `tcg`基本块以跳转类型的微指令结束，即微指令定义时`flag`为`TCG-OPF-BBEND`。

本地临时变量(local temorary)的作用周期为`tcg`的一个函数， tcg函数对应于QEMU的一个翻译基本块(Translation Block，简称tb)。

全局临时变量(global temporary)的作用周期为所有的`tcg`函数，相当于C语言中的全局变量，一般在`tcg`函数外定义。全局变量通常被映射到某个内存地址或某个固定的寄存器。

QEMU包含了一个临时变量池，其最大容量为`512`，进行前端指令翻译时，需要从临时变量池中申请临时变量进行操作，并在操作结束后及时对申请的临时变量进行释放。

### 基本块
基本块是QEMU翻译和执行的基本单位，在QEMU中基本块也称为翻译块(Translation Block，简称tb)，每个源体系结构设置固定的一些指令作为基本块结束指令，称为基本块结束指令。当翻译遇到基本块结束指令时，即停止前端翻译，后端将微指令转化为目标体系指令执行。

基本块结束指令的选择原则是: 1、跳转指令，包括直接跳转指令、间接跳转指令、条件跳转指令;2、能够改变相同指令执行效果的指令，例如特权指令只能在内核态使用，用户态使用特权指令视为非法行为，会产生特权违反异常，用户态内核态切换指令能影响权指令的执行效果，因此用户态内核态切换指令也被认为是基本块结束指令。

>前后端的界限？

### 翻译流程
QEMU首先加载源体系结构二进制文件，并找到程序的入口地址，开始翻译。每次翻译前， QEMU会首先根据当前指令PC查找代码Cache，若找到，则表示该基本块已经翻译过，则取出相应的目标代码执行，没找到，则执行翻译过程。

翻译前端针对当前指令，首先译码判断指令功能，然后将其翻译为对应的一条或多条微指令，缓存在`TCG Cache`中，然后继续翻译下一条指令，直至遇到基本块结束指令，则结束当前基本块前端翻译。

在对`TCG Cache`中的微指令进行一些优化后(去除死代码等)后，后端将当前基本块对应的TCG指令翻译为目标体系结构代码，称为**代码块**，并缓存在代码Cache中，同时执行目标代码。

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210729200436.png)

>什么是指令PC；什么是死代码；

## Reference