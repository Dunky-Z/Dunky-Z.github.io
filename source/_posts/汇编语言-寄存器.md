---
title: 汇编语言-寄存器
date: 2021-08-05 20:00:15
tags: [汇编语言]
---
## 寄存器及其存储
在CPU中：
- 运算器进行信息处理;
- 寄存器进行信息存储;
- 控制器控制各种器件进行工作;
- 内部总线连接各种器件,在它们之间进行数据的传送。

程序员可以通过改变寄存器中的内容来实现对CPU的控制。

每个CPU，寄存器个数和结构都不同。8086CPU有14个16位的寄存器。每个寄存器都有一个名字，其中`AX,BX,CX,DX`，用来放一般性数据，被称为通用寄存器。

上一代CPU的寄存器是8位的，为了保证兼容，这四个通用寄存器可以分为两个独立使用的8位寄存器来使用：

- AX可分为AH和AL;
- BX可分为BH和BL;
- CX可分为CH和CL;
- DX可分为DH和DL

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806100400.png)

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806100416.png)

出于对兼容性的考虑, 8086CPU可以一次性处理以下两种尺寸的数据。
- 字节:记为`byte`,一个字节由8个bit组成,可以存在8位寄存器中。
- 字:记为`word`,一个字由两个字节组成,这两个字节分别称为这个字的**高位字**
节和低位字节,如图2.5所示。

![](https://gitee.com/dominic_z/hexomarkdown_picbed/raw/master/img/20210806100636.png)

因为一个内存单元可以存放8位数据，CPU中的寄存器又可以存放n个8位数据，也就是说，计算机中数据大多是由1-n个8位数据构成的，用十六进制表示数据可以直观的看出这个数据由哪些8位数据构成。比如：
```
20000
0100111000100000
4(0100) E(1110)  2(0010) 0(0000)
4E20
```

## 几条汇编指令

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806102349.png)

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806140628.png)

## 物理地址

CPU访问内存单元时，需要给出内存单元的地址，所有内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这空间中都有唯一的地址，我们将这个唯一的地址称为**物理地址**。

常见的8086CPU是16位机，他可以一次性处理、传输、暂存的信息最大长度是16位。但是8086CPU有20位地址总线，可以传送20位地址，有1M的寻址能力。从内部结构来看，如果简单地将地址发出，他只能送出16位地址，寻址能力只有64K。

8086CPU在内部**使用两个16位地址合成一个20位物理地址**的方法。

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806142816.png)

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806143245.png)

段地址中的段并不是说内存被划分为了一段一段的。段的划分是CPU搞得鬼。

**段寄存器**用来存放段地址。8086CPU有四个段寄存器：`CS,DS,SS,ES`。

`CS `代码段寄存器和 `IP `指令指针寄存器是8086CPU中两个最关键的寄存器，他们指示了CPU当前要读取的指令的地址。

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163009.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163041.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163058.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163122.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163154.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163212.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163228.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163254.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163323.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163710.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163412.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163426.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163907.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806163932.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806170354.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806170432.png)
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210806171935.png)

前面说过，在内存中指令和数据没有区别，都是二进制信息，但是什么时候CPU把信息当做指令，什么时候当做数据呢？
CPU将CS，IP中的内容当做指令的段地址和偏移地址，用他们合成指令的物理地址，到内存中读取指令码，执行。

## 修改CS，IP的指令
8086CPU中大部分寄存器值都可以用`mov`来修改，但是`CS`，`IP`需要通过特殊的指令`jmp`。

能改变`CS`,`IP`的指令统称为**转移指令**。

使用格式：
```
jmp 段地址 : 偏移地址
jmp 2AE3:3 # CS=2AE3H, IP=0003H, CPU将从2AE33H处读取指令
jmp 3:0B16 # CS=0003H, IP=0B16H, CPU将从00B46H处读取指令
```

## 内存中字的存储与传送
CPU中用16位寄存器来存储一个字 ，一个内存单元可以存八位（一个字节），所以一个字需要两个连续的内存单元来存放。

**字单元**：即存放一个字型数据(16位)的内存单元,由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节,低地址内存单元中存放字型数据的低位字节。

`DS`：DS段寄存器，通常用来放要访问数据的段地址。比如我们要读取`10000H`单元的内容，可以用如下程序进行。

```
mov bx, 1000H               # 将数据直接送入寄存器bx
mov ds, bx                  # 将一个寄存器bs的内容送入ds寄存器
mov al, [01]                # 内存单元偏移0
```
因为不能直接将数据送入段寄存器（8086硬件设计问题），所以需要先将数据送入寄存器`bx`，再将`bx`中的内容送入`ds`。

**字的传送**：`mov`指令在寄存器和内存之间进行字节型数据的传送。因为8086CPU是16位结构,有16根数据线,所以,可以一次性传送16位的数据,也就是说可以一次性传送一个字。**只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了**。

实例：
将123B0H-123B9H的内存单元定义为数据段，现在累加数据段的前三个单元的数据：
```
mov ax, 123BH
mov ds, ax          #将123BH送入ds中,作为数据段的段地址
mov al,0            #用al存放累加结果
add al, [0]         #将数据段第一个单元(偏移地址为0)中的数值加到a1中
add al, [1]         #将数据段第二个单元(偏移地址为1)中的数值加到al中
add al, [2]         #将数据段第三个单元(偏移地址为2)中的数值加到a1中
```
现在累加数据段的前三个字型的数据：
```
mov ax, 123BH
mov ds, ax          #将123BH送入ds中,作为数据段的段地址
mov ax, 0           #用ax存放累加结果
add ax, [0]         #将数据段第一个字(偏移地址为0)加到ax中
add ax, [2]         #将数据段第二个字(偏移地址为2)加到ax中
add ax, [4]         #将数据段第三个字(偏移地址为4)加到ax中
# 一个字型数据占两个单元，所以偏移地址为0,2,4
```

## CPU的栈机制
基于8086CPU编程的时候，可以将一段内存当做栈来使用。

入栈和出栈操作都以字为单位进行。

**CPU如何知道某一段内存要当做栈使用？如何知道哪个单元时栈顶单元？**
8086CPU中,有两个寄存器,段寄存器`SS`和寄存器`SP`,栈顶的段地址存放在`SS`中,偏移地址存放在`SP`中。任意时刻, `SS:SP`指向栈顶元素。`push`指令和`pop`指令执行时, CPU从`SS`和`SP`中得到栈顶的地址。

8086CPU中，入栈时，栈顶从高地址向低地址方向增长。

栈溢出是危险的，但是**8086CPU不保证我们对栈的操作不会溢出**。所以要小心安排栈空间，要根据可能用到的最大栈空间，来安排栈的大小。

我们可以将长度为N(N<=64K)的一组连续地址，起始地址为16的倍数的内存单元，当做栈空间来使用，从而定义一个**栈段**。

