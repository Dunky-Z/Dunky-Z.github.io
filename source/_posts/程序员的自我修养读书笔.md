---
title: 程序员的自我修养笔记
date: 2022-03-35 11:12:31
updated:
tags: [读书笔记]
categories: [读书笔记]
---

## 静态链接

库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。

## 第三章 目标文件里有什么
### 3.1 目标文件的格式

**目标文件**从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。

现在PC平台流形的可执行文件格式，主要是windows下的PE（Portable Executable）和Linux下的ELF（Executable Linkable Format）,它们都是COFF（Common file format）格式的变种。

指令和数据分开存放的好处：

- 一方面当程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被设置成可读写和只读，这样可以防止程序的指令被有意或无意地改写。

- 另一方面是现代CPU有强大的缓存体系，由于缓存很重要，所以程序必须尽量提高缓存命中率。指令区和数据区分离有利于提高程序的局部性。现代CPU的缓存一般都被设计成数据缓存和指令缓存，所以程序的指令和数据分开存放对于CPU的缓存命中率提高有好处。

- 第三个原因，也是最重要的原因，就是当系统中运行着多个该进程副本时，他们的指令都是一样的，所以内存中只需要保存一份程序的指令部分。


**真正了牛逼的程序员对自己的程序每一个字节都了如指掌。**

```
objdump -h  SimpleSsection.o  # 打印elf文件各个段的信息
size SimpleSsection.o           # 查看elf文件各个段的长度
objdump -s -d SimpleSsection.o # -s将所有段内容以十六进制打印，-d将所有包含指令的段反汇编
```

|段名称|内容| 
| ---- | ---- | 
|.data|- 初始化的全局变量 <br> - 局部静态变量| 
|.rodata|只读数据段，对这个段的任何修改都是非法的，保证了程序的安全性。 <br> 有时候编译器会把字符串放到data段<br> - 只读变量 const 修饰 <br> - 字符串常量| 
|.bss|不占磁盘空间， <br>- 未初始化的全局变量 <br> - 未初始化的局部静态变量 <br> - 初始化为0的静态变量| 
|.comment|存放编译器版本信息，比如字符串“GCC：（GNU）4.2.0”| 
|.line|调试时的行号表，即源代码行号与编译后指令的对应表| 
|.note|额外的编译器信息，如程序公司名，版本号| 
|.symtab|Symbol Table符号表| 
|.plt|动态链接的跳转表| 
|.got|动态链接的全局入口表| 

段名称都是`.`前缀，表示这些表名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名称。比如可以加入一个`music`段，里面存一首mp3音乐，运行起来后就会播放音乐，打算自定义段不能使用`.`作为前缀，以免与系统保留段名冲突。

> Q: 如何将一个二进制文件，如图片，MP3文件作为目标文件的一个段？
A: 可以使用objcopy工具，比如有一个图片 image..jpg，大小为0x2100字节：
$ objcopy -I binary -O elf32-i388 -B  i38 image.jpg image.o

正常情况下编译出来的目标文件，代码会放到`.text`段，但是有时候你希望变量或者某些代码能放到你指定的段中去，以实现某些特定的功能。比如为了满足某些硬件的内存和IO地址布局。GCC提供了扩展机制，使得程序员可以指定变量所处的段：

```
__attribute__((section("FOO"))) int global = 42;
__attribute__((section("BAR"))) void foo;
```

### 3.4 ELF 文件结构
使用`readelf`命令查看elf文件详细信息。

- ELF 魔数，确认文件类型。
- 文件类型

    |常量|值| 含义| 
    | ---- | ---- |  ---- | 
    |ET_REL|1| 可重定位文件，一般问.o文件| 
    |ET_EXEC|2| 可执行文件| 
    |ET_DYN|3| 共享目标文件，一般为.so文件| 

- 机器类型

    |常量|值| 含义| 
    | ---- | ---- |  ---- | 
    |EM_M32|1|AT&T WE 32100| 
    |EM_SPARC|2| SPARC| 
    |EM_M386|3| Intel x86| 
    |EM_68K|4| Motorola 68000| 
    |EM_88K|5| Motorola 88000| 
    |EM_860|6| Intel 80860| 


**段表**是保存各个段的基本属性的结构。段表是除文件头外最重要的结构。编译器，链接器和装载器都是依靠段表来定位和访问各个段的属性。

### 3.5 链接的接口-符号

#### 符号表结构
链接过程的本质就是要把多个不同的目标文件之间相互粘到一起。

目标文件B要用到目标文件A的函数`foo`，我们称目标文件A**定义**了函数`foo`，目标文件B**引用**了目标文件A的函数`foo`。

链接中，我们将函数和变量统称为**符号**，函数名或变量名就是符号名。、

每一个目标文件都会有一个相应的符号表，表里记录了目标文件中所用到的所有符号。每个符号都有一个对应值，叫符号值，对于变量和函数来说，符号值就是他们的地址。

符号类型：
- 定义在本目标文件的全局符号，可以被其他目标引用。
- 在本目标文件中应用的全局符号，却没有定义在本目标文件。
- 段名称，也就是段起始地址。
- 局部符号，一些静态变量等。
- 行号信息。

最重要的就是第一类和第二类。链接只关心全局符号的相互粘合，其他都是次要的。

可以使用 `readelf` `objdump` `nm`等命令查看符号信息。

#### 特殊符号
一些特殊符号，没有在程序中定义，但是可以直接声明并引用它：
- `__executable_start`，程序起始地址，不是入口地址，是程序最开始的地址。
- `__etext` `__etext`  `etext` 代码段结束地址，代码段最末尾的地址。
- `_edata` `edata` 数据段结束地址，数据段最末尾地址。
- `__end`  `end` 程序结束地址。


#### 符号修饰
符号应与对应的函数或者变量同名，但是在C语言发明时，已经存在了很多库和目标文件，如果再用一样的函数或变量就会冲突为了避免冲突，C语言编译后符号名前会加上下划线`_`，如`foo`变成`_foo`，Fortran语言编译后会在符号前后加上下划线`_foo_`。

C++具有类，继承，重载等复杂机制，为了支持这些复杂特性，人们发明了**符号修饰**和**符号改编**。

**函数签名**包含了一个函数的信息，包括函数名，参数类型，所在类和名称空间等信息。它用于识别不同的函数。在编译器和链接器处理符号时，使用某种名称修饰的方法，是的每个函数签名对应一个**修饰后名称**。