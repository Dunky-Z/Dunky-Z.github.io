---
title: Linux操作系统笔记
date: 2021-07-11 09:09:53
tags:
---

# Linux操作系统学习笔记
## Linux操作系统综述
### 系统调用
#### 创建进程`fork`
在 Linux 里，要创建一个新的进程，需要一个老的进程调用 `fork` 来实现，其中老的进程叫作`父进程`（Parent Process），新的进程叫作`子进程`（Child Process）。为啥叫`fork`（分支），因为Linux 当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。如果当前进程是父进程，就接着做之前的事，如果是子进程就调用`execve`来执行另一个程序，这时候子进程就和父进程彻底分离，也就产生了一个分支(fork)。

#### `waitpid`查看子进程运行情况
父进程可以调用`waitpid`查看子进程是否运行完成，成功与否


#### 内存管理`brk`和`mmap`
每个进程都有自己的内存，互相之间不干扰，叫做`进程内存空间`，里面存放`代码段`(code segment)和`数据段`(data segment)。数据段中局部变量部分只有在函数执行时才起作用，当进入另一个函数时就会被释放，也有动态分配的，保存时间较长，这部分叫做`堆`（heap）。

当分配的内存数量比较小的时候，使用 `brk`，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。当分配的内存数量比较大的时候，使用 `mmap`，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

```c
#include <unistd.h>
int brk(boid *addr)；
//addr:把内存末尾指针设置为addr.返回值：0表示成功，非0表示失败
void *sbrk(intptr_t increment);
//increment:把内存的末尾指针移动increment个字节。返回值：上次调用sbrk/brk的内存末尾指针。
#include <stdio.h>   
#include <unistd.h>   
int main()  
{  
    void* p = sbrk(0);  
    int* p1 = p;  
    brk(p1+4);//分配了16个字节的空间   
    p1[0] = 10;  
    p1[1] = 20;  
    p1[2] = 30;  
    p1[3] = 40;  
    p1[4] = 50;  
    int* p2 = sbrk(4);  
    printf("*p2=%d\n", *p2);  
    brk(p1+1024);//分配整个页面的空间   
    brk(p1+512);//释放一半空间   
    brk(p1);//释放所有空间   
}  
```

#### 创建、打开、读写、跳转文件
`open`打开文件
`close`关闭文件
`creat`创建文件
`lseek`跳转到文件某位置
`read`读取文件
`write`写入文件

#### 进程间通信
当进程之间交互的信息较小时，使用`消息队列`(message queue)
`msgget`创建新的消息队列
`msgsnd`将消息发送到消息队列
`msgrcv`从消息队列中取消息
当进程之间交互的信息较大时，使用`共享内存`
`shmget`创建一个共享内存块
`shmat`将共享内存映射到自己的内存空间
进程之间通信共享数据就会存在竞争的问题，如果同时修改同一块数据就会出问题，这就有了`信号量`机制(semaphore)
对于只允许一个进程访问的需求，我们可以将信号量设为 `1`。当一个进程要访问的时候，先调用`sem_wait`。如果这时候没有进程访问，则占用这个信号量，他就可以开始访问了。如果这个时候另一个进程要访问，也会调用 `sem_wait`。由于前一个进程已经在访问了，所以后面这个进程就必须等待上一个进程访问完之后才能访问。当上一个进程访问完毕后，会调用`sem_post`将信号量释放，于是下一个进程等待结束，可以访问这个资源了。

#### 不同机器之间的通信 `sorket`
不同机器的通过网络相互通信，要遵循相同的网络协议，也即`TCP/IP` 网络协议栈。网络服务是通过套接字 `Socket` 来提供服务的。`Socket` 这个名字很有意思，可以作“插口”或者“插槽”讲。虽然我们是写软件程序，但是你可以想象成弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。因此，在通信之前，双方都要建立一个 `Socket`。

#### 用户友好的系统调用库Glibc
`Glibc 是` Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。`Glibc` 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。
每个特定的系统调用对应了至少一个 `Glibc` 封装的库函数，比如说，系统提供的打开文件系统调用 `sys_open` 对应的是 `Glibc `中的 `open` 函数。
有时候，`Glibc` 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 printf 函数就会调用如 `sys_open`、`sys_mmap`、`sys_write`、`sys_close` 等等系统调用。
也有时候，多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 `malloc`、`calloc`、`free` 等函数用来分配和释放内存，都利用了内核的 `sys_brk` 的系统调用。


## 系统初始化
### x86架构概述
**CPU（Central Processing Unit）**：中央处理器，计算机所有设备都围绕它展开工作。
- 运算单元：只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。
- 数据单元：运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了数据单元。数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。
- 控制单元：有了放数据的地方，也有了算的地方，还需要有个指挥到底做什么运算的地方，这就是控制单元。控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。

**内存（Memory）**：CPU本身不能保存大量数据，许多复杂的计算需要将中间结果保存下来就必须用到内存。

**总线（Bus）**：CPU 和其他设备连接，就靠总线，其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。
- 地址总线：传输地址数据（我想拿内存中哪个位置的数据）
- 数据总线：传输真正的数据

总线就像CPU和内存之间的高速公路，总线多少位就类似高速公路多少个车道，但两种总线的位数意义不同。
地址总线的位数决定了访问地址范围有多广，数据总线位数决定了一次能拿多少数据进来。那么 CPU中总线的位数有没有标准呢？如果没有标准，那操作系统作为软件就很难办了，因为软件层没办法实现通用的运算逻辑。早期每家公司的CPU架构都不同，后来历史将x86平台推到了**开放，统一，兼容**的位置。

#### 8086架构图
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210721092854.png)

**数据单元：** 8086处理器内部共有8 个 16 位的通用寄存器，分别是 AX、BX、CX、DX、SP、BP、SI、DI。其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。

**控制单元：** IP 寄存器（Instruction Pointer Register）就是指令指针寄存器，它指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。

如果需要切换进程呢？每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS、DS、SS、ES。

其中，**CS** 就是代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置；**DS** 是数据段的寄存器（Data Segment Register），通过它可以找到数据在内存中的位置。**SS** 是栈寄存器（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则。**ES**是扩展段寄存器（Extra Segment Register）顾名思义。

如果CPU运算中需要加载内存中的数据，需要通过 DS 找到内存中的数据，加载到通用寄存器中，应该如何加载呢？对于一个段，有一个起始的地址，而段内的具体位置，我们称为**偏移量（Offset）**。在 CS 和 DS 中都存放着一个段的起始地址。**代码段的偏移量在 IP 寄存器中**，**数据段的偏移量会放在通用寄存器中**。因为段寄存器都是16位的，而地址总线是20位的，所以通过 **起始地址 \*16+ 偏移量** 的方式，将寻址位数都变成20位，也就是将CS和DS的值左移4位。

对于只有20位地址总线的8086来说，寻址空间最大也就是$2^{20}=1\text{M}$，超过这个位置就访问不到了，一个段因为偏移量只有16位，所以一个段最大是$2^{16}=64\text{k}$。

#### 32位处理器
随着计算机发展，内存越来越大，总线也越来越宽。在 32 位处理器中，有 32 根地址总线，可以访问 $2^{32}=4\text{G}$ 的内存。使用原来的模式肯定不行了，但是又不能完全抛弃原来的模式，因为这个架构是**开放的**。那么在开发架构的基础上如何保持兼容呢？

首先，通用寄存器有扩展，可以将 8 个 16 位的扩展到 8 个 32 位的，但是依然可以保留 16 位的和 8 位的使用方式。其中，指向下一条指令的指令指针寄存器 IP，就会扩展成 32 位的，同样也兼容 16 位的。

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210721103205.png)


段寄存器改动较大，新的段寄存器都改成了32位的，每个寄存器又分为**段描述符缓存器（Segment Descriptor）**，和**段选择子寄存器（Selector）** ,现在的段寄存器不在是段的起始地址，段的起始地址保存在表格一样的段描述符缓冲器中，段选择子寄存器保存地址在段描述符缓存器中的哪一项。这样，将一个从段寄存器直接拿到的段起始地址，就变成了**先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。**

虽然现在的这种模式和之前的模式不兼容，但是后面这种模式灵活的非常高，可以保持一直兼容下去。在32位的系统架构下，将前一种模式称为**实模式（Real Pattern）**，后一种模式称为**保护模式（Protected Pattern）** 。当系统刚刚启动的时候，CPU 是处于实模式的，这个时候和原来的模式是兼容的。也就是说，哪怕你买了 32 位的 CPU，也支持在原来的模式下运行。

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210721104550.png)

> 汇编命令学习
> mov,
> call, jmp, int, ret, add, or, xor, shl, shr, push, pop, inc, dec, sub, cmp。


























## 进程管理


## 虚拟化
### 虚拟机
