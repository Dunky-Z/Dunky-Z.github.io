---
title: Linux操作系统笔记
date: 2021-07-11 09:09:53
tags:
---

# Linux操作系统学习笔记
## Linux操作系统综述
### 系统调用
#### 创建进程`fork`
在 Linux 里，要创建一个新的进程，需要一个老的进程调用 `fork` 来实现，其中老的进程叫作`父进程`（Parent Process），新的进程叫作`子进程`（Child Process）。为啥叫`fork`（分支），因为Linux 当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。如果当前进程是父进程，就接着做之前的事，如果是子进程就调用`execve`来执行另一个程序，这时候子进程就和父进程彻底分离，也就产生了一个分支(fork)。

#### `waitpid`查看子进程运行情况
父进程可以调用`waitpid`查看子进程是否运行完成，成功与否


#### 内存管理`brk`和`mmap`
每个进程都有自己的内存，互相之间不干扰，叫做`进程内存空间`，里面存放`代码段`(code segment)和`数据段`(data segment)。数据段中局部变量部分只有在函数执行时才起作用，当进入另一个函数时就会被释放，也有动态分配的，保存时间较长，这部分叫做`堆`（heap）。

当分配的内存数量比较小的时候，使用 `brk`，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。当分配的内存数量比较大的时候，使用 `mmap`，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

```c
#include <unistd.h>
int brk(boid *addr)；
//addr:把内存末尾指针设置为addr.返回值：0表示成功，非0表示失败
void *sbrk(intptr_t increment);
//increment:把内存的末尾指针移动increment个字节。返回值：上次调用sbrk/brk的内存末尾指针。
#include <stdio.h>   
#include <unistd.h>   
int main()  
{  
    void* p = sbrk(0);  
    int* p1 = p;  
    brk(p1+4);//分配了16个字节的空间   
    p1[0] = 10;  
    p1[1] = 20;  
    p1[2] = 30;  
    p1[3] = 40;  
    p1[4] = 50;  
    int* p2 = sbrk(4);  
    printf("*p2=%d\n", *p2);  
    brk(p1+1024);//分配整个页面的空间   
    brk(p1+512);//释放一半空间   
    brk(p1);//释放所有空间   
}  
```

#### 创建、打开、读写、跳转文件
`open`打开文件
`close`关闭文件
`creat`创建文件
`lseek`跳转到文件某位置
`read`读取文件
`write`写入文件

#### 进程间通信
当进程之间交互的信息较小时，使用`消息队列`(message queue)
`msgget`创建新的消息队列
`msgsnd`将消息发送到消息队列
`msgrcv`从消息队列中取消息
当进程之间交互的信息较大时，使用`共享内存`
`shmget`创建一个共享内存块
`shmat`将共享内存映射到自己的内存空间
进程之间通信共享数据就会存在竞争的问题，如果同时修改同一块数据就会出问题，这就有了`信号量`机制(semaphore)
对于只允许一个进程访问的需求，我们可以将信号量设为 `1`。当一个进程要访问的时候，先调用`sem_wait`。如果这时候没有进程访问，则占用这个信号量，他就可以开始访问了。如果这个时候另一个进程要访问，也会调用 `sem_wait`。由于前一个进程已经在访问了，所以后面这个进程就必须等待上一个进程访问完之后才能访问。当上一个进程访问完毕后，会调用`sem_post`将信号量释放，于是下一个进程等待结束，可以访问这个资源了。

#### 不同机器之间的通信 `sorket`
不同机器的通过网络相互通信，要遵循相同的网络协议，也即`TCP/IP` 网络协议栈。网络服务是通过套接字 `Socket` 来提供服务的。`Socket` 这个名字很有意思，可以作“插口”或者“插槽”讲。虽然我们是写软件程序，但是你可以想象成弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。因此，在通信之前，双方都要建立一个 `Socket`。

#### 用户友好的系统调用库Glibc
`Glibc 是` Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。`Glibc` 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。
每个特定的系统调用对应了至少一个 `Glibc` 封装的库函数，比如说，系统提供的打开文件系统调用 `sys_open` 对应的是 `Glibc `中的 `open` 函数。
有时候，`Glibc` 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 printf 函数就会调用如 `sys_open`、`sys_mmap`、`sys_write`、`sys_close` 等等系统调用。
也有时候，多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 `malloc`、`calloc`、`free` 等函数用来分配和释放内存，都利用了内核的 `sys_brk` 的系统调用。


## 系统初始化
### x86架构概述
**CPU（Central Processing Unit）**：中央处理器，计算机所有设备都围绕它展开工作。
- 运算单元：只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。
- 数据单元：运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了数据单元。数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。
- 控制单元：有了放数据的地方，也有了算的地方，还需要有个指挥到底做什么运算的地方，这就是控制单元。控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。

**内存（Memory）**：CPU本身不能保存大量数据，许多复杂的计算需要将中间结果保存下来就必须用到内存。

**总线（Bus）**：CPU 和其他设备连接，就靠总线，其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。
- 地址总线：传输地址数据（我想拿内存中哪个位置的数据）
- 数据总线：传输真正的数据

总线就像CPU和内存之间的高速公路，总线多少位就类似高速公路多少个车道，但两种总线的位数意义不同。
地址总线的位数决定了访问地址范围有多广，数据总线位数决定了一次能拿多少数据进来。那么 CPU中总线的位数有没有标准呢？如果没有标准，那操作系统作为软件就很难办了，因为软件层没办法实现通用的运算逻辑。早期每家公司的CPU架构都不同，后来历史将x86平台推到了**开放，统一，兼容**的位置。




## 进程管理
