---
title: Linux操作系统笔记
date: 2021-07-11 09:09:53
tags:
---

# Linux操作系统学习笔记
## Linux操作系统综述
### 系统调用
#### 创建进程`fork`
在 Linux 里，要创建一个新的进程，需要一个老的进程调用 `fork` 来实现，其中老的进程叫作`父进程`（Parent Process），新的进程叫作`子进程`（Child Process）。为啥叫`fork`（分支），因为Linux 当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。如果当前进程是父进程，就接着做之前的事，如果是子进程就调用`execve`来执行另一个程序，这时候子进程就和父进程彻底分离，也就产生了一个分支(fork)。

#### `waitpid`查看子进程运行情况
父进程可以调用`waitpid`查看子进程是否运行完成，成功与否


#### 内存管理`brk`和`mmap`
每个进程都有自己的内存，互相之间不干扰，叫做`进程内存空间`，里面存放`代码段`(code segment)和`数据段`(data segment)。数据段中局部变量部分只有在函数执行时才起作用，当进入另一个函数时就会被释放，也有动态分配的，保存时间较长，这部分叫做`堆`（heap）。

当分配的内存数量比较小的时候，使用 `brk`，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。当分配的内存数量比较大的时候，使用 `mmap`，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

```c
#include <unistd.h>
int brk(void *addr); 
//addr:把内存末尾指针设置为addr.返回值：0表示成功，非0表示失败
void *sbrk(intptr_t increment);
//increment:把内存的末尾指针移动increment个字节。返回值：上次调用sbrk/brk的内存末尾指针。
#include <stdio.h>   
#include <unistd.h>   
int main()  
{  
    void* p = sbrk(0);  
    int* p1 = p;  
    brk(p1+4);//分配了16个字节的空间   
    p1[0] = 10;  
    p1[1] = 20;  
    p1[2] = 30;  
    p1[3] = 40;  
    p1[4] = 50;  
    int* p2 = sbrk(4);  
    printf("*p2=%d\n", *p2);  
    brk(p1+1024);//分配整个页面的空间   
    brk(p1+512);//释放一半空间   
    brk(p1);//释放所有空间   
}  
```

#### 创建、打开、读写、跳转文件
`open`打开文件
`close`关闭文件
`creat`创建文件
`lseek`跳转到文件某位置
`read`读取文件
`write`写入文件

#### 进程间通信
当进程之间交互的信息较小时，使用`消息队列`(message queue)
`msgget`创建新的消息队列
`msgsnd`将消息发送到消息队列
`msgrcv`从消息队列中取消息
当进程之间交互的信息较大时，使用`共享内存`
`shmget`创建一个共享内存块
`shmat`将共享内存映射到自己的内存空间
进程之间通信共享数据就会存在竞争的问题，如果同时修改同一块数据就会出问题，这就有了`信号量`机制(semaphore)
对于只允许一个进程访问的需求，我们可以将信号量设为 `1`。当一个进程要访问的时候，先调用`sem_wait`。如果这时候没有进程访问，则占用这个信号量，他就可以开始访问了。如果这个时候另一个进程要访问，也会调用 `sem_wait`。由于前一个进程已经在访问了，所以后面这个进程就必须等待上一个进程访问完之后才能访问。当上一个进程访问完毕后，会调用`sem_post`将信号量释放，于是下一个进程等待结束，可以访问这个资源了。

#### 不同机器之间的通信 `socket`
不同机器的通过网络相互通信，要遵循相同的网络协议，也即`TCP/IP` 网络协议栈。网络服务是通过套接字 `Socket` 来提供服务的。`Socket` 这个名字很有意思，可以作“插口”或者“插槽”讲。虽然我们是写软件程序，但是你可以想象成弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。因此，在通信之前，双方都要建立一个 `Socket`。

#### 用户友好的系统调用库`Glibc`
`Glibc 是` Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。`Glibc` 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。
每个特定的系统调用对应了至少一个 `Glibc` 封装的库函数，比如说，系统提供的打开文件系统调用 `sys_open` 对应的是 `Glibc `中的 `open` 函数。
有时候，`Glibc` 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 printf 函数就会调用如 `sys_open`、`sys_mmap`、`sys_write`、`sys_close` 等等系统调用。
也有时候，多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 `malloc`、`calloc`、`free` 等函数用来分配和释放内存，都利用了内核的 `sys_brk` 的系统调用。


## 系统初始化
### x86架构概述
**CPU（Central Processing Unit）**：中央处理器，计算机所有设备都围绕它展开工作。
- 运算单元：只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。
- 数据单元：运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了数据单元。数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。
- 控制单元：有了放数据的地方，也有了算的地方，还需要有个指挥到底做什么运算的地方，这就是控制单元。控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。

**内存（Memory）**：CPU本身不能保存大量数据，许多复杂的计算需要将中间结果保存下来就必须用到内存。

**总线（Bus）**：CPU 和其他设备连接，就靠总线，其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。
- 地址总线：传输地址数据（我想拿内存中哪个位置的数据）
- 数据总线：传输真正的数据

总线就像CPU和内存之间的高速公路，总线多少位就类似高速公路多少个车道，但两种总线的位数意义不同。
地址总线的位数决定了访问地址范围有多广，数据总线位数决定了一次能拿多少数据进来。那么 CPU中总线的位数有没有标准呢？如果没有标准，那操作系统作为软件就很难办了，因为软件层没办法实现通用的运算逻辑。早期每家公司的CPU架构都不同，后来历史将x86平台推到了**开放，统一，兼容**的位置。

#### 8086架构图
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210721092854.png)

**数据单元：** 8086处理器内部共有8 个 16 位的通用寄存器，分别是 数据寄存器（AX、BX、CX、DX）、指针寄存器（SP、BP）、变址寄存器（SI、DI）。其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。

**控制单元：** IP 寄存器（Instruction Pointer Register）就是指令指针寄存器，它指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。

如果需要切换进程呢？每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS、DS、SS、ES。

其中，**CS** 就是代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置；**DS** 是数据段的寄存器（Data Segment Register），通过它可以找到数据在内存中的位置。**SS** 是栈寄存器（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则。**ES**是扩展段寄存器（Extra Segment Register）顾名思义。

如果CPU运算中需要加载内存中的数据，需要通过 DS 找到内存中的数据，加载到通用寄存器中，应该如何加载呢？对于一个段，有一个起始的地址，而段内的具体位置，我们称为**偏移量（Offset）**。在 CS 和 DS 中都存放着一个段的起始地址。**代码段的偏移量在 IP 寄存器中**，**数据段的偏移量会放在通用寄存器中**。因为段寄存器都是16位的，而地址总线是20位的，所以通过 **起始地址 \*16+ 偏移量** 的方式，将寻址位数都变成20位，也就是将CS和DS的值左移4位。

对于只有20位地址总线的8086来说，寻址空间最大也就是$2^{20}=1\text{M}$，超过这个位置就访问不到了，一个段因为偏移量只有16位，所以一个段最大是$2^{16}=64\text{k}$。

#### 32位处理器
随着计算机发展，内存越来越大，总线也越来越宽。在 32 位处理器中，有 32 根地址总线，可以访问 $2^{32}=4\text{G}$ 的内存。使用原来的模式肯定不行了，但是又不能完全抛弃原来的模式，因为这个架构是**开放的**。那么在开发架构的基础上如何保持兼容呢？

首先，通用寄存器有扩展，可以将 8 个 16 位的扩展到 8 个 32 位的，但是依然可以保留 16 位的和 8 位的使用方式。其中，指向下一条指令的指令指针寄存器 IP，就会扩展成 32 位的，同样也兼容 16 位的。

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210721103205.png)


段寄存器改动较大，新的段寄存器都改成了32位的，每个寄存器又分为**段描述符缓存器（Segment Descriptor）**，和**段选择子寄存器（Selector）** ,现在的段寄存器不在是段的起始地址，段的起始地址保存在表格一样的段描述符缓冲器中，段选择子寄存器保存地址在段描述符缓存器中的哪一项。这样，将一个从段寄存器直接拿到的段起始地址，就变成了**先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。**

虽然现在的这种模式和之前的模式不兼容，但是后面这种模式灵活的非常高，可以保持一直兼容下去。在32位的系统架构下，将前一种模式称为**实模式（Real Pattern）**，后一种模式称为**保护模式（Protected Pattern）** 。当系统刚刚启动的时候，CPU 是处于实模式的，这个时候和原来的模式是兼容的。也就是说，哪怕你买了 32 位的 CPU，也支持在原来的模式下运行。

![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210721104550.png)

> 汇编命令学习
> mov,
> call, jmp, int, ret, add, or, xor, shl, shr, push, pop, inc, dec, sub, cmp。


### BIOS与BootLoader

BIOS： 基本输入输出系统
ROM： 只读存储器
RAM：随机存取存储器

在我们按下电脑电源键的那一刻，主板就加电了，CPU就要开始执行指令了，但是刚开始操作系统都没，CPU执行什么指令呢？这就有了`BIOS`，它相当于一个指导手册，告诉CPU接下来要干啥。

刚开机时，系统初始化代码从ROM读取，将 `CS` 设置为 `0xFFFF`，将 `IP` 设置为 `0x0000`，所以第一条指令就会指向 `0xFFFF0`，初始化完成后确定访问指令位置。

接下来BIOS会检查各个硬件是否正常，检测内容显卡等关键部件的存在于工作状态，设备初始化，执行系统BIOS进行系统检测，更新CMOS中的扩展系统配置数据ESCD。这期间也会建立中断向量表和中断服务程序，因为要使用键盘鼠标都需要中断进行。

下一步BIOS就得要找操作系统了，操作系统一般安装在硬盘上，但是BIOS得先找到启动盘，启动盘一般安装在第一个扇区，占512字节，会包含启动的相关代码。在Linux中，可以通过`Grub2`配置这些代码。
```
grub2-mkconfig -o /boot/grub2/grub.cfg
```
`grub2 `第一个要安装的就是` boot.img`。它由 `boot.S `编译而成，一共 `512` 字节，正式安装到启动盘的第一个扇区。这个扇区通常称为`MBR`（Master Boot Record，主引导记录 / 扇区）。

`BIOS` 完成任务后，会将 `boot.img` 从硬盘加载到内存中的 `0x7c00 `来运行。

由于 `512` 个字节实在有限，`boot.img` 做不了太多的事情。它能做的最重要的一个事情就是加载` grub2` 的另一个镜像 `core.img`。

`core.img` 由` lzma_decompress.img`、`diskboot.img`、`kernel.img` 和一系列的模块组成，功能比较丰富，能做很多事情。


`boot.img` 先加载的是 `core.img` 的第一个扇区。如果从硬盘启动的话，这个扇区里面是` diskboot.img`，对应的代码是 `diskboot.S`。

`boot.img` 将控制权交给 `diskboot.img` 后，`diskboot.img` 的任务就是将` core.img` 的其他部分加载进来，先是解压缩程序 `lzma_decompress.img`，再往下是 `kernel.img`，最后是各个模块` module `对应的映像。这里需要注意，它不是 Linux 的内核，而是` grub` 的内核。

在这之前，我们所有遇到过的程序都非常非常小，完全可以在实模式下运行，但是随着我们加载的东西越来越大，实模式这`1M` 的地址空间实在放不下了，所以在真正的解压缩之前，`lzma_decompress.img` 做了一个重要的决定，就是调用 `real_to_prot`，切换到**保护模式**，这样就能在更大的寻址空间里面，加载更多的东西。

`BIOS`将加载程序从硬盘的引导扇区加载到指定位置，再跳转到指定位置，将控制权转交给加载程序。加载程序将操作系统代码读取到内存，并将控制权转到操作系统。

>Q：BIOS-操作系统，中间经过加载程序。为何不直接读取？
A：磁盘文件系统多种多样，硬盘出厂时不能限制只能用一种文件系统，而BIOS也不能加上识别所有文件系统的代码。所有为了灵活性只读取磁盘的一块，由加载程序来识别磁盘的文件系统。


切换到保护模式后，将会做以下这些事，大多数都与内存访问方式有关。

首先**启动分段**，就是在内存里面**建立段描述符表**，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。

接着是**启动分页**。能够管理的内存变大了，就需要将内存分成相等大小的块。

**打开Gate20**，也就是第21根地址线的控制线。因为在实模式8086下，一共就20根地址线，最大访问`1M`的地址空间。切换保护模式的函数`DATA32 call real_to_prot `会打开`Gate A20`。

现在好了，有的是空间了。接下来我们要对压缩过的 **kernel.img 进行解压缩**，然后跳转到 `kernel.img` 开始运行。


### 内核初始化

### 系统调用












## 进程管理


## 虚拟化
### 虚拟机

#### QEMU工作原理
![](https://gitee.com/dominic_z/markdown_picbed/raw/master/img/20210721140349.png)
单纯使用 qemu，采用的是完全虚拟化的模式。qemu 向 Guest OS 模拟 CPU，也模拟其他的硬件，GuestOS 认为自己和硬件直接打交道，其实是同 qemu 模拟出来的硬件打交道，qemu 会将这些指令转译给真正的硬件。由于所有的指令都要从 qemu 里面过一手，因而性能就会比较差。

完全虚拟化是非常慢的，所以要使用硬件辅助虚拟化技术 Intel-VT，AMD-V，所以需要 CPU 硬件开启这个标志位，一般在 BIOS 里面设置。当确认开始了标志位之后，通过 KVM，GuestOS 的 CPU 指令不用经过 Qemu 转译，直接运行，大大提高了速度。所以，KVM 在内核里面需要有一个模块，来设置当前 CPU 是 Guest OS 在用，还是 Host OS 在用。

可以通过如下命令查看内核模块中是否有KVM
```
lsmod | grep kvm
```
KVM 内核模块通过 `/dev/kvm` 暴露接口，用户态程序可以通过 `ioctl`来访问这个接口。Qemu 将 KVM 整合进来，将有关 CPU 指令的部分交由内核模块来做，就是 qemu-kvm (qemu-system-XXX)。

qemu 和 kvm 整合之后，CPU 的性能问题解决了。另外 Qemu 还会模拟其他的硬件，如网络和硬盘。同样，全虚拟化的方式也会影响这些设备的性能。

于是，qemu 采取半虚拟化的方式，让 Guest OS 加载特殊的驱动来做这件事情。

例如，网络需要加载 `virtio_net`，存储需要加载 `virtio_blk`，Guest 需要安装这些半虚拟化驱动，GuestOS 知道自己是虚拟机，所以数据会直接发送给半虚拟化设备，经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。

### 计算虚拟化之CPU

### 计算虚拟化之内存