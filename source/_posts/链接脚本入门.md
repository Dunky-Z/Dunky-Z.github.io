---
title: 链接脚本入门
date: 2022-05-08 21:32:23
updated:
tags: [链接, 编译, 动态链接]
categories:
---

运行时的地址是由运行时决定的（编译链接时是无法绝对确定运行时地址的）。

链接地址是由程序员在编译链接的过程中，通过Makefile中-Ttext xxx或者在链接脚本中指定的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。

举例：
1、linux中的应用程序。`gcc hello.c -o hello`，这时使用默认的链接地址就是`0x0`，所以应用程序都是链接在0地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享4G的虚拟地址空间。所以应用程序都可以链接到0地址，因为每个进程都是从0地址开始的。（编译时可以不给定链接地址而都使用`0x0`）
2、210中的裸机程序。运行地址由我们下载时确定，下载时下载到`0xd0020010`，所以就从这里开始运行。（这个下载地址也不是我们随意定的，是iROM中的BL0加载BL1时事先指定好的地址，这是由CPU的设计决定的）。所以理论上我们编译链接时应该将地址指定到`0xd0020010`，但是实际上我们在之前裸机程序中都是使用位置无关码PIC，所以链接地址可以是0。


长跳转：一种跳转指令，类似于分支指令B，BL等作用的指令，跳转指令通过给PC（r15）赋一个新值来完成代码跳转。当我们执行完重定位后，实际上SRAM中有两份代码的镜像（一份是我们下载到0xd0020010处的，一份是重定位到0xd0024000处的），这两份代码内容完全相同。

当链接地址和运行地址相同是，短跳转和长跳转实际效果一样。但是当链接地址和运行地址不同时，短跳转和长跳转就有差异了，这时候段跳转执行的是运行地址处的那一份，而长跳转执行的是链接地址的那一份。

adr与ldr伪指令的区别：
ldr和adr都是伪指令，区别是ldr是长加载、adr是短加载。
重点：adr指令加载符号地址，加载的是运行时地址；ldr指令在加载符号地址时，加载的是链接地址。





## 实例

通过链接脚本，将代码链接到`0xd002400`：
```
SECTIONS
{
	. = 0xd0024000;
	
	.text : {
		start.o
		* (.text)
	}
    		
	.data : {
		* (.data)
	}
	
	bss_start = .; 
	.bss : {
		* (.bss)
	}
	
	bss_end  = .;	
}
```
