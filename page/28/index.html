<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.131.0"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8888&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>PaperMod</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:8888/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:8888/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:8888/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:8888/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:8888/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:8888/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:8888/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:8888/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:8888/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:8888/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:8888/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:8888/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">CPU 亲和性与中断亲和性
    </h2>
  </header>
  <div class="entry-content">
    <p>预备知识 超线程技术 (Hyper-Threading)：就是利用特殊的硬件指令，把两个逻辑内核 (CPU core) 模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了 CPU 的闲置时间，提高的 CPU 的运行效率。
我们常听到的双核四线程/四核八线程指的就是支持超线程技术的CPU.
物理 CPU：机器上安装的实际 CPU, 比如说你的主板上安装了一个 8 核 CPU，那么物理 CPU 个数就是 1 个，所以物理 CPU 个数就是主板上安装的 CPU 个数。
逻辑 CPU：一般情况，我们认为一颗 CPU 可以有多核，加上 Intel 的超线程技术 (HT), 可以在逻辑上再分一倍数量的 CPU core 出来；
逻辑CPU数量 = 物理CPU数量 x CPU cores x 2(如果支持并开启HT) //前提是CPU的型号一致，如果不一致只能一个一个的加起来，不用直接乘以物理CPU数量//比如你的电脑安装了一块4核CPU，并且支持且开启了超线程（HT）技术，那么逻辑CPU数量 = 1 × 4 × 2 = 8 Linux 下查看 CPU 相关信息, CPU 的信息主要都在/proc/cupinfo中。
# 查看物理CPU个数➜ ~ cat /proc/cpuinfo|grep &#34;physical id&#34;|sort -u|wc -l32# 查看每个物理CPU中core的个数(即核数)➜ ~ cat /proc/cpuinfo|grep &#34;cpu cores&#34;|uniq1# 或者➜ cat /proc/cpuinfo | grep &#39;process&#39; | sort | uniq | wc -l1# 查看逻辑CPU的个数➜ ~ cat /proc/cpuinfo|grep &#34;processor&#34;|wc -l32# 查看CPU的名称型号➜ ~ cat /proc/cpuinfo|grep &#34;name&#34;|cut -f2 -d:|uniqIntel Xeon Processor (Skylake, IBRS) Linux 查看某个进程运行在哪个逻辑 CPU 上...</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-23 22:38:14 +0000 UTC'>May 23, 2022</span>&nbsp;·&nbsp;10 min</footer>
  <a class="entry-link" aria-label="post link to CPU 亲和性与中断亲和性" href="http://localhost:8888/posts/cpu%E4%BA%B2%E5%92%8C%E6%80%A7%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%BA%B2%E5%92%8C%E6%80%A7/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">SoC 存储器比较
    </h2>
  </header>
  <div class="entry-content">
    <p>内存 也就是内部存储器，主要用来运行程序的，典型的就是 RAM 随机存储器（Random Access Memory），那么随机是什么意思？所谓随机，指的是当存储器中的数据被读取或写入时，所需要的时间与这段信息所在的位置无关（任何位置读写速度一样）。
DRAM（Dynamic Random Access Memory，动态随机存储器）是最为常见的系统内存。我们使用的电脑和手机的运行内存都是 DRAM。DRAM 使用电容存储，DRAM 只能将数据保持很短的时间。为了保持数据，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。数据的存储，请参考数据存储模型。我们知道，电容中的电荷很容易变化，所以随着时间推移，电容中的电荷数会增加或减少，为了确保数据不会丢失，DRAM 每隔一段时间会给电容刷新（充电或放电）。动态：定时刷新数据
SRAM（Static Random Access Memory，静态随机存储器），它是一种具有静止存取功能的内存，其内部机构比 DRAM 复杂，可以做到不刷新电路即能保存它内部存储的数据。静态：不需要刷新
DDR SDRAM（Double Data Rate SDRAM）：为双信道同步动态随机存取内存，是新一代的 SDRAM 技术。DDR 内存芯片的数据预取宽度（Prefetch）为 2 bit（SDRAM 的两倍）。
DDR2 SDRAM（Double Data Rate Two SDRAM）：为双信道两次同步动态随机存取内存。DDR2 内存 Prefetch 又再度提升至 4 bit（DDR 的两倍）
DDR3 SDRAM（Double Data Rate Three SDRAM）：为双信道三次同步动态随机存取内存。DDR3 内存 Prefetch 提升至 8 bit，即每次会存取 8 bits 为一组的数据。运算频率介于 800MHz -1600MHz 之间。
外存 外部存储器，通常用来存储文件的，一般也叫 ROM（Read-only memory）只读存储器。
CPU 连接内存和外存的连接方式不同。内存需要直接地址访问，所以是通过地址总线&amp;数据总线的总线式访问方式连接的（好处是直接访问，随机访问；坏处是占用 CPU 的地址空间，大小受限）；外存是通过 CPU 的外存接口来连接的（好处是不占用 CPU 的地址空间，坏处是访问速度没有总线式快，访问时序较复杂）...</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-21 17:13:33 +0000 UTC'>May 21, 2022</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to SoC 存储器比较" href="http://localhost:8888/posts/soc%E5%AD%98%E5%82%A8%E5%99%A8%E6%AF%94%E8%BE%83/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Interlaken 协议
    </h2>
  </header>
  <div class="entry-content">
    <p>对 Interlaken 协议文档的翻译加了一些自己的理解；
8b/10b编码：在串行通道上传输时，将 8bits 数据编码为 10bits 数据，做一个转换，使各位数据之间有更多的 1 到 0 和 0 到 1 的跳变，以便接收设备检测这些跳变，能更容易地恢复时钟。64B/67B 编码编码的原因也是类似的。这样，在串行通道上传输 10 位数据，实际上只传输了 8 位。
协议层（Protocol Layer） 传输格式 数据通过可配置数量的 SerDes 通道（Lane），再由 Interlaken 接口传输。在本文档中，通道被定义为两个 IC 之间的单工串行链路（simplex serial link）。该协议旨在与任意数量的通道一起运行（1 个或多个，没有上限）。实际实现时会固定一个数值，不会设计为可变值。
接口发送数据的基本单位是一个 8 字节的字（Word）。用 8 字节是为了符合64B/67B 编码，用于描述突发（Burst）的控制字的大小也是 8 字节。通过使基本传输单元与控制字大小相等，可以很容易地调整接口的宽度。
数据和控制字按顺序在通道上传输，从通道 0 开始，到通道 M 结束，并在下一个数据块中重复。图 4 说明了该过程
64B/67B编码在每个通道上独立进行。传输通过两种基本数据类型实现：数据字和控制字，他们通过64B/67B 帧位（framing bits）进行区分。这两种数据字类型的格式如下图所示：
数据和控制信息都是以位 66～0 的顺序传输的，框架层引入了 4 个附加控制字，详细信息后面将描述。
Burst 结构（Burst Structure） 数据传输流程 Interlaken 接口的带宽在支持的通道上被划分为 Bursts。数据包通过一个或多个 Burst 在接口上传输。Burst 通过一个或多个控制字来描述。为了将任意大小的数据包分割成 Burst，定义以下两个参数：
BurstMax：Burst 的最大大小（64Bytes 的倍数） BurstShort：Burst 的最小大小（最小 32Bytes，增量为 8Bytes） 该接口通常通过发送一个 BurstMax 长度的数据突发来运行，然后是一个控制字。发送设备中的调度逻辑可以自由选择信道服务的顺序，受流控状态的约束。Burst 在每个通道上传输，直到数据包完全传输，此时该通道上的新数据包传输才开始。...</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-18 22:40:47 +0000 UTC'>May 18, 2022</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to Interlaken 协议" href="http://localhost:8888/posts/interlaken%E5%8D%8F%E8%AE%AE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">AMBA 总线协议-AXI 协议
    </h2>
  </header>
  <div class="entry-content">
    <p>AXI 组成部分：
AXI4 协议中包含五种信道，通道之间相互独立且存在差别，通过通道进行通信之前需要使用 VALID/READY 进行握手，Read 和 Write 根据 Master 定义：
读地址信道（Read Address Channel） 写地址信道（Write Address Channel） 读数据信道（Read Data Channel） 写数据信道（Write Data Channel） 写响应信道（Write Response Channel） 还有两种 Component
Master component Slave component 通信由 Master 发起，Master 可以对 Slave 进行读数据（read）或写（write）数据。每次读写操作都需要一个地址，读地址信道（Read Address Channel）和写地址信道（Write Address Channel）用于传输地址。在写完数据后，Master 需要确认 Slave 有没有收完数据，Slave 收到完整数据后，会通过写响应信道（Write Response Channel）给 Master 一个反馈（completion），表示写操作已经完成。
VALID/READY 握手机制 AXI 五个信道相互独立，但是使用同一个握手机制来实现信息传递。
在握手机制中，通信双方分别扮演发送方(Source) 和接收方（Destination），两者的操作（技能）并不相同。
发送方置高 VALID 信号表示发送方已经将数据，地址或者控制信息已经就绪，并保持于消息总线上。
接收方置高 READY 信号表示接收方已经做好接收的准备。
当双方的 VALID/READY 信号同时为高，在时钟 ACLK 上升沿，完成一次数据传输。所有数据传输完毕后，双方同时置低自己的信号。
每个通道都有自己的 VALID /READY 握手信号对：...</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-17 21:16:45 +0000 UTC'>May 17, 2022</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to AMBA 总线协议-AXI 协议" href="http://localhost:8888/posts/amba%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE-axi%E5%8D%8F%E8%AE%AE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">C 语言实现简单有限状态机
    </h2>
  </header>
  <div class="entry-content">
    <p>简介 常说的状态机是有限状态机 FSM，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。 三个特征：
状态总数（state）是有限的。 任一时刻，只处在一种状态之中。 某种条件下，会从一种状态转变（transition）到另一种状态。 设计状态机的关键点：当前状态、外部输入、下一个状态。
状态机分类 Moore 型状态机 Moore 型状态机特点是：输出只与当前状态有关（与输入信号无关）。相对简单，考虑状态机的下一个状态时只需要考虑它的当前状态就行了。
Mealy 型状态机 Mealy 型状态机的特点是：输出不只和当前状态有关，还与输入信号有关。状态机接收到一个输入信号需要跳转到下一个状态时，状态机综合考虑 2 个条件（当前状态、输入值）后才决定跳转到哪个状态。
实现一个简单的状态机 代码参考AstarLight/FSM-framework。
以小明的一天设计出一个状态机，下图为状态转移图：
首先，有限状态机的状态是有限的，我们可以定义一天中的状态：
enum { GET_UP, GO_TO_SCHOOL, HAVE_LUNCH, DO_HOMEWORK, SLEEP, }; 状态机在没有事件的驱动下就是一潭死水，所以我们还需要定义出一些会发生的事件，去驱动状态机的运转：
enum { EVENT1 = 1, EVENT2, EVENT3, }; 再定义一些在某个状态下需要处理的动作，也就是函数：
void GetUp() { // do something printf(&#34;xiao ming gets up!\n&#34;); } void Go2School() { // do something printf(&#34;xiao ming goes to school!\n&#34;); } void HaveLunch() { // do something printf(&#34;xiao ming has lunch!...</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-15 12:41:30 +0000 UTC'>May 15, 2022</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to C 语言实现简单有限状态机" href="http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:8888/page/27/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:8888/page/29/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:8888/">PaperMod</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
