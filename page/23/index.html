<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>如云泊</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">





    <meta property="og:type" content="website">
<meta property="og:title" content="如云泊">
<meta property="og:url" content="https://lifeislife.cn/page/23/index.html">
<meta property="og:site_name" content="如云泊">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Dominic">
<meta name="twitter:card" content="summary">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="../../css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-PS8L2EEEPR');
</script>


    


<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="如云泊" type="application/atom+xml">
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="../../index.html">
                
                <img src="../../images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="../../archives">Archives</a>
            
            <a class="navbar-item "
               href="../../about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" target="_blank" rel="noopener" href="https://github.com/Dunky-Z">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url">Linux 操作系统-内存管理</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-19T01:37:04.000Z" itemprop="datePublished">8月 19 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">Linux 操作系统</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            21 分钟 读完 (约 3109 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h2><p>计算机所谓的“计算”指的是：</p>
<ul>
<li>进程和线程对于 CPU 的使用</li>
<li>对内存的管理</li>
</ul>
<h3 id="独享内存空间的原理"><a href="#独享内存空间的原理" class="headerlink" title="独享内存空间的原理"></a>独享内存空间的原理</h3><p>每个进程都独享一段内存空间，并且真实物理内存地址对进程不可见，操作系统会给进程分配一个虚拟地址，每个进程看到的内存地址都是从 0 开始。操作系统会将不同进程的虚拟地址和不同内存的物理地址做映射。当程序访问虚拟地址时，由内核的数据结构进行转换，转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址。</p>
<h3 id="规划虚拟地址空间"><a href="#规划虚拟地址空间" class="headerlink" title="规划虚拟地址空间"></a>规划虚拟地址空间</h3><p>通过以上的原理，我们可以看出，操作系统的内存管理，主要分为三个方面。</p>
<ol>
<li>物理内存的管理；</li>
<li>虚拟地址的管理；</li>
<li>虚拟地址和物理地址如何映射；</li>
</ol>
<p>进程获取了一段独立的虚拟内存空间后，可以不用管其他进程，“任意”使用这片内存，但是也有一点规则。这篇内存需要存放内核态和用户态的内容。高地址存放内核态的内容，低地址存放用户态的内容。具体分界线 64 位与 32 位不同，暂不深究。</p>
<p>我们从最低位开始排起，先是<strong>Text Segment、Data Segment 和 BSS Segment</strong>。Text Segment 是存放二进制可执行代码的位置，Data Segment 存放静态常量，BSS Segment 存放未初始化的静态变量。是不是觉得这几个名字很熟悉？没错，咱们前面讲 ELF 格式的时候提到过，在二进制执行文件里面，就有这三个部分。这里就是把二进制执行文件的三个部分加载到内存里面。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129170110.png"></p>
<p>接下来是<strong>堆</strong>（Heap）<strong>段</strong>。堆是往高地址增长的，是用来动态分配内存的区域，<code>malloc</code> 就是在这里面分配的。<br>接下来的区域是<strong>Memory Mapping Segment</strong>。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将 so 文件映射到了内存中。<br>再下面就是<strong>栈</strong>（Stack）<strong>地址段</strong>。主线程的函数调用的函数栈就是用这里的。</p>
<p>普通进程不能访问内核空间，如果需要进行更高权限的工作，就需要系统调用进入内核。每一段进程的内存空间存放的内容各不相同，但是进入内核后看到的都是同一个内核空间，同一个进程列表。</p>
<p>内核的代码访问内核的数据结构，大部分的情况下都是使用虚拟地址的，虽然内核代码权限很大，但是能够使用的虚拟地址范围也只能在内核空间，也即内核代码访问内核数据结构。</p>
<p>接下来，我们需要知道，如何将其映射成为物理地址呢？</p>
<p>咱们前面讲 x86 CPU 的时候，讲过分段机制，咱们规划虚拟空间的时候，也是将空间分成多个段进行保存。我们来看看分段机制的原理。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129182908.png"></p>
<p>分段机制下的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。段选择子就保存在咱们前面讲过的段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。段表里面保存的是这个段的<strong>基地址</strong>、<strong>段的界限</strong>和<strong>特权等级</strong>等。虚拟地址中的段内偏移量应该位于 0 和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</p>
<p>例如，我们将上面的虚拟空间分成以下 4 个段，用 0～3 来编号。每个段在段表中有一个项，在物理空间中，段的排列如下图的右边所示。如果要访问段 2 中偏移量 600 的虚拟地址，我们可以计算出物理地址为，段 2 基地址 2000 + 偏移量 600 = 2600。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129183334.png"></p>
<p>在 Linux 里面，段表全称<strong>段描述符表</strong>（segment descriptors），放在<strong>全局描述符表 GDT</strong>（Global Descriptor Table）里面，会有下面的宏来初始化段描述符表里面的表项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GDT_ENTRY_INIT(flags, base, limit) &#123; &#123; &#123; \</span><br><span class="hljs-meta">    .a = ((limit) &amp; 0xffff) | (((base) &amp; 0xffff) &lt;&lt; 16), \</span><br><span class="hljs-meta">    .b = (((base) &amp; 0xff0000) &gt;&gt; 16) | (((flags) &amp; 0xf0ff) &lt;&lt; 8) | \</span><br><span class="hljs-meta">      ((limit) &amp; 0xf0000) | ((base) &amp; 0xff000000), \</span><br><span class="hljs-meta">  &#125; &#125; &#125;</span><br></code></pre></td></tr></table></figure>

<p>一个段表项由段基地址 base、段界限 limit，还有一些标识符组成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = &#123; .gdt = &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_X86_64</span><br>  [GDT_ENTRY_KERNEL32_CS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc09b</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_KERNEL_CS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xa09b</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_KERNEL_DS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc093</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER32_CS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0fb</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_DS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0f3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_CS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xa0fb</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  [GDT_ENTRY_KERNEL_CS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc09a</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_KERNEL_DS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc092</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_CS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0fa</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_DS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0f2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125; &#125;;<br>EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);<br></code></pre></td></tr></table></figure>

<p>这里面对于 64 位的和 32 位的，都定义了内核代码段、内核数据段、用户代码段和用户数据段。另外，还会定义下面四个段选择子，指向上面的段描述符表项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __KERNEL_CS      (GDT_ENTRY_KERNEL_CS*8)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __KERNEL_DS      (GDT_ENTRY_KERNEL_DS*8)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __USER_DS      (GDT_ENTRY_DEFAULT_USER_DS*8 + 3)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __USER_CS      (GDT_ENTRY_DEFAULT_USER_CS*8 + 3)</span><br></code></pre></td></tr></table></figure>

<p>通过分析，我们发现，所有的段的起始地址都是一样的，都是 0。所以，在 Linux 操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。<br>其实 Linux 倾向于另外一种从虚拟地址到物理地址的转换方式，称为<strong>分页</strong>（Paging）。对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以<strong>暂时写到硬盘上</strong>，称为<strong>换出</strong>。一旦需要的时候，再<strong>加载进来</strong>，叫作<strong>换入</strong>。这样可以扩大可用物理内存的大小，提高物理内存的利用率。</p>
<p>这个换入和换出都是以页为单位的。页面的大小一般为 4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129185728.png"></p>
<p>虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。</p>
<p>32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了。</p>
<p>页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。</p>
<p>那怎么办呢？我们可以试着将页表再分页，4G 的空间需要 4M 的页表来存储映射。我们把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K。</p>
<p>页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置。</p>
<p>这样加起来正好 32 位，也就是用前 10 位定位到页目录表中的一项。将这一项对应的页表取出来共 1k 项，再用中间 10 位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后 12 位定位到页中的具体位置访问数据。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129192245.png"></p>
<p>你可能会问，如果这样的话，映射 4GB 地址空间就需要 4MB+4KB 的内存，这样不是更大了吗？当然如果页是满的，当时是更大了，但是，我们往往不会为一个进程分配那么多内存。</p>
<p>比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省多了。</p>
<p>当然对于 64 位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。</p>
<h2 id="进程空间管理"><a href="#进程空间管理" class="headerlink" title="进程空间管理"></a>进程空间管理</h2><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><h2 id="用户态内存映射"><a href="#用户态内存映射" class="headerlink" title="用户态内存映射"></a>用户态内存映射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GDT_ENTRY_INIT(flags, base, limit) &#123; &#123; &#123; \</span><br><span class="hljs-meta">  .a = ((limit) &amp; 0xffff) | (((base) &amp; 0xffff) &lt;&lt; 16), \</span><br><span class="hljs-meta">  .b = (((base) &amp; 0xff0000) &gt;&gt; 16) | (((flags) &amp; 0xf0ff) &lt;&lt; 8) | \</span><br><span class="hljs-meta">    ((limit) &amp; 0xf0000) | ((base) &amp; 0xff000000), \</span><br><span class="hljs-meta">  &#125; &#125; &#125;</span><br></code></pre></td></tr></table></figure>

<p>通过分析，我们发现，所有的段的起始地址都是一样的，都是 0。这算哪门子分段嘛！所以，在 Linux 操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。</p>
<p>其实 Linux 倾向于另外一种从虚拟地址到物理地址的转换方式，称为分页（Paging）。</p>
<p>对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为换出。一旦需要的时候，再加载进来，叫作换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/18/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E4%BA%A4%E4%BA%92%E5%93%8D%E5%BA%94/" itemprop="url">Qt 模仿登录界面-交互响应</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-18T05:07:01.000Z" itemprop="datePublished">8月 18 2021</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            11 分钟 读完 (约 1655 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820152215.gif"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820152316.gif"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820153546.gif"></p>
<h2 id="设置窗口拖动"><a href="#设置窗口拖动" class="headerlink" title="设置窗口拖动"></a>设置窗口拖动</h2><p>因为这个项目中没有将登录界面直接继承<code>MainWindow</code>，而是继承的<code>Dialog</code>类，所以它是不能直接移动的，需要我们自己添加相应的方法。这里实现了三种方法，点击，拖动，释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//mytitlebar.cpp</span><br><span class="hljs-comment">// 以下通过 mousePressEvent、mouseMoveEvent、mouseReleaseEvent 三个事件实现了鼠标拖动标题栏移动窗口的效果;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (m_buttonType == MIN_MAX_BUTTON)<br> &#123;<br>  <span class="hljs-comment">// 在窗口最大化时禁止拖动窗口;</span><br>  <span class="hljs-keyword">if</span> (m_pButtonMax-&gt;<span class="hljs-built_in">isVisible</span>())<br>  &#123;<br>   m_isPressed = <span class="hljs-literal">true</span>;<br>   m_startMovePos = event-&gt;<span class="hljs-built_in">globalPos</span>();<br>  &#125;<br> &#125;<br> <span class="hljs-keyword">else</span><br> &#123;<br>  m_isPressed = <span class="hljs-literal">true</span>;<br>  m_startMovePos = event-&gt;<span class="hljs-built_in">globalPos</span>();<br> &#125;<br> <br> <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">mousePressEvent</span>(event);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::mouseMoveEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (m_isPressed &amp;&amp; m_isMoveParentWindow)<br> &#123;<br>  QPoint movePoint = event-&gt;<span class="hljs-built_in">globalPos</span>() - m_startMovePos;<br>  QPoint widgetPos = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">parentWidget</span>()-&gt;<span class="hljs-built_in">pos</span>() + movePoint;<br>  m_startMovePos = event-&gt;<span class="hljs-built_in">globalPos</span>();<br>  <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">parentWidget</span>()-&gt;<span class="hljs-built_in">move</span>(widgetPos.<span class="hljs-built_in">x</span>(), widgetPos.<span class="hljs-built_in">y</span>());<br> &#125;<br> <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">mouseMoveEvent</span>(event);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::mouseReleaseEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br> m_isPressed = <span class="hljs-literal">false</span>;<br> <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">mouseReleaseEvent</span>(event);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="globalPos-获取全局的坐标"><a href="#globalPos-获取全局的坐标" class="headerlink" title="globalPos()获取全局的坐标"></a><code>globalPos()</code>获取全局的坐标</h3><p><code>event-&gt;globalPos()</code>是获取全局的坐标，全局是相对于整个屏幕而言的。还有一个函数<code>pos()</code>获取的是局部坐标，相对于一个<code>widget</code>窗口而言。</p>
<h3 id="move-移动窗口"><a href="#move-移动窗口" class="headerlink" title="move()移动窗口"></a><code>move()</code>移动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QPoint &amp;)</span></span>;<br></code></pre></td></tr></table></figure>

<p>其中<code>move</code>的原点是父窗口的左上角，如果没有父窗口，则桌面即为父窗口。x 往右递增，y 往下递增</p>
<p><code>mouseMoveEvent()</code>这个函数里有一点需要注意的是，<code>m_startMovePos = event-&gt;globalPos()</code>这条语句。每次移动窗口之前，先把鼠标移动后的位置记录下来，作为下一次移动的起点。</p>
<h2 id="设置最小化，关闭"><a href="#设置最小化，关闭" class="headerlink" title="设置最小化，关闭"></a>设置最小化，关闭</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//mytitlebar.cpp</span><br><span class="hljs-comment">// 信号槽的绑定;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::initConnections</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">connect</span>(m_pButtonMin, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonMinClicked</span>()));<br> <span class="hljs-built_in">connect</span>(m_pButtonClose, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonCloseClicked</span>()));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::onButtonMinClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-function">emit <span class="hljs-title">signalButtonMinClicked</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::onButtonCloseClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-function">emit <span class="hljs-title">signalButtonCloseClicked</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>标题栏是在<code>basewindow</code>中 new 出来的，<code>mytitlebar</code>类只负责发送信号，真正处理信号的是在<code>basewindow</code>类中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//basewindow.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BaseWindow::initTitleBar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">createMyTitle</span>(<span class="hljs-keyword">this</span>);<br> m_titleBar-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br> <br> <span class="hljs-built_in">connect</span>(m_titleBar, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalButtonMinClicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonMinClicked</span>()));<br> <span class="hljs-built_in">connect</span>(m_titleBar, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalButtonCloseClicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonCloseClicked</span>()));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BaseWindow::onButtonMinClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (Qt::Tool == (<span class="hljs-built_in">windowFlags</span>() &amp; Qt::Tool))<br> &#123;<br>  <span class="hljs-built_in">hide</span>();<br> &#125;<br> <span class="hljs-keyword">else</span><br> &#123;<br>  <span class="hljs-built_in">showMinimized</span>();<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BaseWindow::onButtonCloseClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在初始化标题栏时，就把点击信号与相关的槽函数绑定。当有最小化点击信号发生时，就会调用最小化操作。</p>
<h3 id="和窗口相关的几个函数"><a href="#和窗口相关的几个函数" class="headerlink" title="和窗口相关的几个函数"></a>和窗口相关的几个函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">showMinimized</span>()     <span class="hljs-comment">//最小化</span><br><span class="hljs-built_in">showNormal</span>()        <span class="hljs-comment">//从最小化或者最大化窗口恢复到正常窗口</span><br><span class="hljs-built_in">showMaximized</span>()     <span class="hljs-comment">//最大化</span><br><span class="hljs-built_in">show</span>()              <span class="hljs-comment">//显示窗口，可以显示模态窗口也可以显示非模态</span><br><span class="hljs-built_in">hide</span>()              <span class="hljs-comment">//隐藏窗口</span><br><span class="hljs-built_in">isVisible</span>()         <span class="hljs-comment">//判断是否可见</span><br><span class="hljs-built_in">isMinimized</span>()       <span class="hljs-comment">//判断是否处于最小化状态</span><br><span class="hljs-built_in">close</span>()             <span class="hljs-comment">//关闭窗口</span><br></code></pre></td></tr></table></figure>

<h2 id="切换用户及删除用户"><a href="#切换用户及删除用户" class="headerlink" title="切换用户及删除用户"></a>切换用户及删除用户</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//loginwindow.cpp</span><br><span class="hljs-comment">// 初始化用户登录信息;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initAccountList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 设置代理;</span><br>    m_Accountlist = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QListWidget</span>(<span class="hljs-keyword">this</span>);<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setModel</span>(m_Accountlist-&gt;<span class="hljs-built_in">model</span>());<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setView</span>(m_Accountlist);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        AccountItem *account_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AccountItem</span>();<br>        account_item-&gt;<span class="hljs-built_in">setAccountInfo</span>(i, <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;Dominic%1号&quot;</span>).<span class="hljs-built_in">arg</span>(i), <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/headImage/head_%1.png&quot;</span>).<span class="hljs-built_in">arg</span>(i));<br>        <span class="hljs-built_in">connect</span>(account_item, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalShowAccountInfo</span>(<span class="hljs-keyword">int</span>, QString)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onShowAccountInfo</span>(<span class="hljs-keyword">int</span>, QString)));<br>        <span class="hljs-built_in">connect</span>(account_item, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalRemoveAccount</span>(<span class="hljs-keyword">int</span>)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onRemoveAccount</span>(<span class="hljs-keyword">int</span>)));<br>        QListWidgetItem *list_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QListWidgetItem</span>(m_Accountlist);<br>        m_Accountlist-&gt;<span class="hljs-built_in">setItemWidget</span>(list_item, account_item);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//将选项文本显示在 QComboBox 当中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onShowAccountInfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, QString accountName)</span></span><br><span class="hljs-function"></span>&#123;<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setEditText</span>(accountName);<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">hidePopup</span>();<br><br>    <span class="hljs-comment">// 更换用户头像;</span><br>    QString fileName = <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/headImage/head_%1.png&quot;</span>).<span class="hljs-built_in">arg</span>(index);<br>    ui-&gt;userHead-&gt;<span class="hljs-built_in">setPixmap</span>(<span class="hljs-built_in">QPixmap</span>(fileName).<span class="hljs-built_in">scaled</span>(ui-&gt;userHead-&gt;<span class="hljs-built_in">width</span>(), ui-&gt;userHead-&gt;<span class="hljs-built_in">height</span>()));<br>&#125;<br><br><span class="hljs-comment">// 移除当前登录列表中某一项;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onRemoveAccount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; m_Accountlist-&gt;<span class="hljs-built_in">count</span>(); row++)<br>    &#123;<br>        AccountItem* itemWidget = (AccountItem*)m_Accountlist-&gt;<span class="hljs-built_in">itemWidget</span>(m_Accountlist-&gt;<span class="hljs-built_in">item</span>(row));<br>        <span class="hljs-keyword">if</span> (itemWidget != <span class="hljs-literal">NULL</span> &amp;&amp; itemWidget-&gt;<span class="hljs-built_in">getItemWidgetIndex</span>() == index)<br>        &#123;<br>            m_Accountlist-&gt;<span class="hljs-built_in">takeItem</span>(row);<br>            itemWidget-&gt;<span class="hljs-built_in">deleteLater</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>initAccountList()</code>中，初始化好了三个账户信息，当接收到显示用户信息的信号<code>signalShowAccountInfo</code>后，就会调用<code>onShowAccountInfo</code>槽函数显示用户信息。在这个函数中，将下拉框的内容设置成切换后的用户名，然后隐藏下拉框<code>hidPopup</code>。更改头像。</p>
<p>当接收到删除信号时，调用<code>onRemoveAccount</code>槽函数，删除指定的用户信息。</p>
<h3 id="hidPopup-隐藏下拉框"><a href="#hidPopup-隐藏下拉框" class="headerlink" title="hidPopup()隐藏下拉框"></a><code>hidPopup()</code>隐藏下拉框</h3><p>文章开头的效果图是隐藏下拉框的效果，每次切换用户下拉框隐藏，我们再来看一下不隐藏什么效果就容易理解了。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820105158.gif"></p>
<h3 id="takeItem-删除部件"><a href="#takeItem-删除部件" class="headerlink" title="takeItem()删除部件"></a><code>takeItem()</code>删除部件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QListWidgetItem *<span class="hljs-title">QListWidget::takeItem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row)</span></span><br></code></pre></td></tr></table></figure>

<p>从下拉菜单中选择一行部件删除。</p>
<h3 id="deleteLater-稍后删除对象"><a href="#deleteLater-稍后删除对象" class="headerlink" title="deleteLater()稍后删除对象"></a><code>deleteLater()</code>稍后删除对象</h3><p><code>deletelater</code>的原理是 <code>QObject::deleteLater()</code>并没有将对象立即销毁，而是向主消息循环发送了一个<code>event</code>，下一次主消息循环收到这个<code>event</code>之后才会销毁对象。</p>
<h2 id="切换登录状态"><a href="#切换登录状态" class="headerlink" title="切换登录状态"></a>切换登录状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//loginwindow.cpp</span><br><span class="hljs-comment">// 选择了新的用户登录状态;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onLoginStateClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_loginStateMemu = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QMenu</span>();<br>    QAction *pActionOnline = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_online.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;我在线上&quot;</span>));<br>    QAction *pActionActive = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_Qme.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;Q 我吧&quot;</span>));<br>    m_loginStateMemu-&gt;<span class="hljs-built_in">addSeparator</span>();<br>    QAction *pActionAway = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_away.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;离开&quot;</span>));<br>    QAction *pActionBusy = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_busy.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;忙碌&quot;</span>));<br>    QAction *pActionNoDisturb = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_notdisturb.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;请勿打扰&quot;</span>));<br>    m_loginStateMemu-&gt;<span class="hljs-built_in">addSeparator</span>();<br>    QAction *pActionHide = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_hide.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;隐身&quot;</span>));<br>    <span class="hljs-comment">// 设置状态值;</span><br>    pActionOnline-&gt;<span class="hljs-built_in">setData</span>(ONLINE);<br>    pActionActive-&gt;<span class="hljs-built_in">setData</span>(ACTIVE);<br>    pActionAway-&gt;<span class="hljs-built_in">setData</span>(AWAY);<br>    pActionBusy-&gt;<span class="hljs-built_in">setData</span>(BUSY);<br>    pActionNoDisturb-&gt;<span class="hljs-built_in">setData</span>(NOT_DISTURB);<br>    pActionHide-&gt;<span class="hljs-built_in">setData</span>(HIDE);<br><br><br>    <span class="hljs-built_in">connect</span>(m_loginStateMemu, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">triggered</span>(QAction *)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onMenuClicked</span>(QAction*)));<br><br>    QPoint pos = ui-&gt;loginState-&gt;<span class="hljs-built_in">mapToGlobal</span>(<span class="hljs-built_in">QPoint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) + <span class="hljs-built_in">QPoint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br>    m_loginStateMemu-&gt;<span class="hljs-built_in">exec</span>(pos);<br>&#125;<br><br><span class="hljs-comment">// 用户状态菜单点击;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onMenuClicked</span><span class="hljs-params">(QAction * action)</span></span><br><span class="hljs-function"></span>&#123;<br>    ui-&gt;loginState-&gt;<span class="hljs-built_in">setIcon</span>(action-&gt;<span class="hljs-built_in">icon</span>());<br>    <span class="hljs-comment">// 获取状态值;</span><br>    m_loginState = (LoginState)action-&gt;<span class="hljs-built_in">data</span>().<span class="hljs-built_in">toInt</span>();<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;onMenuClicked&quot;</span> &lt;&lt; m_loginState;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在接收到点击状态按钮信号时，调用<code>onLoginStateClicked</code>槽函数，改变用户登录状态。切换的下拉菜单用的是<code>QMenu</code>。</p>
<h3 id="addSeparator-添加分割线"><a href="#addSeparator-添加分割线" class="headerlink" title="addSeparator()添加分割线"></a><code>addSeparator()</code>添加分割线</h3><p>Q 我吧和离开状态之间的分割线。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820113856.png"></p>
<h3 id="mapToGlobal-映射成全局坐标"><a href="#mapToGlobal-映射成全局坐标" class="headerlink" title="mapToGlobal()映射成全局坐标"></a><code>mapToGlobal()</code>映射成全局坐标</h3><p>弹出登录状态菜单<code>m_loginStateMemu</code>是我们自己 new 出来的，默认显示是从左上角开始显示，这样当然不行。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820140445.png"></p>
<p> <code>mapToGlobal()</code>的作用就是将控件的坐标映射成全局坐标。代码里的意思就是将<code>loginState</code>控件里面的坐标用全局坐标表示。然后再向下偏移<code>20</code>个单位。再把得到的全局坐标作为<code>m_loginStateMemu</code>显示起始坐标。</p>
<p>下图是未偏移的结果，<br> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820141408.png"></p>
<p>向下偏移<code>20</code>个单位的效果，因为我们<code>mapToGlobal(QPoint(0, 0))</code>的参数是<code>(0,0)</code>为起点。如果我们<code>mapToGlobal(QPoint(0, 20))</code>的参数是<code>(0,20)</code>，就不用再加上偏移了。<br> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820141521.png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/17/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80%E5%8F%8A%E6%A0%B7%E5%BC%8F/" itemprop="url">Qt 模仿登录界面-窗口布局及样式</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-17T03:30:06.000Z" itemprop="datePublished">8月 17 2021</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            6 分钟 读完 (约 974 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="框架类图"><a href="#框架类图" class="headerlink" title="框架类图"></a>框架类图</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827120419.png"></p>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210818130510.gif"><br>完整项目及资源文件请在<a target="_blank" rel="noopener" href="https://github.com/Dunky-Z/learning-qt/tree/main/Demo/login">Github</a>查看。</p>
<h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820101857.png"></p>
<h2 id="初始化标题栏"><a href="#初始化标题栏" class="headerlink" title="初始化标题栏"></a>初始化标题栏</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化标题栏;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initMyTitle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 因为这里有控件层叠了，所以要注意控件 raise() 方法的调用顺序;</span><br>    m_titleBar-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    m_titleBar-&gt;<span class="hljs-built_in">raise</span>();<br>    m_titleBar-&gt;<span class="hljs-built_in">setBackgroundColor</span>(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    m_titleBar-&gt;<span class="hljs-built_in">setButtonType</span>(MIN_BUTTON);<br>    m_titleBar-&gt;<span class="hljs-built_in">setTitleWidth</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>());<br>    <span class="hljs-comment">// 这里需要设置成 false，不允许通过标题栏拖动来移动窗口位置，否则会造成窗口位置错误;</span><br>    m_titleBar-&gt;<span class="hljs-built_in">setMoveParentWindowFlag</span>(<span class="hljs-literal">false</span>);<br>    ui-&gt;pButtonArrow-&gt;<span class="hljs-built_in">raise</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="raise-将控件置于顶层"><a href="#raise-将控件置于顶层" class="headerlink" title="raise()将控件置于顶层"></a><code>raise()</code>将控件置于顶层</h3><p>程序在打开后一般都在所有窗体的顶层，打开其他程序后之前的程序就会被放到下一层，在这里，当设置完<code>my_titleBar</code>后对其他控件操作就会把<code>my_titleBar</code>控件覆盖。所有要用<code>raise()</code>方法将其置于顶层。</p>
<h2 id="初始化窗口"><a href="#初始化窗口" class="headerlink" title="初始化窗口"></a>初始化窗口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化窗口;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initWindow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//背景 GIG 图;</span><br>    QLabel* pBack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QLabel</span>(<span class="hljs-keyword">this</span>);<br>    QMovie *movie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QMovie</span>();<br>    movie-&gt;<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/back.gif&quot;</span>);<br>    pBack-&gt;<span class="hljs-built_in">setMovie</span>(movie);<br>    movie-&gt;<span class="hljs-built_in">start</span>();<br>    pBack-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//文本框内提示</span><br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setEditable</span>(<span class="hljs-literal">true</span>);<br>    QLineEdit* lineEdit = ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">lineEdit</span>();<br>    lineEdit-&gt;<span class="hljs-built_in">setPlaceholderText</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;QQ 号码/手机/邮箱&quot;</span>));<br>    <span class="hljs-function">QRegExp <span class="hljs-title">regExp</span><span class="hljs-params">(<span class="hljs-string">&quot;[A-Za-z0-9_]&#123;6,30&#125;&quot;</span>)</span></span>; <span class="hljs-comment">//正则表达式限制用户名输入不能输入汉字</span><br>    lineEdit-&gt;<span class="hljs-built_in">setValidator</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QRegExpValidator</span>(regExp,<span class="hljs-keyword">this</span>));<br>    ui-&gt;passwordEdit-&gt;<span class="hljs-built_in">setPlaceholderText</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;密码&quot;</span>));<br><br>    <span class="hljs-comment">//密码框中的小键盘按钮;</span><br>    m_keyboardButton = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>();<br>    m_keyboardButton-&gt;<span class="hljs-built_in">setObjectName</span>(<span class="hljs-string">&quot;pButtonKeyboard&quot;</span>);<br>    m_keyboardButton-&gt;<span class="hljs-built_in">setFixedSize</span>(<span class="hljs-built_in">QSize</span>(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>));<br>    m_keyboardButton-&gt;<span class="hljs-built_in">setCursor</span>(<span class="hljs-built_in">QCursor</span>(Qt::PointingHandCursor));<span class="hljs-comment">//鼠标放上去变成手形</span><br><br>    QHBoxLayout* passwordEditLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>    passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>();<br>    passwordEditLayout-&gt;<span class="hljs-built_in">addWidget</span>(m_keyboardButton);<br>    passwordEditLayout-&gt;<span class="hljs-built_in">setSpacing</span>(<span class="hljs-number">0</span>);<br>    passwordEditLayout-&gt;<span class="hljs-built_in">setContentsMargins</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br><br>    ui-&gt;passwordEdit-&gt;<span class="hljs-built_in">setLayout</span>(passwordEditLayout);<br>    <span class="hljs-comment">//设置密码达到最长时最后一个字符离小键盘图标的距离（12）</span><br>    ui-&gt;passwordEdit-&gt;<span class="hljs-built_in">setTextMargins</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m_keyboardButton-&gt;<span class="hljs-built_in">width</span>() + <span class="hljs-number">12</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//设置头像以及状态图标</span><br>    ui-&gt;userHead-&gt;<span class="hljs-built_in">setPixmap</span>(<span class="hljs-built_in">QPixmap</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/HeadImage.png&quot;</span>));<br>    ui-&gt;loginState-&gt;<span class="hljs-built_in">setIcon</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_online.png&quot;</span>));<br>    ui-&gt;loginState-&gt;<span class="hljs-built_in">setIconSize</span>(<span class="hljs-built_in">QSize</span>(<span class="hljs-number">13</span>, <span class="hljs-number">13</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>lineEdit-&gt;setPlaceholderText<br>QStringLiteral:如果该 QString 不会修改的话，那使用 QStringLiteral</p>
<h3 id="setPlaceholderText-设置文本提示"><a href="#setPlaceholderText-设置文本提示" class="headerlink" title="setPlaceholderText()设置文本提示"></a><code>setPlaceholderText()</code>设置文本提示</h3><p>该方法可以设置文本框中的默认文字提示，如图片中的 QQ 号码/手机/邮箱。</p>
<h3 id="setCursor-设置鼠标形态"><a href="#setCursor-设置鼠标形态" class="headerlink" title="setCursor()设置鼠标形态"></a><code>setCursor()</code>设置鼠标形态</h3><p>共有以下 19 种鼠标形态：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820150422.png"></p>
<p>图片来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/taiyang1987912/article/details/35281407">这里</a></p>
<h3 id="addStretch-布局加入弹簧"><a href="#addStretch-布局加入弹簧" class="headerlink" title="addStretch()布局加入弹簧"></a><code>addStretch()</code>布局加入弹簧</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QHBoxLayout* passwordEditLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>();<br>passwordEditLayout-&gt;<span class="hljs-built_in">addWidget</span>(m_keyboardButton);<br></code></pre></td></tr></table></figure>

<p><code>addStretch()</code>用来在布局中平分布局，他就是个弹簧的作用。如果不加参数，就是等于加个弹簧，会把小键盘图标挤到边上。如图：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817143033.png"></p>
<p>如果将代码改一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QHBoxLayout* passwordEditLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>(<span class="hljs-number">1</span>);<br>passwordEditLayout-&gt;<span class="hljs-built_in">addWidget</span>(m_keyboardButton);<br>passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>意思就是将除了小键盘图标以外的空间分成两份，那么刚好小键盘图标就是在中间位置，就像两遍各防止了一个弹簧。效果如下：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817143135.png"></p>
<p><code>setSpacing()</code>设置空间之间上下距离，还有一个容易混淆的设置<code>setMargin()</code>表示设置空间与窗口边缘的左右距离。</p>
<p><code>setContentsMargins</code>设置左侧、顶部、右侧和底部边距，以便在布局周围使用。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817144359.png"></p>
<p>现在我们设置的是<code>setContentsMargins(0, 0, 8, 0)</code>，现在我们设置大一点看看效果。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817144532.png"></p>
<p><code>QLineEdit.setTextMargins(left=,top=,right=,bottom=)</code>设置文本边距，这里主要为了设置密码输入过长时，最后一个字符距离小键盘图标有一定间隙。</p>
<h2 id="初始化用户登录信息"><a href="#初始化用户登录信息" class="headerlink" title="初始化用户登录信息"></a>初始化用户登录信息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//accountitem.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initAccountList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br> &#123;<br>  AccountItem *account_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AccountItem</span>();<br>  account_item-&gt;<span class="hljs-built_in">setAccountInfo</span>(i, <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;Dominic_%1号&quot;</span>).<span class="hljs-built_in">arg</span>(i), <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/headImage/head_%1.png&quot;</span>).<span class="hljs-built_in">arg</span>(i));<br>  QListWidgetItem *list_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QListWidgetItem</span>(m_Accountlist);<br>  m_Accountlist-&gt;<span class="hljs-built_in">setItemWidget</span>(list_item, account_item);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/14/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" itemprop="url">Linux 操作系统-进程间通信</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-14T01:46:39.000Z" itemprop="datePublished">8月 14 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">Linux 操作系统</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            14 分钟 读完 (约 2108 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong>。</p>
<h2 id="进程间通信概述"><a href="#进程间通信概述" class="headerlink" title="进程间通信概述"></a>进程间通信概述</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>在学 Linux 命令时就有管道在这个概念，比如下面这个命令</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">ps -ef  | <span class="hljs-type">-grep</span> root | <span class="hljs-type">xargs</span> kill <span class="hljs-number">-9</span><br></code></pre></td></tr></table></figure>

<p>将上一个命令的输出作为下一个命令的输入，数据只能向一个方向流动；双方需要互相通信时，需要建立起两个管道。</p>
<p>管道有两种类型：匿名管道和命名管道。上面提到的命令中<code>|</code>表示的管道即<strong>匿名管道 pipe</strong>。用完即销毁，自动创建，自动销毁。</p>
<p>使用<code>mkfifo</code>显示创建的是<strong>命名管道 fifo</strong>，</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mkfifo hello</span><br></code></pre></td></tr></table></figure>

<p><code>hello</code>即是管道名称，类型为<code>p</code>，就是<code>pipe</code>，接下来就可以在管道里写入东西，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span> &gt; hello</span><br></code></pre></td></tr></table></figure>

<p>光写入还不行，只有有另一个进程读取了内容才完成一次信息交换，才完成一次通信，</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># cat &lt; hello </span><br><span class="hljs-attribute">hello</span> world<br></code></pre></td></tr></table></figure>

<p>这种方式通信效率低，无法频繁通信。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>类似于日常沟通使用的邮件，有一定格式，有个收件列表，列表上的用户都可以反复在原邮件基础上回复，达到频繁交流的目的。这种模型就是<strong>消息队列模型</strong>。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。</p>
<p>每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存空间映射到不同的物理内存中去。这个进程访问 A 地址和另一个进程访问 A 地址，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p>但是，咱们是不是可以变通一下，<strong>拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。</p>
<p>使用<code>shmget</code>函数创建一个共享内存，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//key_t key:  唯一定位一个共享内存对象</span><br><span class="hljs-comment">//size_t size: 共享内存大小</span><br><span class="hljs-comment">//int flag: 如果是 IPC_CREAT 表示创建新的共享内存空间</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> flag)</span></span>;<br></code></pre></td></tr></table></figure>

<p>创建完毕之后，我们可以通过 <code>ipcs</code> 命令查看这个共享内存。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#ipcs ­­--shmems</span><br> <br>------ <span class="hljs-keyword">Shared </span>Memory Segments ------ ­­­­­­­­<br>key        <span class="hljs-keyword">shmid </span>   owner perms    <span class="hljs-keyword">bytes </span>nattch status<br><span class="hljs-number">0x00000000</span> <span class="hljs-number">19398656</span> marc  <span class="hljs-number">600</span>    <span class="hljs-number">1048576</span> <span class="hljs-number">2</span>      dest<br></code></pre></td></tr></table></figure>

<p>进程通过<code>shmat</code>，就是<code>attach</code>的意思，将内存加载到自己虚拟地址空间某个位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//int shm_id:</span><br><span class="hljs-comment">//const void *addr: 加载的地址，通常设为 NULL，让内核选一个合适地址</span><br><span class="hljs-comment">//int flag:</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">shmat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">int</span> flag)</span></span>;<br></code></pre></td></tr></table></figure>

<p>如果共享内存使用完毕，可以通过 <code>shmdt</code> 解除绑定，然后通过 <code>shmctl</code>，将 <code>cmd</code> 设置为 <code>IPC_RMID</code>，从而删除这个共享内存对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmdt</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;<br></code></pre></td></tr></table></figure>

<p>共享内存的最大不足之处在于，由于多个进程对同一块内存区具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>如果两个进程同时向一个共享内存读写数据，很可能就会导致冲突。所以需要有一种保护机制，使得同一个共享资源同时只能被一个进程访问。在进程间通信机制中，<strong>信号量</strong>（Semaphore）就是用来实现进程间互斥与同步的。它其实是个<strong>计数器</strong>，只不过不是用来记录进程间通信数据的。</p>
<p>我们可以将信号量初始化为一个数值，来代表某种资源的总体数量。对于信号量来讲，会定义两种原子操作，一个是<code>P</code> 操作，我们称为<strong>申请资源操作</strong>。这个操作会申请将信号量的数值<strong>减去</strong> N，表示这些数量被他申请使用了，其他人不能用了。另一个是<code>V</code>操作，我们称为<strong>归还资源操作</strong>，这个操作会申请将信号量<strong>加上</strong> M，表示这些数量已经还给信号量了，其他人可以使用了。</p>
<p>所谓<strong>原子操作</strong>（Atom Operation）就是不可被中断的一个或一系列操作。</p>
<p>使用<code>semget</code><strong>创建</strong>信号量，第一个参数表示唯一标识，第二个参数表示可以创建多少个信号量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">int</span> num_sems, <span class="hljs-keyword">int</span> sem_flags)</span></span>;<br></code></pre></td></tr></table></figure>

<p>接下来，我们需要<strong>初始化</strong>信号量的总的资源数量。通过<code>semctl</code> 函数，第一个参数 <code>semid</code>是这个信号量组的<code>id</code>，第二个参数 <code>semnum</code> 才是在这个信号量组中某个信号量的<code>id</code>，第三个参数是命令，如果是初始化，则用 <code>SETVAL</code>，第四个参数是一个 <code>union</code>。如果初始化，应该用里面的<code>val</code>设置资源总量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> semid, <span class="hljs-keyword">int</span> semnum, <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">union</span> semun args)</span></span>;<br> <br> <br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">semun</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">int</span> val;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semid_ds</span> *<span class="hljs-title">buf</span>;</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seminfo</span> *__<span class="hljs-title">buf</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>无论是 P 操作还是 V 操作，我们统一用 semop 函数。第一个参数还是信号量组的 id，一次可以操作多个信号量。第三个参数 numops 就是有多少个操作，第二个参数将这些操作放在一个数组中。</p>
<p>数组的每一项是一个 <code>struct sembuf</code>，里面的第一个成员是这个操作的对象是哪个信号量。第二个成员就是要对这个信号量做多少改变。如果 <code>sem_op &lt; 0</code>，就请求 <code>sem_op</code> 的绝对值的资源。如果相应的资源数可以满足请求，则将该信号量的值减去 <code>sem_op</code> 的绝对值，函数成功返回。</p>
<p>当相应的资源数不能满足请求时，就要看<code>sem_flg</code> 了。如果把 <code>sem_flg</code> 设置为<code>IPC_NOWAIT</code>，也就是没有资源也不等待，则 <code>semop</code> 函数出错返回 <code>EAGAIN</code>。如果 <code>sem_flg</code> 没有指定<code>IPC_NOWAIT</code>，则进程挂起，直到当相应的资源数可以满足请求。若 <code>sem_op &gt; 0</code>，表示进程归还相应的资源数，将 <code>sem_op</code> 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则唤醒它们。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> semid, struct sembuf semoparray[], <span class="hljs-keyword">size_t</span>  numops)</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> </span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">short</span> sem_num; <span class="hljs-comment">// 信号量组中对应的序号，0～sem_nums-1</span><br>  <span class="hljs-keyword">short</span> sem_op;  <span class="hljs-comment">// 信号量值在一次操作中的改变量</span><br>  <span class="hljs-keyword">short</span> sem_flg; <span class="hljs-comment">// IPC_NOWAIT, SEM_UNDO</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>以上提到的通信方式，都是常规状态下的工作模式，而信号一般是由<strong>错误</strong>产生的。</p>
<p>信号没有特别复杂的数据结构，就是用一个代号一样的数字。Linux 提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/13/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-rename%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/" itemprop="url">每天学命令-rename 批量重命名</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-13T10:40:16.000Z" itemprop="datePublished">8月 13 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/">每天学命令</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 读完 (约 304 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">rename</span> [<span class="hljs-meta">options</span>] <span class="hljs-string">&quot;s/oldname/newname/&quot;</span> <span class="hljs-meta">file</span><br></code></pre></td></tr></table></figure>

<p>格式就很容易看出来怎么用的，就是<code>/</code>不能丢。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-v 将重命名的内容都打印到标准输出，v 可以看成 verbose</span><br><span class="hljs-deletion">-n 测试会重命名的内容，将结果都打印，但是并不真正执行重命名的过程</span><br><span class="hljs-deletion">-f force 会覆盖本地已经存在的文件</span><br><span class="hljs-deletion">-h -m -V 分别为帮助，帮助，版本</span><br><span class="hljs-deletion">-e 比较复杂，可以通过该选项，写一些脚本来做一些复杂的事情</span><br></code></pre></td></tr></table></figure>

<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="替换文件名中的特定字段"><a href="#替换文件名中的特定字段" class="headerlink" title="替换文件名中的特定字段"></a>替换文件名中的特定字段</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/AA/aa/&quot;</span> *  <span class="hljs-comment"># 把文件名中的AA替换成aa</span><br></code></pre></td></tr></table></figure>

<h3 id="修改文件后缀"><a href="#修改文件后缀" class="headerlink" title="修改文件后缀"></a>修改文件后缀</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/.html/.php/&quot;</span> *     <span class="hljs-comment"># 把.html 后缀的改成 .php后缀</span><br><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/.png/.jpg/&quot;</span> *      <span class="hljs-comment"># 将 png 改为 jpg</span><br></code></pre></td></tr></table></figure>

<h3 id="添加后缀"><a href="#添加后缀" class="headerlink" title="添加后缀"></a>添加后缀</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/$/.txt/&quot;</span> *     <span class="hljs-comment"># 把所有的文件名都以txt结尾</span><br></code></pre></td></tr></table></figure>

<p><code>$</code>正则表达式中表示结尾。</p>
<h3 id="保留部分文件名"><a href="#保留部分文件名" class="headerlink" title="保留部分文件名"></a>保留部分文件名</h3><p>假如需要在批量修改的时候保留部分文件名，可以使用引用<code>\1</code> ，比如有下面格式的文件，只想保留日期部分。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Screenshot</span> from <span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span> <span class="hljs-number">15</span>-<span class="hljs-number">56</span>-<span class="hljs-number">49</span>.jpg<br><span class="hljs-attribute">rename</span> -n <span class="hljs-string">&quot;s/Screenshot from ([0-9\\- ]+).jpg/\1.jpg/&quot;</span> *<br></code></pre></td></tr></table></figure>

<p>将<code>()</code> 匹配的内容取出来放到替换部分。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/12/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-apt%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/" itemprop="url">每天学命令-apt 安装卸载软件</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-12T10:42:39.000Z" itemprop="datePublished">8月 12 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/">每天学命令</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 读完 (约 323 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>这个命令应该是我们平时用的最多的命令之一了，应该早就拿出来讲一下的。但是平时用的太多，总感觉自己都会用了，但是仔细看了所有命令，还是有一些比较实用但是没记住的命令。</p>
<p><code>apt</code>的全称是<code>Advanced Packaging Tool</code>是 Linux 系统下的一款安装包管理工具。APT 可以自动下载、配置和安装二进制或源代码格式软件包，简化了 Unix 系统上管理软件的过程。</p>
<p>APT 主要由以下几个命令组成：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">apt-<span class="hljs-keyword">get</span><br>apt-cache<br>apt-<span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure>

<h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><h3 id="搜索软件包"><a href="#搜索软件包" class="headerlink" title="搜索软件包"></a>搜索软件包</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">apt <span class="hljs-built_in">search</span> <span class="hljs-keyword">python3</span><br></code></pre></td></tr></table></figure>

<h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">apt</span> install python<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h3 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> update<br></code></pre></td></tr></table></figure>

<h3 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h3><p>执行完 update 命令后，就可以使用 apt upgrade 来升级软件包了。执行命令后系统会提示有几个软件需要升级。在得到你的同意后，系统即开始自动下载安装软件包。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> upgrade<br></code></pre></td></tr></table></figure>

<h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">remove</span> python3  <span class="hljs-comment"># 移除软件包，但是保留配置文件</span><br>apt purge python3 <span class="hljs-comment">#移除软件包并移除配置</span><br>apt autoremove <span class="hljs-comment"># 移除孤立的并不被依赖的软件包</span><br></code></pre></td></tr></table></figure>

<h3 id="列出软件清单"><a href="#列出软件清单" class="headerlink" title="列出软件清单"></a>列出软件清单</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">apt list</span><br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/12/Qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%88QtCreator%EF%BC%89/" itemprop="url">Qt 添加资源文件（QtCreator）</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-12T02:23:58.000Z" itemprop="datePublished">8月 12 2021</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 分钟 读完 (约 415 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>QtCreator➜新建文件或项目➜Qt➜Qt Resource File</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812102544.png"></p>
<p>点击<code>Choose</code>，设置资源文件名和路径。资源文件是一系列文件的集合，比如我要建立一个图片的资源文件，我可以设置<code>img</code>为资源文件名，将来所有图片类资源，都放到这个资源文件里，加入还有音频类的文件，我可以新建一个<code>audio</code>的资源文件，以后所有音频类的文件都放到这个资源文件下。</p>
<p>而不是我想要添加的文件名。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812103024.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812103101.png"></p>
<p>右侧编辑器下方有个<code>Add Prefix</code>(添加前缀)，我们首先要添加文件前缀，前缀就是存放文件的文件夹名，然后添加需要的文件。添加完以后看效果就知道啥意思了。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812104121.png"></p>
<p>这么做带来的一个问题是，如果以后我们要更改文件名，比如将 <code>xbl.png</code> 改成 <code>xiabanle.png</code>，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：</p>
<p>这样，我们可以直接使用<code>:/images/avatar</code>用到这个资源，无需关心图片的真实文件名。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/11/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-kill%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B/" itemprop="url">每天学命令-kill 这个进程</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-11T07:22:40.000Z" itemprop="datePublished">8月 11 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/">每天学命令</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 读完 (约 286 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>对于在前台运行的程序，我们可以用<code>Ctrl+C</code>来终止运行，但是在后台的程序就必须用<code>kill</code>命令来终止了。</p>
<h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class="hljs-deletion">-a  当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="hljs-deletion">-p  指定 kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="hljs-deletion">-s  指定发送信号</span><br><span class="hljs-deletion">-u  指定用户</span><br></code></pre></td></tr></table></figure>

<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="查看所有信号"><a href="#查看所有信号" class="headerlink" title="查看所有信号"></a>查看所有信号</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos">➜   <span class="hljs-keyword">kill</span> -<span class="hljs-keyword">l</span><br>HUP INT <span class="hljs-keyword">QUIT</span> ILL TRAP ABRT BUS FPE <span class="hljs-keyword">KILL</span> USR1 <br>SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP <br>TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS<br></code></pre></td></tr></table></figure>

<p>常用信号</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HUP</span>    <span class="hljs-number">1</span>    终端断线<br><span class="hljs-attribute">INT</span>     <span class="hljs-number">2</span>    中断（同 Ctrl + C）<br><span class="hljs-attribute">QUIT</span>    <span class="hljs-number">3</span>    退出（同 Ctrl + \）<br><span class="hljs-attribute">TERM</span>   <span class="hljs-number">15</span>    终止<br><span class="hljs-attribute">KILL</span>    <span class="hljs-number">9</span>    强制终止<br><span class="hljs-attribute">CONT</span>   <span class="hljs-number">18</span>    继续（与 STOP 相反， fg/bg 命令）<br><span class="hljs-attribute">STOP</span>    <span class="hljs-number">19</span>    暂停（同 Ctrl + Z）<br></code></pre></td></tr></table></figure>

<h3 id="用-ps-查找进程，然后用-kill-杀掉"><a href="#用-ps-查找进程，然后用-kill-杀掉" class="headerlink" title="用 ps 查找进程，然后用 kill 杀掉"></a>用 ps 查找进程，然后用 kill 杀掉</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">ps -ef | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;program&#x27;</span><br><span class="hljs-keyword">kill</span> PID<br></code></pre></td></tr></table></figure>

<h3 id="无条件彻底杀死进程"><a href="#无条件彻底杀死进程" class="headerlink" title="无条件彻底杀死进程"></a>无条件彻底杀死进程</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> –<span class="hljs-number">9</span> PID<br></code></pre></td></tr></table></figure>

<h3 id="杀死指定用户所有进程"><a href="#杀死指定用户所有进程" class="headerlink" title="杀死指定用户所有进程"></a>杀死指定用户所有进程</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">kill -<span class="hljs-number">9</span> <span class="hljs-constructor">$(<span class="hljs-params">ps</span> -<span class="hljs-params">ef</span> | <span class="hljs-params">grep</span> <span class="hljs-params">username</span>)</span><br>kill -u username<br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/11/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E4%BF%A1%E5%8F%B7%EF%BC%88Signal%EF%BC%89/" itemprop="url">进程间通信（IPC）之信号（Signal）</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-11T02:59:22.000Z" itemprop="datePublished">8月 11 2021</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            6 分钟 读完 (约 871 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>关于进程间通信的概述可以查看<a target="_blank" rel="noopener" href="https://dunky-z.github.io/2021/08/10/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">Linux 操作系统 - 进程间通信</a>，<a target="_blank" rel="noopener" href="https://github.com/Dunky-Z/learning-linux/tree/main/IPC/SharedMemory">代码同步在这里</a>。</p>
<p>本文通过实例介绍通过共享内存实现进程间通信。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>信号就像实际生产过程中的应急预案，发生了某个异常就会启动特定的应急预案，为了响应各类异常情况，所以就定义了很多个信号，信号的名称是在头文件<code>signal.h</code>中定义的，信号都以<code>SIG</code>开头，常用的信号并不多，常用的信号如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SIGALRM</span>     <span class="hljs-comment">#时钟定时信号, 计算的是实际的时间或时钟时间</span><br>SIGHUP      <span class="hljs-comment">#终端的挂断或进程死亡</span><br>SIGINT      <span class="hljs-comment">#来自键盘的中断信号</span><br>SIGKILL     <span class="hljs-comment">#用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。</span><br>SIGPIPE     <span class="hljs-comment">#管道破裂</span><br>SIGTERM     <span class="hljs-comment">#程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理</span><br>SIGUSR1,SIGUSR2     <span class="hljs-comment">#留给用户使用</span><br></code></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nOps! - I got signal %d\n&quot;</span>, sig);<br><br>    <span class="hljs-comment">// 恢复终端中断信号 SIGINT 的默认行为</span><br>    (<span class="hljs-keyword">void</span>)signal(SIGINT, SIG_DFL);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 改变终端中断信号 SIGINT 的默认行为，使之执行 ouch 函数</span><br>    <span class="hljs-comment">// 而不是终止程序的执行</span><br>    (<span class="hljs-keyword">void</span>)signal(SIGINT, signalHandler);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以用<code>signal()</code>函数处理指定的信号，主要通过忽略和恢复其默认行为来工作。signal() 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> (*signal(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">int</span>)))(<span class="hljs-keyword">int</span>);<br></code></pre></td></tr></table></figure>

<p>这是一个相当复杂的声明，耐心点看可以知道 signal 是一个带有<code>sig</code>和<code>func</code>两个参数的函数，<code>func</code>是一个类型为<code>void (*)(int)</code>的函数指针。该函数返回一个与<code>func</code>相同类型的指针，指向先前指定信号处理函数的函数指针。准备捕获的信号的参数由<code>sig</code>给出，接收到的指定信号后要调用的函数由参数<code>func</code>给出。其实这个函数的使用是相当简单的，通过下面的例子就可以知道。注意信号处理函数的原型必须为<code>void func（int）</code>，或者是下面的特殊值：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">SIG_IGN : 忽略信号<br>SIG_DFL : 恢复信号的默认行为<br></code></pre></td></tr></table></figure>

<p>我们程序的目的是想要捕获键盘输入<code>Ctrl+C</code>，这个中断。通过表里可以查到，我们使用<code>SIGINT</code>这个信号，当我们的程序出现<code>SIGINT</code>信号时，让程序接下来干啥呢？正常情况下，我们的<code>Ctrl+C</code>会中断当前运行的程序，但是现在我们做了一些更改，更改的内容在我们自己编写的<code>signalHandler</code>中。我们让程序输出一行字符串加上信号值。然后再把信号的行为恢复原样。此时我们运行程序可以得到如下</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210811143147.png"></p>
<p>在我们第一输入<code>Ctrl+C</code>时，程序没有中断，而是调用了<code>signalHanlder</code>函数，因为我们更改了信号的行为。但是第二次输入<code>Ctrl+C</code>时，程序中断了。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88SharedMemory%EF%BC%89/" itemprop="url">进程间通信（IPC）之共享内存 (SharedMemory)</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-10T09:41:26.000Z" itemprop="datePublished">8月 10 2021</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            18 分钟 读完 (约 2723 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>关于进程间通信的概述可以查看<a target="_blank" rel="noopener" href="https://dunky-z.github.io/2021/08/10/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">Linux 操作系统 - 进程间通信</a>，<a target="_blank" rel="noopener" href="https://github.com/Dunky-Z/learning-linux/tree/main/IPC/SharedMemory">代码同步在这里</a>。</p>
<p>本文通过实例介绍通过共享内存实现进程间通信。</p>
<h2 id="shmget-得到一个共享内存标识符或创建一个共享内存对象"><a href="#shmget-得到一个共享内存标识符或创建一个共享内存对象" class="headerlink" title="shmget(得到一个共享内存标识符或创建一个共享内存对象)"></a>shmget(得到一个共享内存标识符或创建一个共享内存对象)</h2><p>我们可以通过<code>shmget</code>函数创建或打开共享内存，通过函数签名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//key_t key:  唯一定位一个共享内存对象</span><br><span class="hljs-comment">//size_t size: 共享内存大小</span><br><span class="hljs-comment">//int flag: 如果是 IPC_CREAT 表示创建新的共享内存空间</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> flag)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>第一个参数是共享内存的唯一标识，是需要我们指定的。那么如何指定<code>key</code>呢？如何保证唯一性呢？我们可以指定一个文件，<code>ftok</code>会根据这个文件的 <code>inode</code>，生成一个近乎唯一的 <code>key</code>。只要在这个消息队列的生命周期内，这个文件不要被删除就可以了。只要不删除，无论什么时刻，再调用 <code>ftok</code>，也会得到同样的<code>key</code>。</li>
<li>第二个参数是申请的空间大小，我们就申请 1024B。</li>
<li>第三个参数是权限标识，<code>IPC_CREAT</code>表示创建共享内存，<code>0644</code>表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。</li>
</ul>
<h2 id="shmat-把共享内存区对象映射到调用进程的地址空间"><a href="#shmat-把共享内存区对象映射到调用进程的地址空间" class="headerlink" title="shmat(把共享内存区对象映射到调用进程的地址空间)"></a>shmat(把共享内存区对象映射到调用进程的地址空间)</h2><p>第一次创建完共享内存时，它还不能被任何进程访问，<code>shmat()</code>函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。它的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">shmat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *shm_addr, <span class="hljs-keyword">int</span> shmflg)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>第一个参数就是上文产生的唯一标识。</li>
<li>第二个参数，<code>shm_addr</code>指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</li>
<li>第三个参数，<code>shm_flg</code>是一组标志位，通常为 0。<br>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</li>
</ul>
<p><code>(void *) - 1</code>把<code>-1</code>转换为指针<code>0xFFFFFFFF</code>，有时也会用到<code>(void*)0</code>，表示一个空指针。</p>
<h2 id="shmdt-断开共享内存连接"><a href="#shmdt-断开共享内存连接" class="headerlink" title="shmdt(断开共享内存连接)"></a>shmdt(断开共享内存连接)</h2><p>与 shmat 函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存</p>
<p>函数签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmdt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *shmaddr)</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li>参数一<code>shmaddr</code>为连接共享内存的起始地址。</li>
</ul>
<p>需要注意的是，本函数调用并不删除所指定的共享内存区，而只是将先前用 shmat 函数连接（attach）好的共享内存脱离（detach）目前的进程。删除共享内存就需要下面的这个函数。</p>
<h2 id="shmctl-共享内存管理"><a href="#shmctl-共享内存管理" class="headerlink" title="shmctl(共享内存管理)"></a>shmctl(共享内存管理)</h2><p>完成对共享内存的控制，包括改变状态，删除共享内存等。</p>
<p>函数签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shmid, <span class="hljs-keyword">int</span> cmd, struct shmid_ds *buf)</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>shmid</code>共享内存唯一标识符</li>
<li><code>cmd</code>执行的操作，包括如下<ul>
<li><code>IPC_STAT</code>：得到共享内存的状态，把共享内存的<code>shmid_ds</code>结构复制到<code>buf</code>中</li>
<li><code>IPC_SET</code>：改变共享内存的状态，把<code>buf</code>所指的<code>shmid_ds</code>结构中的<code>uid</code>、<code>gid</code>、<code>mode</code>复制到共享内存的<code>shmid_ds</code>结构内</li>
<li><code>IPC_RMID</code>：删除这片共享内存</li>
</ul>
</li>
<li><code>buf</code>共享内存管理结构体。具体说明参见共享内存内核结构定义部分</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//server.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> shmid;<br>    <span class="hljs-keyword">key_t</span> shmkey;<br>    <span class="hljs-keyword">char</span> *shmptr;<br>    shmkey = ftok(<span class="hljs-string">&quot;./client.c&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 创建或打开内存共享区域</span><br>    shmid = shmget(shmkey, <span class="hljs-number">1024</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (shmid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmget error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将共享内存映射到当前进程的地址中，</span><br>    <span class="hljs-comment">//之后直接对进程中的地址 addr 操作就是对共享内存操作</span><br>    shmptr = (<span class="hljs-keyword">char</span> *)shmat(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (shmptr == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmat error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 把用户的输入存到共享内存区域中</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, shmptr);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//client.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> shmid;<br>    <span class="hljs-keyword">char</span> *shmptr;<br>    <span class="hljs-keyword">key_t</span> shmkey;<br>    shmkey = ftok(<span class="hljs-string">&quot;./client.c&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 创建或打开内存共享区域</span><br>    shmid = shmget(shmkey, <span class="hljs-number">1024</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (shmid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmget error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将共享内存映射到当前进程的地址中，</span><br>    <span class="hljs-comment">//之后直接对进程中的地址 addr 操作就是对共享内存操作</span><br>    shmptr = (<span class="hljs-keyword">char</span> *)shmat(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (shmptr == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;shmat error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 每隔 3 秒从共享内存中取一次数据并打印到控制台</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string:%s\n&quot;</span>, shmptr);<br>        sleep(<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在两个终端分别运行<code>client</code>和<code>server</code>，<code>client</code>会每三秒在终端打印出<code>server</code>输入的内容。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810205816.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810205830.png"></p>
<h3 id="如何手动删除共享内存？"><a href="#如何手动删除共享内存？" class="headerlink" title="如何手动删除共享内存？"></a>如何手动删除共享内存？</h3><p>列出所有的共享内存段：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dns">ipcs -m<br>------------ 共享内存段 --------------<br>键        shmid      拥有者  权限     字节     连接数  状态      <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">2</span>          dominic    <span class="hljs-number">600</span>        <span class="hljs-number">16384</span>      <span class="hljs-number">1</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">753668</span>     dominic    <span class="hljs-number">606</span>        <span class="hljs-number">10089696</span>   <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">622597</span>     dominic    <span class="hljs-number">600</span>        <span class="hljs-number">4194304</span>    <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">753670</span>     dominic    <span class="hljs-number">606</span>        <span class="hljs-number">10089696</span>   <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">688135</span>     dominic    <span class="hljs-number">600</span>        <span class="hljs-number">899976</span>     <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">8</span>          dominic    <span class="hljs-number">600</span>        <span class="hljs-number">524288</span>     <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">9</span>          dominic    <span class="hljs-number">600</span>        <span class="hljs-number">524288</span>     <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">753674</span>     dominic    <span class="hljs-number">600</span>        <span class="hljs-number">7127040</span>    <span class="hljs-number">2</span>          目标 <br><span class="hljs-number">0</span>x0000006f <span class="hljs-number">720918</span>     dominic    <span class="hljs-number">666</span>        <span class="hljs-number">1024</span>        <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>我们发现最后一个键值为<code>0x0000006f = 111</code>的共享内存段，就是我们创建的共享内存段。<br>删除指定共享内存段：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ipcrm</span> -m <span class="hljs-number">720918</span>  <br>或者 <br>ipcrm -M 0x0000006f  <br></code></pre></td></tr></table></figure>

<p>信号量和消息队列的操作，命令类似，只是参数不同。<br>查看命令：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">ipcs [-m|<span class="hljs-type">-q</span>|<span class="hljs-type">-s</span>]<br></code></pre></td></tr></table></figure>

<ul>
<li><code>-m</code> 输出有关共享内存 (shared memory) 的信息</li>
<li><code>-q</code> 输出有关信息队列 (message queue) 的信息</li>
<li><code>-s</code> 输出有关“信号量”(semaphore) 的信息</li>
</ul>
<p>删除命令</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">ipcrm [ -M<span class="hljs-built_in"> key</span> | -m<span class="hljs-built_in"> id</span> | -Q<span class="hljs-built_in"> key</span> | -q<span class="hljs-built_in"> id</span> | -S<span class="hljs-built_in"> key</span> | -s<span class="hljs-built_in"> id</span> ]<br></code></pre></td></tr></table></figure>

<ul>
<li><code>-M</code>用 shmkey 删除共享内存</li>
<li><code>-m</code>用 shmid 删除共享内存</li>
<li><code>-Q</code>用 msgkey 删除消息队列</li>
<li><code>-q</code>用 msgid 删除消息队列</li>
<li><code>-S</code>用 semkey 删除信号量</li>
<li><code>-s</code>用 semid 删除信号量</li>
</ul>
<h2 id="超过共享内存的大小限制"><a href="#超过共享内存的大小限制" class="headerlink" title="超过共享内存的大小限制"></a>超过共享内存的大小限制</h2><p>共享内存的总体大小是有限制的，这个大小通过 SHMMAX 参数来定义（以字节为单位），您可以通过执行以下命令来确定 SHMMAX 的值：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmmax<br></code></pre></td></tr></table></figure>

<p>如果机器上创建的共享内存的总共大小超出了这个限制，在程序中使用标准错误<code>perror</code>可能会出现以下的信息：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">unable <span class="hljs-keyword">to</span> attach <span class="hljs-keyword">to</span> <span class="hljs-keyword">shared</span> memory<br></code></pre></td></tr></table></figure>

<p>1、设置 SHMMAX</p>
<p>　　SHMMAX 的默认值是 <code>32MB</code> 。一般使用下列方法之一种将 SHMMAX 参数设为 <code>2GB</code> ：<br>通过直接更改 <code>/proc</code> 文件系统，你不需重新启动机器就可以改变 SHMMAX 的默认设置。我使用的方法是将以下命令放入 <code>/&gt;etc/rc.local</code> 启动文件中：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-string">&quot;2147483648&quot;</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmmax<br></code></pre></td></tr></table></figure>

<p>  您还可以使用 <code>sysctl</code> 命令来更改 SHMMAX 的值：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sysctl -w kernel.<span class="hljs-attribute">shmmax</span>=2147483648<br></code></pre></td></tr></table></figure>

<p>最后，通过将该内核参数插入到<code>/etc/sysctl.conf</code> 启动文件中，您可以使这种更改永久有效：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;kernel.shmmax=2147483648&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>sysctl.conf<br></code></pre></td></tr></table></figure>

<p>  2、设置 SHMMNI</p>
<p>  我们现在来看 SHMMNI 参数。这个内核参数用于设置系统范围内共享内存段的最大数量。该参数的默认值是 <code>4096</code> 。这一数值已经足够，通常不需要更改。您可以通过执行以下命令来确定 SHMMNI 的值：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmmni<br></code></pre></td></tr></table></figure>

<p>  3、设置 SHMALL</p>
<p>  最后，我们来看 SHMALL 共享内存内核参数。该参数控制着系统一次可以使用的共享内存总量（以页为单位）。简言之，该参数的值始终应该至少为：<code>ceil(SHMMAX/PAGE_SIZE)</code></p>
<p>SHMALL 的默认大小为 <code>2097152</code> ，可以使用以下命令进行查询：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmall<br></code></pre></td></tr></table></figure>

<p>　　SHMALL 的默认设置对于我们来说应该足够使用。注意：在 i386 平台上 Red Hat Linux 的 页面大小 为 <code>4096</code> 字节。但是，您可以使用 <code>bigpages</code> ，它支持配置更大的内存页面尺寸。</p>
<h2 id="多次进行-shmat-操作会出现什么问题"><a href="#多次进行-shmat-操作会出现什么问题" class="headerlink" title="多次进行 shmat 操作会出现什么问题"></a>多次进行 shmat 操作会出现什么问题</h2><p>一个进程是可以对同一个共享内存多次 shmat 进行挂载的，物理内存是指向同一块，如果 shmaddr 为 NULL，则每次返回的线性地址空间都不同。而且指向这块共享内存的引用计数会增加。也就是进程多块线性空间会指向同一块物理地址。这样，如果之前挂载过这块共享内存的进程的线性地址没有被<code>shmdt</code>掉，即申请的线性地址都没有释放，就会一直消耗进程的虚拟内存空间，很有可能会最后导致进程线性空间被使用完而导致下次 shmat 或者其他操作失败。</p>
<h2 id="shmget-创建共享内存，当-key-相同时，什么情况下会出错？"><a href="#shmget-创建共享内存，当-key-相同时，什么情况下会出错？" class="headerlink" title="shmget 创建共享内存，当 key 相同时，什么情况下会出错？"></a>shmget 创建共享内存，当 key 相同时，什么情况下会出错？</h2><p>当创建一个新的共享内存区时，size 的值必须大于 0；如果是访问一个已经存在的内存共享区，则置 size 为 0。</p>
<p>已经创建的共享内存的大小是可以调整的，但是已经创建的共享内存的大小只能调小，不能调大</p>
<p>当多个进程都能创建共享内存的时候，如果 key 出现相同的情况，并且一个进程需要创建的共享内存的大小要比另外一个进程要创建的共享内存小，共享内存大的进程先创建共享内存，共享内存小的进程后创建共享内存，小共享内存的进程就会获取到大的共享内存进程的共享内存，并修改其共享内存的大小和内容，从而可能导致大的共享内存进程崩溃。</p>
<h2 id="ftok-是否一定会产生唯一的-key-值？"><a href="#ftok-是否一定会产生唯一的-key-值？" class="headerlink" title="ftok 是否一定会产生唯一的 key 值？"></a>ftok 是否一定会产生唯一的 key 值？</h2><p>ftok 原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">key_t</span> <span class="hljs-title">ftok</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * pathname, <span class="hljs-keyword">int</span> proj_id)</span></span><br></code></pre></td></tr></table></figure>

<p><code>pathname</code>就时你指定的文件名，<code>proj_id</code>是子序号。在一般的 UNIX 实现中，是将文件的索引节点号取出，前面加上子序号得到<code>key_t</code>的返回值。如指定文件的索引节点号为 65538，换算成 16 进制为<code>0×010002</code>，而你指定的<code>proj_id</code>值为<code>38</code>，换算成 16 进制为<code>0×26</code>，则最后的<code>key_t</code>返回值为<code>0×26010002</code>。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="../22/">上一页</a>
    </div>
    <div class="pagination-next">
        <a href="../24/">下一页</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="../../">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="../22/">22</a></li>
        
        <li><a class="pagination-link is-current" href="">23</a></li>
        
        <li><a class="pagination-link" href="../24/">24</a></li>
        
        <li><a class="pagination-link" href="../25/">25</a></li>
        
        <li><a class="pagination-link" href="../26/">26</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2024 Dominic&nbsp;
                powered_by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery > p > .gallery-item').unwrap();
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="../../js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '../../content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="../../js/insight.js"></script>

    
</body>
</html>