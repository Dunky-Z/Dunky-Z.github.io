<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>如云泊</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">










<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="../../css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="如云泊" type="application/atom+xml">
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="../../index.html">
                
                <img src="../../images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/06/09/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-watch%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/" itemprop="url">每天学命令-watch 周期执行命令</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-06-09T14:50:54.000Z" itemprop="datePublished">6月 9 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/">每天学命令</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 分钟 lesen (Über 219 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>watch 命令的功能如其名，可以监视命令的执行结果。它实现的原理就是每隔一段时间执行一次命令，然后显示结果。他的用途很广，具体怎么用就靠想象力了。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">n <span class="hljs-comment"># 或--interval  watch默认每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。</span></span><br><span class="ruby"></span>-<span class="ruby">d <span class="hljs-comment"># 或--differences  用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。</span></span><br><span class="ruby"></span>-<span class="ruby">t <span class="hljs-comment"># 或-no-title  会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。</span></span><br><span class="ruby"></span>-<span class="ruby">h <span class="hljs-comment"># 或--help # 查看帮助文档</span></span><br></code></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">watch</span> -d <span class="hljs-string">&#x27;ls -l | grep tmp&#x27;</span>       <span class="hljs-comment"># 监测当前目录中 scf&#x27; 的文件的变化</span><br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/30/Git-hooks%E9%92%A9%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/" itemprop="url">Git hooks 钩子的使用</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-30T04:16:11.000Z" itemprop="datePublished">5月 30 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/Git-%E5%AE%9E%E6%88%98/">Git 实战</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            11 分钟 lesen (Über 1695 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="Git-hooks-简介"><a href="#Git-hooks-简介" class="headerlink" title="Git hooks 简介"></a>Git hooks 简介</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208271329199.png"></p>
<p>Git 能在特定的重要动作发生时触发自定义脚本。比如，<code>commit</code>之前检查<code>commit message</code>是否符合约定的格式，<code>push</code>之前检查代码格式是否正确，是否编译通过等等。Git 就提供了<code>hooks</code>这样的机制。</p>
<p>我们在哪能找到<code>hooks</code>呢？在初始化代码仓库<code>git init</code>时，Git 会自动为我们创建一个<code>.git/hooks</code>目录，里面存放了所有的钩子。因为<code>.git</code>是隐藏目录，显示隐藏目录后就可以找到<code>hooks</code>这个目录。</p>
<p>在 VSCode 里一般默认把<code>.git</code>目录排除显示，所以打开项目目录时不会显示该目录，我们可以收到在 VSCode 显示<code>.git</code>目录：打开设置界面，搜索<code>exclude</code>找到图中的设置，将<code>.git</code>目录从排除列表中移除，即可在 VSCode 中显示<code>.git</code>目录。</p>
<div align=center>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220530134106.png" height = "90%" /> </div>

<p>现在我们找到了<code>hooks</code>，该如何使用呢？<br>所有默认的<code>hooks</code>都是以<code>.sample</code>为后缀，只需要移除<code>.sample</code>即可激活<code>hooks</code>。</p>
<div align=center> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220530154954.png"    alt=""></div>

<p>随便打开一个<code>hooks</code>文件，我们可以发现，实际是<code>hooks</code>就是一个个<code>shell</code>脚本。这些脚本会在特定的动作发生时被执行。示范的这些<code>hooks</code>都是<code>shell</code>脚本，<strong>实际上只要是文件名正确的可执行脚本都可以使用</strong>，如将<code>pre-push</code>内容改为<code>python, Ruby</code>等等脚本都可以。</p>
<h2 id="如何使用一个-hooks"><a href="#如何使用一个-hooks" class="headerlink" title="如何使用一个 hooks"></a>如何使用一个 hooks</h2><p>以<code>pre-commit</code>这个<code>hooks</code>为例，来示范一下如何使用 Git hooks。</p>
<ul>
<li><p>打开<code>.git/hooks/pre-commit.sample</code>，这个<code>hooks</code>的大体功能是检查文件名是否包含非<code>ASCII</code>字符，如果包含，则无法执行<code>commit</code>操作，并提示用户修改文件名。</p>
</li>
<li><p>删除<code>pre-commit.sample</code>的后缀</p>
  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜ mv .git<span class="hljs-regexp">/hooks/</span>pre-commit.sample .git<span class="hljs-regexp">/hooks/</span>pre-commit<br></code></pre></td></tr></table></figure></li>
<li><p>添加一个有汉字的文件名，如<code>测试.md</code></p>
  <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">➜  touch 测试.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure></li>
<li><p>将新文件提交</p>
  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">➜ git <span class="hljs-built_in">add</span> 测试.md<br>➜ git commit -m <span class="hljs-string">&quot;测试&quot;</span><br>Error: Attempt <span class="hljs-built_in">to</span> <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> non-ASCII <span class="hljs-built_in">file</span> name.<br><br>This can cause problems <span class="hljs-keyword">if</span> you want <span class="hljs-built_in">to</span> work <span class="hljs-keyword">with</span> people <span class="hljs-keyword">on</span> <span class="hljs-title">other</span> <span class="hljs-title">platforms</span>.<br><br>To be portable <span class="hljs-keyword">it</span> is advisable <span class="hljs-built_in">to</span> <span class="hljs-built_in">rename</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span>.<br><br>If you know what you are doing you can disable this check <span class="hljs-keyword">using</span>:<br><br>git config hooks.allownonascii <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果无法执行<code>pre-commit</code>可能未被赋予执行权限，修改一下权限即可：<code>chmod +x .git/hooks/pre-commit</code></p>
</blockquote>
</li>
</ul>
<p>我们可以发现，在进行<code>commit</code>操作时被中断了，会提示用户修改文件名。其他的<code>hooks</code>用法类似，我们可以自定义在什么时候可以<code>push</code>，什么时候可以<code>rebase</code>等等。</p>
<p><code>hooks</code>通常会被用来做提交代码前的一个检查，比如风格是否统一，编译是否通过等等。如果团队合作时，这样的检查最好能够与成员保持一致，但是<code>hooks</code>所在的<code>.git</code>目录是不会被Git自己版本管理的，换句话说，它不能推送到远端与成员共享。那么如何解决这个问题呢？</p>
<h2 id="如何同步hooks文件"><a href="#如何同步hooks文件" class="headerlink" title="如何同步hooks文件"></a>如何同步hooks文件</h2><h3 id="方案一：与源码放在一起"><a href="#方案一：与源码放在一起" class="headerlink" title="方案一：与源码放在一起"></a>方案一：与源码放在一起</h3><p>代码仓库中新建一个<code>hooks</code>目录，将该目录同步到远程。其他成员下载代码时也会下载<code>hooks</code>目录，通过脚本的方式将<code>hooks</code>目录覆盖本地的<code>.git/hooks</code>目录。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/bin/bash</span><br>cp -r .<span class="hljs-regexp">/hooks/</span> .git<span class="hljs-regexp">/hooks/</span><br>chmod +x -R .git/hooks<br>echo <span class="hljs-string">&#x27;Hooks sync to remote success!&#x27;</span><br><span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h3 id="方案二：使用pre-commit框架"><a href="#方案二：使用pre-commit框架" class="headerlink" title="方案二：使用pre-commit框架"></a>方案二：使用pre-commit框架</h3><p><code>pre_commit</code> 是 <code>pre-commit</code> 同名的开源应用，使用<code>pre-commit</code>，代码仓库里只需要有一个配置文件，所有成员都可以根据配置文件，使用<code>pre_commit</code>生成统一的<code>hooks</code>。</p>
<p><code>pre-commit</code>随着发展，已经不单单只能用于<code>git hooks的pre-commit</code>阶段，而是能作用于所有<code>git hooks</code>的所有阶段，如上面说的<code>prepare-commit-msg</code>, <code>commit-msg</code>, <code>post-commi</code>等。</p>
<p>安装pre-commit</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pre-commit<br></code></pre></td></tr></table></figure>

<p>在项目目录下，添加配置文件 <code>.pre-commit-config.yaml</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">touch .pre-commit-config.yaml<br></code></pre></td></tr></table></figure>

<ul>
<li><p>首先了解配置的格式</p>
<ul>
<li>顶层有一个参数名为 <code>repos</code></li>
<li><code>repos</code> 中每个元素为 <code>repo</code> ，代表一个代码库，一般是<code>github</code>或<code>gitlab</code>链接。在使用时会从对应地址下载，如果出现下载慢的情况，可以在<code>gitee</code>搜索是否有相关镜像。</li>
<li>每个 <code>repo</code> 中有一个或多个 <code>hook</code> ，每个 <code>hook</code> 代表一个任务。</li>
<li>每个任务里可理解为一个命令行指令，例如<code>flake8/yapf/black</code>。</li>
</ul>
</li>
<li><p><code>pre_commit</code>官方提供了<a target="_blank" rel="noopener" href="https://pre-commit.com/hooks.html">各种配置</a>，我们可以根据需要选择一个合适的。比如我需要一个格式化C语言代码的配置，选择了<a target="_blank" rel="noopener" href="https://github.com/pre-commit/mirrors-clang-format">mirrors-clang-format</a>，还选了一个用来删除行尾空格的。</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">repos:</span><br><span class="hljs-bullet">-</span>   <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/pre-commit/pre-commit-hooks</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v4.3.0</span><br>    <span class="hljs-attr">hooks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">trailing-whitespace</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/pre-commit/mirrors-clang-format</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v14.0.6</span><br>    <span class="hljs-attr">hooks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">clang-format</span><br>        <span class="hljs-attr">types_or:</span> [<span class="hljs-string">c</span>]<br></code></pre></td></tr></table></figure>

<p>  参数的含义可以参考<a target="_blank" rel="noopener" href="https://pre-commit.com/#pre-commit-configyaml---top-level">pre-commit</a>的文档。每个id对应的其实都是一个程序，为了保证都能正常运行，还需要安装这些程序。一般在仓库的<code>README</code>中都会有提示如何安装。</p>
</li>
<li><p>根据配置文件安装<code>hooks</code><br>  在项目根目录下运行：</p>
  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pre-commit <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure></li>
<li><p>在执行<code>git commit</code>命令时将会自动检查。这个过程中，<code>pre-commit</code>会从仓库里下载代码，然后根据里面的配置执行相应的脚本。完成各种检查。</p>
</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 手动对所有的文件执行 hooks，新增 hook 的时候可以执行，使得代码均符合规范。直接执行该指令则无需等到 pre-commit 阶段再触发 hooks</span><br>pre-commit run --all-files<br><span class="hljs-comment"># 执行特定 hooks</span><br>pre-commit run &lt;hook_id&gt;<br><span class="hljs-comment"># 将所有的hook更新到最新的版本/tag</span><br>pre-commit autoupdate<br><span class="hljs-comment"># 指定更新 repo</span><br>pre-commit autoupdate --repo https://github.com/pre-commit/mirrors-clang-format<br></code></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/irving512/article/details/124377109">C++ 项目中使用 Pre-commit 协助实现代码规范检查_清欢守护者的博客-CSDN 博客</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7951ff907ccb">git push 之前自动编译验证 - 简书</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/irving512/article/details/108701017">使用 pre-commit 实现代码检查_清欢守护者的博客-CSDN 博客</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://pre-commit.com/#pre-commit-configyaml---top-level">pre-commit</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eZ4y1G7hh/?spm_id_from=333.788">Git 基本原理介绍 (32)——git hook 和 python_哔哩哔哩_bilibili</a></p>
</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/29/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7MESI%E5%8D%8F%E8%AE%AE/" itemprop="url">CPU 缓存一致性 MESI 协议</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-29T07:04:59.000Z" itemprop="datePublished">5月 29 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            10 分钟 lesen (Über 1509 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="为什么需要缓存一致"><a href="#为什么需要缓存一致" class="headerlink" title="为什么需要缓存一致"></a>为什么需要缓存一致</h2><p>目前主流电脑的 CPU 都是多核心的，多核心的有点就是在不能提升 CPU 主频后，通过增加核心来提升 CPU 吞吐量。每个核心都有自己的 L1 Cache 和 L2 Cache，只是共用 L3 Cache 和主内存。每个核心操作是独立的，每个核心的 Cache 就不是同步更新的，这样就会带来缓存一致性（Cache Coherence）的问题。</p>
<p>举个例子，如图：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205291536919.gif"></p>
<p>有 2 个 CPU，主内存里有个变量<code>x=0</code>。CPU A 中有个需要将变量<code>x</code>加<code>1</code>。CPU A 就将变量<code>x</code>加载到自己的缓存中，然后将变量<code>x</code>加<code>1</code>。因为此时 CPU A 还未将缓存数据写回主内存，CPU B 再读取变量<code>x</code>时，变量<code>x</code>的值依然是<code>0</code>。</p>
<p>这里的问题就是所谓的缓存一致性问题，因为 CPU A 的缓存与 CPU B 的缓存是不一致的。</p>
<h2 id="如何解决缓存一致性问题"><a href="#如何解决缓存一致性问题" class="headerlink" title="如何解决缓存一致性问题"></a>如何解决缓存一致性问题</h2><h3 id="通过在总线加-LOCK-锁的方式"><a href="#通过在总线加-LOCK-锁的方式" class="headerlink" title="通过在总线加 LOCK 锁的方式"></a>通过在总线加 LOCK 锁的方式</h3><p>在锁住总线上加一个 LOCK 标识，CPU A 进行读写操作时，锁住总线，其他 CPU 此时无法进行内存读写操作，只有等解锁了才能进行操作。</p>
<p>该方式因为锁住了整个总线，所以效率低。</p>
<h3 id="缓存一致性协议-MESI"><a href="#缓存一致性协议-MESI" class="headerlink" title="缓存一致性协议 MESI"></a>缓存一致性协议 MESI</h3><p>该方式对单个缓存行的数据进行加锁，不会影响到内存其他数据的读写。</p>
<p>在学习 MESI 协议之前，简单了解一下总线嗅探机制（Bus Snooping）。要对自己的缓存加锁，需要通知其他 CPU，多个 CPU 核心之间的数据传播问题。最常见的一种解决方案就是总线嗅探。</p>
<p>这个策略，本质上就是把所有的读写请求都通过总线广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。MESI 就是基于总线嗅探机制的缓存一致性协议。</p>
<p>MESI 协议的由来是对 Cache Line 的四个不同的标记，分别是：</p>
<table>
<thead>
<tr>
<th align="center"><div style="width:50px">状态</div></th>
<th align="center"><div style="width:100px">状态</div></th>
<th><div style="width:200px">描述</div></th>
<th><div style="width:200px">监听任务</div></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Modified</td>
<td align="center">已修改</td>
<td>该 Cache Line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中</td>
<td>Cache Line 必须时刻监听所有试图读该 Cache Line 相对于主存的操作，这种操作必须在缓存将该 Cache Line 写回主存并将状态改为 S 状态之前，被延迟执行</td>
</tr>
<tr>
<td align="center">Exclusive</td>
<td align="center">独享，互斥</td>
<td>该 Cache Line 有效，数据和内存中的数据一直，数据只存在于本 Cache</td>
<td>Cache Line 必须监听其他缓存读主存中该 Cache Line 的操作，一旦有这种操作，该 Cache Line 需要改为 S 状态</td>
</tr>
<tr>
<td align="center">Shared</td>
<td align="center">共享的</td>
<td>该 Cache Line 有效，数据和内存中的数据一直，数据存在于很多个 Cache 中</td>
<td>Cache Line 必须监听其他  Cache Line 使该 Cache Line 无效或者独享该 Cache Line 的请求，并将 Cache Line 改为 I 状态</td>
</tr>
<tr>
<td align="center">Invalid</td>
<td align="center">无效的</td>
<td>该 Cache Line 无效</td>
<td>无</td>
</tr>
</tbody></table>
<p>整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把各个状态之间的流转用表格总结了一下：</p>
<table>
<thead>
<tr>
<th align="center"><div style="width:80px">当前状态</div></th>
<th align="center"><div style="width:80px">事件</div></th>
<th><div style="width:300px,center">行为</div></th>
<th align="center"><div style="width:80px">下个状态</div></th>
</tr>
</thead>
<tbody><tr>
<td align="center">M</td>
<td align="center">Local Read</td>
<td>从 Cache 中读，状态不变</td>
<td align="center">M</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">Local Write</td>
<td>修改 cache 数据，状态不变</td>
<td align="center">M</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">Remote Read</td>
<td>这行数据被写到内存中，使其他核能使用到最新数据，状态变为 S</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">Remote Write</td>
<td>这行数据被写入内存中，其他核可以获取到最新数据，由于其他 CPU 修改该条数据，则本地 Cache 变为 I</td>
<td align="center">I</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><div style="width:80px">当前状态</div></th>
<th align="center"><div style="width:80px">事件</div></th>
<th><div style="width:200px,center">行为</div></th>
<th align="center"><div style="width:80px">下个状态</div></th>
</tr>
</thead>
<tbody><tr>
<td align="center">E</td>
<td align="center">Local Read</td>
<td>从 Cache 中读，状态不变</td>
<td align="center">E</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">Local Write</td>
<td>修改数据，状态改为 M</td>
<td align="center">M</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">Remote Read</td>
<td>数据和其他 CPU 共享，变为 S</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">Remote Write</td>
<td>数据被修改，本地缓存失效，变为 I</td>
<td align="center">I</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><div style="width:80px">当前状态</div></th>
<th align="center"><div style="width:80px">事件</div></th>
<th><div style="width:200px,text-align: center">行为</div></th>
<th align="center"><div style="width:80px">下个状态</div></th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">Local Read</td>
<td>从 Cache 中读，状态不变</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">Local Write</td>
<td>修改数据，状态改为 M，其他 CPU 的 Cache Line 状态改为 I</td>
<td align="center">M</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">Remote Read</td>
<td>数据和其他 CPU 共享，状态不变</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">Remote Write</td>
<td>数据被修改，本地缓存失效，变为 I</td>
<td align="center">I</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><div style="width:80px">当前状态</div></th>
<th align="center"><div style="width:80px">事件</div></th>
<th><div style="width:200px,center">行为</div></th>
<th align="center"><div style="width:80px">下个状态</div></th>
</tr>
</thead>
<tbody><tr>
<td align="center">I</td>
<td align="center">Local Read</td>
<td>1. 如果其他 CPU 没有这份数据，直接从内存中加载数据，状态变为 E；<br> 2. 如果其他 CPU 有这个数据，且 Cache Line 状态为 M，则先把 Cache Line 中的内容写回到主存。本地 Cache 再从内存中读取数据，这时两个 Cache Line 的状态都变为 S；<br>3. 如果其他 Cache Line 有这份数据，并且状态为 S 或者 E，则本地 Cache Line 从主存读取数据，并将这些 Cache Line 状态改为 S</td>
<td align="center">E 或者 S</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">Local Write</td>
<td>1. 先从内存中读取数据，如果其他 Cache Line 中有这份数据，且状态为 M，则现将数据更新到主存再读取，将 Cache Line 状态改为 M；<br> 2. 如果其他 Cache Line 有这份数据，且状态为 E 或者 S，则其他 Cache Line 状态改为 I</td>
<td align="center">M</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">Remote Read</td>
<td>数据和其他 CPU 共享，状态不变</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">Remote Write</td>
<td>数据被修改，本地缓存失效，变为 I</td>
<td align="center">I</td>
</tr>
</tbody></table>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/24/VSCode%E8%AE%BE%E7%BD%AE%E7%BB%88%E7%AB%AF%E4%B8%BAGitbash/" itemprop="url">VSCode 设置终端为 Gitbash</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-24T06:42:48.000Z" itemprop="datePublished">5月 24 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E4%B8%87%E8%83%BD-VSCode/">万能 VSCode</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 lesen (Über 364 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="设置终端为-Gitbash"><a href="#设置终端为-Gitbash" class="headerlink" title="设置终端为 Gitbash"></a>设置终端为 Gitbash</h2><p>用惯了 Linux 终端的命令，Windows 的 shell 真的太不顺手了，但是 Gitbash 很多命令相似，可以将默认的 shell 换成 Gitbash。</p>
<p>打开<code>settings.json</code>配置文件，添加如下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;terminal.integrated.profiles.windows&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;PowerShell -NoProfile&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;source&quot;</span>: <span class="hljs-string">&quot;PowerShell&quot;</span>,<br>      <span class="hljs-attr">&quot;args&quot;</span>: [<br>        <span class="hljs-string">&quot;-NoProfile&quot;</span><br>      ]<br>    &#125;,<br>    <span class="hljs-attr">&quot;Git-Bash&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;D:\\Software\\Git\\bin\\bash.exe&quot;</span>, <span class="hljs-comment">//bin路径下的bash，不是git-bash.exe。否则会打开外部窗口</span><br>      <span class="hljs-attr">&quot;args&quot;</span>: []<br>    &#125;<br>  &#125;,<br><span class="hljs-string">&quot;terminal.integrated.defaultProfile.windows&quot;</span>: <span class="hljs-string">&quot;Git-Bash&quot;</span>,<br></code></pre></td></tr></table></figure>

<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301517302.png"></p>
<h2 id="修改终端配色"><a href="#修改终端配色" class="headerlink" title="修改终端配色"></a>修改终端配色</h2><p>打开<a target="_blank" rel="noopener" href="https://glitchbone.github.io/vscode-base16-term/#/">Base16 Terminal Colors for Visual Studio Code</a>，选择一款配置复制</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301515778.png"></p>
<p>打开 VScode<code>settings.json</code>，替换如下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;workbench.colorCustomizations&quot;</span>: &#123;<br>       <span class="hljs-attr">&quot;terminal.background&quot;</span>:<span class="hljs-string">&quot;#1C2023&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.foreground&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminalCursor.background&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminalCursor.foreground&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBlack&quot;</span>:<span class="hljs-string">&quot;#1C2023&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBlue&quot;</span>:<span class="hljs-string">&quot;#AE95C7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightBlack&quot;</span>:<span class="hljs-string">&quot;#747C84&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightBlue&quot;</span>:<span class="hljs-string">&quot;#AE95C7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightCyan&quot;</span>:<span class="hljs-string">&quot;#95AEC7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightGreen&quot;</span>:<span class="hljs-string">&quot;#95C7AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightMagenta&quot;</span>:<span class="hljs-string">&quot;#C795AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightRed&quot;</span>:<span class="hljs-string">&quot;#C7AE95&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightWhite&quot;</span>:<span class="hljs-string">&quot;#F3F4F5&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightYellow&quot;</span>:<span class="hljs-string">&quot;#AEC795&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiCyan&quot;</span>:<span class="hljs-string">&quot;#95AEC7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiGreen&quot;</span>:<span class="hljs-string">&quot;#95C7AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiMagenta&quot;</span>:<span class="hljs-string">&quot;#C795AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiRed&quot;</span>:<span class="hljs-string">&quot;#C7AE95&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiWhite&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiYellow&quot;</span>:<span class="hljs-string">&quot;#AEC795&quot;</span><br>   &#125;,<br></code></pre></td></tr></table></figure>

<p>修改后效果</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301517302.png"></p>
<h2 id="修改终端字体"><a href="#修改终端字体" class="headerlink" title="修改终端字体"></a>修改终端字体</h2><p>方法一：打开 VScode<code>settings.json</code>，加上下面这个配置，字体改成自己电脑上的字体</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="hljs-string">&quot;JetBrains Mono&quot;</span>,<br><br></code></pre></td></tr></table></figure>

<p>方法二：打开设置页面，搜索<code>terminal font</code></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220524142319.png"></p>
<p>修改后的效果</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220524142612.png"></p>
<h2 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/23/CPU%E4%BA%B2%E5%92%8C%E6%80%A7%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%BA%B2%E5%92%8C%E6%80%A7/" itemprop="url">CPU 亲和性与中断亲和性</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-23T14:38:14.000Z" itemprop="datePublished">5月 23 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            35 分钟 lesen (Über 5283 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HwDqCk8vtMdSEVSCLHAsbg">超线程技术 (Hyper-Threading)</a>：就是利用特殊的硬件指令，把两个逻辑内核 (CPU core) 模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了 CPU 的闲置时间，提高的 CPU 的运行效率。</p>
<p>我们常听到的双核四线程/四核八线程指的就是支持超线程技术的CPU.</p>
<p><strong>物理 CPU</strong>：机器上安装的实际 CPU, 比如说你的主板上安装了一个 8 核 CPU，那么物理 CPU 个数就是 1 个，所以物理 CPU 个数就是主板上安装的 CPU 个数。</p>
<p><strong>逻辑 CPU</strong>：一般情况，我们认为一颗 CPU 可以有多核，加上 Intel 的超线程技术 (HT), 可以在逻辑上再分一倍数量的 CPU core 出来；</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">逻辑<span class="hljs-meta">CPU</span>数量 = 物理<span class="hljs-meta">CPU</span>数量 x <span class="hljs-meta">CPU</span> cores x <span class="hljs-number">2</span>(如果支持并开启HT) //前提是<span class="hljs-meta">CPU</span>的型号一致，如果不一致只能一个一个的加起来，不用直接乘以物理<span class="hljs-meta">CPU</span>数量<br>//比如你的电脑安装了一块<span class="hljs-number">4</span>核<span class="hljs-meta">CPU</span>，并且支持且开启了超线程（HT）技术，那么逻辑<span class="hljs-meta">CPU</span>数量 = <span class="hljs-number">1</span> × <span class="hljs-number">4</span> × <span class="hljs-number">2</span> = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>

<p><strong>Linux 下查看 CPU 相关信息</strong>, CPU 的信息主要都在<code>/proc/cupinfo</code>中。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># 查看物理CPU个数<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;physical id&quot;</span>|<span class="hljs-keyword">sort</span> -u|wc -l<br><span class="hljs-number">32</span><br><br># 查看每个物理CPU中core的个数(即核数)<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;cpu cores&quot;</span>|uniq<br><span class="hljs-number">1</span><br># 或者<br>➜    cat <span class="hljs-regexp">/proc/</span>cpuinfo | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;process&#x27;</span> | <span class="hljs-keyword">sort</span> | uniq | wc -l<br><span class="hljs-number">1</span><br><br># 查看逻辑CPU的个数<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;processor&quot;</span>|wc -l<br><span class="hljs-number">32</span><br><br># 查看CPU的名称型号<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;name&quot;</span>|cut -f2 -d:|uniq<br>Intel Xeon Processor (Skylake, IBRS)<br></code></pre></td></tr></table></figure>

<p><strong>Linux 查看某个进程运行在哪个逻辑 CPU 上</strong></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -eo pid,<span class="hljs-keyword">args</span>,psr<br></code></pre></td></tr></table></figure>

<ul>
<li><code>pid</code>：进程 ID</li>
<li><code>args</code>：该进程执行时传入的命令行参数</li>
<li><code>psr</code>：分配给进程的逻辑 CPU</li>
</ul>
<p>例子：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle">➜  ps -eo pid,args,psr | <span class="hljs-keyword">grep</span> firefox<br><span class="hljs-number">20118</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -n  <span class="hljs-number">13</span><br><span class="hljs-number">20208</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c   <span class="hljs-number">9</span><br><span class="hljs-number">20266</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">29</span><br><span class="hljs-number">20329</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">24</span><br><span class="hljs-number">20499</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c   <span class="hljs-number">7</span><br><span class="hljs-number">20565</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">15</span><br><span class="hljs-number">20596</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">24</span><br><span class="hljs-number">20760</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">18</span><br><span class="hljs-number">22110</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">27</span><br><span class="hljs-number">25857</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">28</span><br><span class="hljs-number">26347</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">19</span><br><span class="hljs-number">26899</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">29</span><br></code></pre></td></tr></table></figure>

<p><strong>Linux 查看线程的 TID</strong></p>
<p>TID 就是 Thread ID，他和 POSIX 中<code>pthread_t</code>表示的线程 ID 完全不是同一个东西。</p>
<p>Linux 中的 POSIX 线程库实现的线程其实也是一个轻量级进程 (LWP),这个 TID 就是这个线程的真实 PID.</p>
<p>但是又不能通过<code>getpid()</code>函数获取，Linux 中定义了<code>gettid()</code>这个接口，但是通常都是未实现的，所以需要使用下面的方式获取 TID。</p>
<p>使用 API 获取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span>  </span><br><span class="hljs-keyword">pid_t</span> tid;<br>tid = <span class="hljs-built_in">syscall</span>(__NR_gettid); <span class="hljs-comment">// or syscall(SYS_gettid)  </span><br></code></pre></td></tr></table></figure>

<p>命令行方式获取：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 3种方法(推荐第三种方法)</span><br>➜  <span class="hljs-built_in">ps</span> <span class="hljs-literal">-efL</span> | grep prog_name<br>➜  <span class="hljs-built_in">ls</span> /proc/pid/task      //文件夹名即TID<br>➜  <span class="hljs-built_in">ps</span> <span class="hljs-literal">-To</span> <span class="hljs-string">&#x27;pid,lwp,psr,cmd&#x27;</span> <span class="hljs-literal">-p</span> PID<br></code></pre></td></tr></table></figure>

<h2 id="什么是-CPU-亲和性"><a href="#什么是-CPU-亲和性" class="headerlink" title="什么是 CPU 亲和性"></a>什么是 CPU 亲和性</h2><p>CPU 的亲和性 (Affinity)，属于一种调度属性，可以绑定进程到指定 CPU 上。 换句话说，就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器。</p>
<p>为何会出现这种技术？在 SMP(Symmetric Multi-Processing 对称多处理) 架构下，调度器会试图保持进程在相同的 CPU 上运行，这意味着进程通常不会在处理器之间频繁迁移，进程迁移的频率小就意味着产生的负载小。</p>
<p>又如，每个 CPU 本身自己会有缓存，缓存着进程使用的信息，而进程可能会被操作系统调度到其他 CPU 上，如此，CPU 缓存命中率就低了，当绑定 CPU 后，程序就会一直在指定的 CPU 跑，不会由操作系统调度到其他 CPU 上，性能有一定的提高。</p>
<p><strong>软亲和性</strong>:  就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，Linux 内核进程调度器天生就具有被称为 软 CPU 亲和性（affinity）的特性，这意味着进程通常不会在处理器之间频繁迁移。这种状态正是我们希望的，因为进程迁移的频率小就意味着产生的负载小。</p>
<p><strong>硬亲和性</strong>：简单来说就是利用 Linux 内核提供给用户的 API，强行将进程或者线程绑定到某一个指定的 CPU 核运行。</p>
<p>CPU affinity 使用位掩码 (bitmask) 表示，每一位都表示一个 CPU, 置 1 表示”绑定”。最低位表示第一个逻辑 CPU, 最高位表示最后一个逻辑 CPU。</p>
<p>CPU affinity 典型的表示方法是使用 16 进制，具体如下。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">0b00000000000000000000000000000001<br><span class="hljs-section">= 0x00000001</span><br>表示 processor #0<br><br>0b00000000000000000000000001010101<br><span class="hljs-section">= 0x00000055</span><br>表示 processors #0, #2, #4, #6<br><br>0b11111111111111111111111111111111<br><span class="hljs-section">= 0xFFFFFFFF</span><br>表示所有 processors (#0 through #31)<br></code></pre></td></tr></table></figure>

<h2 id="使用taskset命令设置-CPU-亲和性"><a href="#使用taskset命令设置-CPU-亲和性" class="headerlink" title="使用taskset命令设置 CPU 亲和性"></a>使用<code>taskset</code>命令设置 CPU 亲和性</h2><p><strong>命令行形式</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">taskset <span class="hljs-selector-attr">[options]</span> <span class="hljs-attribute">mask</span> command <span class="hljs-selector-attr">[arg]</span>...<br>taskset <span class="hljs-selector-attr">[options]</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-selector-attr">[mask]</span> pid<br></code></pre></td></tr></table></figure>

<p><strong>参数解析</strong><br>[OPTIONS]taskset 的可选参数</p>
<ul>
<li><p><code>-a, --all-tasks</code> (旧版本中没有这个选项)</p>
<pre><code class="hljs">  这个选项涉及到了linux中TID的概念,他会将一个进程中所有的TID都执行一次CPU亲和性设置.
  TID 就是 Thread ID，他和 POSIX 中 pthread_t 表示的线程 ID 完全不是同一个东西。
  Linux中的POSIX线程库实现的线程其实也是一个进程(LWP),这个TID就是这个线程的真实PID.
</code></pre>
</li>
<li><p><code>-p, --pid</code></p>
<pre><code class="hljs">  操作已存在的PID,而不是加载一个新的程序
</code></pre>
</li>
<li><p><code>-c, --cpu-list</code></p>
<pre><code class="hljs">        声明CPU的亲和力使用数字表示而不是用位掩码表示. 例如 0,5,7,9-11.
</code></pre>
</li>
<li><p><code>-h, --help</code></p>
<pre><code class="hljs">  显示帮助信息
</code></pre>
</li>
<li><p><code>-V, --version</code></p>
<pre><code class="hljs">  显示版本信息
</code></pre>
</li>
<li><p><code>mask</code> : cpu 亲和性，当没有<code>-c</code>选项时，其值前无论有没有<code>0x</code>标记都是 16 进制的，当有<code>-c</code>选项时，其值是十进制的。</p>
</li>
<li><p><code>command</code> : 命令或者可执行程序</p>
</li>
<li><p><code>pid</code> : 进程 ID，可以通过<code>ps/top/pidof</code>等命令获取</p>
</li>
</ul>
<p><code>[arg]</code> command 的参数</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="使用指定的-CPU-亲和性运行一个新程序"><a href="#使用指定的-CPU-亲和性运行一个新程序" class="headerlink" title="使用指定的 CPU 亲和性运行一个新程序"></a>使用指定的 CPU 亲和性运行一个新程序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskset [-c] mask <span class="hljs-built_in">command</span> [arg]...<br><span class="hljs-comment"># 举例: 使用CPU0运行ls命令显示/etc/init.d下的所有内容</span><br>taskset -c 0 ls -al /etc/init.d/<br></code></pre></td></tr></table></figure>

<h4 id="显示已经运行的进程的-CPU-亲和性"><a href="#显示已经运行的进程的-CPU-亲和性" class="headerlink" title="显示已经运行的进程的 CPU 亲和性"></a>显示已经运行的进程的 CPU 亲和性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskset -p pid<br><span class="hljs-comment"># 举例:查看init进程(PID=1)的CPU亲和性</span><br>taskset -p 1<br></code></pre></td></tr></table></figure>

<h4 id="改变已经运行进程的-CPU-亲和性"><a href="#改变已经运行进程的-CPU-亲和性" class="headerlink" title="改变已经运行进程的 CPU 亲和性"></a>改变已经运行进程的 CPU 亲和性</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq">taskset -p[c] mask pid<br>举例:打开<span class="hljs-number">2</span>个终端,在第一个终端运行<span class="hljs-built_in">top</span>命令,第二个终端中<br> 　　首先运行:[~]# ps -eo pid,args,psr | <span class="hljs-type">grep</span> <span class="hljs-built_in">top</span> #获取<span class="hljs-built_in">top</span>命令的pid和其所运行的CPU号<br> 　　其次运行:[~]# taskset -cp 新的CPU号 pid       #更改<span class="hljs-built_in">top</span>命令运行的CPU号<br> 　　最后运行:[~]# ps -eo pid,args,psr | <span class="hljs-type">grep</span> <span class="hljs-built_in">top</span> #查看是否更改成功<br></code></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">ps</span> <span class="hljs-string">-eo</span> <span class="hljs-string">pid,args,psr</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">top</span><br><span class="hljs-number">2501 </span><span class="hljs-string">nautilus-desktop</span>             <span class="hljs-number">24</span><br><span class="hljs-number">2634</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">18</span><br><span class="hljs-number">2658</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">11</span><br><span class="hljs-number">23848</span> <span class="hljs-string">top</span>                           <span class="hljs-number">6</span><br><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">taskset</span> <span class="hljs-string">-cp</span> <span class="hljs-number">10</span> <span class="hljs-number">23848</span><br><span class="hljs-string">pid</span> <span class="hljs-number">23848</span><span class="hljs-string">&#x27;s current affinity list: 0-31</span><br><span class="hljs-string">pid 23848&#x27;</span><span class="hljs-attr">s new affinity list:</span> <span class="hljs-number">10</span><br><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">ps</span> <span class="hljs-string">-eo</span> <span class="hljs-string">pid,args,psr</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">top</span><br> <span class="hljs-number">2501 </span><span class="hljs-string">nautilus-desktop</span>             <span class="hljs-number">24</span><br> <span class="hljs-number">2634</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">18</span><br> <span class="hljs-number">2658</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">11</span><br><span class="hljs-number">23848</span> <span class="hljs-string">top</span>                          <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>一个用户要设定一个进程的 CPU 亲和性，如果目标进程是该用户的，则可以设置，如果是其他用户的，则会设置失败，提示 Operation not permitted.当然 root 用户没有任何限制。<br>任何用户都可以获取任意一个进程的 CPU 亲和性。</p>
</blockquote>
<h2 id="程序-API-实现硬亲和性"><a href="#程序-API-实现硬亲和性" class="headerlink" title="程序 API 实现硬亲和性"></a>程序 API 实现硬亲和性</h2><p>以下实验使用的源码可以从<a target="_blank" rel="noopener" href="https://github.com/Dunky-Z/learning-linux/tree/main/Affinity">这个仓库</a>获取。</p>
<p>以下是一些设置亲和性时会用到的宏定义及函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span> <span class="hljs-comment">//注意&lt;pthread.h&gt;包含&lt;sched.h&gt;</span></span><br><br><span class="hljs-comment">/* MACRO */</span><br>        <span class="hljs-comment">// 对 CPU 集初始化，将其设置为空集</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_ZERO</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_ZERO_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 将 CPU 加入到 CPU 集中</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_SET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_SET_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 将 CPU 从 CPU 集中移除</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_CLR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_CLR_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 判断 CPU 是否在 CPU 集中</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_ISSET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_ISSET_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 计算 CPU 集的大小</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_COUNT</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_COUNT_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// The following macros perform logical operations on CPU sets </span><br>        <span class="hljs-comment">/* Store the logical AND of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_AND</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_AND_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Store the logical OR of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_OR</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_OR_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Store  the logical XOR of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_XOR</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_XOR_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Test whether two CPU set contain exactly the same CPUs. */</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_EQUAL</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *set1, <span class="hljs-keyword">cpu_set_t</span> *set2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_EQUAL_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *set1, <span class="hljs-keyword">cpu_set_t</span> *set2)</span></span>;<br>    <br>    <span class="hljs-comment">/* The following macros are used to allocate and deallocate CPU sets: */</span><br>        <span class="hljs-comment">/* Allocate a CPU set large enough to hold CPUs in the range 0 to num_cpus-1 */</span><br>        <span class="hljs-function"><span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-title">CPU_ALLOC</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num_cpus)</span></span>;<br>    <br>        <span class="hljs-comment">/* Return the size in bytes of the CPU set that would be needed to  hold  CPUs  in the  range 0 to num_cpus-1. </span><br><span class="hljs-comment">           This macro provides the value that can be used for the setsize argument in the CPU_*_S() macros */</span><br>        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">CPU_ALLOC_SIZE</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num_cpus)</span></span>;<br>        <br>        <span class="hljs-comment">/* Free a CPU set previously allocated by CPU_ALLOC(). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_FREE</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br><br><span class="hljs-comment">/* API */</span><br>    <span class="hljs-comment">/*该函数设置进程为 pid 的这个进程，让它运行在 mask 所设定的 CPU 上。如果 pid 的值为 0,</span><br><span class="hljs-comment">    *则表示指定的是当前进程，使当前进程运行在 mask 所设定的那些 CPU 上.</span><br><span class="hljs-comment">    *第二个参数 cpusetsize 是 mask 所指定的数的长度。通常设定为 sizeof(cpu_set_t).</span><br><span class="hljs-comment">    *如果当前 pid 所指定的进程此时没有运行在 mask 所指定的任意一个 CPU 上，</span><br><span class="hljs-comment">    *则该指定的进程会从其它 CPU 上迁移到 mask 的指定的一个 CPU 上运行.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sched_setaffinity</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *mask)</span></span>;<br>    <span class="hljs-comment">/*该函数获得 pid 所指示的进程的 CPU 位掩码，并将该掩码返回到 mask 所指向的结构中.</span><br><span class="hljs-comment">    *即获得指定 pid 当前可以运行在哪些 CPU 上.</span><br><span class="hljs-comment">    *同样，如果 pid 的值为 0.也表示的是当前进程</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sched_getaffinity</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *mask)</span></span>;<br>    <br>    <span class="hljs-comment">/* set CPU affinity attribute in thread attributes object */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_attr_setaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_attr_t</span> *attr, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">const</span> <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <span class="hljs-comment">/* get CPU affinity attribute in thread attributes object */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_attr_getaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_attr_t</span> *attr, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <br>    <span class="hljs-comment">/* set CPU affinity of a thread */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_setaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">const</span> <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <span class="hljs-comment">/* get CPU affinity of a thread */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_getaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br></code></pre></td></tr></table></figure>

<p>程序中会使用<code>syscall</code>来获取一些内核数据，<code>syscall</code>是执行一个系统调用，根据指定的参数<code>number</code>和所有系统调用的接口来确定调用哪个系统调用，用于用户空间跟内核之间的数据交换，下面是<code>syscall</code>函数原型及一些常用的<code>number</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//syscall - indirect system call</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE         <span class="hljs-comment">/* See feature_test_macros(7) */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span>   <span class="hljs-comment">/* For SYS_xxx definitions */</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number, ...)</span></span>;<br><br><span class="hljs-comment">// 查看缓存内存页面的大小；打印用%ld 长整型。</span><br>sysconf(_SC_PAGESIZE);  <br><span class="hljs-comment">// 查看内存的总页数；打印用%ld 长整型。</span><br>sysconf(_SC_PHYS_PAGES) <br><span class="hljs-comment">// 查看可以利用的总页数；打印用%ld 长整型。</span><br>sysconf(_SC_AVPHYS_PAGES) <br><span class="hljs-comment">// 查看 CPU 的个数；打印用%ld 长整。</span><br>sysconf(_SC_NPROCESSORS_CONF) <br><span class="hljs-comment">// 查看在使用的 CPU 个数；打印用%ld 长整。</span><br>sysconf(_SC_NPROCESSORS_ONLN) <br><span class="hljs-comment">// 计算内存大小。</span><br>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)sysconf(_SC_PAGESIZE) * (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)sysconf(_SC_PHYS_PAGES) <br><span class="hljs-comment">// 查看最大登录名长度；打印用%ld 长整。</span><br>sysconf(_SC_LOGIN_NAME_MAX) <br><span class="hljs-comment">// 查看最大主机长度；打印用%ld 长整。</span><br>sysconf(_SC_HOST_NAME_MAX) <br><span class="hljs-comment">// 每个进程运行时打开的文件数目；打印用%ld 长整。</span><br>sysconf(_SC_OPEN_MAX)  <br><span class="hljs-comment">// 查看每秒中跑过的运算速率；打印用%ld 长整。</span><br>sysconf(_SC_CLK_TCK) <br><br></code></pre></td></tr></table></figure>

<h3 id="使用-2-种方式-带和不带-S-后缀的宏-获取当前进程的-CPU-亲和性"><a href="#使用-2-种方式-带和不带-S-后缀的宏-获取当前进程的-CPU-亲和性" class="headerlink" title="使用 2 种方式 (带和不带_S 后缀的宏) 获取当前进程的 CPU 亲和性"></a>使用 2 种方式 (带和不带_S 后缀的宏) 获取当前进程的 CPU 亲和性</h3><p>相关的宏通常都分为 2 种，一种是带<code>_S</code>后缀的，一种不是不带<code>_S</code>后缀的，从声明上看带<code>_S</code>后缀的宏都多出一个参数 <code>setsize</code>。</p>
<p>从功能上看他们的区别是带<code>_S</code>后缀的宏是用于操作动态申请的<code>CPU set(s)</code>，所谓的动态申请其实就是使用宏 <code>CPU_ALLOC</code> 申请，</p>
<p>参数 <code>setsize</code> 可以是通过宏 <code>CPU_ALLOC_SIZE</code> 获得，两者的用法详见下面的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> WITH_S</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WITH_S</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> *pmask;<br>    <span class="hljs-keyword">size_t</span> cpusize;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 获取逻辑 CPU 个数 */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br><br>    pmask = CPU_ALLOC(nrcpus);<br>    cpusize = CPU_ALLOC_SIZE(nrcpus);<br>    CPU_ZERO_S(cpusize, pmask);<br><br>    <span class="hljs-comment">/* 获取 CPU 亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, cpusize, pmask) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        CPU_FREE(pmask);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET_S(i, cpusize, pmask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    CPU_FREE(pmask);<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br><br>    CPU_ZERO(&amp;mask);<br><br>    <span class="hljs-comment">/* 获取 CPU 亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取逻辑 CPU 个数 */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(i, &amp;mask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs delphi"># 直接运行，不设置亲和性，获取CPU亲和性为所有CPU都会被设置<br>➜  Affinity git:(main)   ./bin/main <br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#5</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#6</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#7</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#8</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#9</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#10</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#11</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#12</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#13</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#14</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#15</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#16</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#17</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#18</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#19</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#20</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#21</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#22</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#23</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#24</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#25</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#26</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#27</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#28</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#29</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#30</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#31</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>xffffffff<br><br># 使用taskset设置亲和性，将main程序绑定到第<span class="hljs-number">1</span>个CPU上，mask转化为<span class="hljs-number">16</span>进制为<span class="hljs-number">0</span>x1<br>➜  Affinity git:(main)  taskset <span class="hljs-number">1</span> ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>x1<br><br># 使用taskset设置亲和性，将main程序绑定到第<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>个CPU上，mask转化为<span class="hljs-number">16</span>进制为<span class="hljs-number">0</span>x55<br>➜  Affinity git:(main)  taskset <span class="hljs-number">55</span> ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#6</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>x55<br><br># 使用taskset设置亲和性，将main程序绑定到第<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>个CPU上，mask转化为<span class="hljs-number">16</span>进制为<span class="hljs-number">0</span>xf<br>➜  Affinity git:(main)  taskset F ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>xf<br></code></pre></td></tr></table></figure>

<h3 id="设置进程的-CPU-亲和性后再获取显示-CPU-亲和性"><a href="#设置进程的-CPU-亲和性后再获取显示-CPU-亲和性" class="headerlink" title="设置进程的 CPU 亲和性后再获取显示 CPU 亲和性"></a>设置进程的 CPU 亲和性后再获取显示 CPU 亲和性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span> <span class="hljs-comment">/* sysconf */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">/* exit */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br>    <br>    CPU_ZERO(&amp;mask);<br>    <br>    CPU_SET(<span class="hljs-number">0</span>, &amp;mask); <span class="hljs-comment">/* add CPU0 to cpu set */</span><br>    CPU_SET(<span class="hljs-number">2</span>, &amp;mask); <span class="hljs-comment">/* add CPU2 to cpu set */</span><br>    CPU_SET(<span class="hljs-number">3</span>, &amp;mask); <span class="hljs-comment">/* add CPU3 to cpu set */</span><br><br>    <span class="hljs-comment">/* 设置 CPU 亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_setaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) <br>    &#123;   <br>        perror(<span class="hljs-string">&quot;sched_setaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <br>    CPU_ZERO(&amp;mask);<br>    <br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) <br>    &#123;   <br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>       <span class="hljs-comment">/* get logical cpu number */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(i, &amp;mask))<br>        &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i); <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">➜  Affinity git:(main) ✗ ./bin/main <br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>xd<br></code></pre></td></tr></table></figure>

<h3 id="设置线程的-CPU-属性后再获取显示-CPU-亲和性"><a href="#设置线程的-CPU-属性后再获取显示-CPU-亲和性" class="headerlink" title="设置线程的 CPU 属性后再获取显示 CPU 亲和性"></a>设置线程的 CPU 属性后再获取显示 CPU 亲和性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span> <span class="hljs-comment">//不用再包含&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> handle_error_en(en, msg) \</span><br><span class="hljs-meta">        do &#123; errno = en; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> s, j;<br>    <span class="hljs-keyword">cpu_set_t</span> cpuset;<br>    <span class="hljs-keyword">pthread_t</span> thread;<br>    <br>    thread = pthread_self();<br>    <br>    <span class="hljs-comment">/* Set affinity mask to include CPUs 0 to 7 */</span><br>    CPU_ZERO(&amp;cpuset);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>        CPU_SET(j, &amp;cpuset);<br>    <br>    s = pthread_setaffinity_np(thread, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;cpuset);<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>    &#123;<br>        handle_error_en(s, <span class="hljs-string">&quot;pthread_setaffinity_np&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* Check the actual affinity mask assigned to the thread */</span><br>    s = pthread_getaffinity_np(thread, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;cpuset);<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>    &#123;<br>        handle_error_en(s, <span class="hljs-string">&quot;pthread_getaffinity_np&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Set returned by pthread_getaffinity_np() contained:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; CPU_SETSIZE; j++) <span class="hljs-comment">//CPU_SETSIZE 是定义在&lt;sched.h&gt;中的宏，通常是 1024</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(j, &amp;cpuset))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    CPU %d\n&quot;</span>, j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gams">➜  Affinity git:(main) ./bin/main<br><span class="hljs-keyword">Set</span> returned <span class="hljs-comment">by pthread_getaffinity_np() contained:</span><br>    CPU <span class="hljs-comment">0</span><br>    CPU <span class="hljs-comment">1</span><br>    CPU <span class="hljs-comment">2</span><br>    CPU <span class="hljs-comment">3</span><br>    CPU <span class="hljs-comment">4</span><br>    CPU <span class="hljs-comment">5</span><br>    CPU <span class="hljs-comment">6</span><br>    CPU <span class="hljs-comment">7</span><br></code></pre></td></tr></table></figure>

<h3 id="使用-seched-setaffinity-设置线程的-CPU-亲和性"><a href="#使用-seched-setaffinity-设置线程的-CPU-亲和性" class="headerlink" title="使用 seched_setaffinity 设置线程的 CPU 亲和性"></a>使用 seched_setaffinity 设置线程的 CPU 亲和性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span> <span class="hljs-comment">// syscall</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> tid;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br>    <br>    CPU_ZERO(&amp;mask);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;mask); <span class="hljs-comment">/* add CPU0 to cpu set */</span><br>    CPU_SET(<span class="hljs-number">2</span>, &amp;mask); <span class="hljs-comment">/* add CPU2 to cpu set */</span><br><br>    <span class="hljs-comment">// 获取线程 id</span><br>    tid = syscall(__NR_gettid); <span class="hljs-comment">// or syscall(SYS_gettid);</span><br><br>    <span class="hljs-comment">// 对指定线程 id 设置 CPU 亲和性</span><br>    <span class="hljs-keyword">if</span> (sched_setaffinity(tid, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) <br>    &#123;<br>        perror(<span class="hljs-string">&quot;sched_setaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(i, &amp;mask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">➜  Affinity git:(main) ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br></code></pre></td></tr></table></figure>

<h2 id="什么是中断亲和性"><a href="#什么是中断亲和性" class="headerlink" title="什么是中断亲和性"></a>什么是中断亲和性</h2><p>计算机中，中断是一种电信号，由硬件产生并直接送到中断控制器上，再由中断控制器向 CPU 发送中断信号，CPU 检测到信号后，中断当前工作转而处理中断信号。CPU 会通知操作系统已经产生中断，操作系统就会对中断进行处理。<br>这里有篇推文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247484717&idx=1&sn=2c1dd6c389c8476eb4fd178c714eaafc&scene=21#wechat_redirect">CPU 明明 8 个核，网卡为啥拼命折腾一号核？</a>生动的解释了中断亲和性。</p>
<p>默认情况下，Linux 中断响应会被平均分配到所有 CPU 核心上，势必会发生写新的数据和指令缓存，并与 CPU 核心上原有进程产生冲突，造成中断响应延迟，影响进程处理时间。为了解决这个问题，可以将中断（或进程）绑定到指定 CPU 核心上，中断（或进程）所需要指令代码和数据有更大概率位于指定 CPU 本地数据和指令缓存内，而不必进行新的写缓存，从而提高中断响应（或进程）的处理速度。</p>
<h2 id="中断亲和性的使用场景"><a href="#中断亲和性的使用场景" class="headerlink" title="中断亲和性的使用场景"></a>中断亲和性的使用场景</h2><p>对于文件服务器、Web 服务器，把不同的网卡 IRQ 均衡绑定到不同的 CPU 上将会减轻某 CP 的负载，提高多个 CPU 整体处理中断的能力; 对于数据库服务器，把磁盘控制器绑到一个 CPU、把网卡绑定到另一个 CPU 将会提高数据库的响应时间、优化性能。<br>合理的根据自己的生产环境和应用的特点来平衡 IRQ 中断有助于提高系统的整体吞吐能力和性能。</p>
<h2 id="中断绑定流程"><a href="#中断绑定流程" class="headerlink" title="中断绑定流程"></a>中断绑定流程</h2><ol>
<li><p>关闭中断平衡守护进程<br>中断平衡守护进程（irqbalance daemon）会周期性地将中断平均地公平地分配给各个 CPU 核心，默认开启。为了实现中断绑定，首先需要将中断平衡守护进程关闭。</p>
<ul>
<li><code>systemctl status irqbalance</code>查看守护进程的运行状态</li>
</ul>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ systemctl status irqbalance<br><br>● irqbalance.service - irqbalance daemon<br>Loaded: loaded (/lib/systemd/system/irqbalance.service; enabled; vendor preset: <span class="hljs-built_in">enable</span><br>Active: active (running) since Thu 2022-05-19 14:46:20 CST; 1 weeks 1 days ago<br>Main PID: 1062 (irqbalance)<br>    Tasks: 2 (<span class="hljs-built_in">limit</span>: 4915)<br>CGroup: /system.slice/irqbalance.service<br>        └─1062 /usr/sbin/irqbalance --foreground<br><br>5月 19 14:46:20 zdd systemd[1]: Started irqbalance daemon.<br></code></pre></td></tr></table></figure>

<ul>
<li><code>systemctl stop irqbalance</code>关闭中断平衡守护进程，中断响应默认都会由 CPU0 核心处理。或者<code>systemctl disable irqbalance</code>取消中断平衡守护进程开机重启。因为关闭中断平衡守护进程过于强硬，可以在不关闭中断平衡守护进程条件下，让某些 CPU 核心脱离中断平衡守护进程的管理。</li>
</ul>
</li>
<li><p>绑定中断<br>中断绑定时，需要关闭系统中断平衡守护进程<code>systemctl stop irqbalance</code>计算机当前各种中断响应情况在 <code>/proc/interrupts</code> 文件中。</p>
<p> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205281336182.png"><br> 第一列是中断 ID 号，CPU N 列是中断在第 n 个 CPU 核心上的响应次数，倒数第二列是中断类型，最后一列是描述。  </p>
<p> 利用 echo 命令将 CPU 掩码写入 <code>/proc/irq/中断 ID/smp_affinity</code> 文件中，即可实现修改某一中断的 CPU 亲和性。例如  </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> 0x0004 &gt; /proc/irq /50/smp_affinity<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lubinlew/p/cpu_affinity.html">Linux 中 CPU 亲和性 (affinity) - LubinLew - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15302006/3075968">操作系统底层技术——CPU 亲和性_mb60ed33cfc44fa 的技术博客_51CTO 博客</a><br><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15484754/4907846">linux 进程、线程与 CPU 的亲和性（affinity）_wx61d68abba262d 的技术博客_51CTO 博客</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247484717&idx=1&sn=2c1dd6c389c8476eb4fd178c714eaafc&scene=21#wechat_redirect">CPU 明明 8 个核，网卡为啥拼命折腾一号核？</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Processor_affinity">Processor affinity - Wikipedia</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HwDqCk8vtMdSEVSCLHAsbg">什么？一个核同时执行两个线程？</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wenqiang/p/6049978.html#!comments">linux 进程、线程与 CPU 的亲和性（affinity） - zhangwju - 博客园</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/21/SoC%E5%AD%98%E5%82%A8%E5%99%A8%E6%AF%94%E8%BE%83/" itemprop="url">SoC 存储器比较</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-21T09:13:33.000Z" itemprop="datePublished">5月 21 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            9 分钟 lesen (Über 1311 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>也就是内部存储器，主要用来运行程序的，典型的就是 RAM 随机存储器（Random Access Memory），那么随机是什么意思？所谓随机，指的是当存储器中的数据被读取或写入时，所需要的时间与这段信息所在的位置无关（任何位置读写速度一样）。</p>
<p><strong>DRAM</strong>（Dynamic Random Access Memory，动态随机存储器）是最为常见的系统内存。我们使用的电脑和手机的运行内存都是 DRAM。DRAM 使用电容存储，DRAM 只能将数据保持很短的时间。为了保持数据，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。数据的存储，请参考数据存储模型。我们知道，电容中的电荷很容易变化，所以随着时间推移，电容中的电荷数会增加或减少，为了确保数据不会丢失，DRAM 每隔一段时间会给电容刷新（充电或放电）。动态：定时刷新数据</p>
<p><strong>SRAM</strong>（Static Random Access Memory，静态随机存储器），它是一种具有静止存取功能的内存，其内部机构比 DRAM 复杂，可以做到不刷新电路即能保存它内部存储的数据。<strong>静态：不需要刷新</strong></p>
<p><strong>DDR SDRAM</strong>（Double Data Rate SDRAM）：为双信道同步动态随机存取内存，是新一代的 SDRAM 技术。DDR 内存芯片的数据预取宽度（Prefetch）为 2 bit（SDRAM 的两倍）。</p>
<p><strong>DDR2 SDRAM</strong>（Double Data Rate Two SDRAM）：为双信道两次同步动态随机存取内存。DDR2 内存 Prefetch 又再度提升至 4 bit（DDR 的两倍）</p>
<p><strong>DDR3 SDRAM</strong>（Double Data Rate Three SDRAM）：为双信道三次同步动态随机存取内存。DDR3 内存 Prefetch 提升至 8 bit，即每次会存取 8 bits 为一组的数据。运算频率介于 800MHz -1600MHz 之间。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205211606655.png"></p>
<h2 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h2><p>外部存储器，通常用来存储文件的，一般也叫 ROM（<strong>Read-only memory</strong>）只读存储器。</p>
<p>CPU 连接内存和外存的连接方式不同。内存需要直接地址访问，所以是通过地址总线&amp;数据总线的总线式访问方式连接的（好处是直接访问，随机访问；坏处是占用 CPU 的地址空间，大小受限）；外存是通过 CPU 的外存接口来连接的（好处是不占用 CPU 的地址空间，坏处是访问速度没有总线式快，访问时序较复杂）</p>
<blockquote>
<p>我们平时用的硬盘，SD 卡都属于 ROM，但是他们却可以写入？ROM 严格意义来讲确实是只读的，但是随着储存器的发展，出现了可擦可编程只读存储器（EPROM）、电可擦可编程只读存储器（EEPROM）形式的半导体存储器，以及 flash。他们都是可写的。ROM 就不再单单只表示只读存储器了，一般来说与 RAM 相对，掉电不易失的存储器都被当做 ROM。</p>
</blockquote>
<h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p>ROM（Read Only Memory）只读存储器，这种存储器（Memory）的内容任何情况下都不会改变，电脑与用户只能读取保存在这里的指令，和使用存储在 ROM 的资料，但不能变更或存入资料。ROM 被存储在一个非易失性芯片上，也就是说，即使在关机之后记忆的内容仍可以被保存，所以这种存储器多用来存储特定功能的程序，如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E4%BB%B6">固件</a>。ROM 存储用来启动电脑的程序（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a>），电脑引导的时候 BIOS 提供一连串的指令对中央处理器（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU">CPU</a>）等组件进行初始化，在初始化过程中，BIOS 程序初始化并检查<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">RAM</a>。</p>
<h3 id="NorFlash"><a href="#NorFlash" class="headerlink" title="NorFlash"></a>NorFlash</h3><p>总线式访问，接到 SROM bank，优点是可以直接总线访问，一般用来启动。</p>
<h3 id="NandFlash"><a href="#NandFlash" class="headerlink" title="NandFlash"></a>NandFlash</h3><p>SLC：容量小，价格高，稳定性高</p>
<p>MLC：容量大，价格低，稳定性差，易出坏块</p>
<p><strong>iNand</strong><br>SanDisk 公司出产的 eMMC</p>
<p><strong>moviNand</strong><br>三星公司出产的 eMMC</p>
<p><strong>oneNAND</strong><br>三星公司出的一种 Nand，价格贵，用的少</p>
<p><strong>SD 卡（Secure Digital Memory Card）</strong></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205192308956.png"></p>
<p><strong>TF 卡（TransFLash Card, MicroSD）</strong></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205192309547.png"></p>
<p><strong>MMC 卡</strong></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205192312777.png"></p>
<p><strong>eMMC 卡（embeded MMC）</strong><br>嵌入式的 MMC，可以当成一种芯片，内部做了坏块处理</p>
<p><strong>SATA 硬盘</strong></p>
<p>特点：机械式访问、磁存储原理、SATA 是接口。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/18/Interlaken%E5%8D%8F%E8%AE%AE/" itemprop="url">Interlaken 协议</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-18T14:40:47.000Z" itemprop="datePublished">5月 18 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/">通信协议</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            15 分钟 lesen (Über 2288 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>对 Interlaken 协议文档的翻译加了一些自己的理解；</p>
</blockquote>
<p><strong>8b/10b编码</strong>：在串行通道上传输时，将 8bits 数据编码为 10bits 数据，做一个转换，使各位数据之间有更多的 1 到 0 和 0 到 1 的跳变，以便接收设备检测这些跳变，能更容易地恢复时钟。<strong>64B/67B 编码</strong>编码的原因也是类似的。这样，在串行通道上传输 10 位数据，实际上只传输了 8 位。</p>
<h2 id="协议层（Protocol-Layer）"><a href="#协议层（Protocol-Layer）" class="headerlink" title="协议层（Protocol Layer）"></a>协议层（Protocol Layer）</h2><h3 id="传输格式"><a href="#传输格式" class="headerlink" title="传输格式"></a>传输格式</h3><p>数据通过可配置数量的 SerDes 通道（Lane），再由 Interlaken 接口传输。在本文档中，通道被定义为两个 IC 之间的单工串行链路（simplex serial link）。该协议旨在与任意数量的通道一起运行（1 个或多个，没有上限）。实际实现时会固定一个数值，不会设计为可变值。</p>
<p>接口发送数据的基本单位是一个 8 字节的字（Word）。用 8 字节是为了符合<strong>64B/67B 编码</strong>，用于描述突发（Burst）的控制字的大小也是 8 字节。通过使基本传输单元与控制字大小相等，可以<strong>很容易地调整接口的宽度</strong>。</p>
<p>数据和控制字按顺序在通道上传输，从通道 0 开始，到通道 M 结束，并在下一个数据块中重复。图 4 说明了该过程</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517120049.png"></p>
<p>64B/67B编码在每个通道上独立进行。传输通过两种基本数据类型实现：数据字和控制字，他们通过64B/67B 帧位（framing bits）进行区分。这两种数据字类型的格式如下图所示：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517120402.png"></p>
<p>数据和控制信息都是以位 66～0 的顺序传输的，框架层引入了 4 个附加控制字，详细信息后面将描述。</p>
<h3 id="Burst-结构（Burst-Structure）"><a href="#Burst-结构（Burst-Structure）" class="headerlink" title="Burst 结构（Burst Structure）"></a>Burst 结构（Burst Structure）</h3><h4 id="数据传输流程"><a href="#数据传输流程" class="headerlink" title="数据传输流程"></a>数据传输流程</h4><p>Interlaken 接口的带宽在支持的通道上被划分为 Bursts。数据包通过一个或多个 Burst 在接口上传输。Burst 通过一个或多个控制字来描述。为了将任意大小的数据包分割成 Burst，定义以下两个参数：</p>
<ul>
<li>BurstMax：Burst 的最大大小（64Bytes 的倍数）</li>
<li>BurstShort：Burst 的最小大小（最小 32Bytes，增量为 8Bytes）</li>
</ul>
<p>该接口通常通过发送一个 BurstMax 长度的数据突发来运行，然后是一个控制字。发送设备中的调度逻辑可以自由选择信道服务的顺序，<strong>受流控状态的约束</strong>。Burst 在每个通道上传输，直到数据包完全传输，此时该通道上的新数据包传输才开始。</p>
<p>因为接口是信道化的，数据包的结束可能会在几个信道上连续地出现，每个信道上的剩余数据量非常小。由于发射器和接收器的存储器可能被理想地设计成宽数据通路，它们需要以非常高的速率来处理这种情况。为了减少接收器和发射器的负担，BurstShort 参数保证了连续的 Burst 控制字之间的最小间隔。最小的 BurstShort 间隔是 32 字节，更大的值可以以 8 字节为增量。</p>
<blockquote>
<p>如果没有最小 Burst 的限制，那么数据包太小的话，发送器或者接收器就会频繁收到 end-of-packet，这就增加了处理负担。</p>
</blockquote>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517142438.png" alt="示意如何保证 BurstShort 最小间隔。BurstShort 通过在下一个 Burst 控制字之前添加额外的空闲控制字来保证最小 Burst 的大小。图中，Idle Control Word 1 的 EOP_Format 指示 EOP 和 Last Data Word 的适当大小，Idle Control Word 1 的 CRC24 涵盖了 Last Data Word 和 Idle Control Word 1。插入 Idle Control Word 2 和 Idle Control Word 3 BurstShort 来保证 BurstShort 为 32 字节，随后的 Burst 控制字属于下一轮发送的数据。"></p>
<h4 id="控制字格式"><a href="#控制字格式" class="headerlink" title="控制字格式"></a>控制字格式</h4><p>突发通过一个 8 字节的控制字来描述。控制字在数据流中通过使用位 [66:64] 的“0x10”控制代码和位 [63] = ‘1’ 来标识突发和空闲控制字格式如第 16 页的图 7 所示：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517182706.png"></p>
<h3 id="流控（Flow-Control）"><a href="#流控（Flow-Control）" class="headerlink" title="流控（Flow Control）"></a>流控（Flow Control）</h3><p>Interlaken 的一个关键特性是能够传达每个通道背压（backpressure）。为了提供此功能，指定了两个选项：<strong>带外流控接口和带内通道</strong>。从语义上讲，流控制信息<strong>使用简单的开关机制来表示允许在特定通道上传输</strong>。</p>
<p>开关流控制状态与每个通道的单个状态位进行通信。按照惯例，“1”标识“XON”状态，表示允许发送器在该通道上发送数据。 “0”标识“XOFF”状态，表示发送器不允许在该通道上发送数据。</p>
<p>该协议没有 Credits 的概念；一旦通道被指示为 XON，发送器可以在该通道上发送尽可能多的数据，直到流控制状态更改为 XOFF。接收器选择在 XON 和 XOFF 状态之间切换的阈值是留给用户的可编程选项，取决于支持的通道数量、接收缓冲区的深度和给定环境的流控制延迟。</p>
<p>流控制通道可以选择映射到 calendar，从而流控制可以映射到任何一组 calendar entry。例如，这些可以包括通道到 calendar entry 的一对一映射、一对多映射或插入空字段以匹配具有不同通道定义的设备。</p>
<blockquote>
<p>Channel Calendar 将通道映射到流控状态槽</p>
</blockquote>
<p>这个 Calendar 结构也可以用来提供链路级的流控制，Calendar 中的一个 bit 代表了在整个接口上传输数据的权限。链路状态的极性将与通道状态的极性相同：“1”表示允许传输，“0”表示立即停止传输。要启用此功能，可以为每个 Calendar entry 配置通道信息或链接信息。为了促进低延迟链路状态，接口需要提供足够的 Calendar entry，以便在每个突发/空闲控制字的相同位位置编程链路状态。例如，使用超过 16 个通道，这可以通过以下设置执行：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517165148.png"></p>
<p>使用此方法，link status将始终出现在突发/空闲控制字的位[55]中。</p>
<h4 id="带外流控"><a href="#带外流控" class="headerlink" title="带外流控"></a>带外流控</h4><p>为了支持需要单工操作的系统，定义了带外流量控制选项。这是作为一个源同步接口实现的，并由以下信号指定：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>型号名称</td>
<td>功能</td>
</tr>
<tr>
<td>FC_CLK</td>
<td>与流控数据同步的时钟</td>
</tr>
<tr>
<td>FC_DATA</td>
<td>流量控制状态信息 (单比特)</td>
</tr>
<tr>
<td>FC_SYNC</td>
<td>一种同步信号，用于标识流控制 calendar 的开头</td>
</tr>
</tbody></table>
<p>每个信号的 pad 技术可以是 LVDS 或 LVCMOS。这些信号的逻辑时序关系如下图所示：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517165803.png"></p>
<p>带外流控制通道由 4 位 CRC 计算保护，该 CRC 计算覆盖了多达 64 位的流控制数据。根据^[P. Koopman and T. Chakravarty, Cyclic Redundancy Code (CRC) Polynomial Selection<br>for Embedded Networks, The International Conference on Dependable Networks and<br>Systems, DSN-2004.] 中的建议，CRC4 多项式为：</p>
<p>$$<br>x^4+x+1<br>$$</p>
<h4 id="带内流控"><a href="#带内流控" class="headerlink" title="带内流控"></a>带内流控</h4><p>当使用此选项时，接收器利用通过接口发送的控制字中的流控制状态，作为正常数据传输的一部分。提供此选项的目的是，需要最少数量的外部信号引脚的全双工实现。  </p>
<p>如 Figure 7 所示，控制字的流控制字段为 16 位，位于 bit[55:40]。控制字的位 [31:24] 也可以用于流控制的另外 8 位，总共 24 位。这些状态位表示每个 Interlaken Calendar 通道的 ON-OFF 流控制状态，当前 Calendar Entry X 在位 [55]，Calendar Entry X + 1 在位 [54]，依此类推。为了同步 calendar 的开始，在空闲/突发控制字中提供了“reset calendar”位。当该位为“1”时，calendar entry 0 的状态将出现在位 [55] 中。当“reset calendar”为“0”时，calendar 将从上一个控制字中保留的位置开始继续。当所有通道的流控状态被传输完，发送器将重置复位 calendar，然后重复上一轮顺序操作。Calendar 最后一个控制字中不需要的 bit（即，当通道数目不是状态数目的倍数时）被发送端置 0，接收端忽略。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/17/AMBA%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE-AXI%E5%8D%8F%E8%AE%AE/" itemprop="url">AMBA 总线协议-AXI 协议</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-17T13:16:45.000Z" itemprop="datePublished">5月 17 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/">通信协议</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            22 分钟 lesen (Über 3279 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="AXI"><a href="#AXI" class="headerlink" title="AXI"></a>AXI</h2><p>组成部分：</p>
<p>AXI4 协议中包含五种信道，通道之间相互独立且存在差别，通过通道进行通信之前需要使用 VALID/READY 进行握手，Read 和 Write 根据 Master 定义：</p>
<ul>
<li>读地址信道（Read Address Channel）</li>
<li>写地址信道（Write Address Channel）</li>
<li>读数据信道（Read Data Channel）</li>
<li>写数据信道（Write Data Channel）</li>
<li>写响应信道（Write Response Channel）</li>
</ul>
<p>还有两种 Component</p>
<ul>
<li>Master component</li>
<li>Slave component</li>
</ul>
<p>通信由 Master 发起，Master 可以对 Slave 进行读数据（read）或写（write）数据。每次读写操作都需要一个地址，读地址信道（Read Address Channel）和写地址信道（Write Address Channel）用于传输地址。在写完数据后，Master 需要确认 Slave 有没有收完数据，Slave 收到完整数据后，会通过写响应信道（Write Response Channel）给 Master 一个反馈（completion），表示写操作已经完成。</p>
<h3 id="VALID-READY-握手机制"><a href="#VALID-READY-握手机制" class="headerlink" title="VALID/READY 握手机制"></a>VALID/READY 握手机制</h3><p>AXI 五个信道相互独立，但是使用同一个握手机制来实现信息传递。</p>
<p>在握手机制中，通信双方分别扮演<strong>发送方</strong>(Source) 和<strong>接收方</strong>（Destination），两者的操作（技能）并不相同。</p>
<p><strong>发送方</strong>置高 <strong>VALID</strong> 信号表示发送方已经将数据，地址或者控制信息已经就绪，并保持于消息总线上。</p>
<p><strong>接收方</strong>置高 <strong>READY</strong> 信号表示接收方已经做好接收的准备。</p>
<p>当双方的 VALID/READY 信号同时为高，在时钟 ACLK 上升沿，完成一次数据传输。所有数据传输完毕后，双方同时置低自己的信号。</p>
<p>每个通道都有自己的 VALID /READY 握手信号对：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516200137.png"></p>
<p>在握手过程中，还会用到 LAST 信号。LAST 信号存在 Write Data Channel 和 Read Data Channel 中，分别表示为 WLAST 和 RLAST，用于标记 burst 的最后一次数据传输，当 slave 接收到 LAST 信号后，说明本次数据传输完成。</p>
<h4 id="双向流控"><a href="#双向流控" class="headerlink" title="双向流控"></a>双向流控</h4><p>所谓的<strong>双向流控</strong>机制，指的是发送方通过置起 VALID 信号控制发送的时机与速度，接收方也可以通过 READY 信号的置起与否控制接收速度。</p>
<p>发送方拥有传输的主动权，但接收方在不具备接收能力时，也能够置低信号停止传输，反压发送方。</p>
<h4 id="握手过程分析"><a href="#握手过程分析" class="headerlink" title="握手过程分析"></a>握手过程分析</h4><blockquote>
<p>图中 INFORMATION 信号无底色区域表示此时数据已经准备好，已经有新的数据到达。</p>
</blockquote>
<p><strong>VALID 信号先到</strong></p>
<p>发送方 VALID 信号早早就到了，但是接收方的 READY 信号在 T2 之前都没有发送。可能接收方在接收其他数据，或者被堵在数据通路上。</p>
<p>过了 T2 后，READY 信号到来，此时开始传输，直到 T3 结束，传输完成。</p>
<p>这里也体现了双向流控机制，发送方的 VALID 信号只要置高，再握手完成之前都不能置低，必须等到接收方 READY 信号置高。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201556.png"></p>
<p><strong>READY 信号先到</strong></p>
<p>READY 信号很自由，可以等待 VALID 信号到来再做响应，但也完全可以在 VALID 信号到来前就置高，表示接收端已经做好准备了。</p>
<p>而且，READY 信号与 VALID 不同，接收方可以置起 READY 之后在 VALID 置高之前都可以随时再置低 READY 信号。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201616.png"></p>
<p><strong>信号同时同时到达</strong></p>
<p>这个最简单，两个信号都等着一个时钟上升沿就完成传输了。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201647.png"></p>
<h4 id="握手信号之间的依赖关系"><a href="#握手信号之间的依赖关系" class="headerlink" title="握手信号之间的依赖关系"></a>握手信号之间的依赖关系</h4><p>为了防止死锁发生，信号之间要遵循一些规矩，举例来说，如上面提到的 READY 信号依赖 VALID 信号，但是 VALID 信号不能根据 READY 信号来判断是否数据已准备好，否则将会造成死锁。下面详细解释读写过程中需要遵循的依赖关系。</p>
<ul>
<li>单箭头指向的两个信号，信号的置高，低没有顺序要求。</li>
<li>双箭头表示箭头所指对象应迟于箭头出发信号发送。</li>
</ul>
<p><strong>Read transaction dependencies</strong></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517100503.png"></p>
<ul>
<li>Master 不得等待 Slave 置高 ARREADY</li>
<li>Slave 可以在置高 ARREADY 之前等待 ARVALID 置高</li>
<li>Slave 能够在 ARVALID 置高之前先置高 ARREADY</li>
<li>Slave 必须等待 ARVALID 和 ARREADY 都被置高，然后才置高 RVALID 以表示有效数据可用</li>
<li>在置高 RVALID 之前，Slave 不得等待 Master 置高 RREADY</li>
<li>Master 可以在置高 RREADY 之前等待 RVALID 被置高</li>
<li>Master 可以在 RVALID 被置高之前置高 RREADY</li>
</ul>
<p><strong>Write transaction dependencies</strong></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517100647.png"></p>
<ul>
<li>在置高 AWVALID 或 WVALID 之前，Master 不得等待 Slave 置高 AWREADY 或 WREADY</li>
<li>Slave 可以在置高 AWREADY 之前等待 AWVALID 或 WVALID，或两者都等待</li>
<li>Slave 可以在 AWVALID 或 WVALID 或两者都被置高之前置高 AWREADY</li>
<li>在置高 WREADY 之前，Slave 可以等待 AWVALID 或 WVALID，或两者都等待</li>
<li>Slave 可以在 AWVALID 或 WVALID 或两者都被置高之前置高 WREADY</li>
<li>在置高 BVALID 之前，Slave 必须等待 WVALID 和 WREADY 都被置高<ul>
<li>Slave还必须在置高 BVALID 之前等待 WLAST 被置高，因为写入响应 BRESP 必须在写入事务的最后一次数据传输之后才发出信号</li>
</ul>
</li>
<li>在置高 BVALID 之前，Slave 不得等待 Master 置高 BREADY</li>
<li>Master 可以在置高 BREADY 之前等待 BVALID</li>
<li>Master 可以在 BVALID 被置高之前置高 BREADY</li>
</ul>
<h3 id="地址结构（Address-structure）"><a href="#地址结构（Address-structure）" class="headerlink" title="地址结构（Address structure）"></a>地址结构（Address structure）</h3><p>AXI 协议是基于 Burst 的，地址结构里声明了一些传输过程中需要的信号，如起始地址，burst 传输长度，传输模式等等。</p>
<h4 id="Burst"><a href="#Burst" class="headerlink" title="Burst"></a>Burst</h4><p>在介绍 Burst transfer 之前，需要解释一下什么是 Burst。在手册的术语表中，与 AXI 传输相关的有三个概念，分别是 transfer(beat)、burst、transaction。</p>
<ul>
<li><strong>AXI Transaction</strong>：the complete set of required operations on the AXI bus form the AXI Transaction.表示传输一段数据 (AXI burst) 所需的一整套操作；</li>
<li><strong>AXI Burst</strong>：any required payload data is transferred as an AXI Burst.表示 AXI 待传数据；</li>
<li><strong>AXI Beats</strong>：a burst can comprise multiple data transfers, or AXI Beats.表示 AXI burst 的组成，一个 Beat 就是一个 transfer。</li>
</ul>
<p>三者的关系：在 AXI 传输事务（Transaction）中，数据以突发传输（Burst）的形式组织。一次突发传输中可以包含一至多个数据（Transfer）。每个 transfer 因为使用一个周期，又被称为一拍数据（Beat）。</p>
<p>$$<br>\text{Transaction} = M <em>\text{Burst} ,M \geq 1 \<br>\text{Burst} = N</em> \text{Transfer( or Beat)} ,N \geq 1<br>$$</p>
<p>在地址通道中有三个信号控制进行控制，包括：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516151233.png"></p>
<p><strong>ARLEN(Burst Length)</strong></p>
<p>指一次突发传输中包含的数据传输 (transfer) 数量，在协议中使用 AxLen 信号控制。在 AXI4 中，INCR 类型最大支持长度为 256，其他类型最大长度为 16。而 AXI3 中这一数字无论何种模式均为 16。因此 AXI4 中 AxLen 信号位宽为 8bit，AXI3 中的 AxLen 则仅需要 4bit。</p>
<p><strong>ARSIZE(Burst Size)</strong></p>
<p>指传输中的数据位宽，具体地，是每周期传输数据的字节数量，在协议中使用 AXSIZE 信号控制。<strong>突发传输数据宽度不能超过数据总线本身的位宽</strong>。而当数据总线位宽大于突发传输宽度时，将根据协议的相关规定，将数据在部分数据线上传输。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516154710.png"></p>
<p><strong>ARBURST(Burst Type)</strong></p>
<p>Burst Type：AXI 协议中支持不同的 Burst 传输类型，主要分 FIXED、INCR、WRAP。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516144318.png"></p>
<ul>
<li><strong>FIXED 传输为地址固定传输</strong>，所有传输都会写在同一个地址中。主要应用在 FIFO 的传输中，因为 FIFO 为先入先出，只需要往同一个地址写数据即可。</li>
<li><strong>INCR 传输为地址递增传输</strong>，可根据具体的配置有固定长度递增和非定长递增。<strong>大部分的数据传输都是使用这种方式</strong>，尤其是在内存访问中，可以大大提高效率。</li>
<li><strong>WRAP 传输为地址回环传输</strong>，在一定长度后会回环到起始地址。主要应用在 Cache 操作中，因为 cache 是按照 cache line 进行操作，采用 wrap 传输可以方便的实现从内存中取回整个 cache line。</li>
</ul>
<p>AXI burst 读操作：<strong>master 只需要发送 burst 的起始地址</strong>，slave 会根据 burst 的起始地址与 burst 场地自动进行地址计算，将对应的数据与响应发送到 master 侧。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516143930.png"></p>
<p>AXI burst 写操作中，<strong>也只需要发送 burst 写的起始地址</strong>，slave 只需要接受起始地址，然后根据传输的长度将数据传输到对应的地址缓存中。只需要进行一次握手就可以实现地址通道的请求传输，避免系统总线的占用。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516144030.png"></p>
<h3 id="数据结构（Data-read-and-write-structure）"><a href="#数据结构（Data-read-and-write-structure）" class="headerlink" title="数据结构（Data read and write structure）"></a>数据结构（Data read and write structure）</h3><p>读写数据结构中声明了几种数据传输方式。</p>
<p>在介绍这些传输方式之前，需要了解<strong>WSTRB(Write strobes) 写选通信号</strong>。写选通信号 WSTRB 允许在写数据总线上进行 稀疏数据 传输。每个写选通信号对应写数据总线上的一个字节。当写选通断言时，表示写数据总线上对应的字节通道中包含将被更新到 memory 的有效信息。  </p>
<p>写数据总线上每 8 位具有一个写选通位，因此 WSTRB[n] 对应  WDATA[(8 x n) + 7 : (8 x n)]。默认情况下 WSTRB = 0xFFFF。也就是所有通路都是通的。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516162105.png"></p>
<h4 id="Narrow-Transfer"><a href="#Narrow-Transfer" class="headerlink" title="Narrow Transfer"></a>Narrow Transfer</h4><p>当本次传输中数据位宽小于通道本身的数据位宽时，称为<strong>窄位宽数据传输</strong>，或者直接翻译成<strong>窄传输</strong>。如下图，传输总线为 32bit，但是每次只传了 8 bit。</p>
<p>窄传输就是<strong>通过 STRB 信号指定有效传输数据的位宽来实现</strong>。针对一些特定的寄存器读写，或者在不同数据位宽的总线传输中会使用窄传输操作。如图，第一次传输时，WSTRB 信号为 0x01，WSTRB = b’001，表示 WDATA[7:0] 数据有效。</p>
<p>需要注意<strong>在多笔连续的窄传输操作中，STRB 会随着地址递增进行响应的变化</strong>，这样方便在系统设计使用中可以方便的将窄传输合并，从而提升系统传输效率。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516162805.png"></p>
<h4 id="Unaligned-Transfer"><a href="#Unaligned-Transfer" class="headerlink" title="Unaligned Transfer"></a>Unaligned Transfer</h4><p>AXI 协议规定单次 burst 传输中的数据，其地址不能跨越 4KB 边界。也就是在传输过程中会进行 4K 对齐。但是在某些时候，会期望在非对齐的地址开始一个突发，即非对齐传输。  </p>
<blockquote>
<p>协议中之所以规定一个 burst 不能跨越 4K 边界是为了避免一次 burst 访问两个 slave（每个 slave 的地址空间是 4K/1K 对齐的）。4K 对齐最大原因是系统中定义一个 page 大小是 4K，而所谓的 4K 边界是指低 12bit 为 0 的地址。</p>
</blockquote>
<p>非对齐传输是指<strong>有些传输指令不是按照 word 对齐，而是按照 Byte 对齐进行传输</strong>。起始地址可能是任意的地址。如下图中，起始地址为 0x1，则在系统上需要按照非对齐的方式进行传输。<strong>第一次传输采用 strb 信号指定对应的 Byte 有效，后面的传输可以按照正常的传输进行</strong>。</p>
<p>下图是一些传输示例，有阴影的格子表示当前字节不会被传输。</p>
<p>图一为正常的对齐传输，传输起始地址为 0x00。</p>
<p>图二为非对齐传输，起始地址为 0x01，第一个格子对应的 WSTRB = b’1110。</p>
<p>图三同上，只是 Burst length 为 5。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516171247.png"></p>
<p>图四也为非对齐传输，起始地址为 0x07。对应的 WSTRB = b’1000。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516171348.png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/15/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" itemprop="url">C 语言实现简单有限状态机</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-15T04:41:30.000Z" itemprop="datePublished">5月 15 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            8 分钟 lesen (Über 1129 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>常说的状态机是有限状态机 FSM，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。<br>三个特征：</p>
<ul>
<li>状态总数（state）是有限的。</li>
<li>任一时刻，只处在一种状态之中。</li>
<li>某种条件下，会从一种状态转变（transition）到另一种状态。</li>
</ul>
<p>设计状态机的关键点：当前状态、外部输入、下一个状态。</p>
<h2 id="状态机分类"><a href="#状态机分类" class="headerlink" title="状态机分类"></a>状态机分类</h2><h3 id="Moore-型状态机"><a href="#Moore-型状态机" class="headerlink" title="Moore 型状态机"></a>Moore 型状态机</h3><p>Moore 型状态机特点是：输出只与当前状态有关（与输入信号无关）。相对简单，考虑状态机的下一个状态时只需要考虑它的当前状态就行了。</p>
<h3 id="Mealy-型状态机"><a href="#Mealy-型状态机" class="headerlink" title="Mealy 型状态机"></a>Mealy 型状态机</h3><p>Mealy 型状态机的特点是：输出不只和当前状态有关，还与输入信号有关。状态机接收到一个输入信号需要跳转到下一个状态时，状态机综合考虑 2 个条件（当前状态、输入值）后才决定跳转到哪个状态。</p>
<h2 id="实现一个简单的状态机"><a href="#实现一个简单的状态机" class="headerlink" title="实现一个简单的状态机"></a>实现一个简单的状态机</h2><p>代码参考<a target="_blank" rel="noopener" href="https://github.com/AstarLight/FSM-framework">AstarLight/FSM-framework</a>。</p>
<p>以小明的一天设计出一个状态机，下图为状态转移图：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205151353618.png"></p>
<p>首先，有限状态机的状态是有限的，我们可以定义一天中的状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br> GET_UP,<br> GO_TO_SCHOOL,<br> HAVE_LUNCH,<br> DO_HOMEWORK,<br> SLEEP,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>状态机在没有事件的驱动下就是一潭死水，所以我们还需要定义出一些会发生的事件，去驱动状态机的运转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br> EVENT1 = <span class="hljs-number">1</span>,<br> EVENT2,<br> EVENT3,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>再定义一些在某个状态下需要处理的动作，也就是函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetUp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming gets up!\n&quot;</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Go2School</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming goes to school!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HaveLunch</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming has lunch!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoHomework</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming does homework!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Go2Bed</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming goes to bed!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义一个状态表结构，用来表示一个状态机的状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FsmTable_s</span></span><br><span class="hljs-class">&#123;</span><br> <span class="hljs-keyword">int</span> event;              <span class="hljs-comment">//事件</span><br> <span class="hljs-keyword">int</span> CurState;           <span class="hljs-comment">//当前状态</span><br> <span class="hljs-keyword">void</span> (*eventActFun)();  <span class="hljs-comment">//函数指针</span><br> <span class="hljs-keyword">int</span> NextState;          <span class="hljs-comment">//下一个状态</span><br>&#125;FsmTable_t;<br></code></pre></td></tr></table></figure>

<p>接下来，我们就可以这个结构定义一个状态表，状态机根据这个表进行状态的流转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">FsmTable_t XiaoMingTable[] =<br>&#123;<br> <span class="hljs-comment">//&#123;到来的事件，当前的状态，将要要执行的函数，下一个状态&#125;</span><br> &#123; EVENT1,  SLEEP,           GetUp,        GET_UP &#125;,<br> &#123; EVENT2,  GET_UP,          Go2School,    GO_TO_SCHOOL &#125;,<br> &#123; EVENT3,  GO_TO_SCHOOL,    HaveLunch,    HAVE_LUNCH &#125;,<br> &#123; EVENT1,  HAVE_LUNCH,      DoHomework,   DO_HOMEWORK &#125;,<br> &#123; EVENT2,  DO_HOMEWORK,     Go2Bed,       SLEEP &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>定义一个状态机结构，表示一个状态机：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FSM_s</span></span><br><span class="hljs-class">&#123;</span><br> FsmTable_t* FsmTable;   <span class="hljs-comment">//指向的状态表</span><br> <span class="hljs-keyword">int</span> curState;           <span class="hljs-comment">//FSM当前所处的状态</span><br><br>&#125;FSM_t;<br></code></pre></td></tr></table></figure>

<p>有了这些基本的结构，就可以写主函数了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> FSM_t fsm;                        <span class="hljs-comment">// 实例化一个状态机</span><br> InitFsm(&amp;fsm);                    <span class="hljs-comment">// 初始化状态机</span><br> <span class="hljs-keyword">int</span> event = EVENT1;               <span class="hljs-comment">// 初始化事件，为了启动状态机流转，</span><br>                                      <span class="hljs-comment">// 因为状态机只有在有时间发生时才会改变状态</span><br><br> <span class="hljs-comment">//小明的一天,周而复始的一天又一天，进行着相同的活动</span><br> <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event %d is coming...\n&quot;</span>, event);<br>  FSM_EventHandle(&amp;fsm, event); <span class="hljs-comment">// 有了初始事件，我们就需要处理这个事件，</span><br>                                      <span class="hljs-comment">// 再写一个处理事件的函数</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fsm current state %d\n&quot;</span>, fsm.curState);<br>  test(&amp;event); <br>  Sleep(<span class="hljs-number">1</span>);                     <span class="hljs-comment">//休眠1秒，方便观察</span><br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 测试用的，模拟事件的发生</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *event)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (*event == <span class="hljs-number">3</span>)<br> &#123;<br>  *event = <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span><br> &#123;<br>  (*event)++;<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>

<p>编写初始化状态机的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">int</span> g_state_max_num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 状态机的状态最大数量，根据状态表的大小来计算</span><br><span class="hljs-comment">// 初始化FSM</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitFsm</span><span class="hljs-params">(FSM_t* pFsm)</span></span><br><span class="hljs-function"></span>&#123;<br> g_state_max_num = <span class="hljs-keyword">sizeof</span>(XiaoMingTable) / <span class="hljs-keyword">sizeof</span>(FsmTable_t);<br> pFsm-&gt;curState = SLEEP; <span class="hljs-comment">// 初始状态为睡觉</span><br>    pFsm-&gt;FsmTable = XiaoMingTable;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编写事件处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 事件处理 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSM_EventHandle</span><span class="hljs-params">(FSM_t* pFsm, <span class="hljs-keyword">int</span> event)</span></span><br><span class="hljs-function"></span>&#123;<br> FsmTable_t* pActTable = pFsm-&gt;FsmTable;<br> <span class="hljs-keyword">void</span> (*eventActFun)() = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//函数指针初始化为空</span><br> <span class="hljs-keyword">int</span> NextState;<br> <span class="hljs-keyword">int</span> CurState = pFsm-&gt;curState;<br><br> <span class="hljs-comment">/* 获取当前动作函数 */</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;g_max_num; i++)<br> &#123;<br>  <span class="hljs-comment">//当且仅当当前状态下来个指定的事件，我才执行它</span><br>  <span class="hljs-keyword">if</span> (event == pActTable[i].event &amp;&amp; CurState == pActTable[i].CurState)<br>  &#123;<br>   pActTable[i].eventActFun();                      <span class="hljs-comment">// 执行动作函数</span><br>            FSM_StateTransfer(pFsm, pActTable[i].NextState); <span class="hljs-comment">// 执行状态转移</span><br>   <span class="hljs-keyword">break</span>;<br>  &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 状态迁移 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSM_StateTransfer</span><span class="hljs-params">(FSM_t* pFsm, <span class="hljs-keyword">int</span> state)</span></span><br><span class="hljs-function"></span>&#123;<br> pFsm-&gt;curState = state;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skyfsm/p/7071386.html">Linux 编程之有限状态机 FSM 的理解与实现 - Madcola - 博客园</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html">JavaScript 与有限状态机 - 阮一峰的网络日志</a><br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">有限状态机 - 维基百科，自由的百科全书</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/08/%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/" itemprop="url">链接脚本入门</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-08T13:32:23.000Z" itemprop="datePublished">5月 8 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            21 分钟 lesen (Über 3176 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>位置无关编码 (PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。</p>
<p>位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。</p>
<p>我们在设计一个程序时，会给这个程序指定一个运行地址（链接地址）。就是说我们在编译程序时其实心里是知道我们程序将来被运行时的地址（运行地址）的，而且必须给编译器链接器指定这个地址（链接地址）才行。</p>
<p>最后得到的二进制程序理论上是和你指定的运行地址有关的，将来这个程序被执行时必须放在当时编译链接时给定的那个地址（链接地址）下才行，否则不能运行（就叫位置有关代码）。但是有个别特别的指令他可以跟指定的地址（链接地址）没有关系，也就是说这些代码实际运行时不管放在哪里都能正常运行。</p>
<p><strong>运行地址</strong>：由运行时决定的（编译链接时是无法绝对确定运行时地址的）。</p>
<p><strong>链接地址</strong>：由程序员在编译链接的过程中，通过<code>Makefile</code>中<code>-Ttext xxx</code>或者<strong>在链接脚本中指定</strong>的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。</p>
<p>举例：Linux 中的应用程序。<code>gcc hello.c -o hello</code>，这时使用默认的链接地址就是<code>0x0</code>，所以应用程序都是链接在<code>0x0</code>地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享 4G 的虚拟地址空间。所以应用程序都可以链接到 0 地址，因为每个进程都是从 0 地址开始的。（编译时可以不给定链接地址而都使用<code>0x0</code>）</p>
<h2 id="编译链接过程"><a href="#编译链接过程" class="headerlink" title="编译链接过程"></a>编译链接过程</h2><h3 id="每个过程的作用"><a href="#每个过程的作用" class="headerlink" title="每个过程的作用"></a>每个过程的作用</h3><ul>
<li>预编译：预编译器执行。替换宏定义，删除注释等工作。</li>
<li>编译：编译器来执行。把源码<code>.c .S</code>编程机器码<code>.o</code>文件。</li>
<li>链接：链接器来执行。把<code>.o</code>文件中的各函数（段）按照一定规则（链接脚本来指定）累积在一起，形成可执行文件。</li>
<li>strip：strip 是把可执行程序中的符号信息给拿掉，以节省空间。（Debug 版本和 Release 版本）</li>
<li>objcopy：由可执行程序生成可烧录的镜像<code>bin</code>文件。</li>
</ul>
<h3 id="编译后生成的段"><a href="#编译后生成的段" class="headerlink" title="编译后生成的段"></a>编译后生成的段</h3><p>段就是程序的一部分，我们把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段放在合适的位置。</p>
<p>段名分为 2 种：一种是编译器链接器内部定好的，一种是程序员自己指定的、自定义的段名。<br>已有段名：</p>
<ul>
<li>代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西</li>
<li>数据段：（.data），数据段就是 C 语言中有显式初始化为非 0 的全局变量</li>
<li>bss 段：（.bss），又叫 ZI（zero initial）段，就是零初始化段，对应 C 语言中初始化为 0 的全局变量。</li>
<li>自定义段名：段名由程序员自己定义，段的属性和特征也由程序员自己定义。</li>
</ul>
<blockquote>
<p>C 语言中全局变量如果未显式初始化，值是 0。本质就是 C 语言把这类全局变量放在了 bss 段，从而保证了为 0。<br>C 运行时环境如何保证显式初始化为非 0 的全局变量的值在 main 之前就被赋值了？就是因为它把这类变量放在了.data 段中，而.data 段会在 main 执行之前被处理（初始化）。</p>
</blockquote>
<h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><h3 id="链接脚本做什么事？"><a href="#链接脚本做什么事？" class="headerlink" title="链接脚本做什么事？"></a>链接脚本做什么事？</h3><p>链接脚本其实是个规则文件，他是程序员用来指挥链接器工作的。链接器会参考链接脚本，并且使用其中规定的规则来处理<code>.o</code>文件中那些段，将其链接成一个可执行程序。</p>
<p>链接脚本的关键内容有 2 部分：段名 + 地址（作为链接地址的内存地址）。把段，放到一个地址的意思。</p>
<p>链接脚本就像是一个从上到下顺序执行的一个代码</p>
<ul>
<li><code>.</code> 表示当前位置</li>
<li><code>=</code> 表示赋值</li>
<li><code>*</code> 表示通配符</li>
</ul>
<p>链接脚本里的符号，可以在汇编源码里引用。</p>
<p>一个简易示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lds">SECTIONS<br>&#123;<br>    . = 0xd0024000; # 当前地址为0xd0024000<br>    <br>    .text : &#123;<br>        start.o<br>        * (.text)   # 所有的text段<br>    &#125;<br>            <br>    .data : &#123;<br>        * (.data)<br>    &#125;<br>    <br>    bss_start = .;  # bss_start的值为当前地址，是执行到这里的地址，不是最上面. = 0xd0024000的地址<br>    .bss : &#123;<br>        * (.bss)<br>    &#125;<br>    <br>    bss_end  = .;    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h3><p><strong>任务：在 SRAM 中将代码从 0xd0020010 重定位到 0xd0024000</strong>。</p>
<p>第一点：通过链接脚本将代码链接到 0xd0024000<br>    重定位代码的作用就是：在PIC执行完之前（在代码中第一句位置有关码执行之前）必须将整个代码搬移到0xd0024000位置去执行，这就是重定位。</p>
<p>第二点：dnw 下载时将 bin 文件下载到 0xd0020010<br>    这样就能完成，下载代码与运行代码位置不同。</p>
<p>第三点：代码执行时通过代码前段的少量位置无关码将整个代码搬移到 0xd0024000。</p>
<p>第四点：使用一个长跳转跳转到 0xd0024000 处的代码继续执行，重定位完成。</p>
<p><strong>长跳转</strong>：一种跳转指令，类似于分支指令 B，BL 等作用的指令，跳转指令通过给 PC（r15）赋一个新值来完成代码跳转。当我们执行完重定位后，<strong>实际上 SRAM 中有两份代码的镜像</strong>（一份是我们下载到 0xd0020010 处的，一份是重定位到 0xd0024000 处的），这两份代码内容完全相同。</p>
<p><strong>短跳转</strong>：短跳转指令可以实现向前或向后 32MB 的地址空间跳转。</p>
<p>当链接地址和运行地址相同是，短跳转和长跳转实际效果一样。但是当链接地址和运行地址不同时，短跳转和长跳转就有差异了，这时候段跳转执行的是运行地址处的那一份，而长跳转执行的是链接地址的那一份。</p>
<p>重定位实际就是在运行地址处执行一段位置无关码 PIC，让这段 PIC（也就是重定位代码）从运行地址处把整个程序镜像拷贝一份到链接地址处，完了之后使用一句长跳转指令从运行地址处直接跳转到链接地址处去执行同一个函数（led_blink），这样就实现了重定位之后的无缝连接。</p>
<p>汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs lds">/*<br> * 文件名：    led.s    <br> * 作者：    朱老师（朱友鹏）<br> * 描述：    演示重定位（在SRAM内部重定位）<br> */<br><br>#define WTCON        0xE2700000<br><br>#define SVC_STACK    0xd0037d80<br><br>.global _start                    // 把_start链接属性改为外部，这样其他文件就可以看见_start了<br>_start:<br>    // 第1步：关看门狗（向WTCON的bit5写入0即可）<br>    ldr r0, =WTCON<br>    ldr r1, =0x0<br>    str r1, [r0]<br>    <br>    // 第2步：设置SVC栈<br>    ldr sp, =SVC_STACK<br>    <br>    // 第3步：开/关icache<br>    mrc p15,0,r0,c1,c0,0;            // 读出cp15的c1到r0中<br>    //bic r0, r0, #(1&lt;&lt;12)            // bit12 置0  关icache<br>    orr r0, r0, #(1&lt;&lt;12)            // bit12 置1  开icache<br>    mcr p15,0,r0,c1,c0,0;<br>    <br>    // 第4步：重定位<br>    adr r0, _start          // adr加载时就叫短加载，此处adr指令用于加载_start当前运行地址，详解见正文    <br>    ldr r1, =_start         // ldr加载时如果目标寄存器是pc就叫长跳转，如果目标寄存器是r1等就叫长加载    <br>                            // 此处ldr指令用于加载_start的链接地址:0xd0024000<br><br>    // bss段的起始地址<br>    ldr r2, =bss_start    // 就是我们重定位代码的结束地址，重定位只需重定位代码段和数据段即可<br>                        // 该符号在链接脚本里定义<br>    cmp r0, r1            // 比较_start的运行时地址和链接地址是否相等<br>    beq clean_bss        // 如果相等说明不需要重定位，所以跳过copy_loop，直接到clean_bss<br>                        // 如果不相等说明需要重定位，那么会顺序执行下面的copy_loop进行重定位<br>                        // 重定位完成后继续执行clean_bss。<br><br>// 用汇编来实现的一个while循环<br>copy_loop:<br>    ldr r3, [r0], #4    // 源   r0内容写入r3，然后r0自增4<br>    str r3, [r1], #4    // 目的 r3内容写入r1，然后r1自增4<br>                        // 这两句代码就完成了4个字节内容的拷贝<br>    cmp r1, r2            // r1和r2都是用ldr加载的，都是链接地址，所以r1不断+4总能等于r2<br>    bne copy_loop<br><br>// 清bss段，其实就是在链接地址处把bss段全部清零<br>clean_bss:<br>    ldr r0, =bss_start                    <br>    ldr r1, =bss_end<br>    cmp r0, r1                // 如果r0等于r1，说明bss段为空，直接继续执行下面的代码<br>    beq run_on_dram            // 清除bss完之后的地址<br>    mov r2, #0<br><br>clear_loop:<br>    str r2, [r0], #4        // 先将r2中的值放入r0所指向的内存地址（r0中的值作为内存地址），<br>    cmp r0, r1                // 然后r0 = r0 + 4<br>    bne clear_loop<br><br>//    清理完bss段后重定位就结束了。然后当前的状况是：<br>//    1、当前运行地址还在0xd0020010开头的（重定位前的）那一份代码中运行着。<br>//    2、此时SRAM中已经有了2份代码，1份在d0020010开头，另一份在d0024000开头的位置。<br>//    然后就要长跳转了。<br><br>run_on_dram:    <br>    // 长跳转到led_blink开始第二阶段<br>    ldr pc, =led_blink                // ldr指令实现长跳转，把led_blink的值，写入pc寄存器<br>    <br>    // 从这里之后就可以开始调用C程序了<br>    //bl led_blink                    // bl指令实现短跳转<br>    <br>    // 汇编最后的这个死循环不能丢<br>    b .<br>    <br></code></pre></td></tr></table></figure>

<p><code>adr</code>与 ldr 伪指令的区别：<code>ldr</code>和<code>adr</code>都是伪指令</p>
<ul>
<li><code>adr</code>短加载，指令加载符号地址，加载的是运行时地址；</li>
<li><code>ldr</code>长加载，指令在加载符号地址时，加载的是链接地址；</li>
</ul>
<p>重定位就是汇编代码中的<code>copy_loop</code>函数，代码的作用是使用循环结构来逐句复制代码到链接地址。<br>复制的源地址是 SRAM 的<code>0xd0020010</code>，复制目标地址是 SRAM 的<code>0xd0024000</code>，复制长度是<code>bss_start</code>减去<code>_start</code>，所以复制的长度就是整个重定位需要重定位的长度，也就是整个程序中代码段 + 数据段的长度。<code>bss</code>段（bss 段中就是 0 初始化的全局变量）不需要重定位。</p>
<p>清除<code>bss</code>段是为了满足 C 语言的运行时要求（C 语言要求显式初始化为 0 的全局变量，或者未显式初始化的全局变量的值为 0，实际上 C 语言编译器就是通过清<code>bss</code>段来实现 C 语言的这个特性的）。一般情况下我们的程序是不需要负责清零<code>bss</code>段的（C 语言编译器和链接器会帮我们的程序自动添加一段头程序，这段程序会在我们的 main 函数之前运行，这段代码就负责清除<code>bss</code>）。但是在我们代码重定位了之后，因为编译器帮我们附加的代码只是帮我们清除了运行地址那一份代码中的<code>bss</code>，而未清除重定位地址处开头的那一份代码的<code>bss</code>，所以重定位之后需要自己去清除<code>bss</code>。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="../12/">Vorheriges</a>
    </div>
    <div class="pagination-next">
        <a href="../14/">Nächstes</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="../../">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="../12/">12</a></li>
        
        <li><a class="pagination-link is-current" href="">13</a></li>
        
        <li><a class="pagination-link" href="../14/">14</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="../26/">26</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2024 Dominic&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>




<script src="../../js/script.js"></script>


    
</body>
</html>