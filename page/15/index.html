<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>如云泊</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">





    <meta property="og:type" content="website">
<meta property="og:title" content="如云泊">
<meta property="og:url" content="https://lifeislife.cn/page/15/index.html">
<meta property="og:site_name" content="如云泊">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Dominic">
<meta name="twitter:card" content="summary">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="../../css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-PS8L2EEEPR');
</script>


    


<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="如云泊" type="application/atom+xml">
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="../../index.html">
                
                <img src="../../images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="../../archives">Archives</a>
            
            <a class="navbar-item "
               href="../../about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" target="_blank" rel="noopener" href="https://github.com/Dunky-Z">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/" itemprop="url">计算机组成原理-指令和运算</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-02-28T13:28:56.000Z" itemprop="datePublished">2月 28 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 读完 (约 7252 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="计算机指令"><a href="#计算机指令" class="headerlink" title="计算机指令"></a>计算机指令</h2><p>上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0 表示不打孔，1 表示打孔），送入特殊的计算机中执行。</p>
<p>从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。</p>
<p>从软件的角度来看，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作<strong>机器语言</strong>（Machine Language）。</p>
<p>不同的 CPU 能够听懂的语言不太一样。也就是 CPU 支持的语言不一样，这里的语言叫<strong>指令集</strong>（Instruction Set）。</p>
<p>一个计算机程序由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作<strong>存储程序型计算机</strong>（Stored-program Computer）。</p>
<p>了解了计算机指令和计算机指令集，接下来我们来看看，平时编写的代码，到底是怎么变成一条条计算机指令，最后被 CPU 执行的呢？我们拿一小段真实的 C 语言程序来看看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; <br>  <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>  a = a + b;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过编译器，可以将上述代码编译成汇编代码，再通过汇编器，将汇编代码编译成机器码，最后通过 CPU 执行。</p>
<p>在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -g -c test.c<br>$ objdump -d -M intel -S test.o<br><br>test.o:     file format elf64-x86-64<br>Disassembly of section .text:<br>0000000000000000 &lt;main&gt;:<br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br>   0:   55                      push   rbp<br>   1:   48 89 e5                mov    rbp,rsp<br>  int a = 1; <br>   4:   c7 45 <span class="hljs-built_in">fc</span> 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1<br>  int b = 2;<br>   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2<br>  a = a + b;<br>  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]<br>  15:   01 45 <span class="hljs-built_in">fc</span>                add    DWORD PTR [rbp-0x4],eax<br>&#125;<br>  18:   5d                      pop    rbp<br>  19:   c3                      ret    <br></code></pre></td></tr></table></figure>

<p>左侧有一堆数字，这些就是一条条机器码；右边有一系列的<code>push</code>、<code>mov</code>、<code>add</code>、<code>pop</code> 等，这些就是对应的汇编代码。</p>
<p>了解了这个过程，下面我们放大局部，来看看这一行行的汇编代码和机器指令，到底是什么意思。</p>
<p>常见的指令可以分成五大类。</p>
<p>第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。</p>
<p>第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。</p>
<p>第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。</p>
<p>第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。</p>
<p>最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。</p>
<h2 id="指令跳转"><a href="#指令跳转" class="headerlink" title="指令跳转"></a>指令跳转</h2><h3 id="CPU-如何执行指令的"><a href="#CPU-如何执行指令的" class="headerlink" title="CPU 如何执行指令的"></a>CPU 如何执行指令的</h3><p>代码经过软件层面的编译后就是一条条二进制指令，指令交由 CPU 中几百亿个晶体管去执行。我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。而寄存器就是 CPU 内部，由多个<strong>触发器</strong>（Flip-Flop）或者<strong>锁存器</strong>（Latches）组成的简单电路。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。</p>
<p><code>N</code> 个触发器或者锁存器，就可以组成一个<code>N</code>位（Bit）的寄存器，能够保存 <code>N</code>位的数据。比方说，我们用的<code>64</code>位 <code>Intel</code>服务器，寄存器就是<code>64</code> 位的。</p>
<p>一个 CPU 里面会有很多种不同功能的寄存器。这里介绍三种比较特殊的。</p>
<ul>
<li><p>PC 寄存器（Program Counter Register），我们也叫<strong>指令地址寄存器</strong>（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。</p>
</li>
<li><p>指令寄存器（Instruction Register），用来存放当前正在执行的指令。</p>
</li>
<li><p>条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。</p>
</li>
</ul>
<p>除此之外还有<strong>整数寄存器</strong>、<strong>浮点数寄存器</strong>、<strong>向量寄存器</strong>和<strong>地址寄存器</strong>等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。</p>
<p>实际上，一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。</p>
<p>而有些特殊指令，比如上一讲我们讲到 <code>J</code> 类指令，也就是跳转指令，会修改 PC 寄存器里面的地址值。</p>
<h3 id="从-if…else-来看程序的执行和跳转"><a href="#从-if…else-来看程序的执行和跳转" class="headerlink" title="从 if…else 来看程序的执行和跳转"></a>从 if…else 来看程序的执行和跳转</h3><p>首先看如下的例程，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  srand(time(<span class="hljs-literal">NULL</span>));<br>  <span class="hljs-keyword">int</span> r = rand() % <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>)<br>  &#123;<br>    a = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    a = <span class="hljs-number">2</span>;<br>  &#125; <br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g -c test.c<br>objdump -d -M intel -S test.o <br></code></pre></td></tr></table></figure>

<p>编译后打印出汇编代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">if (r == <span class="hljs-number">0</span>)<br> 3b:   <span class="hljs-number">83</span> <span class="hljs-number">7d</span> fc <span class="hljs-number">00</span>             <span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>],<span class="hljs-number">0x0</span><br> 3f:   <span class="hljs-number">75</span> <span class="hljs-number">09</span>                   <span class="hljs-keyword">jne</span>    4a &lt;main+<span class="hljs-number">0x4a</span>&gt;<br>   &#123;<br>       a = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br> <span class="hljs-number">41</span>:   c7 <span class="hljs-number">45</span> f8 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>],<span class="hljs-number">0x1</span><br> <span class="hljs-number">48</span>:   eb <span class="hljs-number">07</span>                   <span class="hljs-keyword">jmp</span>    <span class="hljs-number">51</span> &lt;main+<span class="hljs-number">0x51</span>&gt;<br>   &#125;<br>   else<br>   &#123;<br>       a = <span class="hljs-number">2</span><span class="hljs-comment">;</span><br> 4a:   c7 <span class="hljs-number">45</span> f8 <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>],<span class="hljs-number">0x2</span><br> <span class="hljs-number">51</span>:   b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0</span><br>   &#125; <br></code></pre></td></tr></table></figure>

<p>可以看到，这里对于 <code>r == 0</code>的条件判断，被编译成了 cmp 和 jne 这两条指令。</p>
<p><code>cmp</code> 指令比较了前后两个操作数的值，这里的<code>DWORD PTR</code> 代表操作的数据类型是 <code>32</code>位的整数，而 <code>[rbp-0x4]</code> 则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量 <code>r</code> 的值。第二个操作数 <code>0x0</code> 就是我们设定的常量<code>0</code>的 <code>16</code> 进制表示。<code>cmp</code> 指令的比较结果，会存入到条件码寄存器当中去。</p>
<p>在这里，如果比较的结果是 <code>True</code>，也就是 <code>r == 0</code>，就把零标志条件码（对应的条件码是 <code>ZF</code>，<code>Zero Flag</code>）设置为 <code>1</code>。除了零标志之外，<code>Intel</code> 的 <code>CPU</code> 下还有进位标志（<code>CF</code>，<code>Carry Flag</code>）、符号标志（<code>SF</code>，<code>Sign Flag</code>）以及溢出标志（<code>OF</code>，<code>Overflow Flag</code>），用在不同的判断条件下。</p>
<p><code>cmp</code> 指令执行完成之后，<code>PC</code> 寄存器会自动自增，开始执行下一条 <code>jne</code> 的指令。</p>
<p>跟着的 <code>jne</code> 指令，是 <code>jump if not equal</code> 的意思，它会查看对应的零标志位。如果为<code>0</code>，会跳转到后面跟着的操作数 <code>4a</code> 的位置。这个 <code>4a</code>，对应这里汇编代码的行号，也就是上面设置的 <code>else</code> 条件里的第一条指令。当跳转发生的时候，<code>PC</code> 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 <code>4a</code> 这个地址。这个时候，<code>CPU</code> 再把 <code>4a</code> 地址里的指令加载到指令寄存器中来执行。</p>
<p>跳转到执行地址为 <code>4a</code> 的指令，实际是一条 <code>mov</code> 指令，第一个操作数和前面的 <code>cmp</code> 指令一样，是另一个 <code>32</code> 位整型的寄存器地址，以及对应的 <code>2</code> 的<code>16</code> 进制值 <code>0x2</code>。<code>mov</code> 指令把 <code>2</code> 设置到对应的寄存器里去，相当于一个赋值操作。然后，<code>PC</code>寄存器里的值继续自增，执行下一条 <code>mov</code> 指令。</p>
<p>这条 <code>mov</code> 指令的第一个操作数<code>eax</code>，代表累加寄存器，第二个操作数<code>0x0</code>则是 <code>16</code> 进制的<code>0</code>的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的 <code>if</code> 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 <code>jmp</code> 的无条件跳转指令。跳转的地址就是这一行的地址<code>51</code>。我们的 <code>main</code> 函数没有设定返回值，而<code>mov eax</code>, <code>0x0</code> 其实就是给 <code>main</code> 函数生成了一个默认的为 <code>0</code> 的返回值到累加器里面。<code>if</code> 条件里面的内容执行完成之后也会跳转到这里，和 <code>else</code> 里的内容结束之后的位置是一样的。</p>
<h2 id="函数调用：为什么会发生-Stack-Overflow"><a href="#函数调用：为什么会发生-Stack-Overflow" class="headerlink" title="函数调用：为什么会发生 Stack Overflow"></a>函数调用：为什么会发生 Stack Overflow</h2><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>既然我们的程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在 Linux 下可以运行，而在 Windows 下却不行呢？反过来，Windows 上的程序在 Linux 上也是一样不能执行的。可是我们的 CPU 并没有换掉，它应该可以识别同样的指令呀？</p>
<p>将以下两个例程编译，然后通过 objdump 命令看看它们的汇编代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// add_lib.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-comment">// link_example.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> c = add(a, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %d\n&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g -c add_lib.c link_example.c<br>objdump -d -M intel -S add_lib.o<br>objdump -d -M intel -S link_example.o<br></code></pre></td></tr></table></figure>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">add_lib.o:</span>     file format elf64-x86-<span class="hljs-number">64</span><br>Disassembly of <span class="hljs-meta">section</span> .text:<br><span class="hljs-number">0000000000000000</span> &lt;<span class="hljs-keyword">add</span>&gt;:<br>   <span class="hljs-number">0</span>:   <span class="hljs-number">55</span>                      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbp</span><br>   <span class="hljs-number">1</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbp</span>,<span class="hljs-built_in">rsp</span><br>   <span class="hljs-number">4</span>:   <span class="hljs-number">89</span> <span class="hljs-number">7d</span> fc                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>],<span class="hljs-built_in">edi</span><br>   <span class="hljs-number">7</span>:   <span class="hljs-number">89</span> <span class="hljs-number">75</span> f8                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>],<span class="hljs-built_in">esi</span><br><span class="hljs-symbol">   a:</span>   8b <span class="hljs-number">55</span> fc                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>]<br><span class="hljs-symbol">   d:</span>   8b <span class="hljs-number">45</span> f8                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>]<br>  <span class="hljs-number">10</span>:   <span class="hljs-number">01</span> d0                   <span class="hljs-keyword">add</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">edx</span><br>  <span class="hljs-number">12</span>:   <span class="hljs-number">5d</span>                      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rbp</span><br>  <span class="hljs-number">13</span>:   c3                      <span class="hljs-keyword">ret</span>    <br></code></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">link_example</span>.o:     file format elf<span class="hljs-number">64</span>-x<span class="hljs-number">86</span>-<span class="hljs-number">64</span><br><span class="hljs-attribute">Disassembly</span> of section .text:<br><span class="hljs-attribute">0000000000000000</span> &lt;main&gt;:<br>   <span class="hljs-attribute">0</span>:   <span class="hljs-number">55</span>                      push   rbp<br>   <span class="hljs-attribute">1</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e<span class="hljs-number">5</span>                mov    rbp,rsp<br>   <span class="hljs-attribute">4</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>             sub    rsp,<span class="hljs-number">0</span>x<span class="hljs-number">10</span><br>   <span class="hljs-attribute">8</span>:   c<span class="hljs-number">7</span> <span class="hljs-number">45</span> fc <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    mov    DWORD PTR<span class="hljs-meta"> [rbp-0x4],0xa</span><br><span class="hljs-meta">   f:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5</span><br><span class="hljs-meta">  16:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]</span><br>  <span class="hljs-attribute">19</span>:   <span class="hljs-number">8</span>b <span class="hljs-number">45</span> fc                mov    eax,DWORD PTR<span class="hljs-meta"> [rbp-0x4]</span><br>  <span class="hljs-attribute">1c</span>:   <span class="hljs-number">89</span> d<span class="hljs-number">6</span>                   mov    esi,edx<br>  <span class="hljs-attribute">1e</span>:   <span class="hljs-number">89</span> c<span class="hljs-number">7</span>                   mov    edi,eax<br>  <span class="hljs-attribute">20</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    eax,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><br>  <span class="hljs-attribute">25</span>:   e<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          call   <span class="hljs-number">2</span>a &lt;main+<span class="hljs-number">0</span>x<span class="hljs-number">2</span>a&gt;<br>  <span class="hljs-attribute">2a</span>:   <span class="hljs-number">89</span> <span class="hljs-number">45</span> f<span class="hljs-number">4</span>                mov    DWORD PTR<span class="hljs-meta"> [rbp-0xc],eax</span><br><span class="hljs-meta">  2d:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]</span><br>  <span class="hljs-attribute">30</span>:   <span class="hljs-number">89</span> c<span class="hljs-number">6</span>                   mov    esi,eax<br>  <span class="hljs-attribute">32</span>:   <span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">3</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    lea    rdi,[rip+<span class="hljs-number">0</span>x<span class="hljs-number">0</span>]        # <span class="hljs-number">39</span> &lt;main+<span class="hljs-number">0</span>x<span class="hljs-number">39</span>&gt;<br>  <span class="hljs-attribute">39</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    eax,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><br>  <span class="hljs-attribute">3e</span>:   e<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          call   <span class="hljs-number">43</span> &lt;main+<span class="hljs-number">0</span>x<span class="hljs-number">43</span>&gt;<br>  <span class="hljs-attribute">43</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    eax,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><br>  <span class="hljs-attribute">48</span>:   c<span class="hljs-number">9</span>                      leave  <br>  <span class="hljs-attribute">49</span>:   c<span class="hljs-number">3</span>                      ret    <br></code></pre></td></tr></table></figure>

<p>既然代码已经被我们“编译”成了指令，我们不妨尝试运行一下 <code>./link_example.o</code>。</p>
<p>然而我们并不能成功运行，会得到一条<code>cannot execute binary file: Exec format error</code> 的错误。</p>
<p>我们再仔细看一下 objdump 出来的两个文件的代码，<strong>会发现两个程序的地址都是从 0 开始的</strong>。如果地址是一样的，程序如果需要通过 <code>call</code> 指令调用函数的话，<strong>它怎么知道应该跳转到哪一个文件里呢？</strong></p>
<p>无论是这里的运行报错，还是 <code>objdump</code> 出来的汇编代码里面的重复地址，都是因为<code>add_lib.o</code>以及 <code>link_example.o</code> 并不是一个可执行文件（Executable Program），而是目标文件（Object File）。<strong>只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。</strong></p>
<p>通过 <code>gcc</code> 的<code>-o</code>参数，可以生成对应的可执行文件。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>gcc -o link-example add_lib.o link_example.o<br><span class="hljs-variable">$ </span>./link_example<br>c = <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure>

<p>ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203032207712.png"></p>
<p>链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203032209801.png"></p>
<p>在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。</p>
<p>为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。其中一个非常重要的原因就是，<strong>两个操作系统下可执行文件的格式不一样</strong>。</p>
<p>我们今天讲的是 Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作 PE（Portable Executable Format）的文件格式。<strong>Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。</strong></p>
<p>如果我们有一个可以能够解析 PE 格式的装载器，我们就有可能在 Linux 下运行 Windows 程序了。这样的程序真的存在吗？没错，Linux 下著名的开源项目 Wine，就是通过兼容 PE 格式的装载器，使得我们能直接在 Linux 下运行 Windows 程序的。而现在微软的 Windows 里面也提供了 WSL，也就是 Windows Subsystem for Linux，可以解析和加载 ELF 格式的文件。</p>
<h2 id="程序装载"><a href="#程序装载" class="headerlink" title="程序装载"></a>程序装载</h2><h4 id="程序装载面临的挑战"><a href="#程序装载面临的挑战" class="headerlink" title="程序装载面临的挑战"></a>程序装载面临的挑战</h4><ul>
<li>可执行程序加载后占用的内存空间应该是连续的。<br>  这点很好理解，指令正常都是顺序执行的。</li>
<li>我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。<br>  计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用了。</li>
</ul>
<p>我们把指令里用到的内存地址叫作<strong>虚拟内存地址</strong>（Virtual Memory Address），实际在内存硬件里面的空间地址，我们叫<strong>物理内存地址</strong>（Physical Memory Address）。</p>
<p>程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了。对于任何一个程序来说，它看到的都是同样的内存地址。我们<strong>维护一个虚拟内存到物理内存的映射表</strong>，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。</p>
<h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><p>这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫<strong>分段</strong>（Segmentation）。这里的段，就是指系统分配出来的那个连续的内存空间。</p>
<p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处，第一个就是<strong>内存碎片</strong>（Memory Fragmentation）的问题。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203051544158.png"></p>
<p>我们可以通过<strong>内存交换</strong>（Memory Swapping）技术解决。</p>
<p>我们可以把 Python 程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里面。不过读回来的时候，我们不再把它加载到原来的位置，而是紧紧跟在那已经被占用了的 512MB 内存后面。这样，我们就有了连续的 256MB 内存空间，就可以去加载一个新的 200MB 的程序。</p>
<p>如果你自己安装过 Linux 操作系统，你应该遇到过分配一个 swap 硬盘分区的问题。这块分出来的磁盘空间，其实就是专门给 Linux 操作系统进行内存交换用的。</p>
<p>硬盘的访问速度要比内存慢很多，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。</p>
<h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p>既然问题出在内存碎片和内存交换的空间太大上，那么解决问题的办法就是，<strong>少出现一些内存碎片，并且让需要交换写入或者从磁盘装载的数据更少一点</strong>。于是就有了内存分页（Paging）。</p>
<p><strong>和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小</strong>。而对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。</p>
<p>从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。页的尺寸一般远远小于整个程序的大小。在 Linux 下，我们通常只设置成 4KB。</p>
<p><strong>由于内存空间都是预先划分好的，也就没有了不能使用的碎片</strong>，而只有被释放出来的很多 4KB 的页。即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，让整个机器被内存交换的过程给卡住。</p>
<p>分页的方式使得我们在加载程序的时候，<strong>不再需要一次性都把程序加载到物理内存中</strong>。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</p>
<p>实际上，我们的操作系统，的确是这么做的。当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的<strong>缺页错误</strong>（Page Fault）。我们的操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>如果我们有很多个程序都要通过装载器装载到内存里面，那里面链接好的同样的功能代码，也都需要再装载一遍，再占一遍内存空间。在一个运行上百个进程的系统中，这将会造成极大的资源浪费。</p>
<p>共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>（dynamic linking）是由一个叫做<strong>动态链接器</strong>（dynamic linker）的程序来执行的。Linux 中为<code>.so</code>文件，Windows 中为<code>.dll</code>文件。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203061034401.png"></p>
<h3 id="PIC-（Position-Independent-Code）"><a href="#PIC-（Position-Independent-Code）" class="headerlink" title="PIC （Position-Independent Code）"></a>PIC （Position-Independent Code）</h3><p>要想要在程序运行的时候共享代码，也有一定的要求，就是这些机器码必须是“<strong>地址无关</strong>”的。也就是说，我们编译出来的共享库文件的指令代码，放在哪个内存地址都能正常运行。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203061037029.png"></p>
<p>对于所有动态链接共享库的程序来讲，虽然我们的<strong>共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的</strong>。我们没办法、也不应该要求动态链接同一个共享库的不同程序，必须把这个共享库所使用的虚拟内存地址变成一致。如果这样的话，我们写的程序就必须明确地知道内部的内存地址分配。</p>
<p>如何才能实现地址无关？</p>
<p>动态代码库内部的变量和函数调用都很容易解决，我们只需要使用<strong>相对地址</strong>（Relative Address）就好了。各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。因为整个共享库是放在一段连续的虚拟内存地址中的，无论装载到哪一段地址，不同指令之间的相对地址都是不变的。</p>
<h3 id="PLT-和-GOT"><a href="#PLT-和-GOT" class="headerlink" title="PLT 和 GOT"></a>PLT 和 GOT</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// lib.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LIB_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIB_H</span><br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_me_the_money</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">// lib.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_me_the_money</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Show me USD %d from lib.c \n&quot;</span>, money);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// show_me_poor.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lib.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> money = <span class="hljs-number">5</span>;<br>    show_me_the_money(money);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">gcc <span class="hljs-keyword">lib</span>.c -fPIC -<span class="hljs-keyword">shared</span> -o <span class="hljs-keyword">lib</span>.so<br>gcc -o show_me_poor show_me_poor.c ./<span class="hljs-keyword">lib</span>.so<br></code></pre></td></tr></table></figure>

<p><code>-fpic</code> 选项指示编译器生成与位置无关的代码。<code>-shared</code>选项指示链接器创建一个共享的目标文件。</p>
<p>然后，我们再通过 <code>gcc</code> 编译 <code>show_me_poor</code> 动态链接了 <code>lib.so</code> 的可执行文件。在这些操作都完成了之后，我们把 <code>show_me_poor</code> 这个文件通过 <code>objdump</code> 出来看一下。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">$ objdump -d -M intel -S show_me_poor<br><br>……<br><span class="hljs-number">0000000000400540</span> &lt;show_me_the_money@plt-<span class="hljs-number">0x10</span>&gt;:<br>  <span class="hljs-number">400540</span>:       ff <span class="hljs-number">35</span> <span class="hljs-number">12</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">push</span>   <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x200512</span>]        # 600a58 &lt;_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x8</span>&gt;<br>  <span class="hljs-number">400546</span>:       ff <span class="hljs-number">25</span> <span class="hljs-number">14</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">jmp</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x200514</span>]        # 600a60 &lt;_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x10</span>&gt;<br>  40054c:       0f 1f <span class="hljs-number">40</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">nop</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0x0</span>]<br> <br><span class="hljs-number">0000000000400550</span> &lt;show_me_the_money@plt&gt;:<br>  <span class="hljs-number">400550</span>:       ff <span class="hljs-number">25</span> <span class="hljs-number">12</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">jmp</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x200512</span>]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x18</span>&gt;<br>  <span class="hljs-number">400556</span>:       <span class="hljs-number">68</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">push</span>   <span class="hljs-number">0x0</span><br>  40055b:       e9 e0 ff ff ff          <span class="hljs-keyword">jmp</span>    <span class="hljs-number">400540</span> &lt;_init+<span class="hljs-number">0x28</span>&gt;<br>……<br><span class="hljs-number">0000000000400676</span> &lt;main&gt;:<br>  <span class="hljs-number">400676</span>:       <span class="hljs-number">55</span>                      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbp</span><br>  <span class="hljs-number">400677</span>:       <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbp</span>,<span class="hljs-built_in">rsp</span><br>  40067a:       <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>             <span class="hljs-keyword">sub</span>    <span class="hljs-built_in">rsp</span>,<span class="hljs-number">0x10</span><br>  40067e:       c7 <span class="hljs-number">45</span> fc <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>],<span class="hljs-number">0x5</span><br>  <span class="hljs-number">400685</span>:       8b <span class="hljs-number">45</span> fc                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>]<br>  <span class="hljs-number">400688</span>:       <span class="hljs-number">89</span> c7                   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>,<span class="hljs-built_in">eax</span><br>  40068a:       e8 c1 fe ff ff          <span class="hljs-keyword">call</span>   <span class="hljs-number">400550</span> &lt;show_me_the_money@plt&gt;<br>  40068f:       c9                      <span class="hljs-keyword">leave</span>  <br>  <span class="hljs-number">400690</span>:       c3                      <span class="hljs-keyword">ret</span>    <br>  <span class="hljs-number">400691</span>:       <span class="hljs-number">66</span> 2e 0f 1f <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">nop</span>    <span class="hljs-built_in">WORD</span> <span class="hljs-built_in">PTR</span> <span class="hljs-built_in">cs</span>:[<span class="hljs-built_in">rax</span>+<span class="hljs-built_in">rax</span>*<span class="hljs-number">1</span>+<span class="hljs-number">0x0</span>]<br>  <span class="hljs-number">400698</span>:       <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  40069b:       0f 1f <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">nop</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>+<span class="hljs-built_in">rax</span>*<span class="hljs-number">1</span>+<span class="hljs-number">0x0</span>]<br>……<br></code></pre></td></tr></table></figure>

<p>在 <code>main</code> 函数调用 <code>show_me_the_money</code> 的函数的时候，对应的代码是这样的：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">call</span>   <span class="hljs-number">400550</span> &lt;show_me_the_money<span class="hljs-symbol">@plt</span>&gt;<br></code></pre></td></tr></table></figure>

<p>这里后面有一个<code>@plt</code> 的关键字，代表了我们需要从<code>PLT</code>，也就是<strong>过程链接表</strong>（Procedure Link Table）里面找要调用的函数。对应的地址呢，则是 <code>400550</code> 这个地址。</p>
<p>那当我们把目光挪到上面的 400550 这个地址，你又会看到里面进行了一次跳转，这个跳转指定的跳转地址，你可以在后面的注释里面可以看到，GLOBAL_OFFSET_TABLE+0x18。这里的 GLOBAL_OFFSET_TABLE，就是我接下来要说的全局偏移表。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">400550</span>:       ff <span class="hljs-number">25</span> <span class="hljs-number">12</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       jmp    QWORD PTR<span class="hljs-meta"> [rip+0x200512]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt;</span><br></code></pre></td></tr></table></figure>

<p>在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张<strong>全局偏移表</strong>（GOT，Global Offset Table）。<strong>虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的</strong>。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。</p>
<p>虽然不同的程序调用的同样的动态库，各自的内存地址是独立的，调用的又都是同一个动态库，但是不需要去修改动态库里面的代码所使用的地址，而是各个程序各自维护好自己的 GOT，能够找到对应的动态库就好了。</p>
<h2 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h2><p>原码表示法，左侧第一位是符号位，符号位为 1 时表示负数，为 0 时表示正数。<br>补码表示法，我们不再把这一位当成单独的符号位，在剩下几位计算出的十进制前加上正负号，而是在计算整个二进制值的时候，在左侧最高位前面加个负号。</p>
<p>比如，一个 4 位的二进制补码数值 1011，转换成十进制，就是<br>$-1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1  + 1 \times 2^0 = -5$</p>
<p>一个 4 位的二进制数，可以表示从 -8 到 7 这 16 个整数，不会白白浪费一位。</p>
<p>字符集：表示的可以是字符的一个集合。比如说“第一版《新华字典》里面出现的所有汉字”，这是一个中文字符集。比如，我们日常说的<code>Unicode</code>，其实就是一个字符集，包含了 150 种语言的 14 万个不同的字符。</p>
<p>字符编码：对于字符集里的这些字符，怎么一一用二进制表示出来的一个字典。我们上面说的 <code>Unicode</code>，就可以用<code>UTF-8</code>、<code>UTF-16</code>，乃至 <code>UTF-32</code> 来进行编码，存储成二进制。</p>
<p>同样的文本，采用不同的编码存储下来。如果另外一个程序，用一种不同的编码方式来进行解码和展示，就会出现乱码。</p>
<h3 id="锟斤拷-烫烫烫"><a href="#锟斤拷-烫烫烫" class="headerlink" title="锟斤拷 烫烫烫"></a>锟斤拷 烫烫烫</h3><p>Unicode 编码一直持续在收录各种字元，这就可能会出现各种作业系统支援的 Unicode 字元不一样。这也就会导致 A 上的一个用 Unicode 编码的字元，在 B 上就会出现无法显示的情况。为了避免这种情况，在 Unicode 中定义了一个特殊字元�，它的 Unicode 编码为 0xFFFD。</p>
<p>假如 A 支援特殊字元⬆，但是 B 并不支援这个⬆，那么在 B 中将会用�来代替。</p>
<p>这个字元用 UTF-8 编码后，十六进位表示为<code>0xEF 0XBF 0XBD</code>。如果连续出现两个⬆符号，那么用 UTF-8 编码后的十六进位则表示为<code>0xEF 0XBF 0XBD 0xEF 0XBF 0XBD</code>，这时候再转码成 GBK，因为 GBK 中用两个位元组表示一个字元，那么上述的字元就成了锟（<code>0xEFBF</code>），斤（<code>0xBDEF</code>），拷（<code>0xBFBD</code>）。出现锟斤拷的原因就是 UTF-8 转码 GBK 的过程中出现了问题。当然如果想要出现锟斤拷，则至少需要两个字元出现乱码。</p>
<p>而“烫烫烫”，则是因为如果你用了 Visual Studio 的调试器，默认使用 MBCS 字符集。“烫”在里面是由 <code>0xCCCC</code> 来表示的，而 <code>0xCC</code> 又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。</p>
<h2 id="理解电路"><a href="#理解电路" class="headerlink" title="理解电路"></a>理解电路</h2><p>从以上的学习可以知道，最终执行的程序都是二进制的指令。那为何计算机最终选择了二进制呢？接下来看看计算机在硬件层面究竟是怎么表示二进制的，以此你就会明白，为什么计算机会选择二进制。</p>
<h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><h2 id="乘法器"><a href="#乘法器" class="headerlink" title="乘法器"></a>乘法器</h2><h2 id="浮点数和定点数"><a href="#浮点数和定点数" class="headerlink" title="浮点数和定点数"></a>浮点数和定点数</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/02/16/%E8%A7%A3%E5%86%B3OpenSSL-SSL-read-Connection-was-reset-errno-10054/" itemprop="url">解决 OpenSSL SSL_read: Connection was reset, errno 10054</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-02-16T03:12:31.000Z" itemprop="datePublished">2月 16 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/Bug-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">Bug 踩坑记录</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 分钟 读完 (约 184 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法一：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">http</span>.sslVerify <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> https<span class="hljs-variable">.sslVerify</span> <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure>

<p>方法三：<br>这可能是因为版本库的大小和 git 的默认缓冲区大小，所以通过下述操作（在 git bash 上），git 的缓冲区大小会增加。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//在仓库init后，添加以下配置</span><br>git <span class="hljs-keyword">config</span> http<span class="hljs-variable">.postBuffer</span> <span class="hljs-number">524288000</span><br><span class="hljs-comment">//如果仓库不是自己的，可以添加以下配置</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> http<span class="hljs-variable">.postBuffer</span> <span class="hljs-number">524288000</span><br></code></pre></td></tr></table></figure>

<p>方法四：<br>网速太慢，换个网速快的环境。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/46232906/git-clone-error-rpc-failed-curl-56-openssl-ssl-read-ssl-error-syscall-errno">windows - git clone error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 - Stack Overflow</a><br><a target="_blank" rel="noopener" href="https://chowdera.com/2021/08/20210816115836695u.html">解决 OpenSSL SSL_read: Connection was reset, errno 10054 問題</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/02/11/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84/" itemprop="url">C 语言中的变长数组与零长数组</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-02-11T13:09:35.000Z" itemprop="datePublished">2月 11 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            10 分钟 读完 (约 1553 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>想必很多学习 C 语言的人都会在书上看到，<strong>数组在初始化时必须要确定长度（维度）</strong>，也就是说定义数组时，维度一定要用常量。但是在编程中很多人肯定发现了，及时像下面这样写，编译器也不会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> n;             <br><span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[n];    <br></code></pre></td></tr></table></figure>

<p>这是怎么回事？难道以前我学的是错的吗？当然不是。最官方的解释应该是 C 语言的规范和编译器的规范说明了。</p>
<ul>
<li>在 ISO/IEC9899 标准的 <a target="_blank" rel="noopener" href="http://busybox.net/~landley/c99-draft.html#6.7.5.2">6.7.5.2 Array declarators</a> 中明确说明了数组的长度可以为变量的，称为变长数组（VLA，variable length array）。（注：这里的变长指的是数组的长度是在运行时才能决定，但一旦决定在数组的生命周期内就不会再变。）</li>
<li>在 GCC 标准规范的 <a target="_blank" rel="noopener" href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">6.19 Arrays of Variable Length</a> 中指出，作为编译器扩展，GCC 在 C90 模式和 C++ 编译器下遵守 ISO C99 关于变长数组的规范。</li>
</ul>
<p>原来这种语法确实是 C 语言规范，GCC 非常完美的支持了 ISO C99。但是在 C99 之前的 C 语言中，变长数组的语法是不存在的。</p>
<p>这种变长数组有什么好处呢？它可以实现与<code>alloca</code>函数一样的效果，在栈上进行动态的空间分配，并且在函数返回时自动释放内存，无需手动释放。</p>
<blockquote>
<p><code>alloca</code> 函数用来在栈上分配空间，当函数返回时自动释放，无需手动再去释放；</p>
</blockquote>
<p>可变数组示例：<br>所有可变修改 (VM) 类型的声明必须在块范围或函数原型范围内。使用 <code>static</code> 或 <code>extern</code> 存储类说明符声明的数组对象不能具有可变长度数组 (VLA) 类型。但是，使用静态存储类说明符声明的对象可以具有 <code>VM</code> 类型（即，指向 <code>VLA</code> 类型的指针）。最后，使用 <code>VM</code> 类型声明的所有标识符都必须是普通标识符，因此<strong>不能是结构或联合的成员</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> A[n];                       <span class="hljs-comment">// Error - file scope VLA.</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">int</span> <span class="hljs-params">(*p2)</span>[n]</span>;            <span class="hljs-comment">// Error - file scope VM.</span><br><span class="hljs-keyword">int</span> B[<span class="hljs-number">100</span>];                     <span class="hljs-comment">// OK - file scope but not VM.</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fvla</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> C[m][m])</span>   <span class="hljs-comment">// OK - VLA with prototype scope.</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> VLA[m][m]   <span class="hljs-comment">// OK - block scope typedef VLA.</span><br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> &#123;</span><br>                <span class="hljs-keyword">int</span> (*y)[n];        <span class="hljs-comment">// Error - y not ordinary identifier.</span><br>                <span class="hljs-keyword">int</span> z[n];           <span class="hljs-comment">// Error - z not ordinary identifier.</span><br>        &#125;;<br>        <span class="hljs-keyword">int</span> D[m];                   <span class="hljs-comment">// OK - auto VLA.</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> E[m];            <span class="hljs-comment">// Error - static block scope VLA.</span><br>        <span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> F[m];            <span class="hljs-comment">// Error - F has linkage and is VLA.</span><br>        <span class="hljs-keyword">int</span> (*s)[m];                <span class="hljs-comment">// OK - auto pointer to VLA.</span><br>        <span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">int</span> <span class="hljs-params">(*r)</span>[m]</span>;         <span class="hljs-comment">// Error - r had linkage and is</span><br>                                    <span class="hljs-comment">// a pointer to VLA.</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">int</span> <span class="hljs-params">(*q)</span>[m] </span>= &amp;B;    <span class="hljs-comment">// OK - q is a static block</span><br>                                    <span class="hljs-comment">// pointer to VLA.</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="零长数组"><a href="#零长数组" class="headerlink" title="零长数组"></a>零长数组</h2><p>GNU/GCC 在标准的 C/C++ 基础上做了有实用性的扩展，零长度数组（Arrays of Length Zero）就是其中一个知名的扩展。使用零长数组，把它作为结构体的最后一个元素非常有用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> &#123;</span><br>    <span class="hljs-keyword">int</span> length;<br>    <span class="hljs-keyword">char</span> contents[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> *<span class="hljs-title">thisline</span> =</span> (struct line *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span> (struct line) + this_length);<br>thisline-&gt;length = this_length;<br></code></pre></td></tr></table></figure>

<p>从上例就可以看出，零长数组在有固定头部的可变对象上非常适用，我们可以根据对象的大小动态地去分配结构体的大小。</p>
<p>在 <code>Linux</code> 内核中也有这种应用，例如由于 <code>PID</code> 命名空间的存在，每个进程 <code>PID</code> 需要映射到所有能看到其的命名空间上，但该进程所在的命名空间在开始并不确定（但至少为 <code>init</code> 命名空间），需要在运行是根据 <code>level</code> 的值来确定，所以在该结构体后面增加了一个长度为 <code>1</code> 的数组（因为至少在一个<code>init</code>命名空间上），使得该结构体 <code>pid</code> 是个可变长的结构体，在运行时根据进程所处的命名空间的 <code>level</code> 来决定 <code>numbers</code> 分配多大。（注：虽然不是零长度的数组，但用法是一样的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">atomic_t</span> count;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> level;<br>    <span class="hljs-comment">/* lists of tasks that use this pid */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span> <span class="hljs-title">tasks</span>[<span class="hljs-title">PIDTYPE_MAX</span>];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">upid</span> <span class="hljs-title">numbers</span>[1];</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="什么-0-长度数组不占用存储空间"><a href="#什么-0-长度数组不占用存储空间" class="headerlink" title="什么 0 长度数组不占用存储空间"></a>什么 0 长度数组不占用存储空间</h3><p>0 长度数组与指针实现有什么区别呢，为什么 0 长度数组不占用存储空间呢？</p>
<p>其实本质上涉及到的是一个 C 语言里面的数组和指针的区别问题。char a[1] 里面的 a 和 char *b 的 b 相同吗？</p>
<p>《Programming Abstractions in C》（Roberts, E. S.，机械工业出版社，2004.6）82 页里面说。</p>
<blockquote>
<p>“arr is defined to be identical to &amp;arr[0]”.</p>
</blockquote>
<p>也就是说，<code>char a[1]</code>里面的<code>a</code>实际是一个常量，等于<code>&amp;a[0]</code>。而<code>char *b</code>是有一个实实在在的指针变量<code>b</code>存在。所以，<code>a=b</code>是不允许的，而<code>b=a</code>是允许的。</p>
<p>本质上因为数组名它只是一个偏移量，数组名这个符号本身代 表了一个不可修改的<strong>地址常量</strong> （注意：数组名永远都不会是指针！ ），但对于这个数组的大小，我们可以进行动态分配，对于编译器而言，数组名仅仅是一个符号，它不会占用任何空间，它在结构体中，只是代表了一个偏移量，代表一个不可修改的地址常量！</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hazir/p/variable_length_array.html">alloca 函数用来在栈上分配空间，当函数返回时自动释放，无需手动再去释放</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gatieme/article/details/64131322">C 语言 0 长度数组 (可变数组/柔性数组) 详解_OSKernelLAB(gatieme)-CSDN 博客_柔性数组</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43083491/article/details/112632310">零长数组（柔性数组、可变数组）的使用_禾仔仔的博客-CSDN 博客</a></p>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Zero-Length.html#Zero-Length">Zero Length - Using the GNU Compiler Collection (GCC)</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/01/27/SSH%E5%8E%9F%E7%90%86/" itemprop="url">SSH 原理</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-27T13:30:29.000Z" itemprop="datePublished">1月 27 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            几秒 读完 (约 0 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url">QEMU 源码分析-内存虚拟化</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-25T05:42:11.000Z" itemprop="datePublished">1月 25 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/QEMU-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">QEMU 源码分析</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 读完 (约 10654 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>1.大部分转载自<a target="_blank" rel="noopener" href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a><br>2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改<br>3.部分内容根据自己理解补充添加</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：</p>
<ul>
<li>虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间；</li>
<li>虚拟机里面的物理内存（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存；</li>
<li>物理机的虚拟内存（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间；</li>
<li>物理机的物理内存（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。</li>
</ul>
<p>内存虚拟化的关键在于维护 <code>GPA</code> 到 <code>HVA</code> 的映射关系。</p>
<h2 id="页面分配和映射的两种方式"><a href="#页面分配和映射的两种方式" class="headerlink" title="页面分配和映射的两种方式"></a>页面分配和映射的两种方式</h2><p>要搞清楚 QEMU system emulation 的仿真架构，首先对于 Host OS，将 QEMU 作为进程启动，然后对于 QEMU 进程，会仿真各种硬件和运行 Guest OS，在这层 OS 上运行要全系统模拟的应用程序，因此对于 Guest OS 管理的内存要实现到 QEMU 进程的虚拟空间的转换需要 softMMU（即需要对 GPA 到 HVA 进行转换）。从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。</p>
<h3 id="影子页表-Shadow-Page-Table，SPT"><a href="#影子页表-Shadow-Page-Table，SPT" class="headerlink" title="影子页表 Shadow Page Table，SPT"></a>影子页表 Shadow Page Table，SPT</h3><p>第一种方式就是软件的方式，影子页表（Shadow Page Table）。</p>
<p>KVM 通过维护记录 GVA-&gt;HPA 的影子页表 SPT，减少了地址转换带来的开销，可以直接将 GVA 转换为 HPA。</p>
<p>内存映射要通过页表来管理，页表地址应该放在 CR3 寄存器里面。在软件虚拟化的内存转换中，GVA 到 GPA 的转换通过查询 CR3 寄存器来完成，CR3 中保存了 Guest 的页表基地址，然后载入 MMU 中进行地址转换。</p>
<p>在加入了 SPT 技术后，当 Guest 访问 CR3 时，KVM 会捕获到这个操作 EXIT_REASON_CR_ACCESS，之后 KVM 会载入特殊的 CR3 和影子页表，欺骗 Guest 这就是真实的 CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。</p>
<blockquote>
<p>本来的过程是，客户机要通过 cr3 找到客户机的页表，实现从 GVA 到 GPA 的转换，然后在宿主机上，要通过 cr3 找到宿主机的页表，实现从 HVA 到 HPA 的转换。<br>为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。<br>在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。</p>
</blockquote>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124192700.png"></p>
<p>为了快速检索 Guest 页表对应的影子页表，KVM 为每个客户机维护了一个 hash 表来进行客户机页表到影子页表之间的映射。对于每一个 Guest 来说，其页目录和页表都有唯一的 GPA，通过页目录/页表的 GPA 就可以在哈希链表中快速地找到对应的影子页目录/页表。</p>
<p>当 Guest 切换进程时，Guest 会把待切换进程的页表基址载入 CR3，而 KVM 将会截获这一特权指令。KVM 在哈希表中找到与此页表基址对应的影子页表基址，载入 Guest CR3，使 Guest 在恢复运行时 CR3 实际指向的是新切换进程对应的影子页表。</p>
<p>影子页表的引入，减少了 GVA-&gt;HPA 的转换开销，但是缺点在于需要为 Guest 的每个进程都维护一个影子页表，这将带来很大的内存开销。同时影子页表的建立是很耗时的，如果 Guest 的进程过多，将导致影子页表频繁切换。</p>
<p>因此 Intel 和 AMD 在此基础上提供了基于硬件的虚拟化技术 EPT。</p>
<h3 id="扩展页表-Extent-Page-Table，EPT"><a href="#扩展页表-Extent-Page-Table，EPT" class="headerlink" title="扩展页表 Extent Page Table，EPT"></a>扩展页表 Extent Page Table，EPT</h3><p>Intel 的 EPT（Extent Page Table）技术和 AMD 的 NPT（Nest Page Table）技术都对内存虚拟化提供了硬件支持。这两种技术原理类似，都是在硬件层面上实现 GVA 到 HPA 之间的转换。下面就以 EPT 为例分析一下 KVM 基于硬件辅助的内存虚拟化实现。</p>
<p>EPT 在原有客户机页表对客户机虚拟地址 GVA 到客户机物理地址 GPA 映射的基础上，又引入了 EPT 页表来实现客户机物理地址 GPA 到宿主机物理地址 HPA 的另一次映射。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。</p>
<p>即 EPT 技术采用了在两级页表结构，即原有 Guest OS 页表对 <strong>GVA-&gt;GPA</strong> 映射的基础上，又引入了 EPT 页表来实现 <strong>GPA-&gt;HPA</strong> 的另一次映射，这<strong>两次地址映射都是由硬件自动完成</strong>。</p>
<p>有了 EPT，在<strong>GPA-&gt;HPA</strong>转换的过程中，缺页会产生 EPT 缺页异常。KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。</p>
<p>KVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。</p>
<p>这里，我们重点看第二种方式。因为使用了 EPT 之后，客户机里面的页表映射，也即从 GVA 到 GPA 的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而 EPT 重点帮我们解决的就是从 GPA 到 HPA 的转换问题。因为要经过两次页表，所以 EPT 又 tdp(two dimentional paging)。</p>
<p>EPT 的页表结构也是分为四层，EPT Pointer（EPTP）指向 PML4 的首地址。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124194059.png"></p>
<h2 id="QEMU-的主要工作"><a href="#QEMU-的主要工作" class="headerlink" title="QEMU 的主要工作"></a>QEMU 的主要工作</h2><p>内存虚拟化的目的就是让虚拟机能够无缝的访问内存。有了 Intel EPT 的支持后，CPU 在 VMX non-root 状态时进行内存访问会再做一次 EPT 转换。在这个过程中，QEMU 会负责以下内容：</p>
<p>首先需要从自己的进程地址空间中申请内存用于 Guest<br>需要将上一步中申请到的内存的虚拟地址（HVA）和 Guest 的物理地址之间的映射关系传递给 KVM（kernel），即 GPA-&gt;HVA<br>需要组织一系列的数据结构来管理虚拟内存空间，并在内存拓扑结构更改时将最新的内存信息同步至 KVM 中</p>
<h2 id="QEMU-和-KVM-的工作分界"><a href="#QEMU-和-KVM-的工作分界" class="headerlink" title="QEMU 和 KVM 的工作分界"></a>QEMU 和 KVM 的工作分界</h2><p>QEMU 和 KVM 之间是通过 KVM 提供的 ioctl() 接口进行交互的。在内核的 kvm_vm_ioctl() 中，<strong>设置虚拟机内存</strong>的系统调用【kernel 就是一系列系统调用函数接口和处理逻辑，其中有个处理”创建/设置虚拟机内存“的系统调用接口】为  <code>VM_SET_USER_MEMORY_REGION</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">kvm_vm_ioctl</span><span class="hljs-params">(struct file *filp,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ioctl, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">case</span> KVM_SET_USER_MEMORY_REGION: &#123; <span class="hljs-comment">// 在 KVM 中注册用户空间传入的内存信息</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">kvm_userspace_mem</span>;</span><br><br>        r = -EFAULT;<br>         <span class="hljs-comment">// 将传入的数据结构复制到内核空间</span><br>        <span class="hljs-keyword">if</span> (copy_from_user(&amp;kvm_userspace_mem, argp, <span class="hljs-keyword">sizeof</span> kvm_userspace_mem))<br>            <span class="hljs-keyword">goto</span> out;<br><br>         <span class="hljs-comment">// 实际进行处理的函数</span><br>        r = kvm_vm_ioctl_set_memory_region(kvm, &amp;kvm_userspace_mem, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (r)<br>            <span class="hljs-keyword">goto</span> out;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里需要传递的参数类型为 <code>kvm_userspace_memory_region</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* for KVM_SET_USER_MEMORY_REGION */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;            <span class="hljs-comment">// slot 编号 [参考：https://www.cnblogs.com/LoyenWang/p/11922887.html]</span><br>    __u32 flags;           <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    __u64 guest_phys_addr; <span class="hljs-comment">// Guest 物理地址，即 GPA</span><br>    __u64 memory_size;     <span class="hljs-comment">// 内存大小，单位 bytes</span><br>    __u64 userspace_addr;  <span class="hljs-comment">// 从 QEMU 进程地址空间中分配内存的起始地址，即 HVA</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>KVM_SET_USER_MEMORY_REGION</code>这个 <code>ioctl</code> 主要目的就是设置<code>GPA-&gt;HVA</code>的映射关系，KVM 会继续调用<code>kvm_vm_ioctl_set_memory_region()</code>，在内核空间维护并管理 Guest 的内存。</p>
<h2 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h2><h3 id="AddressSpace"><a href="#AddressSpace" class="headerlink" title="AddressSpace"></a>AddressSpace</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>QEMU 用 AddressSpace 结构体表示 Guest 中 CPU/设备看到的内存【也就是Guest OS 可以在 QEMU 进程虚存中用到的所有内存，是 MemoryRegion 的集合，即 GPA 的整体】，类似于物理机中地址空间的概念，但在这里表示的是 Guest 的一段地址空间，如内存地址空间 <code>address_space_memory</code> 、<code>I/O</code> 地址空间<code>address_space_io</code>，它在 QEMU 源码<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSpace</span> &#123;</span><br>    <span class="hljs-comment">/* private: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-keyword">char</span> *name;<br>    MemoryRegion *root;<br><br>    <span class="hljs-comment">/* Accessed via RCU.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatView</span> *<span class="hljs-title">current_map</span>;</span><br><br>    <span class="hljs-keyword">int</span> ioeventfd_nb;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionIoeventfd</span> *<span class="hljs-title">ioeventfds</span>;</span><br>    QTAILQ_HEAD(, MemoryListener) listeners;<br>    QTAILQ_ENTRY(AddressSpace) address_spaces_link;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每个 AddressSpace 一般包含一系列的 MemoryRegion：<code>root</code>指针指向根级 MemoryRegion，而 root 可能有自己的若干个 sub-regions（子节点），于是形成树状结构。这些 MemoryRegion 通过树连接起来，树的根即为 AddressSpace 的 root 域。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>另外，QEMU 中有两个全局的静态 AddressSpace，在 memory.c 中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> AddressSpace address_space_memory; <span class="hljs-comment">// 内存地址空间</span><br><span class="hljs-keyword">static</span> AddressSpace address_space_io;     <span class="hljs-comment">// I/O 地址空间</span><br></code></pre></td></tr></table></figure>

<p>其 root 域分别指向之后会提到的两个 MemoryRegion 类型变量：system_memory、system_io。</p>
<h3 id="MemoryRegion"><a href="#MemoryRegion" class="headerlink" title="MemoryRegion"></a>MemoryRegion</h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>MemoryRegion</code> 表示在 <code>Guest Memory Layout</code> 中的一段内存区域【也就是单元级 GPA 的概念，Guest OS 可以管理到的那些 Guest 物理内存单元】，它是联系 <code>GPA</code> 和 <code>RAMBlocks</code>（描述真实内存）之间的桥梁，在<code>memory.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> &#123;</span><br>    <span class="hljs-comment">/* All fields are private - violators will be prosecuted */</span><br>    <span class="hljs-keyword">const</span> MemoryRegionOps *ops;      <span class="hljs-comment">// 回调函数集合</span><br>    <span class="hljs-keyword">void</span> *opaque;<br>    MemoryRegion *parent;            <span class="hljs-comment">// 父 MemoryRegion 指针</span><br>    Int128 size;                     <span class="hljs-comment">// 该区域内存的大小</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> addr;         <span class="hljs-comment">// 在 Address Space 中的地址，即 HVA</span><br>    <span class="hljs-keyword">void</span> (*destructor)(MemoryRegion *mr);<br>    <span class="hljs-keyword">ram_addr_t</span> ram_addr;             <span class="hljs-comment">// MemoryRegion 的起始地址，即 GPA</span><br>    <span class="hljs-keyword">bool</span> subpage;<br>    <span class="hljs-keyword">bool</span> terminates;<br>    <span class="hljs-keyword">bool</span> readable;<br>    <span class="hljs-keyword">bool</span> ram;                        <span class="hljs-comment">// 是否表示 RAM</span><br>    <span class="hljs-keyword">bool</span> readonly; <span class="hljs-comment">/* For RAM regions */</span><br>    <span class="hljs-keyword">bool</span> enabled;                    <span class="hljs-comment">// 是否已经通知 KVM 使用这段内存</span><br>    <span class="hljs-keyword">bool</span> rom_device;<br>    <span class="hljs-keyword">bool</span> warning_printed; <span class="hljs-comment">/* For reservations */</span><br>    MemoryRegion *alias;             <span class="hljs-comment">// 是否为 MemoryRegion alias</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> alias_offset; <span class="hljs-comment">// 若为 alias，在原 MemoryRegion 中的 offset</span><br>    <span class="hljs-keyword">unsigned</span> priority;<br>    <span class="hljs-keyword">bool</span> may_overlap;<br>    QTAILQ_HEAD(subregions, MemoryRegion) subregions; <span class="hljs-comment">// 子区域链表头</span><br>    QTAILQ_ENTRY(MemoryRegion) subregions_link;       <span class="hljs-comment">// 子区域链表节点</span><br>    QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;       <span class="hljs-comment">// MemoryRegion 的名字，调试时使用</span><br>    <span class="hljs-keyword">uint8_t</span> dirty_log_mask; <span class="hljs-comment">// 表示哪一种 dirty map 被使用，共分三种</span><br>    <span class="hljs-keyword">unsigned</span> ioeventfd_nb;<br>    MemoryRegionIoeventfd *ioeventfds;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><p>在 QEMU 的 exec.c 中也定义了两个静态的 MemoryRegion 指针变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> MemoryRegion *system_memory; <span class="hljs-comment">// 内存 MemoryRegion，对应 address_space_memory</span><br><span class="hljs-keyword">static</span> MemoryRegion *system_io;     <span class="hljs-comment">// I/O MemoryRegion，对应 address_space_io</span><br></code></pre></td></tr></table></figure>

<p>与两个全局 AddressSpace 对应，即 AddressSpace 的 root 域指向这两个 MemoryRegion。</p>
<h4 id="MemoryRegion-的类型"><a href="#MemoryRegion-的类型" class="headerlink" title="MemoryRegion 的类型"></a>MemoryRegion 的类型</h4><p>MemoryRegion 有多种类型，可以表示一段 RAM、ROM、MMIO、alias(别名)。</p>
<p>若为 alias 则表示一个 MemoryRegion 的部分区域，例如，QEMU 会为 pc.ram 这个表示 RAM 的 MemoryRegion 添加两个 alias：ram-below-4g 和 ram-above-4g，之后会看到具体的代码实例。</p>
<p>另外，MemoryRegion 也可以表示一个 container，这就表示它只是其他若干个 MemoryRegion 的容器。</p>
<p>那么要如何创建不同类型的 <code>MemoryRegion</code> 呢？</p>
<p>在 QEMU 中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将 MemoryRegion 划分为以下三种类型：</p>
<ul>
<li>根级 MemoryRegion：直接通过 memory_region_init 初始化，没有自己的内存，用于管理 subregion，例如 system_memory：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    mr-&gt;ops = <span class="hljs-literal">NULL</span>;<br>    mr-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    mr-&gt;size = int128_make64(size);<br>    <span class="hljs-keyword">if</span> (size == UINT64_MAX) &#123;<br>        mr-&gt;size = int128_2_64();<br>    &#125;<br>    mr-&gt;addr = <span class="hljs-number">0</span>;<br>    mr-&gt;subpage = <span class="hljs-literal">false</span>;<br>    mr-&gt;enabled = <span class="hljs-literal">true</span>;<br>    mr-&gt;terminates = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 非实体 MemoryRegion，搜索时会继续前往其 subregions</span><br>    mr-&gt;ram = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 根级 MemoryRegion 不分配内存</span><br>    mr-&gt;readable = <span class="hljs-literal">true</span>;<br>    mr-&gt;readonly = <span class="hljs-literal">false</span>;<br>    mr-&gt;rom_device = <span class="hljs-literal">false</span>;<br>    mr-&gt;destructor = memory_region_destructor_none;<br>    mr-&gt;priority = <span class="hljs-number">0</span>;<br>    mr-&gt;may_overlap = <span class="hljs-literal">false</span>;<br>    mr-&gt;alias = <span class="hljs-literal">NULL</span>;<br>    QTAILQ_INIT(&amp;mr-&gt;subregions);<br>    <span class="hljs-built_in">memset</span>(&amp;mr-&gt;subregions_link, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> mr-&gt;subregions_link);<br>    QTAILQ_INIT(&amp;mr-&gt;coalesced);<br>    mr-&gt;name = g_strdup(name);<br>    mr-&gt;dirty_log_mask = <span class="hljs-number">0</span>;<br>    mr-&gt;ioeventfd_nb = <span class="hljs-number">0</span>;<br>    mr-&gt;ioeventfds = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到 mr-&gt;addr 被设置为 0，而 mr-&gt;ram_addr 则并没有初始化。</p>
<ul>
<li>实体 <code>MemoryRegion</code>：通过<code>memory_region_init_ram()</code>初始化，有自己的内存（从 QEMU 进程地址空间中分配），大小为<code>size</code>，例如<code>ram_memory</code>、 <code>pci_memory</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram, *option_rom_mr;<br>    <span class="hljs-comment">/* ...*/</span><br><br>    <span class="hljs-comment">/* Allocate RAM.  We allocate it as a single memory region and use</span><br><span class="hljs-comment">     * aliases to address portions of it, mostly for backwards compatibility</span><br><span class="hljs-comment">     * with older qemus that used qemu_ram_alloc().</span><br><span class="hljs-comment">     */</span><br>    ram = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram));<br>    <span class="hljs-comment">// 调用 memory_region_init_ram 对 ram_memory 进行初始化</span><br>    memory_region_init_ram(ram, <span class="hljs-string">&quot;pc.ram&quot;</span>, below_4g_mem_size + above_4g_mem_size);<br>    vmstate_register_ram_global(ram);<br>    *ram_memory = ram;<br><br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size);<br>    mr-&gt;ram = <span class="hljs-literal">true</span>;<br>    mr-&gt;terminates = <span class="hljs-literal">true</span>;<br>    mr-&gt;destructor = memory_region_destructor_ram;<br>    mr-&gt;ram_addr = qemu_ram_alloc(size, mr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里是先调用了<code>memory_region_init()</code>，之后设置 <code>RAM</code> 属性，并继续调用<code>qemu_ram_alloc()</code>分配内存。</p>
<ul>
<li>别名 <code>MemoryRegion</code>：通过<code>memory_region_init_alias()</code> 初始化，没有自己的内存，表示实体 <code>MemoryRegion</code> 的一部分。通过 <code>alias</code> 成员指向实体 <code>MemoryRegion</code>，<code>alias_offset</code>为在实体 <code>MemoryRegion</code> 中的偏移量，例如<code>ram_below_4g</code>、<code>ram_above_4g</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram_below_4g, *ram_above_4g;<br>    <span class="hljs-comment">/* ... */</span><br>    ram_below_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_below_4g));<br>    <span class="hljs-comment">// 调用 memory_region_init_alias 对 ram_below_4g 进行初始化</span><br>    memory_region_init_alias(ram_below_4g, <span class="hljs-string">&quot;ram-below-4g&quot;</span>, ram, <span class="hljs-number">0</span>, below_4g_mem_size);<br>    <span class="hljs-comment">/* ..</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_alias</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                              MemoryRegion *orig,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">target_phys_addr_t</span> offset,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size);<br>    mr-&gt;alias = orig; <span class="hljs-comment">// 指向实体 MemoryRegion</span><br>    mr-&gt;alias_offset = offset; <span class="hljs-comment">//通过 offset 得到实体的某一个部分</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="RAMBlock"><a href="#RAMBlock" class="headerlink" title="RAMBlock"></a>RAMBlock</h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>MemoryRegion</code> 用来描述一段逻辑层面上的内存区域，而记录实际分配的内存地址信息的结构体则是 <code>RAMBlock</code>，在<code>ramblock.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RAMBlock</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> *<span class="hljs-title">mr</span>;</span><br>    <span class="hljs-keyword">uint8_t</span> *host;<br>    <span class="hljs-keyword">uint8_t</span> *colo_cache; <span class="hljs-comment">/* For colo, VM&#x27;s ram cache */</span><br>    <span class="hljs-keyword">ram_addr_t</span> offset;<br>    <span class="hljs-keyword">ram_addr_t</span> used_length;<br>    <span class="hljs-keyword">ram_addr_t</span> max_length;<br>    <span class="hljs-keyword">void</span> (*resized)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">uint64_t</span> length, <span class="hljs-keyword">void</span> *host);<br>    <span class="hljs-keyword">uint32_t</span> flags;<br>    <span class="hljs-comment">/* Protected by iothread lock.  */</span><br>    <span class="hljs-keyword">char</span> idstr[<span class="hljs-number">256</span>];<br>    <span class="hljs-comment">/* RCU-enabled, writes protected by the ramlist lock */</span><br>    QLIST_ENTRY(RAMBlock) next;<br>    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;<br>    <span class="hljs-keyword">int</span> fd;<br>    <span class="hljs-keyword">size_t</span> page_size;<br>    <span class="hljs-comment">/* dirty bitmap used during migration */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *bmap;<br>    <span class="hljs-comment">/* bitmap of already received pages in postcopy */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *receivedmap;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * bitmap to track already cleared dirty bitmap.  When the bit is</span><br><span class="hljs-comment">     * set, it means the corresponding memory chunk needs a log-clear.</span><br><span class="hljs-comment">     * Set this up to non-NULL to enable the capability to postpone</span><br><span class="hljs-comment">     * and split clearing of dirty bitmap on the remote node (e.g.,</span><br><span class="hljs-comment">     * KVM).  The bitmap will be set only when doing global sync.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> this bitmap is different comparing to the other bitmaps</span><br><span class="hljs-comment">     * in that one bit can represent multiple guest pages (which is</span><br><span class="hljs-comment">     * decided by the `clear_bmap_shift&#x27; variable below).  On</span><br><span class="hljs-comment">     * destination side, this should always be NULL, and the variable</span><br><span class="hljs-comment">     * `clear_bmap_shift&#x27; is meaningless.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *clear_bmap;<br>    <span class="hljs-keyword">uint8_t</span> clear_bmap_shift;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * RAM block length that corresponds to the used_length on the migration</span><br><span class="hljs-comment">     * source (after RAM block sizes were synchronized). Especially, after</span><br><span class="hljs-comment">     * starting to run the guest, used_length and postcopy_length can differ.</span><br><span class="hljs-comment">     * Used to register/unregister uffd handlers and as the size of the received</span><br><span class="hljs-comment">     * bitmap. Receiving any page beyond this length will bail out, as it</span><br><span class="hljs-comment">     * could not have been valid on the source.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">ram_addr_t</span> postcopy_length;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>可以看到在 <code>RAMBlock</code> 中 host 和 offset 域分别对应了 <code>HVA</code> 和<code>GPA</code>，因此也可以说 <code>RAMBlock</code> 中存储了<code>GPA-&gt;HVA</code>的映射关系，另外每一个 <code>RAMBlock</code> 都会指向其所属的 <code>MemoryRegion</code>。</p>
<h4 id="全局变量-ram-list"><a href="#全局变量-ram-list" class="headerlink" title="全局变量 ram_list"></a>全局变量 ram_list</h4><p>QEMU 在<code>ramlist.h</code>中定义了一个全局变量<code>ram_list</code>，以链表的形式维护了所有的 <code>RAMBlock</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RAMList</span> &#123;</span><br>    QemuMutex mutex;<br>    RAMBlock *mru_block;<br>    <span class="hljs-comment">/* RCU-enabled, writes protected by the ramlist lock. */</span><br>    QLIST_HEAD(, RAMBlock) blocks;<br>    DirtyMemoryBlocks *dirty_memory[DIRTY_MEMORY_NUM];<br>    <span class="hljs-keyword">uint32_t</span> version;<br>    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;<br>&#125; RAMList;<br><span class="hljs-keyword">extern</span> RAMList ram_list;<br></code></pre></td></tr></table></figure>

<p>每一个新分配的 <code>RAMBlock</code> 都会被插入到<code>ram_list</code>的头部。如需查找地址所对应的 <code>RAMBlock</code>，则需要遍历<code>ram_list</code>，当目标地址落在当前<code>RAMBlock</code>的地址区间时，该 <code>RAMBlock</code> 即为查找目标。</p>
<h4 id="AS、MR、RAMBlock-之间的关系"><a href="#AS、MR、RAMBlock-之间的关系" class="headerlink" title="AS、MR、RAMBlock 之间的关系"></a>AS、MR、RAMBlock 之间的关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225155936.png"></p>
<h3 id="FlatView"><a href="#FlatView" class="headerlink" title="FlatView"></a>FlatView</h3><p>AddressSpace 的 root 域及其子树共同构成了 Guest 的物理地址空间，但这些都是在 QEMU 侧定义的。要传入 KVM 进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其<strong>转换为一个“平坦”的地址模</strong>型，也就是一个从零开始、只包含地址信息的数据结构，这在 QEMU 中通过 <strong>FlatView</strong> 来表示。每个 AddressSpace 都有一个与之对应的 FlatView 指针 current_map，表示其对应的平面展开视图。</p>
<h4 id="结构体定义-3"><a href="#结构体定义-3" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>FlatView</code> 在<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* Flattened global view of current active memory hierarchy.  Kept in sorted</span><br><span class="hljs-comment"> * order.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatView</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-keyword">unsigned</span> ref;<br>    FlatRange *ranges;      <span class="hljs-comment">// 对应的 FlatRange 数组</span><br>    <span class="hljs-keyword">unsigned</span> nr;            <span class="hljs-comment">// FlatRange 的数目</span><br>    <span class="hljs-keyword">unsigned</span> nr_allocated;  <span class="hljs-comment">// 当前数组的项数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSpaceDispatch</span> *<span class="hljs-title">dispatch</span>;</span><br>    MemoryRegion *root;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其中，<code>ranges</code>是一个数组，记录了 <code>FlatView</code> 下所有的 <code>FlatRange</code>。</p>
<h4 id="FlatRange"><a href="#FlatRange" class="headerlink" title="FlatRange"></a>FlatRange</h4><p>在 <code>FlatView</code> 中，<code>FlatRange</code> 表示在 <code>FlatView</code> 中的一段内存范围，同样在<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Range of memory in the global map.  Addresses are absolute. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatRange</span> &#123;</span><br>    MemoryRegion *mr;           <span class="hljs-comment">// 指向所属的 MemoryRegion</span><br>    hwaddr offset_in_region;    <span class="hljs-comment">// 在全局 MemoryRegion 中的 offset，对应 GPA</span><br>    AddrRange addr;             <span class="hljs-comment">// 代表的地址区间，对应 HVA</span><br>    <span class="hljs-keyword">uint8_t</span> dirty_log_mask;<br>    <span class="hljs-keyword">bool</span> romd_mode;<br>    <span class="hljs-keyword">bool</span> readonly;<br>    <span class="hljs-keyword">bool</span> nonvolatile;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每个 <code>FlatRange</code> 对应一段虚拟机物理地址区间，各个 <code>FlatRange</code> 不会重叠，<strong>按照地址的顺序保存在数组中</strong>，具体的地址范围由一个 <code>AddrRange</code> 结构来描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * AddrRange 用于表示 FlatRange 的起始地址及大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddrRange</span> &#123;</span><br>    Int128 start;<br>    Int128 size;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="MemoryRegionSection"><a href="#MemoryRegionSection" class="headerlink" title="MemoryRegionSection"></a>MemoryRegionSection</h3><h4 id="结构体定义-4"><a href="#结构体定义-4" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>在 <code>QEMU</code> 中，还有几个起到中介作用的结构体，<code>MemoryRegionSection</code> 就是其中之一。</p>
<p>之前介绍的 <code>FlatRange</code> 代表一个物理地址空间的片段，偏向于描述在 <code>Host</code> 侧即 <strong>AddressSpace 中的分布【Guest 的物理空间】</strong>，而 <code>MemoryRegionSection</code> 则代表在 <code>Guest</code> 侧即 <strong>MemoryRegion 中的片段</strong>。<code>MemoryRegionSection</code> 在<code>memory.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MemoryRegionSection: describes a fragment of a #MemoryRegion</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @mr: the region, or %NULL if empty</span><br><span class="hljs-comment"> * @address_space: the address space the region is mapped in</span><br><span class="hljs-comment"> * @offset_within_region: the beginning of the section, relative to @mr&#x27;s start</span><br><span class="hljs-comment"> * @size: the size of the section; will not exceed @mr&#x27;s boundaries</span><br><span class="hljs-comment"> * @offset_within_address_space: the address of the first byte of the section</span><br><span class="hljs-comment"> *     relative to the region&#x27;s address space</span><br><span class="hljs-comment"> * @readonly: writes to this section are ignored</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//只是起到描述的作用，描述了是哪个 AddressSpace 的 MemoryRegion，</span><br> <span class="hljs-comment">//并且在 MemoryRegion 中的 offset，和在 AddressSpace 展开为平坦内存的 offset</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionSection</span> &#123;</span>  <br>    MemoryRegion *mr;                               <span class="hljs-comment">// 所属的 MemoryRegion</span><br>    MemoryRegion *address_space;                    <span class="hljs-comment">// 关联的 AddressSpace</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> offset_within_region;        <span class="hljs-comment">// 在 MemoryRegion 内部的 offset</span><br>    <span class="hljs-keyword">uint64_t</span> size;                                  <span class="hljs-comment">// Section 的大小</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> offset_within_address_space; <span class="hljs-comment">// 在 AddressSpace 内部的 offset</span><br>    <span class="hljs-keyword">bool</span> readonly;                                  <span class="hljs-comment">// 是否为只读</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>offset_within_region</code>：在所属 <code>MemoryRegion</code> 中的<code>offset</code>。一个<code>AddressSpace</code> 可能由多个 <code>MemoryRegion</code> 组成，因此该 <code>offset</code> 是局部的</li>
<li><code>offset_within_address_space</code>：在所属 <code>AddressSpace</code> 中的 <code>offset</code>，它是全局的</li>
</ul>
<h4 id="和其他数据结构之间的关系"><a href="#和其他数据结构之间的关系" class="headerlink" title="和其他数据结构之间的关系"></a>和其他数据结构之间的关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125110422.png"></p>
<ul>
<li><code>AddressSpace</code> 的<code>root</code>指向对应的根级<code>MemoryRegion</code>，<code>current_map</code>指向<code>AddressSpace</code> 的<code>root</code>通过<code>generate_memory_topology()</code>生成的 <code>FlatView</code></li>
<li><code>FlatView</code> 中的<code>ranges</code>数组表示该<code>MemoryRegion</code> 所表示的<code>Guest</code>地址区间【GPA 的整个平坦物理空间】，并按照地址的顺序进行排列</li>
<li><code>MemoryRegionSection</code> 由<code>ranges</code>数组中的 <code>FlatRange</code> 对应生成，作为注册到 <code>KVM</code>中的基本单位</li>
</ul>
<hr>
<p><code>QEMU</code> 在用户空间申请内存后，需要将内存信息通过一系列系统调用传入内核空间的 <code>KVM</code>，由 <code>KVM</code> 侧进行管理，因此 <code>QEMU</code> 侧也定义了一些用于向 <code>KVM</code> 传递参数的结构体。</p>
<p>以下为<code>KVM</code>相关的数据结构。</p>
<h3 id="KVMSlot"><a href="#KVMSlot" class="headerlink" title="KVMSlot"></a>KVMSlot</h3><p><code>在 kvm_init.h</code>中定义，是 <code>KVM</code> 中内存管理的基本单位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KVMSlot</span></span><br><span class="hljs-class">&#123;</span><br>    hwaddr start_addr; <span class="hljs-comment">// Guest 物理地址，GPA</span><br>    <span class="hljs-keyword">ram_addr_t</span> memory_size;        <span class="hljs-comment">// 内存大小</span><br>    <span class="hljs-keyword">void</span> *ram; <span class="hljs-comment">// QEMU 用户空间地址，HVA</span><br>    <span class="hljs-keyword">int</span> slot;  <span class="hljs-comment">// Slot 编号</span><br>    <span class="hljs-keyword">int</span> flags; <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    <span class="hljs-comment">/* Dirty bitmap cache for the slot */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *dirty_bmap;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> dirty_bmap_size;<br>    <span class="hljs-comment">/* Cache of the address space ID */</span><br>    <span class="hljs-keyword">int</span> as_id;<br>    <span class="hljs-comment">/* Cache of the offset in ram address space */</span><br>    <span class="hljs-keyword">ram_addr_t</span> ram_start_offset;<br>&#125; KVMSlot;<br></code></pre></td></tr></table></figure>

<p><code>KVMSlot</code> 类似于内存插槽的概念。</p>
<h3 id="kvm-userspace-memory-region"><a href="#kvm-userspace-memory-region" class="headerlink" title="kvm_userspace_memory_region"></a>kvm_userspace_memory_region</h3><p>调用<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>时需要向 <code>KVM</code> 传递的参数，在<code>kvm.h</code>中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* for KVM_SET_USER_MEMORY_REGION */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;            <span class="hljs-comment">// slot 编号</span><br>    __u32 flags;           <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    __u64 guest_phys_addr; <span class="hljs-comment">// Guest 物理地址，GPA</span><br>    __u64 memory_size;     <span class="hljs-comment">// 内存大小，bytes</span><br>    __u64 userspace_addr;  <span class="hljs-comment">// 从 QEMU 进程空间分配的起始地址，HVA</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="MemoryListener"><a href="#MemoryListener" class="headerlink" title="MemoryListener"></a>MemoryListener</h3><h4 id="结构体定义-5"><a href="#结构体定义-5" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>为了监控虚拟机的物理地址访问，对于每一个 <code>AddressSpace</code>，都会有一个 <code>MemoryListener</code> 与之对应。每当物理映射<code>GPA-&gt;HVA</code>发生改变时，就会回调这些函数。<strong>MemoryListener</strong> 是对一些事件的<strong>回调函数合集</strong>，在<code>memory.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MemoryListener: callbacks structure for updates to the physical memory map</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Allows a component to adjust to changes in the guest-visible memory map.</span><br><span class="hljs-comment"> * Use with memory_listener_register() and memory_listener_unregister().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryListener</span> &#123;</span><br>    <span class="hljs-keyword">void</span> (*begin)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*commit)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*region_add)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*region_del)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*region_nop)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_start)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_stop)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_sync)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_global_start)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*log_global_stop)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*eventfd_add)(MemoryListener *listener, MemoryRegionSection *section,<br>                        <span class="hljs-keyword">bool</span> match_data, <span class="hljs-keyword">uint64_t</span> data, EventNotifier *e);<br>    <span class="hljs-keyword">void</span> (*eventfd_del)(MemoryListener *listener, MemoryRegionSection *section,<br>                        <span class="hljs-keyword">bool</span> match_data, <span class="hljs-keyword">uint64_t</span> data, EventNotifier *e);<br>    <span class="hljs-comment">/* Lower = earlier (during add), later (during del) */</span><br>    <span class="hljs-keyword">unsigned</span> priority;<br>    MemoryRegion *address_space_filter;<br>    QTAILQ_ENTRY(MemoryListener) link;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="全局变量-memory-listeners"><a href="#全局变量-memory-listeners" class="headerlink" title="全局变量 memory_listeners"></a>全局变量 memory_listeners</h4><p>所有的 <code>MemoryListener</code> 都会挂在全局变量<code>memory_listeners</code>链表上，在<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">QTAILQ_HEAD</span><span class="hljs-params">(, MemoryListener)</span> memory_listeners</span><br><span class="hljs-function">    </span>= QTAILQ_HEAD_INITIALIZER(memory_listeners);<br></code></pre></td></tr></table></figure>

<p>在<code>memory.c</code>中枚举了<code>ListenerDirection</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ListenerDirection</span> &#123;</span> Forward, Reverse &#125;;<br></code></pre></td></tr></table></figure>

<h3 id="重要数据结构总览"><a href="#重要数据结构总览" class="headerlink" title="重要数据结构总览"></a>重要数据结构总览</h3><table>
<thead>
<tr>
<th align="center">结构体名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AddressSpace</td>
<td align="left">VM 能看到的一段地址空间，偏向 Host 侧【注意指的是偏向】</td>
</tr>
<tr>
<td align="center">MemoryRegion</td>
<td align="left">地址空间中一段逻辑层面的内存区域，偏向 Guest 侧</td>
</tr>
<tr>
<td align="center">RAMBlock</td>
<td align="left">记录实际分配的内存地址信息，存储了 GPA-&gt;HVA 的映射关系</td>
</tr>
<tr>
<td align="center">FlatView</td>
<td align="left">MemoryRegion 对应的平面展开视图，包含一个 FlatRange 类型的 ranges 数组</td>
</tr>
<tr>
<td align="center">FlatRange</td>
<td align="left">对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中</td>
</tr>
<tr>
<td align="center">MemoryRegionSection</td>
<td align="left">表示 MemoryRegion 中的片段</td>
</tr>
<tr>
<td align="center">MemoryListener</td>
<td align="left">回调函数集合</td>
</tr>
<tr>
<td align="center">KVMSlot</td>
<td align="left">KVM 中内存管理的基本单位，表示一个内存插槽</td>
</tr>
<tr>
<td align="center">kvm_userspace_memory_region</td>
<td align="left">调用 ioctl(KVM_SET_USER_MEMORY_REGION) 时需要向 KVM 传递的参数</td>
</tr>
</tbody></table>
<h2 id="具体实现机制"><a href="#具体实现机制" class="headerlink" title="具体实现机制"></a>具体实现机制</h2><p>QEMU 的内存申请流程大致可分为三个部分：回调函数的注册、AddressSpace 的初始化、实际内存的分配。下面将根据在 vl.c 的 main() 函数中的调用顺序分别介绍。</p>
<h3 id="回调函数的注册"><a href="#回调函数的注册" class="headerlink" title="回调函数的注册"></a>回调函数的注册</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125133808.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">configure_accelerator</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       └─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">()</span>                                     <span class="hljs-comment">// 初始化 KVM</span></span><br><span class="hljs-function">            ├─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_ioctl</span><span class="hljs-params">(KVM_CREATE_VM)</span>                  <span class="hljs-comment">// 创建 VM</span></span><br><span class="hljs-function">            ├─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_arch_init</span><span class="hljs-params">()</span>                           <span class="hljs-comment">// 针对不同的架构进行初始化</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">()</span>               <span class="hljs-comment">// 注册 kvm_memory_listener</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">()</span> <span class="hljs-comment">// 调用 region_add 回调</span></span><br><span class="hljs-function">                      └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span>        <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">                           └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">                                └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                     └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br></code></pre></td></tr></table></figure>

<p>进入<code>configure_accelerator()</code>后，<code>QEMU</code>会先调用<code>configure_accelerator()</code>设置 <code>KVM</code> 的加速支持，之后进入<code>kvm_init()</code>。该函数主要完成对 KVM 的初始化，包括一些常规检查如 <code>CPU</code> 个数、<code>KVM</code> 版本等，之后通过<code>kvm_ioctl(KVM_CREATE_VM)</code>与内核交互，创建 <code>KVM</code> 虚拟机。在<code>kvm_init()</code>的最后，会调用<code>memory_listener_register()</code>注册<code>kvm_memory_listener</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">(MachineState *ms)</span></span><br><span class="hljs-function"></span>&#123;<br>    MachineClass *mc = MACHINE_GET_CLASS(ms);<br>    <span class="hljs-comment">// 打开/dev/kvm</span><br>    s-&gt;fd = qemu_open_old(<span class="hljs-string">&quot;/dev/kvm&quot;</span>, O_RDWR);<br>    <span class="hljs-comment">// 创建 VM</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        ret = kvm_ioctl(s, KVM_CREATE_VM, type);<br>    &#125; <span class="hljs-keyword">while</span> (ret == -EINTR);<br><span class="hljs-comment">/* ... */</span><br>    ret = kvm_arch_init(s); <span class="hljs-comment">// 针对不同的架构进行初始化</span><br><br>    <span class="hljs-comment">// 对于以下 AddressSpace，设置其对应的 listener</span><br>    kvm_memory_listener_register(s, &amp;s-&gt;memory_listener,<br>                                 &amp;address_space_memory, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;kvm-memory&quot;</span>);<br>    memory_listener_register(&amp;kvm_coalesced_pio_listener,<br>                             &amp;address_space_io);<br><span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">(MemoryListener *listener, AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryListener *other = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* Only one of them can be defined for a listener */</span><br>    assert(!(listener-&gt;log_sync &amp;&amp; listener-&gt;log_sync_global));<br><br>    listener-&gt;address_space = as;<br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;memory_listeners)<br>        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;memory_listeners)-&gt;priority) &#123;<br>        QTAILQ_INSERT_TAIL(&amp;memory_listeners, listener, link);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        QTAILQ_FOREACH(other, &amp;memory_listeners, link) &#123;<br>            <span class="hljs-keyword">if</span> (listener-&gt;priority &lt; other-&gt;priority) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        QTAILQ_INSERT_BEFORE(other, listener, link);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;as-&gt;listeners)<br>        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;as-&gt;listeners)-&gt;priority) &#123;<br>        QTAILQ_INSERT_TAIL(&amp;as-&gt;listeners, listener, link_as);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        QTAILQ_FOREACH(other, &amp;as-&gt;listeners, link_as) &#123;<br>            <span class="hljs-keyword">if</span> (listener-&gt;priority &lt; other-&gt;priority) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        QTAILQ_INSERT_BEFORE(other, listener, link_as);<br>    &#125;<br><br>    listener_add_address_space(listener, as);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后的<code>listener_add_address_space()</code>主要是将 listener 注册到其对应的 <code>AddressSpace</code> 上，并根据 <code>AddressSpace</code> 对应的 <code>FlatRange</code> 数组，生成 <code>MemoryRegionSection</code>【<code>MemoryRegionSection</code>就像是为<code>FlatRange</code>数组设置的一种中介表示，便于传入<code>KVM</code>，因为传入<code>KVM</code>应该是对平坦内存的一种表示】，并注册到 <code>KVM</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">(MemoryListener *listener,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    FlatView *view;<br>    FlatRange *fr;<br><br>    <span class="hljs-keyword">if</span> (listener-&gt;begin) &#123;<br>        listener-&gt;begin(listener);<br>    &#125;<br>    <span class="hljs-comment">/* 开启内存脏页记录 */</span><br>    <span class="hljs-keyword">if</span> (global_dirty_tracking) &#123;<br>        <span class="hljs-keyword">if</span> (listener-&gt;log_global_start) &#123;<br>            listener-&gt;log_global_start(listener);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 遍历 AddressSpace 对应的 FlatRange 数组，并将其转换成 MemoryRegionSection */</span><br>    view = address_space_get_flatview(as);<br>    FOR_EACH_FLAT_RANGE(fr, view) &#123;<br>        MemoryRegionSection section = section_from_flat_range(fr, view);<br>        <span class="hljs-comment">/* 将 section 所代表的内存区域注册到 KVM 中 */</span><br>        <span class="hljs-keyword">if</span> (listener-&gt;region_add) &#123;<br>            listener-&gt;region_add(listener, &amp;section);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fr-&gt;dirty_log_mask &amp;&amp; listener-&gt;log_start) &#123;<br>            listener-&gt;log_start(listener, &amp;section, <span class="hljs-number">0</span>, fr-&gt;dirty_log_mask);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (listener-&gt;commit) &#123;<br>        listener-&gt;commit(listener);<br>    &#125;<br>    flatview_unref(view);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于此时 <code>AddressSapce</code> 尚未初始化，所以此处的循环为空，仅是在全局注册了<code>kvm_memory_listener</code>。最后调用了<code>kvm_memory_listener-&gt;region_add()</code>，对应的实现是<code>kvm_region_add()</code>，该函数最终会通过<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>，将 <code>QEMU</code> 侧申请的内存信息传入 <code>KVM</code> 进行注册，这里的流程会在下一部分进行分析。</p>
<h3 id="AddressSpace-的初始化"><a href="#AddressSpace-的初始化" class="headerlink" title="AddressSpace 的初始化"></a>AddressSpace 的初始化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125154841.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">void</span> <span class="hljs-title">cpu_exec_init_all</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       ├─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_map_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 初始化 system_memory/io 这两个全局 MemoryRegion</span></span><br><span class="hljs-function">       |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">set_system_memory_map</span><span class="hljs-params">()</span> <span class="hljs-comment">// address_space_memory-&gt;root = system_memory</span></span><br><span class="hljs-function">       |    |    └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_update_topology</span><span class="hljs-params">()</span>        <span class="hljs-comment">// 为 MemoryRegion 生成 FlatView</span></span><br><span class="hljs-function">       |    |         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">()</span>   <span class="hljs-comment">// as-&gt;current_map = new_view</span></span><br><span class="hljs-function">       |    |              └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    |                   └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span>        <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">       |    |                        └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">       |    |                             └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    |                                  └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br><span class="hljs-function">       |    |</span><br><span class="hljs-function">       |    └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">()</span> <span class="hljs-comment">// 注册对应的 MemoryListener</span></span><br><span class="hljs-function">       |         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |</span><br><span class="hljs-function">       └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io_mem_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_io</span><span class="hljs-params">()</span> <span class="hljs-comment">// ram/rom/unassigned/notdirty/subpage-ram/watch</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>第一部分在全局注册了<code>kvm_memory_listener</code>，但由于<code>AddressSpace</code> 尚未初始化，实际上并未向 <code>KVM</code> 中注册任何实际的内存信息。<code>QEMU</code> 在<code>main()</code>函数中会继续调用<code>cpu_exec_init_all()</code>对<code>AddressSpace</code>进行初始化，该函数实际上是对两个 <code>init</code> 函数的封装调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cpu_exec_init_all</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    qemu_mutex_init(&amp;ram_list.mutex);<br>    <span class="hljs-comment">/* The data structures we set up here depend on knowing the page size,</span><br><span class="hljs-comment">     * so no more changes can be made after this point.</span><br><span class="hljs-comment">     * In an ideal world, nothing we did before we had finished the</span><br><span class="hljs-comment">     * machine setup would care about the target page size, and we could</span><br><span class="hljs-comment">     * do this much later, rather than requiring board models to state</span><br><span class="hljs-comment">     * up front what their requirements are.</span><br><span class="hljs-comment">     */</span><br>    finalize_target_page_bits();<br>    io_mem_init();      <span class="hljs-comment">// 初始化六个I/O MemoryRegion</span><br>    memory_map_init(); <span class="hljs-comment">// 初始化两个全局 AddressSpace，以及对应的 MemoryRegion、FlatView</span><br>    qemu_mutex_init(&amp;map_client_list_lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先来看<code>memory_map_init()</code>，主要用来初始化两个全局的系统地址空间<code>system_memory</code>、<code>system_io</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_map_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    system_memory = g_malloc(<span class="hljs-keyword">sizeof</span>(*system_memory));<br>    <span class="hljs-comment">// 1. 初始化 system_memory</span><br>    memory_region_init(system_memory, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;system&quot;</span>, UINT64_MAX);<br>    <span class="hljs-comment">// 2. 设置 address_space_memory 关联 system_memory</span><br>    <span class="hljs-comment">// 这两个都是全局变量，也就是把内存地址空间和 IO 地址空间于对应的 MemoryRegion 联系起来 </span><br>    <span class="hljs-comment">//及其对应的 FlatView</span><br>    address_space_init(&amp;address_space_memory, system_memory, <span class="hljs-string">&quot;memory&quot;</span>);<br><br>    system_io = g_malloc(<span class="hljs-keyword">sizeof</span>(*system_io));<br>    <span class="hljs-comment">// 1. 初始化 system_io  </span><br>    memory_region_init_io(system_io, <span class="hljs-literal">NULL</span>, &amp;unassigned_io_ops, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;io&quot;</span>,<br>                          <span class="hljs-number">65536</span>);<br>    <span class="hljs-comment">// 2. 设置 address_space_io 关联 system_io </span><br>    <span class="hljs-comment">// 及其对应的 FlatView</span><br>    address_space_init(&amp;address_space_io, system_io, <span class="hljs-string">&quot;I/O&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里比较重要的是<code>address_space_init()</code>，先设置 <code>AddressSpace</code> 对应的 <code>MemoryRegion</code>，之后根据<code>system_memory</code>更新<code>address_space_memory</code>对应的 <code>FlatView</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">address_space_init</span><span class="hljs-params">(AddressSpace *as, MemoryRegion *root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_ref(root);<br>    <span class="hljs-comment">// 将 address_space_memory 的 root 域指向 system_memory</span><br>    as-&gt;root = root;        <br>    as-&gt;current_map = <span class="hljs-literal">NULL</span>;<br>    as-&gt;ioeventfd_nb = <span class="hljs-number">0</span>;<br>    as-&gt;ioeventfds = <span class="hljs-literal">NULL</span>;<br>    QTAILQ_INIT(&amp;as-&gt;listeners);<br>    QTAILQ_INSERT_TAIL(&amp;address_spaces, as, address_spaces_link);<br>    as-&gt;name = g_strdup(name ? name : <span class="hljs-string">&quot;anonymous&quot;</span>);<br>    <span class="hljs-comment">// 根据 system_memory 更新 address_space_memory 对应的 FlatView</span><br>    address_space_update_topology(as);  <br>    address_space_update_ioeventfds(as);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>address_space_update_topology()</code>会继续调用<code>generate_memory_topology()</code>生成 <code>AddressSpace</code> 对应的 <code>FlatView</code>视图：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">(AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);<br><br>    flatviews_init();<br>    <span class="hljs-keyword">if</span> (!g_hash_table_lookup(flat_views, physmr)) &#123;<br>        generate_memory_topology(physmr);<br>    &#125;<br>    address_space_set_flatview(as);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>address_space_update_topology()</code>会先调用<code>generate_memory_topology()</code>生成<code>system_memory</code>更新后的视图<code>new_view</code>，再将<code>address_space_memory</code>的<code>current_map</code>指向这个<code>new_view</code>，最后销毁<code>old_view</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_set_flatview</span><span class="hljs-params">(AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    FlatView *old_view = address_space_to_flatview(as);<br>    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);<br>    FlatView *new_view = g_hash_table_lookup(flat_views, physmr);<br><br>    assert(new_view);<br><br>    <span class="hljs-keyword">if</span> (old_view == new_view) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_ref(old_view);<br>    &#125;<br><br>    flatview_ref(new_view);<br><br>    <span class="hljs-keyword">if</span> (!QTAILQ_EMPTY(&amp;as-&gt;listeners)) &#123;<br>        FlatView tmpview = &#123; .nr = <span class="hljs-number">0</span> &#125;, *old_view2 = old_view;<br><br>        <span class="hljs-keyword">if</span> (!old_view2) &#123;<br>            old_view2 = &amp;tmpview;<br>        &#125;<br>        address_space_update_topology_pass(as, old_view2, new_view, <span class="hljs-literal">false</span>);<br>        address_space_update_topology_pass(as, old_view2, new_view, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Writes are protected by the BQL.  */</span><br>    qatomic_rcu_set(&amp;as-&gt;current_map, new_view);<br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_unref(old_view);<br>    &#125;<br><br>    <span class="hljs-comment">/* Note that all the old MemoryRegions are still alive up to this</span><br><span class="hljs-comment">     * point.  This relieves most MemoryListeners from the need to</span><br><span class="hljs-comment">     * ref/unref the MemoryRegions they get---unless they use them</span><br><span class="hljs-comment">     * outside the iothread mutex, in which case precise reference</span><br><span class="hljs-comment">     * counting is necessary.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_unref(old_view);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>address_space_update_topology_pass()</code>的最后，会调用<code>MEMORY_LISTENER_UPDATE_REGION</code>这个宏，触发<code>region_add</code>对应的回调函数<code>kvm_region_add()</code>。</p>
<p>这个宏在<code>memory.c</code>中定义，会将 <code>FlatView</code> 中的 <code>FlatRange</code> 转换为 <code>MemoryRegionSection</code>，作为入参传递给<code>kvm_region_add()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* No need to ref/unref .mr, the FlatRange keeps it alive.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...)  \</span><br><span class="hljs-meta">    do &#123;                                                                \</span><br><span class="hljs-meta">        MemoryRegionSection mrs = section_from_flat_range(fr,           \</span><br><span class="hljs-meta">                address_space_to_flatview(as));                         \</span><br><span class="hljs-meta">        MEMORY_LISTENER_CALL(as, callback, dir, &amp;mrs, ##_args);         \</span><br><span class="hljs-meta">    &#125; while(0)</span><br></code></pre></td></tr></table></figure>

<p>而<code>kvm_region_add()</code>实际上是对<code>kvm_set_phys_mem()</code>的封装调用。该函数比较复杂，会根据传入的<code>section</code>填充 KVMSlot，再传递给<code>kvm_set_user_memory_region()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">(KVMMemoryListener *kml, KVMSlot *slot, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">new</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    KVMState *s = kvm_state;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">mem</span>;</span><br>    <span class="hljs-keyword">int</span> ret;<br><br>    <span class="hljs-comment">// 根据 KVMSlot 填充 kvm_userspace_memory_region</span><br>    mem.slot = slot-&gt;slot | (kml-&gt;as_id &lt;&lt; <span class="hljs-number">16</span>);<br>    mem.guest_phys_addr = slot-&gt;start_addr;<br>    mem.userspace_addr = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)slot-&gt;ram;<br>    mem.flags = slot-&gt;flags;<br><br>    <span class="hljs-keyword">if</span> (slot-&gt;memory_size &amp;&amp; !<span class="hljs-keyword">new</span> &amp;&amp; (mem.flags ^ slot-&gt;old_flags) &amp; KVM_MEM_READONLY) &#123;<br>        <span class="hljs-comment">/* Set the slot size to 0 before setting the slot to the desired</span><br><span class="hljs-comment">         * value. This is needed based on KVM commit 75d61fbc. */</span><br>        mem.memory_size = <span class="hljs-number">0</span>;<br>        ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> err;<br>        &#125;<br>    &#125;<br>    mem.memory_size = slot-&gt;memory_size;<br>    ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>    slot-&gt;old_flags = mem.flags;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里又将 <code>KVMSlot</code> 转换为 <code>kvm_userspace_memory_region</code>，作为<code>ioctl()</code>的参数，交给内核中的 <code>KVM</code> 进行内存的注册【设置<code>GPA-&gt;HVA</code>的映射关系，在内核空间维护并管理 Guest 的内存】。</p>
<p>至此 QEMU 侧负责管理内存的数据结构均已完成初始化，<strong>可以参考下面的图片了解各数据结构之间的对应关系</strong></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127155506.png"></p>
<h3 id="实际内存的分配"><a href="#实际内存的分配" class="headerlink" title="实际内存的分配"></a>实际内存的分配</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127160121.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">void</span> machine-&gt;<span class="hljs-title">init</span><span class="hljs-params">(ram_size, ...)</span></span><br><span class="hljs-function">       └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc_init_pci</span><span class="hljs-params">(ram_size, ...)</span> <span class="hljs-comment">// 初始化虚拟机</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc_init1</span><span class="hljs-params">(system_memory, system_io, ram_size, ...)</span></span><br><span class="hljs-function">                 ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">(pci_memory, <span class="hljs-string">&quot;pci&quot;</span>, ...)</span> <span class="hljs-comment">// pci_memory, rom_memory</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">void</span> <span class="hljs-title">pc_memory_init</span><span class="hljs-params">()</span> <span class="hljs-comment">// 初始化内存，分配实际的物理内存地址</span></span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">()</span> <span class="hljs-comment">// 创建 pc.ram, pc.rom 并分配内存</span></span><br><span class="hljs-function">                      |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |    └─ <span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |         └─ <span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc_from_ptr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |</span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">vmstate_register_ram_global</span><span class="hljs-params">()</span> <span class="hljs-comment">// 将 MR 的 name 写入 RAMBlock 的 idstr</span></span><br><span class="hljs-function">                      |    └─ <span class="hljs-keyword">void</span> <span class="hljs-title">vmstate_register_ram</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |         └─ <span class="hljs-keyword">void</span> <span class="hljs-title">qemu_ram_set_idstr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |</span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_alias</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 初始化 ram_below_4g, ram_above_4g</span></span><br><span class="hljs-function">                      └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_add_subregion</span><span class="hljs-params">()</span> <span class="hljs-comment">// 在 system_memory 中添加 subregions</span></span><br><span class="hljs-function">                           └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_add_subregion_common</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_update_topology</span><span class="hljs-params">()</span> <span class="hljs-comment">// 为 MemoryRegion 生成 FlatView</span></span><br><span class="hljs-function">                                     └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">()</span> <span class="hljs-comment">// as-&gt;current_map = new_view</span></span><br><span class="hljs-function">                                          └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                               └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span> <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">                                                    └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">                                                         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                                              └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br></code></pre></td></tr></table></figure>

<p>之前的回调函数注册、AddressSpace 的初始化，实际上均没有对应的物理内存。【实际的内存是在 RAMBlock 中】</p>
<p>我们再回到 <code>qemu</code> 启动的 <code>main</code> 函数中。接下来的初始化过程会调用 <code>pc_init1</code>。在这里面，对于 <code>CPU</code> 虚拟化，我们会调用 <code>pc_cpus_init</code>。另外，<code>pc_init1</code> 还会调用<code>pc_memory_init</code>，进行内存的虚拟化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram, *option_rom_mr;         <span class="hljs-comment">// 两个实体 MR: pc.ram, pc.rom</span><br>    MemoryRegion *ram_below_4g, *ram_above_4g; <span class="hljs-comment">// 两个别名 MR: ram_below_4g, ram_above_4g</span><br><br>    <span class="hljs-comment">/* Allocate RAM.  We allocate it as a single memory region and use</span><br><span class="hljs-comment">     * aliases to address portions of it, mostly for backwards compatibility</span><br><span class="hljs-comment">     * with older qemus that used qemu_ram_alloc().</span><br><span class="hljs-comment">     */</span><br>    ram = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram)); <span class="hljs-comment">// 创建 ram</span><br>    <span class="hljs-comment">// 分配具体的内存（实际上会创建一个 RAMBlock 并将其 offset 值写入 ram.ram_addr，对应 GPA）</span><br>    memory_region_init_ram(ram, <span class="hljs-string">&quot;pc.ram&quot;</span>, below_4g_mem_size + above_4g_mem_size);<br>    <span class="hljs-comment">// 将 MR 的 name 写入 RAMBlock 的 idstr</span><br>    vmstate_register_ram_global(ram);<br>    *ram_memory = ram;<br><br>    <span class="hljs-comment">// 创建 ram_below_4g 表示 4G 以下的内存</span><br>    ram_below_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_below_4g));<br>    memory_region_init_alias(ram_below_4g, <span class="hljs-string">&quot;ram-below-4g&quot;</span>, ram, <span class="hljs-number">0</span>, below_4g_mem_size);<br>    <span class="hljs-comment">// 将 ram_below_4g 挂在 system_memory 下</span><br>    memory_region_add_subregion(system_memory, <span class="hljs-number">0</span>, ram_below_4g);<br><br>    <span class="hljs-keyword">if</span> (above_4g_mem_size &gt; <span class="hljs-number">0</span>) &#123;<br>        ram_above_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_above_4g));<br>        memory_region_init_alias(ram_above_4g, <span class="hljs-string">&quot;ram-above-4g&quot;</span>, ram, below_4g_mem_size, above_4g_mem_size);<br>        memory_region_add_subregion(system_memory, <span class="hljs-number">0x100000000</span>ULL, ram_above_4g);<br>    &#125;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的重点在于<code>memory_region_init_ram()</code>，它通过<code>qemu_ram_alloc()</code>获取 ram 这个 <code>MemoryRegion</code> 对应的 <code>RAMBlock</code> 的<code>offset</code>，并存入<code>ram.ram_addr</code>，这样就可以在<code>ram_list</code>中根据该字段查找 <code>MR</code> 对应的 <code>RAMBlock</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">(MemoryRegion *mr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size); <span class="hljs-comment">// 填充字段，初始化默认值</span><br>    mr-&gt;ram = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示为 RAM</span><br>    mr-&gt;terminates = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示为实体 MemoryRegion</span><br>    mr-&gt;destructor = memory_region_destructor_ram;<br>    mr-&gt;ram_addr = qemu_ram_alloc(size, mr); <span class="hljs-comment">// 这里保存 RAMBlock 的 offset，即 GPA</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>而 qemu_ram_alloc() 最终会调用 qemu_ram_alloc_from_ptr()，创建一个对应大小 RAMBlock 并分配内存，返回对应的 GPA 地址存入 mr-&gt;ram_addr 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc_from_ptr</span><span class="hljs-params">(<span class="hljs-keyword">ram_addr_t</span> size, <span class="hljs-keyword">void</span> *host,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   MemoryRegion *mr)</span></span><br><span class="hljs-function"></span>&#123;<br>    RAMBlock *new_block; <span class="hljs-comment">// 创建一个 RAMBlock</span><br><br>    size = TARGET_PAGE_ALIGN(size); <span class="hljs-comment">// 页对齐</span><br>    new_block = g_malloc0(<span class="hljs-keyword">sizeof</span>(*new_block)); <span class="hljs-comment">// 初始化 new_block</span><br><br>    new_block-&gt;mr = mr; <span class="hljs-comment">// 将 new_block-&gt; 指向入参的 MemoryRegion</span><br>    new_block-&gt;offset = find_ram_offset(size); <span class="hljs-comment">// 从 ram_list 中的 RAMBlock 之间找到一段可以满足 size 需求的 gap，并返回起始地址的 offset，对应 GPA</span><br>    <span class="hljs-keyword">if</span> (host) &#123; <span class="hljs-comment">// 新建的 RAMBlock host 字段为空，跳过</span><br>        new_block-&gt;host = host;<br>        new_block-&gt;flags |= RAM_PREALLOC_MASK;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mem_path) &#123; <span class="hljs-comment">// 未指定 mem_path</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (__linux__) &amp;&amp; !defined(TARGET_S390X)</span><br>            new_block-&gt;host = file_ram_alloc(new_block, size, mem_path);<br>            <span class="hljs-keyword">if</span> (!new_block-&gt;host) &#123;<br>                new_block-&gt;host = qemu_vmalloc(size);<br>                qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;-mem-path option unsupported\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (xen_enabled()) &#123;<br>                xen_ram_alloc(new_block-&gt;offset, size, mr);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kvm_enabled()) &#123; <span class="hljs-comment">// 从这里继续</span><br>                <span class="hljs-comment">/* some s390/kvm configurations have special constraints */</span><br>                new_block-&gt;host = kvm_vmalloc(size); <span class="hljs-comment">// 实际上还是调用 qemu_vmalloc(size)</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                new_block-&gt;host = qemu_vmalloc(size); <span class="hljs-comment">// 从 QEMU 的线性空间中分配 size 大小的内存，返回 HVA</span><br>            &#125;<br>            qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);<br>        &#125;<br>    &#125;<br>    new_block-&gt;length = size; <span class="hljs-comment">// 将 length 设置为 size</span><br><br>    QLIST_INSERT_HEAD(&amp;ram_list.blocks, new_block, next); <span class="hljs-comment">// 将该 RAMBlock 插入 ram_list 头部</span><br><br>    ram_list.phys_dirty = g_realloc(ram_list.phys_dirty, <span class="hljs-comment">// 重新分配 ram_list.phys_dirty 的内存空间</span><br>                                       last_ram_offset() &gt;&gt; TARGET_PAGE_BITS);<br>    <span class="hljs-built_in">memset</span>(ram_list.phys_dirty + (new_block-&gt;offset &gt;&gt; TARGET_PAGE_BITS),<br>           <span class="hljs-number">0</span>, size &gt;&gt; TARGET_PAGE_BITS);<br>    cpu_physical_memory_set_dirty_range(new_block-&gt;offset, size, <span class="hljs-number">0xff</span>); <span class="hljs-comment">// 对该 RAMBlock 对应的内存标记为 dirty</span><br><br>    qemu_ram_setup_dump(new_block-&gt;host, size);<br><br>    <span class="hljs-keyword">if</span> (kvm_enabled())<br>        kvm_setup_guest_memory(new_block-&gt;host, size);<br><br>    <span class="hljs-keyword">return</span> new_block-&gt;offset;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样一来<code>ram</code>【其实就是<code>system memory</code>，整个<code>Guest</code>物理空间的大小】对应的 <code>RAMBlock</code> 中就分配好了 <code>GPA</code> 和 <code>HVA</code>，就可以<strong>将内存信息同步至 KVM 侧</strong>了。</p>
<p>最后回到<code>pc_memory_init()</code>中，在分配完实际内存后，会先调用<code>memory_region_init_alias()</code>初始化<code>ram_below_4g</code>、<code>ram_above_4g</code>这两个<code>alias</code>，之后调用<code>memory_region_add_subregion()</code>将这两个 <code>alias</code> 指向<code>ram</code>这个实体 <code>MemoryRegion</code>。如下图，该函数最终会触发<code>kvm_region_add()</code>回调，将实际的内存信息传入 <code>KVM</code> 注册。该过程如下图所示，与之前分析的流程相同，此处不再赘述。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163205.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟机的内存管理也是需要用户态的 <code>qemu</code> 和内核态的 <code>KVM</code> 共同完成。为了加速内存映射，需要借助硬件的 <code>EPT</code> 技术。</p>
<h3 id="QEMU-侧"><a href="#QEMU-侧" class="headerlink" title="QEMU 侧"></a>QEMU 侧</h3><ul>
<li><p>创建一系列 <code>MemoryRegion</code>，分别表示 <code>Guest</code> 中的 <code>RAM</code>、<code>ROM</code> 等区域。<code>MemoryRegion</code>之间通过 <code>alias</code> 或 <code>subregions</code> 的方式维护相互之间的关系，从而进一步细化区域的定义</p>
</li>
<li><p>对于一个实体 <code>MemoryRegion</code>（非 <code>alias</code>），在初始化内存的过程中 <code>QEMU</code> 会创建它所对应的 <code>RAMBlock</code>。该 <code>RAMBlock</code> 通过调用<code>qemu_ram_alloc_from_ptr()</code>从 <code>QEMU</code> 的进程地址空间中<strong>以 mmap 的方式分配内存</strong>，并负责<strong>维护该 MemoryRegion 对应内存的起始 GPA/HVA/size 等相关信息</strong>【在<code>qemu_ram_alloc_from_ptr</code>中创建的新<code>RAMBlock</code>有<code>offset</code>、<code>host</code>的赋值，即<code>GPA-&gt;HVA</code>的对应关系】</p>
</li>
<li><p><code>AddressSpace</code> 表示 <code>Guest</code> 的物理地址空间。如果 <code>AddressSpace</code> 中的 <code>MemoryRegion</code> 发生变化，则注册的 <code>listener</code> 会被触发，将所属的 <code>MemoryRegion</code> 树展开生成一维的 <code>FlatView</code>，比较 FlatRange 是否发生了变化。如果是，则调用相应的方法对 <code>MemoryRegionSection</code> 进行检查，更新 <code>QEMU</code> 中的 <code>KVMSlot</code>，同时填充<code>kvm_userspace_memory_region</code>结构体，作为<code>ioctl()</code>的参数更新 <code>KVM</code> 中的<code>kvm_memory_slot</code></p>
</li>
</ul>
<h3 id="KVM-侧"><a href="#KVM-侧" class="headerlink" title="KVM 侧"></a>KVM 侧</h3><ul>
<li><p>当 <code>QEMU</code> 通过<code>ioctl()</code>创建 <code>vcpu</code> 时，调用<code>kvm_mmu_create()</code>初始化 <code>MMU</code> 相关信息。<br>当 <code>KVM</code> 要进入 <code>Guest</code> 前，<code>vcpu_enter_guest()=&gt;kvm_mmu_reload()</code>会将根级页表地址加载到 <code>VMCS</code>，让 <code>Guest</code> 使用该页表</p>
</li>
<li><p>当发生<code>EPT Violation</code> 时，<code>VM-EXIT</code>到 <code>KVM</code> 中。如果是缺页，则根据 <code>GPA</code> 算出 <code>gfn</code>，再根据 <code>gfn</code> 找到对应的 <code>KVMSlot</code>，从中得到对应的 <code>HVA</code>。然后根据 <code>HVA</code> 算出对应的 <code>pfn</code>，确保该 <code>Page</code> 位于内存中。填好缺失的页之后，需要更新 <code>EPT</code>，完善其中缺少的页表项，逐层补全页表</p>
</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163418.png"></p>
<blockquote>
<p>虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即 <code>mmap</code> 分配的虚拟内存空间被访问的时候，先查看 <code>EPT</code> 页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。<br>如果没有映射过，则虚拟机会通过<code>VM-Exit</code>指令回到宿主机模式，通过 <code>handle_ept_violation</code> 补充页表映射。先是通过 <code>handle_mm_fault</code>为虚拟机的物理内存空间分配真正的物理页面，然后通过 <code>__direct_map</code> 添加 <code>EPT</code> 页表映射。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127171031.jpg"></p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="http://xudaxian.fun/2020/09/03/QEMU%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">“QEMU 内存空间虚拟化及内存管理” - B10g | FΓom 许大仙</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LoyenWang/p/13943005.html">【原创】Linux 虚拟化 KVM-Qemu 分析（五）之内存虚拟化 - LoyenWang - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiongwenwu/article/details/58586013">KVM/Qemu 工作原理系列目录_xiongwenwu 的专栏-CSDN 博客_qemu 目录结构</a><br><a target="_blank" rel="noopener" href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/01/19/%E8%A7%A3%E5%86%B3VSCode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%87%E7%A8%8B%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8/" itemprop="url">解决 VSCode 配置远程连接，过程试图写入的管道不存在</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-19T15:07:49.000Z" itemprop="datePublished">1月 19 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 读完 (约 321 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201192309069.png"></p>
<h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>本地记录的服务器信息和现有的产生了冲突</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>将<code>known_hosts</code>文件的内容全部删除。</p>
<p><code>C:\Users\user name\.ssh\known_hosts</code></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>搜遍全网几乎都是上述方法，应该绝大部分人通过上述方法都能解决。如果你也跟我一样不走运，不管是重新生成公私钥，还是删除<code>hnow_hosts</code>都不行，那么可以尝试修改 VSCode 使用的<code>ssh.exe</code>。Windows 下默认使用的是环境变量里配置的<code>OpenSSH</code>提供的<code>ssh.exe</code>。你可以将环境变量里的<code>OpenSSH</code>删除。然后在<code>VSCode</code>设置里搜索<code>remote</code>，也就是设置插件<code>remote ssh</code>。</p>
<p>将 Path 强制设置成<code>Git</code>安装包内的<code>ssh.exe</code></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201192304598.png"></p>
<p>或者<code>mobaxterm</code>安装包内的<code>ssh.exe</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://codeantenna.com/a/8z5QCm29iy">Debug | VSCode | 过程试图写入的管道不存在 - CodeAntenna</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42096901/article/details/105193366">VScode 通过 remote ssh 连接虚拟机 &amp; 报错 过程试图写入的管道不存在（已解决）_Tasdily 的博客-CSDN 博客_vscode 过程试图写入的管道不存在</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/01/17/Linux%E5%B8%A7%E7%BC%93%E5%86%B2/" itemprop="url">Linux 帧缓冲</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-17T09:38:04.000Z" itemprop="datePublished">1月 17 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            26 分钟 读完 (约 3950 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220118092227.png"></p>
<h2 id="帧缓冲主要结构"><a href="#帧缓冲主要结构" class="headerlink" title="帧缓冲主要结构"></a>帧缓冲主要结构</h2><ul>
<li><p>fb_info<br>  该结构体记录当前帧缓冲设备的状态信息，如果系统中有多个帧缓冲设备，就需要两个fb_info结构，这个结构只在内核中可以看到，对用户空间不可见。</p>
</li>
<li><p>fb_var_screeninfo<br>  该结构体记录指定的帧缓冲设备和显示模式中可以被修改的信息，其中包括显示器分辨率等信息。</p>
</li>
<li><p>fb_fix_screeninfo<br>  该结构体表示帧缓冲设备中一些不能修改的参数，包括特定的显示模式，屏幕缓冲区的物理地址，显示缓冲区的长度信息。</p>
</li>
<li><p>fb_ops<br>  LCD底层硬件操作接口集。比如<code>fb_open</code>、<code>fb_release</code>、<code>fb_read</code>、<code>fb_write</code>、<code>fb_ioctl</code>、<code>fb_mmap</code>等：</p>
</li>
<li><p>fb_cmap<br>  <code>fb_cmap</code>指定颜色映射，用于以内核可以理解的方式存储用户的颜色定义。</p>
</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220117192106.png"></p>
<h2 id="帧缓冲显示原理"><a href="#帧缓冲显示原理" class="headerlink" title="帧缓冲显示原理"></a>帧缓冲显示原理</h2><p>帧缓冲设备是一种显示抽象的设备，也可以被理解为它是一个内存区域，上面的应用程序可以直接对显示缓冲区进行读和写操作，就像访问文件的通用接口一样，用户可以认为帧缓冲是一块内存，能读取数据的内存块也可以向这个内存写入数据，因此显示器显示图形界面实际上根据根据的是指定的内存数据块内的数据。</p>
<p>帧缓冲的显示缓冲区位于 Linux 内核地址空间，应用程序不能直接访问内核地址空间，在 Linux 中，只有一个内存的内核地址空间映射到用户地址空间才可以由用户访问，内存的映射是通过<code>MMAP</code>函数实现的在 Linux 中。对于帧缓冲，虚拟地址是通过内存映射的方法将显示缓冲区内核地址映射到用户空间的，然后用户可以通过读和写这部分的虚拟地址来访问显示缓冲区，在屏幕上绘图。</p>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><p>使用帧缓冲之前应该首先确定 Linux 系统上已安装了帧缓冲驱动，可以在目录<code>/dev/</code>下查找<code>fb*</code>如，<code>/dev/fb0, /dev/fb1</code>等设备来确定是否安装。如果没有需要安装一个帧缓冲驱动的模块到内核，或者重新编译内核生成一个带帧缓冲模块的镜像。</p>
<p>使用帧缓冲需要进入控制台模式，即纯命令行的模式进行编程。一般可以通过快捷键<code>CTRL+ALT+F1</code>进入控制台模式，<code>CTRL+ALT+F7</code>切回图形窗口。如果控制台模式没有登录，可以<code>CTRL+ALT+F6</code>尝试登录。</p>
<p>因硬件显示设备的物理显示区是通过帧缓存区操作，而帧缓存区是处于内核空间，应用程序不能随意操作，此时可以通过系统调用<code>mmap</code>把帧缓存映射到用户空间，在用户空间中创建出帧缓存映射区（用户图像数据缓存区），以后只需把用户图像数据写入到帧缓存映射区就可在硬件设备上显示图像。</p>
<p>具体实现流程如下：</p>
<h3 id="打开帧缓冲设备-dev-f0"><a href="#打开帧缓冲设备-dev-f0" class="headerlink" title="打开帧缓冲设备/dev/f0"></a>打开帧缓冲设备<code>/dev/f0</code></h3><p>在Linux的/dev目录的寻找b*设备文件然后使用读写模式打开它，Linux 系统将使用通用的<code>open</code>系统调用来完成功能， <code>open</code>的功能原型如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflags)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>Path</code>是准备打开的文件或设备的路径参数；</li>
<li><code>oflags</code>指定打开文件时使用的参数；</li>
<li><code>flags</code>参数的指定，是通过组合文件访问模式和其他的可选模式一起的，可以支持多个模式或，参数必须是指定下列文件的访问模式。<ul>
<li>只读：O_RDONLLY</li>
<li>只写：O_WRONLY</li>
<li>读写：O_RDWR</li>
</ul>
</li>
</ul>
<p>简而言之， <code>open</code>函数建立设备文件的访问路径。如果操作成功，它返回一个文件描述符，只是一个文件描述符，它将不使用其他任何正在运行的进程共享。如果两个程序同时打开相同的文件，将得到两个不同的文件描述符。如果他们执行文件写入操作，他们将操作每个文件描述符，不会发生冲突，写完之后退出。他们的数据不会互相交织在一起的，但会互相的彼此覆盖 (后写完的内容覆盖前面写的内容)，两个程序来读取和写入的文件位置看似一样但是有各自不同拷贝所以不会发生交织。如果<code>open</code>调用未能返回<code>1</code>，则将全局变量<code>errno</code>设置为指示失败的原因。</p>
<h3 id="通过系统调用ioctl函数获得帧设备相关信息"><a href="#通过系统调用ioctl函数获得帧设备相关信息" class="headerlink" title="通过系统调用ioctl函数获得帧设备相关信息"></a>通过系统调用<code>ioctl</code>函数获得帧设备相关信息</h3><p>通过顿缓冲文件描述符，屏幕的分辨率、颜色深度等信息可以被获得，帧缓冲驱动中存放了这些对应的信息，必须使用 Linux 系统调用<code>ioctl</code>首先将帧缓冲的文件描述符和<code>fb_var_screeninfo</code> 结构体对应起来。</p>
<p>结构体<code>fb_var_screeninfo</code>包含以下三个重要数据结构：</p>
<ul>
<li>屏幕的 x 方向分辨率，像素作为单位。</li>
<li>屏幕的 Y 方向分辨率，像素作为单位。</li>
<li>屏幕的像素颜色深度，每个像素用多少比特数表示。</li>
</ul>
<p><code>ioctl</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> __request, ...)</span> __THROW</span>;<br></code></pre></td></tr></table></figure>

<p><code>ioctl</code>调用实现访问设备驱动各种各样的配置信息功能，它提供了一个控制设备的行为和配置底层服务接口的驱动函数，各种设备驱动程序，例如套接字和系统终端，还有磁带机都有<code>ioctl</code>命令可以支持。</p>
<ul>
<li><code>__fd</code>：<code>ioctl</code>命令中是该帧缓冲的文件描述符；</li>
<li><code>__request</code>：<code>ioctl</code>函数将要执行的命令，实现参数给定的对象描述符中指定的函数操作，各种设备支持的功能是有差异的<ul>
<li><code>FBIOGET_VSCREENINFO</code>命令字返回与Framebuffer有关的固定的信息；</li>
<li><code>FBIOGET_VSCREENINFO</code>命令字返回与 Framebuffer 有关的可变的信息；</li>
</ul>
</li>
<li>第三个参数是一个指针用来指向结构体<code>fb_var_screeninfo</code>。</li>
</ul>
<p>最后使用者可以通过结构体<code>fb_var_screeninfo</code>来获得屏幕的分辨率和颜色位深和其他重要的屏幕信息。根据这些信息可以计算屏幕缓冲区的大小：屏幕缓冲区大小 (以字节为单位) = 屏幕宽度x高度x屏幕颜色深度/8</p>
<h3 id="帧缓冲映射"><a href="#帧缓冲映射" class="headerlink" title="帧缓冲映射"></a>帧缓冲映射</h3><p>在进行帧缓冲的<code>MMAP</code>映射之前，要先得到帧缓冲文件描述符，才能像屏幕上面显示，必须首先将缓冲区的内核地址映射映射到用户地址空间。Linux 系统将使用<code>MMAP</code>系统调用完成功能，<code>MMAP</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">mmap</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *__addr, <span class="hljs-keyword">size_t</span> __len, <span class="hljs-keyword">int</span> __prot,</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-keyword">int</span> __flags, <span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">__off_t</span> __offset)</span> __THROW</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>__addr</code>：返回一个指向<code>mmap</code>函数的内存区域的指针，与内容相关的文件指针，通过指针可以访问帧缓冲区的内存区域。</p>
</li>
<li><p><code>__len</code>：可以请求使用特定内存地址，通过设置地址参数，如果值为<code>0</code>，将自动分配指针，这是推荐的做法，否则会降低程序的可移植性，因为不同的系统可用的地址范围是不一样的。</p>
</li>
<li><p><code>__prot</code>：设置内存访问的权限设定，通过端口相关的参数定义，位的定义值如下：</p>
<ul>
<li><code>PORT_EXEC</code>:允许内存段的执行。</li>
<li><code>PORT_NONE</code>:无法访问内存段。</li>
<li><code>PORT_READ</code>:允许读取内存段。</li>
<li><code>PORT_WRITE</code>:允许编写内存段。</li>
</ul>
</li>
<li><p><code>__flags</code>：改变控制参数标志，能够影响该内存段的作用域，如下所示：</p>
<ul>
<li><code>MAP_FIXED</code>:内存段必须位于addr中指定的地址。</li>
<li><code>MAP_SHARED</code>:内存的修改保存到一个文件中。</li>
<li><code>MAP_PRIVATE</code>:内存段是私人的，变化仅在本地范围内有效。</li>
</ul>
</li>
<li><p><code>__fd</code>：是通过一个<code>open</code>调用得到的访问文件的描述符。</p>
</li>
<li><p><code>offset</code>：用于指定访问数据的开始偏移量在内存段中，和访问普通文件使用方式是相同的，再指定文件描述符参数，以及访问的数据长度参数即可。</p>
</li>
</ul>
<h3 id="读写帧缓冲"><a href="#读写帧缓冲" class="headerlink" title="读写帧缓冲"></a>读写帧缓冲</h3><p><code>MMAP</code>返回的指针，可以访问到帧缓冲内存区，可以定位到屏幕缓冲区具体为每个显示像素的位置，通过读函数调用读取对应的位置数据在帧缓冲内存中，相反写操作对应于内存的写入数据可以显示内容写到屏幕上。</p>
<h3 id="解除帧缓冲映射"><a href="#解除帧缓冲映射" class="headerlink" title="解除帧缓冲映射"></a>解除帧缓冲映射</h3><p>在绘图完成后，帧缓冲文件描述符必须被释放之前，解除帧缓冲区的地址映射，使用 Linux 系统调用完成<code>mmap</code>函数的逆函数实现，即是<code>munmap</code>，函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *__addr, <span class="hljs-keyword">size_t</span> __len)</span> __THROW</span>;<br></code></pre></td></tr></table></figure>

<p><code>addr</code>参数应该与调用<code>MMAP</code>时指定的参数值一致， <code>len</code>参数也应该与之前调用<code>MMAP</code>时指定的<code>len</code>参数保持一致。</p>
<p><code>mmap</code>调用返回<code>0</code>成功，失败则返回<code>1</code>，同时将全局变量<code>erno</code>设置为指示失败的原因。</p>
<h3 id="调用close关闭设备"><a href="#调用close关闭设备" class="headerlink" title="调用close关闭设备"></a>调用<code>close</code>关闭设备</h3><p>使用帧缓冲设备后，应关闭相应的文件描述符，使用 Linux 系统标准的函数完成关闭功能，<code>close</code>函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">close</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> __fd)</span></span>;<br></code></pre></td></tr></table></figure>

<p><code>close</code>的参数和在开始调用<code>open</code>时指定的参数一致，文件描述符释放后可以重用，结束调用成功返回<code>0</code>，失败返回<code>1</code>。</p>
<h2 id="帧缓冲实例"><a href="#帧缓冲实例" class="headerlink" title="帧缓冲实例"></a>帧缓冲实例</h2><p>以下代码摘自<a target="_blank" rel="noopener" href="https://github.com/xianjimli/linux-framebuffer-tools">xianjimli/linux-framebuffer-tools: linux framebuffer tool</a>，演示了帧缓冲设备的使用流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">fb_info_t</span> *<span class="hljs-title">linux_fb_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint32_t</span>                 size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">fb_info_t</span>               *fb   = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_fix_screeninfo</span> <span class="hljs-title">fix</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_var_screeninfo</span> <span class="hljs-title">var</span>;</span><br>    return_value_if_fail(filename != <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    fb = (<span class="hljs-keyword">fb_info_t</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">fb_info_t</span>));<br>    return_value_if_fail(fb != <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 打开帧缓冲设备，O_RDWR 读写模式</span><br>    fb-&gt;fd = open(filename, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fb-&gt;fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        log_debug(<span class="hljs-string">&quot;open %s failed(%d)\n&quot;</span>, filename, errno);<br>        <span class="hljs-built_in">free</span>(fb);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">// 通过系统调用 ioctl 函数获得帧设备相关信息</span><br>    <span class="hljs-comment">// FBIOGET_FSCREENINFO 命令字返回与 Framebuffer 有关的固定的信息</span><br>    <span class="hljs-keyword">if</span> (ioctl(fb-&gt;fd, FBIOGET_FSCREENINFO, &amp;fix) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> fail;<br>    <span class="hljs-comment">//命令字返回与 Framebuffer 有关的可变的信息</span><br>    <span class="hljs-keyword">if</span> (ioctl(fb-&gt;fd, FBIOGET_VSCREENINFO, &amp;var) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> fail;<br><br>    var.xoffset = <span class="hljs-number">0</span>;<br>    var.yoffset = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 显示</span><br>    ioctl(fb-&gt;fd, FBIOPAN_DISPLAY, &amp;(var));<br><br>    log_debug(<span class="hljs-string">&quot;fb_info_t: %s\n&quot;</span>, filename);<br>    log_debug(<span class="hljs-string">&quot;fb_info_t: xres=%d yres=%d bits_per_pixel=%d mem_size=%d\n&quot;</span>, var.xres, var.yres,<br>              var.bits_per_pixel, fb_size(fb));<br>    log_debug(<span class="hljs-string">&quot;fb_info_t: red(%d %d) green(%d %d) blue(%d %d)\n&quot;</span>, var.red.offset, var.red.length,<br>              var.green.offset, var.green.length, var.blue.offset, var.blue.length);<br><br>    fb-&gt;w           = var.xres;<br>    fb-&gt;h           = var.yres;<br>    fb-&gt;bpp         = var.bits_per_pixel / <span class="hljs-number">8</span>;<br>    fb-&gt;line_length = fix.line_length;<br><br>    size = fb_size(fb);<br>    <span class="hljs-comment">// 帧缓冲映射</span><br>    <span class="hljs-comment">// PROT_READ | PROT_WRITE:可读写</span><br>    <span class="hljs-comment">// MAP_SHARED：内存的修改保存到一个文件</span><br>    fb-&gt;data = (<span class="hljs-keyword">uint8_t</span> *)mmap(<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fb-&gt;fd, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (fb-&gt;data == MAP_FAILED)<br>    &#123;<br>        log_debug(<span class="hljs-string">&quot;map framebuffer failed.\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br><br>    log_debug(<span class="hljs-string">&quot;line_length=%d mem_size=%d\n&quot;</span>, fix.line_length, fb_size(fb));<br>    log_debug(<span class="hljs-string">&quot;xres_virtual =%d yres_virtual=%d xpanstep=%d ywrapstep=%d\n&quot;</span>, var.xres_virtual,<br>              var.yres_virtual, fix.xpanstep, fix.ywrapstep);<br><br>    <span class="hljs-keyword">return</span> fb;<br>fail:<br>    log_debug(<span class="hljs-string">&quot;%s is not a framebuffer.\n&quot;</span>, filename);<br>    close(fb-&gt;fd);<br>    <span class="hljs-built_in">free</span>(fb);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>感兴趣可以下载源码编译运行，其中<code>/bin/fbshow</code>可以使用帧缓冲设备显示图片。图形界面下直接运行可能提示无法运行，需要<code>Chrtl+Alt+F1</code>切换到控制台模式。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220120202118.png"></p>
<h2 id="LCD-与-Framebuffer-的关系"><a href="#LCD-与-Framebuffer-的关系" class="headerlink" title="LCD 与 Framebuffer 的关系"></a>LCD 与 Framebuffer 的关系</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225141549.jpg"></p>
<p>LCD 控制器首先通过 VDEN 信号，使能。接下来根据 VCLK 时钟信号，在像素点上“喷涂”不同的颜色（打个比方），控制器有 VD（video data）信号，传送不同颜色信息。每来一个时钟信号，就向右移动一个像素，根据行同步信号 HSYNC，就从最右边移动到最左边。当移动到右下角时根据垂直同步信号 VSYNC。</p>
<p>那么问题来了，不同颜色的信息从哪里来？就是从上文介绍的 Framebuffer 中来的。</p>
<p>很多人都会说操纵 LCD 显示就是操纵 FrameBuffer，表面上来看是这样的。实际上是 FrameBuffer 就是 Linux 内核驱动申请的一片内存空间，然后 LCD 内有一片 sram，CPU 内部有个 LCD 控制器，它有个单独的 dma 用来将 FrameBuffer 中的数据拷贝到 LCD 的 sram 中去 拷贝到 LCD 的 sram 中的数据就会显示在 LCD 上，LCD 驱动和 FrameBuffer 驱动没有必然的联系，它只是驱动 LCD 正常工作的，比如有信号传过来，那么 LCD 驱动负责把信号转成显示屏上的内容，至于什么内容这就是应用层要处理的。</p>
<blockquote>
<p>静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。<br>DMA（Direct Memory Access），直接内存访问。使用 DMA 的好处就是它不需要 CPU 的干预而直接服务外设，这样 CPU 就可以去处理别的事务，从而提高系统的效率。</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://carlyleliu.github.io/2021/Linux%E9%A9%B1%E5%8A%A8%E4%B9%8BFramebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">Linux 驱动之 Framebuffer 子系统 | 量子范式</a><br><a target="_blank" rel="noopener" href="https://www.codenong.com/cs106598190/">Linux 驱动开发（9）——- framebuffer 驱动详解 | 码农家园</a><br><a target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201502&filename=1015587486.nh&uniplatform=NZKPT&v=KNvhApgKTzqH-mWxqP6f8BkbDR9mSjPHz8PfaxqDg2f1j30XqnHzSDsvwoqz-CbX">嵌入式系统中帧缓冲显示模块的设计与实现 - 中国知网</a><br><a target="_blank" rel="noopener" href="https://github.com/tsuibin/research/tree/master/framebuffer/fivechess/fivechess-0.1">research/framebuffer/fivechess/fivechess-0.1 at master · tsuibin/research</a><br><a target="_blank" rel="noopener" href="https://www.shangmayuan.com/a/f67d260756ce42258a9ed4ef.html">五子棋 framebuffer 版 - 尚码园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/article/details/12096483">FrameBuffer 驱动程序分析_深入剖析 Android 系统-CSDN 博客_framebuffer</a><br><a target="_blank" rel="noopener" href="https://github.com/xianjimli/linux-framebuffer-tools">xianjimli/linux-framebuffer-tools: linux framebuffer tool</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HW411L76t?p=2">韦东山_嵌入式 Linux_第 2 期_Linux 高级驱动视频教程_免费试看版_哔哩哔哩_bilibili</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356443723">Linux LCD Frambuffer 基础介绍和使用（1） - 知乎</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/01/13/%E8%A7%A3%E5%86%B3Git%20ssh%20permission%20denied(publickey)/" itemprop="url">解决 ssh permission denied(publickey)</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-13T14:43:02.000Z" itemprop="datePublished">1月 13 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/Bug-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">Bug 踩坑记录</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 分钟 读完 (约 448 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">linux&gt; ssh -p 2221 xxx@gerrit.com<br>xxx@gerrit.com: Permission denied(publickey)<br></code></pre></td></tr></table></figure>

<h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>本次出错是在测试是否能连接 gerrit 时。连接 GitHub 也可能会出现。只要用到 ssh 功能的都有可能。</p>
<p>出错的原因：</p>
<ul>
<li>网页（如 gerrit,github）没有设置公钥，一般为<code>id_rsa.pub</code>内容；</li>
<li>本地生成了多个公私钥，配对配错了；</li>
<li>本地没有配置好<code>git</code>，比如<code>git config</code>时用户名或者邮箱填错；</li>
<li>需要开启 ssh 代理；</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>生成密钥<code>cd ~/.ssh &amp;&amp; ssh-keygen</code></li>
<li>复制公钥内容，添加到网页中<code>github</code>或者<code>gerrit</code>的设置里。<code>cat id_rsa.pub | xclip</code></li>
<li>配置<code>git</code>账户<ul>
<li><code>git config --global user.name &quot;bob&quot;</code></li>
<li><code>git config --global user.email bob@...</code></li>
</ul>
</li>
</ul>
<p>以上检查无误，仍然报错</p>
<ul>
<li>开启<code>ssh</code>代理<ul>
<li><code>eval $(ssh-agent -s)</code></li>
</ul>
</li>
<li>将私钥加入代理<ul>
<li><code>ssh-add ~/.ssh/id_rsa</code></li>
</ul>
</li>
</ul>
<h2 id="登陆用户时启动-ssh-agent"><a href="#登陆用户时启动-ssh-agent" class="headerlink" title="登陆用户时启动 ssh-agent"></a>登陆用户时启动 ssh-agent</h2><p>如果不幸你的问题就是需要开启<code>ssh-agent</code>，那么每次重启电脑都需要开启一次。这也是相当麻烦的，可以通过将以下配置添加到<code>~/.bashrc</code>中，让 Linux 启动时自动开启<code>ssh-agent</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># Add following code at the end of ~/.bashrc</span><br><br><span class="hljs-comment"># Check if ~/.pid_ssh_agent exists.</span><br><span class="hljs-keyword">if</span> [ -f ~/.pid_ssh_agent ]; <span class="hljs-keyword">then</span><br><br>    <span class="hljs-built_in">source</span> ~/.pid_ssh_agent<br><br>    <span class="hljs-comment"># Check process of ssh-agent still exists.</span><br>    TEST=$(ssh-add -l)<br><br>    <span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$TEST</span>&quot;</span> ]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># Reinit if not.</span><br>        NEED_INIT=1<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">else</span><br>    NEED_INIT=1 <span class="hljs-comment"># PID file doesm&#x27;t exist, reinit it.</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># Try start ssh-agent.</span><br><span class="hljs-keyword">if</span> [ ! -z <span class="hljs-string">&quot;<span class="hljs-variable">$NEED_INIT</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> $(ssh-agent -s) | sed -e <span class="hljs-string">&#x27;s/echo[ A-Za-z0-9]*;//g&#x27;</span> &gt; ~/.pid_ssh_agent <span class="hljs-comment"># save the PID to file.</span><br>    <span class="hljs-built_in">source</span> ~/.pid_ssh_agent<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2643502/git-how-to-solve-permission-denied-publickey-error-when-using-git">ssh - Git: How to solve Permission denied (publickey) error when using Git? - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://fenying.net/post/2017/12/20/auto-init-ssh-agent/">Linux 登陆用户时启动 ssh-agent 并复用 - Fenying</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/01/10/Linux%E5%AE%89%E8%A3%85nodejs/" itemprop="url">Linux 安装 Node.js 以及 hexo</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-10T03:51:50.000Z" itemprop="datePublished">1月 10 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 读完 (约 258 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="安装-Node-js-过程"><a href="#安装-Node-js-过程" class="headerlink" title="安装 Node.js 过程"></a>安装 Node.js 过程</h2><p>进入该网站<a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/download/">下载 | Node.js</a><br>也可以进入该网站下载历史版本，<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js</a></p>
<p>进入 download 目录，</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> download<br><span class="hljs-attribute">wget</span> https://nodejs.org/dist/v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>/node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span>.tar.xz  -O nodejs.tar.xz<br></code></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -xvf node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span>.tar.xz<br></code></pre></td></tr></table></figure>

<p>改名 Node.js</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span> nodejs<br></code></pre></td></tr></table></figure>

<p>将 npm，node 两个程序建立软连接，能够全局可用</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln -s <span class="hljs-regexp">/download/</span>nodejs<span class="hljs-regexp">/bin/</span>npm <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span> <br><br>ln -s <span class="hljs-regexp">/download/</span>nodejs<span class="hljs-regexp">/bin/</span>node <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span><br></code></pre></td></tr></table></figure>

<p>检查是否安装</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br><br>npm -v<br></code></pre></td></tr></table></figure>

<h2 id="安装-hexo-过程"><a href="#安装-hexo-过程" class="headerlink" title="安装 hexo 过程"></a>安装 hexo 过程</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm i hexo-<span class="hljs-keyword">cli</span> -g<br>hexo -v<br></code></pre></td></tr></table></figure>

<p>如果出现命令未找到到错误，说明 hexo 还未加入全局变量。<br>将下面命令加入</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim ~/.bashrc<br>export PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nodejs/</span>lib<span class="hljs-regexp">/node_modules/</span>hexo-cli<span class="hljs-regexp">/bin/</span>:<span class="hljs-variable">$PATH</span> <br></code></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js</a><br><a target="_blank" rel="noopener" href="https://learnku.com/articles/32767">Linux 安装 Node.js | F2E 前端技术论坛</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000024422534">Linux 下安装 node 及 npm - SegmentFault 思否</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35668237">超详细 Hexo+Github 博客搭建小白教程 - 知乎</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/01/08/C%E8%AF%AD%E8%A8%80-attribute-%E4%BD%BF%E7%94%A8/" itemprop="url">C 语言__attribute__使用</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-08T07:40:51.000Z" itemprop="datePublished">1月 8 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            10 分钟 读完 (约 1540 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>__attribute__</code> 其实是个编译器指令，告诉编译器声明的特性，或者让编译器进行更多的错误检查和高级优化。</p>
<p><code>__attribute__</code> 可以设置<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Function-Attributes.html#Function-Attributes">函数属性（Function Attribute）</a>、<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Variable-Attributes.html#Variable-Attributes">变量属性（Variable Attribute）</a>和<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Type-Attributes.html#Type-Attributes">类型属性（Type Attribute）</a>。每一类都包含数十种属性，本文不会逐一解释，只抛砖引玉，完整属性可以查看链接中的官方文档。</p>
<p>一个属性说明符的形式是<code>__attribute__ ((attribute-list))</code>。一个属性列表是一个可能为空的逗号分隔的属性序列，其中每个属性都是以下的一个。</p>
<ul>
<li>属性为空。空属性会被忽略。</li>
<li>一个单词（可能是未使用的标识符，也可能是 const 等保留字）。</li>
<li>一个单词，后面跟着括号中的属性参数。这些参数采用以下形式之一：<ul>
<li>一个标识符。例如，<code>mode</code>属性使用这种形式。</li>
<li>一个标识符，后跟一个逗号和一个以逗号分隔的非空表达式列表。例如，<code>format</code>属性使用这种形式。</li>
<li>一个可能是空的逗号分隔的表达式列表。例如，<code>format_arg</code>属性使用这种形式，该列表是一个单一的整数常量表达式，而<code>alias</code>属性也使用这种形式，该列表是一个单一的字符串常量。</li>
</ul>
</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><p>该属性可以设置函数的别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __f() &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;__attribute__ test\n&quot;</span>); &#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((weak, alias(<span class="hljs-string">&quot;__f&quot;</span>)))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  f();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*--- 输出 ---*/</span> <br><span class="hljs-comment">//__attribute__ test</span><br></code></pre></td></tr></table></figure>

<p>函数<code>f()</code>的别名为<code>__f()</code>，调用<code>f()</code>即调用<code>__f()</code>。</p>
<h4 id="alloc-size"><a href="#alloc-size" class="headerlink" title="alloc_size"></a>alloc_size</h4><p><code>alloc_size</code>属性用来告诉编译器，函数的返回值指向内存，其中的大小由一个或两个函数参数给出。GCC 使用这些信息来提高<code>__builtin_object_size</code>的正确性。</p>
<p><code>alloc_size</code>后面可以跟一到二个参数，<code>alloc_size</code> 后面跟的参数是指定使用函数的第几个参数。</p>
<ul>
<li><p>函数的参数的个数只有一个，那么 alloc_size 的参数只能是 1。通过<code>__builtin_object_size</code> 获取的值 就是传入的参数值。如图，我们给函数<code>my_malloc</code> 传入的值是<code>100</code> ，那么我们通过<code>__builtin_object_size</code> 获取的值就是<code>100</code>。</p>
</li>
<li><p>函数的参数的个数多余两个，那么<code>alloc_size</code> 的最多可以指定两个参数。传入两个参数，<code>__builtin_object_size</code>的值是这两个参数的乘积。传入一个参数，<code>__builtin_object_size</code>的值就是这个参数的值。如图，<code>my_callocd</code>函数指定的参数是<code>alloc_size(2,3)</code>，通过<code>__builtin_object_size</code>获取的值就是<code>my_callocd</code>传入的第二和三个参数的乘积（2*3=6）。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_calloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((alloc_size(<span class="hljs-number">1</span>)))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_realloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((alloc_size(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_calloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_realloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> p = my_calloc(<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size : %ld\n&quot;</span>, __builtin_object_size(p, <span class="hljs-number">0</span>));<br><br>  <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> a = my_realloc(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size : %ld\n&quot;</span>, __builtin_object_size(a, <span class="hljs-number">1</span>));<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*--- 输出 ---*/</span> <br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure>

<h4 id="constructor-priority-destructor-priority"><a href="#constructor-priority-destructor-priority" class="headerlink" title="constructor (priority) / destructor (priority)"></a>constructor (priority) / destructor (priority)</h4><p><code>constructor</code>属性使该函数在执行进入<code>main()</code>之前被自动调用。同样地，<code>destructor</code>属性使函数在<code>main()</code>完成后或<code>exit()</code>被调用后被自动调用。具有这些属性的函数对于初始化将在程序执行过程中隐含使用的数据非常有用。</p>
<p><code>constructor</code> 和 <code>+load</code> 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。</p>
<p>若有多个 <code>constructor</code> 且想控制优先级的话，可以写成 <code>attribute((constructor(101)))</code>，里面的数字越小优先级越高，<code>1 ~ 100</code> 为系统保留。</p>
<h3 id="变量属性"><a href="#变量属性" class="headerlink" title="变量属性"></a>变量属性</h3><h4 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h4><p>该属性在变量作用域结束时，调用指定的一个函数。这个属性只能应用于自动函数范围的变量；它不能应用于参数或具有静态存储期限的变量。该函数必须接受一个参数，一个指向与变量兼容的类型的指针。函数的返回值（如果有的话）被忽略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_cleanup</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **str)</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after cleanup: %s\n&quot;</span>, *str);<br>  <span class="hljs-built_in">free</span>(*str);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br><br>  <span class="hljs-keyword">char</span> *str __attribute__((__cleanup__(test_cleanup))) = <span class="hljs-literal">NULL</span>;<br>  str = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>((<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)) * <span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;test&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;before cleanup : %s\n&quot;</span>, str);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*--- 输出 ---*/</span> <br><span class="hljs-comment">//before cleanup : test</span><br><span class="hljs-comment">//after cleanup: test</span><br></code></pre></td></tr></table></figure>

<p>作用域结束包括大括号结束、<code>return</code>、<code>goto</code>、<code>break</code>、<code>exception</code>等各种情况。在上面的实验中，<code>main</code>函数返回标志变量<code>str</code>作用域结束，所以最后才打印<code>after cleanup: test</code>。</p>
<h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><h4 id="aligned-alignment"><a href="#aligned-alignment" class="headerlink" title="aligned (alignment)"></a>aligned (alignment)</h4><p>这个属性指定了函数的最小对齐方式，以字节为单位。对齐的大小只能增加，不能减小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> &#123;</span><br>  <span class="hljs-keyword">char</span> sex;<br>  <span class="hljs-keyword">int</span> length;<br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">char</span> value[<span class="hljs-number">15</span>];<br>&#125; __attribute__((aligned(<span class="hljs-number">1</span>)));<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> <span class="hljs-title">my_stu</span>;</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d \n&quot;</span>, <span class="hljs-keyword">sizeof</span>(my_stu));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p,%p,%p \n&quot;</span>, &amp;my_stu, &amp;my_stu.length, &amp;my_stu.name,<br>         &amp;my_stu.value);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*---  __attribute__((aligned(1)));输出 ---*/</span> <br><span class="hljs-comment">//28 </span><br><span class="hljs-comment">//0x55af2ba25020 0x55af2ba25024,0x55af2ba25028,0x55af2ba2502a</span><br><span class="hljs-comment">/*---  __attribute__((aligned(4)));输出 ---*/</span> <br><span class="hljs-comment">//28 </span><br><span class="hljs-comment">//0x556fbce54020 0x556fbce54024,0x556fbce54028,0x556fbce5402a </span><br><span class="hljs-comment">/*---  __attribute__((aligned(8)));输出 ---*/</span> <br><span class="hljs-comment">//32 </span><br><span class="hljs-comment">//0x5646e130e040 0x5646e130e044,0x5646e130e048,0x5646e130e04a</span><br></code></pre></td></tr></table></figure>

<p>由以上代码实验结果发现，默认对齐代下为 4 字节，小于这个值就被忽略，大于 4 字节才生效。</p>
<h2 id="Refernece"><a href="#Refernece" class="headerlink" title="Refernece"></a>Refernece</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e2dfccc32c80"><strong>attribute</strong> 机制使用 - 简书</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangweixaut061/article/details/6549768">C 语言复杂声明解析_wangweixaut061 的专栏-CSDN 博客_c 语言复杂声明</a><br><a target="_blank" rel="noopener" href="http://www.360doc.com/content/15/0305/15/14530056_452758913.shtml"><strong>attribute</strong> 你知多少？</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="../14/">上一页</a>
    </div>
    <div class="pagination-next">
        <a href="../16/">下一页</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="../../">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="../14/">14</a></li>
        
        <li><a class="pagination-link is-current" href="">15</a></li>
        
        <li><a class="pagination-link" href="../16/">16</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="../27/">27</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2024 Dominic&nbsp;
                powered_by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery > p > .gallery-item').unwrap();
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="../../js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '../../content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="../../js/insight.js"></script>

    
</body>
</html>