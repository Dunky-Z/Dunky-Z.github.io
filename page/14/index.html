<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>如云泊</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">





    <meta property="og:type" content="website">
<meta property="og:title" content="如云泊">
<meta property="og:url" content="https://lifeislife.cn/page/14/index.html">
<meta property="og:site_name" content="如云泊">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Dominic">
<meta name="twitter:card" content="summary">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="../../css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-PS8L2EEEPR');
</script>


    


<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="如云泊" type="application/atom+xml">
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="../../index.html">
                
                <img src="../../images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="../../archives">Archives</a>
            
            <a class="navbar-item "
               href="../../about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" target="_blank" rel="noopener" href="https://github.com/Dunky-Z">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/15/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" itemprop="url">C 语言实现简单有限状态机</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-15T04:41:30.000Z" itemprop="datePublished">5月 15 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            8 分钟 读完 (约 1129 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>常说的状态机是有限状态机 FSM，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。<br>三个特征：</p>
<ul>
<li>状态总数（state）是有限的。</li>
<li>任一时刻，只处在一种状态之中。</li>
<li>某种条件下，会从一种状态转变（transition）到另一种状态。</li>
</ul>
<p>设计状态机的关键点：当前状态、外部输入、下一个状态。</p>
<h2 id="状态机分类"><a href="#状态机分类" class="headerlink" title="状态机分类"></a>状态机分类</h2><h3 id="Moore-型状态机"><a href="#Moore-型状态机" class="headerlink" title="Moore 型状态机"></a>Moore 型状态机</h3><p>Moore 型状态机特点是：输出只与当前状态有关（与输入信号无关）。相对简单，考虑状态机的下一个状态时只需要考虑它的当前状态就行了。</p>
<h3 id="Mealy-型状态机"><a href="#Mealy-型状态机" class="headerlink" title="Mealy 型状态机"></a>Mealy 型状态机</h3><p>Mealy 型状态机的特点是：输出不只和当前状态有关，还与输入信号有关。状态机接收到一个输入信号需要跳转到下一个状态时，状态机综合考虑 2 个条件（当前状态、输入值）后才决定跳转到哪个状态。</p>
<h2 id="实现一个简单的状态机"><a href="#实现一个简单的状态机" class="headerlink" title="实现一个简单的状态机"></a>实现一个简单的状态机</h2><p>代码参考<a target="_blank" rel="noopener" href="https://github.com/AstarLight/FSM-framework">AstarLight/FSM-framework</a>。</p>
<p>以小明的一天设计出一个状态机，下图为状态转移图：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205151353618.png"></p>
<p>首先，有限状态机的状态是有限的，我们可以定义一天中的状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br> GET_UP,<br> GO_TO_SCHOOL,<br> HAVE_LUNCH,<br> DO_HOMEWORK,<br> SLEEP,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>状态机在没有事件的驱动下就是一潭死水，所以我们还需要定义出一些会发生的事件，去驱动状态机的运转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br> EVENT1 = <span class="hljs-number">1</span>,<br> EVENT2,<br> EVENT3,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>再定义一些在某个状态下需要处理的动作，也就是函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetUp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming gets up!\n&quot;</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Go2School</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming goes to school!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HaveLunch</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming has lunch!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoHomework</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming does homework!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Go2Bed</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming goes to bed!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义一个状态表结构，用来表示一个状态机的状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FsmTable_s</span></span><br><span class="hljs-class">&#123;</span><br> <span class="hljs-keyword">int</span> event;              <span class="hljs-comment">//事件</span><br> <span class="hljs-keyword">int</span> CurState;           <span class="hljs-comment">//当前状态</span><br> <span class="hljs-keyword">void</span> (*eventActFun)();  <span class="hljs-comment">//函数指针</span><br> <span class="hljs-keyword">int</span> NextState;          <span class="hljs-comment">//下一个状态</span><br>&#125;FsmTable_t;<br></code></pre></td></tr></table></figure>

<p>接下来，我们就可以这个结构定义一个状态表，状态机根据这个表进行状态的流转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">FsmTable_t XiaoMingTable[] =<br>&#123;<br> <span class="hljs-comment">//&#123;到来的事件，当前的状态，将要要执行的函数，下一个状态&#125;</span><br> &#123; EVENT1,  SLEEP,           GetUp,        GET_UP &#125;,<br> &#123; EVENT2,  GET_UP,          Go2School,    GO_TO_SCHOOL &#125;,<br> &#123; EVENT3,  GO_TO_SCHOOL,    HaveLunch,    HAVE_LUNCH &#125;,<br> &#123; EVENT1,  HAVE_LUNCH,      DoHomework,   DO_HOMEWORK &#125;,<br> &#123; EVENT2,  DO_HOMEWORK,     Go2Bed,       SLEEP &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>定义一个状态机结构，表示一个状态机：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FSM_s</span></span><br><span class="hljs-class">&#123;</span><br> FsmTable_t* FsmTable;   <span class="hljs-comment">//指向的状态表</span><br> <span class="hljs-keyword">int</span> curState;           <span class="hljs-comment">//FSM当前所处的状态</span><br><br>&#125;FSM_t;<br></code></pre></td></tr></table></figure>

<p>有了这些基本的结构，就可以写主函数了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> FSM_t fsm;                        <span class="hljs-comment">// 实例化一个状态机</span><br> InitFsm(&amp;fsm);                    <span class="hljs-comment">// 初始化状态机</span><br> <span class="hljs-keyword">int</span> event = EVENT1;               <span class="hljs-comment">// 初始化事件，为了启动状态机流转，</span><br>                                      <span class="hljs-comment">// 因为状态机只有在有时间发生时才会改变状态</span><br><br> <span class="hljs-comment">//小明的一天,周而复始的一天又一天，进行着相同的活动</span><br> <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event %d is coming...\n&quot;</span>, event);<br>  FSM_EventHandle(&amp;fsm, event); <span class="hljs-comment">// 有了初始事件，我们就需要处理这个事件，</span><br>                                      <span class="hljs-comment">// 再写一个处理事件的函数</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fsm current state %d\n&quot;</span>, fsm.curState);<br>  test(&amp;event); <br>  Sleep(<span class="hljs-number">1</span>);                     <span class="hljs-comment">//休眠1秒，方便观察</span><br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 测试用的，模拟事件的发生</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *event)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (*event == <span class="hljs-number">3</span>)<br> &#123;<br>  *event = <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span><br> &#123;<br>  (*event)++;<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>

<p>编写初始化状态机的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">int</span> g_state_max_num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 状态机的状态最大数量，根据状态表的大小来计算</span><br><span class="hljs-comment">// 初始化FSM</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitFsm</span><span class="hljs-params">(FSM_t* pFsm)</span></span><br><span class="hljs-function"></span>&#123;<br> g_state_max_num = <span class="hljs-keyword">sizeof</span>(XiaoMingTable) / <span class="hljs-keyword">sizeof</span>(FsmTable_t);<br> pFsm-&gt;curState = SLEEP; <span class="hljs-comment">// 初始状态为睡觉</span><br>    pFsm-&gt;FsmTable = XiaoMingTable;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编写事件处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 事件处理 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSM_EventHandle</span><span class="hljs-params">(FSM_t* pFsm, <span class="hljs-keyword">int</span> event)</span></span><br><span class="hljs-function"></span>&#123;<br> FsmTable_t* pActTable = pFsm-&gt;FsmTable;<br> <span class="hljs-keyword">void</span> (*eventActFun)() = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//函数指针初始化为空</span><br> <span class="hljs-keyword">int</span> NextState;<br> <span class="hljs-keyword">int</span> CurState = pFsm-&gt;curState;<br><br> <span class="hljs-comment">/* 获取当前动作函数 */</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;g_max_num; i++)<br> &#123;<br>  <span class="hljs-comment">//当且仅当当前状态下来个指定的事件，我才执行它</span><br>  <span class="hljs-keyword">if</span> (event == pActTable[i].event &amp;&amp; CurState == pActTable[i].CurState)<br>  &#123;<br>   pActTable[i].eventActFun();                      <span class="hljs-comment">// 执行动作函数</span><br>            FSM_StateTransfer(pFsm, pActTable[i].NextState); <span class="hljs-comment">// 执行状态转移</span><br>   <span class="hljs-keyword">break</span>;<br>  &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 状态迁移 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSM_StateTransfer</span><span class="hljs-params">(FSM_t* pFsm, <span class="hljs-keyword">int</span> state)</span></span><br><span class="hljs-function"></span>&#123;<br> pFsm-&gt;curState = state;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skyfsm/p/7071386.html">Linux 编程之有限状态机 FSM 的理解与实现 - Madcola - 博客园</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html">JavaScript 与有限状态机 - 阮一峰的网络日志</a><br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">有限状态机 - 维基百科，自由的百科全书</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/08/%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/" itemprop="url">链接脚本入门</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-08T13:32:23.000Z" itemprop="datePublished">5月 8 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            21 分钟 读完 (约 3176 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>位置无关编码 (PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。</p>
<p>位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。</p>
<p>我们在设计一个程序时，会给这个程序指定一个运行地址（链接地址）。就是说我们在编译程序时其实心里是知道我们程序将来被运行时的地址（运行地址）的，而且必须给编译器链接器指定这个地址（链接地址）才行。</p>
<p>最后得到的二进制程序理论上是和你指定的运行地址有关的，将来这个程序被执行时必须放在当时编译链接时给定的那个地址（链接地址）下才行，否则不能运行（就叫位置有关代码）。但是有个别特别的指令他可以跟指定的地址（链接地址）没有关系，也就是说这些代码实际运行时不管放在哪里都能正常运行。</p>
<p><strong>运行地址</strong>：由运行时决定的（编译链接时是无法绝对确定运行时地址的）。</p>
<p><strong>链接地址</strong>：由程序员在编译链接的过程中，通过<code>Makefile</code>中<code>-Ttext xxx</code>或者<strong>在链接脚本中指定</strong>的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。</p>
<p>举例：Linux 中的应用程序。<code>gcc hello.c -o hello</code>，这时使用默认的链接地址就是<code>0x0</code>，所以应用程序都是链接在<code>0x0</code>地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享 4G 的虚拟地址空间。所以应用程序都可以链接到 0 地址，因为每个进程都是从 0 地址开始的。（编译时可以不给定链接地址而都使用<code>0x0</code>）</p>
<h2 id="编译链接过程"><a href="#编译链接过程" class="headerlink" title="编译链接过程"></a>编译链接过程</h2><h3 id="每个过程的作用"><a href="#每个过程的作用" class="headerlink" title="每个过程的作用"></a>每个过程的作用</h3><ul>
<li>预编译：预编译器执行。替换宏定义，删除注释等工作。</li>
<li>编译：编译器来执行。把源码<code>.c .S</code>编程机器码<code>.o</code>文件。</li>
<li>链接：链接器来执行。把<code>.o</code>文件中的各函数（段）按照一定规则（链接脚本来指定）累积在一起，形成可执行文件。</li>
<li>strip：strip 是把可执行程序中的符号信息给拿掉，以节省空间。（Debug 版本和 Release 版本）</li>
<li>objcopy：由可执行程序生成可烧录的镜像<code>bin</code>文件。</li>
</ul>
<h3 id="编译后生成的段"><a href="#编译后生成的段" class="headerlink" title="编译后生成的段"></a>编译后生成的段</h3><p>段就是程序的一部分，我们把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段放在合适的位置。</p>
<p>段名分为 2 种：一种是编译器链接器内部定好的，一种是程序员自己指定的、自定义的段名。<br>已有段名：</p>
<ul>
<li>代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西</li>
<li>数据段：（.data），数据段就是 C 语言中有显式初始化为非 0 的全局变量</li>
<li>bss 段：（.bss），又叫 ZI（zero initial）段，就是零初始化段，对应 C 语言中初始化为 0 的全局变量。</li>
<li>自定义段名：段名由程序员自己定义，段的属性和特征也由程序员自己定义。</li>
</ul>
<blockquote>
<p>C 语言中全局变量如果未显式初始化，值是 0。本质就是 C 语言把这类全局变量放在了 bss 段，从而保证了为 0。<br>C 运行时环境如何保证显式初始化为非 0 的全局变量的值在 main 之前就被赋值了？就是因为它把这类变量放在了.data 段中，而.data 段会在 main 执行之前被处理（初始化）。</p>
</blockquote>
<h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><h3 id="链接脚本做什么事？"><a href="#链接脚本做什么事？" class="headerlink" title="链接脚本做什么事？"></a>链接脚本做什么事？</h3><p>链接脚本其实是个规则文件，他是程序员用来指挥链接器工作的。链接器会参考链接脚本，并且使用其中规定的规则来处理<code>.o</code>文件中那些段，将其链接成一个可执行程序。</p>
<p>链接脚本的关键内容有 2 部分：段名 + 地址（作为链接地址的内存地址）。把段，放到一个地址的意思。</p>
<p>链接脚本就像是一个从上到下顺序执行的一个代码</p>
<ul>
<li><code>.</code> 表示当前位置</li>
<li><code>=</code> 表示赋值</li>
<li><code>*</code> 表示通配符</li>
</ul>
<p>链接脚本里的符号，可以在汇编源码里引用。</p>
<p>一个简易示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lds">SECTIONS<br>&#123;<br>    . = 0xd0024000; # 当前地址为0xd0024000<br>    <br>    .text : &#123;<br>        start.o<br>        * (.text)   # 所有的text段<br>    &#125;<br>            <br>    .data : &#123;<br>        * (.data)<br>    &#125;<br>    <br>    bss_start = .;  # bss_start的值为当前地址，是执行到这里的地址，不是最上面. = 0xd0024000的地址<br>    .bss : &#123;<br>        * (.bss)<br>    &#125;<br>    <br>    bss_end  = .;    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h3><p><strong>任务：在 SRAM 中将代码从 0xd0020010 重定位到 0xd0024000</strong>。</p>
<p>第一点：通过链接脚本将代码链接到 0xd0024000<br>    重定位代码的作用就是：在PIC执行完之前（在代码中第一句位置有关码执行之前）必须将整个代码搬移到0xd0024000位置去执行，这就是重定位。</p>
<p>第二点：dnw 下载时将 bin 文件下载到 0xd0020010<br>    这样就能完成，下载代码与运行代码位置不同。</p>
<p>第三点：代码执行时通过代码前段的少量位置无关码将整个代码搬移到 0xd0024000。</p>
<p>第四点：使用一个长跳转跳转到 0xd0024000 处的代码继续执行，重定位完成。</p>
<p><strong>长跳转</strong>：一种跳转指令，类似于分支指令 B，BL 等作用的指令，跳转指令通过给 PC（r15）赋一个新值来完成代码跳转。当我们执行完重定位后，<strong>实际上 SRAM 中有两份代码的镜像</strong>（一份是我们下载到 0xd0020010 处的，一份是重定位到 0xd0024000 处的），这两份代码内容完全相同。</p>
<p><strong>短跳转</strong>：短跳转指令可以实现向前或向后 32MB 的地址空间跳转。</p>
<p>当链接地址和运行地址相同是，短跳转和长跳转实际效果一样。但是当链接地址和运行地址不同时，短跳转和长跳转就有差异了，这时候段跳转执行的是运行地址处的那一份，而长跳转执行的是链接地址的那一份。</p>
<p>重定位实际就是在运行地址处执行一段位置无关码 PIC，让这段 PIC（也就是重定位代码）从运行地址处把整个程序镜像拷贝一份到链接地址处，完了之后使用一句长跳转指令从运行地址处直接跳转到链接地址处去执行同一个函数（led_blink），这样就实现了重定位之后的无缝连接。</p>
<p>汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs lds">/*<br> * 文件名：    led.s    <br> * 作者：    朱老师（朱友鹏）<br> * 描述：    演示重定位（在SRAM内部重定位）<br> */<br><br>#define WTCON        0xE2700000<br><br>#define SVC_STACK    0xd0037d80<br><br>.global _start                    // 把_start链接属性改为外部，这样其他文件就可以看见_start了<br>_start:<br>    // 第1步：关看门狗（向WTCON的bit5写入0即可）<br>    ldr r0, =WTCON<br>    ldr r1, =0x0<br>    str r1, [r0]<br>    <br>    // 第2步：设置SVC栈<br>    ldr sp, =SVC_STACK<br>    <br>    // 第3步：开/关icache<br>    mrc p15,0,r0,c1,c0,0;            // 读出cp15的c1到r0中<br>    //bic r0, r0, #(1&lt;&lt;12)            // bit12 置0  关icache<br>    orr r0, r0, #(1&lt;&lt;12)            // bit12 置1  开icache<br>    mcr p15,0,r0,c1,c0,0;<br>    <br>    // 第4步：重定位<br>    adr r0, _start          // adr加载时就叫短加载，此处adr指令用于加载_start当前运行地址，详解见正文    <br>    ldr r1, =_start         // ldr加载时如果目标寄存器是pc就叫长跳转，如果目标寄存器是r1等就叫长加载    <br>                            // 此处ldr指令用于加载_start的链接地址:0xd0024000<br><br>    // bss段的起始地址<br>    ldr r2, =bss_start    // 就是我们重定位代码的结束地址，重定位只需重定位代码段和数据段即可<br>                        // 该符号在链接脚本里定义<br>    cmp r0, r1            // 比较_start的运行时地址和链接地址是否相等<br>    beq clean_bss        // 如果相等说明不需要重定位，所以跳过copy_loop，直接到clean_bss<br>                        // 如果不相等说明需要重定位，那么会顺序执行下面的copy_loop进行重定位<br>                        // 重定位完成后继续执行clean_bss。<br><br>// 用汇编来实现的一个while循环<br>copy_loop:<br>    ldr r3, [r0], #4    // 源   r0内容写入r3，然后r0自增4<br>    str r3, [r1], #4    // 目的 r3内容写入r1，然后r1自增4<br>                        // 这两句代码就完成了4个字节内容的拷贝<br>    cmp r1, r2            // r1和r2都是用ldr加载的，都是链接地址，所以r1不断+4总能等于r2<br>    bne copy_loop<br><br>// 清bss段，其实就是在链接地址处把bss段全部清零<br>clean_bss:<br>    ldr r0, =bss_start                    <br>    ldr r1, =bss_end<br>    cmp r0, r1                // 如果r0等于r1，说明bss段为空，直接继续执行下面的代码<br>    beq run_on_dram            // 清除bss完之后的地址<br>    mov r2, #0<br><br>clear_loop:<br>    str r2, [r0], #4        // 先将r2中的值放入r0所指向的内存地址（r0中的值作为内存地址），<br>    cmp r0, r1                // 然后r0 = r0 + 4<br>    bne clear_loop<br><br>//    清理完bss段后重定位就结束了。然后当前的状况是：<br>//    1、当前运行地址还在0xd0020010开头的（重定位前的）那一份代码中运行着。<br>//    2、此时SRAM中已经有了2份代码，1份在d0020010开头，另一份在d0024000开头的位置。<br>//    然后就要长跳转了。<br><br>run_on_dram:    <br>    // 长跳转到led_blink开始第二阶段<br>    ldr pc, =led_blink                // ldr指令实现长跳转，把led_blink的值，写入pc寄存器<br>    <br>    // 从这里之后就可以开始调用C程序了<br>    //bl led_blink                    // bl指令实现短跳转<br>    <br>    // 汇编最后的这个死循环不能丢<br>    b .<br>    <br></code></pre></td></tr></table></figure>

<p><code>adr</code>与 ldr 伪指令的区别：<code>ldr</code>和<code>adr</code>都是伪指令</p>
<ul>
<li><code>adr</code>短加载，指令加载符号地址，加载的是运行时地址；</li>
<li><code>ldr</code>长加载，指令在加载符号地址时，加载的是链接地址；</li>
</ul>
<p>重定位就是汇编代码中的<code>copy_loop</code>函数，代码的作用是使用循环结构来逐句复制代码到链接地址。<br>复制的源地址是 SRAM 的<code>0xd0020010</code>，复制目标地址是 SRAM 的<code>0xd0024000</code>，复制长度是<code>bss_start</code>减去<code>_start</code>，所以复制的长度就是整个重定位需要重定位的长度，也就是整个程序中代码段 + 数据段的长度。<code>bss</code>段（bss 段中就是 0 初始化的全局变量）不需要重定位。</p>
<p>清除<code>bss</code>段是为了满足 C 语言的运行时要求（C 语言要求显式初始化为 0 的全局变量，或者未显式初始化的全局变量的值为 0，实际上 C 语言编译器就是通过清<code>bss</code>段来实现 C 语言的这个特性的）。一般情况下我们的程序是不需要负责清零<code>bss</code>段的（C 语言编译器和链接器会帮我们的程序自动添加一段头程序，这段程序会在我们的 main 函数之前运行，这段代码就负责清除<code>bss</code>）。但是在我们代码重定位了之后，因为编译器帮我们附加的代码只是帮我们清除了运行地址那一份代码中的<code>bss</code>，而未清除重定位地址处开头的那一份代码的<code>bss</code>，所以重定位之后需要自己去清除<code>bss</code>。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E4%B8%8EIO%E7%B3%BB%E7%BB%9F/" itemprop="url">计算机组成原理-存储与 IO 系统</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-08T02:48:23.000Z" itemprop="datePublished">5月 8 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 读完 (约 8262 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><h4 id="SRAM（Static-Random-Access-Memory，静态随机存取存储器）"><a href="#SRAM（Static-Random-Access-Memory，静态随机存取存储器）" class="headerlink" title="SRAM（Static Random-Access Memory，静态随机存取存储器）"></a>SRAM（Static Random-Access Memory，静态随机存取存储器）</h4><p>CPU 如果形容成人的大脑的话，那么 CPU Cache (高速缓存) 就好比人的记忆。它用的是 SRAM 芯片。</p>
<p>SRAM 的“静态”的意思是，只要处于通电状态，里面的数据就保持存在，一旦断电，数据就会丢失。SRAM 里 1bit 数据需要 6-8 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间，能够存的数据有限。因为其电路简单，访问速度非常快。</p>
<p>在 CPU 里，通常会有 L1、L2、L3 这样三层高速缓存。每个 CPU 核心都有一块属于自己的 L1 高速缓存，通常分成指令缓存和数据缓存，分开存放 CPU 使用的指令和数据。</p>
<p>L2 的 Cache 同样是每个 CPU 核心都有的，不过它往往不在 CPU 核心的内部。所以，L2 Cache 的访问速度会比 L1 稍微慢一些。而 L3Cache，则通常是多个 CPU 核心共用的，尺寸会更大一些，访问速度自然也就更慢一些。</p>
<p>你可以把 CPU 中的 L1Cache 理解为我们的短期记忆，把 L2/L3Cache 理解成长期记忆，把内存当成我们拥有的书架或者书桌。当我们自己记忆中没有资料的时候，可以从书桌或者书架上拿书来翻阅。这个过程中就相当于，数据从内存中加载到 CPU 的寄存器和 Cache 中，然后通过“大脑”，也就是 CPU，进行处理和运算。</p>
<h4 id="DRAM（Dynamic-Random-Access-Memory，动态随机存取存储器）"><a href="#DRAM（Dynamic-Random-Access-Memory，动态随机存取存储器）" class="headerlink" title="DRAM（Dynamic Random Access Memory，动态随机存取存储器）"></a>DRAM（Dynamic Random Access Memory，动态随机存取存储器）</h4><p>内存用的芯片和 Cache 有所不同，它用的是一种叫作 DRAM 的芯片，比起 SRAM 来说，它的密度更高，有更大的容量，而且它也比 SRAM 芯片便宜不少。</p>
<p>DRAM 被称为“动态”存储器，是因为 DRAM 需要靠不断地“刷新”，才能保持数据被存储起来。DRAM 的一个比特，只需要一个晶体管和一个电容就能存储。所以，DRAM 在同样的物理空间下，能够存储的数据也就更多，也就是存储的“密度”更大。但是，因为数据是存储在电容里的，电容会不断漏电，所以需要定时刷新充电，才能保持数据不丢失。DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问延时也就更长。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081652018.png"></p>
<p>从 Cache、内存，到 SSD 和 HDD 硬盘，一台现代计算机中，就用上了所有这些存储器设备。其中，容量越小的设备速度越快，而且，CPU 并不是直接和每一种存储器设备打交道，而是每一种存储器设备，只和它相邻的存储设备打交道。比如，CPUCache 是从内存里加载而来的，或者需要写回内存，并不会直接写回数据到硬盘，也不会直接从硬盘加载数据到 CPUCache 中，而是先加载到内存，再从内存加载到 Cache 中。</p>
<p>这样，各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降，也就构成了我们日常所说的存储器层次结构。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="CPU-cache"><a href="#CPU-cache" class="headerlink" title="CPU cache"></a>CPU cache</h3><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>缓存不是 CPU 的专属功能，可以把它当成一种策略，任何时候想要增加数据传输性能，都可以通过加一层缓存试试。</p>
<p>存储器层次结构的中心思想是，对于每个$k$，位于$k$层的更快更小的存储设备作为位于$k+1$层的更大更慢的存储设备的缓存。<a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86">下图</a>展示了存储器层次结构中缓存的一般性概念。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711145943.png"></p>
<div id="存储器层次结构中基本的缓存原理"></div>

<p>数据总是以块<code>block</code>为单位，在层与层之间来回复制。</p>
<p>说回高速缓存，按照摩尔定律，CPU 的访问速度每 18 个月便会翻一翻，相当于每年增长 60%。内存的访问速度虽然不断增长，却远没有那么快，每年只增长 7% 左右。这样就导致 CPU 性能和内存访问的差距不断拉大。为了弥补两者之间差异，现代 CPU 引入了<strong>高速缓存</strong>。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220708092012.png"></p>
<p>CPU 的读（load）实质上就是从缓存中读取数据到寄存器（register）里，在多级缓存的架构中，如果缓存中找不到数据（Cache miss），就会层层读取二级缓存三级缓存，一旦所有的缓存里都找不到对应的数据，就要去内存里寻址了。寻址到的数据首先放到寄存器里，其副本会驻留到 CPU 的缓存中。</p>
<p>CPU 的写（store）也是针对缓存作写入。并不会直接和内存打交道，而是通过某种机制实现数据从缓存到内存的写回（write back）。</p>
<p>缓存到底如何与 CPU 和主存数据交换的？CPU 如何从缓存中读写数据的？缓存中没有读的数据，或者缓存写满了怎么办？我们先从 CPU 如何读取数据说起。</p>
<h4 id="缓存读取"><a href="#缓存读取" class="headerlink" title="缓存读取"></a>缓存读取</h4><p>CPU 发起一个读取请求后，返回的结果会有如下几种情况：</p>
<ul>
<li>缓存命中 (cache hit)<br>要读取的数据刚好在缓存中，叫做<strong>缓存命中</strong>。</li>
<li>缓存不命中 (cache miss)<br>发送缓存不命中，缓存就得执行一直<strong>放置策略</strong>(placement policy)，比如 LRU。来决定从主存中取出的数据放到哪里。<ul>
<li><strong>强制性不命中</strong>(compulsory miss)/冷不命中(cold miss)：缓存中没有要读取的数据，需要从主存读取数据，并将数据放入缓存。</li>
<li><strong>冲突不命中</strong>(conflict miss)：缓存中有要读的数据，在采取放置策略时，从主存中取数据放到缓存时发生了冲突，这叫做冲突不命中。</li>
</ul>
</li>
</ul>
<h4 id="高速缓存存储器组织结构"><a href="#高速缓存存储器组织结构" class="headerlink" title="高速缓存存储器组织结构"></a>高速缓存存储器组织结构</h4><p>整个 Cache 被划分为 1 个或多个<strong>组</strong> (Set)，$S$ 表示组的个数。每个组包含 1 个或多个<strong>缓存行</strong>(Cache line)，$E$ 表示一个组中缓存行的行数。每个缓存行由三部分组成：<strong>有效位</strong>(valid)，<strong>标记位</strong>（tag），<strong>数据块</strong>（cache block）。</p>
<ul>
<li>有效位：该位等于 1，表示这个行数据有效。</li>
<li>标记位：唯一的标识了存储在高速缓存中的块，标识目标数据是否存在当前的缓存行中。</li>
<li>数据块：一部分内存数据的副本。</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711171136.png"></p>
<p>Cache 的结构可以由元组$(S,E,B,m)$表示。不包括有效位和标记位。Cache 的大小为 $C=S \times E \times B$.</p>
<p>接下来看看 Cache 是如何工作的，当 CPU 执行数据加载指令，从内存地址 A 读取数据时，根据存储器层次原理，如果 Cache 中保存着目标数据的副本，那么就立即将数据返回给 CPU。那么 Cache 如何知道自己保存了目标数据的副本呢？</p>
<p>假设目标地址的数据长度为$m$位，这个地址被参数 $S$ 和 $B$ 分成了三个字段：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711174416.png"></p>
<p>首先通过长度为$s$的<strong>组索引</strong>，确定目标数据保存在哪一个组 (Set) 中，其次通过长度为$t$的<strong>标记</strong>，确定在哪一行，需要注意的是此时有效位必须等于 1，最后根据长度为$b$的<strong>块偏移</strong>，来确定目标数据在数据块中的确切位置。</p>
<blockquote>
<p>Q：既然读取 Cache 第一步是组选择，为什么不用高位作为组索引，而使用中间的为作为组索引？<br>A：如果使用了高位作索引，那么一些连续的内存块就会映射到相同的高速缓存块。如图前四个块映射到第一个缓存组，第二个四个块映射到第二个组，依次类推。如果一个程序有良好的空间局部性，顺序扫描一个数组的元素，那么在任何时候，缓存中都只保存在一个块大小的数组内容。这样对缓存的使用率很低。相比而言，如果使用中间的位作为组索引，那么相邻的块总是映射到不同的组，图中的情况能够存放整个大小的数组片。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711185819.png"></p>
</blockquote>
<h5 id="直接映射高速缓存-Direct-Mapped-Cache"><a href="#直接映射高速缓存-Direct-Mapped-Cache" class="headerlink" title="直接映射高速缓存 Direct Mapped Cache"></a>直接映射高速缓存 Direct Mapped Cache</h5><p>根据每个组的缓存行数 $E$ 的不同，Cache 被分为不同的类。每个组只有一行$E=1$的高速缓存被称为<strong>直接映射高速缓存</strong>(direct-mapped cache)。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711190845.png"></p>
<p>当一条加载指令指示 CPU 从主存地址 A 中读取一个字 w 时，会将该主存地址 A 发送到高速缓存中，则高速缓存会根据<strong>组选择</strong>，<strong>行匹配</strong>和<strong>字抽取</strong>三步来判断地址 A 是否命中。</p>
<p><strong>组选择</strong>(set selection)：根据组索引值来确定属于哪一个组，如图中索引长度为 5 位，可以检索 32 个组 ($2^5=32$)。当$s=0$时，此时组选择的结果为<code>set 0</code>，当$s=1$时，此时组选择的结果为<code>set 1</code>。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711191708.png"></p>
<p>**行匹配 (line match)**：首先看缓存行的有效位，此时有效位为 1，表示当前数据有效。然后对比缓存行的标记<code>0110</code>与地址中的标记<code>0110</code>是否相等，如果相等，则表示目标数据在当前的缓存行中（缓存命中）。如果不一致或者有效位为 0，则表示目标数据不在当前的缓存行中（缓存不命中）。如果命中，就可以进行下一步字抽取。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711192435.png"></p>
<p>**字抽取 (word extraction)**：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于<code>100</code>时，表示目标数据起始地址位于字节 4 处。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711192757.png"></p>
<p>下面通过一个例子来解释清除这个过程。假设我们有一个直接映射高速缓存，描述为$(S,E,B,m) = (4,1,2,4)$。换句话说，高速缓存有 4 个组，每个组 1 行，每个数据块 2 个字节，地址长度为 4 位。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711194256.png"></p>
<p>从图中可以看出，8 个内存块，但只有 4 个高速缓存组，所以会有多个块映射到同一个高速缓存组中。例如，块 0 和块 4 都会被映射到组 0。</p>
<p>下面我们来模拟当 CPU 执行一系列读的时候，高速缓存的执行情况，我们假设每次 CPU 读 1 个字节的字。</p>
<p><strong>读地址 0(0000) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711193901.gif"></p>
<p><strong>读地址 1(0001) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711194838.gif"></p>
<p><strong>读地址 13(1101) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711195108.gif"></p>
<p><strong>读地址 8(1000) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711200054.gif"></p>
<p><strong>读地址 0(0000) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711200409.gif"></p>
<h5 id="组相联高速缓存-Set-Associative-Cache"><a href="#组相联高速缓存-Set-Associative-Cache" class="headerlink" title="组相联高速缓存 Set Associative Cache"></a>组相联高速缓存 Set Associative Cache</h5><p>由于直接映射高速缓存的组中只有一行，所以容易发生冲突不命中。组相联高速缓存 (Set associative cache) 运行有多行缓存行。但是缓存行最大不能超过 $C/B$。</p>
<p>如图一个组中包含了两行缓存行，这种我们称为 2 路相联高速缓存。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220712160513.png"></p>
<p><strong>组选择</strong>：与直接映射高速缓存的组选择过程一样。</p>
<p><strong>行匹配</strong>：因为一个组有多行，所以需要遍历所有行，找到一个有效位为 1，并且标记为与地址中的标记位相匹配的一行。如果找到了，表示缓存命中。</p>
<p><strong>字抽取</strong>：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于<code>100</code>时，表示目标数据起始地址位于字节 4 处。</p>
<p>如果不命中，那么就需要从主存中取出需要的数据块，但是将数据块放在哪一行缓存行呢？如果存在空行 ($valid=0$)，那就放到空行里。如果没有空行，就得选择一个非空行来替换，同时希望 CPU 不会很快引用这个被替换的行。这里介绍几个替换策略。</p>
<p>最简单的方式就是随机选择一行来替换，其他复杂的方式就是利用局部性原理，使得接下来 CPU 引用替换的行概率最小。如</p>
<h3 id="缓存一致性协议-MESI"><a href="#缓存一致性协议-MESI" class="headerlink" title="缓存一致性协议 MESI"></a>缓存一致性协议 MESI</h3><h4 id="为什么需要缓存一致"><a href="#为什么需要缓存一致" class="headerlink" title="为什么需要缓存一致"></a>为什么需要缓存一致</h4><p>目前主流电脑的 CPU 都是多核心的，多核心的有点就是在不能提升 CPU 主频后，通过增加核心来提升 CPU 吞吐量。每个核心都有自己的 L1 Cache 和 L2 Cache，只是共用 L3 Cache 和主内存。每个核心操作是独立的，每个核心的 Cache 就不是同步更新的，这样就会带来缓存一致性（Cache Coherence）的问题。</p>
<p>举个例子，如图：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205291536919.gif"></p>
<p>有 2 个 CPU，主内存里有个变量<code>x=0</code>。CPU A 中有个需要将变量<code>x</code>加<code>1</code>。CPU A 就将变量<code>x</code>加载到自己的缓存中，然后将变量<code>x</code>加<code>1</code>。因为此时 CPU A 还未将缓存数据写回主内存，CPU B 再读取变量<code>x</code>时，变量<code>x</code>的值依然是<code>0</code>。</p>
<p>这里的问题就是所谓的缓存一致性问题，因为 CPU A 的缓存与 CPU B 的缓存是不一致的。</p>
<h4 id="如何解决缓存一致性问题"><a href="#如何解决缓存一致性问题" class="headerlink" title="如何解决缓存一致性问题"></a>如何解决缓存一致性问题</h4><h5 id="通过在总线加-LOCK-锁的方式"><a href="#通过在总线加-LOCK-锁的方式" class="headerlink" title="通过在总线加 LOCK 锁的方式"></a>通过在总线加 LOCK 锁的方式</h5><p>在锁住总线上加一个 LOCK 标识，CPU A 进行读写操作时，锁住总线，其他 CPU 此时无法进行内存读写操作，只有等解锁了才能进行操作。</p>
<p>该方式因为锁住了整个总线，所以效率低。</p>
<h5 id="缓存一致性协议-MESI-1"><a href="#缓存一致性协议-MESI-1" class="headerlink" title="缓存一致性协议 MESI"></a>缓存一致性协议 MESI</h5><p>该方式对单个缓存行的数据进行加锁，不会影响到内存其他数据的读写。</p>
<p>在学习 MESI 协议之前，简单了解一下总线嗅探机制（Bus Snooping）。要对自己的缓存加锁，需要通知其他 CPU，多个 CPU 核心之间的数据传播问题。最常见的一种解决方案就是总线嗅探。</p>
<p>这个策略，本质上就是把所有的读写请求都通过总线广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。MESI 就是基于总线嗅探机制的缓存一致性协议。</p>
<p>MESI 协议的由来是对 Cache Line 的四个不同的标记，分别是：</p>
<table>
<thead>
<tr>
<th align="center"><div style="width:50px">状态</div></th>
<th align="center"><div style="width:100px">状态</div></th>
<th><div style="width:200px">描述</div></th>
<th><div style="width:200px">监听任务</div></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Modified</td>
<td align="center">已修改</td>
<td>该 Cache Line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中</td>
<td>Cache Line 必须时刻监听所有试图读该 Cache Line 相对于主存的操作，这种操作必须在缓存将该 Cache Line 写回主存并将状态改为 S 状态之前，被延迟执行</td>
</tr>
<tr>
<td align="center">Exclusive</td>
<td align="center">独享，互斥</td>
<td>该 Cache Line 有效，数据和内存中的数据一直，数据只存在于本 Cache</td>
<td>Cache Line 必须监听其他缓存读主存中该 Cache Line 的操作，一旦有这种操作，该 Cache Line 需要改为 S 状态</td>
</tr>
<tr>
<td align="center">Shared</td>
<td align="center">共享的</td>
<td>该 Cache Line 有效，数据和内存中的数据一直，数据存在于很多个 Cache 中</td>
<td>Cache Line 必须监听其他  Cache Line 使该 Cache Line 无效或者独享该 Cache Line 的请求，并将 Cache Line 改为 I 状态</td>
</tr>
<tr>
<td align="center">Invalid</td>
<td align="center">无效的</td>
<td>该 Cache Line 无效</td>
<td>无</td>
</tr>
</tbody></table>
<p>整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把各个状态之间的流转用表格总结了一下：</p>
<table>
<thead>
<tr>
<th align="center"><div style="width:80px">当前状态</div></th>
<th align="center"><div style="width:80px">事件</div></th>
<th><div style="width:300px,center">行为</div></th>
<th align="center"><div style="width:80px">下个状态</div></th>
</tr>
</thead>
<tbody><tr>
<td align="center">M</td>
<td align="center">Local Read</td>
<td>从 Cache 中读，状态不变</td>
<td align="center">M</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">Local Write</td>
<td>修改 cache 数据，状态不变</td>
<td align="center">M</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">Remote Read</td>
<td>这行数据被写到内存中，使其他核能使用到最新数据，状态变为 S</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">Remote Write</td>
<td>这行数据被写入内存中，其他核可以获取到最新数据，由于其他 CPU 修改该条数据，则本地 Cache 变为 I</td>
<td align="center">I</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><div style="width:80px">当前状态</div></th>
<th align="center"><div style="width:80px">事件</div></th>
<th><div style="width:200px,center">行为</div></th>
<th align="center"><div style="width:80px">下个状态</div></th>
</tr>
</thead>
<tbody><tr>
<td align="center">E</td>
<td align="center">Local Read</td>
<td>从 Cache 中读，状态不变</td>
<td align="center">E</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">Local Write</td>
<td>修改数据，状态改为 M</td>
<td align="center">M</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">Remote Read</td>
<td>数据和其他 CPU 共享，变为 S</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">Remote Write</td>
<td>数据被修改，本地缓存失效，变为 I</td>
<td align="center">I</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><div style="width:80px">当前状态</div></th>
<th align="center"><div style="width:80px">事件</div></th>
<th><div style="width:200px,text-align: center">行为</div></th>
<th align="center"><div style="width:80px">下个状态</div></th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">Local Read</td>
<td>从 Cache 中读，状态不变</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">Local Write</td>
<td>修改数据，状态改为 M，其他 CPU 的 Cache Line 状态改为 I</td>
<td align="center">M</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">Remote Read</td>
<td>数据和其他 CPU 共享，状态不变</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">Remote Write</td>
<td>数据被修改，本地缓存失效，变为 I</td>
<td align="center">I</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><div style="width:80px">当前状态</div></th>
<th align="center"><div style="width:80px">事件</div></th>
<th><div style="width:200px,center">行为</div></th>
<th align="center"><div style="width:80px">下个状态</div></th>
</tr>
</thead>
<tbody><tr>
<td align="center">I</td>
<td align="center">Local Read</td>
<td>1. 如果其他 CPU 没有这份数据，直接从内存中加载数据，状态变为 E；<br> 2. 如果其他 CPU 有这个数据，且 Cache Line 状态为 M，则先把 Cache Line 中的内容写回到主存。本地 Cache 再从内存中读取数据，这时两个 Cache Line 的状态都变为 S；<br>3. 如果其他 Cache Line 有这份数据，并且状态为 S 或者 E，则本地 Cache Line 从主存读取数据，并将这些 Cache Line 状态改为 S</td>
<td align="center">E 或者 S</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">Local Write</td>
<td>1. 先从内存中读取数据，如果其他 Cache Line 中有这份数据，且状态为 M，则现将数据更新到主存再读取，将 Cache Line 状态改为 M；<br> 2. 如果其他 Cache Line 有这份数据，且状态为 E 或者 S，则其他 Cache Line 状态改为 I</td>
<td align="center">M</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">Remote Read</td>
<td>数据和其他 CPU 共享，状态不变</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">Remote Write</td>
<td>数据被修改，本地缓存失效，变为 I</td>
<td align="center">I</td>
</tr>
</tbody></table>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>计算机有五大组成部分，分别是：运算器、控制器、存储器、输入设备和输出设备。而内存就是其中的存储器。我们的数据和指令都需要先放到内存中，然后再被 CPU 执行。</p>
<p>操作系统中程序并不能直接访问物理内存，我们的内存需要被分成固定大小的页（Page），然后再通过<strong>虚拟内存地址（Virtual Address）到物理内存地址（Physical Address）的地址转换（Address Translation）</strong>，才能到达实际存放数据的物理内存位置。而我们的程序看到的内存地址，都是虚拟内存地址。那么如何进行转换的呢？</p>
<h3 id="简单页表"><a href="#简单页表" class="headerlink" title="简单页表"></a>简单页表</h3><p>最简单的方式，就是建立一张虚拟内存到物理内存的映射表，在计算机里叫做页表（Page Table）。页表这个地址转换的办法，会把一个内存地址分成页号（Directory）和偏移量（Offset）两个部分，是不是似曾相识，因为在前面的高速缓存里，缓存的结构也是这样的。</p>
<p>以一个 32 位地址举例，高 20 位是虚拟页号，可以从虚拟页表中找到物理页号的信息，低 12 位是偏移量，可以准确获得物理地址。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207161640968.png"></p>
<p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li>把虚拟内存地址，切分成页号和偏移量的组合；</li>
<li>从页表里面，查询出虚拟页号，对应的物理页号；</li>
<li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207161645714.png"></p>
<p>但是这样的页表有个问题，它需要记录$2^{20}$个物理页表，这个存储关系，就好比一个 $2^{20}$大小的数组。一个页号是完整的 32 位的 4 字节（Byte），这样一个页表就需要 4MB 的空间。并且每个进程都会有这样一个页表，现代电脑正常都有成百上千个进程，如果用这样的页表肯定行不通的。</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>所以，<strong>在一个实际的程序进程里面，虚拟内存占用的地址空间，通常是两段连续的空间。而不是完全散落的随机的内存地址</strong>。而多级页表，就特别适合这样的内存地址分布。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357648933">谈一谈内存管理，虚拟内存，多级页表 - 知乎</a></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><h3 id="内存保护-可执行空间保护"><a href="#内存保护-可执行空间保护" class="headerlink" title="内存保护 - 可执行空间保护"></a>内存保护 - 可执行空间保护</h3><h3 id="内存保护-地址空间布局随机化"><a href="#内存保护-地址空间布局随机化" class="headerlink" title="内存保护 - 地址空间布局随机化"></a>内存保护 - 地址空间布局随机化</h3><p>Address Space Layout Randomization</p>
<h2 id="总线：计算机内部的高速公路"><a href="#总线：计算机内部的高速公路" class="headerlink" title="总线：计算机内部的高速公路"></a>总线：计算机内部的高速公路</h2><p>计算机由控制器、运算器、存储器、输入设备以及输出设备五大部分组成。CPU 所代表的控制器和运算器，要和存储器，也就是我们的主内存，以及输入和输出设备进行通信。那么计算机是用什么样的方式来完成，CPU 和内存、以及外部输入输出设备的通信呢？答案就是通过总线来通信。</p>
<p>计算机里有不同的硬件设备，如果设备与设备之间都单独连接，那么就需要 N*N 的连线。那么怎么降低复杂度呢？与其让各个设备之间互相单独通信，不如我们去设计一个公用的线路。CPU 想要和什么设备通信，通信的指令是什么，对应的数据是什么，都发送到这个线路上；设备要向 CPU 发送什么信息呢，也发送到这个线路上。这个线路就好像一个高速公路，各个设备和其他设备之间，不需要单独建公路，只建一条小路通向这条高速公路就好了。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081510203.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081510711.png"></p>
<h3 id="三种线路和多总线架构"><a href="#三种线路和多总线架构" class="headerlink" title="三种线路和多总线架构"></a>三种线路和多总线架构</h3><p>首先，CPU 和内存以及高速缓存通信的总线，这里面通常有两种总线。这种方式，我们称之为双独立总线（Dual Independent Bus，缩写为 DIB）。CPU 里，有一个快速的本地总线（Local Bus），以及一个速度相对较慢的前端总线（Front-side Bus）。</p>
<p>现代的 CPU 里，通常有专门的高速缓存芯片。这里的高速本地总线，就是用来和高速缓存通信的。而前端总线，则是用来和主内存以及输入输出设备通信的。有时候，我们会把本地总线也叫作后端总线（Back-sideBus），和前面的前端总线对应起来。</p>
<p>除了前端总线呢，我们常常还会听到 PCI 总线、I/O 总线或者系统总线（System Bus）。看到这么多总线的名字，你是不是已经有点晕了。这些名词确实容易混为一谈。其实各种总线的命名一直都很混乱，我们不如直接来看一看 CPU 的硬件架构图。对照图来看，一切问题就都清楚了。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081513938.png"></p>
<p>CPU 里面的北桥芯片，把我们上面说的前端总线，一分为二，变成了三个总线。我们的前端总线，其实就是系统总线。CPU 里面的内存接口，直接和系统总线通信，然后系统总线再接入一个 I/O 桥接器（I/OBridge）。这个 I/O 桥接器，一边接入了我们的内存总线，使得我们的 CPU 和内存通信；另一边呢，又接入了一个 I/O 总线，用来连接 I/O 设备。</p>
<p>事实上，真实的计算机里，这个总线层面拆分得更细。根据不同的设备，还会分成独立的 PCI 总线、ISA 总线等等。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081516341.png"></p>
<p>在物理层面，其实我们完全可以把总线看作一组“电线”。不过呢，这些电线之间也是有分工的，我们通常有三类线路。</p>
<ol>
<li>数据线（Data Bus），用来传输实际的数据信息，也就是实际上了公交车的“人”。</li>
<li>地址线（Address Bus），用来确定到底把数据传输到哪里去，是内存的某个位置，还是某一个 I/O 设备。这个其实就相当于拿了个纸条，写下了上面的人要下车的站点。</li>
<li>控制线（ControlBus），用来控制对于总线的访问。虽然我们把总线比喻成了一辆公交车。那么有人想要做公交车的时候，需要告诉公交车司机，这个就是我们的控制信号。</li>
</ol>
<p>尽管总线减少了设备之间的耦合，也降低了系统设计的复杂度，但同时也带来了一个新问题，那就是<strong>总线不能同时给多个设备提供通信功能</strong>。</p>
<p>我们的总线是很多个设备公用的，那多个设备都想要用总线，我们就需要有一个机制，去决定这种情况下，到底把总线给哪一个设备用。这个机制，就叫作<strong>总线裁决</strong>（Bus Arbitraction）</p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>过去几年，计算机产业一直在为提升 I/O 设备的速度而努力，从机械硬盘 HDD 到固态硬盘 SSD，从 SATA 协议到 PCIE 协议，虽然速度都几十上百倍的增加，但是仍然不够快。因为相比于 CPU 基本都是 2GHz 的频率（每秒会有 20 亿次的操作），SSD 硬盘的 IOPS 的 2 万次操作就显得微不足道。</p>
<p>如果我们对于 I/O 的操作，都是由 CPU 发出对应的指令，然后等待 I/O 设备完成操作之后返回，那 CPU 有大量的时间其实都是在等待 I/O 设备完成操作。特别是当传输的数据量比较大的时候，比如进行大文件复制，如果所有数据都要经过 CPU，实在是有点儿太浪费时间了。</p>
<p>因此，计算机工程师们，就发明了<strong>DMA 技术</strong>，也就是<strong>直接内存访问（Direct Memory Access）技术</strong>，来减少 CPU 等待的时间。</p>
<h3 id="什么是-DMA"><a href="#什么是-DMA" class="headerlink" title="什么是 DMA"></a>什么是 DMA</h3><p>本质上，DMA 技术就是我们在主板上放一块<strong>独立的芯片</strong>。在进行内存和 I/O 设备的数据传输的时候，我们不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器（DMA Controller，简称 DMAC）。这块芯片，我们可以认为它其实就是一个<strong>协处理器</strong>（Co-Processor）。</p>
<p>DMAC 最有价值的地方体现在，当我们要传输的数据特别大、速度特别快，或者传输的数据特别小、速度特别慢的时候。</p>
<p>比如说，我们用千兆网卡或者硬盘传输大量数据的时候，如果都用 CPU 来搬运的话，肯定忙不过来，所以可以选择 DMAC。而当数据传输很慢的时候，DMAC 可以等数据到齐了，再向 CPU 发起中断，让 CPU 去处理，而不是让 CPU 在那里忙等待。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208152252016.png"></p>
<ol>
<li>首先，CPU 还是作为一个主设备，向 DMAC 设备发起请求。这个请求，其实就是在 DMAC 里面修改配置寄存器。</li>
<li>CPU 修改 DMAC 的配置的时候，会告诉 DMAC 这样几个信息：<ul>
<li>源地址的初始值：数据要从哪里传输过来。如果我们要从内存里面写入数据到硬盘上，那么就是要读取的数据在内存里面的地址</li>
<li>传输时候的地址增减方式：数据是从大的地址向小的地址传输，还是从小的地址往大的地址传输</li>
<li>传输的数据长度：也就是我们一共要传输多少数据</li>
</ul>
</li>
<li>设置完这些信息之后，DMAC 就会变成一个空闲的状态（Idle）。</li>
<li>如果我们要从硬盘上往内存里面加载数据，这个时候，硬盘就会向 DMAC 发起一个数据传输请求。这个请求并不是通过总线，而是通过一个额外的连线。</li>
<li>然后，我们的 DMAC 需要再通过一个额外的连线响应这个申请。</li>
<li>DMAC 这个芯片，就向硬盘的接口发起要总线读的传输请求。数据就从硬盘里面，读到了 DMAC 的控制器里面。</li>
<li>DMAC 再向我们的内存发起总线写的数据传输请求，把数据写入到内存里面。</li>
<li>DMAC 会反复进行上面第 6、7 步的操作，直到 DMAC 的寄存器里面设置的数据长度传输完成。</li>
<li>数据传输完成之后，DMAC 重新回到第 3 步的空闲状态。</li>
</ol>
<p>所以，整个数据传输的过程中，我们不是通过 CPU 来搬运数据，而是由 DMAC 这个芯片来搬运数据。但是 CPU 在这个过程中也是必不可少的。因为传输什么数据，从哪里传输到哪里，其实还是由 CPU 来设置的。这也是为什么，DMAC 被叫作 <strong>协处理器</strong>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cJ411K7HW?spm_id_from=333.999.0.0">【硬件科普】电脑主板右下角的散热片下面究竟隐藏着什么？详解主板南桥芯片组的功能和作用_哔哩哔哩_bilibili</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%A4%84%E7%90%86%E5%99%A8/" itemprop="url">计算机组成原理-处理器</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-01T07:42:11.000Z" itemprop="datePublished">5月 1 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            36 分钟 读完 (约 5401 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="建立数据通路：指令-运算-CPU"><a href="#建立数据通路：指令-运算-CPU" class="headerlink" title="建立数据通路：指令 + 运算=CPU"></a>建立数据通路：指令 + 运算=CPU</h2><p>指令周期</p>
<ul>
<li>Fetch（取得指令）：从内存里把指令加载到指令寄存器中。</li>
<li>Decode（指令译码）</li>
<li>Execute（执行指令）<br>重复操作这三步，这个循环称为指令周期。</li>
</ul>
<p>不同的步骤在不同组件内完成<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011556148.png"></p>
<p>机器周期/CPU周期：从内存里读取一条指令的最短时间。<br>时钟周期：就是机器的主频，一个 CPU 周期由多个时钟周期组成。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011607706.png"></p>
<p>操作元件：组合逻辑元件，ALU，功能是在特定的输入下，生成特定的输出。<br>存储元件：状态元件，寄存器。</p>
<p>将操作元件，操作原件通过数据总线的方式连接起来，就<strong>建立了数据通路</strong>了。</p>
<p>控制器：循环执行取址-译码，产生控制信号交给 ALU 处理。电路特别复杂，CPU 如果支持 2000 个指令，意味着控制器输出的信号有 2000 个不同的组合。</p>
<p>CPU 需要的电路</p>
<ul>
<li>根据输入计算出结果的一个电路，ALU</li>
<li>能够进行状态读写的电路元件，寄存器</li>
<li>按照固定周期，不停实现 PC 寄存器自增的电路</li>
<li>译码电路，能够对于拿到的内存地址获取对应的数据或者指令</li>
</ul>
<blockquote>
<p>Q :  CPU 好像一个永不停歇的机器，一直在不停地读取下一条指令去运行。那 为什么 CPU 还会有满载运行和 Idle 闲置的状态呢？<br>A：CPU 还会有满载运行和 Idle 闲置的状态，指的系统层面的状态。即使是 Idle 空闲状态，CPU 也在执行循环指令。<br>操作系统内核有 idle 进程，优先级最低，仅当其他进程都阻塞时被调度器选中。idle 进程循环执行 HLT 指令，关闭 CPU 大部分功能以降低功耗，收到中断信号时 CPU 恢复正常状态。CPU 在空闲状态就会停止执行，即切断时钟信号，CPU 主频会瞬间降低为 0，功耗也会瞬间降为 0。由于这个空闲状态是十分短暂的，所以你在任务管理器也只会看到 CPU 频率下降，不会看到降为 0。当 CPU 从空闲状态中恢复时，就会接通时钟信号，CPU 频率就会上升。所以你会在任务管理器里面看到 CPU 的频率起伏变化。</p>
</blockquote>
<p>实现一个完整的 CPU，除了<strong>组合逻辑电路</strong>，还需要<strong>时序逻辑电路</strong>。因为组合逻辑电路只是处理固定输入，得到固定输出，这种电路只能协助我们完成一些计算工作，干不了太复杂的工作。</p>
<p>时序逻辑电路可以解决这几个问题：</p>
<ul>
<li>自动运行问题<br>  时序电路接通之后可以<strong>不停地开启和关闭开关</strong>，进入一个自动运行的状态。这个使得我们上一讲说的，控制器不停地让 PC 寄存器自增读取下一条指令成为可能。</li>
<li>存储问题<br>  通过时序电路实现的触发器，<strong>能把计算结果存储在特定的电路里面</strong>， 而不是像组合逻辑电路那样，一旦输入有任何改变，对应的输出也会改变。</li>
<li><strong>时序协调问题</strong><br>  无论是程序实现的软件指令，还是到硬件层面，各种指令的操作都有<strong>先后的顺序</strong>要求。时序电路使得不同的事件按照时间顺序发生。</li>
</ul>
<p><strong>解决自动运行问题</strong><br>实现时序逻辑电路的第一步就需要一个时钟。CPU 的主频是一个晶振来实现的，晶振生成的电路信号就是我们的时钟信号。</p>
<p>实现如图所示，我们在原先一般只放一个开关的信号输入端，放上了两个开 关。一个开关 A，一开始是断开的，由我们手工控制；另外一个开关 B，一开始是合上的，<br>磁性线圈对准一开始就合上的开关 B。</p>
<p>于是，一旦我们合上开关 A，磁性线圈就会通电，产生磁性，开关 B 就会从合上变成断 开。一旦这个开关断开了，电路就中断了，磁性线圈就失去了磁性。于是，开关 B 又会弹 回到合上的状态。这样一来，电路接通，线圈又有了磁性。我们的电路就会来回不断地在开<br>启、关闭这两个状态中切换。</p>
<p>这个不断切换的过程，对于下游电路来说，就是不断地产生新的 0 和 1 这样的信号。如果 你在下游的电路上接上一个灯泡，就会发现这个灯泡在亮和暗之间不停切换。这个按照固定的周期不断在 0 和 1 之间切换的信号，就是我们的时钟信号。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011740388.png"></p>
<p>一般这样产生的时钟信号，就像你在各种教科书图例中看到的一样，是一个振荡产生的 0、1 信号。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011745410.png"></p>
<p>这种电路，其实就相当于把电路的输出信号作为输入信号，再回到当前电路。这样的电路构 造方式呢，我们叫作反馈电路（Feedback Circuit）。</p>
<p>上面这个反馈电路一般可以用下面这个示意图来表 示，其实就是一个输出结果接回输入的反相器（Inverter），也就是我们之前讲过的非门。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011746094.png"></p>
<p><strong>解决存储问题</strong></p>
<p>有了时钟信号，我们的系统里就有了一个像“自动门”一样的开关。利用这个开关和相同的 反馈电路，我们就可以构造出一个有“记忆”功能的电路。</p>
<p>我们先来看下面这个 <strong>RS 触发器</strong>电路。这个电路由两个或非门电路组成。我在图里面，把它 标成了 A 和 B。</p>
<p>或非门真值表：<br>|NOR|0| 1|<br>| —- | —- | —- |<br>|0|1|0|<br>|1|0|0|<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011851028.png"></p>
<ol>
<li>在这个电路一开始，输入开关都是关闭的，所以或非门（NOR）A 的输入是 0 和 0。对 应到我列的这个真值表，输出就是 1。而或非门 B 的输入是 0 和 A 的输出 1，对应输出 就是 0。B 的输出 0 反馈到 A，和之前的输入没有变化，A 的输出仍然是 1。而整个电 路的输出 Q，也就是 0。</li>
<li>当我们把 A 前面的开关 R 合上的时候，A 的输入变成了 1 和 0，输出就变成了 0，对应 B 的输入变成 0 和 0，输出就变成了 1。B 的输出 1 反馈给到了 A，A 的输入变成了 1 和 1，输出仍然是 0。所以把 A 的开关合上之后，电路仍然是稳定的，不会像晶振那样 振荡，但是整个电路的输出 Q 变成了 1。</li>
<li>这个时候，如果我们再把 A 前面的开关 R 打开，A 的输入变成和 1 和 0，输出还是 0，对应的 B 的输入没有变化，输出也还是 1。B 的输出 1 反馈给到了 A，A 的输入变成了 1 和 0，输出仍然是 0。这个时候，电路仍然稳定。开关 R 和 S 的状态和上面的第一步是一样的，但是最终的输出 Q 仍然是 1，和第 1 步里 Q 状态是相反的。我们的输入和刚才第二步的开关状态不一样，但是输出结果仍然保留在了第 2 步时的输出没有发生变 化。</li>
<li>这个时候，只有我们再去关闭下面的开关 S，才可以看到，这个时候，B 有一个输入必然是 1，所以 B 的输出必然是 0，也就是电路的最终输出 Q 必然是 0。</li>
</ol>
<p>这样一个电路，我们称之为触发器（Flip-Flop）。接通开关 R，输出变为 1，即使断开开 关，输出还是 1 不变。接通开关 S，输出变为 0，即使断开开关，输出也还是 0。也就是， <strong>当两个开关都断开的时候，最终的输出结果，取决于之前动作的输出结果，这个也就是我们说的记忆功能</strong>。</p>
<h2 id="面向流水线的指令设计"><a href="#面向流水线的指令设计" class="headerlink" title="面向流水线的指令设计"></a>面向流水线的指令设计</h2><h3 id="单指令周期处理器"><a href="#单指令周期处理器" class="headerlink" title="单指令周期处理器"></a>单指令周期处理器</h3><p>一条 CPU 指令的执行，有三步：取得指令，译码，执行。需要一个时钟周期。自然设计指令时，我们也希望一整条指令能在一个时钟周期内完成。这就是单指令周期处理器。</p>
<p>不过，时钟周期是固定的，但是指令的电路复杂程度是不同的，所以实际一条指令执行的时间是不同的。从前面的学习中也知道，随着门电路层数的增加，门延迟的存在，计算复杂的指令需要的时间更长。</p>
<p>不同指令的执行时间不同，但是我们需要让所有指令都在一个时钟周期内完成，那就只好<strong>把执行时间最长的那个指令和时钟周期设成一样</strong>。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205142125165.png"></p>
<p>所以，在单指令周期处理器里面，无论是执行一条用不到 ALU 的无条件跳转指令，还是一条计算起来电路特别复杂的浮点数乘法运算，我们都等要等满一个时钟周期。这样时钟频率就无法提高，因为太高了，有些复杂指令无法在一个时钟周期内运行完。</p>
<p>到这可能就有人发问了，之前不是说一个 CPU 时钟周期，可以认为是完成一条简单指令的时间。为什么单指令周期处理器上，却成了执行一条最复杂的指令的时间？</p>
<p>这是因为，无论是 PC 上使用的 Intel CPU，还是手机上使用的 ARM CPU，都不是单指令周期处理器，而是采用了一种叫作<strong>指令流水线</strong>（Instruction Pipeline）的技术。</p>
<h3 id="流水线设计"><a href="#流水线设计" class="headerlink" title="流水线设计"></a>流水线设计</h3><p>CPU 执行指令的过程和我们做饭一样，我们不会等米饭蒸好再洗菜，不会等肉腌好再切菜，而是蒸饭时，可以洗菜，腌肉时可以切菜。</p>
<p>CPU 的指令执行过程，其实也是由各个电路模块组成的。我们在取指令的时候，需要一个译码器把数据从内存里面取出来，写入到寄存器中；在指令译码的时候，我们需要另外一个译码器，把指令解析成对应的控制信号、内存地址和数据；到了指令执行的时候，我们需要的则是一个完成计算工作的 ALU。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205142142974.png"></p>
<p>这样一来，我们就不用把时钟周期设置成整条指令执行的时间，而是拆分成完成这样的一个一个小步骤需要的时间。同时，每一个阶段的电路在完成对应的任务之后，也不需要等待整个指令执行完成，而是可以直接执行下一条指令的对应阶段。</p>
<p>如果我们把一个指令拆分成“取指令 - 指令译码 - 执行指令”这样三个部分，那这就是一个<strong>三级的流水线</strong>。如果我们进一步把“执行指令”拆分成“ALU 计算（指令执行）- 内存访问 - 数据写回”，那么它就会变成一个<strong>五级的流水线</strong>。</p>
<p>五级的流水线，就表示我们在同一个时钟周期里面，同时运行五条指令的不同阶段。这个时候，虽然<strong>执行一条指令的时钟周期变成了 5</strong>，但是我们可以把 CPU 的主频提得更高了。<strong>我们不需要确保最复杂的那条指令在时钟周期里面执行完成，而只要保障一个最复杂的流水线级的操作，在一个时钟周期内完成就好了</strong>。</p>
<p>如果某一个操作步骤的时间太长，我们就可以考虑把这个步骤，拆分成更多的步骤，让所有步骤需要执行的时间尽量都差不多长。</p>
<p>既然流水线可以增加我们的吞吐率，你可能要问了，为什么我们不把流水线级数做得更深 呢？为什么不做成 20 级，乃至 40 级呢？这个其实有很多原因，我在之后几讲里面会详细讲解。这里，我先讲一个最基本的原因，就是增加流水线深度，其实是有性能成本的。</p>
<p>我们用来同步时钟周期的，不再是指令级别的，而是流水线阶段级别的。每一级流水线对应 的输出，都要放到流水线寄存器（Pipeline Register）里面，然后在下一个时钟周期，交给下一个流水线级去处理。所以，每增加一级的流水线，就要多一级写入到流水线寄存器的操作。虽然流水线寄存器非常快，比如只有 20 皮秒（ps，10−12 秒）。</p>
<p>但是，如果我们不断加深流水线，这些操作占整个指令的执行时间的比例就会不断增加。最后，我们的性能瓶颈就会出现在这些 overhead 上。如果我们指令的执行有 3 纳秒，也就 是 3000 皮秒。我们需要 20 级的流水线，那流水线寄存器的写入就需要花费 400 皮秒，占了超过 10%。如果我们需要 50 级流水线，就要多花费 1 纳秒在流水线寄存器上，占到 25%。这也就意味着，单纯地增加流水线级数，不仅不能提升性能，反而会有更多的 overhead 的开销。所以，设计合理的流水线级数也是现代 CPU 中非常重要的一点。</p>
<h2 id="FPGA-ASIC-TPU"><a href="#FPGA-ASIC-TPU" class="headerlink" title="FPGA/ASIC/TPU"></a>FPGA/ASIC/TPU</h2><h3 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h3><p>CPU 是由简单的门电路搭积木一样搭建出来的，那一个 CPU 里有多少个晶体管这样的电路开关呢？一个四核 i7 的 Intel CPU，有 20 亿个晶体管。那么问题来了，我们要设计一个 CPU，就要想办法连接这 20 亿个晶体管。</p>
<p>连接一次已经很难了，我们还要根据问题重新调整连接。设计更简单的特定功能的芯片，少说要几个月。而设计一个 CPU 往往以年计。在这个过程中，硬件工程师要设计、验证各种各样的方案，可能会遇到各种 BUG。如果每验证一个方案都要生产一块芯片，这代价太高了。</p>
<p>我们有没有什么办法，不用单独制造一块专门的芯片来验证 硬件设计呢？能不能设计一个硬件，通过不同的程序代码，来操作这个硬件之前的电路连线，通过“编程”让这个硬件 变成我们设计的电路连线的芯片呢？</p>
<p>这个，就是我们接下来要说的 <strong>FPGA</strong>，也就是<strong>现场可编程门阵列</strong>（Field-Programmable Gate Array）。</p>
<ul>
<li>P 代表 Programmable，也就是说这 是一个<strong>可以通过编程来控制的硬件</strong>。</li>
<li>G 代表 Gate，它就代表芯片里面的门电路。我们能够去进行编程组合的就是这样一个一个<strong>门电路</strong>。</li>
<li>A 代表的 Array，叫作阵列，说的是在一块 FPGA 上，密密麻麻列了<strong>大量 Gate 这样的门电路</strong>。</li>
<li>F，不太容易理解。它其实是说，一块 FPGA 这样的板子，<strong>可以进行在“现场”多次地进行编程</strong>。它不像 PAL（Programmable Array Logic，可编程阵列逻辑）这样更古老的硬件设备，只能“编程”一次，把预先写好的程序一次性烧录到硬件里面，之后就不能再修改了。</li>
</ul>
<p>我们之前说过，CPU 其实就是通过晶体管，来实现各 种组合逻辑或者时序逻辑。那么，<strong>我们怎么去“编程”连接这些线路呢</strong>？</p>
<p>FPGA 的解决方案分三步：</p>
<p><strong>第一，用存储换功能实现组合逻辑</strong>。在实现 CPU 的功能的时候，我们需要完成各种各样的电路逻辑。在 FPGA 里，这 些基本的电路逻辑，不是采用布线连接的方式进行的，而是 预先根据我们在软件里面设计的逻辑电路，算出对应的真值表，然后直接存到一个叫作 LUT（Look-Up Table，查找 表）的电路里面。这个 LUT 呢，其实就是一块存储空间，里面存储了“特定的输入信号下，对应输出 0 还是 1”。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081009007.png"></p>
<p><strong>第二，对于需要实现的时序逻辑电路，我们可以在 FPGA 里面直接放上 D 触发器，作为寄存器</strong>。这个和 CPU 里的触发器没有什么本质不同。不过，我们会把很多个 LUT 的电路和寄存器组合在一起，变成一个叫作逻辑簇（Logic Cluster）的东西。在 FPGA 里，这样组合了多个 LUT 和寄 存器的设备，也被叫做 CLB Configurable Logic Block，可配置逻辑块）。</p>
<p>可以把 CLB 想象成函数或者 API，设计更复杂的功能，不用重新造轮子，只需要调用函数或者 API 即可。设计芯片也是一样，不用再从门电路开始搭建，可以通过 CLB 组合搭建。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081014661.png"></p>
<p><strong>第三，FPGA 是通过可编程逻辑布线，来连接各个不同的 CLB，最终实现我们想要实现的芯片功能</strong>。这个可编程逻辑布线，你可以把它当成我们的铁路网。整个铁路系统已经铺 好了，但是整个铁路网里面，设计了很多个道岔。我们可以 通过控制道岔，来确定不同的列车线路。在可编程逻辑布线 里面，“编程”在做的，就是拨动像道岔一样的各个电路开 关，最终实现不同 CLB 之间的连接，完成我们想要的芯片<br>功能。</p>
<h3 id="ASIC"><a href="#ASIC" class="headerlink" title="ASIC"></a>ASIC</h3><p>除了 CPU，GPU 以及 FPGA，我们还需要用到很多其他芯片，比如除了音视频的芯片，或者专门用来挖矿的芯片。尽管 CPU 也能实现这些功能，但是有点大炮打蚊子的感觉。</p>
<p>于是针对一些特殊场景，单独设计一个芯片，我们称这些芯片为 ASIC（Application-Specific Integrated Circuit），专用集成电路。设计精简，制造成本低。</p>
<p>其实我们的 FPGA 也能做 ASIC 的事情，每次对 FPGA 进行编程，就是把 FPGA 电路编程了一个 ASIC。但是如果全用 FPGA，同样会浪费。因为每一个 LUT 电路，都可以实现与门以及或门，这比单纯连死的与门或者或门，用到的晶体管数量要多的多。自然功耗也要大得多，单片 FPGA 的生产制造成本也比 ASIC 要高。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">FPAG</th>
<th align="center">ASIC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一次性成本</td>
<td align="center">极低，约等于 0</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">量产成本</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">延迟</td>
<td align="center">低</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">开发周期</td>
<td align="center">短</td>
<td align="center">长</td>
</tr>
<tr>
<td align="center">市场风险</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">开发环境</td>
<td align="center">设置 FPGA 需要硬件知识，编程和配置门槛很高</td>
<td align="center">需要底层硬件变成，开发难度很高</td>
</tr>
</tbody></table>
<h2 id="TPU"><a href="#TPU" class="headerlink" title="TPU"></a>TPU</h2><p>TPU（Tensor Processing Unit）张量处理器；</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/04/09/%E6%9B%BF%E6%8D%A2Gitee%E5%9B%BE%E5%BA%8A%E4%B8%BA%E8%85%BE%E8%AE%AF%E4%BA%91COS/" itemprop="url">替换 Gitee 图床为腾讯云 COS</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-04-09T08:43:08.000Z" itemprop="datePublished">4月 9 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/">工欲善其事必先利其器</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 读完 (约 537 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1964208">Gitee 图床挂了</a>，但是各大云服务厂商提供的对象存储服务免费额度，对于个人小博客来说也够用了。下面介绍如何将图床更换为腾讯云 COS。</p>
<h2 id="下载原有图片"><a href="#下载原有图片" class="headerlink" title="下载原有图片"></a>下载原有图片</h2><p>从<code>gitee</code>下载整个仓库。保持原有目录结构。</p>
<h2 id="配置腾讯云-COS"><a href="#配置腾讯云-COS" class="headerlink" title="配置腾讯云 COS"></a>配置腾讯云 COS</h2><p>注册腾讯云账号，创建 COS 存储桶，选择公有读私有写。创建 COS 存储桶地址：<a target="_blank" rel="noopener" href="https://console.cloud.tencent.com/cos">https://console.cloud.tencent.com/cos</a>，创建存储桶后可以在存储桶里打开防盗链设置。</p>
<p>创建桶–选择地域–填写名称–选择公有读私有写–点击创建。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091731554.png"></p>
<p>如果忘了设置读写权限可以按一下方法设置；<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727355.png"></p>
<p>选择<strong>菜单</strong>–<strong>文件列表</strong>。上传下载好的文件夹（整个仓库的文件夹）。鼠标放到<strong>选择文件</strong>出现<strong>上传文件夹选项</strong>，或者将文件夹<strong>拖入浏览器</strong>。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727353.png"></p>
<h2 id="配置-Picgo"><a href="#配置-Picgo" class="headerlink" title="配置 Picgo"></a>配置 Picgo</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727351.png"></p>
<p><strong>COS 版本</strong>：V5<br><strong>设定 Secreid，设定 Secrekey，设定 APPID：</strong> APPID、SecretID 与 SecretKey <a target="_blank" rel="noopener" href="https://console.cloud.tencent.com/cam/capi">点此直达获取</a>。<br>选择继续使用–创建秘钥。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/202204091715578.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727352.png"></p>
<p><strong>设定存储空间名，设定存储区域：</strong> <a target="_blank" rel="noopener" href="https://console.cloud.tencent.com/cos/bucket">点此获取存储空间名以及存储区域</a>。桶名称即存储空间名，所属区域：<code>ap-shanghai</code>即确认存储区域。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727354.png"></p>
<p><strong>指定存储区域：</strong><br>指定上传到 COS 的目录，比如我原先从<code>gitee</code>下载来的图床的仓库名是<code>markdown_picbed</code>，图片又保存在<code>markdown_picbed/img</code>目录下，那么就指定<code>markdown_picbed/img</code>目录。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091722487.png"></p>
<h2 id="替换旧图床-URL"><a href="#替换旧图床-URL" class="headerlink" title="替换旧图床 URL"></a>替换旧图床 URL</h2><p>VSCode 全局替换：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091753809.png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/03/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url">程序员的自我修养笔记</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-03-30T03:12:31.000Z" itemprop="datePublished">3月 30 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 读完 (约 8804 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。</p>
<h2 id="第三章-目标文件里有什么"><a href="#第三章-目标文件里有什么" class="headerlink" title="第三章 目标文件里有什么"></a>第三章 目标文件里有什么</h2><h3 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h3><p><strong>目标文件</strong>从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。</p>
<p>现在 PC 平台流形的可执行文件格式，主要是 Windows 下的 PE（Portable Executable）和 Linux 下的 ELF（Executable Linkable Format）,它们都是 COFF（Common file format）格式的变种。</p>
<p>指令和数据分开存放的好处：</p>
<ul>
<li><p>一方面当程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被设置成可读写和只读，这样可以防止程序的指令被有意或无意地改写。</p>
</li>
<li><p>另一方面是现代 CPU 有强大的缓存体系，由于缓存很重要，所以程序必须尽量提高缓存命中率。指令区和数据区分离有利于提高程序的局部性。现代 CPU 的缓存一般都被设计成数据缓存和指令缓存，所以程序的指令和数据分开存放对于 CPU 的缓存命中率提高有好处。</p>
</li>
<li><p>第三个原因，也是最重要的原因，就是当系统中运行着多个该进程副本时，他们的指令都是一样的，所以内存中只需要保存一份程序的指令部分。</p>
</li>
</ul>
<p><strong>真正了牛逼的程序员对自己的程序每一个字节都了如指掌。</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">objdump -h  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SimpleSsection</span>.</span></span>o  # 打印elf文件各个段的信息<br>size <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SimpleSsection</span>.</span></span>o           # 查看elf文件各个段的长度<br>objdump -s -d <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SimpleSsection</span>.</span></span>o # -s将所有段内容以十六进制打印，-d将所有包含指令的段反汇编<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>段名称</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>.data</td>
<td>- 初始化的全局变量 <br> - 局部静态变量</td>
</tr>
<tr>
<td>.rodata</td>
<td>只读数据段，对这个段的任何修改都是非法的，保证了程序的安全性。 <br> 有时候编译器会把字符串放到 data 段<br> - 只读变量 const 修饰 <br> - 字符串常量</td>
</tr>
<tr>
<td>.bss</td>
<td>不占磁盘空间， <br>- 未初始化的全局变量 <br> - 未初始化的局部静态变量 <br> - 初始化为 0 的静态变量</td>
</tr>
<tr>
<td>.comment</td>
<td>存放编译器版本信息，比如字符串“GCC：（GNU）4.2.0”</td>
</tr>
<tr>
<td>.line</td>
<td>调试时的行号表，即源代码行号与编译后指令的对应表</td>
</tr>
<tr>
<td>.note</td>
<td>额外的编译器信息，如程序公司名，版本号</td>
</tr>
<tr>
<td>.symtab</td>
<td>Symbol Table 符号表</td>
</tr>
<tr>
<td>.plt</td>
<td>动态链接的跳转表</td>
</tr>
<tr>
<td>.got</td>
<td>动态链接的全局入口表</td>
</tr>
</tbody></table>
<p>段名称都是<code>.</code>前缀，表示这些表名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名称。比如可以加入一个<code>music</code>段，里面存一首 mp3 音乐，运行起来后就会播放音乐，打算自定义段不能使用<code>.</code>作为前缀，以免与系统保留段名冲突。</p>
<blockquote>
<p>Q: 如何将一个二进制文件，如图片，MP3 文件作为目标文件的一个段？<br>A: 可以使用 objcopy 工具，比如有一个图片 image..jpg，大小为 0x2100 字节：<br>$ objcopy -I binary -O elf32-i388 -B  i38 image.jpg image.o</p>
</blockquote>
<p>正常情况下编译出来的目标文件，代码会放到<code>.text</code>段，但是有时候你希望变量或者某些代码能放到你指定的段中去，以实现某些特定的功能。比如为了满足某些硬件的内存和 IO 地址布局。GCC 提供了扩展机制，使得程序员可以指定变量所处的段：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">__attribute__((<span class="hljs-name">section</span>(<span class="hljs-string">&quot;FOO&quot;</span>))) int global = <span class="hljs-number">42</span><span class="hljs-comment">;</span><br>__attribute__((<span class="hljs-name">section</span>(<span class="hljs-string">&quot;BAR&quot;</span>))) void foo<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="ELF-文件结构"><a href="#ELF-文件结构" class="headerlink" title="ELF 文件结构"></a>ELF 文件结构</h3><p>使用<code>readelf</code>命令查看 elf 文件详细信息。</p>
<ul>
<li><p>ELF 魔数，确认文件类型。</p>
</li>
<li><p>文件类型</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ET_REL</td>
<td>1</td>
<td>可重定位文件，一般问.o文件</td>
</tr>
<tr>
<td>ET_EXEC</td>
<td>2</td>
<td>可执行文件</td>
</tr>
<tr>
<td>ET_DYN</td>
<td>3</td>
<td>共享目标文件，一般为.so文件</td>
</tr>
</tbody></table>
</li>
<li><p>机器类型</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EM_M32</td>
<td>1</td>
<td>AT&amp;T WE 32100</td>
</tr>
<tr>
<td>EM_SPARC</td>
<td>2</td>
<td>SPARC</td>
</tr>
<tr>
<td>EM_M386</td>
<td>3</td>
<td>Intel x86</td>
</tr>
<tr>
<td>EM_68K</td>
<td>4</td>
<td>Motorola 68000</td>
</tr>
<tr>
<td>EM_88K</td>
<td>5</td>
<td>Motorola 88000</td>
</tr>
<tr>
<td>EM_860</td>
<td>6</td>
<td>Intel 80860</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>段表</strong>是保存各个段的基本属性的结构。段表是除文件头外最重要的结构。编译器，链接器和装载器都是依靠段表来定位和访问各个段的属性。</p>
<h3 id="链接的接口-符号"><a href="#链接的接口-符号" class="headerlink" title="链接的接口 - 符号"></a>链接的接口 - 符号</h3><h4 id="符号表结构"><a href="#符号表结构" class="headerlink" title="符号表结构"></a>符号表结构</h4><p>链接过程的本质就是要把多个不同的目标文件之间相互粘到一起。</p>
<p>目标文件 B 要用到目标文件 A 的函数<code>foo</code>，我们称目标文件 A<strong>定义</strong>了函数<code>foo</code>，目标文件 B<strong>引用</strong>了目标文件 A 的函数<code>foo</code>。</p>
<p>链接中，我们将函数和变量统称为<strong>符号</strong>，函数名或变量名就是符号名。、</p>
<p>每一个目标文件都会有一个相应的符号表，表里记录了目标文件中所用到的所有符号。每个符号都有一个对应值，叫符号值，对于变量和函数来说，符号值就是他们的地址。</p>
<p>符号类型：</p>
<ul>
<li>定义在本目标文件的全局符号，可以被其他目标引用。</li>
<li>在本目标文件中应用的全局符号，却没有定义在本目标文件。</li>
<li>段名称，也就是段起始地址。</li>
<li>局部符号，一些静态变量等。</li>
<li>行号信息。</li>
</ul>
<p>最重要的就是第一类和第二类。链接只关心全局符号的相互粘合，其他都是次要的。</p>
<p>可以使用 <code>readelf</code> <code>objdump</code> <code>nm</code>等命令查看符号信息。</p>
<h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><p>一些特殊符号，没有在程序中定义，但是可以直接声明并引用它：</p>
<ul>
<li><code>__executable_start</code>，程序起始地址，不是入口地址，是程序最开始的地址。</li>
<li><code>__etext</code> <code>__etext</code>  <code>etext</code> 代码段结束地址，代码段最末尾的地址。</li>
<li><code>_edata</code> <code>edata</code> 数据段结束地址，数据段最末尾地址。</li>
<li><code>__end</code>  <code>end</code> 程序结束地址。</li>
</ul>
<h4 id="符号修饰"><a href="#符号修饰" class="headerlink" title="符号修饰"></a>符号修饰</h4><p>符号应与对应的函数或者变量同名，但是在 C 语言发明时，已经存在了很多库和目标文件，如果再用一样的函数或变量就会冲突为了避免冲突，C 语言编译后符号名前会加上下划线<code>_</code>，如<code>foo</code>变成<code>_foo</code>，Fortran 语言编译后会在符号前后加上下划线<code>_foo_</code>。</p>
<p>C++具有类，继承，重载等复杂机制，为了支持这些复杂特性，人们发明了<strong>符号修饰</strong>和<strong>符号改编</strong>。</p>
<p><strong>函数签名</strong>包含了一个函数的信息，包括函数名，参数类型，所在类和名称空间等信息。它用于识别不同的函数。在编译器和链接器处理符号时，使用某种名称修饰的方法，是的每个函数签名对应一个<strong>修饰后名称</strong>。</p>
<p>由于不同的编译器采用不同的名字修饰方式，必然导致由不同编译器编译产生的目标文件无法正常互相链接，这是导致不同编译器之间不能互操作的主要原因之一。</p>
<h4 id="extern-C"><a href="#extern-C" class="headerlink" title="extern C"></a>extern C</h4><p>C++为了兼容 C，C++编译器会将在<code>extern C</code> 的大括号内部的代码当做 C 语言代码处理，这样就不会使用 C++的名称修饰机制。（也就不会在编译的时候加上下划线）</p>
<p>但是 C 语言并不支持<code>extern C</code>关键字，又不能为同一个库函数写两套头文件，这时候就可以用 C++的宏，<code>__cplusplus</code>。C++编译器会在编译 C++的程序时默认定义这个宏，我们可以用条件宏来判断当前编译单元是不是 C++代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">int</span> , <span class="hljs-keyword">size_t</span>)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h4 id="弱符号与强符号"><a href="#弱符号与强符号" class="headerlink" title="弱符号与强符号"></a>弱符号与强符号</h4><p>我们经常碰到符号重定义，多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候就会出现符号重定义的错误。比如在两个文件中定义了相同的全局变量。</p>
<p>对于C/C++来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。</p>
<p>也可以使用 GCC 的<code>__attribute__((weak))</code>来定义任何一个强符号为弱符号。</p>
<ul>
<li>不允许强符号被多次定义，如果多次定义，则链接器报重复定义错误；</li>
<li>如果一个符号在某文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</li>
<li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。</li>
</ul>
<h2 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a>第四章 静态链接</h2><h3 id="空间地址分配"><a href="#空间地址分配" class="headerlink" title="空间地址分配"></a>空间地址分配</h3><p>可执行文件中的代码段和数据段就是多个文件合并而来的，对于多个文件链接器如何将它们合并到输出文件？</p>
<p>按序叠加：最简单的方式，按照输入文件顺序依次合并。这会导致大量碎片，比如 x86 的硬件，段的装载地址和空间的对齐单位是页，也就是 4096 字节，那么如果一个段的长度只有 1 字节，它在内存里也要占用 4096 字节。</p>
<p>相似段合并：将所有相同性质的段合并在一起。</p>
<p>现在的链接器基本上采用第二种。使用这种方法的链接器都采用一种叫两步链接的方法。</p>
<p>第一步，空间与地址分配。扫描所有的输入目标文件，并且获得各个段的长度，属性和位置，并将输入目标文件中的符号表所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步，链接器将能够获得所有输入目标文件的段长度，并且将他们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。</p>
<p>第二部，符号解析与重定位。使用上面收集到的信息，读取输入文件中段的数据，重定位信息。并且进行符号解析与重定位，调整代码中的地址。</p>
<p>VMA（Virtual Memory Address）虚拟地址，LMA（Load Memory Address）加载地址。正常情况这两个值是一样的。</p>
<p>链接之前目标文件的所有短 VMA 都是 0，因为虚拟空间还没有被分配，默认为 0，链接之后各个段就会被分配相应的虚拟地址。</p>
<p>Linux 下，ELF 可执行文件默认从地址<code>0x8048000</code>开始分配。</p>
<h3 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">objdump</span> -d  查看代码段反汇编结果<br></code></pre></td></tr></table></figure>

<p>源代码在编译成目标文件时并不知道函数的调用地址。需要通过链接时重定位。</p>
<p>链接器如何知道哪些指令需要被调整？这就用到了<strong>重定位表</strong>。</p>
<p>重定位表就是 ELF 文件的一个段，所以其实重定位表也可以叫重定位段。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">objdump</span> -r 查看重定位表<br></code></pre></td></tr></table></figure>

<p>每个要被重定位的地方叫一个重定位入口（Relocation Entry）。</p>
<p>重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，或引用到定义在其他文件的符号。重定位过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，他就要确定这个符号的目标地址。这时候链接器就会取查找由所有输入目标文件的符号表组成的全局符号表，找到对应的符号进行重定位。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">readelf</span> -s 查看符号表<br></code></pre></td></tr></table></figure>

<p>对于 32 位 x86 平台下的 ELF 文件的重定位入口所修正的指令寻址方式只有两种：</p>
<ul>
<li>绝对近址 32 位寻址</li>
<li>相对近址 32 位寻址</li>
</ul>
<p>x86 基本重定位类型</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th>重定位修正方法</th>
</tr>
</thead>
<tbody><tr>
<td>R_386_32</td>
<td>1</td>
<td>绝对寻址修正 S+A</td>
</tr>
<tr>
<td>R_386_PC32</td>
<td>2</td>
<td>相对寻址修正 S+A-P</td>
</tr>
</tbody></table>
<p>A = 保存在被修正位置的值<br>P = 被修正的位置 (相对于段开始的偏移量或者虚拟地址)，注意，该值可通过 r_offset 计算得到<br>S = 符号的实际地址，即由 <code>r_info</code>的高 24 位指定的符号的实际地址</p>
<h2 id="第六章-可执行文件的装载与进程"><a href="#第六章-可执行文件的装载与进程" class="headerlink" title="第六章 可执行文件的装载与进程"></a>第六章 可执行文件的装载与进程</h2><p>程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。</p>
<h3 id="COMMON-块"><a href="#COMMON-块" class="headerlink" title="COMMON 块"></a>COMMON 块</h3><blockquote>
<p>Q:在目标文件中，编译器为什么不直接把未初始化的全局变量也当做未初始化的局部静态变量一样处理，为它在 BSS 段分配空间，而是将其标记为一个 COMMON 类型的变量？<br>A:当编译器将一个编译单元编译成目标文件时，如果该编译单元包含了弱符号（未初始化的全局变量就是典型），那么该弱符号最终所占大小未知，因为有可能其他编译单元中该符号所占空间比当前的大所以编译器此时无法为该符号在 BSS 段分配空间。但链接器在链接过程中可以确定弱符号大小，因为当链接器读取所有输入目标文件后，任何一个弱符号大小都可以确定，所以它可以在最终输出文件的 BSS 段为其分配空间。总体来看，未初始化全局变量最终还是被放在 BSS 段。</p>
</blockquote>
<p>GCC 的<code>-fno-common</code>吧所有未初始化的全局变量不以 COMMON 块形式处理。</p>
<p><code>__attribute__</code>扩展也可以实现，<code>int global __attribute__((nocommon))</code>。这样未初始化的全局变量就是强符号。</p>
<blockquote>
<p>Q: 为什么静态运行库里面一个目标文件只包含一个函数？比如 libc.o 里面 printf.o 只包含 printf() 函数，strlen.o 只有 strlen 函数？<br>A:因为链接器在链接静态库时是以目标文件为单位的，比如我们引用了静态库中的 printf 函数，那么链接器就会把库中包含 printf 函数的那个目标文件链接进来，如果很多函数写在一个目标文件中，就将没用到的函数一起链接进了输出结果中。</p>
</blockquote>
<h3 id="链接的过程控制"><a href="#链接的过程控制" class="headerlink" title="链接的过程控制"></a>链接的过程控制</h3><h2 id="第-6-章-可执行文件的装载与进程"><a href="#第-6-章-可执行文件的装载与进程" class="headerlink" title="第 6 章 可执行文件的装载与进程"></a>第 6 章 可执行文件的装载与进程</h2><p>程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。</p>
<p><strong>可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件又被叫做映像文件 (Image)。</strong></p>
<p>Segment 和 Section  很难从中文翻译上区分，ELF 文件按 Section 存储的，从装载的角度 ELF 文件又可以按照 Segment 划分。</p>
<h4 id="段地址对齐"><a href="#段地址对齐" class="headerlink" title="段地址对齐"></a>段地址对齐</h4><p>可执行文件需要被装载，装载一般通过虚拟内存页映射机制完成，页是映射的最小单位，对于 x86 处理器来说，默认页大小为 4096 字节，所以内存空间的长度必须是 4096 的整数倍，并且这段空间在物理内存和进程虚拟地址空间的起始地址必须是 4096 的整数倍。</p>
<h2 id="第-7-章-动态链接"><a href="#第-7-章-动态链接" class="headerlink" title="第 7 章 动态链接"></a>第 7 章 动态链接</h2><h2 id="第七章-动态链接"><a href="#第七章-动态链接" class="headerlink" title="第七章 动态链接"></a>第七章 动态链接</h2><h3 id="为什么要动态链接？"><a href="#为什么要动态链接？" class="headerlink" title="为什么要动态链接？"></a>为什么要动态链接？</h3><ul>
<li>内存和磁盘空间：如果两个程序都用到一个静态库，链接时就会有静态库的两个副本，运行时就会占用两份内存。</li>
<li>程序的开发与发布：一个程序用到的静态库如果有更新，那么程序就需要重新链接，发布给用户。</li>
</ul>
<p>要解决以上问题，最简单的方法就是把程序的模块相互分割开来，形成独立的文件，而不再将它们静态链接。就是不对目标文件进行链接，而等到程序运行时再链接。这就是<strong>动态链接的基本思想</strong>。</p>
<p>动态链接模块的装载地址是从<code>0x00000000</code>开始的。</p>
<p>共享对象的最终装载地址在编译时是不确定的。</p>
<h3 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h3><p>静态共享库：将程序的各个模块交给操作系统管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。</p>
<p><strong>装载时重定位</strong>：程序在编译时被装载的目标地址为<code>0x1000</code>，但是在装载时操作系统发现<code>0x1000</code>这个地址已经被别的程序使用了，从<code>0x4000</code>开始有一块足够大的空间可以容纳，那么该程序就可以被装载至<code>0x4000</code>，程序指令和数据所有引用都只需要加上<code>0x3000</code>偏移量即可。因为他们在程序中的相对位置是不会改变的。</p>
<p>地址无关代码为了解决共享对象指令中对绝对地址的重定位问题，基本想法是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p>
<p>模块中四类地址引用：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204092152653.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101004886.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101004869.png"></p>
<p><strong>模块内部调用或者跳转</strong><br>不需要重定位，本身就是地址无关的。</p>
<p><strong>模块内部数据访问</strong><br>指令中不能包含数据的绝对地址，所以使用相对寻址的方式。</p>
<p><strong>模块间数据访问</strong><br>把跟地址相关的部分放到数据段里面。ELF 的做法是在数据段里面建立一个指向这些数据的指针数据，称为<strong>全局偏移表</strong>（GOT）。当代码需要引用全局变量时，可以通过 GOT 间接引用。</p>
<p>链接器在装载时会查找每个变量的地址，填充 GOT 每个项，当指令中需要访问变量时，程序会先找到 GOT，根据 GOT 中对应的地址，找到对应的变量。GOT 本身放在数据段，所以他可以在模块装载时被修改，并且每个进程有独立副本，相互不影响。</p>
<p>以访问变量 b 为例，程序首先计算出变量 b 的地址在 GOT 中的位置，即</p>
<p><code>0x10000000 + 0x454 + 0x118c + 0xfffffff8 = 0x100015d8</code></p>
<p><code>0xfffffff8</code>为<code>-8</code>的补码表示，然后使用寄存器间接寻址方式给变量 b 赋值 2。</p>
<p><strong>模块间调用跳转</strong><br>类似于模块机数据访问，不同的是 GOT 中相应项保存的是目标函数的地址。</p>
<hr>
<p><strong>各种地址引用方式</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>指令跳转，调用</th>
<th>数据访问</th>
</tr>
</thead>
<tbody><tr>
<td>模块内部</td>
<td>相对跳转和调用</td>
<td>相对地址访问</td>
</tr>
<tr>
<td>模块外部</td>
<td>间接跳转和调用（GOT）</td>
<td>间接访问（GOT）</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>Q : -fpic 和-fPIC 的区别？<br>A: 都是 GCC 产生地址无关代码的参数。<code>-fpic</code>产生的代码较小，<code>-fPIC</code>产生的代码较大。因为地址无关代码和硬件平台相关，在一些平台上<code>-fpic</code>会受到限制，比如全局符号的数量或者代码长度等，而后者没有这样的限制。</p>
</blockquote>
<blockquote>
<p>Q: 如果一个共享对象 lib.so 中定义了一个全局变量 G，进程 A 和进程 B 都是用了 lib.so。那么当进程 A 改变这个全局变量时，进程 B 的 G 是否受到影响？<br>A: 不会，应当 lib.so 被加载时，它的数据段部分在每个进程都有独立的副本。如果是同一个进程里的线程 A 和线程 B，那么他们是共享数据 G 的。</p>
</blockquote>
<p>如果代码不是地址无关的，它就不能被多个进程共享，就失去了节省内存的优点。但是装载是重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数是需要做一次计算当前地址以及间接地址寻址的过程。</p>
<h3 id="延迟绑定-PLT"><a href="#延迟绑定-PLT" class="headerlink" title="延迟绑定 PLT"></a>延迟绑定 PLT</h3><p>动态链接要比静态链接慢，一是因为动态链接下，对全局和静态数据的访问都要进行复杂的 GOT 定位，然后间接寻址。另外，程序开始执行时，动态链接器都要进行一次链接工作。</p>
<p>而在一个程序运行过程中，可能很多函数在程序执行完时都不会用到，如果一开始就把所有函数链接好实际就是一种浪费，所有 ELF 采用了一种叫做延迟绑定的做法，基本思想就是当函数<strong>第一次使用时</strong>才进行绑定（符号查找，重定位等）。</p>
<p>ELF 使用 PLT（Procedure Linkage Table）来实现延迟绑定。以调用<code>bar()</code>函数为例，之前的做法是通过 GOT 中的相应项进行跳转，而延迟绑定下，在这过程中间加了一层 PLT 间接跳转。每个外部函数在 PLT 中都有一个对应项，比如<code>bar()</code>在 PLT 中项的地址为<code>bar@plt</code>。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">bar</span>@<span class="hljs-selector-tag">plt</span>:<br>    <span class="hljs-selector-tag">jmp</span> *(bar<span class="hljs-variable">@GOT</span>)<br>    <span class="hljs-selector-tag">push</span> <span class="hljs-selector-tag">n</span><br>    <span class="hljs-selector-tag">push</span> <span class="hljs-selector-tag">moduleID</span><br>    <span class="hljs-selector-tag">jump</span> <span class="hljs-selector-tag">_dl_runtime_resolve</span><br></code></pre></td></tr></table></figure>

<p>第一条是指令通过 GOT 间接跳转的指令，如果链接器在初始化阶段已经初始化该项，并将<code>bar()</code>地址填入该项，那么就能正确跳转到<code>bar()</code>。但是为了延迟绑定，链接器初始化时并没有将<code>bar()</code>地址填入，而是将第二条指令<code>push n</code>的地址填入了<code>bar@GOT</code>中，这一步不需要查找符号，代价很低。</p>
<p>第一条指令的效果就是跳转到第二条指令，第二条指令将数字<code>n</code>压入堆栈，这个数字是<code>bar</code>这个符号引用在重定位表<code>.rel.plt</code>中的下标。第三条指令将模块 ID 压入堆栈，最后跳转到<code>_dl_runtime_resolve</code>。</p>
<p><code>_dl_runtime_resolve</code>进行一系列工作后将<code>bar()</code>真正地址填入到<code>bar@GOT</code>。</p>
<p>一旦<code>bar()</code>这个函数被解析完，当面再次调用<code>bar@plt</code>时，第一条<code>jump</code>指令就能跳转到<code>bar()</code>的真正地址。<code>bar()</code>函数返回时根据堆栈里保存的<code>EIP</code>直接返回到调用者，而不会执行<code>bar@plt</code>中第二条指令。<strong>那段代码只会在符号未被解析时执行一次</strong>。</p>
<p>PLT 在 ELF 文件中以独立段存在，段名通常叫做<code>.plt</code>，因为它本身是一些地址无关的代码，所以可以跟代码段合并成同一个可读可执行的 Segment 被装载入内存。</p>
<h3 id="动态链接相关结构"><a href="#动态链接相关结构" class="headerlink" title="动态链接相关结构"></a>动态链接相关结构</h3><p><strong>.interp 段</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">objdump</span> -s a.out<br><br><span class="hljs-attribute">Contents</span> of section .interp:<br><span class="hljs-attribute">804811</span> <span class="hljs-number">2</span>f<span class="hljs-number">6</span>c<span class="hljs-number">6962</span> <span class="hljs-number">2</span>f<span class="hljs-number">6</span>c<span class="hljs-number">696</span>d <span class="hljs-number">6</span>c<span class="hljs-number">696</span>e<span class="hljs-number">78</span> <span class="hljs-number">782</span>e<span class="hljs-number">736</span>f  /lib/ld-linux.so.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>里面保存的就是可执行文件所需要的动态链接器的路径，在 Linux 下，可执行文件动态链接器几乎都是<code>/lib/ld-linux.so.2</code>。</p>
<p>这是个软链接，会他会指向系统中安装的动态链接器。当系统中的 Glibc 库更新时，软链接也会指向新的动态链接器，所以<code>.interp</code>段不需要修改。</p>
<p>可以通过以下命令查看可执行文件需要的动态链接器的路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ readelf -l a.out | grep interpreter<br>    [Requesting program interpreter: /lib/ld-linux.so.2]<br></code></pre></td></tr></table></figure>

<p><strong>.dynamic 段</strong></p>
<p>动态链接 ELF 中最重要的结构，这里保存了动态链接器所需要的基本信息，如依赖哪些共享对象，动态链接符号表的位置，动态链接重定位表的位置，共享对象初始化代码的地址等。</p>
<p><strong>动态符号表</strong></p>
<p><code>Program1</code>程序一来<code>Lib.so</code>，引用到了里面的<code>foobar()</code>函数，那么对于<code>Program1</code>来说，称<code>Program1</code>导入（Import）了<code>foobar</code>函数，<code>foobar</code>是<code>Program1</code>的导入函数。</p>
<p>而站在<code>Lib.so</code>角度来说，它定义了<code>foobar</code>函数，我们称<code>Lib.so</code>导出（Export）了<code>foobar</code>函数，<code>foobar</code>是<code>Lib.so</code>的导出函数。</p>
<p>为了表示动态链接这些模块之间的符号导入导出关系，ELF 专门有一个叫做动态符号表的段来保存这些信息，段名通常叫<code>.dynsym</code>。</p>
<p><code>.dynsym</code>只保存与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。</p>
<p><strong>动态链接重定位表</strong></p>
<p>PIC 模式的共享对象也需要重定位。</p>
<p>对于使用 PIC 技术的可执行文件或共享对象来说，虽然代码段不需要重定位，但是数据段还包含了绝对地址的引用，因为代码段中绝对地址相关的部分被分离出来，变成了 GOT，而 GOT 实际上是数据段的一部分。</p>
<p>目标文件的重定位在静态链接时完成，共享对象的重定位在装载时完成。</p>
<p>目标文件里包含专门用于重定位信息的重定位表，比如<code>.rel.text</code>表示是代码段重定位表，<code>.rel.data</code>表示数据段重定位表。</p>
<p>共享对象里类似的重定位表叫做<code>.rel.dyn</code>和<code>.rel.plt</code>。<code>.rel.dyn</code>实际上是对数据引用的修正，它所修正的位置位于<code>.got</code>以及数据段；<code>.rel.plt</code>实际上是对代码引用的修正，它所修正的位置位于<code>.got.plt</code>。</p>
<p>用以下命令可以查看重定位表；</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101958979.png"></p>
<p><code>printf</code>这个重定位入口，它的类型为<code>R_386_JUMP_SLOT</code>，它的偏移为<code>0x000015d8</code>。它实际位于<code>.got.plt</code>中，前三项是被系统占用的，第四项开始才是真正存放导入函数地址的地方，刚好是<code>0x000015c8 + 4 * 3 = 0x000015d4</code>，即<code>__gmon_start__</code>。</p>
<p>当动态链接器要进行重定位时，先查找<code>printf</code>的地址，假设链接器在全局符号表中找到<code>printf</code>的地址为<code>0x08801234</code>，那么链接器就会将这个地址填入<code>.got.plt</code>中偏移为<code>0x000015d8</code>的位置。<strong>从而实现了地址重定位，即动态链接最关键的一步</strong>。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204102010906.png"></p>
<h3 id="动态链接时进程堆栈初始化信息"><a href="#动态链接时进程堆栈初始化信息" class="headerlink" title="动态链接时进程堆栈初始化信息"></a>动态链接时进程堆栈初始化信息</h3><h3 id="动态链接的步骤和实现"><a href="#动态链接的步骤和实现" class="headerlink" title="动态链接的步骤和实现"></a>动态链接的步骤和实现</h3><p>动态链接分为三步：启动动态链接本身，装载所有的共享对象，重定位和初始化。</p>
<blockquote>
<p>Q：动态链接器本身是动态链接还是静态链接？<br>A：动态链接器本身应该是静态链接的，它不能依赖于其他共享对象，动态链接器本身使用来帮助其他 ELF 文件解决共享对象依赖问题的，如果它也依赖其他共享对象，那就陷入矛盾了。</p>
</blockquote>
<blockquote>
<p>Q：动态链接器本身必须是 PIC 的吗？<br>A：动态链接器可以是 PIC 的也可以不是，但是往往用 PIC 会简单一些。</p>
</blockquote>
<blockquote>
<p>Q：动态链接器可以被当做可执行文件运行，那么它的装载地址是多少？<br>A：ld.so 的装载地址跟一般的共享对象一样，即<code>0x00000000</code>。这个装载地址是一个无效的装载地址，作为一个共享库，内核在装载它时会为其选择一个合适的装载地址。</p>
</blockquote>
<h3 id="显示运行时链接"><a href="#显示运行时链接" class="headerlink" title="显示运行时链接"></a>显示运行时链接</h3><h2 id="第-10-章-内存"><a href="#第-10-章-内存" class="headerlink" title="第 10 章 内存"></a>第 10 章 内存</h2><h3 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h3><p>在 32 位操作系统里，有 4GB 的寻址能力，大部分操作系统会将一部分挪给内核使用，应用程序无法直接访问这段内存。这部分称为内核空间。Windows 默认将高地址的 2GB 分给内核，Linux 默认分 1GB 给内核。</p>
<p>剩下的称为用户空间，在用户空间里也有一些特殊的地址区间：</p>
<ul>
<li>栈：维护函数调用上下文，通常在用户空间的最高地址处分配。</li>
<li>堆：用来容纳程序动态分配的内存区域，当使用 malloc 或者 new 分配内存时，得到的内存来自于堆。通常在栈下方。</li>
<li>可执行文件映像：存储可执行文件再内存里的映像，由装载器在装载时将可执行文件的内存读取活映射到这里。</li>
<li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。比如<code>NULL</code>。</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301614683.png"></p>
<h3 id="栈与调用惯例"><a href="#栈与调用惯例" class="headerlink" title="栈与调用惯例"></a>栈与调用惯例</h3><p>栈保存了一个函数调用所需要的维护信息，通常这被称为栈帧。一般包括如下几个方面：</p>
<ul>
<li>函数的返回地址和参数</li>
<li>临时变量</li>
<li>保存的上下文</li>
</ul>
<p>一个函数的调用流程：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301632031.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301632216.png"></p>
<p>I386 标准函数进入和退出指令序列，基本形式：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>, x<br>[<span class="hljs-keyword">push</span> reg1]<br>...<br>[<span class="hljs-keyword">push</span> regn]<br><br>函数实际内存<br><br>[<span class="hljs-keyword">pop</span> regn]<br>...<br>[<span class="hljs-keyword">pop</span> reg1]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure>

<hr>
<p><strong>Hot Patch Prologue 热补丁</strong><br>在 Windows 函数里，有些函数尽管使用了标准的进入指令序列，但是在这些指令之前却插入了一些特殊内容：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">mov</span> <span class="hljs-keyword">edi</span>,<span class="hljs-keyword">edi</span><br></code></pre></td></tr></table></figure>

<p>这条指令没有任何用，在汇编之后会成为一个占用 2 字节的机器码，纯粹为了占位符而存在，使用这条指令开头的函数整体看起来是这样的：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-symbol">FUNCTION:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>,<span class="hljs-built_in">edi</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br></code></pre></td></tr></table></figure>

<p>其中 nop 占 1 个字节，也是占位符，FUNCTION 为一个标号，表示函数入口，本身不占空间。</p>
<p>设计成这样的函数在运行时可以很容易被其他函数替换掉，在上面的指令序列中调用的函数是 FUNCTION，但是我们可以做一些修改，可以在运行时刻意改成调用函数 REPLACEMENT_FUNCTION。首先在进程内存空间任意处写入 REPLACEMENT_FUNCTION 的定义：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">REPLACEMENT_FUNCTION:</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br>...<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure>

<p>然后修改原函数的内容：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">LABEL:</span>         <span class="hljs-meta"># 标号不占字节</span><br><span class="hljs-keyword">jmp</span> REPLACEMENT_FUNCTION <span class="hljs-meta"># 占5字节，刚好五个nop</span><br><span class="hljs-symbol">FUNCTION:</span>      <span class="hljs-meta"># 函数入口标号，不占字节</span><br><span class="hljs-keyword">jmp</span> LABEL      <span class="hljs-meta"># 近跳指令，占2字节，跳跃到上方，即使截获失败也不影响原函数执行</span><br><span class="hljs-keyword">push</span> ebp<br><span class="hljs-keyword">mov</span> ebp, esp<br>...<br></code></pre></td></tr></table></figure>

<p>将 5 个<code>nop</code>换成一个<code>jmp</code>指令，然后将占用两个字节的<code>mov edi,edi</code>换成另一个<code>jmp</code>指令。因为这个<code>jmp</code>指令跳转的距离非常近，因此被汇编器翻译成了一个“近跳”指令，这种指令只占用两个字节。但<strong>只能跳跃到当前地址前后 127 个字节范围的目标位置</strong>。</p>
<p>这里的替换机制，可以实现一种叫做<em>钩子</em>（HOOK）的技术，允许用户在某时刻截获特定函数的调用。</p>
<hr>
<p>函数传递参数时压栈顺序，传递参数是寄存器传参还是栈传参等等都需要遵守一定的约定，否则函数将无法正确执行，这样的约定称为<strong>调用惯例</strong>。</p>
<p>一个调用惯例一般会规定如下几个方面：</p>
<ul>
<li>函数参数的传递顺序和方式<ul>
<li>调用方压栈，函数自己从栈用取参数</li>
<li>调用方压栈顺序：从左至右，还是从右至左？</li>
</ul>
</li>
<li>栈的维护方式<ul>
<li>参数出栈，可以由调用方完成还是由函数自己完成？</li>
</ul>
</li>
<li>名字修饰的策略<ul>
<li>为了链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰，不同调用惯例有不同的名字修饰策略</li>
<li>没有显示指定调用惯例的函数默认是<code>cdecl</code>惯例</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> _cdecl <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">float</span> m)</span></span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>_cdel 是非标准关键字，在不同编译器中写法不同，在 gcc 中使用的是<code>__attribute__((cdecl))</code></p>
</blockquote>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><table>
<thead>
<tr>
<th>英文名</th>
<th>Linux</th>
<th align="center">扩展名</th>
<th>英文名</th>
<th>Windows</th>
<th align="center">扩展名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>DSO-Dynamic Shared Objects</td>
<td>ELF 动态链接文件，动态共享对象，共享对象</td>
<td align="center">.so</td>
<td>DLL-Dynamic Linking Library</td>
<td>动态链接库</td>
<td align="center">.dll</td>
<td>1111</td>
</tr>
<tr>
<td>Static Shared Library</td>
<td>静态共享库</td>
<td align="center">2222</td>
<td>2222</td>
<td>2222</td>
<td align="center">2222</td>
<td>2222</td>
</tr>
<tr>
<td>1111</td>
<td>1111</td>
<td align="center">1111</td>
<td>1111</td>
<td>1111</td>
<td align="center">1111</td>
<td>1111</td>
</tr>
<tr>
<td>1111</td>
<td>1111</td>
<td align="center">1111</td>
<td>1111</td>
<td>1111</td>
<td align="center">1111</td>
<td>1111</td>
</tr>
<tr>
<td>1111</td>
<td>1111</td>
<td align="center">1111</td>
<td>1111</td>
<td>1111</td>
<td align="center">1111</td>
<td>1111</td>
</tr>
</tbody></table>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/03/28/ZH-%E4%BB%80%E4%B9%88%E6%98%AFDie-to-Die%E6%8E%A5%E5%8F%A3/" itemprop="url">ZH-什么是 Die-to-Die 接口</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-03-28T11:06:56.000Z" itemprop="datePublished">3月 28 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            13 分钟 读完 (约 1895 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="什么是-Die-to-Die-接口"><a href="#什么是-Die-to-Die-接口" class="headerlink" title="什么是 Die-to-Die 接口"></a>什么是 Die-to-Die 接口</h1><blockquote>
<p>Author：Synopsys<br>译：<a target="_blank" rel="noopener" href="https://www.synopsys.com/glossary/what-is-die-to-die-interface.html">What is a Die-to-Die Interface? – How it Works | Synopsys</a></p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>裸片到裸片（Die2Die）接口是一个功能块，它提供组装在同一封装中的两个硅管芯之间的数据接口。芯片到芯片接口利用非常短的通道连接封装内的两个芯片，以实现功率效率和非常高的带宽效率，这超出了传统芯片到芯片接口所能达到的效果。</p>
<p>Die2Die 接口通常由 PHY 和控制器块组成，控制器块在两个 die 上的内部互连结构之间提供无缝连接。Die2Die 的 PHY 使用高速 SerDes 架构或高密度并行架构实现，经过优化以支持多种先进的 2D、2.5D 和 3D 封装技术。</p>
<p>Die2Die 接口是推动行业趋势从单片 SoC 设计转向同一封装中的多 Die SoC 组件的关键推动力。这种方法减轻了人们对小型工艺节点的高成本/低产量日益增长的担忧，并提供了额外的产品模块化和灵活性。</p>
<h2 id="Die-to-Die-接口如何工作？"><a href="#Die-to-Die-接口如何工作？" class="headerlink" title="Die-to-Die 接口如何工作？"></a>Die-to-Die 接口如何工作？</h2><p>Die2Die 的接口，就像任何其他芯片到芯片的接口一样，在两个芯片之间建立了可靠的数据链路。</p>
<p>接口在逻辑上分为物理层、链路层和事务层。它在芯片运行期间建立和维护链路，同时向应用程序提供连接到内部互连结构的标准化并行接口。</p>
<p>通过添加诸如前向纠错 (FEC) 和/或循环冗余码 (CRC) 和重试等错误检测和纠正机制来保证链路可靠性。</p>
<p>物理层架构可以是基于 SerDes 或基于并行的。</p>
<ul>
<li><p>基于 SerDes 的架构包括并行到串行（串行到并行）数据转换、阻抗匹配电路和时钟数据恢复或时钟转发功能。它可以支持更高带宽的 NRZ 信令或 PAM-4 信令，最高可达 112 Gbps。SerDes 架构的主要作用是尽量减少简单 2D 类型封装（如有机基板）中的 I/O 互连数量。</p>
</li>
<li><p>基于并行的架构包括许多并行的低速简单收发器，每个收发器都由驱动器和具有转发时钟技术的接收器组成，以进一步简化架构。它支持 DDR 类型的信令。并行架构的主要作用是最大限度地降低密集 2.5D 型封装（如硅中介层）的功耗。</p>
</li>
</ul>
<h2 id="Die2Die-的优势"><a href="#Die2Die-的优势" class="headerlink" title="Die2Die 的优势"></a>Die2Die 的优势</h2><p>现代芯片实现趋向于基于在封装中组装多个裸片以提高模块化和灵活性的解决方案。当（单片）芯片尺寸接近全光罩尺寸时，这种多管芯方法还通过将功能分成几个管芯来提高产量，从而促进更具成本效益的解决方案。</p>
<p>Die 之间的接口必须满足此类系统的所有关键要求：</p>
<ul>
<li><p><strong>电源效率</strong>。多芯片系统实现应该与等效的单片实现一样节能。Die2Die 链接使用短距离、低损耗的信道，没有明显的不连续性。PHY 架构利用良好的通道特性来降低 PHY 复杂性并节省功耗。</p>
</li>
<li><p><strong>低延迟</strong>。将服务器或加速器 SoC 划分为多个 Die 不应导致内存架构不统一，因为访问不同 Die 中的内存具有显着不同的延迟。Die2Die 接口实现了简化的协议，并直接连接到芯片互连结构，以最大限度地减少延迟。</p>
</li>
<li><p><strong>高带宽效率</strong>。高级服务器、加速器和网络交换机需要在 Die 之间传输大量数据。Die2Die 接口必须能够支持所有需要的带宽，同时减少 Die 边缘的占用。通常使用两种替代方案来实现此目标：通过以非常高的每通道数据速率（高达 112 Gbps）部署 PHY 来最小化所需通道的数量，或者通过使用更精细的凸块间距（微凸块）来增加 PHY 的密度) 在大量并行化以实现所需带宽的低数据速率通道（高达 8 Gbps/通道）上。</p>
</li>
<li><p><strong>健壮的链接</strong>。Die2Die 链接必须没有错误。该接口必须实现足够强大的低延迟错误检测和纠正机制，以检测所有错误并以低延迟纠正它们。这些机制通常包括 FEC 和重试协议。</p>
</li>
</ul>
<h2 id="Die-to-Die-接口用例"><a href="#Die-to-Die-接口用例" class="headerlink" title="Die-to-Die 接口用例"></a>Die-to-Die 接口用例</h2><p>通过将多个 Die 组合到一个封装中，小芯片提供了另一种扩展摩尔定律的方法，同时实现了产品模块化和工艺节点优化。小芯片用于计算密集型、工作负载繁重的应用程序，如高性能计算 (HPC)。</p>
<p>针对 HPC、网络、超大规模数据中心和人工智能 (AI) 等应用程序的 die-to-die 接口有四个主要用例：</p>
<h3 id="Scale-SoC"><a href="#Scale-SoC" class="headerlink" title="Scale SoC"></a>Scale SoC</h3><p>目标是通过虚拟（裸片到裸片）连接来连接裸片，从而提高计算能力并为服务器和 AI 加速器创建多个 SKU，从而实现裸片之间的紧密耦合性能。</p>
<h3 id="Split-SoC"><a href="#Split-SoC" class="headerlink" title="Split SoC"></a>Split SoC</h3><p>目标是启用非常大的 SoC。大型计算和网络交换机芯片正在接近光罩限制。将它们分成几个裸片会带来技术可行性、提高产量、降低成本并扩展摩尔定律。</p>
<h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><p>其目的是聚合在不同模具中实现的多种不同的功能，以利用每个功能的最佳工艺节点，降低功率，并改善 FPGA、汽车和 5G 基站等应用的外形尺寸。</p>
<h3 id="Disaggregate"><a href="#Disaggregate" class="headerlink" title="Disaggregate"></a>Disaggregate</h3><p>目标是将中央芯片与 I/O 芯片分离，以便将中央芯片轻松迁移到高级工艺，同时将 I/O 芯片保持在保守节点中，以降低产品演进的风险/成本，实现重用并缩短时间在服务器、FPGA、网络交换机和其他应用程序中投放市场。</p>
<h2 id="Die-to-Die-接口和-Synopsys"><a href="#Die-to-Die-接口和-Synopsys" class="headerlink" title="Die-to-Die 接口和 Synopsys"></a>Die-to-Die 接口和 Synopsys</h2><p>Synopsys 结合了广泛的 Die2Die 112G USR/XSR 和 HBI PHY IP、控制器 IP 和中介层专业知识产品组合，提供全面的 die-to-die IP 解决方案，以支持芯片拆分、芯片分解、计算扩展和聚合的功能。基于 SerDes 的 112G USR/XSR PHY 和基于并行的 8G OpenHBI PHY 可用于高级 FinFET 工艺。可配置控制器使用具有重放和可选 (FEC) 功能的纠错机制，以最大限度地降低可靠芯片到芯片链接的误码率。它支持用于连贯和非连贯数据通信的 Arm® 特定接口。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li>PHY 架构</li>
<li>SerDes 架构</li>
<li>reticle<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/457213984">LCD 厂掩膜版叫 Mask,Fab 里掩膜版叫 reticle，两者有什么区别？ - 知乎</a></li>
</ul>
<h2 id="原文参考"><a href="#原文参考" class="headerlink" title="原文参考"></a>原文参考</h2><p><a target="_blank" rel="noopener" href="https://www.synopsys.com/glossary/what-is-die-to-die-interface.html">What is a Die-to-Die Interface? – How it Works | Synopsys</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/03/18/Qt%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%B1%8F%E8%94%BDqDebug%E8%BE%93%E5%87%BA/" itemprop="url">Qt 编译后的程序放到指定目录，屏蔽 qDebug 输出</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-03-18T05:50:35.000Z" itemprop="datePublished">3月 18 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 读完 (约 247 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="可执行程序放到指定目录"><a href="#可执行程序放到指定目录" class="headerlink" title="可执行程序放到指定目录"></a>可执行程序放到指定目录</h2><p>默认情况下 QtCreator 会将编译链接后的可执行程序与中间生成的文件防盗<code>build-***-</code>文件中，如何能将可执行文件生成在指定目录？</p>
<p>修改<code>.pro</code>:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">CONFIG(<span class="hljs-builtin-name">debug</span> ,<span class="hljs-builtin-name">debug</span>|release)&#123;<br>    DESTDIR = <span class="hljs-built_in">..</span>/<span class="hljs-builtin-name">debug</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    DESTDIR = <span class="hljs-built_in">..</span>/release<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>debug</code>版本放在<code>../debug</code>目录中，<code>release</code>版本放在<code>../release</code>目录中。</p>
<h2 id="屏蔽-qDebug-输出"><a href="#屏蔽-qDebug-输出" class="headerlink" title="屏蔽 qDebug 输出"></a>屏蔽 qDebug 输出</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">CONFIG(<span class="hljs-builtin-name">debug</span> ,<span class="hljs-builtin-name">debug</span>|release)&#123;<br>    DEFINES -= QT_NO_DEBUG_OUTPUT<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    DEFINES += QT_NO_DEBUG_OUTPUT<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>QT_NO_DEBUG_OUTPUT</code>即为屏蔽 qDebug 输出的宏定义，可以在<code>debug</code>版本中不屏蔽 qDebug 输出，<code>release</code>版本中屏蔽 qDebug 输出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35173114/article/details/81037315">QT 屏蔽 qDebug()、qWarning() 打印信息_qq_35173114 的博客-CSDN 博客_qwarning</a><br><a target="_blank" rel="noopener" href="https://www.cxyzjd.com/article/amwha/115263253">QT 的 QDebug 无法输出日志_amwha 的专栏 - 程序员宅基地_qdebug 打印不出来 - 程序员宅基地</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hebbely/article/details/66970821">Qt Creator 中的.pro 文件的详解_hebbely 的博客-CSDN 博客_qt 的 pro 文件</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/03/09/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-QOM/" itemprop="url">QEMU 源码分析-QOM</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-03-09T08:02:19.000Z" itemprop="datePublished">3月 9 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/QEMU-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">QEMU 源码分析</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            16 分钟 读完 (约 2413 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="QOM-简介"><a href="#QOM-简介" class="headerlink" title="QOM 简介"></a>QOM 简介</h2><p>QOM(QEMU Object Model) 是 QEMU 的一个模块，用于描述虚拟机的结构，包括虚拟机的 CPU、内存、硬盘、网络、输入输出设备等。QEMU 为了方便整个系统的构建，实现了自己的一套的面向对象机制，也就是 QOM(QEMU Object Model)。它能够方便的表示各个设备（Device）与总线（Bus）之间的关系。</p>
<p>这个模型主要包含四个结构体：</p>
<ul>
<li>Object: 是所有对象的 基类 Base Object</li>
<li>ObjectClass: 是所有类对象的基类</li>
<li>TypeInfo：是用户用来定义一个 Type 的工具型的数据结构</li>
<li>TypeImpl：TypeInfo 抽象数据结构，TypeInfo 的属性与 TypeImpl 的属性对应</li>
</ul>
<p>在 QEMU 里要初始化一个对象需要完成四步：</p>
<ul>
<li>将 TypeInfo 注册 TypeImpl</li>
<li>实例化 Class（ObjectClass）</li>
<li>实例化 Object</li>
<li>添加 Property</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-09-19-4995177f1aeb782fadaf586f8f5c8b32-qemu-QOM%E5%88%86%E6%9E%90.drawio%20-2--1a4eac.png"></p>
<h2 id="QOM-中的面向对象"><a href="#QOM-中的面向对象" class="headerlink" title="QOM 中的面向对象"></a>QOM 中的面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 QEMU 中通过 <strong>TypeInfo</strong> 来定义一个类。</p>
<p>例如 <code>x86_base_cpu_type_info</code> 就是一个 <code>class</code>，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_base_cpu_type_info = &#123;<br>        .name = X86_CPU_TYPE_NAME(<span class="hljs-string">&quot;base&quot;</span>),<br>        .parent = TYPE_X86_CPU,<br>        .class_init = x86_cpu_base_class_init,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>利用结构体包含来实现继承</strong>。这应该是所有的语言实现继承的方法，在 C++ 中，结构体包含的操作被语言内部实现了，而 C 语言需要自己实现。</p>
<p>例如 <code>x86_cpu_type_info</code> 的 <code>parent</code> 是 <code>cpu_type_info</code>, 他们的结构体分别是 <code>X86CPU</code> 和 <code>CPUState</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_cpu_type_info = &#123;<br>    .name = TYPE_X86_CPU,<br>    .parent = TYPE_CPU,<br>  <span class="hljs-comment">// ...</span><br>    .instance_size = <span class="hljs-keyword">sizeof</span>(X86CPU),<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo cpu_type_info = &#123;<br>    .name = TYPE_CPU,<br>    .parent = TYPE_DEVICE,<br>  <span class="hljs-comment">// ...</span><br>    .instance_size = <span class="hljs-keyword">sizeof</span>(CPUState),<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在 <code>X86CPU</code> 中包含一个 <code>CPUState</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPU</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    CPUState parent_obj;<br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br><br>    CPUNegativeOffsetState neg;<br></code></pre></td></tr></table></figure>

<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态成员变量可以在类的多个对象中访问，但是要在类外声明。<strong>不同对象访问的其实是同一个实体，静态成员变量被多个对象共享</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_cpu_type_info = &#123;<br>    .name = TYPE_X86_CPU,<br>    .parent = TYPE_CPU,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(X86CPU),<br>    .instance_init = x86_cpu_initfn,<br>    .instance_post_init = x86_cpu_post_initfn,<br><br>    .abstract = <span class="hljs-literal">true</span>,<br>    .class_size = <span class="hljs-keyword">sizeof</span>(X86CPUClass),<br>    .class_init = x86_cpu_common_class_init,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其中 <code>X86CPU</code> 描述的是非静态成员，而 <code>X86CPUClass</code> 描述的是静态的成员。也就是说<code>class_init</code>初始化静态成员，<code>instance_init</code>初始化非静态成员。</p>
<p>那么何时初始化静态成员呢？首先得告诉系统，咱有<code>class_init</code>这个初始化函数，等需要的时候随时可以调用它初始化，所有先解决如何将这个初始化函数注册到系统中？</p>
<p>在<code>target/i386/cpu.c</code>最后使用了<code>type_init</code>。在<code>qemu/include/qemu/module.h</code>中有一个<code>type_init</code>宏定义，除了<code>type_init</code>还有其他宏，比如<code>block_init</code>，<code>opts_init</code>等。每个宏都表示一类<code>module</code>，通过<code>module_init</code>构造出来。我们展开这个宏，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __attribute__((constructor))<br>do_qemu_init_x86_cpu_register_types(<span class="hljs-keyword">void</span>) &#123;<br>  register_module_init(x86_cpu_register_types, MODULE_INIT_QOM);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过 <code>gcc</code> 扩展属性<code>__attribute__((constructor))</code>可以让 <code>do_qemu_init_x86_cpu_register_types</code> 在运行 <code>main</code> 函数之前运行。 <code>register_module_init</code> 会让 <code>x86_cpu_register_types</code> 这个函数挂载到 <code>init_type_list[MODULE_INIT_QOM]</code> 这个链表上。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210907133931.svg"></p>
<p>到底，所有的 <code>TypeInfo</code> 通过 <code>type_init</code> 都被放到 <code>type_table</code> 上了，之后通过 <code>Typeinfo</code> 的名称调用 <code>type_table_lookup</code> 获取到 <code>TypeImpl</code> 了。</p>
<p>到这里，将<code>TYPE_X86_CPU</code>注册进类系统，包括其初始化函数，这部分也就是 QEMU 中类型的构造。那么何时调用静态成员初始化函数呢？也就是类型的初始化。</p>
<p>静态成员是所有的对象公用的，其初始化显然要发生在所有的对象初始化之前。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">main<br>    qemu_init <br>        select_machine <br>            object_class_get_list <br>                object_class_foreach <br>                    g_hash_table_foreach <br>                        object_class_foreach_tramp <br>                            type_initialize <br>                                type_initialize <br>                                    x86_cpu_common_class_init <br></code></pre></td></tr></table></figure>

<p><code>select_machine</code> 需要获取所有的 <code>TYPE_MACHINE</code> 的 <code>class</code>, 其首先会调用所有的<code>class_list</code>，其会遍历 <code>type_table</code>，遍历的过程中会顺带 <code>type_initialize</code> 所有的 <code>TypeImpl</code> 进而调用的 <code>class_init</code>。</p>
<p>说完类型的初始化，再讲一下对象的初始化，也就是初始化非静态成员，也就是<code>instance_init</code>在何时被调用？</p>
<p>对象初始化，通过调用 <code>object_new</code> 来实现初始化。</p>
<ul>
<li><code>object_initialize_with_type</code><ul>
<li>初始化一个空的 :<code>Object::properties</code></li>
<li><code>object_init_with_type</code><ul>
<li>如果 <code>object</code> 有 <code>parent</code>，那么调用 <code>object_init_with_type</code> 首先初始化 <code>parent</code> 的</li>
<li>调用<code>TypeImpl::instance_init</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">main <br>    qemu_init <br>        qmp_x_exit_preconfig <br>            qemu_init_board <br>                machine_run_board_init <br>                    pc_init_v6_1 <br>                        pc_init1 <br>                            x86_cpus_init <br>                                x86_cpu_new <br>                                    object_new <br>                                        object_new_with_type <br>                                            object_initialize_with_type <br>                                                object_init_with_type <br>                                                    x86_cpu_initfn <br></code></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。为了实现多态，QOM 实现了一个非常重要的功能，就是动态类型转换。我们可以使用相关的函数，将一个<code>Object</code>的指针在运行时转换为子类对象的指针，可以将一个<code>ObjectClass</code>的指针在运行时转换为子类的指针。这样就可以调用子类中定义的函数指针来完成相应的功能。</p>
<p>QEMU 定义了一些列的宏封来进行动态类型转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//include/qom/object.h</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_INSTANCE_CHECKER:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the instance type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED InstanceType * \</span><br><span class="hljs-meta">    OBJ_NAME(const void *obj) \</span><br><span class="hljs-meta">    &#123; return OBJECT_CHECK(InstanceType, obj, TYPENAME); &#125;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_CLASS_CHECKERS:</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the class type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED ClassType * \</span><br><span class="hljs-meta">    OBJ_NAME##_GET_CLASS(const void *obj) \</span><br><span class="hljs-meta">    &#123; return OBJECT_GET_CLASS(ClassType, obj, TYPENAME); &#125; \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED ClassType * \</span><br><span class="hljs-meta">    OBJ_NAME##_CLASS(const void *klass) \</span><br><span class="hljs-meta">    &#123; return OBJECT_CLASS_CHECK(ClassType, klass, TYPENAME); &#125;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_OBJ_CHECKERS:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the three standard type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_OBJ_CHECKERS(InstanceType, ClassType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @MODULE_OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro is typically used in a header file, and will:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   - create the typedefs for the object and class structs</span><br><span class="hljs-comment"> *   - register the type for use with g_autoptr</span><br><span class="hljs-comment"> *   - provide three standard type cast functions</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The object struct and class struct need to be declared manually.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_DECLARE_TYPE(InstanceType, ClassType, MODULE_OBJ_NAME) \</span><br><span class="hljs-meta">    typedef struct InstanceType InstanceType; \</span><br><span class="hljs-meta">    typedef struct ClassType ClassType; \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    G_DEFINE_AUTOPTR_CLEANUP_FUNC(InstanceType, object_unref) \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    DECLARE_OBJ_CHECKERS(InstanceType, ClassType, \</span><br><span class="hljs-meta">                         MODULE_OBJ_NAME, TYPE_##MODULE_OBJ_NAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT:</span><br><span class="hljs-comment"> * @obj: A derivative of #Object</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Converts an object to a #Object.  Since all objects are #Objects,</span><br><span class="hljs-comment"> * this function will always succeed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT(obj) \</span><br><span class="hljs-meta">    ((Object *)(obj))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CLASS:</span><br><span class="hljs-comment"> * @class: A derivative of #ObjectClass.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Converts a class to an #ObjectClass.  Since all objects are #Objects,</span><br><span class="hljs-comment"> * this function will always succeed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CLASS(class) \</span><br><span class="hljs-meta">    ((ObjectClass *)(class))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CHECK:</span><br><span class="hljs-comment"> * @type: The C type to use for the return value.</span><br><span class="hljs-comment"> * @obj: A derivative of @type to cast.</span><br><span class="hljs-comment"> * @name: The QOM typename of @type</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A type safe version of @object_dynamic_cast_assert.  Typically each class</span><br><span class="hljs-comment"> * will define a macro based on this type to perform type safe dynamic_casts to</span><br><span class="hljs-comment"> * this object type.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If an invalid object is passed to this function, a run time assert will be</span><br><span class="hljs-comment"> * generated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CHECK(type, obj, name) \</span><br><span class="hljs-meta">    ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \</span><br><span class="hljs-meta">                                        __FILE__, __LINE__, __func__))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CLASS_CHECK:</span><br><span class="hljs-comment"> * @class_type: The C type to use for the return value.</span><br><span class="hljs-comment"> * @class: A derivative class of @class_type to cast.</span><br><span class="hljs-comment"> * @name: the QOM typename of @class_type.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A type safe version of @object_class_dynamic_cast_assert.  This macro is</span><br><span class="hljs-comment"> * typically wrapped by each type to perform type safe casts of a class to a</span><br><span class="hljs-comment"> * specific class type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CLASS_CHECK(class_type, class, name) \</span><br><span class="hljs-meta">    ((class_type *)object_class_dynamic_cast_assert(OBJECT_CLASS(class), (name), \</span><br><span class="hljs-meta">                                               __FILE__, __LINE__, __func__))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_GET_CLASS:</span><br><span class="hljs-comment"> * @class: The C type to use for the return value.</span><br><span class="hljs-comment"> * @obj: The object to obtain the class for.</span><br><span class="hljs-comment"> * @name: The QOM typename of @obj.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function will return a specific class for a given object.  Its generally</span><br><span class="hljs-comment"> * used by each type to provide a type safe macro to get a specific class type</span><br><span class="hljs-comment"> * from an object.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_GET_CLASS(class, obj, name) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(class, object_get_class(OBJECT(obj)), name)</span><br><br></code></pre></td></tr></table></figure>

<p>以<code>OBJECT_DECLARE_TYPE(X86CPU, X86CPUClass, X86_CPU)</code>为例，宏展开如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPU</span> <span class="hljs-title">X86CPU</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPUClass</span> <span class="hljs-title">X86CPUClass</span>;</span><br>G_DEFINE_AUTOPTR_CLEANUP_FUNC(X86CPU, object_unref)<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPU *<span class="hljs-title">X86_CPU</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPU *)object_dynamic_cast_assert(<br>      ((Object *)(obj)), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPUClass *<span class="hljs-title">X86_CPU_GET_CLASS</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPUClass *)object_class_dynamic_cast_assert(<br>      ((ObjectClass *)(object_get_class(((Object *)(obj))))), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPUClass *<span class="hljs-title">X86_CPU_CLASS</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *klass)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPUClass *)object_class_dynamic_cast_assert(<br>      ((ObjectClass *)(klass)), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>OBJECT_DECLARE_TYPE</code>通常在头文件中使用，效果是：</p>
<ul>
<li>创建了<code>X86CPU</code>和<code>X86CPUClass</code>的<code>typedef</code></li>
<li>用<code>G_DEFINE_AUTOPTR_CLEANUP_FUNC</code>注册类型</li>
<li>创建了三个类型转换函数<ul>
<li><code>X86_CPU</code> : 将任何一个 <code>object</code> 指针 转换为 <code>X86CPU</code>（Object 转子对象）</li>
<li><code>X86_CPU_GET_CLASS</code> : 根据 <code>object</code> 指针获取到 <code>X86CPUClass</code></li>
<li><code>X86_CPU_CLASS</code> : 根据 <code>ObjectClass</code> 指针转换到 <code>X86CPUClass</code>（基类转子类）</li>
</ul>
</li>
</ul>
<p>这里的转换依赖内存布局，子类型的第一个成员总是基类型。子类转基类就很容易，只需要强制类型转换就可以实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://martins3.github.io/qemu/qom.html#init">QEMU 中的面向对象 : QOM | Deep Dark Fantasy</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4a9d26abb44d">浅谈 QEMU 的对象系统 - 简书</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/03/01/RGB%E4%B8%8EYUV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/" itemprop="url">RGB 与 YUV 颜色空间</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-03-01T08:00:03.000Z" itemprop="datePublished">3月 1 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 分钟 读完 (约 1022 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>RGB 和 YUV 都属于一种颜色编码方式，或者说颜色空间。</p>
<p>RGB 色彩模式是工业界的一种颜色标准，是通过对红、绿、蓝三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB 即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。</p>
<p>在 YUV 空间中，Y 代表亮度，其实 Y 就是图像的灰度值；UV 代表色差，U 和 V 是构成彩色的两个分量。在现代彩色电视系统中，通常采用三管彩色摄影机或彩色 CCD 摄影机进行取像，然后把取得的彩色图像信号经分色、分别放大校正后得到 RGB，再经过矩阵变换电路得到亮度信号 Y 和两个色差信号 B–Y(即 U)、R–Y(即 V)，最后发送端将亮度和色差三个信号分别进行编码，用同一信道发送出去。这种色彩的表示方法就是所谓的 YUV 色彩空间表示。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="RGB-格式"><a href="#RGB-格式" class="headerlink" title="RGB 格式"></a>RGB 格式</h3><h4 id="RGB16"><a href="#RGB16" class="headerlink" title="RGB16"></a>RGB16</h4><p>RGB16 数据格式主要有二种：RGB565 和 RGB555。</p>
<p>RGB565，每个像素用 16 比特位表示，占 2 个字节，RGB 分量分别使用 5 位、6 位、5 位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//获取高字节的5个bit</span><br>R = color &amp; <span class="hljs-number">0xF800</span>;<br><span class="hljs-comment">//获取中间6个bit</span><br>G = color &amp; <span class="hljs-number">0x07E0</span>;<br><span class="hljs-comment">//获取低字节5个bit</span><br>B = color &amp; <span class="hljs-number">0x001F</span>;<br></code></pre></td></tr></table></figure>

<p>RGB555，每个像素用 16 比特位表示，占 2 个字节，RGB 分量都使用 5 位 (最高位不用)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//获取高字节的5个bit</span><br>R = color &amp; <span class="hljs-number">0x7C00</span>;<br><span class="hljs-comment">//获取中间5个bit</span><br>G = color &amp; <span class="hljs-number">0x03E0</span>;<br><span class="hljs-comment">//获取低字节5个bit</span><br>B = color &amp; <span class="hljs-number">0x001F</span>;<br></code></pre></td></tr></table></figure>

<h4 id="RGB24"><a href="#RGB24" class="headerlink" title="RGB24"></a>RGB24</h4><p>RGB24 图像每个像素用 24 比特位表示，占 3 个字节，注意：在内存中 RGB 各分量的排列顺序为：<strong>BGR BGR BGR</strong>。</p>
<h4 id="RGB32"><a href="#RGB32" class="headerlink" title="RGB32"></a>RGB32</h4><p>RGB32 图像每个像素用 32 比特位表示，占 4 个字节，R，G，B 分量分别用 8 个 bit 表示，存储顺序为 B，G，R，最后 8 个字节保留。注意：在内存中 RGB 各分量的排列顺序为：<strong>BGRA BGRA BGRA</strong> ……。</p>
<p>本质就是带 alpha 通道的 RGB24，与 RGB32 的区别在与，保留的 8 个 bit 用来表示透明，也就是 alpha 的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">R = color &amp; <span class="hljs-number">0x0000FF00</span>;<br>G = color &amp; <span class="hljs-number">0x00FF0000</span>;<br>B = color &amp; <span class="hljs-number">0xFF000000</span>;<br>A = color &amp; <span class="hljs-number">0x000000FF</span>;<br></code></pre></td></tr></table></figure>

<h3 id="YUV-采样"><a href="#YUV-采样" class="headerlink" title="YUV 采样"></a>YUV 采样</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220301170332.png"></p>
<ul>
<li>YUV444：一个像素就有 YUV 三个值，和 RGB 类似；一个 YUV 占 8+8+8 = 24bits 3 个字节。</li>
<li>YUV422：第一个像素有 YUV 三个值，第二个像素只有 Y，与前一个像素共用 UV；一个 YUV 占 8+4+4 = 16bits 2 个字节。</li>
<li>YUV420：上下四个像素共用一个 UV。一个 YUV 占 8+2+2 = 12bits 1.5 个字节。</li>
</ul>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="YUV2RGB"><a href="#YUV2RGB" class="headerlink" title="YUV2RGB"></a>YUV2RGB</h3><p>$$<br>R = Y + 1.403 \times (V-128)\<br>G=Y-0.343 \times (U-128) - 0.714 \times (V-128)\<br>B=Y + 1.770 \times (U-128)<br>$$</p>
<h3 id="RGB2YUV"><a href="#RGB2YUV" class="headerlink" title="RGB2YUV"></a>RGB2YUV</h3><p>$$<br>Y = 0.299 \times R + 0.587 \times G + 0.114 \times B\<br>U = -0.169 \times R - 0.331 \times G + 0.500 \times B + 128\<br>V = 0.500 \times R - 0.419 \times G - 0.081 \times B + 128\<br>$$</p>
<p>浮点型运算比较耗时，将所有运算换成位运算，提高效率。具体推倒过程见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40647819/article/details/92619298">色彩转换系列之 RGB 格式与 YUV 格式互转原理及实现_小武的博客-CSDN 博客_rgb yuv</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">Y= ((R &lt;&lt; <span class="hljs-number">6</span>) + (R &lt;&lt; <span class="hljs-number">3</span>) + (R &lt;&lt; <span class="hljs-number">2</span>) + R + (G &lt;&lt; <span class="hljs-number">7</span>) + (G &lt;&lt; <span class="hljs-number">4</span>) + (G &lt;&lt; <span class="hljs-number">2</span>) + (G &lt;&lt; <span class="hljs-number">1</span>) + (B &lt;&lt; <span class="hljs-number">4</span>) + (B &lt;&lt; <span class="hljs-number">3</span>) + (B &lt;&lt; <span class="hljs-number">2</span>) + B) &gt;&gt; <span class="hljs-number">8</span><br>U= (-((R &lt;&lt; <span class="hljs-number">5</span>) + (R &lt;&lt; <span class="hljs-number">3</span>) + (R &lt;&lt; <span class="hljs-number">1</span>)+ R) - ((G &lt;&lt; <span class="hljs-number">6</span>) + (G &lt;&lt; <span class="hljs-number">4</span>) + (G &lt;&lt; <span class="hljs-number">2</span>)+G) + (B &lt;&lt; <span class="hljs-number">7</span>) + <span class="hljs-number">32768</span>) &gt;&gt; <span class="hljs-number">8</span><br>V= ((R &lt;&lt; <span class="hljs-number">7</span>) - ((G &lt;&lt; <span class="hljs-number">6</span>) + (G &lt;&lt; <span class="hljs-number">5</span>) + (G &lt;&lt; <span class="hljs-number">3</span>) + (G &lt;&lt; <span class="hljs-number">3</span>) + G) - ((B &lt;&lt; <span class="hljs-number">4</span>) + (B &lt;&lt; <span class="hljs-number">2</span>) + B) + <span class="hljs-number">32768</span> )&gt;&gt; <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cd7e73005ac4">RGB 和 YUV - 简书</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengbingchun/article/details/50216901">颜色空间 YUV 简介_网络资源是无限的-CSDN 博客_yuv 颜色空间</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/byhook/article/details/84262330">图解 RGB565、RGB555、RGB16、RGB24、RGB32、ARGB32 等格式的区别_handy 周-CSDN 博客_rgb565</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/byhook/article/details/84037338">图解 YU12、I420、YV12、NV12、NV21、YUV420P、YUV420SP、YUV422P、YUV444P 的区别_handy 周-CSDN 博客_yv12</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="../13/">上一页</a>
    </div>
    <div class="pagination-next">
        <a href="../15/">下一页</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="../../">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="../13/">13</a></li>
        
        <li><a class="pagination-link is-current" href="">14</a></li>
        
        <li><a class="pagination-link" href="../15/">15</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="../27/">27</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2024 Dominic&nbsp;
                powered_by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery > p > .gallery-item').unwrap();
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="../../js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '../../content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="../../js/insight.js"></script>

    
</body>
</html>