<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.131.0"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8888&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>PaperMod</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:8888/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:8888/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:8888/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:8888/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:8888/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:8888/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:8888/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:8888/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:8888/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:8888/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:8888/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:8888/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">C 语言复杂声明
    </h2>
  </header>
  <div class="entry-content">
    <p>C 语言常常因为声明的语法问题而受到人们的批评，特别是涉及到函数指针的语法。C 语言的语法力图使声明和使用相一致。对于简单的情况，C 语言的做法是很有效的，但是，如果情况比较复杂，则容易让人混淆，原因在于，C 语言的声明不能从左至右阅读，而且使用了太多的圆括号。 在 C 中，声明的形式为（dcl 是 declaration 的简写）：
dcl: optional *&#39;s direct-dcl（含有可选&#34;*&#34;的direct-dcl）direct-dcl name(dcl)direct-dcl()direct-dcl[optional size] 简而言之，声明符dc1(可以理解成间接声明) 就是前面可能带有多个*的direcr-dclo。direct-dcl可以是name、由一对圆括号括起来的dcl、后面跟有一对圆括号的direct-dcl、后面跟有用方括号括起来的表示可选长度的direc-dcl。
根据该规则进行逆向解析，就可以得到正确的声明。简化一下：TypeName Declarator;其中，Declarator就是声明中的那个name。当你遇到任何你不能理解的声明时，这个法则就是救命稻草。最简单的例子：
int aInt; 这里，int是TypeName，aInt是Declarator。
再说明一下结合紧密度。在声或定义变量时，可以使用一些修饰比如*，[]，()等。()（非函数声明中的()）具有最高的紧密度，其次才是函数和数组的()和[]。
没有*的声明称为直接声明（direct-dcl），而有*称为声明（dcl）。直接声明要比声明结合的紧。分解声明时，先读出结合紧的。在这里，我把direct-dcl称为更紧的结合，它比dcl结合得紧。
最后，需要你用英语来读出这个声明。对于[]，应该读成array of。
对于复杂的定义，可以将其分解。比如T (*p)()可以分解成T D1()，D1读作：function returning T。其中D1是*p。那么该声明应该读成：p is a poniter to。二者合在一起，就变成了 p is a pointer to function returning T，即：p是指向返回T类对象的函数的指针。
再看一个稍微复杂的示例：
T (*pfa[])(); 根据dcl和direct-dcl，可以分解成T1 D1（因为结合紧密度），T1也就是T ()，那么应该读作： D1 is function returning T。
D1又可以写成T2 D2，其中T2是T1 []，可以分解成T1 D2[]，读作：array of D2 function returning T。
D2是指针，读作：pointers to。那么整个 T (*pfa[])() 应该读作：pfa is an array of pointers to function returning T，即：pfa是个存放指向返回 T 类对象函数的指针的数组。...</p>
  </div>
  <footer class="entry-footer"><span title='2021-10-22 11:02:58 +0000 UTC'>October 22, 2021</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to C 语言复杂声明" href="http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">C 语言共享内存实现 CyclicBuffer 循环缓冲区
    </h2>
  </header>
  <div class="entry-content">
    <p>完整代码详见GitHub CyclicBuffer。
什么是循环缓冲区 循环缓冲区通常应用在模块与模块之间的通信，可以减少程序挂起的时间，节省内存空间。
如图所示，蓝色箭头表示读取指针，红色表示写入指针。写入指针可以在缓冲区有剩余空间时不中断地写入数据，读取指针可以在循环缓冲区有数据时不停读取。
如何设计循环缓冲区 为了方便两个进程之间的通信，我们在共享内存中创建循环缓冲区。基本原理如图：
结构体定义 typedef struct CyclicBuffer { uint8_t buf[CYCBUFFSIZ]; //缓冲区 uint8_t read; //读指针 uint8_t write; //写指针 uint32_t valid_size; //已写入数据数 } CyCBuf; 写入数据 void cycbuff_write(CyCBuf *cycbuff, uint8_t ch) { while (cycbuff_isfull(cycbuff)) ; cycbuff-&gt;buf[cycbuff-&gt;write] = ch; cycbuff-&gt;write&#43;&#43;; cycbuff-&gt;write %= CYCBUFFSIZ; cycbuff-&gt;valid_size&#43;&#43;; } 写入数据前，要检查缓冲区是否已满，如果已满就得挂起等待。直到缓冲区有空间再进行写入。
写入指针每次写完向后偏移一位，valid_size记录当前缓冲区中有效数据个数。
读取数据 uint8_t cycbuff_read(CyCBuf *cycbuff) { uint8_t ch; while (cycbuff_isempty(cycbuff)) ; ch = cycbuff-&gt;buf[cycbuff-&gt;read]; cycbuff-&gt;read&#43;&#43;; cycbuff-&gt;read %= CYCBUFFSIZ; cycbuff-&gt;valid_size--; return ch; } 读取数据前，要检查缓冲区是否为空，如果为空就要挂起等待。
判断空 bool cycbuff_isempty(CyCBuf *cycbuff) { if (cycbuff-&gt;valid_size == 0) return true; return false; } 判断满 bool cycbuff_isfull(CyCBuf *cycbuff) { if (cycbuff-&gt;valid_size == CYCBUFFSIZ) return true; return false; } 本次实验中，为了方便期间，用valid_size保存有效数据个数，没有用读写指针是否重合来判断，这就无需再考虑读写指针重合时，是空还是满。...</p>
  </div>
  <footer class="entry-footer"><span title='2021-10-21 17:12:06 +0000 UTC'>October 21, 2021</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to C 语言共享内存实现 CyclicBuffer 循环缓冲区" href="http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0cyclicbuffer%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">解决 gcc 编译后 fflush 失效
    </h2>
  </header>
  <div class="entry-content">
    <p>保留现场 使用scanf()获取输入时，因为涉及键盘缓冲区的问题，每次输入后想要把缓冲清空，但是在 gcc 编译后，使用fflush无法清空缓冲区。
探究原因 C 标准 (ISO/IEC 9899:1999 standard) 规定fflush(stdin)操作是未定义的&lt;参看《ISO/IEC 9899:1999 standard》p270&gt;;。也就是说不一定能实现刷新功能，但有的编译器可能不遵循标准，对fflush(stdin)操作不予警告，并且有时可能产生正确的结果，但最好不要这样使用。
解决方法 通过 while 循环把输入流中的余留数据“吃”掉：
int c; while ((c=getchar()) != ‘\n’ &amp;&amp; c != EOF); </p>
  </div>
  <footer class="entry-footer"><span title='2021-10-21 09:56:51 +0000 UTC'>October 21, 2021</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 解决 gcc 编译后 fflush 失效" href="http://localhost:8888/posts/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">RISC-V 入门-RVOS 系统引导
    </h2>
  </header>
  <div class="entry-content">
    <p>操作系统定义与分类 操作系统（英语：Operating System，缩写：OS）是一组系统软件程序，狭义上就是内核如 Linux，广义上就是内核加一组软件组成的发行包，如 Ubuntu，Debian：
• 主管并控制计算机操作、运用和运行硬件、软件资源
• 提供公共服务来组织用户交互。
硬件的基本概念 Hart Platform 不能说是个板子，应该理解为芯片。早期的板子就是一块芯片加上各种外设，但是随着技术发展，板子越来越小，外设却并没有变少，是因为外设都被集成到了芯片中。当所有外设都被集成，那么芯片就是 platform。 SoC(System on Chip) 片上系统 QEMU 模拟 virt 这个平台，这个平台有八个 Hart。
地址映射 为了方便访问外设，现在主流的 platform 会对外设的内存地址做一个映射。映射到 platform 的真实物理地址。对真实物理地址进行操作时，就是对外设的地址进行操作。
物理地址从最低位到最高位都被分配给了各种外设。
引导过程介绍 通电后，会先到箭头所指的地址，这个地址就是对应的 ROM 外设首地址。ROM 相当于一个小硬盘，断电后不会丢失数据。这里面固化了一些指令。
主要就是跳转指令，运行到 kernel 段继续执行。
八核同时会执行这个过程。
以上是硬件的部分过程，软件该如何写？
为了简化学习流程和降低调试难度，目前只支持单核，其余七个核处于空转状态。
如何判断当前 Hart 是不是第一个？ 这些寄存器必须使用以下的指令读写：
以上指令就是将寄存器值进行一次交换，只不过这个过程是原子性的，不能被打断。
CSRRW经常会用在伪指令CSRW中，完整指令中，第一步向x0写入数据，就是空操作，第二步将rs写入csr。这个伪指令就是完成了一个写入csr的操作。
mhartid就是machine hart id。
学习以上几个指令，就可以完成判断 hart 是否为第一个的工作了，
csrr t0, mhartid #读寄存器值 mv tp, t0 # bnez t0, park # 跳转指令，不等于 0 就跳转到 park 标签 wfi休眠指令 如何初始化栈空间 如何跳转到 C 语言环境 # start....</p>
  </div>
  <footer class="entry-footer"><span title='2021-10-20 23:13:40 +0000 UTC'>October 20, 2021</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to RISC-V 入门-RVOS 系统引导" href="http://localhost:8888/posts/risc-v%E5%85%A5%E9%97%A8-rvos%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">解决 Segmentation fault (core dumped)
    </h2>
  </header>
  <div class="entry-content">
    <p>相关概念 Core 在使用半导体作为内存的材料前，人类是利用线圈当作内存的材料（发明者为王安），线圈就叫作 core ，用线圈做的内存就叫作 core memory。如今，半导体工业澎勃发展，已经没有人用core memory 了，不过，在许多情况下，人们还是把记忆体叫作 core 。
Core dump 我们在开发（或使用）一个程序时，最怕的就是程序莫明其妙地宕掉。虽然系统没事，但我们下次仍可能遇到相同的问题。于是这时操作系统就会把程序宕掉时的内存内容 dump 出来（现在通常是写在一个叫 core 的 file 里面），让我们做为参考。这个动作就叫作 core dump。
如何获取 Core 文件 1、在一些 Linux 版本下，默认是不产生core文件的，首先可以查看一下系统core文件的大小限制：
$:~/segfault$ ulimit -c0 2、可以看到默认设置情况下，本机 Linux 环境下发生段错误时不会自动生成core文件，下面设置下core文件的大小限制（单位为 KB）：
$:~/segfault$ ulimit -c 1024$:~/segfault$ ulimit -c1024 3、重新运行程序，如果发生段错误，就会生成core文件。
出现段错误的可能原因 访问不存在的内存地址 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void main() { int *ptr = NULL; *ptr = 0; } 访问系统保护的内存地址 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void main() { int *ptr = (int *)0; *ptr = 100; } 访问只读的内存地址 #include&lt;stdio....</p>
  </div>
  <footer class="entry-footer"><span title='2021-10-20 14:23:02 +0000 UTC'>October 20, 2021</span>&nbsp;·&nbsp;4 min</footer>
  <a class="entry-link" aria-label="post link to 解决 Segmentation fault (core dumped)" href="http://localhost:8888/posts/%E8%A7%A3%E5%86%B3segmentation-fault-core-dumped/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:8888/page/38/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:8888/page/40/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:8888/">PaperMod</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
