<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如云泊</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-28T02:46:20.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Dominic</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>uCore-实验第 0 章 - 实验环境搭建</title>
    <link href="http://example.com/2023/09/08/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC0%E7%AB%A0-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2023/09/08/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC0%E7%AB%A0-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2023-09-08T02:46:20.000Z</published>
    <updated>2023-08-28T02:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本次实验是清华大学操作系统课程的课程实验，实验内容是基于 RISC-V 架构的 uCore 操作系统。本次实验的目的是搭建实验环境，为后续实验做准备。指导书参考<a href="https://learningos.github.io/uCore-Tutorial-Guide-2023S/index.html">uCore-Tutorial-Guide-2023S 文档</a>。本系列文章内容主要是指导书的补充以及我在实验过程的一些理解。</p></blockquote><p>本章没有什么需要特别说明的，指导手册十分详细，按照指导手册的步骤一步步来就可以了。因为平时也在用 WSL2 开发，所以配置十分顺利，没有遇到什么问题。这篇文章就当占坑了，如果后续有什么需要补充的再来更新。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本次实验是清华大学操作系统课程的课程实验，实验内容是基于 RISC-V 架构的 uCore 操作系统。本次实验的目的是搭建实验环境，为后续实验做准备。指导书参考&lt;a href=&quot;https://learningos.github.io/uCore-</summary>
      
    
    
    
    <category term="uCore 实验" scheme="http://example.com/categories/uCore-%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="RISC-V" scheme="http://example.com/tags/RISC-V/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="uCore" scheme="http://example.com/tags/uCore/"/>
    
    <category term="Lab" scheme="http://example.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>uCore-实验第 1 章 - 应用程序与基本执行环境</title>
    <link href="http://example.com/2023/09/08/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC1%E7%AB%A0-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2023/09/08/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC1%E7%AB%A0-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/</id>
    <published>2023-09-08T02:45:14.000Z</published>
    <updated>2023-08-28T06:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解系统调用"><a href="#了解系统调用" class="headerlink" title="了解系统调用"></a>了解系统调用</h1><p>操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送请求，来执行一些必须由操作系统来完成的任务，例如读取文件、创建进程、分配内存等。</p><p>通俗地说，可以把操作系统看作一个巨大的服务员，而应用程序就像是顾客。应用程序不能直接访问硬件或执行特权操作，因为这样可能会导致系统不稳定或不安全。所以，应用程序需要通过系统调用来与操作系统进行交互，请求操作系统代表它完成某些任务。</p><p>当应用程序需要操作系统执行特定的功能时，它会调用适当的系统调用函数，并传递参数给它。然后操作系统会接收到这个请求，并根据请求的类型和参数来执行相应的操作。完成后，操作系统会将执行结果返回给应用程序。</p><p><strong>在 RISC-V 架构中</strong>，系统调用是通过使用特定的指令来实现的。具体来说，RISC-V 架构提供了一个称为 <code>ecall</code>（environment call）的指令来触发系统调用。</p><p>要使用 syscall，在 RISC-V 汇编代码中可以通过以下步骤来完成：</p><ol><li>将系统调用编号（syscall number）放入寄存器 a7 中，该编号对应于所需的系统调用功能。</li><li>将系统调用所需的参数放入其他相应的寄存器中。例如，参数传递给文件读取系统调用可能需要将文件描述符放入 a0 寄存器，缓冲区地址放入 a1 寄存器，以及读取的字节数放入 a2 寄存器。</li><li>执行 ecall 指令。这会触发操作系统处理当前运行的程序的系统调用请求。</li><li>操作系统接收到系统调用请求后，根据寄存器 a7 中的系统调用编号和其他寄存器中的参数来执行相应的操作。</li><li>当操作系统完成系统调用请求时，它将结果放入适当的寄存器中，通常是 a0 寄存器。</li><li>程序继续执行，可以检查结果并进行后续的处理。</li></ol><p>需要注意的是，具体的系统调用编号以及参数的传递方式会根据操作系统的实现而有所不同。所以在编写 RISC-V 汇编代码时，需要参考操作系统的相关文档来了解具体的系统调用接口和参数传递方式。</p><h1 id="makr-run-之后发生了什么？"><a href="#makr-run-之后发生了什么？" class="headerlink" title="makr run 之后发生了什么？"></a>makr run 之后发生了什么？</h1><p>当执行<code>make run</code>命令后，以下是运行流程的概述：</p><ol><li><p>内核代码编译：执行<code>make run</code>会触发 Makefile 中的相应规则，从而编译生成内核（kernel）二进制文件。</p></li><li><p>加载 kernel 并启动 QEMU：根据 QEMUOPTS 变量指定的参数，QEMU 加载生成的 kernel 二进制文件，并启动模拟器。</p></li><li><p>引导代码执行：在模拟器启动后，CPU 的通用寄存器被清零，程序计数器（PC）指向 0x1000 的位置，这里有硬件固化的一小段引导代码。该引导代码会迅速跳转到 0x80000000 处的 RustSBI（Rust Supervisor Binary Interface）。</p></li><li><p>RustSBI 完成硬件初始化：RustSBI 是一个用于与操作系统进行交互的接口层。在跳转到 RustSBI 之后，它会完成必要的硬件初始化工作。</p></li><li><p>执行操作系统第一条指令：RustSBI 在完成硬件初始化后，会跳转到 kernel 二进制文件所在内存位置 0x80200000 处，并开始执行我们操作系统的第一条指令。</p></li></ol><p>综上所述，执行<code>make run</code>命令会完成内核的编译和加载，启动 QEMU 虚拟机，并经过引导代码和 RustSBI 的处理，最终开始执行操作系统的第一条指令。</p><h1 id="了解链接脚本"><a href="#了解链接脚本" class="headerlink" title="了解链接脚本"></a>了解链接脚本</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># kernel.ld</span><br><span class="line">BASE_ADDRESS = 0x80200000;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">   . = BASE_ADDRESS;</span><br><span class="line">   skernel = .;</span><br><span class="line"></span><br><span class="line">   stext = .;</span><br><span class="line">   .text : &#123;</span><br><span class="line">      *(.text.entry)   # 第一行代码</span><br><span class="line">      *(.text .text.*)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kernel-ld-中的-BASE-ADDRESS-0x80200000-指定了内核的加载地址，这个地址哪来的？"><a href="#kernel-ld-中的-BASE-ADDRESS-0x80200000-指定了内核的加载地址，这个地址哪来的？" class="headerlink" title="kernel.ld 中的 BASE_ADDRESS = 0x80200000 指定了内核的加载地址，这个地址哪来的？"></a>kernel.ld 中的 <code>BASE_ADDRESS = 0x80200000</code> 指定了内核的加载地址，这个地址哪来的？</h2><p>以下内容摘自参考<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/3first-instruction-in-kernel1.html">rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</a>：</p><p>在 Qemu 模拟的 virt 硬件平台上，物理内存的起始物理地址为 <code>0x80000000</code>，物理内存的默认大小为 128MiB，它可以通过 <code>-m</code> 选项进行配置。如果使用默认配置的 128MiB 物理内存则对应的物理地址区间为 <code>[0x80000000,0x88000000)</code> 。如果使用上面给出的命令启动 Qemu，那么在 Qemu 开始执行任何指令之前，首先把两个文件加载到 Qemu 的物理内存中：即作把作为 bootloader 的 rustsbi-qemu.bin 加载到物理内存以物理地址 <code>0x80000000</code> 开头的区域上，同时把内核镜像 <code>os.bin</code> 加载到以物理地址 <code>0x80200000</code> 开头的区域上。</p><p>为什么加载到这两个位置呢？这与 Qemu 模拟计算机加电启动后的运行流程有关。一般来说，计算机加电之后的启动流程可以分成若干个阶段，每个阶段均由一层软件或 固件 负责，每一层软件或固件的功能是进行它应当承担的初始化工作，并在此之后跳转到下一层软件或固件的入口地址，也就是将计算机的控制权移交给了下一层软件或固件。Qemu 模拟的启动流程则可以分为三个阶段：第一个阶段由固化在 Qemu 内的一小段汇编程序负责；第二个阶段由 bootloader 负责；第三个阶段则由内核镜像负责。</p><p>第一阶段：将必要的文件载入到 Qemu 物理内存之后，Qemu CPU 的程序计数器（PC, Program Counter）会被初始化为 0x1000，因此 Qemu 实际执行的第一条指令位于物理地址 0x1000，接下来它将执行寥寥数条指令并跳转到物理地址 <code>0x80000000</code> 对应的指令处并进入第二阶段。从后面的调试过程可以看出，该地址 <code>0x80000000</code> 被固化在 Qemu 中，作为 Qemu 的使用者，我们在不触及 Qemu 源代码的情况下无法进行更改。</p><p>第二阶段：由于 Qemu 的第一阶段固定跳转到 <code>0x80000000</code>，我们需要将负责第二阶段的 bootloader rustsbi-qemu.bin 放在以物理地址 <code>0x80000000</code> 开头的物理内存中，这样就能保证 <code>0x80000000</code> 处正好保存 bootloader 的第一条指令。在这一阶段，bootloader 负责对计算机进行一些初始化工作，并跳转到下一阶段软件的入口，在 Qemu 上即可实现将计算机控制权移交给我们的内核镜像 os.bin。这里需要注意的是，对于不同的 bootloader 而言，下一阶段软件的入口不一定相同，而且获取这一信息的方式和时间点也不同：入口地址可能是一个预先约定好的固定的值，也有可能是在 bootloader 运行期间才动态获取到的值。我们选用的 RustSBI 则是将下一阶段的入口地址预先约定为固定的 0x80200000，在 RustSBI 的初始化工作完成之后，它会跳转到该地址并将计算机控制权移交给下一阶段的软件——也即我们的内核镜像。</p><p>第三阶段：为了正确地和上一阶段的 RustSBI 对接，我们需要保证内核的第一条指令位于物理地址 <code>0x80200000</code> 处。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 0x80200000 开头的区域上。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核，也就达到了本节的目标。</p><blockquote><p>以上过程是 QEMU 中的启动流程，真实计算机的加电启动流程大致如下：<br>第一阶段：加电后 CPU 的 PC 寄存器被设置为计算机内部只读存储器（ROM，Read-only Memory）的物理地址，随后 CPU 开始运行 ROM 内的软件。我们一般将该软件称为固件（Firmware），它的功能是对 CPU 进行一些初始化操作，将后续阶段的 bootloader 的代码、数据从硬盘载入到物理内存，最后跳转到适当的地址将计算机控制权转移给 bootloader。它大致对应于 Qemu 启动的第一阶段，即在物理地址 0x1000 处放置的若干条指令。可以看到 Qemu 上的固件非常简单，因为它并不需要负责将 bootloader 从硬盘加载到物理内存中，这个任务此前已经由 Qemu 自身完成了。<br>第二阶段：bootloader 同样完成一些 CPU 的初始化工作，将操作系统镜像从硬盘加载到物理内存中，最后跳转到适当地址将控制权转移给操作系统。可以看到一般情况下 bootloader 需要完成一些数据加载工作，这也就是它名字中 loader 的来源。它对应于 Qemu 启动的第二阶段。在 Qemu 中，我们使用的 RustSBI 功能较弱，它并没有能力完成加载的工作，内核镜像实际上是和 bootloader 一起在 Qemu 启动之前加载到物理内存中的。<br>第三阶段：控制权被转移给操作系统。由于篇幅所限后面我们就不再赘述了。<br>值得一提的是，为了让计算机的启动更加灵活，bootloader 目前可能非常复杂：它可能也分为多个阶段，并且能管理一些硬件资源，从复杂性上它已接近一个传统意义上的操作系统。</p></blockquote><h1 id="终端是如何控制颜色的？"><a href="#终端是如何控制颜色的？" class="headerlink" title="终端是如何控制颜色的？"></a>终端是如何控制颜色的？</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LOG_COLOR</span> &#123;</span></span><br><span class="line">RED = <span class="number">31</span>,</span><br><span class="line">GREEN = <span class="number">32</span>,</span><br><span class="line">BLUE = <span class="number">34</span>,</span><br><span class="line">GRAY = <span class="number">90</span>,</span><br><span class="line">YELLOW = <span class="number">93</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_LOG_ERROR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errorf(fmt, ...)                                               \</span></span><br><span class="line"><span class="meta">do &#123;                                                               \</span></span><br><span class="line"><span class="meta">int tid = threadid();                                          \</span></span><br><span class="line"><span class="meta">printf(<span class="meta-string">&quot;\x1b[%dm[%s %d]&quot;</span> fmt <span class="meta-string">&quot;\x1b[0m\n&quot;</span>, RED, <span class="meta-string">&quot;ERROR&quot;</span>, tid,   \</span></span><br><span class="line"><span class="meta">       ##__VA_ARGS__);                                         \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br></pre></td></tr></table></figure><p>ANSI 转义码是一种用于控制终端输出的特殊字符序列。它们由<code>\x1b</code>（或<code>\033</code>）开头，后面跟着一系列数字和分号组成。</p><p>ANSI 转义码中的数字部分用于指定不同的控制操作，如设置文本颜色、背景颜色、光标位置等等。其中，用于设置颜色的转义码包括三个主要的部分：<code>\x1b[颜色代码m</code>。</p><p>具体来说，<code>\x1b[</code>表示开始使用控制序列，接下来的数字代表不同的颜色代码，最后的<code>m</code>表示结束控制序列。例如，<code>\x1b[31m</code>表示将文本颜色设置为红色，而<code>\x1b[0m</code>用于重置所有属性为默认值。</p><p>当终端遇到这样的转义序列时，它会解析并执行相应的控制操作，从而实现对文本颜色、背景颜色和其他属性的控制。</p><p>需要注意的是，不同的终端可能支持不同的 ANSI 转义码，并且不同操作系统也可能有不同的实现。因此，在编写使用 ANSI 转义码的代码时，建议先测试并确保其在目标终端上正常工作。</p><p>更多详细解释可以参考文章：<a href="https://www.jianshu.com/p/790fc612aaa5">终端颜色控制 - 简书</a>。</p><h1 id="应用程序输出字符会调用-SBI-服务，SBI-中发生了什么？"><a href="#应用程序输出字符会调用-SBI-服务，SBI-中发生了什么？" class="headerlink" title="应用程序输出字符会调用 SBI 服务，SBI 中发生了什么？"></a>应用程序输出字符会调用 SBI 服务，SBI 中发生了什么？</h1><blockquote><p>因为对 Rust 语言不熟悉，所以这里的分析是基于 C 语言的 OpenSBI 来分析的，他们的逻辑是一样的。如果有熟悉 Rust 的可以查看 <a href="https://github.com/rustsbi/rustsbi/blob/main/src/instance.rs">RustSBI 源码</a></p></blockquote><p>根据指导书中的解释以及阅读代码，我们知道调用了 <code>printf</code> 最终实际上是调用了 <code>sbi_call</code>。那么 <code>sbi_call</code> 是如何实现的呢？因为我是做驱动开发以及固件开发的，也经常需要使用 OpenSBI，所想多问一句，OpenSBI 是如何实现的呢？OpenSBI 是如何提供服务的呢？它是如何打印出字符的呢？</p><h2 id="内核中的-SBI-调用"><a href="#内核中的-SBI-调用" class="headerlink" title="内核中的 SBI 调用"></a>内核中的 SBI 调用</h2><p>我们先看一下内核中的 <code>sbi_call</code> 都做了写啥。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uCore-Tutorial-Code-2023S/os/sbi.c</span></span><br><span class="line"><span class="keyword">const</span> uint64 SBI_CONSOLE_PUTCHAR = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">console_putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sbi_call(SBI_CONSOLE_PUTCHAR, c, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uCore-Tutorial-Code-2023S/os/sbi.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">inline</span> <span class="title">sbi_call</span><span class="params">(uint64 which, uint64 arg0, uint64 arg1, uint64 arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用寄存器变量来保存参数值和系统调用编号</span></span><br><span class="line">    <span class="function"><span class="keyword">register</span> uint64 a0 <span class="title">asm</span><span class="params">(<span class="string">&quot;a0&quot;</span>)</span> </span>= arg0;  <span class="comment">// 将 &#x27;arg0&#x27; 的值保存在寄存器 &#x27;a0&#x27; 中</span></span><br><span class="line">    <span class="function"><span class="keyword">register</span> uint64 a1 <span class="title">asm</span><span class="params">(<span class="string">&quot;a1&quot;</span>)</span> </span>= arg1;  <span class="comment">// 将 &#x27;arg1&#x27; 的值保存在寄存器 &#x27;a1&#x27; 中</span></span><br><span class="line">    <span class="function"><span class="keyword">register</span> uint64 a2 <span class="title">asm</span><span class="params">(<span class="string">&quot;a2&quot;</span>)</span> </span>= arg2;  <span class="comment">// 将 &#x27;arg2&#x27; 的值保存在寄存器 &#x27;a2&#x27; 中</span></span><br><span class="line">    <span class="function"><span class="keyword">register</span> uint64 a7 <span class="title">asm</span><span class="params">(<span class="string">&quot;a7&quot;</span>)</span> </span>= which; <span class="comment">// 将 &#x27;which&#x27; 的值保存在寄存器 &#x27;a7&#x27; 中</span></span><br><span class="line">    <span class="comment">// 内联汇编代码使用 ecall 指令进行系统调用</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;ecall&quot;</span>  <span class="comment">// 使用 ecall 指令进行系统调用</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 在这段代码中，指令 &quot;ecall&quot; 的输入参数是寄存器 a0 a1 a2 和 a7，输出参数是寄存器 a0</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;=r&quot;</span>(a0)  <span class="comment">// 输出操作数：将返回值存储在变量 &#x27;a0&#x27; 中</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;r&quot;</span>(a0), <span class="string">&quot;r&quot;</span>(a1), <span class="string">&quot;r&quot;</span>(a2), <span class="string">&quot;r&quot;</span>(a7)  <span class="comment">// 输入操作数：传递参数和系统调用编号</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;memory&quot;</span>  <span class="comment">//  &quot;memory&quot; 标志告诉编译器，这条指令可能会修改内存中的数据，需要进行内存屏障操作来保证数据的正确性。 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a0;  <span class="comment">// 返回存储在变量 &#x27;a0&#x27; 中的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 OpenSBI 如何提供服务？在<code>include/sbi/sbi_ecall.h</code>这种定义了每个<code>ecall</code>服务全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/sbi/sbi_ecall.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_base</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_legacy</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_time</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_rfence</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_ipi</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_vendor</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_hsm</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_srst</span>;</span></span><br></pre></td></tr></table></figure><p>在<code>lib/sbi/sbi_ecall.c</code>中注册了所有的<code>ecall</code>服务，并将其加到链表<code>ecall_exts_list</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbi_ecall_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The order of below registrations is performance optimized */</span></span><br><span class="line">ret = sbi_ecall_register_extension(&amp;ecall_time);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">ret = sbi_ecall_register_extension(&amp;ecall_rfence);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">ret = sbi_ecall_register_extension(&amp;ecall_ipi);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">ret = sbi_ecall_register_extension(&amp;ecall_base);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">ret = sbi_ecall_register_extension(&amp;ecall_hsm);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">ret = sbi_ecall_register_extension(&amp;ecall_srst);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">ret = sbi_ecall_register_extension(&amp;ecall_legacy);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">ret = sbi_ecall_register_extension(&amp;ecall_vendor);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么服务 id 如何和相对应的服务绑定的呢？以<code>ecall_time</code>为例，查看其结构体原型<code>struct sbi_ecall_extension</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/sbi/sbi_ecall.h: 23</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sbi_dlist</span> <span class="title">head</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> extid_start;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> extid_end;</span><br><span class="line">        <span class="keyword">int</span> (* probe)(<span class="keyword">unsigned</span> <span class="keyword">long</span> extid, <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_val);</span><br><span class="line">        <span class="keyword">int</span> (* handle)(<span class="keyword">unsigned</span> <span class="keyword">long</span> extid, <span class="keyword">unsigned</span> <span class="keyword">long</span> funcid,</span><br><span class="line">                       <span class="keyword">const</span> struct sbi_trap_regs *regs,</span><br><span class="line">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_val,</span><br><span class="line">                       struct sbi_trap_info *out_trap);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到有 <code>extid_start</code>、<code>extid_end</code> 和 <code>handle</code>。在找到<code>ecall_timer</code>的初始化代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/sbi/sbi_ecall_replace.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_time</span> =</span> &#123;</span><br><span class="line">        .extid_start = SBI_EXT_TIME,</span><br><span class="line">        .extid_end = SBI_EXT_TIME,</span><br><span class="line">        .handle = sbi_ecall_time_handler,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sbi_ecall_time_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> extid, <span class="keyword">unsigned</span> <span class="keyword">long</span> funcid,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> struct sbi_trap_regs *regs,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_val,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct sbi_trap_info *out_trap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (funcid == SBI_EXT_TIME_SET_TIMER) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __riscv_xlen == 32</span></span><br><span class="line">sbi_timer_event_start((((u64)regs-&gt;a1 &lt;&lt; <span class="number">32</span>) | (u64)regs-&gt;a0));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">sbi_timer_event_start((u64)regs-&gt;a0);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">ret = SBI_ENOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就把 <code>id</code> 与相应的服务函数绑定。一个<code>extid</code>对应一个<code>handler</code>。</p><p>我们可以在找到<code>SBI_EXT_TIME</code>的值，是与 Linux 内核里定义的值是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/sbi/sbi_ecall_interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SBI_EXT_TIME0x54494D45</span></span><br></pre></td></tr></table></figure><h2 id="ecall-服务调用流程"><a href="#ecall-服务调用流程" class="headerlink" title="ecall 服务调用流程"></a>ecall 服务调用流程</h2><ol><li><p>在 <code>firmware/fw_base.S</code> 中注册了 <code>Machine Mode</code> 的 <code>trap handler</code>，即 <code>sbi_trap_handler</code>；</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">_start_warm:</span><br><span class="line">    /* Setup trap handler */</span><br><span class="line">    laa4, _trap_handler</span><br><span class="line">    csrwCSR_MTVEC, a4  /* CSR_MTVEC = _trap_handler */</span><br><span class="line"></span><br><span class="line">_trap_handler:</span><br><span class="line">    TRAP_SAVE_AND_SETUP_SP_T0</span><br><span class="line"></span><br><span class="line">    TRAP_SAVE_MEPC_MSTATUS 0</span><br><span class="line"></span><br><span class="line">    TRAP_SAVE_GENERAL_REGS_EXCEPT_SP_T0</span><br><span class="line"></span><br><span class="line">    TRAP_CALL_C_ROUTINE</span><br><span class="line"></span><br><span class="line">    TRAP_RESTORE_GENERAL_REGS_EXCEPT_SP_T0</span><br><span class="line"></span><br><span class="line">    TRAP_RESTORE_MEPC_MSTATUS 0</span><br><span class="line"></span><br><span class="line">    TRAP_RESTORE_SP_T0</span><br><span class="line"></span><br><span class="line">    mret</span><br><span class="line"></span><br><span class="line">.macroTRAP_CALL_C_ROUTINE</span><br><span class="line">    /* Call C routine */</span><br><span class="line">    adda0, sp, zero</span><br><span class="line">    callsbi_trap_handler</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure></li><li><p>在 <code>lib/sbi/sbi_trap.c</code> 中定义了 <code>sbi_trap_handler</code>，处理各种 <code>mcause</code>，比如 <code>Illegal Instructions</code>，<code>Misaligned Load &amp; Store</code>, <code>Supervisor &amp; Machine Ecall</code> 等。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbi_trap_handler</span><span class="params">(struct sbi_trap_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mcause) &#123;</span><br><span class="line">    <span class="keyword">case</span> CAUSE_ILLEGAL_INSTRUCTION:</span><br><span class="line">        rc  = sbi_illegal_insn_handler(mtval, regs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CAUSE_MISALIGNED_LOAD:</span><br><span class="line">        rc = sbi_misaligned_load_handler(mtval, mtval2, mtinst, regs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CAUSE_MISALIGNED_STORE:</span><br><span class="line">        rc  = sbi_misaligned_store_handler(mtval, mtval2, mtinst, regs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CAUSE_SUPERVISOR_ECALL:</span><br><span class="line">    <span class="keyword">case</span> CAUSE_MACHINE_ECALL:</span><br><span class="line">        rc  = sbi_ecall_handler(regs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* If the trap came from S or U mode, redirect it there */</span></span><br><span class="line">        trap.epc = regs-&gt;mepc;</span><br><span class="line">        trap.cause = mcause;</span><br><span class="line">        trap.tval = mtval;</span><br><span class="line">        trap.tval2 = mtval2;</span><br><span class="line">        trap.tinst = mtinst;</span><br><span class="line">        rc = sbi_trap_redirect(regs, &amp;trap);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>在 <code>lib/sbi/sbi_ecall.c</code> 中定义了处理 <code>ecall mcause</code> 的 <code>sbi_ecall_handler</code>，它遍历上面 <code>ecall_exts_list</code> 中注册的各种 <code>ecall</code> 服务。</p></li><li><p><code>sbi_ecall_handler</code> 根据 Linux 内核传递的 <code>ext (extension id)</code> 找到链表中对应的 <code>ecall</code> 服务，执行其中的 <code>handle</code> 函数，该函数根据 <code>fid</code> 执行具体的服务内容。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbi_ecall_handler</span><span class="params">(struct sbi_trap_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有 ecall 服务</span></span><br><span class="line">    ext = sbi_ecall_find_extension(extension_id);</span><br><span class="line">    <span class="keyword">if</span> (ext &amp;&amp; ext-&gt;handle) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了就执行</span></span><br><span class="line">        ret = ext-&gt;handle(extension_id, func_id,</span><br><span class="line">                regs, &amp;out_val, &amp;trap);</span><br><span class="line">        <span class="keyword">if</span> (extension_id &gt;= SBI_EXT_0_1_SET_TIMER &amp;&amp;</span><br><span class="line">            extension_id &lt;= SBI_EXT_0_1_SHUTDOWN)</span><br><span class="line">            is_0_1_spec = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = SBI_ENOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="程序的内存布局与编译流程"><a href="#程序的内存布局与编译流程" class="headerlink" title="程序的内存布局与编译流程"></a>程序的内存布局与编译流程</h1><h2 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h2><h1 id="uCore-的编译系统"><a href="#uCore-的编译系统" class="headerlink" title="uCore 的编译系统"></a>uCore 的编译系统</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean build user</span></span><br><span class="line"><span class="comment"># 设置伪目标clean、build和user，可以通过命令make来执行这些目标</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: build_kernel</span></span><br><span class="line"><span class="comment"># 默认目标为build_kernel，即执行build_kernel目标下的指令</span></span><br><span class="line"></span><br><span class="line">LOG ?= error</span><br><span class="line"><span class="comment"># 定义一个变量LOG，默认值是error</span></span><br><span class="line"></span><br><span class="line">K = os</span><br><span class="line">TOOLPREFIX = riscv64-unknown-elf-</span><br><span class="line"></span><br><span class="line">CC = <span class="variable">$(TOOLPREFIX)</span>gcc</span><br><span class="line">AS = <span class="variable">$(TOOLPREFIX)</span>gcc</span><br><span class="line">LD = <span class="variable">$(TOOLPREFIX)</span>ld</span><br><span class="line">OBJCOPY = <span class="variable">$(TOOLPREFIX)</span>objcopy</span><br><span class="line">OBJDUMP = <span class="variable">$(TOOLPREFIX)</span>objdump</span><br><span class="line">PY = python3</span><br><span class="line">GDB = <span class="variable">$(TOOLPREFIX)</span>gdb</span><br><span class="line">CP = cp</span><br><span class="line"></span><br><span class="line">MKDIR_P = mkdir -p</span><br><span class="line"></span><br><span class="line">BUILDDIR = build</span><br><span class="line"></span><br><span class="line">C_SRCS = <span class="variable">$(<span class="built_in">wildcard</span> $K/*.c)</span></span><br><span class="line"><span class="comment"># 定义一个变量C_SRCS，使用wildcard函数匹配所有以.c为后缀的文件，并存储在$K目录下</span></span><br><span class="line"></span><br><span class="line">AS_SRCS = <span class="variable">$(<span class="built_in">wildcard</span> $K/*.S)</span></span><br><span class="line"><span class="comment"># 定义一个变量AS_SRCS，使用wildcard函数匹配所有以.S为后缀的文件，并存储在$K目录下</span></span><br><span class="line"></span><br><span class="line">C_OBJS = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BUILDDIR)</span>/, $(<span class="built_in">addsuffix</span> .o, $(<span class="built_in">basename</span> <span class="variable">$(C_SRCS)</span>)</span>))</span><br><span class="line"><span class="comment"># 定义一个变量C_OBJS，通过addprefix和addsuffix函数将$(C_SRCS)中的路径替换为$(BUILDDIR)，并将后缀修改为.o</span></span><br><span class="line"></span><br><span class="line">AS_OBJS = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BUILDDIR)</span>/, $(<span class="built_in">addsuffix</span> .o, $(<span class="built_in">basename</span> <span class="variable">$(AS_SRCS)</span>)</span>))</span><br><span class="line"><span class="comment"># 定义一个变量AS_OBJS，通过addprefix和addsuffix函数将$(AS_SRCS)中的路径替换为$(BUILDDIR)，并将后缀修改为.o</span></span><br><span class="line"></span><br><span class="line">OBJS = <span class="variable">$(C_OBJS)</span> <span class="variable">$(AS_OBJS)</span></span><br><span class="line"><span class="comment"># 定义一个变量OBJS，其值为$(C_OBJS)和$(AS_OBJS)的组合</span></span><br><span class="line"></span><br><span class="line">HEADER_DEP = <span class="variable">$(<span class="built_in">addsuffix</span> .d, $(<span class="built_in">basename</span> <span class="variable">$(C_OBJS)</span>)</span>)</span><br><span class="line"><span class="comment"># 定义一个变量HEADER_DEP，通过addsuffix函数将$(C_OBJS)中的后缀修改为.d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(HEADER_DEP)</span></span><br><span class="line"><span class="comment"># 包含$(HEADER_DEP)中的.d文件</span></span><br><span class="line"></span><br><span class="line">CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb</span><br><span class="line"><span class="comment"># 定义一个变量CFLAGS，并赋值为-Wall -Werror -O -fno-omit-frame-pointer -ggdb</span></span><br><span class="line"></span><br><span class="line">CFLAGS += -MD</span><br><span class="line"><span class="comment"># 将-MD选项追加到CFLAGS变量中，用于自动生成依赖关系文件</span></span><br><span class="line"></span><br><span class="line">CFLAGS += -mcmodel=medany</span><br><span class="line"><span class="comment"># 将-mcmodel=medany选项追加到CFLAGS变量中，用于指定内存模型</span></span><br><span class="line"></span><br><span class="line">CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax</span><br><span class="line"><span class="comment"># 将-ffreestanding -fno-common -nostdlib -mno-relax选项追加到CFLAGS变量中，用于编译无操作系统环境下的程序</span></span><br><span class="line"></span><br><span class="line">CFLAGS += -I$K</span><br><span class="line"><span class="comment"># 将-I$K选项追加到CFLAGS变量中，用于指定头文件搜索路径为$K目录下</span></span><br><span class="line"></span><br><span class="line">CFLAGS += <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span></span><br><span class="line"><span class="comment"># 将$(CC) -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector命令执行结果追加到CFLAGS变量中，用于禁用栈保护机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(LOG)</span>, error)</span><br><span class="line">CFLAGS += -D LOG_LEVEL_ERROR</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(LOG)</span>, warn)</span><br><span class="line">CFLAGS += -D LOG_LEVEL_WARN</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(LOG)</span>, info)</span><br><span class="line">CFLAGS += -D LOG_LEVEL_INFO</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(LOG)</span>, debug)</span><br><span class="line">CFLAGS += -D LOG_LEVEL_DEBUG</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(LOG)</span>, trace)</span><br><span class="line">CFLAGS += -D LOG_LEVEL_TRACE</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># 根据$(LOG)变量的值，向CFLAGS变量追加相应的预处理器选项，相当于添加了一个宏定义，log.h中的LOG_LEVEL_ERROR等宏定义会根据这个宏定义来决定是否生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable PIE when possible (for Ubuntu 16.10 toolchain)</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> -dumpspecs 2&gt;/dev/null | grep -e &#x27;[^f]no-pie&#x27;)</span>,)</span><br><span class="line">CFLAGS += -fno-pie -no-pie</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> -dumpspecs 2&gt;/dev/null | grep -e &#x27;[^f]nopie&#x27;)</span>,)</span><br><span class="line">CFLAGS += -fno-pie -nopie</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># 根据系统环境判断是否支持PIE（位置无关执行）选项，并根据情况向CFLAGS变量追加相应的选项</span></span><br><span class="line"></span><br><span class="line">LDFLAGS = -z max-page-size=4096</span><br><span class="line"><span class="comment"># 定义一个变量LDFLAGS，并赋值为-z max-page-size=4096</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(AS_OBJS)</span>: <span class="variable">$(BUILDDIR)</span>/$K/%.o : $K/%.S</span><br><span class="line">    @mkdir -p $(@D)</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 规则：生成$(AS_OBJS)目标所需的依赖文件$(BUILDDIR)/$K/%.o，依赖于$K/%.S，并通过$(CC)命令编译生成目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(C_OBJS)</span>: <span class="variable">$(BUILDDIR)</span>/$K/%.o : $K/%.c  <span class="variable">$(BUILDDIR)</span>/$K/%.d</span><br><span class="line">    @mkdir -p $(@D)</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 规则：生成$(C_OBJS)目标所需的依赖文件$(BUILDDIR)/$K/%.o，依赖于$K/%.c和$(BUILDDIR)/$K/%.d，并通过$(CC)命令编译生成目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(HEADER_DEP)</span>: <span class="variable">$(BUILDDIR)</span>/$K/%.d : $K/%.c</span><br><span class="line">    @mkdir -p $(@D)</span><br><span class="line">    @set -e; rm -f <span class="variable">$@</span>; <span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> <span class="variable">$(INCLUDEFLAGS)</span> &gt; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">        sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>; \</span><br><span class="line">        rm -f <span class="variable">$@</span>.$$$$</span><br><span class="line"><span class="comment"># 规则：生成$(HEADER_DEP)目标所需的依赖文件$(BUILDDIR)/$K/%.d，依赖于$K/%.c，并通过$(CC)命令生成依赖关系文件</span></span><br><span class="line"></span><br><span class="line"><span class="section">build: build/kernel</span></span><br><span class="line"><span class="comment"># 定义一个目标build，其依赖于build/kernel</span></span><br><span class="line"></span><br><span class="line"><span class="section">build/kernel: <span class="variable">$(OBJS)</span></span></span><br><span class="line">    <span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T os/kernel.ld -o <span class="variable">$(BUILDDIR)</span>/kernel <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(BUILDDIR)</span>/kernel &gt; <span class="variable">$(BUILDDIR)</span>/kernel.asm</span><br><span class="line">    <span class="variable">$(OBJDUMP)</span> -t <span class="variable">$(BUILDDIR)</span>/kernel | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(BUILDDIR)</span>/kernel.sym</span><br><span class="line">    @echo &#x27;Build kernel done&#x27;</span><br><span class="line"><span class="comment"># 规则：生成build/kernel目标，依赖于$(OBJS)，通过$(LD)命令连接生成kernel，并通过$(OBJDUMP)命令生成汇编文件和符号表</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(BUILDDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BOARD</span></span><br><span class="line">BOARD?= qemu</span><br><span class="line">SBI?= rustsbi</span><br><span class="line">BOOTLOADER:= ./bootloader/rustsbi-qemu.bin</span><br><span class="line"></span><br><span class="line">QEMU = qemu-system-riscv64</span><br><span class="line">QEMUOPTS = \</span><br><span class="line">-nographic \</span><br><span class="line">-machine virt \</span><br><span class="line">-bios <span class="variable">$(BOOTLOADER)</span> \</span><br><span class="line">-kernel build/kernel\</span><br><span class="line"></span><br><span class="line"><span class="section">run: build/kernel</span></span><br><span class="line"><span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># QEMU&#x27;s gdb stub command line changed in 0.11</span></span><br><span class="line">QEMUGDB = <span class="variable">$(<span class="built_in">shell</span> <span class="built_in">if</span> <span class="variable">$(QEMU)</span> -help | grep -q &#x27;^-gdb&#x27;; \</span></span><br><span class="line"><span class="variable">then echo &quot;-gdb tcp::15234&quot;; \</span></span><br><span class="line"><span class="variable">else echo &quot;-s -p 15234&quot;; fi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动QEMU并通过GDB调试，此时QEMu会进入后台运行，并暂停执行，等待GDB连接</span></span><br><span class="line"><span class="comment"># 连接的GDB端口为15234</span></span><br><span class="line"><span class="section">debug: build/kernel .gdbinit</span></span><br><span class="line"><span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span> -S <span class="variable">$(QEMUGDB)</span> &amp;</span><br><span class="line">sleep 1</span><br><span class="line"><span class="variable">$(GDB)</span></span><br></pre></td></tr></table></figure><p>编译、运行 uCore 的一些常用命令有如下一些，涉及了后续章节中引入的测试用例中的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">make run</span><br><span class="line">make debug</span><br><span class="line">make clean</span><br><span class="line"><span class="comment"># 编译测试用例的前四章</span></span><br><span class="line">make user CHAPTER=4 LOG=trace</span><br><span class="line"><span class="comment"># 编译测试用例的第四章</span></span><br><span class="line">make user CHAPTER=4_only LOG=trace</span><br><span class="line"><span class="comment"># 只运行测试用例的第四章</span></span><br><span class="line">make <span class="built_in">test</span> CHAPTER=4_only    </span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>makefile 和 qemu</p><p>AS = $(TOOLPREFIX)gas  &gt; AS = $(TOOLPREFIX)as</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.jianshu.com/p/790fc612aaa5">终端颜色控制 - 简书</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;了解系统调用&quot;&gt;&lt;a href=&quot;#了解系统调用&quot; class=&quot;headerlink&quot; title=&quot;了解系统调用&quot;&gt;&lt;/a&gt;了解系统调用&lt;/h1&gt;&lt;p&gt;操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送</summary>
      
    
    
    
    <category term="uCore 实验" scheme="http://example.com/categories/uCore-%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="RISC-V" scheme="http://example.com/tags/RISC-V/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="uCore" scheme="http://example.com/tags/uCore/"/>
    
    <category term="Lab" scheme="http://example.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>uCore 实验第 5 章 - 进程及进程管理</title>
    <link href="http://example.com/2023/09/08/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC5%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/09/08/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC5%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2023-09-08T02:01:20.000Z</published>
    <updated>2023-09-09T04:01:37.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>本章任务：<br>在次 -&gt; 在此</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;附录&quot;&gt;&lt;a href=&quot;#附录&quot; class=&quot;headerlink&quot; title=&quot;附录&quot;&gt;&lt;/a&gt;附录&lt;/h1&gt;&lt;p&gt;本章任务：&lt;br&gt;在次 -&amp;gt; 在此&lt;/p&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://c</summary>
      
    
    
    
    <category term="uCore 实验" scheme="http://example.com/categories/uCore-%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="RISC-V" scheme="http://example.com/tags/RISC-V/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="uCore" scheme="http://example.com/tags/uCore/"/>
    
    <category term="Lab" scheme="http://example.com/tags/Lab/"/>
    
    <category term="进程管理" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    <category term="进程" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="多进程" scheme="http://example.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>uCore 实验第 4 章 - 地址空间</title>
    <link href="http://example.com/2023/09/04/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC4%E7%AB%A0-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    <id>http://example.com/2023/09/04/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC4%E7%AB%A0-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</id>
    <published>2023-09-04T03:11:48.000Z</published>
    <updated>2023-09-09T04:01:37.232Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为何指定 TRAMPOLINE 和 TRAPFRAME 在 va 的最高位？<br>TRAMPOLINE 和 TRAPFRAME 被定义在最高的虚拟内存地址上，是因为它们在操作系统的内存布局中起着重要作用。<br>TRAMPOLINE 被用作从用户模式切换到内核模式的跳转目标。当发生异常或中断时，处理器将从用户模式切换到内核模式，并将控制权转移到内核中预定义的位置，也就是陷阱处理程序。TRAMPOLINE 页面被映射到最高虚拟地址，以便处理器能够在这个转换过程中方便地引用它。通过将其放置在最高地址，确保了无论系统的具体内存布局如何，它始终是可访问的。<br>另一方面，TRAPFRAME 用于在发生异常或中断时存储机器状态。它包含寄存器、标志和其他操作系统处理异常所需的信息。TRAPFRAME 也被放置在最高的虚拟地址上，以确保它易于访问，并且陷阱处理程序可以高效地访问它。<br>通过将 TRAMPOLINE 和 TRAPFRAME 定义在最高的虚拟内存地址上，内核可以方便而可靠地处理异常和中断，而无需关心它们在内存中的特定位置。</p></blockquote><h1 id="如何确定分页方案-satp"><a href="#如何确定分页方案-satp" class="headerlink" title="如何确定分页方案 - satp"></a>如何确定分页方案 - satp</h1><p>在 MMU 没有使能的情况下，虚拟地址和物理地址是相同的。在 MMU 使能的情况下，虚拟地址会被转换成物理地址。这个转换过程是由操作系统来管理的，操作系统需要维护一个数据结构来记录虚拟地址和物理地址的映射关系。这个数据结构就是页表。</p><p>转换的过程需要分页机制，分页机制有多种。RISC-V 的分页方案以 SvX 的模式命名，其中 X 是以位为单位的<strong>虚拟地址的长度</strong>。在 RV64 架构下，RISC-V 支持多种分页方案，包括 Sv39，Sv48，Sv57 以及 Sv64。Sv39 最大支持 39 位的虚拟地址，这意味着它可以支持 512 GB 的虚拟地址空间。Sv48 最大支持 48 位的虚拟地址，这意味着它可以支持 256 TB 的虚拟地址空间。我们将在本章中实现 Sv39 分页方案。</p><p>如何开启分页机制呢？RISC-V 的分页机制是通过 satp（Supervisor address translation and protection）寄存器来开启的。satp 寄存器字段分布如下：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/09/05/5d1ec6e9adaf743f7c9abc177cd12eb1.png" title="RV64 架构下的 satp 寄存器"></p><ul><li>Mode 字段可以决定是否开启分页以及分页级数。Mode=0 时，不开启分页；Mode=8 时，开启 Sv39 分页机制。</li><li>ASID（Address Space Identifier，地址空间标识符）域是可选的，它可以用来降低上下文切换的开销。目前我们暂不考虑这个字段的作用。</li><li>PPN（Physical Page Number，物理页号），保存了根页表的物理地址。</li></ul><h1 id="SV39-多级页表机制"><a href="#SV39-多级页表机制" class="headerlink" title="SV39 多级页表机制"></a>SV39 多级页表机制</h1><h2 id="页表项描述"><a href="#页表项描述" class="headerlink" title="页表项描述"></a>页表项描述</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/09/05/86e06238c562bdd238e868fcd819df3c.png" title="Sv39 页表项"></p><p>Sv39 页表项（page-table entry，PTE）的布局，从左到右分别包含如下所述的域：</p><ul><li>V 位决定了该页表项的其余部分是否有效 (V=1 时有效)。若 V=0，则任何遍历到此页表项的虚址转换操作都会导致页错误。</li><li>R、W 和 X 位分别表示此页是否可以读取、写入和执行。如果这三个位都是 0，那么这个页表项是指向下一级页表的指针，否则它是页表树的一个叶节点。</li><li>U 位表示该页是否是用户页面。若 U=0，则 U 模式不能访问此页面，但 S 模式可以。若 U=1，则 U 模式下能访问这个页面，而 S 模式不能。</li><li>G 位表示这个映射是否对所有虚址空间有效，硬件可以用这个信息来提高地址转换的性能。这一位通常只用于属于操作系统的页面。</li><li>A 位表示自从上次 A 位被清除以来，该页面是否被访问过。</li><li>D 位表示自从上次清除 D 位以来页面是否被弄脏（例如被写入）。</li><li>RSW 域留给操作系统使用，它会被硬件忽略。</li><li>PPN 域包含物理页号，这是物理地址的一部分。若这个页表项是一个叶节点，那么 PPN 是转换后物理地址的一部分。否则 PPN 给出下一节页表的地址。</li></ul><h2 id="虚拟地址转换物理地址过程"><a href="#虚拟地址转换物理地址过程" class="headerlink" title="虚拟地址转换物理地址过程"></a>虚拟地址转换物理地址过程</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/09/05/48e6ce48ffb827a10371344ad07324c2.png"></p><p>当 satp 寄存器中开启分页时，S 模式和 U 模式中访存的地址都会被视为虚拟地址，需要将其转换为物理地址。虚拟地址转换物理地址的过程如下：</p><ul><li>从 satp 寄存器中读取 PPN，得到根页表的物理地址，为了表述方便，我们将其记做三级页表基地址 satp.PPN；</li><li>从虚拟地址中取出三级虚拟页号 L2</li><li>处理器会读取地址位于 satp.PPN * 4096 + L2 * 4 的页表项，得到下一级页表的基地址 L1.PPN；</li><li>从虚拟地址中取出二级虚拟页号 L1</li><li>处理器会读取地址位于 L1.PPN * 4096 + L1 * 4 的页表项，得到下一级页表的基地址 L0.PPN；</li><li>从虚拟地址中取出一级虚拟页号 L0</li><li>处理器会读取地址位于 L0.PPN * 4096 + L0 * 4 的页表项，得到物理页号 PPN；</li><li>将 PPN 和虚拟地址的低 12 位也就是 Offset 拼接起来，得到物理地址。</li></ul><p>我们看代码中是如何实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="comment">// 从虚拟地址中提取三个 9 位的页表索引</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXMASK 0x1FF <span class="comment">// 9</span></span></span><br><span class="line"><span class="comment">// PGSHIFT = 12，这段宏定义用于定位 VPNx 的位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXSHIFT(level) (PGSHIFT + (9 * (level)))</span></span><br><span class="line"><span class="comment">// 从虚拟地址 VA 中提取出第 level 级页表的索引</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PX(level, va) ((((uint64)(va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br></pre></td></tr></table></figure><p>上面这三个工具宏可以用来提取虚拟页号 VPN。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 返回页表 pagetable 中与虚拟地址 va 对应的 PTE 的地址。</span></span><br><span class="line"><span class="comment">// 如果 alloc != 0，则创建所需的页表页。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RISC-V Sv39 方案有三级页表页。一个页表页包含 512 个 64 位的 PTEs。</span></span><br><span class="line"><span class="comment">// 一个 64 位的虚拟地址被分为五个字段：</span></span><br><span class="line"><span class="comment">//   39..63 -- 必须为零。</span></span><br><span class="line"><span class="comment">//   30..38 -- 2 级索引的 9 位。</span></span><br><span class="line"><span class="comment">//   21..29 -- 1 级索引的 9 位。</span></span><br><span class="line"><span class="comment">//   12..20 -- 0 级索引的 9 位。</span></span><br><span class="line"><span class="comment">//    0..11 -- 页面内的 12 位字节偏移量。</span></span><br><span class="line"><span class="comment">// pagetable 页表</span></span><br><span class="line"><span class="comment">// va 虚拟地址</span></span><br><span class="line"><span class="comment">// alloc 页表项不存在时是否分配</span></span><br><span class="line"><span class="function"><span class="keyword">pte_t</span> *<span class="title">walk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, <span class="keyword">int</span> alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= MAXVA)</span><br><span class="line">        panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">        <span class="comment">// 通过 PTE 的标志位判断每一级的 pte 是否是有效的（V 位）</span></span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_V) &#123;</span><br><span class="line">            pagetable = (<span class="keyword">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果该项无效且 alloc 标志被设置，则分配一个新的页表</span></span><br><span class="line">            <span class="comment">// 如果 alloc 参数=0 或者已经没有空闲的内存了，那么遇到中途 V=0 的 pte 整个 walk 过程就会直接退出</span></span><br><span class="line">            <span class="keyword">if</span> (!alloc || (pagetable = (<span class="keyword">pde_t</span> *)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空分配的页表</span></span><br><span class="line">            <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">            <span class="comment">// 更新页表项，将其指向新分配的页表，并设置有效位 PTE_V</span></span><br><span class="line">            *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最低级和虚拟地址的页表项，不是返回物理地址</span></span><br><span class="line">    <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次从虚拟地址 va 中提取出一个虚拟页号，然后根据这个虚拟页号从页表中取出下一级页表的基地址。如果这个页表项无效，那么根据 alloc 参数决定是否分配一个新的页表。如果 alloc 参数为 0 或者已经没有空闲的内存了，那么遇到中途 V=0 的 pte 整个 walk 过程就会直接退出。如果 alloc 参数为 1，那么就会分配一个新的页表，然后将这个页表项指向新分配的页表，并设置有效位 PTE_V。</p><p>我们可以发现 walk 返回的结果不是物理地址，而是页表项的地址。这是因为 walk 函数的作用是将虚拟地址转换为物理地址，而页表项中的 PPN 只是物理地址的一部分，<strong>还需要加上虚拟地址的低 12 位偏移量才能得到物理地址</strong>。</p><h2 id="如何建立页表"><a href="#如何建立页表" class="headerlink" title="如何建立页表"></a>如何建立页表</h2><p>前面的过程实际上是以用户的角度来考虑的，也就是给你一个虚拟地址按照分页的规则将其转化成物理地址就能访问了。但是作为一个操作系统，我们还需要多考虑一下，页表是哪来的？我们知道从虚拟地址中去获取页表地址，但是<strong>页表的内容是哪来的呢</strong>？页表是如何建立起来的呢？这些是需要操作系统来完成的。</p><p>建立页表也就是建立虚拟地址到物理地址的映射关系。也就是给你一个虚拟地址，你需要告诉我如何查到物理地址，实际上这个过程就是建立页表的过程。这个过程也是通过 walk 函数来完成的，从上文我们知道如果页表都建好的情况下 walk 就是不断查页表的过程，那么在没有页表的情况下，walk 还可以建立一个个页表。稍有不同的是，walk 返回的是最后一级页表项的地址，我们需要将物理地址写入这个页表项中。</p><p>在 uCore 中使用 mappages 函数封装了 walk 函数，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为从虚拟地址 va 开始的页面创建指向物理地址 pa 开始的页表项（PTE）</span></span><br><span class="line"><span class="comment"> * 注意：va 和 size 可能不是页面对齐的</span></span><br><span class="line"><span class="comment"> * 如果无法分配所需的页表，则返回 0，否则返回 -1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param pagetable 根页表地址</span></span><br><span class="line"><span class="comment"> * @param va        虚拟地址</span></span><br><span class="line"><span class="comment"> * @param size      映射的字节数</span></span><br><span class="line"><span class="comment"> * @param pa        物理地址</span></span><br><span class="line"><span class="comment"> * @param perm      权限位</span></span><br><span class="line"><span class="comment"> * @return          成功返回 0，否则返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mappages</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint64 virtualAddress, lastVirtualAddress;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址必须是页面对齐的</span></span><br><span class="line">    virtualAddress     = PGROUNDDOWN(va);</span><br><span class="line">    lastVirtualAddress = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 返回最低级的虚拟地址的页表项，如果不存在会创建一个新的页表项</span></span><br><span class="line">        <span class="comment">// 页表项可能会因为内存不足创建失败，如果创建失败，则返回 -1</span></span><br><span class="line">        <span class="keyword">if</span> ((pte = walk(pagetable, virtualAddress, <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 PTE 已经有效，则输出错误信息并返回 -1</span></span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_V) &#123;</span><br><span class="line">            errorf(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将物理地址 pa 转换为页表项，并设置权限位 perm 和 有效位 PTE_V</span></span><br><span class="line">        *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">        <span class="comment">// 如果当前是最后一个地址，则结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (virtualAddress == lastVirtualAddress) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        virtualAddress += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="请列举-SV39-页表页表项的组成，结合课堂内容，描述其中的标志位有何作用／潜在作用？"><a href="#请列举-SV39-页表页表项的组成，结合课堂内容，描述其中的标志位有何作用／潜在作用？" class="headerlink" title="请列举 SV39 页表页表项的组成，结合课堂内容，描述其中的标志位有何作用／潜在作用？"></a>请列举 SV39 页表页表项的组成，结合课堂内容，描述其中的标志位有何作用／潜在作用？</h2><p>Sv39 页表页表项的组成如下：</p><ol><li>**有效位 (V)**：这是页表项的最高位，用于指示页表项是否有效。如果有效位设置为 1，表示页表项有效，可以使用；如果设置为 0，表示页表项无效，禁止使用。这是虚拟内存中页表项的基本有效性标志。</li><li>**写入位 (W)**：这个标志位用于指示是否可以对此页进行写入操作。如果设置为 1，表示允许写入；如果设置为 0，表示禁止写入。它是页表项的访问权限控制标志之一。</li><li>**用户位 (U)**：用户位用于指示是否允许用户态程序访问此页。如果设置为 1，表示允许用户态访问；如果设置为 0，表示只允许内核态访问。它是页表项的访问权限控制标志之一。</li><li>**执行位 (X)**：执行位用于指示是否允许执行此页上的指令。如果设置为 1，表示允许执行；如果设置为 0，表示禁止执行。它也是页表项的访问权限控制标志之一。</li><li>**全局位 (G)**：全局位用于指示此页是否是全局的，即无需 TLB 缓存，通常用于内核页。如果设置为 1，表示是全局的；如果设置为 0，表示不是全局的。</li><li>**已访问位 (A)**：已访问位表示是否已经访问过此页，通常由硬件设置。操作系统可以用它来实现页面置换算法，如 LRU。</li><li>**已修改位 (D)**：已修改位表示是否已经对此页进行了写入操作。与已访问位类似，操作系统可以用它来实现页面置换算法。</li><li>**物理页框地址 (PPN)**：这是页表项中存储的物理页框的地址。它指示了虚拟页到物理页的映射关系。</li></ol><p>Sv39 页表的页表项标志位允许操作系统和硬件实现对虚拟内存的细粒度控制和保护。不同的标志位组合可以实现不同级别的内存保护和权限控制，从而提高系统的安全性和可用性。例如，有效位、写入位、用户位和执行位的不同组合可以实现不同级别的内存保护，使操作系统可以将不同的内存区域分配给用户态和内核态，并设置不同的权限。已访问位和已修改位则用于实现页面置换算法，帮助操作系统决定哪些页面应该被置换出去，以优化内存利用率。全局位可以用于标识全局共享的页，从而节省 TLB 缓存空间。物理页框地址是页表项的核心，它建立了虚拟地址到物理地址的映射关系，使虚拟内存管理成为可能。</p><h2 id="缺页相关问题"><a href="#缺页相关问题" class="headerlink" title="缺页相关问题"></a>缺页相关问题</h2><h3 id="请问哪些异常可能是缺页导致的？"><a href="#请问哪些异常可能是缺页导致的？" class="headerlink" title="请问哪些异常可能是缺页导致的？"></a>请问哪些异常可能是缺页导致的？</h3><p>缺页异常是由于进程访问的页面不在页表中或者在页表中无效而引发的异常。以下这些异常可能是因为缺页导致的：</p><ul><li><p>Load Page Fault（Load 异常）：当进程试图读取一个不在页表中或者无效的页面时，会引发 Load Page Fault 异常。在 RISC-V 中，这个异常对应的异常代码是 5。</p></li><li><p>Store Page Fault（Store 异常）：当进程试图写入一个不在页表中或者无效的页面时，会引发 Store Page Fault 异常。在 RISC-V 中，这个异常对应的异常代码是 7。</p></li><li><p>Instruction Page Fault（指令页异常）：当进程试图执行一个不在页表中或者无效的页面上的指令时，会引发 Instruction Page Fault 异常。在 RISC-V 中，这个异常对应的异常代码是 12。</p></li></ul><h3 id="发生缺页时，描述相关的重要寄存器的值（lab2-中描述过的可以简单点）。"><a href="#发生缺页时，描述相关的重要寄存器的值（lab2-中描述过的可以简单点）。" class="headerlink" title="发生缺页时，描述相关的重要寄存器的值（lab2 中描述过的可以简单点）。"></a>发生缺页时，描述相关的重要寄存器的值（lab2 中描述过的可以简单点）。</h3><ul><li>sepc（Exception Program Counter）：trap 发生时会将当前指令的下一条指令地址写入其中，用于 trap 处理完成后返回。</li><li>stval（Machine Trap Value）：mtval 寄存器包含导致异常的原因，即导致异常的指令的具体信息。例如，如果是缺页异常，那么 mtval 寄存器包含导致缺页异常的虚拟地址。</li><li>scause: 中断/异常发生时， CSR 寄存器 scause 中会记录其信息， Interrupt 位记录是中断还是异常， Exception Code 记录中断/异常的种类。</li><li>sstatus: 记录处理器当前状态，其中 SPP 段记录当前特权等级。</li><li>stvec: 记录处理 trap 的入口地址，现有两种模式  Direct 和 Vectored 。</li><li>sscratch: 其中的值是指向hart相关的S态上下文的指针，比如内核栈的指针。</li></ul><h3 id="以下行为的好处？"><a href="#以下行为的好处？" class="headerlink" title="以下行为的好处？"></a>以下行为的好处？</h3><p>缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做，而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。</p><p>Lazy Loading 策略有以下好处：</p><ol><li><strong>减少初始化开销</strong>：Lazy Loading 允许操作系统在程序启动时只加载必需的页面，而不是一次性加载整个程序。这可以减少启动时间和初始化开销，因为不需要将整个程序加载到内存中。</li><li><strong>节省内存</strong>：Lazy Loading 策略避免了不必要的内存占用。如果程序的某些部分从不被访问，那么它们就不会被加载到内存中，从而节省了内存资源。</li><li><strong>提高响应速度</strong>：通过仅在需要时加载页面，Lazy Loading 可以提高系统的响应速度。只有当程序访问某个页面时，操作系统才会执行磁盘加载操作，而不会在程序启动时浪费时间加载可能永远不会被访问的内容。</li><li><strong>更好的磁盘利用率</strong>：Lazy Loading 允许操作系统将程序的不同部分分散在磁盘上，根据需要加载。这可以提高磁盘利用率，因为不需要在磁盘上为整个程序分配连续的空间。</li></ol><h3 id="请问处理-10G-连续的内存页面，需要操作的页表实际大致占用多少内存-给出数量级即可-？"><a href="#请问处理-10G-连续的内存页面，需要操作的页表实际大致占用多少内存-给出数量级即可-？" class="headerlink" title="请问处理 10G 连续的内存页面，需要操作的页表实际大致占用多少内存 (给出数量级即可)？"></a>请问处理 10G 连续的内存页面，需要操作的页表实际大致占用多少内存 (给出数量级即可)？</h3><blockquote><p>此外 COW(Copy On Write) 也是常见的容易导致缺页的 Lazy 策略，这个之后再说。其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间，然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。</p></blockquote><p>处理 10GB 连续的内存页面所需的页表实际上占用的内存量取决于操作系统的页表结构和管理策略。在 RISC-V 的页表结构中，一个页表项（Page Table Entry，PTE）通常占据 8 字节（64 位系统），其中包括物理页框号和一些标志位。让我们假设一个 PTE 占用 8 字节。</p><p>为了估算 10GB 连续内存页面所需的页表实际占用内存量，我们可以按照以下步骤进行计算：</p><ol><li><p>首先，将 10GB 转换为字节数。1GB 等于 1,073,741,824 字节，所以 10GB 等于 10 * 1,073,741,824 = 10,737,418,240 字节。</p></li><li><p>然后，计算每个页面表项覆盖的内存范围。假设每个页面表项管理 4KB（4 * 1024 字节）的内存页面。</p></li><li><p>计算需要多少个页面表项来管理 10GB 的内存。这可以通过将 10GB 除以每个页面表项管理的内存范围来实现。</p></li><li><p>最后，将所需的页面表项数量乘以每个 PTE 的大小来估算所需的总内存量。</p></li></ol><p>让我们进行具体计算：</p><ul><li>内存大小：10,737,418,240 字节</li><li>每个页面表项管理的内存范围：4KB = 4 * 1024 字节</li><li>需要的页面表项数量：10,737,418,240 字节 / 4KB = 2,621,440 个页表项</li></ul><p>假设每个页表项占用 8 字节，则需要的总内存量为：</p><p>2,621,440 个页表项 * 8 字节/页表项 = 20,971,520 字节</p><p>所以，处理 10GB 连续的内存页面所需的页表实际占用内存量约为 20,971,520 字节，或者大约 20MB。这只是一个估算，实际内存占用可能会因操作系统的管理策略和对齐等因素而有所不同。</p><h3 id="请简单思考如何才能在现有框架基础上实现-Lazy-策略，缺页时又如何处理？描述合理即可，不需要考虑实现。"><a href="#请简单思考如何才能在现有框架基础上实现-Lazy-策略，缺页时又如何处理？描述合理即可，不需要考虑实现。" class="headerlink" title="请简单思考如何才能在现有框架基础上实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。"></a>请简单思考如何才能在现有框架基础上实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。</h3><p>要在现有框架基础上实现 Lazy 策略，可以采取以下简单思路：</p><ol><li><p><strong>延迟加载（Lazy Loading）</strong>：在用户进程请求内存映射时，不立即将整个内存区域加载到物理内存中。而是仅创建虚拟内存映射和页表项，记录对应的磁盘位置等信息。</p></li><li><p><strong>缺页处理（Page Fault Handling）</strong>：当用户进程访问虚拟内存中的某个尚未加载的内存页面时，会触发缺页异常。在缺页异常处理程序中，操作系统会根据页表中的磁盘位置信息，将相应的磁盘数据加载到物理内存中，并更新页表项，使其指向新加载的物理页面。</p></li><li><p><strong>惰性加载（Demand Paging）</strong>：为了提高性能，可以采用惰性加载策略，即只加载实际被访问的内存页面，而不是一次性加载整个区域。这可以通过在缺页处理程序中进行懒加载操作来实现。</p></li><li><p><strong>内存回收（Memory Reclamation）</strong>：当系统内存不足时，操作系统可以选择回收一些不常访问的内存页面，将其写回磁盘，并更新页表项为无效。这需要根据页面访问模式和策略来确定哪些页面可以被回收。</p></li><li><p><strong>性能优化</strong>：为了提高性能，可以采用预读取（Prefetching）策略，即在缺页处理时，不仅加载当前访问的页面，还预先加载相邻的页面，以减少未来可能的缺页次数。</p></li></ol><h3 id="此时页面失效如何表现在页表项-PTE-上？"><a href="#此时页面失效如何表现在页表项-PTE-上？" class="headerlink" title="此时页面失效如何表现在页表项 (PTE) 上？"></a>此时页面失效如何表现在页表项 (PTE) 上？</h3><blockquote><p>缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。</p></blockquote><p>Dirty bit (D 位)：当页面被修改并且尚未写回到主存时，该位会被设置为 1。如果页面已经被换出到磁盘上，D 位将保持为 1，以指示页面数据已过期。</p><p>Valid bit (V 位)：当页面在主存中有效时，V 位被设置为 1。如果页面被换出到磁盘上，V 位将被清除为 0，表示该页无效。</p><p>通过检查页表项的 D 位和 V 位，操作系统可以确定页面是否需要从磁盘重新加载到内存中。如果 D 位为 1，说明页面需要写回到主存，在将其置为有效之前，必须将页数据从磁盘读取到内存中。如果 V 位为 0，说明页面当前无效，需要将其从磁盘加载到内存中，并将 V 位设置为 1，表示页面有效。</p><h2 id="双页表与单页表"><a href="#双页表与单页表" class="headerlink" title="双页表与单页表"></a>双页表与单页表</h2><p>为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说，用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。请结合课堂知识回答如下问题：(备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )</p><h2 id="单页表情况下，如何更换页表？"><a href="#单页表情况下，如何更换页表？" class="headerlink" title="单页表情况下，如何更换页表？"></a>单页表情况下，如何更换页表？</h2><p> 在单页表情况下，页表的更换通常是由操作系统的上下文切换来触发的。当从用户态切换到内核态或从一个进程切换到另一个进程时，操作系统会根据相应的上下文信息加载不同的页表，实现页表的更换。</p><h2 id="单页表情况下，如何控制用户态无法访问内核页面？（tips-看看第一题最后一问）"><a href="#单页表情况下，如何控制用户态无法访问内核页面？（tips-看看第一题最后一问）" class="headerlink" title="单页表情况下，如何控制用户态无法访问内核页面？（tips:看看第一题最后一问）"></a>单页表情况下，如何控制用户态无法访问内核页面？（tips:看看第一题最后一问）</h2><ul><li>设置页面权限：内核页面通常会被设置为只能在内核态下访问（例如，设置 PTE_U 位为 0），这样用户态无法访问内核页面。</li><li>操作系统权限：操作系统内核态拥有较高的权限，可以通过特权级别或访问控制机制来确保用户态无法直接访问内核页面。用户程序只能通过系统调用进入内核态，并在内核态下由操作系统执行，从而实现对内核页面的访问控制。</li></ul><h2 id="单页表有何优势？（回答合理即可）"><a href="#单页表有何优势？（回答合理即可）" class="headerlink" title="单页表有何优势？（回答合理即可）"></a>单页表有何优势？（回答合理即可）</h2><p>单页表的主要优势在于简化了地址转换过程，减少了内存访问的开销。由于用户线程和内核线程共享同一张页表，不需要在上下文切换时频繁切换页表，这可以提高地址转换的效率。此外，单页表还可以节省内存，因为不需要为每个用户线程分配独立的页表。</p><h2 id="双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？"><a href="#双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？" class="headerlink" title="双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？"></a>双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？</h2><p>在双页表实现下，页表的更换通常在发生上下文切换时需要。当从用户态切换到内核态或从一个进程切换到另一个进程时，需要加载相应的页表，以确保正确的地址转换。如果操作系统采用了每个进程独立的页表，那么在进程切换时需要更换页表。</p><p>如果我写一个单页表操作系统，我会选择在发生进程切换时更换页表，因为这是最频繁的上下文切换情况之一。在其他情况下，如从用户态切换到内核态，可能不需要更换整张页表，而只需修改页表项的权限位来实现访问控制。这样可以减少页表更换的开销，提高性能。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>修改user项目中的makefile，删除ch4_</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;为何指定 TRAMPOLINE 和 TRAPFRAME 在 va 的最高位？&lt;br&gt;TRAMPOLINE 和 TRAPFRAME 被定义在最高的虚拟内存地址上，是因为它们在操作系统的内存布局中起着重要作用。&lt;br&gt;TRAMPOLINE 被用作从用户</summary>
      
    
    
    
    <category term="uCore 实验" scheme="http://example.com/categories/uCore-%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="RISC-V" scheme="http://example.com/tags/RISC-V/"/>
    
    <category term="内存管理" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="MMU" scheme="http://example.com/tags/MMU/"/>
    
    <category term="虚拟内存" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="uCore" scheme="http://example.com/tags/uCore/"/>
    
    <category term="Lab" scheme="http://example.com/tags/Lab/"/>
    
    <category term="分页分段" scheme="http://example.com/tags/%E5%88%86%E9%A1%B5%E5%88%86%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>uCore 实验第 3 章 - 多道程序与分时多任务</title>
    <link href="http://example.com/2023/09/02/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC3%E7%AB%A0-%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/"/>
    <id>http://example.com/2023/09/02/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC3%E7%AB%A0-%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/</id>
    <published>2023-09-02T08:03:02.000Z</published>
    <updated>2023-09-09T04:01:37.232Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动时初始化进程表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool; p &lt; &amp;pool[NPROC]; p++) &#123;</span><br><span class="line">        p-&gt;state = UNUSED;</span><br><span class="line">        <span class="comment">// p - pool 是 p 指向的 proc 在 pool 中的下标，因此 p - pool 变化情况是 0, 1, 2, ..., NPROC - 1</span></span><br><span class="line">        p-&gt;kstack    = (uint64)kstack[p - pool];</span><br><span class="line">        p-&gt;ustack    = (uint64)ustack[p - pool];</span><br><span class="line">        p-&gt;trapframe = (struct trapframe *)trapframe[p - pool];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">* LAB1: you may need to initialize your new fields of proc here</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    idle.kstack  = (uint64)boot_stack_top;</span><br><span class="line">    idle.pid     = <span class="number">0</span>;</span><br><span class="line">    current_proc = &amp;idle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>p - pool 表示什么？<br>假设我们有一个名为 pool 的数组，其中包含了多个类型为 struct proc 的元素，并且有一个指针 p 指向其中的某个元素。<br>当 p 指向 pool 数组的第一个元素时，p - pool 的结果将是 0，因为指针相对于数组首地址的偏移量为 0。<br>当 p 指向 pool 数组的第二个元素时，p - pool 的结果将是 1，因为指针相对于数组首地址的偏移量为 1。<br>以此类推，当 p 指向 pool 数组的第 N 个元素时，p - pool 的结果将是 N-1，因为指针相对于数组首地址的偏移量为 N-1。<br>总结来说，如果 p 是指向 pool 数组中第 N 个元素的指针，那么 p - pool 的结果将是 N-1。</p></blockquote><p>原调度函数每次都会从 pool 数组的第一个元素开始遍历，这样会导致每次都是从第一个进程开始运行，而不是从上次运行的进程开始运行。需要修改为如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度程序永不返回。它循环执行以下操作：</span></span><br><span class="line"><span class="comment">//  - 选择要运行的进程。</span></span><br><span class="line"><span class="comment">//  - 切换以启动运行该进程。</span></span><br><span class="line"><span class="comment">//  - 最终，该进程通过切换将控制权</span></span><br><span class="line"><span class="comment">//    传递回调度程序。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">last_checked_proc</span> =</span> pool; <span class="comment">// 初始化指针为 pool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (p = last_checked_proc; p &lt; &amp;pool[NPROC];</span><br><span class="line">             p++) &#123; <span class="comment">// 将 p 初始化为 last_checked_proc</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * LAB1：你可能需要在这里初始化进程的起始时间</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                p-&gt;state     = RUNNING;</span><br><span class="line">                current_proc = p;</span><br><span class="line">                swtch(&amp;idle.context, &amp;p-&gt;context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last_checked_proc = pool + <span class="number">1</span>; <span class="comment">// 更新 last_checked_proc 的值为下一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LAB1"><a href="#LAB1" class="headerlink" title="LAB1"></a>LAB1</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"> os/loader.c           |   <span class="number">5</span> +-</span><br><span class="line"> os/proc.c             |  <span class="number">15</span> +-</span><br><span class="line"> os/proc.h             |  <span class="number">23</span> +-</span><br><span class="line"> os/syscall.c          |  <span class="number">55</span> ++++-</span><br><span class="line"> os/syscall_ids.h      |   <span class="number">5</span> +-</span><br><span class="line"> os/timer.h            |   <span class="number">2</span> +</span><br><span class="line"> <span class="number">9</span> files changed, <span class="number">374</span> insertions(+), <span class="number">291</span> deletions(-)</span><br><span class="line"></span><br><span class="line">diff --git a/os/loader.c b/os/loader.c</span><br><span class="line">index b45e85d..b21b0a4 <span class="number">100644</span></span><br><span class="line">--- a/os/loader.c</span><br><span class="line">+++ b/os/loader.c</span><br><span class="line">@@ <span class="number">-1</span>,<span class="number">6</span> +<span class="number">1</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;loader.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;defs.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;trap.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">static</span> uint64  app_num;</span><br><span class="line"> <span class="keyword">static</span> uint64 *app_info_ptr;</span><br><span class="line">@@ <span class="number">-49</span>,<span class="number">8</span> +<span class="number">50</span>,<span class="number">10</span> @@ <span class="function"><span class="keyword">int</span> <span class="title">run_all_app</span><span class="params">()</span></span></span><br><span class="line"><span class="function">         trapframe-&gt;sp  </span>= (uint64)p-&gt;ustack + USER_STACK_SIZE;</span><br><span class="line">         p-&gt;state       = RUNNABLE;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">-* LAB1: you may need to initialize your new fields of proc here</span></span><br><span class="line"><span class="comment">+* LAB1: 初始化系统调用数以及进程开始时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+        <span class="built_in">memset</span>(p-&gt;syscall_times, <span class="number">0</span>, MAX_SYSCALL_NUM * <span class="keyword">sizeof</span>(uint32));</span><br><span class="line">+        p-&gt;start_time = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/os/proc.c b/os/proc.c</span><br><span class="line">index fee3886.<span class="number">.0</span>c69ae5 <span class="number">100644</span></span><br><span class="line">--- a/os/proc.c</span><br><span class="line">+++ b/os/proc.c</span><br><span class="line">@@ <span class="number">-2</span>,<span class="number">6</span> +<span class="number">2</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;defs.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;loader.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;trap.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;timer.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">pool</span>[<span class="title">NPROC</span>];</span></span><br><span class="line"> <span class="keyword">char</span>        kstack[NPROC][PAGE_SIZE];</span><br><span class="line">@@ <span class="number">-33</span>,<span class="number">9</span> +<span class="number">34</span>,<span class="number">8</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">proc_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">         p-&gt;kstack    </span>= (uint64)kstack[p - pool];</span><br><span class="line">         p-&gt;ustack    = (uint64)ustack[p - pool];</span><br><span class="line">         p-&gt;trapframe = (struct trapframe *)trapframe[p - pool];</span><br><span class="line">-        <span class="comment">/*</span></span><br><span class="line"><span class="comment">-* LAB1: you may need to initialize your new fields of proc here</span></span><br><span class="line"><span class="comment">-*/</span></span><br><span class="line">+        <span class="built_in">memset</span>(p-&gt;syscall_times, <span class="number">0</span>, MAX_SYSCALL_NUM * <span class="keyword">sizeof</span>(uint32));</span><br><span class="line">+        p-&gt;start_time = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     idle.kstack  = (uint64)boot_stack_top;</span><br><span class="line">     idle.pid     = <span class="number">0</span>;</span><br><span class="line">@@ <span class="number">-47</span>,<span class="number">6</span> +<span class="number">47</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">int</span> <span class="title">allocpid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     <span class="keyword">static</span> <span class="keyword">int</span> PID </span>= <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> PID++;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line"> <span class="comment">// 在进程表中寻找一个未使用的进程。</span></span><br><span class="line"> <span class="comment">// 如果找到，则初始化在内核中运行所需的状态。</span></span><br><span class="line"> <span class="comment">// 如果没有空闲的进程，或者内存分配失败，则返回 0。</span></span><br><span class="line">@@ <span class="number">-80</span>,<span class="number">14</span> +<span class="number">81</span>,<span class="number">18</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">last_checked_proc</span> =</span> pool; <span class="comment">// 初始化指针为 pool</span></span><br><span class="line">-</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">for</span> (p = last_checked_proc; p &lt; &amp;pool[NPROC];</span><br><span class="line">              p++) &#123; <span class="comment">// 将 p 初始化为 last_checked_proc</span></span><br><span class="line">             <span class="keyword">if</span> (p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">                 <span class="comment">/*</span></span><br><span class="line"><span class="comment">-                * LAB1：你可能需要在这里初始化进程的起始时间</span></span><br><span class="line"><span class="comment">+                * LAB1：在这里初始化进程的开始时间</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">+                <span class="keyword">if</span> (p-&gt;start_time == <span class="number">0</span>) &#123;</span><br><span class="line">+                    uint64 cycle = get_cycle();</span><br><span class="line">+                    p-&gt;start_time =</span><br><span class="line">+                        (cycle % CPU_FREQ) * MILLISECONDS_PER_SECOND / CPU_FREQ;</span><br><span class="line">+                &#125;</span><br><span class="line">                 p-&gt;state     = RUNNING;</span><br><span class="line">                 current_proc = p;</span><br><span class="line">                 swtch(&amp;idle.context, &amp;p-&gt;context);</span><br><span class="line">diff --git a/os/proc.h b/os/proc.h</span><br><span class="line">index d208c5d.<span class="number">.53576</span>bf <span class="number">100644</span></span><br><span class="line">--- a/os/proc.h</span><br><span class="line">+++ b/os/proc.h</span><br><span class="line">@@ <span class="number">-3</span>,<span class="number">7</span> +<span class="number">3</span>,<span class="number">8</span> @@</span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">-<span class="meta">#<span class="meta-keyword">define</span> NPROC (16)</span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">define</span> NPROC           (16)  <span class="comment">// 最大进程数</span></span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">define</span> MAX_SYSCALL_NUM (500) <span class="comment">// 最大系统调用数</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">@@ <span class="number">-42</span>,<span class="number">14</span> +<span class="number">43</span>,<span class="number">28</span> @@ <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">     uint64            kstack;    <span class="comment">// 进程内核栈虚拟地址 (内核页表)</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// 进程中断帧</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">context</span>    <span class="title">context</span>;</span> <span class="comment">// 用于保存进程内核态的寄存器信息，进程切换时使用</span></span><br><span class="line">-                               <span class="comment">/*</span></span><br><span class="line"><span class="comment">-* LAB1: you may need to add some new fields here</span></span><br><span class="line"><span class="comment">+    /*</span></span><br><span class="line"><span class="comment">+* LAB1: 添加一些新的成员用于新的 sys_task_info 系统调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+    uint32 syscall_times[MAX_SYSCALL_NUM]; <span class="comment">// 系统调用次数统计 <span class="doctag">TODO:</span> 后续改为指针</span></span><br><span class="line">+    uint64 start_time;                     <span class="comment">// 进程开始运行时间</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">-* LAB1: you may need to define struct for TaskInfo here</span></span><br><span class="line"><span class="comment">+* LAB1: 定义 TaskInfo 结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+<span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">+    UnInit,</span><br><span class="line">+    Ready,</span><br><span class="line">+    Running,</span><br><span class="line">+    Exited,</span><br><span class="line">+&#125; TaskStatus;</span><br><span class="line">+</span><br><span class="line">+<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">+    TaskStatus status;</span><br><span class="line">+    uint32     syscall_times[MAX_SYSCALL_NUM];</span><br><span class="line">+    <span class="keyword">int</span>        time; <span class="comment">// 进程运行时间统计</span></span><br><span class="line">+&#125; TaskInfo;</span><br><span class="line"> </span><br><span class="line"> <span class="function">struct proc *<span class="title">curr_proc</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span>         <span class="title">exit</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">diff --git a/os/syscall.c b/os/syscall.c</span><br><span class="line">index <span class="number">1</span>cc5aeb..f54ed86 <span class="number">100644</span></span><br><span class="line">--- a/os/syscall.c</span><br><span class="line">+++ b/os/syscall.c</span><br><span class="line">@@ <span class="number">-4</span>,<span class="number">6</span> +<span class="number">4</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;syscall_ids.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;timer.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;trap.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;proc.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function">uint64 <span class="title">sys_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *str, uint len)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">@@ <span class="number">-31</span>,<span class="number">14</span> +<span class="number">32</span>,<span class="number">46</span> @@ <span class="function">uint64 <span class="title">sys_sched_yield</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> uint64 <span class="title">sys_gettimeofday</span><span class="params">(TimeVal *val, <span class="keyword">int</span> _tz)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     uint64 cycle = get_cycle();</span><br><span class="line">-    val-&gt;sec     = cycle / CPU_FREQ;</span><br><span class="line">-    val-&gt;usec    = (cycle % CPU_FREQ) * MICROSECONDS_PER_SECOND / CPU_FREQ;</span><br><span class="line">+    tracef(<span class="string">&quot;sys_gettimeofday cycle = %d&quot;</span>, cycle);</span><br><span class="line">+    val-&gt;sec  = cycle / CPU_FREQ;</span><br><span class="line">+    val-&gt;msec = (cycle % CPU_FREQ) * MILLISECONDS_PER_SECOND / CPU_FREQ;</span><br><span class="line">+    val-&gt;usec = (cycle % CPU_FREQ) * MICROSECONDS_PER_SECOND / CPU_FREQ;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-<span class="comment">/*</span></span><br><span class="line"><span class="comment">-* LAB1: you may need to define sys_task_info here</span></span><br><span class="line"><span class="comment">-*/</span></span><br><span class="line">+<span class="comment">/** </span></span><br><span class="line"><span class="comment">+ * LAB1：此处定义 sys_task_info 函数</span></span><br><span class="line"><span class="comment">+ * 查询当前正在执行的任务信息，任务信息包括任务控制块相关信息（任务状态）、任务使用的系统调用次数、任务总运行时长。 </span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="function"><span class="keyword">int</span> <span class="title">sys_task_info</span><span class="params">(TaskInfo *ti)</span></span></span><br><span class="line"><span class="function">+</span>&#123;</span><br><span class="line">+    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span> =</span> curr_proc();</span><br><span class="line">+    <span class="comment">// <span class="doctag">TODO:</span> proc 检查为空</span></span><br><span class="line">+    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_SYSCALL_NUM; i++) &#123;</span><br><span class="line">+        ti-&gt;syscall_times[i] = proc-&gt;syscall_times[i];</span><br><span class="line">+    &#125;</span><br><span class="line">+    uint64 cycle = get_cycle();</span><br><span class="line">+    uint64 current_time =</span><br><span class="line">+        (cycle % CPU_FREQ) * MILLISECONDS_PER_SECOND / CPU_FREQ;</span><br><span class="line">+    infof(<span class="string">&quot;sys_task_info current_time = %d&quot;</span>, current_time);</span><br><span class="line">+    infof(<span class="string">&quot;proc-&gt;start_time = %d&quot;</span>, proc-&gt;start_time);</span><br><span class="line">+    infof(<span class="string">&quot;ti-&gt;time = %d&quot;</span>, current_time - proc-&gt;start_time);</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (proc-&gt;state == RUNNING) &#123;</span><br><span class="line">+        ti-&gt;status = Running;</span><br><span class="line">+    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;state == RUNNABLE) &#123;</span><br><span class="line">+        ti-&gt;status = Ready;</span><br><span class="line">+    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;state == SLEEPING) &#123;</span><br><span class="line">+        ti-&gt;status = Ready;</span><br><span class="line">+    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;state == ZOMBIE) &#123;</span><br><span class="line">+        ti-&gt;status = Exited;</span><br><span class="line">+    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;state == UNUSED) &#123;</span><br><span class="line">+        ti-&gt;status = UnInit;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    ti-&gt;time = current_time - proc-&gt;start_time;</span><br><span class="line">+    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">extern</span> <span class="keyword">char</span> trap_page[];</span><br><span class="line"> </span><br><span class="line">@@ <span class="number">-51</span>,<span class="number">8</span> +<span class="number">84</span>,<span class="number">9</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     <span class="title">tracef</span><span class="params">(<span class="string">&quot;syscall %d args = [%x, %x, %x, %x, %x, %x]&quot;</span>, id, args[<span class="number">0</span>], args[<span class="number">1</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">            args[<span class="number">2</span>], args[<span class="number">3</span>], args[<span class="number">4</span>], args[<span class="number">5</span>])</span></span>;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">-* LAB1: you may need to update syscall counter for task info here</span></span><br><span class="line"><span class="comment">+* LAB1: 更新系统调用次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+    curr_proc()-&gt;syscall_times[id]++;</span><br><span class="line">     <span class="keyword">switch</span> (id) &#123;</span><br><span class="line">     <span class="keyword">case</span> SYS_write:</span><br><span class="line">         ret = sys_write(args[<span class="number">0</span>], (<span class="keyword">char</span> *)args[<span class="number">1</span>], args[<span class="number">2</span>]);</span><br><span class="line">@@ <span class="number">-67</span>,<span class="number">8</span> +<span class="number">101</span>,<span class="number">15</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">()</span></span></span><br><span class="line"><span class="function">         ret </span>= sys_gettimeofday((TimeVal *)args[<span class="number">0</span>], args[<span class="number">1</span>]);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">-* LAB1: you may need to add SYS_taskinfo case here</span></span><br><span class="line"><span class="comment">+* LAB1: 在此处添加 SYS_task_info 的系统调用处理情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+    <span class="keyword">case</span> SYS_task_info:</span><br><span class="line">+        ret = sys_task_info((TaskInfo *)args[<span class="number">0</span>]);</span><br><span class="line">+        <span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> SYS_getpid:</span><br><span class="line">+        infof(<span class="string">&quot;SYS_getpid %d&quot;</span>, SYS_getpid);</span><br><span class="line">+        ret = curr_proc()-&gt;pid;</span><br><span class="line">+        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">         ret = <span class="number">-1</span>;</span><br><span class="line">         errorf(<span class="string">&quot;unknown syscall %d&quot;</span>, id);</span><br><span class="line">diff --git a/os/syscall_ids.h b/os/syscall_ids.h</span><br><span class="line">index <span class="number">05</span>a6cb9.<span class="number">.3</span>c1a5a9 <span class="number">100644</span></span><br><span class="line">--- a/os/syscall_ids.h</span><br><span class="line">+++ b/os/syscall_ids.h</span><br><span class="line">@@ <span class="number">-277</span>,<span class="number">9</span> +<span class="number">277</span>,<span class="number">8</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> SYS_io_pgetevents          292</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> SYS_rseq                   293</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> SYS_kexec_file_load        294</span></span><br><span class="line">-<span class="comment">/*</span></span><br><span class="line"><span class="comment">-* LAB1: you may need to define SYS_task_info here</span></span><br><span class="line"><span class="comment">-*/</span></span><br><span class="line">+<span class="comment">// LAB1：添加 SYS_task_info 的系统调用号</span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">define</span> SYS_task_info          410</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> SYS_pidfd_send_signal  424</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> SYS_io_uring_setup     425</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> SYS_io_uring_enter     426</span></span><br><span class="line">diff --git a/os/timer.h b/os/timer.h</span><br><span class="line">index c6ebd14.<span class="number">.63</span>ab45c <span class="number">100644</span></span><br><span class="line">--- a/os/timer.h</span><br><span class="line">+++ b/os/timer.h</span><br><span class="line">@@ <span class="number">-6</span>,<span class="number">6</span> +<span class="number">6</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> TICKS_PER_SEC (100)</span></span><br><span class="line"> <span class="comment">// QEMU</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> CPU_FREQ                (12500000)</span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">define</span> MILLISECONDS_PER_SECOND (1000)</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MICROSECONDS_PER_SECOND (1000000)</span></span><br><span class="line"> </span><br><span class="line"> <span class="function">uint64 <span class="title">get_cycle</span><span class="params">()</span></span>;</span><br><span class="line">@@ <span class="number">-14</span>,<span class="number">6</span> +<span class="number">15</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">void</span>   <span class="title">set_next_timer</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     uint64 sec;  <span class="comment">// 自 Unix 纪元起的秒数</span></span><br><span class="line">+    uint64 msec; <span class="comment">// 毫秒数</span></span><br><span class="line">     uint64 usec; <span class="comment">// 微秒数</span></span><br><span class="line"> &#125; TimeVal;</span><br><span class="line"> </span><br><span class="line">-- </span><br><span class="line"><span class="number">2.34</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。请同学们可以自行测试这些内容（参考 前三个测例，描述程序出错行为，同时注意注明你使用的 sbi 及其版本。</p><p>测试前三个测试用例指的是<code>uCore-Tutorial-Code-2023S/user/src/</code> 目录下的三个<code>bad</code>测试用例，查看<code>user</code>项目的 Makefile 可以发现在编译时修改<code>CHAPTER</code>参数值为<code>2_bad</code>即可编译运行这些测试用例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--<span class="string">&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span></span><br><span class="line"><span class="string">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span></span><br><span class="line"><span class="string">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2</span></span><br><span class="line"><span class="string">[rustsbi] Platform Name      : riscv-virtio,qemu</span></span><br><span class="line"><span class="string">[rustsbi] Platform SMP       : 1</span></span><br><span class="line"><span class="string">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span></span><br><span class="line"><span class="string">[rustsbi] Boot HART          : 0</span></span><br><span class="line"><span class="string">[rustsbi] Device Tree Region : 0x87000000..0x87000ef2</span></span><br><span class="line"><span class="string">[rustsbi] Firmware Address   : 0x80000000</span></span><br><span class="line"><span class="string">[rustsbi] Supervisor Address : 0x80200000</span></span><br><span class="line"><span class="string">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span></span><br><span class="line"><span class="string">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span></span><br><span class="line"><span class="string">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span></span><br><span class="line"><span class="string">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span></span><br><span class="line"><span class="string">[TRACE 0]load app 0 at 0x0000000080400000</span></span><br><span class="line"><span class="string">[TRACE 0]load app 1 at 0x0000000080420000</span></span><br><span class="line"><span class="string">[TRACE 0]load app 2 at 0x0000000080440000</span></span><br><span class="line"><span class="string">[INFO 0]start scheduler!</span></span><br><span class="line"><span class="string">[ERROR 1]unknown trap: 0x0000000000000007, stval = 0x0000000000000000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[INFO 1]进程 1 以代码 -1 退出</span></span><br><span class="line"><span class="string">IllegalInstruction in application, core dumped.</span></span><br><span class="line"><span class="string">[INFO 2]进程 2 以代码 -3 退出</span></span><br><span class="line"><span class="string">IllegalInstruction in application, core dumped.</span></span><br><span class="line"><span class="string">[INFO 3]进程 3 以代码 -3 退出</span></span><br><span class="line"><span class="string">[PANIC 3] os/loader.c:15: all apps over</span></span><br></pre></td></tr></table></figure><p>第一个进程测试用例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="number">0</span>;</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在您提供的代码中，将空指针分配给指针变量*p 后，试图对其进行解引用并将值 0 赋给该指针。由于用户模式下禁止直接访问物理内存，操作系统会检测到这个非法操作并触发异常。因此，该程序 IllegalInstruction in application, core dumped.</p><p>在 RISC-V 架构中，U 模式是最低的用户模式，用户程序无法直接访问物理内存或其他特权级别资源。这种限制是为了确保操作系统的安全性和稳定性。</p><p>第二个进程测试用例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;sret&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试图使用汇编语言执行 sret 指令，该指令用于从中断或异常处理程序返回。由于用户模式下禁止直接访问特权级别寄存器，操作系统会检测到这个非法操作并触发异常。因此，该程序 IllegalInstruction in application, core dumped。</p><p>第三个进程测试用例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint64 x;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sstatus&quot;</span> : <span class="string">&quot;=r&quot;</span>(x))</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因同上，试图使用汇编语言执行 csrr 指令，该指令用于从特权级别寄存器中读取值。由于用户模式下禁止直接访问特权级别寄存器，操作系统会检测到这个非法操作并触发异常。因此，该程序 IllegalInstruction in application, core dumped。</p><p>在操作系统代码中，触发异常后会进入<code>void usertrap()</code> 函数，该函数会根据 <code>scause</code> 寄存器的值判断异常类型，用例中的结果进入了<code>case IllegalInstruction</code>，其中 <code>IllegalInstruction = 2</code>。我们查阅手册 <code>riscv-privileged.pdf</code> ，可以查到 <code>IllegalInstruction</code> 的值为 2，与预期相符。</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>请结合用例理解 trampoline.S 中两个函数 <code>userret</code> 和 <code>uservec</code> 的作用，并回答如下几个问题：</p><h3 id="L79-刚进入-userret-时，a0、a1-分别代表了什么值。"><a href="#L79-刚进入-userret-时，a0、a1-分别代表了什么值。" class="headerlink" title="L79: 刚进入 userret 时，a0、a1 分别代表了什么值。"></a>L79: 刚进入 <code>userret</code> 时，<code>a0</code>、<code>a1</code> 分别代表了什么值。</h3><p>在进入<code>userret</code>函数时，<code>a0</code>和<code>a1</code>分别代表以下值：</p><ul><li><code>a0</code>: TRAPFRAME 的地址，指向当前进程的陷阱帧（trapframe）结构体。</li><li><code>a1</code>: 用户页表的地址，即进程的页表（pagetable）。这个地址会被写入到<code>satp</code>寄存器中，用于切换到用户模式的页表。</li></ul><h3 id="L87-L88-sfence-指令有何作用？为什么要执行该指令，当前章节中，删掉该指令会导致错误吗？"><a href="#L87-L88-sfence-指令有何作用？为什么要执行该指令，当前章节中，删掉该指令会导致错误吗？" class="headerlink" title="L87-L88: sfence 指令有何作用？为什么要执行该指令，当前章节中，删掉该指令会导致错误吗？"></a>L87-L88: <code>sfence</code> 指令有何作用？为什么要执行该指令，当前章节中，删掉该指令会导致错误吗？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csrw satp, a1</span><br><span class="line">sfence.vma zero, zero</span><br></pre></td></tr></table></figure><p><code>sfence</code>指令（Store Fence）的作用是确保之前的存储操作完成，并且对其他处理器上的核心可见。</p><p>执行<code>sfence</code>指令的主要目的是为了保证内存访问的顺序性和一致性。在多核处理器系统中，不同的核心可能会有自己的缓存，当一个核心修改了共享内存中的数据时，为了保证其他核心能够看到这个修改，需要使用<code>sfence</code>指令来刷新缓存并将修改写回共享内存。</p><p>在代码中，<code>sfence</code>指令被用于确保对用户页表的修改对其他处理器上的核心可见。因为目前我只使用了单核处理器，所以不会出现多核处理器的情况，因此<code>sfence</code>指令的作用是确保对用户页表的修改对当前核心可见。</p><p>因此，当前章节中，<strong>删掉该指令不会导致错误</strong>。</p><h3 id="L96-L125-为何注释中说要除去-a0？哪一个地址代表-a0？现在-a0-的值存在何处？"><a href="#L96-L125-为何注释中说要除去-a0？哪一个地址代表-a0？现在-a0-的值存在何处？" class="headerlink" title="L96-L125: 为何注释中说要除去 a0？哪一个地址代表 a0？现在 a0 的值存在何处？"></a>L96-L125: 为何注释中说要除去 <code>a0</code>？哪一个地址代表 <code>a0</code>？现在 <code>a0</code> 的值存在何处？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># restore all but a0 from TRAPFRAME</span><br><span class="line">ld ra, 40(a0)</span><br><span class="line">ld sp, 48(a0)</span><br><span class="line">ld t5, 272(a0)</span><br><span class="line">ld t6, 280(a0)</span><br></pre></td></tr></table></figure><p><code>a0</code> 是<strong>保存在 <code>sscratch</code> 寄存器中的</strong>，首先，该代码通过 <code>ld</code> 指令从 <code>TRAPFRAME</code> 中加载各个寄存器的值。然后，这些值被存储在相应的寄存器中，以便在恢复用户上下文时使用。</p><p>接下来，代码使用 <code>csrrw</code> 指令将 sscratch 寄存器的值与 <code>a0</code>（即 <code>TRAPFRAME</code>）进行交换。这样做是为了将用户的 <code>a0</code>（<code>TRAPFRAME</code>）保存在 <code>sscratch</code> 寄存器中，以便后续步骤可以正确地恢复用户上下文。</p><p>最后，通过 <code>sret</code> 指令返回到用户模式，并将控制权交给用户代码。在执行 <code>sret</code> 指令后，处理器将根据用户上下文中的 <code>sepc</code> 寄存器的值跳转到用户代码的指令地址。返回的同时，处理器还会自动恢复 <code>sstatus</code> 寄存器的值，以确保正确的特权级别和中断状态。</p><h3 id="userret：中发生状态切换在哪一条指令？为何执行之后会进入用户态？"><a href="#userret：中发生状态切换在哪一条指令？为何执行之后会进入用户态？" class="headerlink" title="userret：中发生状态切换在哪一条指令？为何执行之后会进入用户态？"></a><code>userret</code>：中发生状态切换在哪一条指令？为何执行之后会进入用户态？</h3><p>在<code>userret</code>函数中，发生状态切换的指令是<code>sret</code>指令。 </p><p><code>sret</code>指令用于从内核模式切换到用户模式，并将控制权交给用户代码。执行<code>sret</code>指令后，处理器会根据用户上下文中的<code>sepc</code>寄存器的值跳转到用户代码的指令地址。</p><p>执行<code>sret</code>指令之后进入用户态的原因是，该指令会自动恢复<code>sstatus</code>寄存器的值，以确保正确的特权级别和中断状态。当<code>sret</code>指令执行后，处理器将从内核态切换回用户态，程序将继续执行用户代码。这意味着<code>userret</code>函数成功完成了从内核切换到用户模式的过程。</p><h3 id="L29：执行之后，a0-和-sscratch-中各是什么值，为什么？"><a href="#L29：执行之后，a0-和-sscratch-中各是什么值，为什么？" class="headerlink" title="L29：执行之后，a0 和 sscratch 中各是什么值，为什么？"></a>L29：执行之后，a0 和 sscratch 中各是什么值，为什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrrw a0, sscratch, a0     </span><br></pre></td></tr></table></figure><p>在执行指令后，<code>a0</code>和<code>sscratch</code>中的值发生了互换。</p><p>假设原始<code>a0</code>寄存器中的值为 X，而<code>sscratch</code>寄存器中的值为 Y。执行<code>csrrw a0, sscratch, a0</code>指令后，<code>a0</code>寄存器中的值变为 Y，而<code>sscratch</code>寄存器中的值变为 X。</p><p>这是因为<code>csrrw</code>指令是一个特权指令，用于将某个 CSR（Control and Status Register）的值读取到目标寄存器，然后将目标寄存器的值写回到该 CSR 中。在这里，<code>csrrw a0, sscratch, a0</code>指令将<code>sscratch</code>寄存器的值读取到<code>a0</code>寄存器中，同时将<code>a0</code>寄存器中的值写回到<code>sscratch</code>寄存器中，从而实现了两者之间的数据交换。</p><h3 id="L32-L61-从-trapframe-第几项开始保存？为什么？是否从该项开始保存了所有的值，如果不是，为什么？"><a href="#L32-L61-从-trapframe-第几项开始保存？为什么？是否从该项开始保存了所有的值，如果不是，为什么？" class="headerlink" title="L32-L61: 从 trapframe 第几项开始保存？为什么？是否从该项开始保存了所有的值，如果不是，为什么？"></a>L32-L61: 从 trapframe 第几项开始保存？为什么？是否从该项开始保存了所有的值，如果不是，为什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sd ra, 40(a0)</span><br><span class="line">sd sp, 48(a0)</span><br><span class="line">...</span><br><span class="line">sd t5, 272(a0)</span><br><span class="line">sd t6, 280(a0)</span><br></pre></td></tr></table></figure><h3 id="进入-S-态是哪一条指令发生的？"><a href="#进入-S-态是哪一条指令发生的？" class="headerlink" title="进入 S 态是哪一条指令发生的？"></a>进入 S 态是哪一条指令发生的？</h3><h3 id="L75-L76-ld-t0-16-a0-执行之后，t0中的值是什么，解释该值的由来？"><a href="#L75-L76-ld-t0-16-a0-执行之后，t0中的值是什么，解释该值的由来？" class="headerlink" title="L75-L76: ld t0, 16(a0) 执行之后，t0中的值是什么，解释该值的由来？"></a>L75-L76: <code>ld t0, 16(a0)</code> 执行之后，<code>t0</code>中的值是什么，解释该值的由来？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ld t0, 16(a0)</span><br><span class="line">jr t0</span><br></pre></td></tr></table></figure><p><code>ld t0, 16(a0)</code>就是从 <code>trapframe</code> 中恢复 <code>t0</code>寄存器值，<code>t0</code>保存了<code>kernel_trap</code>的入口地址。使用 <code>jr t0</code>，就跳转到了我们早先设定在 <code>trapframe-&gt;kernel_trap</code> 中的地址，也就是 <code>trap.c</code> 之中的 <code>usertrap</code> 函数。这个函数在 <code>main</code> 的初始化之中已经调用了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="uCore 实验" scheme="http://example.com/categories/uCore-%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="RISC-V" scheme="http://example.com/tags/RISC-V/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="uCore" scheme="http://example.com/tags/uCore/"/>
    
    <category term="Lab" scheme="http://example.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>yq 为 yaml 文件内容排序</title>
    <link href="http://example.com/2023/09/01/yq%E4%B8%BAyaml%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/09/01/yq%E4%B8%BAyaml%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-01T13:37:25.000Z</published>
    <updated>2023-09-01T13:48:35.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>配置 <code>yaml</code> 文件时会遇到需要将配置的内容按照键值排序的情况，比如下面这样<code>riscv_fork_list.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">packages:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">accumulo</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">abseil-cpp</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">acpica-tools</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">acpid</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">activemq</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">afflib</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">adcli</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">adwaita-icon-theme</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aide</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">alsa-lib</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">amtk</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">anaconda</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-sshd</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">annobin</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">antlr3</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-csv</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aom</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-beanutils</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-daemon</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-el</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-exec</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-jexl</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-poi</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-rat</span></span><br></pre></td></tr></table></figure><p>我想按照 <code>name</code> 的字母顺序排序，可以使用 <code>yq</code> 工具来实现。</p><h1 id="安装-yq"><a href="#安装-yq" class="headerlink" title="安装 yq"></a>安装 yq</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq &amp;&amp;\</span><br><span class="line">    chmod +x /usr/bin/yq</span><br></pre></td></tr></table></figure><h1 id="使用-yq"><a href="#使用-yq" class="headerlink" title="使用 yq"></a>使用 yq</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yq -i <span class="string">&#x27;.packages |= sort_by(.name)&#x27;</span> riscv_fork_list.yaml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">packages:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">abseil-cpp</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">accumulo</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">acpica-tools</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">acpid</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">activemq</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">adcli</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">adwaita-icon-theme</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">afflib</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aide</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">alsa-lib</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">amtk</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">anaconda</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">annobin</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">antlr3</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aom</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-beanutils</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-csv</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-daemon</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-el</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-exec</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-commons-jexl</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-poi</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-rat</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache-sshd</span></span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;配置 &lt;code&gt;yaml&lt;/code&gt; 文件时会遇到需要将配置的内容按照键值排序的情况，比如下面这样&lt;code&gt;riscv_fork_li</summary>
      
    
    
    
    <category term="工欲善其事必先利其器" scheme="http://example.com/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="yaml" scheme="http://example.com/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>解决复制 Markdown 文本到思源笔记无法转义为 Markdown 格式</title>
    <link href="http://example.com/2023/09/01/%E8%A7%A3%E5%86%B3%E5%A4%8D%E5%88%B6Markdown%E6%96%87%E6%9C%AC%E5%88%B0%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E6%97%A0%E6%B3%95%E8%BD%AC%E4%B9%89%E4%B8%BAMarkdown%E6%A0%BC%E5%BC%8F/"/>
    <id>http://example.com/2023/09/01/%E8%A7%A3%E5%86%B3%E5%A4%8D%E5%88%B6Markdown%E6%96%87%E6%9C%AC%E5%88%B0%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E6%97%A0%E6%B3%95%E8%BD%AC%E4%B9%89%E4%B8%BAMarkdown%E6%A0%BC%E5%BC%8F/</id>
    <published>2023-09-01T12:25:05.000Z</published>
    <updated>2023-09-01T12:33:38.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 VSCode 中编辑 Markdown 文本，复制到思源笔记后，思源笔记无法转义为 Markdown 格式。会变成一个代码块，但是代码块内的内容并不是复制的内容。</p><p>比如上面这段话复制到思源笔记成了下图这样：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/09/01/264c4a2f58447a13c50012a676bf0ed7.png"></p><p>但是我需要的是能够转义为 Markdown 的阅读模式。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>问题的原因在于 VSCode 复制的文本是带格式的，而思源笔记默认的粘贴模式是纯文本模式，所以会出现上面的问题。</p><p>解决方法就是从 VSCode 复制的内容为纯文本，一种可以把文本复制到 <code>txt</code> 文件中，再复制，但是比较麻烦。</p><p>第二种方法是使用 VSCode 的插件 <code>Copy Plain Text</code>，搜索下载后，默认快捷键为 <code>Ctrl+Alt+C</code>，可以复制为纯文本。</p><p>再次粘贴到思源笔记中，就可以转义为 Markdown 格式了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/09/01/4f9aa2d7cb07f061aabbc5977977b6cb.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在 VSCode 中编辑 Markdown 文本，复制到思源笔记后，思源笔记无法转义为 Markdown 格式。会变成一个代</summary>
      
    
    
    
    <category term="工欲善其事必先利其器" scheme="http://example.com/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="VSCode" scheme="http://example.com/tags/VSCode/"/>
    
    <category term="Markdown" scheme="http://example.com/tags/Markdown/"/>
    
    <category term="思源笔记" scheme="http://example.com/tags/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>uCore 实验第 2 章 - 批处理系统</title>
    <link href="http://example.com/2023/08/31/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC2%E7%AB%A0-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/08/31/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC2%E7%AB%A0-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-08-31T15:16:38.000Z</published>
    <updated>2023-09-09T04:01:37.231Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">    subgraph entry.S</span><br><span class="line">        _entry[_entry]</span><br><span class="line">    end</span><br><span class="line">    subgraph link_app.S</span><br><span class="line">        _app_num[_app_num]</span><br><span class="line">    end</span><br><span class="line">    subgraph main.c</span><br><span class="line">        main[main]</span><br><span class="line">    end</span><br><span class="line">    subgraph loader.c</span><br><span class="line">        loader_init[loader_init]</span><br><span class="line">        run_next_app[run_next_app]</span><br><span class="line">        load_app[load_app]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    _entry --&gt; main</span><br><span class="line">    main --&gt; loader_init</span><br><span class="line">    main --&gt; run_next_app</span><br><span class="line">    run_next_app --&gt; load_app</span><br><span class="line">    loader_init --&gt; _app_num</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="uCore 实验" scheme="http://example.com/categories/uCore-%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="RISC-V" scheme="http://example.com/tags/RISC-V/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="uCore" scheme="http://example.com/tags/uCore/"/>
    
    <category term="Lab" scheme="http://example.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>如何离线安装 VSCode 插件</title>
    <link href="http://example.com/2023/08/29/%E5%A6%82%E4%BD%95%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85VSCode%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2023/08/29/%E5%A6%82%E4%BD%95%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85VSCode%E6%8F%92%E4%BB%B6/</id>
    <published>2023-08-29T12:59:19.000Z</published>
    <updated>2023-08-29T14:23:50.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h1><p>在使用 VSCode 的过程中，我们经常会安装一些插件来提高开发效率。但是，由于某些原因，我们可能无法直接访问 VSCode 的插件市场，这时候我们就需要离线安装插件了。</p><p>这里存在两种情况，一种是为本地的 VSCode 安装插件，另一种是为远程的 VSCode 安装插件。本文将分别介绍这两种情况下的离线安装方法。</p><blockquote><p>远程 VSCode 也就是 VSCode 的<a href="https://code.visualstudio.com/docs/remote/remote-overview">Remote Development</a>功能，可以通过 SSH、Docker、WSL 等方式远程连接到远程主机上的 VSCode。</p></blockquote><h1 id="方法一：使用已安装的插件目录"><a href="#方法一：使用已安装的插件目录" class="headerlink" title="方法一：使用已安装的插件目录"></a>方法一：使用已安装的插件目录</h1><ul><li>从已经安装插件的电脑上拷贝所有插件，路径一般为 <code>C:\用户\用户名\.vscode\extensions</code></li><li>拷贝到离线安装的电脑上的 <code>.vscode/extensions</code> 文件夹下即可，重启 VScode 即可安装成功。</li></ul><p>对于远程 VSCode 我们需要知道，插件不区分操作系统，所以我们可以在本地的 Windows 上的 VSCode 上安装插件，然后将插件目录压缩后整个拷贝到远程主机上即可。</p><p>远程主机上的插件目录一般在 <code>~/.vscode-server/extensions</code> 下。将压缩的文件解药到这个目录下，重启 VSCode 即可。</p><h1 id="方法二：下载离线安装包-vslx-安装"><a href="#方法二：下载离线安装包-vslx-安装" class="headerlink" title="方法二：下载离线安装包 vslx 安装"></a>方法二：下载离线安装包 vslx 安装</h1><ul><li><p>到 <a href="https://marketplace.visualstudio.com/vscode">VScode 插件中心</a> 搜索需要使用的插件名称</p></li><li><p>下载对应的拓展程序文件，下载的文件的后缀是<code>.vslx</code><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/29/f4349bbfc8cf734951fc70e2f5b0eabd.png"></p></li><li><p>VSCode 中安装<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/29/25b2839add215a8a61449f0ac9b1ca81.png"></p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景简介&quot;&gt;&lt;a href=&quot;#背景简介&quot; class=&quot;headerlink&quot; title=&quot;背景简介&quot;&gt;&lt;/a&gt;背景简介&lt;/h1&gt;&lt;p&gt;在使用 VSCode 的过程中，我们经常会安装一些插件来提高开发效率。但是，由于某些原因，我们可能无法直接访问 VSCode</summary>
      
    
    
    
    <category term="万能 VSCode" scheme="http://example.com/categories/%E4%B8%87%E8%83%BD-VSCode/"/>
    
    
    <category term="VSCode" scheme="http://example.com/tags/VSCode/"/>
    
    <category term="Efficiency" scheme="http://example.com/tags/Efficiency/"/>
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Windows 端口映射</title>
    <link href="http://example.com/2023/08/28/Windows%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"/>
    <id>http://example.com/2023/08/28/Windows%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/</id>
    <published>2023-08-28T15:24:53.000Z</published>
    <updated>2023-08-28T15:29:20.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><p>在 Windows 中，可以使用 netsh 命令来添加、查看和删除端口转发规则。</p><p>要<strong>添加一个端口转发规则</strong>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenaddress=&lt;local_address&gt; listenport=&lt;local_port&gt; connectaddress=&lt;remote_address&gt; connectport=&lt;remote_port&gt;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>&lt;local_address&gt;</code>是本地监听的地址（可以是 IP 地址或 0.0.0.0 表示所有地址）。</li><li><code>&lt;local_port&gt;</code>是本地监听的端口。</li><li><code>&lt;remote_address&gt;</code>是转发连接到的远程地址。</li><li><code>&lt;remote_port&gt;</code>是转发连接到的远程端口。</li></ul><p>例如，要将本地的 8080 端口转发到远程服务器上的 80 端口，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenaddress=127.0.0.1 listenport=8080 connectaddress=192.168.0.100 connectport=80</span><br></pre></td></tr></table></figure><p>要<strong>查看当前的端口转发规则</strong>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy show v4tov4</span><br></pre></td></tr></table></figure><p>要<strong>删除特定的端口转发规则</strong>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy delete v4tov4 listenaddress=&lt;local_address&gt; listenport=&lt;local_port&gt;</span><br></pre></td></tr></table></figure><p>其中的<code>&lt;local_address&gt;</code>和<code>&lt;local_port&gt;</code>应该与你想删除的规则匹配。</p><p>请注意，执行这些操作通常需要管理员权限。</p><h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><p>使用开源工具<a href="https://github.com/zmjack/PortProxyGUI/releases">PortProxyGUI</a>可以在 UI 界面快速增删改查端口映射。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/28/e5bf0ce1f4a25150f69586825c2e7309.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命令行&quot;&gt;&lt;a href=&quot;#命令行&quot; class=&quot;headerlink&quot; title=&quot;命令行&quot;&gt;&lt;/a&gt;命令行&lt;/h1&gt;&lt;p&gt;在 Windows 中，可以使用 netsh 命令来添加、查看和删除端口转发规则。&lt;/p&gt;
&lt;p&gt;要&lt;strong&gt;添加一个端口转发</summary>
      
    
    
    
    <category term="工欲善其事必先利其器" scheme="http://example.com/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="工具，Efficiency，内网穿透" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7%EF%BC%8CEfficiency%EF%BC%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透远程访问家里的 WSL2</title>
    <link href="http://example.com/2023/08/28/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E9%87%8C%E7%9A%84WSL2/"/>
    <id>http://example.com/2023/08/28/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E9%87%8C%E7%9A%84WSL2/</id>
    <published>2023-08-28T14:45:01.000Z</published>
    <updated>2023-08-29T12:35:19.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h1><p>WSL2 是 Windows 的子系统，可以在 Windows 上运行 Linux，但是 WSL2 是运行在虚拟机中的，所以无法直接访问 WSL2 中的服务，比如 SSH 服务。本文介绍如何使用内网穿透工具<strong>花生壳</strong>来实现远程访问 WSL2 中的服务。</p><p>实现这一需求需要完成两个功能。</p><ol><li>WSL2 中的服务是运行在虚拟机中的，如何将公网的访问转发到 WSL2 中。</li><li>Windows 没有公网 IP，如何通过公网来访问。</li></ol><h1 id="WSL2-端口转发"><a href="#WSL2-端口转发" class="headerlink" title="WSL2 端口转发"></a>WSL2 端口转发</h1><p>获取 WSL2 的 IP 地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostname -I | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">172.26.13.98</span><br></pre></td></tr></table></figure><p>Windows 自带的<code>netsh interface portproxy</code>可以实现端口转发。管理员身份打开 cmd，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=2222 connectaddress=172.26.13.98 connectport=22</span><br></pre></td></tr></table></figure><ul><li>listenport：公网访问的端口（改一个不冲突的就行）</li><li>connectaddress：WSL2 的 IP 地址</li><li>connectport：WSL2 中 SSH 服务的端口 (默认为 22，不需要更改)</li></ul><p>开启 Windows 防火墙入站规则，管理员身份打开 cmd，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=WSL2 dir=<span class="keyword">in</span> action=allow protocol=TCP localport=2222</span><br></pre></td></tr></table></figure><p>这个命令是用于在 Windows 高级防火墙中添加一条规则。下面是对每个参数的解释：</p><ul><li><code>name=WSL2</code>：将规则命名为 “WSL2”。</li><li><code>dir=in</code>：指定规则适用于传入的网络流量。</li><li><code>action=allow</code>：允许通过该规则的流量通过防火墙。</li><li><code>protocol=TCP</code>：指定规则适用于 TCP 协议的流量。</li><li><code>localport=2222</code>：指定本地端口号为 2222。</li></ul><p>验证端口转发是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 user@localhost</span><br></pre></td></tr></table></figure><ul><li>user 修改成 WSL2 的用户名</li></ul><p>如果配置成功，则会成功登录 WSL2。</p><h1 id="安装配置花生壳"><a href="#安装配置花生壳" class="headerlink" title="安装配置花生壳"></a>安装配置花生壳</h1><p>进入官网<a href="https://hsk.oray.com/download">下载花生壳客户端</a>，安装后打开，注册账号，登录。<strong>需要实名认证</strong></p><blockquote><p>免费账户可以绑定<strong>2 个映射</strong>，对我来说暂时够用了，免费流量 1G/月。实测阅读代码不编译的话大概<strong>每天 50M</strong>左右。</p></blockquote><p>打开客户端，添加映射，配置如下：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/28/3423c43e8d319abd89c11afd7be03a11.png"></p><p>保存即可。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/28/fddec1e9e0cc03c7208b4244dd35ad01.png"></p><p>验证是否配置成功，找一台不在同一个局域网的电脑，使用 SSH 连接 WSL2：</p><p>如果复制出来的访问地址为<code>abcdjsj.goho.co:33445</code>，那么 SSH 命令修改为如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 33445  user@abcdjsj.goho.co</span><br></pre></td></tr></table></figure><ul><li>user 修改成 WSL2 的用户名</li></ul><p>如果配置成功，则会成功登录 WSL2。</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><ol><li>WSL2 的 <strong>IP 会经常变化</strong>，如果连不上了，可以重新获取一下 IP，然后修改一下各个配置。或者想办法将 WSL2 的 IP 固定下来。</li><li>带宽有限，登录时比较慢，耐心等待。后续准备使用 frp 自建一个穿透服务。</li><li>PC 耗电伤不起啊，一百多瓦赶上三四台 NAS 了。这玩意只能应急，长时间挂机电费都够买个云服务器了。</li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="“System-is-booting-up-Unprivileged-users-are-not-permitted-to-log-in-yet”"><a href="#“System-is-booting-up-Unprivileged-users-are-not-permitted-to-log-in-yet”" class="headerlink" title="“System is booting up. Unprivileged users are not permitted to log in yet”"></a>“System is booting up. Unprivileged users are not permitted to log in yet”</h2><p>登录服务端，也就是 WSL2，执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /run/nologin</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景简介&quot;&gt;&lt;a href=&quot;#背景简介&quot; class=&quot;headerlink&quot; title=&quot;背景简介&quot;&gt;&lt;/a&gt;背景简介&lt;/h1&gt;&lt;p&gt;WSL2 是 Windows 的子系统，可以在 Windows 上运行 Linux，但是 WSL2 是运行在虚拟机中的，所以</summary>
      
    
    
    
    <category term="工欲善其事必先利其器" scheme="http://example.com/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="工具，Efficiency，内网穿透" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7%EF%BC%8CEfficiency%EF%BC%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>PhotoPrism 部署私人相册</title>
    <link href="http://example.com/2023/08/20/PhotoPrism%E9%83%A8%E7%BD%B2%E7%A7%81%E4%BA%BA%E7%9B%B8%E5%86%8C/"/>
    <id>http://example.com/2023/08/20/PhotoPrism%E9%83%A8%E7%BD%B2%E7%A7%81%E4%BA%BA%E7%9B%B8%E5%86%8C/</id>
    <published>2023-08-20T01:48:13.000Z</published>
    <updated>2023-08-20T02:42:00.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-compose-启动"><a href="#Docker-compose-启动" class="headerlink" title="Docker-compose 启动"></a>Docker-compose 启动</h1><p>下载官方的 <code>docker-compose.yml</code> 文件，然后修改一下端口和挂载路径，然后启动即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.photoprism.app/docker/docker-compose.yml</span><br></pre></td></tr></table></figure><blockquote><p>如果无法下载下载地址可以前往 <a href="https://docs.photoprism.app/getting-started/docker-compose/">Docker Compose - PhotoPrism</a> 查看最新。</p></blockquote><p>根据自己需要修改以下参数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">photoprism:</span></span><br><span class="line">    <span class="comment">## Use photoprism/photoprism:preview for testing preview builds:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dockerproxy.com/photoprism/photoprism:latest</span> <span class="comment"># 配置了镜像加速</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2342:2342&quot;</span> <span class="comment"># HTTP port (host:container)</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_ADMIN_USER:</span> <span class="string">&quot;admin&quot;</span>                 <span class="comment"># 管理员用户名</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_ADMIN_PASSWORD:</span> <span class="string">&quot;12345678&quot;</span>          <span class="comment"># 管理员密码</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DETECT_NSFW:</span> <span class="string">&quot;true&quot;</span>                 <span class="comment"># 自动检测 NSFW 图片并标记隐私图片</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_UPLOAD_NSFW:</span> <span class="string">&quot;true&quot;</span>                 <span class="comment"># 运行上传 NSFW 图片   </span></span><br><span class="line">    <span class="comment">## Share hardware devices with FFmpeg and TensorFlow (optional):</span></span><br><span class="line">    <span class="attr">devices:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;/dev/dri:/dev/dri&quot;</span>                           <span class="comment"># 如果有核显或者独显可以配置硬件加速</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/root/sharedfolder/syncthing/Photo_Album:/photoprism/originals/Photo_Album&quot;</span>               <span class="comment"># 照片存放路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/root/sharedfolder/syncthing/daily:/photoprism/originals/daily&quot;</span>               <span class="comment"># 照片存放路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/root/sharedfolder/syncthing/baby:/photoprism/originals/baby&quot;</span>               <span class="comment"># 照片存放路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./storage:/photoprism/storage&quot;</span>                  <span class="comment"># 不要删除 (DO NOT REMOVE)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后启动即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><strong>初始化需要时间，等待一分钟左右</strong>，然后访问 <code>http://&#123;hostip&#125;:2342</code> 即可看到登录界面。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置中文界面"><a href="#配置中文界面" class="headerlink" title="配置中文界面"></a>配置中文界面</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/20/eca4f02a6f2595302abe05ac41f5c965.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/20/b4c5c56ab3eb0242e35a09bd5036885e.png"></p><h2 id="索引照片"><a href="#索引照片" class="headerlink" title="索引照片"></a>索引照片</h2><p>这个过程会调用 TensorFlow 进行照片的 AI 识别，然后自动进行分类，照片如果很多会很慢。如果只想索引某一个目录就点击图片中的区域选择指定目录，<strong>选择目录的过程会加载比较慢</strong>，需要等待。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/20/33a399732f66f9b768007377ffbcb748.png"></p><h1 id="使用相册"><a href="#使用相册" class="headerlink" title="使用相册"></a>使用相册</h1><p>索引完成就可以点击搜索进行查看所有照片了：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/20/c1bc29db426f442362ae17fdd8e29d63.png"></p><p>索引过程会根据照片的 Exif 信息自动分类，包括时间与地点。后悔从相机导出照片时把地点抹去了。</p><p>照片还是得及时整理呀，这成千上万张照片挨个标记还是很麻烦的，就这样吧，做个图片墙也不错。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-compose-启动&quot;&gt;&lt;a href=&quot;#Docker-compose-启动&quot; class=&quot;headerlink&quot; title=&quot;Docker-compose 启动&quot;&gt;&lt;/a&gt;Docker-compose 启动&lt;/h1&gt;&lt;p&gt;下载官方的 &lt;cod</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker 部署 Radarr 刮削电影</title>
    <link href="http://example.com/2023/08/17/Docker%E9%83%A8%E7%BD%B2Radarr%E5%88%AE%E5%89%8A%E7%94%B5%E5%BD%B1/"/>
    <id>http://example.com/2023/08/17/Docker%E9%83%A8%E7%BD%B2Radarr%E5%88%AE%E5%89%8A%E7%94%B5%E5%BD%B1/</id>
    <published>2023-08-17T14:46:26.000Z</published>
    <updated>2023-08-29T14:25:28.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">radarr:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">radarr</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dockerproxy.com/linuxserver/radarr:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7878:7878&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PUID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PGID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">UMASK=002</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/sharedfolder/appdata/radarr:/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/sharedfolder/media:/movies</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/sharedfolder/downloads/qbittorrent:/downloads</span></span><br></pre></td></tr></table></figure><p>配置中文界面：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/17/9dbfcaa5f918bccfa99ce64cc97a7e16.png"></p><p>导入视频：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/17/81a242b30d3ab2d29b7f4bf92ba246de.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker-compose-yml&quot;&gt;&lt;a href=&quot;#docker-compose-yml&quot; class=&quot;headerlink&quot; title=&quot;docker-compose.yml&quot;&gt;&lt;/a&gt;docker-compose.yml&lt;/h1&gt;&lt;figure c</summary>
      
    
    
    
    <category term="工欲善其事必先利其器" scheme="http://example.com/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="NAS" scheme="http://example.com/tags/NAS/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="Radarr" scheme="http://example.com/tags/Radarr/"/>
    
    <category term="Docker-Compose" scheme="http://example.com/tags/Docker-Compose/"/>
    
  </entry>
  
  <entry>
    <title>SSH 免密登录</title>
    <link href="http://example.com/2023/08/12/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2023/08/12/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</id>
    <published>2023-08-12T01:22:56.000Z</published>
    <updated>2023-08-12T02:35:00.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h1><p>宿主机任意下目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/home/user/.ssh/id_rsa): host2servera_id_rsa</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved <span class="keyword">in</span> host2servera_id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> host2servera_id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:OkWcw+R3x6Z2mzeYQuG033H3N9qIeym3TZKzz6YD8tQ user@ubuntu18</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|        .        |</span></span><br><span class="line"><span class="string">|       = .   .   |</span></span><br><span class="line"><span class="string">|        B .o. +  |</span></span><br><span class="line"><span class="string">|       . oo.o+   |</span></span><br><span class="line"><span class="string">|        S  ++ ..o|</span></span><br><span class="line"><span class="string">|       o ..+.A=o=|</span></span><br><span class="line"><span class="string">|      o   +..B+=+|</span></span><br><span class="line"><span class="string">|       .   oo=@o+|</span></span><br><span class="line"><span class="string">|           o=ss= |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p>一直回车确定，生成公私钥，保存在<code>~/.ssh</code>目录下。</p><blockquote><p>我在宿主机上生成的公私钥名称为，分别是<code>host2servera_id_rsa</code>,<code>host2servera_id_rsa.pub</code>方便我记忆。如果一直回车，那么生成的公私钥名称为<code>id_rsa</code>，<code>id_rsa.pub</code>。</p></blockquote><h1 id="发送公钥"><a href="#发送公钥" class="headerlink" title="发送公钥"></a>发送公钥</h1><p>将公钥复制到服务器 ServerA 上，以 IP：<code>10.12.193.53</code> 为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id 10.12.193.53</span><br><span class="line"><span class="comment"># 输入密码</span></span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to <span class="built_in">log</span> <span class="keyword">in</span> with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- <span class="keyword">if</span> you are prompted now it is to install the new keys</span><br><span class="line">user@10.12.193.53<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Number of key(s) added: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Now try logging into the machine, with:   &quot;ssh &#x27;</span>10.12.193.53<span class="string">&#x27;&quot;</span></span><br><span class="line"><span class="string">and check to make sure that only the key(s) you wanted were added.</span></span><br></pre></td></tr></table></figure><p>默认是把 ServerA 的用户当做 user 进行登录。如果有确定的用户如<code>userA</code>，就使用<code>ssh-copy-id userA@10.12.193.53</code></p><p>然后就可以直接免密码登录了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh user@10.12.193.53</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ssh userA@10.12.193.53</span><br></pre></td></tr></table></figure><p>如果还是需要输入密码，可能<code>ssh-agent</code>没有启动，执行<code>eval $(ssh-agent)</code>启动<code>ssh-agent</code>，然后再次登录即可。然后将私钥添加到<code>ssh-agent</code>中，执行<code>ssh-add ~/.ssh/host2servera_id_rsa</code>，然后再次登录即可。</p><h1 id="配置快捷登录"><a href="#配置快捷登录" class="headerlink" title="配置快捷登录"></a>配置快捷登录</h1><p>即使免密登录，输入一长串 IP 也太麻烦了，能不能配置更简单的登录方式，比如给服务器起个名字如<code>ServerA</code>直接使用<code>ssh ServerA</code>就登录服务器，能。</p><p>打开<code>~/.ssh/config</code>配置如下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host ServerA</span><br><span class="line">    HostName 10.12.193.53</span><br><span class="line">    Port 22</span><br><span class="line">    User userA</span><br><span class="line">    IdentityFile ~/.ssh/host2servera_id_rsa</span><br></pre></td></tr></table></figure><p>然后就可以直接使用<code>ssh ServerA</code>登录了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成密钥对&quot;&gt;&lt;a href=&quot;#生成密钥对&quot; class=&quot;headerlink&quot; title=&quot;生成密钥对&quot;&gt;&lt;/a&gt;生成密钥对&lt;/h1&gt;&lt;p&gt;宿主机任意下目录执行：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="工欲善其事必先利其器" scheme="http://example.com/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="SSH,Linux" scheme="http://example.com/tags/SSH-Linux/"/>
    
  </entry>
  
  <entry>
    <title>QEMU常用命令</title>
    <link href="http://example.com/2023/08/06/QEMU%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2023/08/06/QEMU%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2023-08-06T09:22:12.000Z</published>
    <updated>2023-08-06T09:22:28.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QEMU-常用命令总结"><a href="#QEMU-常用命令总结" class="headerlink" title="QEMU 常用命令总结"></a>QEMU 常用命令总结</h1><p>QEMU 是一个开源的虚拟化软件，它能够模拟不同的硬件平台，让用户在不同的操作系统之间进行切换和测试。以下是 QEMU 常用命令的总结文档，包含每个命令的功能说明。</p><h2 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h2><p>以下命令用于启动虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -boot d -cdrom /path/to/iso -m 1024 -hda /path/to/hda.img</span><br></pre></td></tr></table></figure><ul><li>-boot d：从 CD/DVD 启动</li><li>-cdrom /path/to/iso：指定 ISO 文件的路径</li><li>-m 1024：设置虚拟机的内存大小为 1024MB</li><li>-hda /path/to/hda.img：指定虚拟硬盘的路径</li></ul><h2 id="安装系统至磁盘"><a href="#安装系统至磁盘" class="headerlink" title="安装系统至磁盘"></a>安装系统至磁盘</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -cdrom ~/Downloads/ubuntu.iso \</span><br><span class="line">    -drive file=ubuntu.qcow2 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu host \</span><br><span class="line">    -smp cores=2,threads=2 \</span><br><span class="line">    -m 2G \</span><br><span class="line">    -vga virtio \</span><br><span class="line">    -display sdl,gl=on </span><br></pre></td></tr></table></figure><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>以下命令用于配置虚拟机的网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -net nic -net user,hostfwd=tcp::2222-:22</span><br></pre></td></tr></table></figure><ul><li>-net nic：启用虚拟网卡</li><li>-net user：使用用户模式网络堆栈</li><li>hostfwd=tcp::2222-:22：将主机的 2222 端口转发到虚拟机的 22 端口</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>以下命令用于启用调试模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -s -S</span><br></pre></td></tr></table></figure><ul><li>-s：启用 GDB 调试</li><li>-S：在启动时暂停虚拟机，等待调试器连接</li></ul><h2 id="快照管理"><a href="#快照管理" class="headerlink" title="快照管理"></a>快照管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拍快照</span></span><br><span class="line">qemu-img snapshot -c oe-rv-snapshot1  openEuler-22.09-riscv64-qemu.qcow2</span><br><span class="line"><span class="comment"># 列举快照</span></span><br><span class="line">qemu-img snapshot-l openEuler-22.09-riscv64-qemu.qcow2</span><br><span class="line"><span class="comment"># 恢复快照</span></span><br><span class="line">qemu-img snapshot -a my_snapshot mydisk.qcow2</span><br></pre></td></tr></table></figure><h2 id="查看虚拟硬盘信息"><a href="#查看虚拟硬盘信息" class="headerlink" title="查看虚拟硬盘信息"></a>查看虚拟硬盘信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img info /path/to/image</span><br></pre></td></tr></table></figure><h2 id="将虚拟硬盘转换为-QCOW2-格式"><a href="#将虚拟硬盘转换为-QCOW2-格式" class="headerlink" title="将虚拟硬盘转换为 QCOW2 格式"></a>将虚拟硬盘转换为 QCOW2 格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img convert -O qcow2 /path/to/image /path/to/new/image</span><br></pre></td></tr></table></figure><h3 id="调整磁盘大小"><a href="#调整磁盘大小" class="headerlink" title="调整磁盘大小"></a>调整磁盘大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img resize ubuntu.qcow2 +5G</span><br></pre></td></tr></table></figure><h2 id="显示器选项"><a href="#显示器选项" class="headerlink" title="显示器选项"></a>显示器选项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -vga std</span><br><span class="line">qemu-system-x86_64 -display sdl</span><br><span class="line">qemu-system-x86_64 -display gtk</span><br></pre></td></tr></table></figure><ul><li>-vga std：使用标准 VGA 显示器</li><li>-display sdl：使用 SDL 显示器</li><li>-display gtk：使用 GTK 显示器</li></ul><h2 id="输入选项"><a href="#输入选项" class="headerlink" title="输入选项"></a>输入选项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -k en-us</span><br><span class="line">qemu-system-x86_64 -usb</span><br><span class="line">qemu-system-x86_64 -device usb-mouse</span><br></pre></td></tr></table></figure><ul><li>-k en-us：使用英文键盘布局</li><li>-usb：启用 USB 支持</li><li>-device usb-mouse：使用 USB 鼠标设备</li></ul><h2 id="声音选项"><a href="#声音选项" class="headerlink" title="声音选项"></a>声音选项</h2><p>以下命令用于配置虚拟机的声音：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -soundhw all</span><br><span class="line">qemu-system-x86_64 -soundhw sb16</span><br><span class="line">qemu-system-x86_64 -audiodev pa,id=pa1,out.mixing-engine=off</span><br></pre></td></tr></table></figure><ul><li>-soundhw all：启用所有声卡</li><li>-soundhw sb16：启用 SoundBlaster 16 声卡</li><li>-audiodev pa,id=pa1,out.mixing-engine=off：使用 PulseAudio 声音设备</li></ul><h2 id="USB-设备管理"><a href="#USB-设备管理" class="headerlink" title="USB 设备管理"></a>USB 设备管理</h2><p>以下命令用于管理虚拟机的 USB 设备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -usbdevice host:1234:5678</span><br><span class="line">qemu-system-x86_64 -usbdevice tablet</span><br><span class="line">qemu-system-x86_64 -usbdevice keyboard</span><br></pre></td></tr></table></figure><ul><li>-usbdevice host:1234:5678：将主机的 USB 设备 1234:5678 分配给虚拟机</li><li>-usbdevice tablet：使用 USB 触摸板</li><li>-usbdevice keyboard：使用 USB 键盘</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QEMU-常用命令总结&quot;&gt;&lt;a href=&quot;#QEMU-常用命令总结&quot; class=&quot;headerlink&quot; title=&quot;QEMU 常用命令总结&quot;&gt;&lt;/a&gt;QEMU 常用命令总结&lt;/h1&gt;&lt;p&gt;QEMU 是一个开源的虚拟化软件，它能够模拟不同的硬件平台，让用户在</summary>
      
    
    
    
    
    <category term="QEMU" scheme="http://example.com/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>Linux 网络配置常用命令</title>
    <link href="http://example.com/2023/08/05/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2023/08/05/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2023-08-05T07:29:58.000Z</published>
    <updated>2023-08-29T14:22:37.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置网桥-brctl"><a href="#配置网桥-brctl" class="headerlink" title="配置网桥 brctl"></a>配置网桥 brctl</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 br0 的网桥</span></span><br><span class="line">sudo brctl addbr br0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除网桥 br0</span></span><br><span class="line">sudo brctl delbr br0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的网桥及其接口信息</span></span><br><span class="line">sudo brctl show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将网络接口 `eth0` 添加到网桥 `br0` 中</span></span><br><span class="line">sudo brctl addif br0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从网桥 `br0` 中删除网络接口 `eth0`</span></span><br><span class="line">sudo brctl delif br0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment">### 显示网桥 `br0` 的 Spanning Tree Protocol (STP)配置</span></span><br><span class="line">sudo brctl showstp br0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用 Linux 内核中桥接器对数据包进行处理时调用 iptables 的功能。这种配置通常用于提高桥接速度，减少桥接过程中的 CPU 开销。</span></span><br><span class="line">sudo sysctl net.bridge.bridge-nf-call-iptables=0</span><br><span class="line">sudo sysctl net.bridge.bridge-nf-call-iptables=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为虚拟网卡设置IP并启动</span></span><br><span class="line">sudo ifconfig tap0 192.168.2.1 up</span><br></pre></td></tr></table></figure><h1 id="虚拟网络设备-tunctl"><a href="#虚拟网络设备-tunctl" class="headerlink" title="虚拟网络设备 tunctl"></a>虚拟网络设备 tunctl</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为tun0的虚拟网络设备</span></span><br><span class="line">sudo tunctl -t tun0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将虚拟网卡设置为任何人都有权限使用：</span></span><br><span class="line">sudo chmod 0666 /dev/net/tun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除名为tun0的虚拟网络设备</span></span><br><span class="line">sudo tunctl -d tun0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为tun0的虚拟网络设备并指定其拥有者和组</span></span><br><span class="line">sudo tunctl -u user -g group -t tun0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有活跃的虚拟网络设备及其接口信息</span></span><br><span class="line">sudo tunctl -s </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定虚拟网络设备的MAC地址</span></span><br><span class="line">sudo tunctl -m [mac_address] -t tun0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出具有给定设备名称前缀的所有已分配的虚拟网络设备</span></span><br><span class="line">sudo tunctl -g [device_name_prefix]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配虚拟网络设备的文件描述符，将结果输出到标准输出</span></span><br><span class="line">sudo tunctl -p -t tun0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将虚拟网络设备关联到现有的桥接设备</span></span><br><span class="line">sudo tunctl -b -t tun0 -g br0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从现有虚拟网络设备解除关联</span></span><br><span class="line">sudo tunctl -B -t tun0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定虚拟网络设备的最大传输单元(MTU)</span></span><br><span class="line">sudo ip link <span class="built_in">set</span> tun0 mtu [value]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用虚拟网络设备</span></span><br><span class="line">sudo ip link <span class="built_in">set</span> tun0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用虚拟网络设备</span></span><br><span class="line">sudo ip link <span class="built_in">set</span> tun0 down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示由Linux内核管理的虚拟网络设备的状态信息</span></span><br><span class="line">sudo ip link show tun0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改虚拟网络设备的MAC地址</span></span><br><span class="line">sudo ip link <span class="built_in">set</span> dev tun0 address [mac_address]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为虚拟网络设备分配一个IPv4地址</span></span><br><span class="line">sudo ip addr add [ip_address/cidr] dev tun0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从虚拟网络设备中删除一个IPv4地址</span></span><br><span class="line">sudo ip addr del [ip_address/cidr] dev tun0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查虚拟网络设备是否已分配IPv4地址</span></span><br><span class="line">ip addr show tun0 | grep inet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用DLADDR命令获取虚拟网络设备的MAC地址</span></span><br><span class="line">sudo ethtool -P tun0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前所有活动的网络接口</span></span><br><span class="line">ip a </span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查虚拟网络设备是否已分配IPv6地址</span></span><br><span class="line">ip addr show tun0 | grep inet6 </span><br></pre></td></tr></table></figure><h1 id="网络接口管理（ifconfig）"><a href="#网络接口管理（ifconfig）" class="headerlink" title="网络接口管理（ifconfig）"></a>网络接口管理（ifconfig）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有网络接口信息</span></span><br><span class="line">ifconfig -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活指定接口(如 eth0)</span></span><br><span class="line">ifconfig eth0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭指定接口(如 eth0)</span></span><br><span class="line">ifconfig eth0 down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 IP 地址，例如添加 IP 地址为 192.168.2.100 的网卡 eth0</span></span><br><span class="line">ifconfig eth0 192.168.2.100 netmask 255.255.255.0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 IP 地址，例如删除网卡 eth0 上的 IP 地址</span></span><br><span class="line">ifconfig eth0 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用或禁用广播地址</span></span><br><span class="line">ifconfig eth0 broadcast 192.168.2.255 up</span><br><span class="line">ifconfig eth0 -broadcast</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置网卡 mtu 大小为 9000</span></span><br><span class="line">ifconfig eth0 mtu 9000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个虚拟网络接口 eth0:1，并配置 IP 地址为 192.168.2.100</span></span><br><span class="line">ifconfig eth0:1 192.168.2.100 netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure><h1 id="路由管理（route）"><a href="#路由管理（route）" class="headerlink" title="路由管理（route）"></a>路由管理（route）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前路由表</span></span><br><span class="line">route -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加默认路由</span></span><br><span class="line">route add default gw 192.168.2.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除默认路由</span></span><br><span class="line">route del default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个到目标网络的静态路由</span></span><br><span class="line">route add -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.2.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除静态路由</span></span><br><span class="line">route del -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.2.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除所有路由缓存项</span></span><br><span class="line">route flush cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 IP 地址对应网卡接口的 MAC 地址</span></span><br><span class="line">arping -I eth0 192.168.2.1</span><br></pre></td></tr></table></figure><h1 id="DNS-解析（nslookup-和-dig）"><a href="#DNS-解析（nslookup-和-dig）" class="headerlink" title="DNS 解析（nslookup 和 dig）"></a>DNS 解析（nslookup 和 dig）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用域名服务器解析域名</span></span><br><span class="line">nslookup www.example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定域名服务器，并解析域名</span></span><br><span class="line">nslookup www.example.com 8.8.8.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询DNS地址</span></span><br><span class="line">dig example.com +nssearch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询所有的 NS 记录</span></span><br><span class="line">dig example.com NS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询某个域名的 MX 记录</span></span><br><span class="line">dig example.com MX</span><br></pre></td></tr></table></figure><h1 id="网络诊断工具（ping-和-traceroute）"><a href="#网络诊断工具（ping-和-traceroute）" class="headerlink" title="网络诊断工具（ping 和 traceroute）"></a>网络诊断工具（ping 和 traceroute）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试与目标主机之间的连通性，查看网络是否可达</span></span><br><span class="line">ping 192.168.2.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># ping 命令的高级选项，控制发送的数据包数量、大小和时间间隔等参数</span></span><br><span class="line">ping -c 5 -s 100 -i 1 192.168.2.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示数据包在网络上的传输路径，检测网络故障</span></span><br><span class="line">traceroute www.google.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示每一跳所经过的路由器名称和 IP 地址</span></span><br><span class="line">traceroute -n www.google.com</span><br></pre></td></tr></table></figure><h1 id="网络流量分析工具（tcpdump-和-wireshark）"><a href="#网络流量分析工具（tcpdump-和-wireshark）" class="headerlink" title="网络流量分析工具（tcpdump 和 wireshark）"></a>网络流量分析工具（tcpdump 和 wireshark）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听指定的网络接口上的数据包，显示每个数据包的详细信息</span></span><br><span class="line">tcpdump -i eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听指定端口上的数据包</span></span><br><span class="line">tcpdump port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示从指定源地址到目标地址的所有网络流量</span></span><br><span class="line">tcpdump src 192.168.2.100 and dst 192.168.2.200</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有 IP 流量，并将结果保存到文件 tcp.pcap 中，以便使用 Wireshark 分析</span></span><br><span class="line">tcpdump -i eth0 -w tcp.pcap ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图形化的网络协议分析工具，用于分析网络流量</span></span><br><span class="line">wireshark</span><br></pre></td></tr></table></figure><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示网络连接状态和统计信息</span></span><br><span class="line">netstat -an</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 TCP/IP 配置参数</span></span><br><span class="line">sysctl net.ipv4.tcp_*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 TCP/IP 参数，例如设置 SYN 攻击保护</span></span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载 /etc/resolv.conf 文件</span></span><br><span class="line">systemd-resolve --flush-caches</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前 DNS 服务器</span></span><br><span class="line">systemd-resolve --status | grep <span class="string">&#x27;DNS Servers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启网络</span></span><br><span class="line">systemctl restart NetworkManager</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;配置网桥-brctl&quot;&gt;&lt;a href=&quot;#配置网桥-brctl&quot; class=&quot;headerlink&quot; title=&quot;配置网桥 brctl&quot;&gt;&lt;/a&gt;配置网桥 brctl&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
    <category term="Linux,网络配置" scheme="http://example.com/tags/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>QEMU 虚拟机网络配置</title>
    <link href="http://example.com/2023/08/05/QEMU%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2023/08/05/QEMU%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2023-08-05T06:47:54.000Z</published>
    <updated>2023-08-29T14:23:32.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quick-Setup"><a href="#Quick-Setup" class="headerlink" title="Quick Setup"></a>Quick Setup</h1><h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><p>安装两个网络管理工具用于建立网桥以及虚拟网卡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装虚拟网桥工具</span></span><br><span class="line">sudo apt install bridge-utils -y</span><br><span class="line"><span class="comment"># UML（User-mode linux）工具        </span></span><br><span class="line">sudo apt install uml-utilities  -y   </span><br></pre></td></tr></table></figure><h2 id="配置脚本"><a href="#配置脚本" class="headerlink" title="配置脚本"></a>配置脚本</h2><h3 id="qemu-ifup"><a href="#qemu-ifup" class="headerlink" title="qemu-ifup"></a>qemu-ifup</h3><p>将下面的脚本保存为文件 <code>qemu-ifup</code>，并赋予可执行权限：</p><blockquote><p>为了方便复制脚本，在 confluence 页面提供了脚本内容，可以直接复制。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/qemu</span><br><span class="line">mv qemu-ifup /etc/qemu &amp;&amp; mv qemu-ifdown /etc/qemu </span><br><span class="line">sudo chmod +x qemu-ifup</span><br><span class="line">sudo chmod +x qemu-ifdown</span><br></pre></td></tr></table></figure><p>因为网卡信息不容易定位，可能一台机器有多个网卡，所以不方便用脚本获取，需要手动设置一下。将下面的<code>NIC</code>值修改为宿主机可以上网的网卡名称。可以通过<code>ifconfig</code>命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 设置默认网卡信息</span></span><br><span class="line">NIC=enp2s0</span><br><span class="line"><span class="comment"># 设置用户名</span></span><br><span class="line">USER_NAME=user</span><br><span class="line"><span class="comment"># 设置网桥名称</span></span><br><span class="line">BRIDGE=br0</span><br><span class="line"><span class="comment"># 设置网络信息</span></span><br><span class="line">NIC_IP=$(ifconfig <span class="variable">$NIC</span> | grep <span class="string">&quot;inet\b&quot;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">NIC_NETMAST=$(ifconfig <span class="variable">$NIC</span> | grep <span class="string">&quot;inet\b&quot;</span> | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">NIC_BROADCAST=$(ifconfig <span class="variable">$NIC</span> | grep <span class="string">&quot;inet\b&quot;</span> | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">NETMASK=255.255.240.0</span><br><span class="line"><span class="comment"># 设置默认网关地址</span></span><br><span class="line">GATEWAY=10.12.192.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取宿主机网卡MAC地址，因为创建的网桥MAC地址是随机的，</span></span><br><span class="line"><span class="comment"># 无法接入公司，需要从开发机网卡将其MAC地址赋值给网桥</span></span><br><span class="line">MAC=$(ifconfig <span class="variable">$NIC</span> | grep <span class="string">&quot;ether\b&quot;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查网桥是否已创建，已创建就忽略</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">check_bridge</span></span>() </span><br><span class="line">&#123;</span><br><span class="line">    echO <span class="string">&quot;Check bridge...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> brctl show | grep <span class="string">&quot;^<span class="variable">$BRIDGE</span>&quot;</span> &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网桥</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">create_bridge</span></span>() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Start Create bridge...&quot;</span></span><br><span class="line">    brctl addbr <span class="string">&quot;<span class="variable">$BRIDGE</span>&quot;</span></span><br><span class="line">    brctl addif <span class="string">&quot;<span class="variable">$BRIDGE</span>&quot;</span>  <span class="string">&quot;<span class="variable">$NIC</span>&quot;</span></span><br><span class="line">    ifconfig br0 0.0.0.0 promisc up</span><br><span class="line">    dhclient <span class="variable">$BRIDGE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ifconfig &quot;$BRIDGE&quot; &quot;$NIC_IP&quot; netmask &quot;$NIC_NETMAST&quot; broadcast &quot;$NIC_BROADCAST&quot;  hw ether &quot;$MAC&quot; promisc up</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用IP转发</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">enable_ip_forward</span></span>() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置网桥</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">setup_bridge</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    check_bridge <span class="string">&quot;<span class="variable">$BRIDGE</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        create_bridge</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    enable_ip_forward</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    setup_bridge</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Creating <span class="variable">$1</span>...&quot;</span></span><br><span class="line">    tunctl -t <span class="string">&quot;<span class="variable">$1</span>&quot;</span> -u <span class="string">&quot;<span class="variable">$USER_NAME</span>&quot;</span></span><br><span class="line">    ifconfig <span class="string">&quot;<span class="variable">$1</span>&quot;</span> 0.0.0.0 up</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Adding <span class="variable">$1</span> to <span class="variable">$BRIDGE</span>...&quot;</span></span><br><span class="line">    brctl addif <span class="string">&quot;<span class="variable">$BRIDGE</span>&quot;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">    sleep 5</span><br><span class="line">    ifconfig <span class="string">&quot;<span class="variable">$BRIDGE</span>&quot;</span>  hw ether <span class="string">&quot;<span class="variable">$MAC</span>&quot;</span> promisc up</span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: no interface specified.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="qemu-ifdown"><a href="#qemu-ifdown" class="headerlink" title="qemu-ifdown"></a>qemu-ifdown</h3><p>以下是<code>qemu-ifdown</code>脚本，用于在关闭 QEMU 时关闭虚拟网卡，将其从网桥中移除，删除虚拟网卡。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 设置网桥名称</span></span><br><span class="line">BRIDGE=br0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 将tap设备从网桥中移除</span></span><br><span class="line">brctl delif <span class="variable">$&#123;BRIDGE&#125;</span> <span class="variable">$1</span></span><br><span class="line"><span class="comment"># 关闭tap设备</span></span><br><span class="line">ip link link <span class="variable">$1</span> down</span><br><span class="line">    <span class="comment"># 删除tap设备</span></span><br><span class="line">    ip link del <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">tunctl -d <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Error: no interface specified&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>将系统镜像复制一份并修改文件名，QEMU 不能同时使用一个镜像启动两个虚拟机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp openEuler-22.09-riscv64-qemu.qcow2 openEuler-22.09-riscv64-qemu-vm1.qcow2</span><br></pre></td></tr></table></figure><p>需要修改启动脚本中的镜像文件名，以及启动参数，将<code>drive</code>以及<code>cmd</code>变量的内容覆盖为下面的内容，修改<code>mac</code>为分配给自己的虚拟机的 MAC 地址，<code>script</code>为上面的脚本<code>qemu-ifup</code>的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该脚本用于启动VM0</span></span><br><span class="line">drive=<span class="string">&quot;openEuler-22.09-riscv64-qemu.qcow2&quot;</span></span><br><span class="line">....</span><br><span class="line">cmd=<span class="string">&quot;qemu-system-riscv64 \</span></span><br><span class="line"><span class="string">  -nographic -machine virt \</span></span><br><span class="line"><span class="string">  -smp &quot;</span><span class="variable">$vcpu</span><span class="string">&quot; -m &quot;</span><span class="variable">$memory</span><span class="string">&quot;G \</span></span><br><span class="line"><span class="string">  -bios &quot;</span><span class="variable">$fw</span><span class="string">&quot; \</span></span><br><span class="line"><span class="string">  -drive file=&quot;</span><span class="variable">$drive</span><span class="string">&quot;,format=qcow2,id=hd0 \</span></span><br><span class="line"><span class="string">  -object rng-random,filename=/dev/urandom,id=rng0 \</span></span><br><span class="line"><span class="string">  -device virtio-vga \</span></span><br><span class="line"><span class="string">  -device virtio-rng-device,rng=rng0 \</span></span><br><span class="line"><span class="string">  -device virtio-blk-device,drive=hd0 \</span></span><br><span class="line"><span class="string">  -device virtio-net-device,netdev=tapnet,mac=e0:be:03:88:54:e8 \</span></span><br><span class="line"><span class="string">  -netdev tap,id=tapnet,script=/etc/qemu/qemu-ifup,downscript=/etc/qemu/qemu-ifdown \</span></span><br><span class="line"><span class="string">  -device qemu-xhci -usb -device usb-kbd -device usb-tablet&quot;</span></span><br></pre></td></tr></table></figure><p>以<code>sudo</code>权限启动脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./preview_start_vm0.sh</span><br></pre></td></tr></table></figure><p>以下为配置 VM1 过程，VM1 的启动脚本与 VM0 的启动脚本类似，只需要修改<code>drive</code>以及<code>MAC</code>，必须保证<code>MAC</code>与 VM0 的<code>MAC</code>不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该脚本用于启动VM1</span></span><br><span class="line">drive=<span class="string">&quot;openEuler-22.09-riscv64-qemu.qcow2&quot;</span></span><br><span class="line">....</span><br><span class="line">cmd=<span class="string">&quot;qemu-system-riscv64 \</span></span><br><span class="line"><span class="string">  -nographic -machine virt \</span></span><br><span class="line"><span class="string">  -smp &quot;</span><span class="variable">$vcpu</span><span class="string">&quot; -m &quot;</span><span class="variable">$memory</span><span class="string">&quot;G \</span></span><br><span class="line"><span class="string">  -bios &quot;</span><span class="variable">$fw</span><span class="string">&quot; \</span></span><br><span class="line"><span class="string">  -drive file=&quot;</span><span class="variable">$drive</span><span class="string">&quot;,format=qcow2,id=hd0 \</span></span><br><span class="line"><span class="string">  -object rng-random,filename=/dev/urandom,id=rng0 \</span></span><br><span class="line"><span class="string">  -device virtio-vga \</span></span><br><span class="line"><span class="string">  -device virtio-rng-device,rng=rng0 \</span></span><br><span class="line"><span class="string">  -device virtio-blk-device,drive=hd0 \</span></span><br><span class="line"><span class="string">  -device virtio-net-device,netdev=tapnet,mac=80:d4:09:62:cd:3c \</span></span><br><span class="line"><span class="string">  -netdev tap,id=tapnet,script=/etc/qemu/qemu-ifup,downscript=/etc/qemu/qemu-ifdown \</span></span><br><span class="line"><span class="string">  -device qemu-xhci -usb -device usb-kbd -device usb-tablet&quot;</span></span><br></pre></td></tr></table></figure><h2 id="网络通信测试"><a href="#网络通信测试" class="headerlink" title="网络通信测试"></a>网络通信测试</h2><p>当前网络状态如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HOST:10.12.192.177</span><br><span class="line">VM0:10.12.193.53</span><br><span class="line">VM1:10.12.193.101</span><br></pre></td></tr></table></figure><h3 id="HOST-–-gt-VM0"><a href="#HOST-–-gt-VM0" class="headerlink" title="HOST –&gt; VM0"></a>HOST –&gt; VM0</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user @ ubuntu18 in ~/openeuler/openEuler2209 [18:41:54] </span></span><br><span class="line">$ ping -c 3 10.12.193.101</span><br><span class="line">PING 10.12.193.101 (10.12.193.101) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.12.193.101: icmp_seq=1 ttl=64 time=1.37 ms</span><br><span class="line">64 bytes from 10.12.193.101: icmp_seq=2 ttl=64 time=0.897 ms</span><br><span class="line">64 bytes from 10.12.193.101: icmp_seq=3 ttl=64 time=0.890 ms</span><br><span class="line"></span><br><span class="line">--- 10.12.193.101 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</span><br><span class="line">rtt min/avg/max/mdev = 0.890/1.055/1.378/0.228 ms</span><br></pre></td></tr></table></figure><p>Host –&gt; VM1 的测试结果与 Host –&gt; VM0 的测试结果相同。</p><h3 id="VM0-–-gt-HOST"><a href="#VM0-–-gt-HOST" class="headerlink" title="VM0 –&gt; HOST"></a>VM0 –&gt; HOST</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler-riscv64 ~]<span class="comment"># ping -c 3 10.12.193.53 </span></span><br><span class="line">PING 10.12.193.53 (10.12.193.53) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.12.193.53: icmp_seq=1 ttl=64 time=0.716 ms</span><br><span class="line">64 bytes from 10.12.193.53: icmp_seq=2 ttl=64 time=1.74 ms</span><br><span class="line">64 bytes from 10.12.193.53: icmp_seq=3 ttl=64 time=1.81 ms</span><br><span class="line"></span><br><span class="line">--- 10.12.193.53 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2009ms</span><br><span class="line">rtt min/avg/max/mdev = 0.716/1.424/1.812/0.501 ms</span><br></pre></td></tr></table></figure><p>VM1 –&gt; Host 的测试结果与 Host –&gt; VM0 的测试结果相同。</p><h3 id="VM1-–-gt-VM0"><a href="#VM1-–-gt-VM0" class="headerlink" title="VM1 –&gt; VM0"></a>VM1 –&gt; VM0</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler-riscv64 ~]<span class="comment"># ping -c 3 10.12.193.53 </span></span><br><span class="line">PING 10.12.193.53 (10.12.193.53) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.12.193.53: icmp_seq=1 ttl=64 time=0.716 ms</span><br><span class="line">64 bytes from 10.12.193.53: icmp_seq=2 ttl=64 time=1.74 ms</span><br><span class="line">64 bytes from 10.12.193.53: icmp_seq=3 ttl=64 time=1.81 ms</span><br><span class="line"></span><br><span class="line">--- 10.12.193.53 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2009ms</span><br><span class="line">rtt min/avg/max/mdev = 0.716/1.424/1.812/0.501 ms</span><br></pre></td></tr></table></figure><p>VM0 –&gt; VM1 与 VM1 –&gt; VM0 的测试结果相同。</p><h3 id="VM0-–-gt-github"><a href="#VM0-–-gt-github" class="headerlink" title="VM0 –&gt; github"></a>VM0 –&gt; github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler-riscv64 ~]<span class="comment"># ping -c 4 github.com</span></span><br><span class="line">PING github.com (192.30.255.113) 56(84) bytes of data.</span><br><span class="line">64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=1 ttl=46 time=221 ms</span><br><span class="line">64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=2 ttl=46 time=277 ms</span><br><span class="line">64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=3 ttl=46 time=216 ms</span><br><span class="line">64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=4 ttl=46 time=218 ms</span><br><span class="line"></span><br><span class="line">--- github.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3014ms</span><br><span class="line">rtt min/avg/max/mdev = 215.984/232.733/276.593/25.374 ms</span><br></pre></td></tr></table></figure><h3 id="HOST-–-gt-github"><a href="#HOST-–-gt-github" class="headerlink" title="HOST –&gt; github"></a>HOST –&gt; github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user @ ubuntu18 in ~/openeuler/openEuler2209 [17:59:40] </span></span><br><span class="line">$ ping -c 3  github.com</span><br><span class="line">PING github.com (192.30.255.113) 56(84) bytes of data.</span><br><span class="line">64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=1 ttl=46 time=218 ms</span><br><span class="line">64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=2 ttl=46 time=216 ms</span><br><span class="line">64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=3 ttl=46 time=216 ms</span><br><span class="line"></span><br><span class="line">--- github.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</span><br><span class="line">rtt min/avg/max/mdev = 216.252/217.087/218.409/0.945 ms</span><br></pre></td></tr></table></figure><h1 id="原理探究-Ongoing"><a href="#原理探究-Ongoing" class="headerlink" title="原理探究 (Ongoing)"></a>原理探究 (Ongoing)</h1><h2 id="Step-by-Step-解析"><a href="#Step-by-Step-解析" class="headerlink" title="Step by Step 解析"></a>Step by Step 解析</h2><p>查看一下网络接口信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">enp3s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.12.192.173  netmask 255.255.240.0  broadcast 10.12.207.255</span><br><span class="line">        inet6 fe80::a00:27ff:fe32:e709  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 08:00:27:32:e7:09  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 6017  bytes 5412928 (5.4 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1979  bytes 179467 (179.4 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 125  bytes 10142 (10.1 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 125  bytes 10142 (10.1 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>创建一个名为<code>br0</code>的网桥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl addbr br0</span><br></pre></td></tr></table></figure><p>将网桥与宿主机的网卡绑定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl addif br0 enp3s0</span><br></pre></td></tr></table></figure><p>启用 <code>br0</code> 接口，并从 DHCP 服务器获得 IP 地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig br0 0.0.0.0 promisc up</span><br><span class="line">sudo dhclient br0</span><br></pre></td></tr></table></figure><p>查看虚拟网桥列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl show br0</span><br><span class="line"></span><br><span class="line">bridge name    bridge id    STP enabled    interfaces</span><br><span class="line">br0            8000.e0be0388eec9  no             enp3s0</span><br></pre></td></tr></table></figure><p>查看 <code>br0</code> 的各接口信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl showstp br0</span><br><span class="line">br0</span><br><span class="line"> bridge id8000.e0be0388eec9</span><br><span class="line"> designated root8000.e0be0388eec9</span><br><span class="line"> root port0path cost 0</span><br><span class="line"> max age20.00s</span><br><span class="line"> forward delay15.00s</span><br><span class="line"> hello time2.00s</span><br><span class="line"> ageing time300.00s</span><br><span class="line"> hello timer0.00s&lt;tbd&gt;</span><br><span class="line"> forward timer0.00s&lt;tbd&gt;</span><br><span class="line"> ageing timer0.00s&lt;tbd&gt;</span><br><span class="line"> </span><br><span class="line"> enp3s0 (1)</span><br><span class="line"> port id8001<span class="built_in">local</span> state forwarding</span><br><span class="line"> designated root8000.08002732e709</span><br><span class="line"> path cost100</span><br><span class="line"> designated bridge8000.08002732e709</span><br><span class="line"> designated port8001</span><br><span class="line"> forward delay15.00s</span><br><span class="line"> hello time2.00s</span><br><span class="line"> max age20.00s</span><br><span class="line"> ageing time300.00s</span><br><span class="line"> priority128</span><br></pre></td></tr></table></figure><p>当前网络拓扑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            +-----------------------------------+</span><br><span class="line">            |          Internet                 |</span><br><span class="line">            +-----------------------------------+</span><br><span class="line">                             |</span><br><span class="line">                             |</span><br><span class="line">                             v</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                   enp3s0 (Host Interface)               |</span><br><span class="line">|                   IP: 10.12.192.173                     |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">                            |</span><br><span class="line">                            v</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                         br0 (Bridge)                    |</span><br><span class="line">|                      IP: 10.12.192.173                  |</span><br><span class="line">+---------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>创建一个 <code>tap0</code> 接口用于<code>VM0</code>使用，允许 <code>user</code> 用户访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tunctl -t tap0 -u user       </span><br></pre></td></tr></table></figure><p>在虚拟网桥中增加 <code>tap0</code> 接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl addif br0 tap0</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">启用 tap0 接口，混杂模式</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up</span><br></pre></td></tr></table></figure><p>将网桥的 MAC 地址修改为宿主机的 MAC 地址，这样就可以接入公司网络了。否则因为内网的 MAC 地址过滤，无法接入公司网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br0  hw ether 08:00:27:32:e7:09  promisc up</span><br></pre></td></tr></table></figure><p>查看虚拟网桥列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo brctl show br0</span><br><span class="line"></span><br><span class="line">bridge name    bridge id    STP enabled    interfaces</span><br><span class="line">br0            8000.08002732e709  no             enp3s0</span><br><span class="line">                                                        tap0</span><br></pre></td></tr></table></figure><p>查看当前的网桥状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ sudo brctl showstp br0 </span><br><span class="line">br0</span><br><span class="line"> bridge id8000.08002732e709</span><br><span class="line"> designated root8000.08002732e709</span><br><span class="line"> root port   0path cost   0</span><br><span class="line"> max age  20.00bridge max age  20.00</span><br><span class="line"> hello time   2.00bridge hello time   2.00</span><br><span class="line"> forward delay  15.00bridge forward delay  15.00</span><br><span class="line"> ageing time 300.00</span><br><span class="line"> hello timer   0.00tcn timer   0.00</span><br><span class="line"> topology change timer   0.00gc timer   7.75</span><br><span class="line"> flags</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enp2s0 (1)</span><br><span class="line"> port id8001state     forwarding</span><br><span class="line"> designated root8000.08002732e709path cost   4</span><br><span class="line"> designated bridge8000.08002732e709message age timer   0.00</span><br><span class="line"> designated port8001forward delay timer   0.00</span><br><span class="line"> designated cost   0hold timer   0.00</span><br><span class="line"> flags</span><br><span class="line"></span><br><span class="line">tap0 (2)</span><br><span class="line"> port id8002state     disabled</span><br><span class="line"> designated root8000.08002732e709path cost 100</span><br><span class="line"> designated bridge8000.08002732e709message age timer   0.00</span><br><span class="line"> designated port8002forward delay timer   0.00</span><br><span class="line"> designated cost   0hold timer   0.00</span><br><span class="line"> flags</span><br></pre></td></tr></table></figure><p><code>tap0</code>可能处于<code>disabled</code>状态，因为还没有虚拟机使用它。启动虚拟机之后会自动切换到<code>forwarding</code>状态。</p><p>当前网络拓扑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">            +-----------------------------------+</span><br><span class="line">            |          Internet                 |</span><br><span class="line">            +-----------------------------------+</span><br><span class="line">                             |</span><br><span class="line">                             |</span><br><span class="line">                             v</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                   enp3s0 (Host Interface)               |</span><br><span class="line">|                   IP: 10.12.192.173                     |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">                            |</span><br><span class="line">                            v</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                         br0 (Bridge)                    |</span><br><span class="line">|                      IP: 10.12.192.173                  |</span><br><span class="line">|                  +---------------------+                |</span><br><span class="line">|                  |        tap0         |                |</span><br><span class="line">|                  |     IP: 0.0.0.0     |                |</span><br><span class="line">+---------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>启动 QEMU</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cmd=<span class="string">&quot;qemu-system-riscv64 \</span></span><br><span class="line"><span class="string">  -nographic -machine virt \</span></span><br><span class="line"><span class="string">  -smp &quot;</span><span class="variable">$vcpu</span><span class="string">&quot; -m &quot;</span><span class="variable">$memory</span><span class="string">&quot;G \</span></span><br><span class="line"><span class="string">  -bios &quot;</span><span class="variable">$fw</span><span class="string">&quot; \</span></span><br><span class="line"><span class="string">  -drive file=&quot;</span><span class="variable">$drive</span><span class="string">&quot;,format=qcow2,id=hd0 \</span></span><br><span class="line"><span class="string">  -object rng-random,filename=/dev/urandom,id=rng0 \</span></span><br><span class="line"><span class="string">  -device virtio-vga \</span></span><br><span class="line"><span class="string">  -device virtio-rng-device,rng=rng0 \</span></span><br><span class="line"><span class="string">  -device virtio-blk-device,drive=hd0 \</span></span><br><span class="line"><span class="string">  -device virtio-net-device,netdev=tapnet,mac=e0:be:03:88:54:e8 \</span></span><br><span class="line"><span class="string">  -netdev tap,id=tapnet,ifname=tap0,script=no,downscript=no \</span></span><br><span class="line"><span class="string">  -device qemu-xhci -usb -device usb-kbd -device usb-tablet&quot;</span></span><br></pre></td></tr></table></figure><p>关注这段脚本的网络配置部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-device virtio-net-device,netdev=tapnet,mac=e0:be:03:88:54:e8 \</span><br><span class="line">-netdev tap,id=tapnet,ifname=tap0,script=no,downscript=no \</span><br></pre></td></tr></table></figure><p>详细解释可以查看“QEMU 网络虚拟化章节”，第一个参数 <code>-device virtio-net-device</code> 定义了名为 <code>virtio-net-device</code> 的网络设备，并将其连接到一个名为 <code>tapnet</code> 的网络设备上，指定它的 MAC 地址为 <code>e0:be:03:88:54:e8</code>。第二个参数 <code>-netdev tap</code> 用于指定后端实现，使用<code>tap</code>方式，并且指定唯一 ID 为<code>tapnet</code>由<code>-device</code>参数中的子参数<code>netdev</code>使用，指定<code>ifname=tap0</code>，表示使用<code>tap0</code>接口作为虚拟化的后端。<code>script=no</code>和<code>downscript=no</code>表示不使用脚本来启动和关闭<code>tap0</code>接口。</p><p>查看当前的网络接口信息<code>ifconfig</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">br0: flags=4419&lt;UP,BROADCAST,RUNNING,PROMISC,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.12.192.173  netmask 255.255.240.0  broadcast 10.12.207.255</span><br><span class="line">        inet6 fe80::e2be:3ff:fe88:eec9  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 08:00:27:32:e7:09  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 861148  bytes 310707296 (310.7 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 17556062  bytes 1516515693 (1.5 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">enp2s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.12.192.173  netmask 255.255.240.0  broadcast 10.12.207.255</span><br><span class="line">        inet6 fe80::4964:61f8:420d:6781  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 08:00:27:32:e7:09  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 894523  bytes 325547917 (325.5 MB)</span><br><span class="line">        RX errors 0  dropped 1926  overruns 0  frame 0</span><br><span class="line">        TX packets 17563568  bytes 1516947572 (1.5 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 1654925876  bytes 134933568498 (134.9 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1654925876  bytes 134933568498 (134.9 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">tap0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::f8ae:85ff:fed7:f9cd  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether fa:ae:85:d7:f9:<span class="built_in">cd</span>  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 557  bytes 44913 (44.9 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 7165  bytes 832171 (832.1 KB)</span><br><span class="line">        TX errors 0  dropped 55942 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>当前网络拓扑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">            +-----------------------------------+</span><br><span class="line">            |          Internet                 |</span><br><span class="line">            +-----------------------------------+</span><br><span class="line">                             |</span><br><span class="line">                             |</span><br><span class="line">                             v</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                   enp3s0 (Host Interface)               |</span><br><span class="line">|                   IP: 10.12.192.173                     |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">                            |</span><br><span class="line">                            v</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                         br0 (Bridge)                    |</span><br><span class="line">|                      IP: 10.12.192.173                  |</span><br><span class="line">|                  +---------------------+                |</span><br><span class="line">|                  |        tap0         |                |</span><br><span class="line">|                  |     IP: 0.0.0.0     |                |</span><br><span class="line">+---------------------------|-----------------------------+</span><br><span class="line">                            |</span><br><span class="line">                            v</span><br><span class="line">+---------------------------|-----------------------------+</span><br><span class="line">|                  |        eth0         |                |</span><br><span class="line">|                  |     IP:10.12.193.53 |                |</span><br><span class="line">|                  +---------------------+                |</span><br><span class="line">|                     VM0 (QEMU)                          |</span><br><span class="line">+---------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>查看当前的网桥状态，可以看到 tap0 已经处于 forwarding 状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo brctl showstp br0 </span><br><span class="line">br0</span><br><span class="line"> bridge id8000.08002732e709</span><br><span class="line"> designated root8000.08002732e709</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enp2s0 (1)</span><br><span class="line"> port id8001state     forwarding</span><br><span class="line"> designated root8000.08002732e709path cost   4</span><br><span class="line"> designated bridge8000.08002732e709message age </span><br><span class="line"></span><br><span class="line">tap0 (2)</span><br><span class="line"> port id8002state     forwarding</span><br><span class="line"> designated root8000.08002732e709path cost 100</span><br><span class="line"> designated bridge8000.08002732e709message age </span><br></pre></td></tr></table></figure><p>添加 VM1 过程就忽略了，添加后的网络拓扑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">            +-----------------------------------+</span><br><span class="line">            |          Internet                 |</span><br><span class="line">            +-----------------------------------+</span><br><span class="line">                             |</span><br><span class="line">                             |</span><br><span class="line">                             v</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                   enp3s0 (Host Interface)               |</span><br><span class="line">|                   IP: 10.12.192.173                     |</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">                            |</span><br><span class="line">                            v</span><br><span class="line">+---------------------------------------------------------+</span><br><span class="line">|                         br0 (Bridge)                    |</span><br><span class="line">|                      IP: 10.12.192.173                  |</span><br><span class="line">|    +---------------------+  +-------------------+       |</span><br><span class="line">|    |        tap0         |  |        tap1       |       |</span><br><span class="line">|    |     IP: 0.0.0.0     |  |     IP: 0.0.0.0   |       |</span><br><span class="line">+---------------|-------------------------|---------------+</span><br><span class="line">                |                         |</span><br><span class="line">                v                         v</span><br><span class="line">+---------------|----------+  +-----------|---------------+</span><br><span class="line">|   |     eth0         |   |  |   |        eth0       |   |</span><br><span class="line">|   |  IP:10.12.193.53 |   |  |   |  IP:10.12.193.101 |   |</span><br><span class="line">|   +---------------------+|  |   +-------------------+   |</span><br><span class="line">|         VM0 (QEMU)       |  |         VM1 (QEMU)        |</span><br><span class="line">+--------------------------+  +---------------------------+</span><br></pre></td></tr></table></figure><h2 id="QEMU-网络虚拟化"><a href="#QEMU-网络虚拟化" class="headerlink" title="QEMU 网络虚拟化"></a>QEMU 网络虚拟化</h2><p>QEMU 对于网络的虚拟化需要两个参数来指定：</p><ul><li>其中一个用于指定网络的前端驱动，也就是 Guest 中的实现</li><li>另一个用于指定网络的后端实现，也就是在 Host 中的实现。</li></ul><p>QEMU 支持两种方式来实现网络虚拟化，一种是旧版本上使用的参数为 <code>-net</code> 配合 <code>-net</code> ，另一种是在新版本上支持的 <code>-device</code> 配合 <code>-netdev</code> 。QEMU 的发展趋势是倾向于用 <code>-device</code> 一种命令格式来虚拟出不同的设备，其中包括网卡设备。</p><h3 id="net-amp-net-legacy"><a href="#net-amp-net-legacy" class="headerlink" title="-net &amp; -net (legacy)"></a>-net &amp; -net (legacy)</h3><p>虽然仍然支持，但是逐步被废弃，不推荐使用。</p><p>我们以以下命令为例，来说明 <code>-net</code> 和 <code>-net</code> 的使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vcpu=8</span><br><span class="line">memory=8</span><br><span class="line">drive=<span class="string">&quot;openEuler-22.09-V1-riscv64-qemu.qcow2&quot;</span></span><br><span class="line">fw=<span class="string">&quot;fw_payload_oe_qemuvirt.elf&quot;</span></span><br><span class="line"></span><br><span class="line">cmd=<span class="string">&quot;qemu-system-riscv64 \</span></span><br><span class="line"><span class="string">  -nographic -machine virt \</span></span><br><span class="line"><span class="string">  -smp &quot;</span><span class="variable">$vcpu</span><span class="string">&quot; -m &quot;</span><span class="variable">$memory</span><span class="string">&quot;G \</span></span><br><span class="line"><span class="string">  -kernel &quot;</span><span class="variable">$fw</span><span class="string">&quot; \</span></span><br><span class="line"><span class="string">  -bios none \</span></span><br><span class="line"><span class="string">  -drive file=&quot;</span><span class="variable">$drive</span><span class="string">&quot;,format=qcow2,id=hd0 \</span></span><br><span class="line"><span class="string">  -object rng-random,filename=/dev/urandom,id=rng0 \</span></span><br><span class="line"><span class="string">  -device virtio-vga \</span></span><br><span class="line"><span class="string">  -device virtio-rng-device,rng=rng0 \</span></span><br><span class="line"><span class="string">  -device virtio-blk-device,drive=hd0 \</span></span><br><span class="line"><span class="string">  -net nic,mac=52:54:00:12:34:56 \</span></span><br><span class="line"><span class="string">  -net tap,ifname=tap0,script=no,downscript=no \</span></span><br><span class="line"><span class="string">  -device qemu-xhci -usb -device usb-kbd -device usb-tablet \</span></span><br><span class="line"><span class="string">  -append &#x27;root=/dev/vda1 rw console=ttyS0 swiotlb=1 loglevel=3 systemd.default_timeout_start_sec=600 selinux=0 highres=off mem=&quot;</span><span class="variable">$memory_append</span><span class="string">&quot;M earlycon&#x27; &quot;</span></span><br></pre></td></tr></table></figure><p>其中这两个参数即实现了虚拟化网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-net nic,mac=52:54:00:12:34:56 \</span><br><span class="line">-net tap,ifname=tap0,script=no,downscript=no \</span><br></pre></td></tr></table></figure><p>第一个参数 <code>-net nic</code> 用于指定上述所说的前端驱动，也就是 Guest 中的实现，这里使用的是 默认的驱动，这个驱动是 QEMU 中的一个虚拟网卡设备，指定它的 MAC 地址为 <code>52:54:00:12:34:56</code>。</p><p>第二个参数 <code>-net tap</code> 用于指定后端实现，也就是 Host 中的实现，这里使用的是 <code>tap</code> 驱动，它的网卡名称为 <code>tap0</code>，并且不执行任何脚本。这两个参数的组合就实现了虚拟化网络。</p><p>更多示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-net nic,model=virtio \</span><br><span class="line">-net tap,ifname=tap3,script=/ect/qemu/qemu-ifup,downscript=no \</span><br></pre></td></tr></table></figure><p>第一个参数 <code>-net nic</code> 用于指定上述所说的前端驱动，也就是 Guest 中的实现，这里使用的是 <code>virtio</code> 驱动，这个驱动是 QEMU 中的一个虚拟网卡设备。第二个参数 <code>-net tap</code> 用于指定后端实现，也就是 Host 中的实现，这里使用的是 <code>tap</code> 驱动，它的网卡名称为 <code>tap3</code>，并且执行脚本 <code>/ect/qemu/qemu-ifup</code>。</p><blockquote><p>解释<code>/ect/qemu/qemu-ifup</code><br>该脚本用于创建网桥，将网桥与宿主机的网卡绑定，然后将虚拟网卡绑定到网桥上，这样虚拟机就可以通过网桥与宿主机通信，宿主机也可以通过网桥与虚拟机通信。</p></blockquote><h3 id="device-amp-netdev-（Recommended）"><a href="#device-amp-netdev-（Recommended）" class="headerlink" title="-device &amp; -netdev （Recommended）"></a>-device &amp; -netdev （Recommended）</h3><p>这是新版本的 QEMU 支持的命令格式，也是 QEMU 未来的发展趋势，我们以以下命令为例，来说明 <code>-device</code> 和 <code>-netdev</code> 的使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">  -nographic -machine virt \</span><br><span class="line">  -smp <span class="string">&quot;<span class="variable">$vcpu</span>&quot;</span> -m <span class="string">&quot;<span class="variable">$memory</span>&quot;</span>G \</span><br><span class="line">  -bios <span class="string">&quot;<span class="variable">$fw</span>&quot;</span> \</span><br><span class="line">  -drive file=<span class="string">&quot;<span class="variable">$drive</span>&quot;</span>,format=qcow2,id=hd0 \</span><br><span class="line">  -object rng-random,filename=/dev/urandom,id=rng0 \</span><br><span class="line">  -device virtio-vga \</span><br><span class="line">  -device virtio-rng-device,rng=rng0 \</span><br><span class="line">  -device virtio-blk-device,drive=hd0 \</span><br><span class="line">  -device virtio-net-device,netdev=tapnet,mac=e0:be:03:88:54:e8 \</span><br><span class="line">  -netdev tap,id=tapnet,ifname=tap0,script=~/qemu-script/qemu-ifup,downscript=no \</span><br><span class="line">  -device qemu-xhci -usb -device usb-kbd -device usb-tablet</span><br></pre></td></tr></table></figure><p>其中这两个参数即实现了虚拟化网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-device virtio-net-device,netdev=tapnet,mac=e0:be:03:88:54:e8 \</span><br><span class="line">-netdev tap,id=tapnet,ifname=tap0,script=~/qemu-script/qemu-ifup,downscript=no \</span><br></pre></td></tr></table></figure><p>第一个参数 <code>-device virtio-net-device</code> 用于指定上述所说的前端驱动，也就是 Guest 中的实现，定义了名为 <code>virtio-net-device</code> 的网络设备，并将其连接到一个名为 <code>tapnet</code> 的网络设备上，指定它的 MAC 地址为 <code>e0:be:03:88:54:e8</code>。</p><p>第二个参数 <code>-netdev tap</code> 用于指定后端实现，使用<code>tap</code>方式，并且指定唯一 ID 为<code>tapnet</code>由<code>-device</code>参数中的子参数<code>netdev</code>使用。网卡名称为<code>tap0</code>并且执行脚本 <code>~/qemu-script/qemu-ifup</code>。</p><blockquote><p>-netdev 参数中 id 的使用<br>-netdev 参数中的 id 用于指定唯一的 ID，这个 ID 会被 <code>-device</code> 参数中的子参数 <code>netdev</code> 使用，这样 <code>-device</code> 参数就知道要将前端驱动连接到哪个后端实现上了。id 可以自定义任意唯一字符串如<code>-netdev tap,id=test</code>对应<code>-device virtio-net-device,netdev=test</code></p></blockquote><p>更多示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-device virtio-net-pci,netdev=tapnet,mac=e0:be:03:88:54:e8 \</span><br><span class="line">-netdev tap,id=tapnet,script=no,downscript=no \</span><br></pre></td></tr></table></figure><p>第一个参数 <code>-device virtio-net-pci</code> 定义了名为 <code>virtio-net-pci</code> 的网络设备，并将其连接到一个名为 <code>tapnet</code> 的网络设备上，指定它的 MAC 地址为 <code>e0:be:03:88:54:e8</code>。</p><p>第二个参数，仔细观察会发现，我们没有定义链接到后端网卡的名称<code>ifname</code>，这是因为以<code>tap</code>模式启动 QEMU 时会自动创建<code>tap</code>设备，具体网卡名称根据当前宿主机的网卡情况而定，默认会创建一个名为<code>tap0</code>的网卡，如果启动了两个虚拟机，那么第二个虚拟机的网卡名称就是<code>tap1</code>，以此类推。</p><h3 id="区分-tap-模式与-bridge-模式"><a href="#区分-tap-模式与-bridge-模式" class="headerlink" title="区分 tap 模式与 bridge 模式"></a>区分 tap 模式与 bridge 模式</h3><p>我们有时候会用以下的命令进行 QEMU 虚拟机桥接网络的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-device virtio-net-device,netdev=bridgenet,mac=52:54:00:12:34:57 \</span><br><span class="line">-netdev bridge,ifname=br0,id=bridgenet</span><br></pre></td></tr></table></figure><p>这也能为我们创建一个桥接网络，这是因为它和 <code>-netdev tap</code> 的工作方式是一样的，只是 <code>-netdev bridge</code> 的简化写法，<code>qemu-bridge-helper</code> 在背后替我们做了 <code>tap</code> 设备创建以及将 <code>tap</code> 设备加入桥接口的所有事情。</p><h3 id="添加多张网卡"><a href="#添加多张网卡" class="headerlink" title="添加多张网卡"></a>添加多张网卡</h3><p>如果了解上述内容，添加多张网卡就十分容易实现了，我们只需要再添加一对 <code>-device</code> 和 <code>-netdev</code> 参数即可，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">  -nographic -machine virt \</span><br><span class="line">  -smp <span class="string">&quot;<span class="variable">$vcpu</span>&quot;</span> -m <span class="string">&quot;<span class="variable">$memory</span>&quot;</span>G \</span><br><span class="line">  -bios <span class="string">&quot;<span class="variable">$fw</span>&quot;</span> \</span><br><span class="line">  -drive file=<span class="string">&quot;<span class="variable">$drive</span>&quot;</span>,format=qcow2,id=hd0 \</span><br><span class="line">  -object rng-random,filename=/dev/urandom,id=rng0 \</span><br><span class="line">  -device virtio-vga \</span><br><span class="line">  -device virtio-rng-device,rng=rng0 \</span><br><span class="line">  -device virtio-blk-device,drive=hd0 \</span><br><span class="line">  -device virtio-net-device,netdev=tapnet0,mac=e0:be:03:88:54:e8 \</span><br><span class="line">  -netdev tap,id=tapnet0,script=/etc/qemu/qemu-ifup,downscript=/etc/qemu/qemu-ifdown \</span><br><span class="line">  -device virtio-net-device,netdev=tapnet1,mac=e0:be:03:88:54:e8 \</span><br><span class="line">  -netdev tap,id=tapnet1,script=/etc/qemu/qemu-ifup,downscript=/etc/qemu/qemu-ifdown \</span><br><span class="line">  -device qemu-xhci -usb -device usb-kbd -device usb-tablet</span><br></pre></td></tr></table></figure><p>需要注意的是，我们需要为每个 <code>-device</code> 参数指定一个唯一的 ID，这个 ID 会被 <code>-netdev</code> 参数中的子参数 <code>netdev</code> 使用，这样 <code>-device</code> 参数就知道要将前端驱动连接到哪个后端实现上了。并且每个 <code>tap</code> 设备只能被一个虚拟机使用，所以每个虚拟机的 <code>tap</code> 设备名称不能相同。</p><p>登录虚拟机查看网卡信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler-riscv64 ~]<span class="comment"># ifconfig </span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.12.193.53  netmask 255.255.240.0  broadcast 10.12.207.255</span><br><span class="line">        inet6 fe80::9e6:287b:30a2:574d  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether e0:be:03:88:54:e8  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 81  bytes 9871 (9.6 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 19  bytes 1735 (1.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.12.193.101  netmask 255.255.240.0  broadcast 10.12.207.255</span><br><span class="line">        inet6 fe80::4fe0:9e1e:4681:52b7  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 80:d4:09:62:<span class="built_in">cd</span>:3c  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 76  bytes 9471 (9.2 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 15  bytes 1708 (1.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h2 id="不同网络策略工作方式"><a href="#不同网络策略工作方式" class="headerlink" title="不同网络策略工作方式"></a>不同网络策略工作方式</h2><ul><li>NAT 网络模式<ul><li>NAT 网络以路由器的 NAT 功能为原理，允许虚拟机通过共享主机的 IP 地址访问互联网，但虚拟机之间不能直接通信。通过端口转发可以实现虚拟机之间的连接。</li></ul></li><li>桥接网络模式<ul><li>桥接网络模式通过虚拟交换机连接虚拟机和主机，使得虚拟机可以通过局域网访问互联网，并允许虚拟机之间直接通信。</li></ul></li><li>内部网络模式<ul><li>内部网络模式使得虚拟机可以创建一个完全隔离的网络，虚拟机之间可以直接通信，但无法访问互联网或外部网络。</li></ul></li><li>仅主机网络模式<ul><li>仅主机网络模式允许虚拟机之间可以通信，并且与主机之间也可以通信，但无法访问互联网或外部网络。</li></ul></li></ul><table><thead><tr><th></th><th>VM &lt;&gt; VM</th><th>VM → HOST</th><th>HOST → VM</th><th>VM → Internet</th><th>Internet → VM</th></tr></thead><tbody><tr><td>网络地址转换 NAT</td><td>×</td><td>√</td><td>×</td><td>√</td><td>×</td></tr><tr><td>NAT 网络</td><td>√</td><td>√</td><td>×</td><td>√</td><td>×</td></tr><tr><td>Bridged Adapter 桥接网卡</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h2 id="TUN-TAP-网络设备"><a href="#TUN-TAP-网络设备" class="headerlink" title="TUN/TAP 网络设备"></a>TUN/TAP 网络设备</h2><p>TAP 属于 Linux 内核支持的一种虚拟化网络设备，还有 TUN 也属于这种设备，它们完全由软件模拟实现，TUN/TAP 负责在内核协议栈和用户进程之间传送协议数据单元。TUN 工作在网络层，而 TAP 工作在数据链路层，TUN 负责与应用程序交换 IP 数据包，而 TAP 与应用程序交换以太网帧。所以 TUN 经常涉及路由，而 TAP 常用于网络桥接。</p><h1 id="SSH-远程登录虚拟机"><a href="#SSH-远程登录虚拟机" class="headerlink" title="SSH 远程登录虚拟机"></a>SSH 远程登录虚拟机</h1><p>宿主机任意下目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/home/user/.ssh/id_rsa): host2vm0_id_irsa</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved <span class="keyword">in</span> host2vm0_id_irsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> host2vm0_id_irsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:OkWcw+R3x6Z2mzeYQuG033H3N9qIeym3TZKzz6YD8tQ user@ubuntu18</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|        .        |</span></span><br><span class="line"><span class="string">|       = .   .   |</span></span><br><span class="line"><span class="string">|        B .o. +  |</span></span><br><span class="line"><span class="string">|       . oo.o+   |</span></span><br><span class="line"><span class="string">|        S  ++ ..o|</span></span><br><span class="line"><span class="string">|       o ..+.E=o=|</span></span><br><span class="line"><span class="string">|      o   +..B+=+|</span></span><br><span class="line"><span class="string">|       .   oo=@o+|</span></span><br><span class="line"><span class="string">|           o=**= |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p>一直回车确定，生成公私钥，保存在<code>~/.ssh</code>目录下。</p><blockquote><p>我在宿主机上生成的公私钥名称为，分别是<code>host2vm0_id_rsa</code>,<code>host2vm0_id_rsa.pub</code>方便我记忆。如果一直回车，那么生成的公私钥名称为<code>id_rsa</code>，<code>id_rsa.pub</code>。</p></blockquote><p>将公钥复制到虚拟机 <code>VM0</code> 上，以当前虚拟机 <code>VM0</code> 的 IP：<code>10.12.193.53</code> 为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id 10.12.193.53</span><br><span class="line"><span class="comment"># 输入密码</span></span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to <span class="built_in">log</span> <span class="keyword">in</span> with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- <span class="keyword">if</span> you are prompted now it is to install the new keys</span><br><span class="line">user@10.12.193.53<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Number of key(s) added: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Now try logging into the machine, with:   &quot;ssh &#x27;</span>10.12.193.53<span class="string">&#x27;&quot;</span></span><br><span class="line"><span class="string">and check to make sure that only the key(s) you wanted were added.</span></span><br></pre></td></tr></table></figure><p>然后就可以直接免密码登录了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@10.12.193.53</span><br></pre></td></tr></table></figure><h1 id="Fixed-Problems-Ongoing"><a href="#Fixed-Problems-Ongoing" class="headerlink" title="Fixed Problems (Ongoing)"></a>Fixed Problems (Ongoing)</h1><h2 id="cannot-ioctl-tunsetiff-tap0-device-or-resource-busy-errno-16"><a href="#cannot-ioctl-tunsetiff-tap0-device-or-resource-busy-errno-16" class="headerlink" title="cannot ioctl tunsetiff tap0 device or resource busy (errno=16)"></a>cannot ioctl tunsetiff tap0 device or resource busy (errno=16)</h2><h2 id="failed-to-initialize-tap-device-Operation-not-permitted"><a href="#failed-to-initialize-tap-device-Operation-not-permitted" class="headerlink" title="failed to initialize tap device: Operation not permitted"></a>failed to initialize tap device: Operation not permitted</h2><p>同类型错误：failed to create TAP device: Operation not permitted。因为创建虚拟设备 <code>tap</code> 需要 <code>root</code> 权限，所以需要使用 <code>sudo</code> 命令。执行 QEMU 启动是需要添加 <code>sudo</code>。</p><h2 id="QEMU-虚拟机启动后网卡处于-DOWN-状态，无法获取-IP"><a href="#QEMU-虚拟机启动后网卡处于-DOWN-状态，无法获取-IP" class="headerlink" title="QEMU 虚拟机启动后网卡处于 DOWN 状态，无法获取 IP"></a>QEMU 虚拟机启动后网卡处于 DOWN 状态，无法获取 IP</h2><p>查看是否是 MAC 地址配置错误，使用下面命令检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eth0 up</span><br><span class="line">SIOCSIFFLAGS: Cannot assign requested address</span><br></pre></td></tr></table></figure><p>如果报错，参考下面章节<strong>SIOCSIFFLAGS: Cannot assign requested address</strong>解决方法进行解决。</p><h2 id="虚拟机可以-ping-通外网，宿主机无法-ping-外网"><a href="#虚拟机可以-ping-通外网，宿主机无法-ping-外网" class="headerlink" title="虚拟机可以 ping 通外网，宿主机无法 ping 外网"></a>虚拟机可以 ping 通外网，宿主机无法 ping 外网</h2><p>这种情况说明基本网络没有问题，只是 DNS 解析有问题，可以通过修改<code>/etc/resolv.conf</code>文件解决。</p><p>海宁 DNS 服务器地址：<code>10.12.2.21</code> 和 <code>10.12.2.22</code>，我的情况是只能 <code>ping 10.12.2.21</code>，可以选择自己能 <code>ping</code> 通的 DNS 服务器地址。如果无法 <code>ping</code> 通，说明问题不在这，需要自行解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改 DNS 服务器地址</span></span><br><span class="line">sudo vim /etc/resolv.conf</span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line">nameserver 10.12.2.21</span><br><span class="line">nameserver 10.12.2.22</span><br></pre></td></tr></table></figure><h2 id="网络配置错误，如何恢复配置之前的状态"><a href="#网络配置错误，如何恢复配置之前的状态" class="headerlink" title="网络配置错误，如何恢复配置之前的状态"></a>网络配置错误，如何恢复配置之前的状态</h2><p>最简单的方式 - 重启，因为所有操作都是命令行配置，都是临时配置，可以直接重启解决。</p><p>既然有这一小节，说明肯定有时候不方便直接重启，那么就需要手动恢复配置之前的状态。但是能够恢复的<strong>前提是需要记得之前的网卡 IP 地址、子网掩码、网关、广播地址等信息</strong>。这些信息在局域网里，可能只有 IP 不同，其他信息如果没记住可以查看其他同事的网卡配置即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将网桥绑定的网卡从网桥上移除</span></span><br><span class="line">sudo brctl delif br0 enp2s0</span><br><span class="line">sudo brctl delif br0 tap0</span><br><span class="line"><span class="comment"># 配置宿主机网卡信息，必须一字不差，保持和之前一模一样才能恢复</span></span><br><span class="line">sudo ip addr add 10.12.192.173/20 broadcast 10.12.207.255 dev enp2s0</span><br><span class="line"><span class="comment"># 必须设置网关</span></span><br><span class="line">sudo ip route add default via 10.12.192.1 dev enp2s0</span><br><span class="line"><span class="comment"># 重启网络管理器</span></span><br><span class="line">systemctl restart NetworkManager</span><br></pre></td></tr></table></figure><h2 id="netdev-tap-id-tapnet-script-qemu-script-qemu-ifup-network-script-qemu-script-qemu-ifup-failed-with-status-256"><a href="#netdev-tap-id-tapnet-script-qemu-script-qemu-ifup-network-script-qemu-script-qemu-ifup-failed-with-status-256" class="headerlink" title="-netdev tap,id=tapnet,script=/qemu-script/qemu-ifup,:network script /qemu-script/qemu-ifup failed with status 256"></a>-netdev tap,id=tapnet,script=/qemu-script/qemu-ifup,:network script /qemu-script/qemu-ifup failed with status 256</h2><p>可能原因 1: <code>qemu-ifup</code> 脚本没有执行权限，需要添加执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x qemu-ifup</span><br></pre></td></tr></table></figure><p>可能原因 2: <code>qemu-ifup</code> 路径不对，必须放到<code>/etc/qemu/</code>目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/qemu</span><br><span class="line">mv qemu-ifup /etc/qemu &amp;&amp; mv qemu-ifdown /etc/qemu </span><br><span class="line">sudo chmod +x qemu-ifup</span><br><span class="line">sudo chmod +x qemu-ifdown</span><br></pre></td></tr></table></figure><h2 id="SIOCSIFFLAGS-Cannot-assign-requested-address"><a href="#SIOCSIFFLAGS-Cannot-assign-requested-address" class="headerlink" title="SIOCSIFFLAGS: Cannot assign requested address"></a>SIOCSIFFLAGS: Cannot assign requested address</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eth0 up</span><br><span class="line">SIOCSIFFLAGS: Cannot assign requested address</span><br></pre></td></tr></table></figure><p>一般由于 MAC 地址配置错误导致，可以通过修改 MAC 地址为多播地址解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig enp2s0 hw ether 00:11:22:33:44:55</span><br></pre></td></tr></table></figure><p>重启网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig enp2s0 down</span><br><span class="line">sudo ifconfig enp2s0 up</span><br></pre></td></tr></table></figure><p>MAC 地址的第一个字节中的最后一位（即第 7 位）用于标识该地址是单播，多播还是广播地址。如果这个位设置为 0，则表示这是一个单播地址；如果设置为 1，则表示这是一个多播或广播地址。</p><p>使用这种方法，我们可以确定上述每个 MAC 地址是否是单播地址：</p><ul><li><code>cd:c2:05:84:c8:2c</code> - 单播地址</li><li><code>13:7b:49:fc:a6:aa</code> - 单播地址</li><li><code>8f:aa:42:29:e8:68</code> - 单播地址</li></ul><p><code>00:11:22:33:44:55</code> 是多播地址。</p><h2 id="qemu-device-drive-with-0-bus-0-unit-0-exists"><a href="#qemu-device-drive-with-0-bus-0-unit-0-exists" class="headerlink" title="qemu -device drive with 0 bus=0 unit=0 exists"></a>qemu -device drive with 0 bus=0 unit=0 exists</h2><p>这个错误通常意味着您尝试在 QEMU VM 中添加一个重复的设备。</p><p>如果您已经在 VM 中添加了驱动器，则可能会出现此问题。您可以检查是否存在两个具有相同 <code>bus</code> 和 <code>unit</code> 的设备（在此情况下，都是 0）。解决此问题的方法是删除重复设备或更改其配置以包括唯一的 <code>bus</code> 和 <code>unit</code>。</p><p>如果您没有意图添加重复的设备，在运行 QEMU 之前，您可能需要检查您的命令行，以确保正确设置了 <code>-drive</code> 选项。请注意，当使用 <code>-device</code> 添加设备时，您还应该避免使用 <code>-drive</code> 选项，因为它们可能引起冲突。</p><p>如果您需要进一步帮助，建议提供完整的 QEMU 命令和参数列表，以便更好地理解问题并提供更详细的建议。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://tomwei7.com/2021/10/09/qemu-network-config/">QEMU 网络配置 // 围城</a></li><li><a href="https://www.junmajinlong.com/img/virtual/1594802457384.png">理解 Linux 虚拟网卡设备 tun/tap 的一切 | 骏马金龙</a></li><li><a href="https://wzt.ac.cn/2021/05/28/QEMU-networking/">QEMU 网络配置一把梭 | CataLpa’s Site</a></li><li><a href="https://blog.csdn.net/u014022631/article/details/53411557">qemu 虚拟机与外部网络的通信 li_Jiejun 的博客-CSDN 博客</a></li><li><a href="https://zhou-yuxin.github.io/articles/2018/%E5%AE%89%E8%A3%85qemu-kvm%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C/index.html">安装 qemu-kvm 以及配置桥接网络</a></li><li><a href="https://blog.csdn.net/rikeyone/article/details/106767540">QEMU 中的网络虚拟化配置_程序猿 Ricky 的日常干货的博客-CSDN 博客</a></li><li><a href="https://mirror.iscas.ac.cn/openeuler-sig-riscv/openEuler-RISC-V/preview/openEuler-22.09-V1-riscv64/QEMU/">Nginx Directory</a></li><li><a href="https://www.cnblogs.com/huqingyu/archive/2005/04/03/131102.html">QEMU 网络配置 - 浙林龙哥 - 博客园</a></li><li><a href="https://zhuanlan.zhihu.com/p/432022126">【qemu】qemu 网络配置 - 知乎</a></li><li><a href="https://tomwei7.com/2021/10/09/qemu-network-config/">QEMU 网络配置 // 围城</a></li><li><a href="https://zhou-yuxin.github.io/articles/2018/%E5%AE%89%E8%A3%85qemu-kvm%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C/index.html">安装 qemu-kvm 以及配置桥接网络</a></li><li><a href="https://blog.virt.ltd/blog/archives/37/">在 qemu 中使用桥接网络 - T^3 Blog</a></li><li><a href="http://wiki.yanick.site/wiki/os/qemu/">为 QEMU 配置网桥上网 | Yanick’s Wiki</a></li><li><a href="https://www.junmajinlong.com/virtual/network/all_about_tun_tap/">理解 Linux 虚拟网卡设备 tun/tap 的一切 | 骏马金龙</a></li><li><a href="https://wzt.ac.cn/2021/05/28/QEMU-networking/">QEMU 网络配置一把梭 | CataLpa’s Site</a></li></ol><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Quick-Setup&quot;&gt;&lt;a href=&quot;#Quick-Setup&quot; class=&quot;headerlink&quot; title=&quot;Quick Setup&quot;&gt;&lt;/a&gt;Quick Setup&lt;/h1&gt;&lt;h2 id=&quot;安装工具&quot;&gt;&lt;a href=&quot;#安装工具&quot; class=&quot;</summary>
      
    
    
    
    <category term="QEMU 源码分析" scheme="http://example.com/categories/QEMU-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="QEMU" scheme="http://example.com/tags/QEMU/"/>
    
    <category term="虚拟机" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="网络配置" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>使用 Yadm 管理并同步配置文件 Dotfile</title>
    <link href="http://example.com/2023/07/30/%E4%BD%BF%E7%94%A8Yadm%E7%AE%A1%E7%90%86%E5%B9%B6%E5%90%8C%E6%AD%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Dotfile/"/>
    <id>http://example.com/2023/07/30/%E4%BD%BF%E7%94%A8Yadm%E7%AE%A1%E7%90%86%E5%B9%B6%E5%90%8C%E6%AD%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Dotfile/</id>
    <published>2023-07-30T05:39:04.000Z</published>
    <updated>2023-09-01T13:41:37.148Z</updated>
    
    <content type="html"><![CDATA[<p>Dotfiles 就是我们在使用软件的时候，软件为了存储我们个人偏好设置而建立的一个以 <code>.</code> 开头的文件。例如，vim 的配置文件就是 <code>.vimrc</code>，zsh 的配置文件就是 <code>.zshrc</code>。这些文件通常存储在用户的 home 目录中。但是，在不同的电脑上工作时，如果需要使用相同的配置，我们可以考虑使用版本控制工具来管理这些文件。或者在一台新电脑上想快速配置好环境，也可以使用版本控制工具来管理这些文件。Yadm 就可以帮助我们完成这些需求。</p><h1 id="安装-yadm"><a href="#安装-yadm" class="headerlink" title="安装 yadm"></a>安装 yadm</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 <code>yadm</code> 非常简单，只需在终端输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install yadm</span><br></pre></td></tr></table></figure><h2 id="初始化-yadm-仓库"><a href="#初始化-yadm-仓库" class="headerlink" title="初始化 yadm 仓库"></a>初始化 yadm 仓库</h2><p>创建一个新的 yadm 仓库很容易，只需在 home 目录中运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yadm init</span><br></pre></td></tr></table></figure><p>现在，yadm 已经创建了一个空白的 git 仓库。</p><h2 id="添加-dotfile-文件"><a href="#添加-dotfile-文件" class="headerlink" title="添加 dotfile 文件"></a>添加 dotfile 文件</h2><p>要将现有的 dotfile 添加到 yadm 仓库中，请使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yadm add ~/.zshrc</span><br></pre></td></tr></table></figure><p>一旦您完成了对要添加的文件的更改并将它们添加到 yadm 仓库中，您需要提交它们。可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yadm commit -m &quot;Add .zshrc file to yadm repository&quot;</span><br></pre></td></tr></table></figure><h2 id="建立远程仓库"><a href="#建立远程仓库" class="headerlink" title="建立远程仓库"></a>建立远程仓库</h2><p>使用 yadm 还可以将 dotfile 文件同步到 GitHub 等 Git 托管服务中。</p><p>登录 Github，创建一个新的仓库。例如，您可以创建一个名为 <code>dotfile</code> 的仓库。现在，您需要将本地仓库与远程仓库连接起来。要将本地仓库连接到远程仓库，请使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yadm remote add origin https://github.com/[用户名]/dotfile.git</span><br></pre></td></tr></table></figure><p>现在 yadm 已经连接到您在 Github 上创建的仓库。要将本地代码上传到远程仓库，请使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yadm push</span><br></pre></td></tr></table></figure><h1 id="使用多台电脑时如何同步配置"><a href="#使用多台电脑时如何同步配置" class="headerlink" title="使用多台电脑时如何同步配置"></a>使用多台电脑时如何同步配置</h1><p>假设需要在多个计算机之间共享 <code>dotfile</code> 文件。只需按照以下步骤即可：</p><ol><li>在另一台计算机上安装 yadm 并初始化 yadm 仓库。</li><li>将远程仓库克隆到该计算机的 yadm 仓库中：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yadm clone https://github.com/[用户名]/dotfile.git</span><br></pre></td></tr></table></figure></li><li>此时，您的 dotfile 文件应在计算机上自动更新。</li></ol><p>执行完 clone 命令后实际上就是 yadm 会把远程仓库的文件都拷贝到本地。</p><h2 id="如果本地有修改和远程有冲突怎么办"><a href="#如果本地有修改和远程有冲突怎么办" class="headerlink" title="如果本地有修改和远程有冲突怎么办"></a>如果本地有修改和远程有冲突怎么办</h2><p>如果本地有修改，远程也有修改，那么就会产生冲突。这时候需要先解决冲突，然后再提交。</p><h2 id="每台电脑的配置不一样怎么办"><a href="#每台电脑的配置不一样怎么办" class="headerlink" title="每台电脑的配置不一样怎么办"></a>每台电脑的配置不一样怎么办</h2><p>比如我们会在<code>.zshrc</code>中配置一些环境变量，但是每台电脑的环境变量可能不一样。这时候我们可以在<code>.zshrc</code>中添加一些判断，比如我们可以简单的判断一下主机名，然后根据主机名来加载不同的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$HOSTNAME</span> = <span class="string">&quot;xxx&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># xxx的配置</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$HOSTNAME</span> = <span class="string">&quot;yyy&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># yyy的配置</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>但有一些配置文件可能不支持这样的添加语句，比如<code>.gitconfig</code>，这时候我们可以使用 yadm 的 Alternate Files 功能解决。</p><p>Alternate Files 是一个用于管理同一文件不同版本的功能，有时在不同的主机、操作系统和用户需要不同的文件。Alternate Files 允许使用同一个文件名字，在文件名后添加一个带有条件的后缀，例如##os.Linux,hostname.host1，class.work，yadm 会根据当前系统的特定条件自动选择适当的版本，并创建符号链接。如果没有符合条件的版本，它将选择默认版本。</p><p>就以<code>.gitconfig</code>配置文件为例，我们通常在公司的电脑和家里的电脑配置不太一样，比如公司使用下面的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">email = 公司邮箱</span><br><span class="line">name = 公司用户名</span><br></pre></td></tr></table></figure><p>在家里使用下面的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    email = 日常使用邮箱</span><br><span class="line">    name = 日常使用用户名</span><br></pre></td></tr></table></figure><p>配置文件不支持条件语句，所以无法通过直接在同一个配置文件里完成不同环境的配置。这就用到了 Alternate Files 功能，我们可以复制两个<code>.gitconfig</code>文件后面添加一个条件后缀，比如<code>.gitconfig##class.work</code>，然后在<code>.gitconfig##class.work</code>文件中添加公司的配置，<code>.gitconfig</code>文件中添加家里的配置。这样 yadm 就会根据当前的主机名自动选择合适的配置文件。并把这三个文件都加入到 yadm 仓库中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yadm add ~/.gitconfig</span><br><span class="line">yadm add ~/.gitconfig<span class="comment">##class.work</span></span><br><span class="line">yadm add ~/.gitconfig<span class="comment">##class.home</span></span><br></pre></td></tr></table></figure><p>那么 yadm 是如何实现不同环境的切换呢？我们还需要进一步配置，有注意到我们的配置文件名中的<code>class</code>属性吗，这是 yadm 支持的条件属性之一。我们可以通过<code>yadm config</code>命令来配置当前电脑的属性。比如我们配置公司电脑的<code>class</code>属性为<code>work</code>，家里的电脑的<code>class</code>属性为<code>home</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yadm config local.class work</span><br></pre></td></tr></table></figure><p>我们执行完此命令后，yadm 会自动为<code>.gitconfig</code>文件添加一个软链接，链接到<code>.gitconfig##class.work</code>文件。这样我们就可以在公司电脑上使用公司的配置了。如果我们在家里的电脑上执行<code>yadm config local.class home</code>，那么 yadm 会自动为<code>.gitconfig</code>文件添加一个软链接，链接到<code>.gitconfig##class.home</code>文件。这样我们就可以在家里的电脑上使用家里的配置了。</p><p>yadm 支持以下这些条件：</p><table><thead><tr><th>属性</th><th>意义</th></tr></thead><tbody><tr><td>arch, a</td><td>如果值匹配架构则有效。通过运行 uname -m 计算架构。</td></tr><tr><td>class, c</td><td>如果值匹配 local.class 配置，则有效。必须使用“yadm config local.class <class>”手动设置 Class。</td></tr><tr><td>default</td><td>当没有其他备选项有效时有效。</td></tr><tr><td>distro, d</td><td>如果值与发行版匹配，则有效。通过运行 lsb_release -si或检查/etc/os-release来计算分布。</td></tr><tr><td>distro_family, f</td><td>如果值匹配发行版系列，则有效。通过检查/etc/os-release 中的 ID_LIKE 行计算发行版系列。</td></tr><tr><td>extension, e</td><td>一种特殊的“条件”，不影响选择过程。它的目的是允许备选文件以特定扩展名结尾，例如使编辑器正确突出显示内容。</td></tr><tr><td>hostname, h</td><td>如果值匹配短主机名，则有效。通过运行 uname -n，并去除任何域来计算主机名。</td></tr><tr><td>os，o</td><td>如果值与操作系统匹配，则有效。通过运行 uname -s 计算 OS。*</td></tr><tr><td>template, t</td><td>当值与支持的模板处理器匹配时有效。有关更多详细信息，请参见模板部分。</td></tr><tr><td>user, u</td><td>如果值匹配当前用户，则有效。通过运行 id -u -n 计算当前用户。</td></tr></tbody></table><p>再举个例子，上面用的 class 条件是必须通过<code>yadm config local.class &lt;class&gt;</code>手动设置的。但是有一些条件不需要手动设置 yadm 可以自动识别。比如 os 属性。我们将<code>.zshrc</code>文件复制两份份，命名为<code>.zshrc##os.Linux</code>和<code>.zshrc##os.Darwin</code>，然后在<code>.zshrc##os.Linux</code>文件中添加一些 Linux 系统的配置，<code>.zshrc##os.Darwin</code>文件中添加一些 Mac 系统的配置。并把这三个文件都加入到 <code>yadm</code> 仓库中。这样 <code>yadm</code> 就会根据当前的系统自动选择合适的配置文件。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Dotfiles 就是我们在使用软件的时候，软件为了存储我们个人偏好设置而建立的一个以 &lt;code&gt;.&lt;/code&gt; 开头的文件。例如，vim 的配置文件就是 &lt;code&gt;.vimrc&lt;/code&gt;，zsh 的配置文件就是 &lt;code&gt;.zshrc&lt;/code&gt;。这些文件通</summary>
      
    
    
    
    <category term="工欲善其事必先利其器" scheme="http://example.com/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>QEMU启动RISC-V架构OpenEuler并配置OSC环境</title>
    <link href="http://example.com/2023/07/23/QEMU%E5%90%AF%E5%8A%A8RISC-V%E6%9E%B6%E6%9E%84OpenEuler%E5%B9%B6%E9%85%8D%E7%BD%AEOSC%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2023/07/23/QEMU%E5%90%AF%E5%8A%A8RISC-V%E6%9E%B6%E6%9E%84OpenEuler%E5%B9%B6%E9%85%8D%E7%BD%AEOSC%E7%8E%AF%E5%A2%83/</id>
    <published>2023-07-23T11:28:29.000Z</published>
    <updated>2023-07-23T11:29:42.680Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于Ubuntu 18.04，QEMU 8.0.2，OpenEuler 22.09</p></blockquote><h1 id="安装QEMU"><a href="#安装QEMU" class="headerlink" title="安装QEMU"></a>安装QEMU</h1><h2 id="安装基础编译工具"><a href="#安装基础编译工具" class="headerlink" title="安装基础编译工具"></a>安装基础编译工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential autoconf automake autotools-dev pkg-config bc curl \</span><br><span class="line">                 gawk git bison flex texinfo gperf libtool patchutils mingw-w64 libmpc-dev \</span><br><span class="line">                 libmpfr-dev libgmp-dev libexpat-dev libfdt-dev zlib1g-dev libglib2.0-dev \</span><br><span class="line">                 libpixman-1-dev libncurses5-dev libncursesw5-dev meson libvirglrenderer-dev libsdl2-dev  -y</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line">sudo apt install python3.8 python3-pip  -y</span><br><span class="line">sudo apt install -f</span><br><span class="line">pip3 install meson</span><br></pre></td></tr></table></figure><h2 id="下载QEMU"><a href="#下载QEMU" class="headerlink" title="下载QEMU"></a>下载QEMU</h2><p>建立文件夹用于编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &amp;&amp; mkdir -p qemu-build</span><br></pre></td></tr></table></figure><p>建立文件夹用于安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &amp;&amp; mkdir -p /home/user/program/riscv64-qemu</span><br></pre></td></tr></table></figure><p>可登录<a href="https://www.qemu.org/download/">官网</a>将版本号换成最新版本即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu-build &amp;&amp; wget  <span class="string">&quot;https://download.qemu.org/qemu-8.0.2.tar.xz&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf qemu-8.0.2.tar.xz --strip-components=1 </span><br></pre></td></tr></table></figure><h2 id="安装QEMU-1"><a href="#安装QEMU-1" class="headerlink" title="安装QEMU"></a>安装QEMU</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu-build &amp;&amp; ./configure --target-list=riscv32-softmmu,riscv32-linux-user,riscv64-linux-user,riscv64-softmmu \</span><br><span class="line">               --enable-kvm --enable-sdl \</span><br><span class="line">               --prefix=/home/user/program/riscv64-qemu</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install -j $(nproc)</span><br></pre></td></tr></table></figure><p>配置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export QEMU_HOME=/home/user/program/riscv64-qemu&#x27;</span> &gt;&gt; ~/.bashrc &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;export PATH=$QEMU_HOME/bin:$PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="下载-OpenEuler-RISC-V-系统镜像"><a href="#下载-OpenEuler-RISC-V-系统镜像" class="headerlink" title="下载 OpenEuler RISC-V 系统镜像"></a>下载 OpenEuler RISC-V 系统镜像</h1><p>建立目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &amp;&amp; mkdir -p /home/user/openeuler</span><br></pre></td></tr></table></figure><blockquote><p>根据自己的用户名修改user</p></blockquote><p>下载<a href="https://repo.openeuler.org/openEuler-preview/RISC-V/openEuler-22.09-riscv64/QEMU/">OpenEuler 22.09版本</a>，下载目录下所有文件/home/user/openeuler。如需下载其他版本请进入其他目录选择下载即可。</p><blockquote><p>也可以根据自己的情况进入<a href="https://www.openeuler.org/zh/mirror/list/">镜像站列表</a>选择下载速度更快的镜像站下载</p></blockquote><blockquote><p>最新的23.03版本需要在<a href="https://mirror.iscas.ac.cn/openeuler-sig-riscv/openEuler-RISC-V/preview/openEuler-23.03-V1-riscv64/">中科院镜像站</a>下载</p></blockquote><p>文件说明：</p><ul><li><code>fw_payload_oe_qemuvirt.elf</code>: 利用 openSBI 将 kernel-5.10 的 image 作为 payload 所制作的 QEMU 启动所需文件</li><li><code>openEuler-22.09-qemu-xfce.qcow2.tar.zst</code>: openEuler RISC-V QEMU GUI 镜像压缩包</li><li><code>preview_start_vm_xfce.sh</code>: GUI 虚拟机启动脚本</li><li><code>openeuler-22.09-qemu.qcow2.tar.zst</code>: openEuler RISC-V QEMU headless 镜像压缩包</li><li><code>preview_start_vm.sh</code>: headless 虚拟机启动脚本</li></ul><p>解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zstd</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -I <span class="string">&#x27;zstdmt&#x27;</span> -xvf openEuler-22.09-riscv64-qemu.qcow2.tar.zst</span><br></pre></td></tr></table></figure><p>执行启动脚本 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x preview_start_vm.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash preview_start_vm.sh</span><br></pre></td></tr></table></figure><h1 id="登录系统"><a href="#登录系统" class="headerlink" title="登录系统"></a>登录系统</h1><ul><li>用户名: <code>root</code></li><li>默认密码: <code>openEuler12#$</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">openEuler 22.09</span><br><span class="line">Kernel 5.10.0 on an riscv64</span><br><span class="line"></span><br><span class="line">4penEuler-riscv6</span><br><span class="line"> login: openEuler 22.09</span><br><span class="line">Kernel 5.10.0 on an riscv64</span><br><span class="line"></span><br><span class="line">openEuler-riscv64 login: root</span><br><span class="line">Password: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Welcome to 5.10.0</span><br><span class="line"></span><br><span class="line">System information as of time:   Mon Jul  3 07:52:19 PM CST 2023</span><br><span class="line"></span><br><span class="line">System load:   0.17</span><br><span class="line">Processes:   117</span><br><span class="line">Memory used:   .6%</span><br><span class="line">Swap used:   0.0%</span><br><span class="line">Usage On:   6%</span><br><span class="line">Users online:   1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@openEuler-riscv64 ~]<span class="comment"># ls</span></span><br><span class="line">[root@openEuler-riscv64 ~]<span class="comment"># pwd</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="远程登录系统"><a href="#远程登录系统" class="headerlink" title="远程登录系统"></a>远程登录系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 12055 root@localhost</span><br></pre></td></tr></table></figure><h1 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h1><blockquote><p>以下操作均在root用户下执行，如果切换了用户会有提示。因为系统初始状态没有普通用户，也没有sudo，所以需要使用root完成一些基础配置。</p></blockquote><h2 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h2><p>原密码太复杂，修改简单密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd root</span><br><span class="line"><span class="comment"># 输入两次密码</span></span><br></pre></td></tr></table></figure><h2 id="添加普通用户"><a href="#添加普通用户" class="headerlink" title="添加普通用户"></a>添加普通用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加用户 user</span></span><br><span class="line">useradd -s /bin/bash -d /home/user -m user</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd user</span><br><span class="line"><span class="comment"># 输入两次密码</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加管理员权限</span></span><br><span class="line">usermod -aG wheel user</span><br></pre></td></tr></table></figure><h2 id="修改时间"><a href="#修改时间" class="headerlink" title="修改时间"></a>修改时间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;NTP=ntp.aliyun.com&quot;</span> &gt;&gt; /etc/systemd/timesyncd.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart systemd-timesyncd.service</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看<code>timesyncd</code>运行状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status systemd-timesyncd.service</span><br></pre></td></tr></table></figure><p><code>date</code>命令可查看当前系统时间。验证是否配置成功。</p><p><strong>时间务必正确设置</strong>，错误的时间会影响诸如https的TLS认证等过程。</p><h2 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/resolv.conf</span><br><span class="line">nameserver 119.29.29.29</span><br></pre></td></tr></table></figure><h2 id="配置软件包源"><a href="#配置软件包源" class="headerlink" title="配置软件包源"></a>配置软件包源</h2><p>配置文件为 /etc/yum.repos.d/openEuler.repo 下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/openEuler.repo  /etc/yum.repos.d/openEuler.repo.bk &amp;&amp; sudo bash -c <span class="string">&quot;cat &lt;&lt; EOF &gt; /etc/yum.repos.d/openEuler.repo</span></span><br><span class="line"><span class="string"># just for test</span></span><br><span class="line"><span class="string">[mainline]</span></span><br><span class="line"><span class="string">name=mainline</span></span><br><span class="line"><span class="string">baseurl=https://mirror.iscas.ac.cn/openeuler-sig-riscv/openEuler-RISC-V/preview/openEuler-22.09-V1-riscv64/repo/22.09/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string"># just for test</span></span><br><span class="line"><span class="string">[epol]</span></span><br><span class="line"><span class="string">name=epol</span></span><br><span class="line"><span class="string">baseurl=https://mirror.iscas.ac.cn/openeuler-sig-riscv/openEuler-RISC-V/preview/openEuler-22.09-V1-riscv64/repo/22.09/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">[extra]</span></span><br><span class="line"><span class="string">name=extra</span></span><br><span class="line"><span class="string">baseurl=https://mirror.iscas.ac.cn/openeuler-sig-riscv/openEuler-RISC-V/preview/openEuler-22.09-V1-riscv64/repo/extra/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">EOF&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，因为OpenEuler还在快速发展中，镜像地址可能会发生变化，所以需确认地址是否能够正常访问，如无法访问会导致404错误</p></blockquote><blockquote><p>[repoid]中的repoid为软件仓库（repository）的ID号，所有.repo配置文件中的各repoid不能重复，必须唯一。示例中repoid设置为base。<br>name为软件仓库描述的字符串。<br>baseurl为软件仓库的地址。<br>enabled为是否启用该软件源仓库，可选值为1和0。默认值为1，表示启用该软件源仓库。<br>gpgcheck可设置为1或0，1表示进行gpg（GNU Private Guard）校验，0表示不进行gpg校验，gpgcheck可以确定rpm包的来源是有效和安全的。<br>gpgkey为验证签名用的公钥。</p></blockquote><h2 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h2><ol><li>在宿主机上安装 <code>qemu-img</code> 工具:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install qemu-utils</span><br></pre></td></tr></table></figure><ol start="2"><li>在 openEuler RISC-V 虚拟机上安装 <code>growpart</code> 工具:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install cloud-utils-growpart</span><br></pre></td></tr></table></figure><ol start="3"><li>关闭QEMU虚拟机</li><li>把 qcow2 文件的容量加200GB：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img resize *.qcow2 +200G</span><br><span class="line">Image resized.</span><br><span class="line">$ qemu-img info *.qcow2</span><br><span class="line">image: openEuler-preview.riscv64.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 220 GiB </span><br><span class="line">disk size: 9.58 GiB</span><br><span class="line">cluster_size: 65536</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    compression <span class="built_in">type</span>: zlib</span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: 16</span><br><span class="line">    corrupt: <span class="literal">false</span></span><br><span class="line">    extended l2: <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="5"><li>QEMU 启动 openEuler RISC-V。</li></ol><p>启动以后，我们先看看分区情况：可以看到根目录对应的分区只使用了 10G。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler-RISCV-rare ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">vda    254:0    0  220G  0 disk</span><br><span class="line">└─vda1 254:1    0   10G  0 part /</span><br></pre></td></tr></table></figure><ol><li>扩展分区 <code>vda1</code>，执行 </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">growpart /dev/vda1</span><br></pre></td></tr></table></figure><p>执行 <code>lsblk</code> 可以看到 / 所在的 <code>vda1</code> 分区已经扩展到了预期大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler-RISCV-rare ~]<span class="comment"># growpart /dev/vda 1</span></span><br><span class="line">CHANGED: partition=1 start=2048 old: size=20969472 end=20971520 new: size=419428319 end=419430367</span><br><span class="line">[root@openEuler-RISCV-rare ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">vda    254:0    0  220G  0 disk</span><br><span class="line">└─vda1 254:1    0  220G  0 part /</span><br></pre></td></tr></table></figure><ol><li>扩展文件系统：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resize2fs /dev/vda1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h1><h2 id="network-backend-‘user‘-is-not-compiled-into-this-binary"><a href="#network-backend-‘user‘-is-not-compiled-into-this-binary" class="headerlink" title="network backend ‘user‘ is not compiled into this binary"></a>network backend ‘user‘ is not compiled into this binary</h2><p>git clone <a href="https://gitlab.freedesktop.org/slirp/libslirp.git">https://gitlab.freedesktop.org/slirp/libslirp.git</a></p><p><a href="http://security.ubuntu.com/ubuntu/pool/main/libs/libslirp/libslirp-dev_4.1.0-2ubuntu2.2_amd64.deb">http://security.ubuntu.com/ubuntu/pool/main/libs/libslirp/libslirp-dev_4.1.0-2ubuntu2.2_amd64.deb</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libslirp-dev</span><br></pre></td></tr></table></figure><p>重新编译QEMU：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu-build &amp;&amp; rm -rf build</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu-build &amp;&amp; ./configure --target-list=riscv32-softmmu,riscv32-linux-user,riscv64-linux-user,riscv64-softmmu \</span><br><span class="line">               --enable-kvm --enable-sdl --enable-slirp\</span><br><span class="line">               --prefix=/home/user/program/riscv64-qemu</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install -j $(nproc)</span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://github.com/openeuler-mirror/RISC-V/blob/master/doc/tutorials/vm-qemu-oErv.md">RISC-V/doc/tutorials/vm-qemu-oErv.md at master · openeuler-mirror/RISC-V · GitHub</a></p><p><a href="https://www.openeuler.org/whitepaper/openEuler-whitepaper-2209.pdf">openEuler 22.09技术白皮书</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基于Ubuntu 18.04，QEMU 8.0.2，OpenEuler 22.09&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;安装QEMU&quot;&gt;&lt;a href=&quot;#安装QEMU&quot; class=&quot;headerlink&quot; title=&quot;安装QE</summary>
      
    
    
    
    
    <category term="QEMU" scheme="http://example.com/tags/QEMU/"/>
    
    <category term="RISC-V" scheme="http://example.com/tags/RISC-V/"/>
    
    <category term="OpenEuler" scheme="http://example.com/tags/OpenEuler/"/>
    
  </entry>
  
  <entry>
    <title>SSH 登录 OpenStack 实例</title>
    <link href="http://example.com/2023/06/28/SSH-%E7%99%BB%E5%BD%95-OpenStack-%E5%AE%9E%E4%BE%8B/"/>
    <id>http://example.com/2023/06/28/SSH-%E7%99%BB%E5%BD%95-OpenStack-%E5%AE%9E%E4%BE%8B/</id>
    <published>2023-06-28T14:20:05.000Z</published>
    <updated>2023-06-28T14:21:29.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>添加安全组规则，允许 Ping 和 SSH 访问虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack security group rule create --proto icmp default</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@allone:~<span class="comment"># openstack security group rule create --proto icmp default</span></span><br><span class="line">+-------------------+---------------------------+</span><br><span class="line">| Field             | Value                                                                                                                                                   |</span><br><span class="line">+-------------------+-------------------------+</span><br><span class="line">| created_at        | 2023-06-28T06:26:10Z                                                                                                                                    |</span><br><span class="line">| description       |                                                                                                                                                         |</span><br><span class="line">| direction         | ingress                                                                                                                                                 |</span><br><span class="line">| ether_type        | IPv4                                                                                                                                                    |</span><br><span class="line">| id                | fe9adfc3-dc42-4680-8ecd-ed5a667e1215                                                                                                                    |</span><br><span class="line">| location          | cloud=<span class="string">&#x27;&#x27;</span>, project.domain_id=, project.domain_name=<span class="string">&#x27;Default&#x27;</span>, project.id=<span class="string">&#x27;6396365541a74b6b8ea8812d1af05e70&#x27;</span>, project.name=<span class="string">&#x27;admin&#x27;</span>, region_name=<span class="string">&#x27;&#x27;</span>, zone= |</span><br><span class="line">| name              | None                                                                                                                                                    |</span><br><span class="line">| port_range_max    | None                                                                                                                                                    |</span><br><span class="line">| port_range_min    | None                                                                                                                                                    |</span><br><span class="line">| project_id        | 6396365541a74b6b8ea8812d1af05e70                                                                                                                        |</span><br><span class="line">| protocol          | icmp                                                                                                                                                    |</span><br><span class="line">| remote_group_id   | None                                                                                                                                                    |</span><br><span class="line">| remote_ip_prefix  | 0.0.0.0/0                                                                                                                                               |</span><br><span class="line">| revision_number   | 0                                                                                                                                                       |</span><br><span class="line">| security_group_id | f10a3927-5e76-47b4-8691-4169348845ae                                                                                                                    |</span><br><span class="line">| tags              | []                                                                                                                                                      |</span><br><span class="line">| updated_at        | 2023-06-28T06:26:10Z                                                                                                                                    |</span><br><span class="line">+-------------------+--------------------------------+</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack security group rule create --proto tcp --dst-port 22 default</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@allone:~<span class="comment"># openstack security group rule  create --proto tcp --dst-port 22 default</span></span><br><span class="line">+-------------------+--------------------------------------+</span><br><span class="line">| Field             | Value                                                                                                                                                   |</span><br><span class="line">+-------------------+--------------------------------------------+</span><br><span class="line">| created_at        | 2023-06-28T06:26:15Z                                                                                                                                    |</span><br><span class="line">| description       |                                                                                                                                                         |</span><br><span class="line">| direction         | ingress                                                                                                                                                 |</span><br><span class="line">| ether_type        | IPv4                                                                                                                                                    |</span><br><span class="line">| id                | af699cf9-5fc0-45e2-a009-0bb7828e2d1a                                                                                                                    |</span><br><span class="line">| location          | cloud=<span class="string">&#x27;&#x27;</span>, project.domain_id=, project.domain_name=<span class="string">&#x27;Default&#x27;</span>, project.id=<span class="string">&#x27;6396365541a74b6b8ea8812d1af05e70&#x27;</span>, project.name=<span class="string">&#x27;admin&#x27;</span>, region_name=<span class="string">&#x27;&#x27;</span>, zone= |</span><br><span class="line">| name              | None                                                                                                                                                    |</span><br><span class="line">| port_range_max    | 22                                                                                                                                                      |</span><br><span class="line">| port_range_min    | 22                                                                                                                                                      |</span><br><span class="line">| project_id        | 6396365541a74b6b8ea8812d1af05e70                                                                                                                        |</span><br><span class="line">| protocol          | tcp                                                                                                                                                     |</span><br><span class="line">| remote_group_id   | None                                                                                                                                                    |</span><br><span class="line">| remote_ip_prefix  | 0.0.0.0/0                                                                                                                                               |</span><br><span class="line">| revision_number   | 0                                                                                                                                                       |</span><br><span class="line">| security_group_id | f10a3927-5e76-47b4-8691-4169348845ae                                                                                                                    |</span><br><span class="line">| tags              | []                                                                                                                                                      |</span><br><span class="line">| updated_at        | 2023-06-28T06:26:15Z                                                                                                                                    |</span><br><span class="line">+-------------------+-----------------+</span><br></pre></td></tr></table></figure><h1 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h1><h2 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -q -N “”</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>-q</code> 选项表示静默模式，即在生成密钥对的过程中不会输出任何提示信息或警告。</li><li><code>-N</code> 选项后面可以跟一个密码作为参数。该密码将用于保护生成的私钥文件。如果不指定 <code>-N</code> 参数，则私钥文件将不受密码保护。</li></ul></blockquote><p>该命令会在<code>~/.ssh/</code>目录中自动生成一对公私钥。默认私钥名称：id_rsa，默认公钥名称：id_rsa.pub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack keypair create --public-key ~/.ssh/id_rsa.pub mykey</span><br></pre></td></tr></table></figure><p>向 OpenStack 添加公钥，用于创建实例时选择：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@allone:~<span class="comment"># openstack keypair create --public-key ~/.ssh/id_rsa.pub mykey</span></span><br><span class="line">+-------------+-------------------------------------------------+</span><br><span class="line">| Field       | Value                                           |</span><br><span class="line">+-------------+-------------------------------------------------+</span><br><span class="line">| fingerprint | 11:36:75:e0:c3:98:4c:97:90:30:f5:69:e1:17:a9:4b |</span><br><span class="line">| name        | mykey                                           |</span><br><span class="line">| user_id     | 9027da91a2134825a421d78db11011d0                |</span><br><span class="line">+-------------+-------------------------------------------------+</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack keypair list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@allone:~<span class="comment"># openstack keypair list</span></span><br><span class="line">+---------------------+-------------------------------------------------+</span><br><span class="line">| Name                | Fingerprint                                     |</span><br><span class="line">+---------------------+-------------------------------------------------+</span><br><span class="line">| mykey               | 11:36:75:e0:c3:98:4c:97:90:30:f5:69:e1:17:a9:4b |</span><br><span class="line">| ubuntu cloud server | 67:b4:8a:64:83:4e:47:d0:7c:87:46:34:3b:03:e6:17 |</span><br><span class="line">+---------------------+-------------------------------------------------+</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh ubuntu@10.0.2.111</span><br></pre></td></tr></table></figure><p>其中，<code>ubuntun</code>是实例的用户名，<code>10.0.2.111</code>是实例的 IP 地址。</p><h1 id="WEB-界面方式"><a href="#WEB-界面方式" class="headerlink" title="WEB 界面方式"></a>WEB 界面方式</h1><h2 id="创建密钥对"><a href="#创建密钥对" class="headerlink" title="创建密钥对"></a>创建密钥对</h2><p>Project-Key Pairs-Create Keypairs</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/17-53-21-d58cbf697d71c5fff58fda7a8145ceae-20230628175315-733a20.png"></p><p>为密钥对起个名字：sshkey，并选择一个类型：SSH Key</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/17-53-37-56223c56c675b84ea1d375399db38175-20230628175333-06df78.png"></p><p>点击创建后会弹出下载私钥的窗口，这时候需要将私钥下载到本地。并将他移动到 ssh 目录下方便管理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换root用户，因为我们一直都是用root用户操作的OpenStack</span></span><br><span class="line">sudo su</span><br><span class="line">mv sshkey.pem ~/.ssh</span><br></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/17-53-54-d452e4565933506f89744f60f01d7956-20230628175349-ffaa20.png"></p><h2 id="使用公钥创建实例"><a href="#使用公钥创建实例" class="headerlink" title="使用公钥创建实例"></a>使用公钥创建实例</h2><p>Project-Instances-Launch Instance</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/17-54-08-24889d77a26052dab99f758c54ce9483-20230628175403-9acef3.png"></p><p>在 Key Pair 中选择刚刚创建的 sshkey。这里实际就是将创建的密钥对中的公钥放到了我们的实例中，这样我们就可以拿着本地的私钥去访问实例。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/17-54-19-5ac37e246ffbd6007356092eac047d6b-20230628175415-7f105e.png"></p><h2 id="登录实例"><a href="#登录实例" class="headerlink" title="登录实例"></a>登录实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/sshkey.pem  ubuntun@10.0.2.111</span><br></pre></td></tr></table></figure><p>其中<code>~/.ssh/sshkey.pem</code>是我们下载的私钥文件，<code>ubuntun</code>是实例的用户名，<code>10.0.2.111</code>是实例的 IP 地址。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础配置&quot;&gt;&lt;a href=&quot;#基础配置&quot; class=&quot;headerlink&quot; title=&quot;基础配置&quot;&gt;&lt;/a&gt;基础配置&lt;/h1&gt;&lt;p&gt;添加安全组规则，允许 Ping 和 SSH 访问虚拟机：&lt;/p&gt;
&lt;figure class=&quot;highlight bash</summary>
      
    
    
    
    <category term="OpenStack" scheme="http://example.com/categories/OpenStack/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="OpenStack" scheme="http://example.com/tags/OpenStack/"/>
    
  </entry>
  
</feed>
