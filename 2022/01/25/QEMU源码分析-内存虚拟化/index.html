<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>QEMU 源码分析-内存虚拟化 | 夜云泊个人博客</title>
  <meta name="description" content="1.大部分转载自QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改3.部分内容根据自己理解补充添加  概述我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里">
<meta property="og:type" content="article">
<meta property="og:title" content="QEMU 源码分析-内存虚拟化">
<meta property="og:url" content="http://example.com/2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/index.html">
<meta property="og:site_name" content="如云泊">
<meta property="og:description" content="1.大部分转载自QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改3.部分内容根据自己理解补充添加  概述我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124192700.png">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124194059.png">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225155936.png">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125110422.png">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125133808.png">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125154841.png">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127155506.png">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127160121.png">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163205.png">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163418.png">
<meta property="og:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127171031.jpg">
<meta property="article:published_time" content="2022-01-25T05:42:11.000Z">
<meta property="article:modified_time" content="2022-10-15T03:14:29.433Z">
<meta property="article:author" content="Dominic">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="QEMU">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124192700.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/index.html">
  
    <link rel="alternate" href="/atom.xml" title="如云泊" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.png" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">夜云泊</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">软件工程师</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 浙江</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Dunky-Z" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Bug-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">Bug 踩坑记录</a><span class="category-list-count">30</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP-Lab/">CSAPP-Lab</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Embedded-Development/">Embedded Development</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git-%E5%AE%9E%E6%88%98/">Git 实战</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-%E5%BC%80%E5%8F%91/">JAVA 开发</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LaTeX/">LaTeX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">Linux 操作系统</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenStack/">OpenStack</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/QEMU-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">QEMU 源码分析</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RISC-V-%E5%85%A5%E9%97%A8/">RISC-V 入门</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Self-Hosted/">Self-Hosted</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/uCore-%E5%AE%9E%E9%AA%8C/">uCore 实验</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%87%E8%83%BD-VSCode/">万能 VSCode</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/">工欲善其事必先利其器</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/">每天学命令</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/">通信协议</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACPI/" rel="tag">ACPI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AMBA/" rel="tag">AMBA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AXI/" rel="tag">AXI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Affinity/" rel="tag">Affinity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BootROM/" rel="tag">BootROM</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BootRom/" rel="tag">BootRom</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bootloader/" rel="tag">Bootloader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bug/" rel="tag">Bug</a><span class="tag-list-count">34</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CI/" rel="tag">CI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPU/" rel="tag">CPU</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cache/" rel="tag">Cache</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Clash/" rel="tag">Clash</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CodeReview/" rel="tag">CodeReview</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cryptography/" rel="tag">Cryptography</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DMA/" rel="tag">DMA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOS/" rel="tag">DOS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Debian/" rel="tag">Debian</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DevOps/" rel="tag">DevOps</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Devstack/" rel="tag">Devstack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Die2Die/" rel="tag">Die2Die</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker-Compose/" rel="tag">Docker-Compose</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Driver/" rel="tag">Driver</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ELF/" rel="tag">ELF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Efficiency/" rel="tag">Efficiency</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FSM/" rel="tag">FSM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FrameBuffer/" rel="tag">FrameBuffer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GCC/" rel="tag">GCC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GDB/" rel="tag">GDB</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GPIO/" rel="tag">GPIO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gerrit/" rel="tag">Gerrit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">25</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitbash/" rel="tag">Gitbash</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitea/" rel="tag">Gitea</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HEXO/" rel="tag">HEXO</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IIC/" rel="tag">IIC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPC/" rel="tag">IPC</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interlaken/" rel="tag">Interlaken</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JTAG/" rel="tag">JTAG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jellyfin/" rel="tag">Jellyfin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KeePass/" rel="tag">KeePass</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCD/" rel="tag">LCD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LaTeX/" rel="tag">LaTeX</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LaTex/" rel="tag">LaTex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lab/" rel="tag">Lab</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">81</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/" rel="tag">Linux,网络配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCU/" rel="tag">MCU</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MESI/" rel="tag">MESI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MMU/" rel="tag">MMU</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NAS/" rel="tag">NAS</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NOC/" rel="tag">NOC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OCR/" rel="tag">OCR</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Office/" rel="tag">Office</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenEuler/" rel="tag">OpenEuler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenOCD/" rel="tag">OpenOCD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenSBI/" rel="tag">OpenSBI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenStack/" rel="tag">OpenStack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PDF/" rel="tag">PDF</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pandoc/" rel="tag">Pandoc</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Plugins/" rel="tag">Plugins</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QEMU/" rel="tag">QEMU</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/" rel="tag">Qt</a><span class="tag-list-count">22</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QtCreator/" rel="tag">QtCreator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RISC-V/" rel="tag">RISC-V</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RISCV/" rel="tag">RISCV</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radarr/" rel="tag">Radarr</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPI/" rel="tag">SPI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH-Linux/" rel="tag">SSH,Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Self-Hosted/" rel="tag">Self-Hosted</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/" rel="tag">Shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SoC/" rel="tag">SoC</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TLB/" rel="tag">TLB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Timer/" rel="tag">Timer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Translation/" rel="tag">Translation</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unix/" rel="tag">Unix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VSCode/" rel="tag">VSCode</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Virtual-Memory/" rel="tag">Virtual Memory</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WSL2/" rel="tag">WSL2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/listing/" rel="tag">listing</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ocrmypdf/" rel="tag">ocrmypdf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pip/" rel="tag">pip</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uCore/" rel="tag">uCore</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yaml/" rel="tag">yaml</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zsh/" rel="tag">zsh</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag">云计算</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%B2%E5%92%8C%E6%80%A7/" rel="tag">亲和性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E6%A0%B8/" rel="tag">内核</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E9%A1%B5%E5%88%86%E6%AE%B5/" rel="tag">分页分段</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" rel="tag">加密算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" rel="tag">动态链接</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8C%E6%AD%A5/" rel="tag">同步</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">后端开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BA%E4%BB%B6%E5%BC%80%E5%8F%91/" rel="tag">固件开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%BA%8A/" rel="tag">图床</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%87%E4%BB%BD/" rel="tag">备份</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%96%E8%AE%BE/" rel="tag">外设</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8/" rel="tag">多级页表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/" rel="tag">多进程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E4%BD%93/" rel="tag">字体</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E5%99%A8/" rel="tag">存储器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" rel="tag">安装教程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/" rel="tag">密码管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%EF%BC%8CEfficiency%EF%BC%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" rel="tag">工具，Efficiency，内网穿透</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0/" rel="tag">思源笔记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BA%BF/" rel="tag">总线</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/" rel="tag">总线协议</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A8%E8%8D%90/" rel="tag">推荐</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%92%E6%9C%BA/" rel="tag">攒机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%88%E7%8E%87/" rel="tag">效率</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" rel="tag">有限状态机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/" rel="tag">每天学命令</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" rel="tag">汇编语言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A1%AC%E4%BB%B6/" rel="tag">硬件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">组成原理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" rel="tag">缓存一致性</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91/" rel="tag">编译</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/" rel="tag">网络配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/" rel="tag">腾讯云</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8A%AF%E7%89%87%E5%BC%80%E5%8F%91/" rel="tag">芯片开发</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" rel="tag">虚拟内存</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="tag">进程管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E6%8E%A5/" rel="tag">链接</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B5%E8%A1%A8/" rel="tag">页表</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/ACPI/" style="font-size: 13px;">ACPI</a> <a href="/tags/AMBA/" style="font-size: 13px;">AMBA</a> <a href="/tags/AXI/" style="font-size: 13px;">AXI</a> <a href="/tags/Affinity/" style="font-size: 13px;">Affinity</a> <a href="/tags/BootROM/" style="font-size: 13.07px;">BootROM</a> <a href="/tags/BootRom/" style="font-size: 13px;">BootRom</a> <a href="/tags/Bootloader/" style="font-size: 13px;">Bootloader</a> <a href="/tags/Bug/" style="font-size: 13.93px;">Bug</a> <a href="/tags/C/" style="font-size: 13.6px;">C</a> <a href="/tags/C/" style="font-size: 13.2px;">C++</a> <a href="/tags/CI/" style="font-size: 13px;">CI</a> <a href="/tags/CPU/" style="font-size: 13.07px;">CPU</a> <a href="/tags/CSAPP/" style="font-size: 13.13px;">CSAPP</a> <a href="/tags/Cache/" style="font-size: 13.2px;">Cache</a> <a href="/tags/Clash/" style="font-size: 13px;">Clash</a> <a href="/tags/CodeReview/" style="font-size: 13px;">CodeReview</a> <a href="/tags/Cryptography/" style="font-size: 13px;">Cryptography</a> <a href="/tags/DMA/" style="font-size: 13px;">DMA</a> <a href="/tags/DOS/" style="font-size: 13px;">DOS</a> <a href="/tags/Debian/" style="font-size: 13px;">Debian</a> <a href="/tags/DevOps/" style="font-size: 13px;">DevOps</a> <a href="/tags/Devstack/" style="font-size: 13px;">Devstack</a> <a href="/tags/Die2Die/" style="font-size: 13px;">Die2Die</a> <a href="/tags/Docker/" style="font-size: 13.13px;">Docker</a> <a href="/tags/Docker-Compose/" style="font-size: 13px;">Docker-Compose</a> <a href="/tags/Driver/" style="font-size: 13px;">Driver</a> <a href="/tags/ELF/" style="font-size: 13px;">ELF</a> <a href="/tags/Efficiency/" style="font-size: 13.47px;">Efficiency</a> <a href="/tags/Embedded/" style="font-size: 13.07px;">Embedded</a> <a href="/tags/FSM/" style="font-size: 13px;">FSM</a> <a href="/tags/FrameBuffer/" style="font-size: 13px;">FrameBuffer</a> <a href="/tags/GCC/" style="font-size: 13px;">GCC</a> <a href="/tags/GDB/" style="font-size: 13.2px;">GDB</a> <a href="/tags/GPIO/" style="font-size: 13px;">GPIO</a> <a href="/tags/Gerrit/" style="font-size: 13px;">Gerrit</a> <a href="/tags/Git/" style="font-size: 13.87px;">Git</a> <a href="/tags/Gitbash/" style="font-size: 13px;">Gitbash</a> <a href="/tags/Gitea/" style="font-size: 13px;">Gitea</a> <a href="/tags/Github/" style="font-size: 13px;">Github</a> <a href="/tags/HEXO/" style="font-size: 13.2px;">HEXO</a> <a href="/tags/Hexo/" style="font-size: 13px;">Hexo</a> <a href="/tags/IIC/" style="font-size: 13px;">IIC</a> <a href="/tags/IPC/" style="font-size: 13.2px;">IPC</a> <a href="/tags/Interlaken/" style="font-size: 13px;">Interlaken</a> <a href="/tags/JAVA/" style="font-size: 13px;">JAVA</a> <a href="/tags/JTAG/" style="font-size: 13px;">JTAG</a> <a href="/tags/Jellyfin/" style="font-size: 13px;">Jellyfin</a> <a href="/tags/KeePass/" style="font-size: 13px;">KeePass</a> <a href="/tags/Kernel/" style="font-size: 13px;">Kernel</a> <a href="/tags/LCD/" style="font-size: 13px;">LCD</a> <a href="/tags/LaTeX/" style="font-size: 13.13px;">LaTeX</a> <a href="/tags/LaTex/" style="font-size: 13px;">LaTex</a> <a href="/tags/Lab/" style="font-size: 13.33px;">Lab</a> <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/" style="font-size: 13px;">Linux,网络配置</a> <a href="/tags/MCU/" style="font-size: 13.07px;">MCU</a> <a href="/tags/MESI/" style="font-size: 13px;">MESI</a> <a href="/tags/MMU/" style="font-size: 13.07px;">MMU</a> <a href="/tags/Makefile/" style="font-size: 13.07px;">Makefile</a> <a href="/tags/Markdown/" style="font-size: 13.4px;">Markdown</a> <a href="/tags/NAS/" style="font-size: 13.13px;">NAS</a> <a href="/tags/NOC/" style="font-size: 13px;">NOC</a> <a href="/tags/OCR/" style="font-size: 13px;">OCR</a> <a href="/tags/OS/" style="font-size: 13.33px;">OS</a> <a href="/tags/Office/" style="font-size: 13px;">Office</a> <a href="/tags/OpenEuler/" style="font-size: 13px;">OpenEuler</a> <a href="/tags/OpenOCD/" style="font-size: 13px;">OpenOCD</a> <a href="/tags/OpenSBI/" style="font-size: 13px;">OpenSBI</a> <a href="/tags/OpenStack/" style="font-size: 13.07px;">OpenStack</a> <a href="/tags/PDF/" style="font-size: 13.07px;">PDF</a> <a href="/tags/Pandoc/" style="font-size: 13.13px;">Pandoc</a> <a href="/tags/Plugins/" style="font-size: 13px;">Plugins</a> <a href="/tags/Python/" style="font-size: 13.27px;">Python</a> <a href="/tags/QEMU/" style="font-size: 13.53px;">QEMU</a> <a href="/tags/Qt/" style="font-size: 13.8px;">Qt</a> <a href="/tags/QtCreator/" style="font-size: 13px;">QtCreator</a> <a href="/tags/RISC-V/" style="font-size: 13.47px;">RISC-V</a> <a href="/tags/RISCV/" style="font-size: 13.4px;">RISCV</a> <a href="/tags/Radarr/" style="font-size: 13px;">Radarr</a> <a href="/tags/SPI/" style="font-size: 13px;">SPI</a> <a href="/tags/SSH/" style="font-size: 13px;">SSH</a> <a href="/tags/SSH-Linux/" style="font-size: 13px;">SSH,Linux</a> <a href="/tags/Self-Hosted/" style="font-size: 13px;">Self-Hosted</a> <a href="/tags/Shell/" style="font-size: 13px;">Shell</a> <a href="/tags/SoC/" style="font-size: 13.2px;">SoC</a> <a href="/tags/TLB/" style="font-size: 13px;">TLB</a> <a href="/tags/Timer/" style="font-size: 13px;">Timer</a> <a href="/tags/Translation/" style="font-size: 13.2px;">Translation</a> <a href="/tags/Unix/" style="font-size: 13px;">Unix</a> <a href="/tags/VSCode/" style="font-size: 13.73px;">VSCode</a> <a href="/tags/Virtual-Memory/" style="font-size: 13px;">Virtual Memory</a> <a href="/tags/WSL2/" style="font-size: 13px;">WSL2</a> <a href="/tags/listing/" style="font-size: 13px;">listing</a> <a href="/tags/ocrmypdf/" style="font-size: 13px;">ocrmypdf</a> <a href="/tags/pip/" style="font-size: 13px;">pip</a> <a href="/tags/uCore/" style="font-size: 13.33px;">uCore</a> <a href="/tags/yaml/" style="font-size: 13px;">yaml</a> <a href="/tags/zsh/" style="font-size: 13px;">zsh</a> <a href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" style="font-size: 13.07px;">云计算</a> <a href="/tags/%E4%BA%B2%E5%92%8C%E6%80%A7/" style="font-size: 13px;">亲和性</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 13.07px;">内存管理</a> <a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 13px;">内核</a> <a href="/tags/%E5%88%86%E9%A1%B5%E5%88%86%E6%AE%B5/" style="font-size: 13px;">分页分段</a> <a href="/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 13px;">加密算法</a> <a href="/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" style="font-size: 13px;">动态链接</a> <a href="/tags/%E5%8D%8F%E8%AE%AE/" style="font-size: 13px;">协议</a> <a href="/tags/%E5%90%8C%E6%AD%A5/" style="font-size: 13px;">同步</a> <a href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 13px;">后端开发</a> <a href="/tags/%E5%9B%BA%E4%BB%B6%E5%BC%80%E5%8F%91/" style="font-size: 13px;">固件开发</a> <a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 13px;">图床</a> <a href="/tags/%E5%A4%87%E4%BB%BD/" style="font-size: 13px;">备份</a> <a href="/tags/%E5%A4%96%E8%AE%BE/" style="font-size: 13px;">外设</a> <a href="/tags/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8/" style="font-size: 13px;">多级页表</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 13px;">多线程</a> <a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/" style="font-size: 13px;">多进程</a> <a href="/tags/%E5%AD%97%E4%BD%93/" style="font-size: 13.07px;">字体</a> <a href="/tags/%E5%AD%98%E5%82%A8%E5%99%A8/" style="font-size: 13px;">存储器</a> <a href="/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" style="font-size: 13px;">安装教程</a> <a href="/tags/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/" style="font-size: 13px;">密码管理</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 13px;">嵌入式</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 13.27px;">工具</a> <a href="/tags/%E5%B7%A5%E5%85%B7%EF%BC%8CEfficiency%EF%BC%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 13.07px;">工具，Efficiency，内网穿透</a> <a href="/tags/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0/" style="font-size: 13px;">思源笔记</a> <a href="/tags/%E6%80%BB%E7%BA%BF/" style="font-size: 13px;">总线</a> <a href="/tags/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/" style="font-size: 13px;">总线协议</a> <a href="/tags/%E6%8E%A8%E8%8D%90/" style="font-size: 13.2px;">推荐</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 13px;">插件</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 13px;">操作系统</a> <a href="/tags/%E6%94%92%E6%9C%BA/" style="font-size: 13px;">攒机</a> <a href="/tags/%E6%95%88%E7%8E%87/" style="font-size: 13.13px;">效率</a> <a href="/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" style="font-size: 13px;">有限状态机</a> <a href="/tags/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/" style="font-size: 13.67px;">每天学命令</a> <a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 13px;">汇编语言</a> <a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 13px;">硬件</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 13px;">线程</a> <a href="/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 13px;">组成原理</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 13.07px;">缓存一致性</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 13px;">编译</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/" style="font-size: 13px;">网络配置</a> <a href="/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/" style="font-size: 13px;">腾讯云</a> <a href="/tags/%E8%8A%AF%E7%89%87%E5%BC%80%E5%8F%91/" style="font-size: 13.07px;">芯片开发</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" style="font-size: 13.07px;">虚拟内存</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 13px;">虚拟机</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 13.2px;">计算机组成原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.07px;">计算机网络</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 13px;">读书笔记</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 13px;">进程</a> <a href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" style="font-size: 13px;">进程管理</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 13.07px;">通信协议</a> <a href="/tags/%E9%93%BE%E6%8E%A5/" style="font-size: 13px;">链接</a> <a href="/tags/%E9%A1%B5%E8%A1%A8/" style="font-size: 13.07px;">页表</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">38</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/12/13/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91/" class="title">嵌入式Linux驱动开发环境搭建踩坑</a>
              </p>
              <p class="item-date">
                <time datetime="2023-12-13T14:59:23.000Z" itemprop="datePublished">2023-12-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/11/19/%E8%A7%A3%E5%86%B3Ubuntu%E6%9B%B4%E6%96%B0%E6%BA%90%E6%8A%A5%E9%94%99Clearsigned-file-isn-t-valid-got-NOSPLIT/" class="title">解决Ubuntu更新源报错Clearsigned file isnt valid, got NOSPLIT</a>
              </p>
              <p class="item-date">
                <time datetime="2023-11-19T13:18:09.000Z" itemprop="datePublished">2023-11-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Self-Hosted/">Self-Hosted</a>
              </p>
              <p class="item-title">
                <a href="/2023/11/18/%E4%BD%BF%E7%94%A8Gitea%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/" class="title">使用Gitea部署个人代码仓库</a>
              </p>
              <p class="item-date">
                <time datetime="2023-11-18T10:17:42.000Z" itemprop="datePublished">2023-11-18</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/">工欲善其事必先利其器</a>
              </p>
              <p class="item-title">
                <a href="/2023/09/19/ocrmypdf-%E8%AE%A9PDF%E5%8F%AF%E6%90%9C%E7%B4%A2/" class="title">ocrmypdf 让 PDF 可搜索</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-19T11:51:18.000Z" itemprop="datePublished">2023-09-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/uCore-%E5%AE%9E%E9%AA%8C/">uCore 实验</a>
              </p>
              <p class="item-title">
                <a href="/2023/09/08/uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC0%E7%AB%A0-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="title">uCore-实验第 0 章 - 实验环境搭建</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-08T02:46:20.000Z" itemprop="datePublished">2023-09-08</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-QEMU源码分析-内存虚拟化" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      QEMU 源码分析-内存虚拟化
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" class="article-date">
	  <time datetime="2022-01-25T05:42:11.000Z" itemprop="datePublished">2022-01-25</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/QEMU-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">QEMU 源码分析</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/Linux/" rel="tag">Linux</a>, <a class="article-tag-link-link" href="/tags/QEMU/" rel="tag">QEMU</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 9k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 39(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <blockquote>
<p>1.大部分转载自<a target="_blank" rel="noopener" href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a><br>2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改<br>3.部分内容根据自己理解补充添加</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：</p>
<ul>
<li>虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间；</li>
<li>虚拟机里面的物理内存（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存；</li>
<li>物理机的虚拟内存（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间；</li>
<li>物理机的物理内存（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。</li>
</ul>
<p>内存虚拟化的关键在于维护 <code>GPA</code> 到 <code>HVA</code> 的映射关系。</p>
<h2 id="页面分配和映射的两种方式"><a href="#页面分配和映射的两种方式" class="headerlink" title="页面分配和映射的两种方式"></a>页面分配和映射的两种方式</h2><p>要搞清楚 QEMU system emulation 的仿真架构，首先对于 Host OS，将 QEMU 作为进程启动，然后对于 QEMU 进程，会仿真各种硬件和运行 Guest OS，在这层 OS 上运行要全系统模拟的应用程序，因此对于 Guest OS 管理的内存要实现到 QEMU 进程的虚拟空间的转换需要 softMMU（即需要对 GPA 到 HVA 进行转换）。从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。</p>
<h3 id="影子页表-Shadow-Page-Table，SPT"><a href="#影子页表-Shadow-Page-Table，SPT" class="headerlink" title="影子页表 Shadow Page Table，SPT"></a>影子页表 Shadow Page Table，SPT</h3><p>第一种方式就是软件的方式，影子页表（Shadow Page Table）。</p>
<p>KVM 通过维护记录 GVA-&gt;HPA 的影子页表 SPT，减少了地址转换带来的开销，可以直接将 GVA 转换为 HPA。</p>
<p>内存映射要通过页表来管理，页表地址应该放在 CR3 寄存器里面。在软件虚拟化的内存转换中，GVA 到 GPA 的转换通过查询 CR3 寄存器来完成，CR3 中保存了 Guest 的页表基地址，然后载入 MMU 中进行地址转换。</p>
<p>在加入了 SPT 技术后，当 Guest 访问 CR3 时，KVM 会捕获到这个操作 EXIT_REASON_CR_ACCESS，之后 KVM 会载入特殊的 CR3 和影子页表，欺骗 Guest 这就是真实的 CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。</p>
<blockquote>
<p>本来的过程是，客户机要通过 cr3 找到客户机的页表，实现从 GVA 到 GPA 的转换，然后在宿主机上，要通过 cr3 找到宿主机的页表，实现从 HVA 到 HPA 的转换。<br>为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。<br>在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。</p>
</blockquote>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124192700.png"></p>
<p>为了快速检索 Guest 页表对应的影子页表，KVM 为每个客户机维护了一个 hash 表来进行客户机页表到影子页表之间的映射。对于每一个 Guest 来说，其页目录和页表都有唯一的 GPA，通过页目录/页表的 GPA 就可以在哈希链表中快速地找到对应的影子页目录/页表。</p>
<p>当 Guest 切换进程时，Guest 会把待切换进程的页表基址载入 CR3，而 KVM 将会截获这一特权指令。KVM 在哈希表中找到与此页表基址对应的影子页表基址，载入 Guest CR3，使 Guest 在恢复运行时 CR3 实际指向的是新切换进程对应的影子页表。</p>
<p>影子页表的引入，减少了 GVA-&gt;HPA 的转换开销，但是缺点在于需要为 Guest 的每个进程都维护一个影子页表，这将带来很大的内存开销。同时影子页表的建立是很耗时的，如果 Guest 的进程过多，将导致影子页表频繁切换。</p>
<p>因此 Intel 和 AMD 在此基础上提供了基于硬件的虚拟化技术 EPT。</p>
<h3 id="扩展页表-Extent-Page-Table，EPT"><a href="#扩展页表-Extent-Page-Table，EPT" class="headerlink" title="扩展页表 Extent Page Table，EPT"></a>扩展页表 Extent Page Table，EPT</h3><p>Intel 的 EPT（Extent Page Table）技术和 AMD 的 NPT（Nest Page Table）技术都对内存虚拟化提供了硬件支持。这两种技术原理类似，都是在硬件层面上实现 GVA 到 HPA 之间的转换。下面就以 EPT 为例分析一下 KVM 基于硬件辅助的内存虚拟化实现。</p>
<p>EPT 在原有客户机页表对客户机虚拟地址 GVA 到客户机物理地址 GPA 映射的基础上，又引入了 EPT 页表来实现客户机物理地址 GPA 到宿主机物理地址 HPA 的另一次映射。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。</p>
<p>即 EPT 技术采用了在两级页表结构，即原有 Guest OS 页表对 <strong>GVA-&gt;GPA</strong> 映射的基础上，又引入了 EPT 页表来实现 <strong>GPA-&gt;HPA</strong> 的另一次映射，这<strong>两次地址映射都是由硬件自动完成</strong>。</p>
<p>有了 EPT，在<strong>GPA-&gt;HPA</strong>转换的过程中，缺页会产生 EPT 缺页异常。KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。</p>
<p>KVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。</p>
<p>这里，我们重点看第二种方式。因为使用了 EPT 之后，客户机里面的页表映射，也即从 GVA 到 GPA 的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而 EPT 重点帮我们解决的就是从 GPA 到 HPA 的转换问题。因为要经过两次页表，所以 EPT 又 tdp(two dimentional paging)。</p>
<p>EPT 的页表结构也是分为四层，EPT Pointer（EPTP）指向 PML4 的首地址。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124194059.png"></p>
<h2 id="QEMU-的主要工作"><a href="#QEMU-的主要工作" class="headerlink" title="QEMU 的主要工作"></a>QEMU 的主要工作</h2><p>内存虚拟化的目的就是让虚拟机能够无缝的访问内存。有了 Intel EPT 的支持后，CPU 在 VMX non-root 状态时进行内存访问会再做一次 EPT 转换。在这个过程中，QEMU 会负责以下内容：</p>
<p>首先需要从自己的进程地址空间中申请内存用于 Guest<br>需要将上一步中申请到的内存的虚拟地址（HVA）和 Guest 的物理地址之间的映射关系传递给 KVM（kernel），即 GPA-&gt;HVA<br>需要组织一系列的数据结构来管理虚拟内存空间，并在内存拓扑结构更改时将最新的内存信息同步至 KVM 中</p>
<h2 id="QEMU-和-KVM-的工作分界"><a href="#QEMU-和-KVM-的工作分界" class="headerlink" title="QEMU 和 KVM 的工作分界"></a>QEMU 和 KVM 的工作分界</h2><p>QEMU 和 KVM 之间是通过 KVM 提供的 ioctl() 接口进行交互的。在内核的 kvm_vm_ioctl() 中，<strong>设置虚拟机内存</strong>的系统调用【kernel 就是一系列系统调用函数接口和处理逻辑，其中有个处理”创建/设置虚拟机内存“的系统调用接口】为  <code>VM_SET_USER_MEMORY_REGION</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">kvm_vm_ioctl</span><span class="hljs-params">(struct file *filp,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ioctl, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">case</span> KVM_SET_USER_MEMORY_REGION: &#123; <span class="hljs-comment">// 在 KVM 中注册用户空间传入的内存信息</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">kvm_userspace_mem</span>;</span><br><br>        r = -EFAULT;<br>         <span class="hljs-comment">// 将传入的数据结构复制到内核空间</span><br>        <span class="hljs-keyword">if</span> (copy_from_user(&amp;kvm_userspace_mem, argp, <span class="hljs-keyword">sizeof</span> kvm_userspace_mem))<br>            <span class="hljs-keyword">goto</span> out;<br><br>         <span class="hljs-comment">// 实际进行处理的函数</span><br>        r = kvm_vm_ioctl_set_memory_region(kvm, &amp;kvm_userspace_mem, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (r)<br>            <span class="hljs-keyword">goto</span> out;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里需要传递的参数类型为 <code>kvm_userspace_memory_region</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* for KVM_SET_USER_MEMORY_REGION */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;            <span class="hljs-comment">// slot 编号 [参考：https://www.cnblogs.com/LoyenWang/p/11922887.html]</span><br>    __u32 flags;           <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    __u64 guest_phys_addr; <span class="hljs-comment">// Guest 物理地址，即 GPA</span><br>    __u64 memory_size;     <span class="hljs-comment">// 内存大小，单位 bytes</span><br>    __u64 userspace_addr;  <span class="hljs-comment">// 从 QEMU 进程地址空间中分配内存的起始地址，即 HVA</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>KVM_SET_USER_MEMORY_REGION</code>这个 <code>ioctl</code> 主要目的就是设置<code>GPA-&gt;HVA</code>的映射关系，KVM 会继续调用<code>kvm_vm_ioctl_set_memory_region()</code>，在内核空间维护并管理 Guest 的内存。</p>
<h2 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h2><h3 id="AddressSpace"><a href="#AddressSpace" class="headerlink" title="AddressSpace"></a>AddressSpace</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>QEMU 用 AddressSpace 结构体表示 Guest 中 CPU/设备看到的内存【也就是Guest OS 可以在 QEMU 进程虚存中用到的所有内存，是 MemoryRegion 的集合，即 GPA 的整体】，类似于物理机中地址空间的概念，但在这里表示的是 Guest 的一段地址空间，如内存地址空间 <code>address_space_memory</code> 、<code>I/O</code> 地址空间<code>address_space_io</code>，它在 QEMU 源码<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSpace</span> &#123;</span><br>    <span class="hljs-comment">/* private: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-keyword">char</span> *name;<br>    MemoryRegion *root;<br><br>    <span class="hljs-comment">/* Accessed via RCU.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatView</span> *<span class="hljs-title">current_map</span>;</span><br><br>    <span class="hljs-keyword">int</span> ioeventfd_nb;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionIoeventfd</span> *<span class="hljs-title">ioeventfds</span>;</span><br>    QTAILQ_HEAD(, MemoryListener) listeners;<br>    QTAILQ_ENTRY(AddressSpace) address_spaces_link;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每个 AddressSpace 一般包含一系列的 MemoryRegion：<code>root</code>指针指向根级 MemoryRegion，而 root 可能有自己的若干个 sub-regions（子节点），于是形成树状结构。这些 MemoryRegion 通过树连接起来，树的根即为 AddressSpace 的 root 域。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>另外，QEMU 中有两个全局的静态 AddressSpace，在 memory.c 中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> AddressSpace address_space_memory; <span class="hljs-comment">// 内存地址空间</span><br><span class="hljs-keyword">static</span> AddressSpace address_space_io;     <span class="hljs-comment">// I/O 地址空间</span><br></code></pre></td></tr></table></figure>

<p>其 root 域分别指向之后会提到的两个 MemoryRegion 类型变量：system_memory、system_io。</p>
<h3 id="MemoryRegion"><a href="#MemoryRegion" class="headerlink" title="MemoryRegion"></a>MemoryRegion</h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>MemoryRegion</code> 表示在 <code>Guest Memory Layout</code> 中的一段内存区域【也就是单元级 GPA 的概念，Guest OS 可以管理到的那些 Guest 物理内存单元】，它是联系 <code>GPA</code> 和 <code>RAMBlocks</code>（描述真实内存）之间的桥梁，在<code>memory.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> &#123;</span><br>    <span class="hljs-comment">/* All fields are private - violators will be prosecuted */</span><br>    <span class="hljs-keyword">const</span> MemoryRegionOps *ops;      <span class="hljs-comment">// 回调函数集合</span><br>    <span class="hljs-keyword">void</span> *opaque;<br>    MemoryRegion *parent;            <span class="hljs-comment">// 父 MemoryRegion 指针</span><br>    Int128 size;                     <span class="hljs-comment">// 该区域内存的大小</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> addr;         <span class="hljs-comment">// 在 Address Space 中的地址，即 HVA</span><br>    <span class="hljs-keyword">void</span> (*destructor)(MemoryRegion *mr);<br>    <span class="hljs-keyword">ram_addr_t</span> ram_addr;             <span class="hljs-comment">// MemoryRegion 的起始地址，即 GPA</span><br>    <span class="hljs-keyword">bool</span> subpage;<br>    <span class="hljs-keyword">bool</span> terminates;<br>    <span class="hljs-keyword">bool</span> readable;<br>    <span class="hljs-keyword">bool</span> ram;                        <span class="hljs-comment">// 是否表示 RAM</span><br>    <span class="hljs-keyword">bool</span> readonly; <span class="hljs-comment">/* For RAM regions */</span><br>    <span class="hljs-keyword">bool</span> enabled;                    <span class="hljs-comment">// 是否已经通知 KVM 使用这段内存</span><br>    <span class="hljs-keyword">bool</span> rom_device;<br>    <span class="hljs-keyword">bool</span> warning_printed; <span class="hljs-comment">/* For reservations */</span><br>    MemoryRegion *alias;             <span class="hljs-comment">// 是否为 MemoryRegion alias</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> alias_offset; <span class="hljs-comment">// 若为 alias，在原 MemoryRegion 中的 offset</span><br>    <span class="hljs-keyword">unsigned</span> priority;<br>    <span class="hljs-keyword">bool</span> may_overlap;<br>    QTAILQ_HEAD(subregions, MemoryRegion) subregions; <span class="hljs-comment">// 子区域链表头</span><br>    QTAILQ_ENTRY(MemoryRegion) subregions_link;       <span class="hljs-comment">// 子区域链表节点</span><br>    QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;       <span class="hljs-comment">// MemoryRegion 的名字，调试时使用</span><br>    <span class="hljs-keyword">uint8_t</span> dirty_log_mask; <span class="hljs-comment">// 表示哪一种 dirty map 被使用，共分三种</span><br>    <span class="hljs-keyword">unsigned</span> ioeventfd_nb;<br>    MemoryRegionIoeventfd *ioeventfds;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><p>在 QEMU 的 exec.c 中也定义了两个静态的 MemoryRegion 指针变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> MemoryRegion *system_memory; <span class="hljs-comment">// 内存 MemoryRegion，对应 address_space_memory</span><br><span class="hljs-keyword">static</span> MemoryRegion *system_io;     <span class="hljs-comment">// I/O MemoryRegion，对应 address_space_io</span><br></code></pre></td></tr></table></figure>

<p>与两个全局 AddressSpace 对应，即 AddressSpace 的 root 域指向这两个 MemoryRegion。</p>
<h4 id="MemoryRegion-的类型"><a href="#MemoryRegion-的类型" class="headerlink" title="MemoryRegion 的类型"></a>MemoryRegion 的类型</h4><p>MemoryRegion 有多种类型，可以表示一段 RAM、ROM、MMIO、alias(别名)。</p>
<p>若为 alias 则表示一个 MemoryRegion 的部分区域，例如，QEMU 会为 pc.ram 这个表示 RAM 的 MemoryRegion 添加两个 alias：ram-below-4g 和 ram-above-4g，之后会看到具体的代码实例。</p>
<p>另外，MemoryRegion 也可以表示一个 container，这就表示它只是其他若干个 MemoryRegion 的容器。</p>
<p>那么要如何创建不同类型的 <code>MemoryRegion</code> 呢？</p>
<p>在 QEMU 中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将 MemoryRegion 划分为以下三种类型：</p>
<ul>
<li>根级 MemoryRegion：直接通过 memory_region_init 初始化，没有自己的内存，用于管理 subregion，例如 system_memory：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    mr-&gt;ops = <span class="hljs-literal">NULL</span>;<br>    mr-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    mr-&gt;size = int128_make64(size);<br>    <span class="hljs-keyword">if</span> (size == UINT64_MAX) &#123;<br>        mr-&gt;size = int128_2_64();<br>    &#125;<br>    mr-&gt;addr = <span class="hljs-number">0</span>;<br>    mr-&gt;subpage = <span class="hljs-literal">false</span>;<br>    mr-&gt;enabled = <span class="hljs-literal">true</span>;<br>    mr-&gt;terminates = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 非实体 MemoryRegion，搜索时会继续前往其 subregions</span><br>    mr-&gt;ram = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 根级 MemoryRegion 不分配内存</span><br>    mr-&gt;readable = <span class="hljs-literal">true</span>;<br>    mr-&gt;readonly = <span class="hljs-literal">false</span>;<br>    mr-&gt;rom_device = <span class="hljs-literal">false</span>;<br>    mr-&gt;destructor = memory_region_destructor_none;<br>    mr-&gt;priority = <span class="hljs-number">0</span>;<br>    mr-&gt;may_overlap = <span class="hljs-literal">false</span>;<br>    mr-&gt;alias = <span class="hljs-literal">NULL</span>;<br>    QTAILQ_INIT(&amp;mr-&gt;subregions);<br>    <span class="hljs-built_in">memset</span>(&amp;mr-&gt;subregions_link, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> mr-&gt;subregions_link);<br>    QTAILQ_INIT(&amp;mr-&gt;coalesced);<br>    mr-&gt;name = g_strdup(name);<br>    mr-&gt;dirty_log_mask = <span class="hljs-number">0</span>;<br>    mr-&gt;ioeventfd_nb = <span class="hljs-number">0</span>;<br>    mr-&gt;ioeventfds = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到 mr-&gt;addr 被设置为 0，而 mr-&gt;ram_addr 则并没有初始化。</p>
<ul>
<li>实体 <code>MemoryRegion</code>：通过<code>memory_region_init_ram()</code>初始化，有自己的内存（从 QEMU 进程地址空间中分配），大小为<code>size</code>，例如<code>ram_memory</code>、 <code>pci_memory</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram, *option_rom_mr;<br>    <span class="hljs-comment">/* ...*/</span><br><br>    <span class="hljs-comment">/* Allocate RAM.  We allocate it as a single memory region and use</span><br><span class="hljs-comment">     * aliases to address portions of it, mostly for backwards compatibility</span><br><span class="hljs-comment">     * with older qemus that used qemu_ram_alloc().</span><br><span class="hljs-comment">     */</span><br>    ram = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram));<br>    <span class="hljs-comment">// 调用 memory_region_init_ram 对 ram_memory 进行初始化</span><br>    memory_region_init_ram(ram, <span class="hljs-string">&quot;pc.ram&quot;</span>, below_4g_mem_size + above_4g_mem_size);<br>    vmstate_register_ram_global(ram);<br>    *ram_memory = ram;<br><br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size);<br>    mr-&gt;ram = <span class="hljs-literal">true</span>;<br>    mr-&gt;terminates = <span class="hljs-literal">true</span>;<br>    mr-&gt;destructor = memory_region_destructor_ram;<br>    mr-&gt;ram_addr = qemu_ram_alloc(size, mr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里是先调用了<code>memory_region_init()</code>，之后设置 <code>RAM</code> 属性，并继续调用<code>qemu_ram_alloc()</code>分配内存。</p>
<ul>
<li>别名 <code>MemoryRegion</code>：通过<code>memory_region_init_alias()</code> 初始化，没有自己的内存，表示实体 <code>MemoryRegion</code> 的一部分。通过 <code>alias</code> 成员指向实体 <code>MemoryRegion</code>，<code>alias_offset</code>为在实体 <code>MemoryRegion</code> 中的偏移量，例如<code>ram_below_4g</code>、<code>ram_above_4g</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram_below_4g, *ram_above_4g;<br>    <span class="hljs-comment">/* ... */</span><br>    ram_below_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_below_4g));<br>    <span class="hljs-comment">// 调用 memory_region_init_alias 对 ram_below_4g 进行初始化</span><br>    memory_region_init_alias(ram_below_4g, <span class="hljs-string">&quot;ram-below-4g&quot;</span>, ram, <span class="hljs-number">0</span>, below_4g_mem_size);<br>    <span class="hljs-comment">/* ..</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_alias</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                              MemoryRegion *orig,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">target_phys_addr_t</span> offset,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size);<br>    mr-&gt;alias = orig; <span class="hljs-comment">// 指向实体 MemoryRegion</span><br>    mr-&gt;alias_offset = offset; <span class="hljs-comment">//通过 offset 得到实体的某一个部分</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="RAMBlock"><a href="#RAMBlock" class="headerlink" title="RAMBlock"></a>RAMBlock</h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>MemoryRegion</code> 用来描述一段逻辑层面上的内存区域，而记录实际分配的内存地址信息的结构体则是 <code>RAMBlock</code>，在<code>ramblock.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RAMBlock</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> *<span class="hljs-title">mr</span>;</span><br>    <span class="hljs-keyword">uint8_t</span> *host;<br>    <span class="hljs-keyword">uint8_t</span> *colo_cache; <span class="hljs-comment">/* For colo, VM&#x27;s ram cache */</span><br>    <span class="hljs-keyword">ram_addr_t</span> offset;<br>    <span class="hljs-keyword">ram_addr_t</span> used_length;<br>    <span class="hljs-keyword">ram_addr_t</span> max_length;<br>    <span class="hljs-keyword">void</span> (*resized)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">uint64_t</span> length, <span class="hljs-keyword">void</span> *host);<br>    <span class="hljs-keyword">uint32_t</span> flags;<br>    <span class="hljs-comment">/* Protected by iothread lock.  */</span><br>    <span class="hljs-keyword">char</span> idstr[<span class="hljs-number">256</span>];<br>    <span class="hljs-comment">/* RCU-enabled, writes protected by the ramlist lock */</span><br>    QLIST_ENTRY(RAMBlock) next;<br>    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;<br>    <span class="hljs-keyword">int</span> fd;<br>    <span class="hljs-keyword">size_t</span> page_size;<br>    <span class="hljs-comment">/* dirty bitmap used during migration */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *bmap;<br>    <span class="hljs-comment">/* bitmap of already received pages in postcopy */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *receivedmap;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * bitmap to track already cleared dirty bitmap.  When the bit is</span><br><span class="hljs-comment">     * set, it means the corresponding memory chunk needs a log-clear.</span><br><span class="hljs-comment">     * Set this up to non-NULL to enable the capability to postpone</span><br><span class="hljs-comment">     * and split clearing of dirty bitmap on the remote node (e.g.,</span><br><span class="hljs-comment">     * KVM).  The bitmap will be set only when doing global sync.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> this bitmap is different comparing to the other bitmaps</span><br><span class="hljs-comment">     * in that one bit can represent multiple guest pages (which is</span><br><span class="hljs-comment">     * decided by the `clear_bmap_shift&#x27; variable below).  On</span><br><span class="hljs-comment">     * destination side, this should always be NULL, and the variable</span><br><span class="hljs-comment">     * `clear_bmap_shift&#x27; is meaningless.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *clear_bmap;<br>    <span class="hljs-keyword">uint8_t</span> clear_bmap_shift;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * RAM block length that corresponds to the used_length on the migration</span><br><span class="hljs-comment">     * source (after RAM block sizes were synchronized). Especially, after</span><br><span class="hljs-comment">     * starting to run the guest, used_length and postcopy_length can differ.</span><br><span class="hljs-comment">     * Used to register/unregister uffd handlers and as the size of the received</span><br><span class="hljs-comment">     * bitmap. Receiving any page beyond this length will bail out, as it</span><br><span class="hljs-comment">     * could not have been valid on the source.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">ram_addr_t</span> postcopy_length;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>可以看到在 <code>RAMBlock</code> 中 host 和 offset 域分别对应了 <code>HVA</code> 和<code>GPA</code>，因此也可以说 <code>RAMBlock</code> 中存储了<code>GPA-&gt;HVA</code>的映射关系，另外每一个 <code>RAMBlock</code> 都会指向其所属的 <code>MemoryRegion</code>。</p>
<h4 id="全局变量-ram-list"><a href="#全局变量-ram-list" class="headerlink" title="全局变量 ram_list"></a>全局变量 ram_list</h4><p>QEMU 在<code>ramlist.h</code>中定义了一个全局变量<code>ram_list</code>，以链表的形式维护了所有的 <code>RAMBlock</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RAMList</span> &#123;</span><br>    QemuMutex mutex;<br>    RAMBlock *mru_block;<br>    <span class="hljs-comment">/* RCU-enabled, writes protected by the ramlist lock. */</span><br>    QLIST_HEAD(, RAMBlock) blocks;<br>    DirtyMemoryBlocks *dirty_memory[DIRTY_MEMORY_NUM];<br>    <span class="hljs-keyword">uint32_t</span> version;<br>    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;<br>&#125; RAMList;<br><span class="hljs-keyword">extern</span> RAMList ram_list;<br></code></pre></td></tr></table></figure>

<p>每一个新分配的 <code>RAMBlock</code> 都会被插入到<code>ram_list</code>的头部。如需查找地址所对应的 <code>RAMBlock</code>，则需要遍历<code>ram_list</code>，当目标地址落在当前<code>RAMBlock</code>的地址区间时，该 <code>RAMBlock</code> 即为查找目标。</p>
<h4 id="AS、MR、RAMBlock-之间的关系"><a href="#AS、MR、RAMBlock-之间的关系" class="headerlink" title="AS、MR、RAMBlock 之间的关系"></a>AS、MR、RAMBlock 之间的关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225155936.png"></p>
<h3 id="FlatView"><a href="#FlatView" class="headerlink" title="FlatView"></a>FlatView</h3><p>AddressSpace 的 root 域及其子树共同构成了 Guest 的物理地址空间，但这些都是在 QEMU 侧定义的。要传入 KVM 进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其<strong>转换为一个“平坦”的地址模</strong>型，也就是一个从零开始、只包含地址信息的数据结构，这在 QEMU 中通过 <strong>FlatView</strong> 来表示。每个 AddressSpace 都有一个与之对应的 FlatView 指针 current_map，表示其对应的平面展开视图。</p>
<h4 id="结构体定义-3"><a href="#结构体定义-3" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>FlatView</code> 在<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* Flattened global view of current active memory hierarchy.  Kept in sorted</span><br><span class="hljs-comment"> * order.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatView</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-keyword">unsigned</span> ref;<br>    FlatRange *ranges;      <span class="hljs-comment">// 对应的 FlatRange 数组</span><br>    <span class="hljs-keyword">unsigned</span> nr;            <span class="hljs-comment">// FlatRange 的数目</span><br>    <span class="hljs-keyword">unsigned</span> nr_allocated;  <span class="hljs-comment">// 当前数组的项数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSpaceDispatch</span> *<span class="hljs-title">dispatch</span>;</span><br>    MemoryRegion *root;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其中，<code>ranges</code>是一个数组，记录了 <code>FlatView</code> 下所有的 <code>FlatRange</code>。</p>
<h4 id="FlatRange"><a href="#FlatRange" class="headerlink" title="FlatRange"></a>FlatRange</h4><p>在 <code>FlatView</code> 中，<code>FlatRange</code> 表示在 <code>FlatView</code> 中的一段内存范围，同样在<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Range of memory in the global map.  Addresses are absolute. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatRange</span> &#123;</span><br>    MemoryRegion *mr;           <span class="hljs-comment">// 指向所属的 MemoryRegion</span><br>    hwaddr offset_in_region;    <span class="hljs-comment">// 在全局 MemoryRegion 中的 offset，对应 GPA</span><br>    AddrRange addr;             <span class="hljs-comment">// 代表的地址区间，对应 HVA</span><br>    <span class="hljs-keyword">uint8_t</span> dirty_log_mask;<br>    <span class="hljs-keyword">bool</span> romd_mode;<br>    <span class="hljs-keyword">bool</span> readonly;<br>    <span class="hljs-keyword">bool</span> nonvolatile;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每个 <code>FlatRange</code> 对应一段虚拟机物理地址区间，各个 <code>FlatRange</code> 不会重叠，<strong>按照地址的顺序保存在数组中</strong>，具体的地址范围由一个 <code>AddrRange</code> 结构来描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * AddrRange 用于表示 FlatRange 的起始地址及大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddrRange</span> &#123;</span><br>    Int128 start;<br>    Int128 size;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="MemoryRegionSection"><a href="#MemoryRegionSection" class="headerlink" title="MemoryRegionSection"></a>MemoryRegionSection</h3><h4 id="结构体定义-4"><a href="#结构体定义-4" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>在 <code>QEMU</code> 中，还有几个起到中介作用的结构体，<code>MemoryRegionSection</code> 就是其中之一。</p>
<p>之前介绍的 <code>FlatRange</code> 代表一个物理地址空间的片段，偏向于描述在 <code>Host</code> 侧即 <strong>AddressSpace 中的分布【Guest 的物理空间】</strong>，而 <code>MemoryRegionSection</code> 则代表在 <code>Guest</code> 侧即 <strong>MemoryRegion 中的片段</strong>。<code>MemoryRegionSection</code> 在<code>memory.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MemoryRegionSection: describes a fragment of a #MemoryRegion</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @mr: the region, or %NULL if empty</span><br><span class="hljs-comment"> * @address_space: the address space the region is mapped in</span><br><span class="hljs-comment"> * @offset_within_region: the beginning of the section, relative to @mr&#x27;s start</span><br><span class="hljs-comment"> * @size: the size of the section; will not exceed @mr&#x27;s boundaries</span><br><span class="hljs-comment"> * @offset_within_address_space: the address of the first byte of the section</span><br><span class="hljs-comment"> *     relative to the region&#x27;s address space</span><br><span class="hljs-comment"> * @readonly: writes to this section are ignored</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//只是起到描述的作用，描述了是哪个 AddressSpace 的 MemoryRegion，</span><br> <span class="hljs-comment">//并且在 MemoryRegion 中的 offset，和在 AddressSpace 展开为平坦内存的 offset</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionSection</span> &#123;</span>  <br>    MemoryRegion *mr;                               <span class="hljs-comment">// 所属的 MemoryRegion</span><br>    MemoryRegion *address_space;                    <span class="hljs-comment">// 关联的 AddressSpace</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> offset_within_region;        <span class="hljs-comment">// 在 MemoryRegion 内部的 offset</span><br>    <span class="hljs-keyword">uint64_t</span> size;                                  <span class="hljs-comment">// Section 的大小</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> offset_within_address_space; <span class="hljs-comment">// 在 AddressSpace 内部的 offset</span><br>    <span class="hljs-keyword">bool</span> readonly;                                  <span class="hljs-comment">// 是否为只读</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>offset_within_region</code>：在所属 <code>MemoryRegion</code> 中的<code>offset</code>。一个<code>AddressSpace</code> 可能由多个 <code>MemoryRegion</code> 组成，因此该 <code>offset</code> 是局部的</li>
<li><code>offset_within_address_space</code>：在所属 <code>AddressSpace</code> 中的 <code>offset</code>，它是全局的</li>
</ul>
<h4 id="和其他数据结构之间的关系"><a href="#和其他数据结构之间的关系" class="headerlink" title="和其他数据结构之间的关系"></a>和其他数据结构之间的关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125110422.png"></p>
<ul>
<li><code>AddressSpace</code> 的<code>root</code>指向对应的根级<code>MemoryRegion</code>，<code>current_map</code>指向<code>AddressSpace</code> 的<code>root</code>通过<code>generate_memory_topology()</code>生成的 <code>FlatView</code></li>
<li><code>FlatView</code> 中的<code>ranges</code>数组表示该<code>MemoryRegion</code> 所表示的<code>Guest</code>地址区间【GPA 的整个平坦物理空间】，并按照地址的顺序进行排列</li>
<li><code>MemoryRegionSection</code> 由<code>ranges</code>数组中的 <code>FlatRange</code> 对应生成，作为注册到 <code>KVM</code>中的基本单位</li>
</ul>
<hr>
<p><code>QEMU</code> 在用户空间申请内存后，需要将内存信息通过一系列系统调用传入内核空间的 <code>KVM</code>，由 <code>KVM</code> 侧进行管理，因此 <code>QEMU</code> 侧也定义了一些用于向 <code>KVM</code> 传递参数的结构体。</p>
<p>以下为<code>KVM</code>相关的数据结构。</p>
<h3 id="KVMSlot"><a href="#KVMSlot" class="headerlink" title="KVMSlot"></a>KVMSlot</h3><p><code>在 kvm_init.h</code>中定义，是 <code>KVM</code> 中内存管理的基本单位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KVMSlot</span></span><br><span class="hljs-class">&#123;</span><br>    hwaddr start_addr; <span class="hljs-comment">// Guest 物理地址，GPA</span><br>    <span class="hljs-keyword">ram_addr_t</span> memory_size;        <span class="hljs-comment">// 内存大小</span><br>    <span class="hljs-keyword">void</span> *ram; <span class="hljs-comment">// QEMU 用户空间地址，HVA</span><br>    <span class="hljs-keyword">int</span> slot;  <span class="hljs-comment">// Slot 编号</span><br>    <span class="hljs-keyword">int</span> flags; <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    <span class="hljs-comment">/* Dirty bitmap cache for the slot */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *dirty_bmap;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> dirty_bmap_size;<br>    <span class="hljs-comment">/* Cache of the address space ID */</span><br>    <span class="hljs-keyword">int</span> as_id;<br>    <span class="hljs-comment">/* Cache of the offset in ram address space */</span><br>    <span class="hljs-keyword">ram_addr_t</span> ram_start_offset;<br>&#125; KVMSlot;<br></code></pre></td></tr></table></figure>

<p><code>KVMSlot</code> 类似于内存插槽的概念。</p>
<h3 id="kvm-userspace-memory-region"><a href="#kvm-userspace-memory-region" class="headerlink" title="kvm_userspace_memory_region"></a>kvm_userspace_memory_region</h3><p>调用<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>时需要向 <code>KVM</code> 传递的参数，在<code>kvm.h</code>中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* for KVM_SET_USER_MEMORY_REGION */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;            <span class="hljs-comment">// slot 编号</span><br>    __u32 flags;           <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    __u64 guest_phys_addr; <span class="hljs-comment">// Guest 物理地址，GPA</span><br>    __u64 memory_size;     <span class="hljs-comment">// 内存大小，bytes</span><br>    __u64 userspace_addr;  <span class="hljs-comment">// 从 QEMU 进程空间分配的起始地址，HVA</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="MemoryListener"><a href="#MemoryListener" class="headerlink" title="MemoryListener"></a>MemoryListener</h3><h4 id="结构体定义-5"><a href="#结构体定义-5" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>为了监控虚拟机的物理地址访问，对于每一个 <code>AddressSpace</code>，都会有一个 <code>MemoryListener</code> 与之对应。每当物理映射<code>GPA-&gt;HVA</code>发生改变时，就会回调这些函数。<strong>MemoryListener</strong> 是对一些事件的<strong>回调函数合集</strong>，在<code>memory.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MemoryListener: callbacks structure for updates to the physical memory map</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Allows a component to adjust to changes in the guest-visible memory map.</span><br><span class="hljs-comment"> * Use with memory_listener_register() and memory_listener_unregister().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryListener</span> &#123;</span><br>    <span class="hljs-keyword">void</span> (*begin)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*commit)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*region_add)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*region_del)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*region_nop)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_start)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_stop)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_sync)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_global_start)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*log_global_stop)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*eventfd_add)(MemoryListener *listener, MemoryRegionSection *section,<br>                        <span class="hljs-keyword">bool</span> match_data, <span class="hljs-keyword">uint64_t</span> data, EventNotifier *e);<br>    <span class="hljs-keyword">void</span> (*eventfd_del)(MemoryListener *listener, MemoryRegionSection *section,<br>                        <span class="hljs-keyword">bool</span> match_data, <span class="hljs-keyword">uint64_t</span> data, EventNotifier *e);<br>    <span class="hljs-comment">/* Lower = earlier (during add), later (during del) */</span><br>    <span class="hljs-keyword">unsigned</span> priority;<br>    MemoryRegion *address_space_filter;<br>    QTAILQ_ENTRY(MemoryListener) link;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="全局变量-memory-listeners"><a href="#全局变量-memory-listeners" class="headerlink" title="全局变量 memory_listeners"></a>全局变量 memory_listeners</h4><p>所有的 <code>MemoryListener</code> 都会挂在全局变量<code>memory_listeners</code>链表上，在<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">QTAILQ_HEAD</span><span class="hljs-params">(, MemoryListener)</span> memory_listeners</span><br><span class="hljs-function">    </span>= QTAILQ_HEAD_INITIALIZER(memory_listeners);<br></code></pre></td></tr></table></figure>

<p>在<code>memory.c</code>中枚举了<code>ListenerDirection</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ListenerDirection</span> &#123;</span> Forward, Reverse &#125;;<br></code></pre></td></tr></table></figure>

<h3 id="重要数据结构总览"><a href="#重要数据结构总览" class="headerlink" title="重要数据结构总览"></a>重要数据结构总览</h3><table>
<thead>
<tr>
<th align="center">结构体名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AddressSpace</td>
<td align="left">VM 能看到的一段地址空间，偏向 Host 侧【注意指的是偏向】</td>
</tr>
<tr>
<td align="center">MemoryRegion</td>
<td align="left">地址空间中一段逻辑层面的内存区域，偏向 Guest 侧</td>
</tr>
<tr>
<td align="center">RAMBlock</td>
<td align="left">记录实际分配的内存地址信息，存储了 GPA-&gt;HVA 的映射关系</td>
</tr>
<tr>
<td align="center">FlatView</td>
<td align="left">MemoryRegion 对应的平面展开视图，包含一个 FlatRange 类型的 ranges 数组</td>
</tr>
<tr>
<td align="center">FlatRange</td>
<td align="left">对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中</td>
</tr>
<tr>
<td align="center">MemoryRegionSection</td>
<td align="left">表示 MemoryRegion 中的片段</td>
</tr>
<tr>
<td align="center">MemoryListener</td>
<td align="left">回调函数集合</td>
</tr>
<tr>
<td align="center">KVMSlot</td>
<td align="left">KVM 中内存管理的基本单位，表示一个内存插槽</td>
</tr>
<tr>
<td align="center">kvm_userspace_memory_region</td>
<td align="left">调用 ioctl(KVM_SET_USER_MEMORY_REGION) 时需要向 KVM 传递的参数</td>
</tr>
</tbody></table>
<h2 id="具体实现机制"><a href="#具体实现机制" class="headerlink" title="具体实现机制"></a>具体实现机制</h2><p>QEMU 的内存申请流程大致可分为三个部分：回调函数的注册、AddressSpace 的初始化、实际内存的分配。下面将根据在 vl.c 的 main() 函数中的调用顺序分别介绍。</p>
<h3 id="回调函数的注册"><a href="#回调函数的注册" class="headerlink" title="回调函数的注册"></a>回调函数的注册</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125133808.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">configure_accelerator</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       └─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">()</span>                                     <span class="hljs-comment">// 初始化 KVM</span></span><br><span class="hljs-function">            ├─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_ioctl</span><span class="hljs-params">(KVM_CREATE_VM)</span>                  <span class="hljs-comment">// 创建 VM</span></span><br><span class="hljs-function">            ├─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_arch_init</span><span class="hljs-params">()</span>                           <span class="hljs-comment">// 针对不同的架构进行初始化</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">()</span>               <span class="hljs-comment">// 注册 kvm_memory_listener</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">()</span> <span class="hljs-comment">// 调用 region_add 回调</span></span><br><span class="hljs-function">                      └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span>        <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">                           └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">                                └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                     └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br></code></pre></td></tr></table></figure>

<p>进入<code>configure_accelerator()</code>后，<code>QEMU</code>会先调用<code>configure_accelerator()</code>设置 <code>KVM</code> 的加速支持，之后进入<code>kvm_init()</code>。该函数主要完成对 KVM 的初始化，包括一些常规检查如 <code>CPU</code> 个数、<code>KVM</code> 版本等，之后通过<code>kvm_ioctl(KVM_CREATE_VM)</code>与内核交互，创建 <code>KVM</code> 虚拟机。在<code>kvm_init()</code>的最后，会调用<code>memory_listener_register()</code>注册<code>kvm_memory_listener</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">(MachineState *ms)</span></span><br><span class="hljs-function"></span>&#123;<br>    MachineClass *mc = MACHINE_GET_CLASS(ms);<br>    <span class="hljs-comment">// 打开/dev/kvm</span><br>    s-&gt;fd = qemu_open_old(<span class="hljs-string">&quot;/dev/kvm&quot;</span>, O_RDWR);<br>    <span class="hljs-comment">// 创建 VM</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        ret = kvm_ioctl(s, KVM_CREATE_VM, type);<br>    &#125; <span class="hljs-keyword">while</span> (ret == -EINTR);<br><span class="hljs-comment">/* ... */</span><br>    ret = kvm_arch_init(s); <span class="hljs-comment">// 针对不同的架构进行初始化</span><br><br>    <span class="hljs-comment">// 对于以下 AddressSpace，设置其对应的 listener</span><br>    kvm_memory_listener_register(s, &amp;s-&gt;memory_listener,<br>                                 &amp;address_space_memory, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;kvm-memory&quot;</span>);<br>    memory_listener_register(&amp;kvm_coalesced_pio_listener,<br>                             &amp;address_space_io);<br><span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">(MemoryListener *listener, AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryListener *other = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* Only one of them can be defined for a listener */</span><br>    assert(!(listener-&gt;log_sync &amp;&amp; listener-&gt;log_sync_global));<br><br>    listener-&gt;address_space = as;<br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;memory_listeners)<br>        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;memory_listeners)-&gt;priority) &#123;<br>        QTAILQ_INSERT_TAIL(&amp;memory_listeners, listener, link);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        QTAILQ_FOREACH(other, &amp;memory_listeners, link) &#123;<br>            <span class="hljs-keyword">if</span> (listener-&gt;priority &lt; other-&gt;priority) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        QTAILQ_INSERT_BEFORE(other, listener, link);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;as-&gt;listeners)<br>        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;as-&gt;listeners)-&gt;priority) &#123;<br>        QTAILQ_INSERT_TAIL(&amp;as-&gt;listeners, listener, link_as);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        QTAILQ_FOREACH(other, &amp;as-&gt;listeners, link_as) &#123;<br>            <span class="hljs-keyword">if</span> (listener-&gt;priority &lt; other-&gt;priority) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        QTAILQ_INSERT_BEFORE(other, listener, link_as);<br>    &#125;<br><br>    listener_add_address_space(listener, as);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后的<code>listener_add_address_space()</code>主要是将 listener 注册到其对应的 <code>AddressSpace</code> 上，并根据 <code>AddressSpace</code> 对应的 <code>FlatRange</code> 数组，生成 <code>MemoryRegionSection</code>【<code>MemoryRegionSection</code>就像是为<code>FlatRange</code>数组设置的一种中介表示，便于传入<code>KVM</code>，因为传入<code>KVM</code>应该是对平坦内存的一种表示】，并注册到 <code>KVM</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">(MemoryListener *listener,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    FlatView *view;<br>    FlatRange *fr;<br><br>    <span class="hljs-keyword">if</span> (listener-&gt;begin) &#123;<br>        listener-&gt;begin(listener);<br>    &#125;<br>    <span class="hljs-comment">/* 开启内存脏页记录 */</span><br>    <span class="hljs-keyword">if</span> (global_dirty_tracking) &#123;<br>        <span class="hljs-keyword">if</span> (listener-&gt;log_global_start) &#123;<br>            listener-&gt;log_global_start(listener);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 遍历 AddressSpace 对应的 FlatRange 数组，并将其转换成 MemoryRegionSection */</span><br>    view = address_space_get_flatview(as);<br>    FOR_EACH_FLAT_RANGE(fr, view) &#123;<br>        MemoryRegionSection section = section_from_flat_range(fr, view);<br>        <span class="hljs-comment">/* 将 section 所代表的内存区域注册到 KVM 中 */</span><br>        <span class="hljs-keyword">if</span> (listener-&gt;region_add) &#123;<br>            listener-&gt;region_add(listener, &amp;section);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fr-&gt;dirty_log_mask &amp;&amp; listener-&gt;log_start) &#123;<br>            listener-&gt;log_start(listener, &amp;section, <span class="hljs-number">0</span>, fr-&gt;dirty_log_mask);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (listener-&gt;commit) &#123;<br>        listener-&gt;commit(listener);<br>    &#125;<br>    flatview_unref(view);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于此时 <code>AddressSapce</code> 尚未初始化，所以此处的循环为空，仅是在全局注册了<code>kvm_memory_listener</code>。最后调用了<code>kvm_memory_listener-&gt;region_add()</code>，对应的实现是<code>kvm_region_add()</code>，该函数最终会通过<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>，将 <code>QEMU</code> 侧申请的内存信息传入 <code>KVM</code> 进行注册，这里的流程会在下一部分进行分析。</p>
<h3 id="AddressSpace-的初始化"><a href="#AddressSpace-的初始化" class="headerlink" title="AddressSpace 的初始化"></a>AddressSpace 的初始化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125154841.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">void</span> <span class="hljs-title">cpu_exec_init_all</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       ├─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_map_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 初始化 system_memory/io 这两个全局 MemoryRegion</span></span><br><span class="hljs-function">       |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">set_system_memory_map</span><span class="hljs-params">()</span> <span class="hljs-comment">// address_space_memory-&gt;root = system_memory</span></span><br><span class="hljs-function">       |    |    └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_update_topology</span><span class="hljs-params">()</span>        <span class="hljs-comment">// 为 MemoryRegion 生成 FlatView</span></span><br><span class="hljs-function">       |    |         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">()</span>   <span class="hljs-comment">// as-&gt;current_map = new_view</span></span><br><span class="hljs-function">       |    |              └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    |                   └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span>        <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">       |    |                        └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">       |    |                             └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    |                                  └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br><span class="hljs-function">       |    |</span><br><span class="hljs-function">       |    └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">()</span> <span class="hljs-comment">// 注册对应的 MemoryListener</span></span><br><span class="hljs-function">       |         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |</span><br><span class="hljs-function">       └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io_mem_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_io</span><span class="hljs-params">()</span> <span class="hljs-comment">// ram/rom/unassigned/notdirty/subpage-ram/watch</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>第一部分在全局注册了<code>kvm_memory_listener</code>，但由于<code>AddressSpace</code> 尚未初始化，实际上并未向 <code>KVM</code> 中注册任何实际的内存信息。<code>QEMU</code> 在<code>main()</code>函数中会继续调用<code>cpu_exec_init_all()</code>对<code>AddressSpace</code>进行初始化，该函数实际上是对两个 <code>init</code> 函数的封装调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cpu_exec_init_all</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    qemu_mutex_init(&amp;ram_list.mutex);<br>    <span class="hljs-comment">/* The data structures we set up here depend on knowing the page size,</span><br><span class="hljs-comment">     * so no more changes can be made after this point.</span><br><span class="hljs-comment">     * In an ideal world, nothing we did before we had finished the</span><br><span class="hljs-comment">     * machine setup would care about the target page size, and we could</span><br><span class="hljs-comment">     * do this much later, rather than requiring board models to state</span><br><span class="hljs-comment">     * up front what their requirements are.</span><br><span class="hljs-comment">     */</span><br>    finalize_target_page_bits();<br>    io_mem_init();      <span class="hljs-comment">// 初始化六个I/O MemoryRegion</span><br>    memory_map_init(); <span class="hljs-comment">// 初始化两个全局 AddressSpace，以及对应的 MemoryRegion、FlatView</span><br>    qemu_mutex_init(&amp;map_client_list_lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先来看<code>memory_map_init()</code>，主要用来初始化两个全局的系统地址空间<code>system_memory</code>、<code>system_io</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_map_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    system_memory = g_malloc(<span class="hljs-keyword">sizeof</span>(*system_memory));<br>    <span class="hljs-comment">// 1. 初始化 system_memory</span><br>    memory_region_init(system_memory, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;system&quot;</span>, UINT64_MAX);<br>    <span class="hljs-comment">// 2. 设置 address_space_memory 关联 system_memory</span><br>    <span class="hljs-comment">// 这两个都是全局变量，也就是把内存地址空间和 IO 地址空间于对应的 MemoryRegion 联系起来 </span><br>    <span class="hljs-comment">//及其对应的 FlatView</span><br>    address_space_init(&amp;address_space_memory, system_memory, <span class="hljs-string">&quot;memory&quot;</span>);<br><br>    system_io = g_malloc(<span class="hljs-keyword">sizeof</span>(*system_io));<br>    <span class="hljs-comment">// 1. 初始化 system_io  </span><br>    memory_region_init_io(system_io, <span class="hljs-literal">NULL</span>, &amp;unassigned_io_ops, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;io&quot;</span>,<br>                          <span class="hljs-number">65536</span>);<br>    <span class="hljs-comment">// 2. 设置 address_space_io 关联 system_io </span><br>    <span class="hljs-comment">// 及其对应的 FlatView</span><br>    address_space_init(&amp;address_space_io, system_io, <span class="hljs-string">&quot;I/O&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里比较重要的是<code>address_space_init()</code>，先设置 <code>AddressSpace</code> 对应的 <code>MemoryRegion</code>，之后根据<code>system_memory</code>更新<code>address_space_memory</code>对应的 <code>FlatView</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">address_space_init</span><span class="hljs-params">(AddressSpace *as, MemoryRegion *root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_ref(root);<br>    <span class="hljs-comment">// 将 address_space_memory 的 root 域指向 system_memory</span><br>    as-&gt;root = root;        <br>    as-&gt;current_map = <span class="hljs-literal">NULL</span>;<br>    as-&gt;ioeventfd_nb = <span class="hljs-number">0</span>;<br>    as-&gt;ioeventfds = <span class="hljs-literal">NULL</span>;<br>    QTAILQ_INIT(&amp;as-&gt;listeners);<br>    QTAILQ_INSERT_TAIL(&amp;address_spaces, as, address_spaces_link);<br>    as-&gt;name = g_strdup(name ? name : <span class="hljs-string">&quot;anonymous&quot;</span>);<br>    <span class="hljs-comment">// 根据 system_memory 更新 address_space_memory 对应的 FlatView</span><br>    address_space_update_topology(as);  <br>    address_space_update_ioeventfds(as);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>address_space_update_topology()</code>会继续调用<code>generate_memory_topology()</code>生成 <code>AddressSpace</code> 对应的 <code>FlatView</code>视图：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">(AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);<br><br>    flatviews_init();<br>    <span class="hljs-keyword">if</span> (!g_hash_table_lookup(flat_views, physmr)) &#123;<br>        generate_memory_topology(physmr);<br>    &#125;<br>    address_space_set_flatview(as);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>address_space_update_topology()</code>会先调用<code>generate_memory_topology()</code>生成<code>system_memory</code>更新后的视图<code>new_view</code>，再将<code>address_space_memory</code>的<code>current_map</code>指向这个<code>new_view</code>，最后销毁<code>old_view</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_set_flatview</span><span class="hljs-params">(AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    FlatView *old_view = address_space_to_flatview(as);<br>    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);<br>    FlatView *new_view = g_hash_table_lookup(flat_views, physmr);<br><br>    assert(new_view);<br><br>    <span class="hljs-keyword">if</span> (old_view == new_view) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_ref(old_view);<br>    &#125;<br><br>    flatview_ref(new_view);<br><br>    <span class="hljs-keyword">if</span> (!QTAILQ_EMPTY(&amp;as-&gt;listeners)) &#123;<br>        FlatView tmpview = &#123; .nr = <span class="hljs-number">0</span> &#125;, *old_view2 = old_view;<br><br>        <span class="hljs-keyword">if</span> (!old_view2) &#123;<br>            old_view2 = &amp;tmpview;<br>        &#125;<br>        address_space_update_topology_pass(as, old_view2, new_view, <span class="hljs-literal">false</span>);<br>        address_space_update_topology_pass(as, old_view2, new_view, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Writes are protected by the BQL.  */</span><br>    qatomic_rcu_set(&amp;as-&gt;current_map, new_view);<br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_unref(old_view);<br>    &#125;<br><br>    <span class="hljs-comment">/* Note that all the old MemoryRegions are still alive up to this</span><br><span class="hljs-comment">     * point.  This relieves most MemoryListeners from the need to</span><br><span class="hljs-comment">     * ref/unref the MemoryRegions they get---unless they use them</span><br><span class="hljs-comment">     * outside the iothread mutex, in which case precise reference</span><br><span class="hljs-comment">     * counting is necessary.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_unref(old_view);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>address_space_update_topology_pass()</code>的最后，会调用<code>MEMORY_LISTENER_UPDATE_REGION</code>这个宏，触发<code>region_add</code>对应的回调函数<code>kvm_region_add()</code>。</p>
<p>这个宏在<code>memory.c</code>中定义，会将 <code>FlatView</code> 中的 <code>FlatRange</code> 转换为 <code>MemoryRegionSection</code>，作为入参传递给<code>kvm_region_add()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* No need to ref/unref .mr, the FlatRange keeps it alive.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...)  \</span><br><span class="hljs-meta">    do &#123;                                                                \</span><br><span class="hljs-meta">        MemoryRegionSection mrs = section_from_flat_range(fr,           \</span><br><span class="hljs-meta">                address_space_to_flatview(as));                         \</span><br><span class="hljs-meta">        MEMORY_LISTENER_CALL(as, callback, dir, &amp;mrs, ##_args);         \</span><br><span class="hljs-meta">    &#125; while(0)</span><br></code></pre></td></tr></table></figure>

<p>而<code>kvm_region_add()</code>实际上是对<code>kvm_set_phys_mem()</code>的封装调用。该函数比较复杂，会根据传入的<code>section</code>填充 KVMSlot，再传递给<code>kvm_set_user_memory_region()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">(KVMMemoryListener *kml, KVMSlot *slot, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">new</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    KVMState *s = kvm_state;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">mem</span>;</span><br>    <span class="hljs-keyword">int</span> ret;<br><br>    <span class="hljs-comment">// 根据 KVMSlot 填充 kvm_userspace_memory_region</span><br>    mem.slot = slot-&gt;slot | (kml-&gt;as_id &lt;&lt; <span class="hljs-number">16</span>);<br>    mem.guest_phys_addr = slot-&gt;start_addr;<br>    mem.userspace_addr = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)slot-&gt;ram;<br>    mem.flags = slot-&gt;flags;<br><br>    <span class="hljs-keyword">if</span> (slot-&gt;memory_size &amp;&amp; !<span class="hljs-keyword">new</span> &amp;&amp; (mem.flags ^ slot-&gt;old_flags) &amp; KVM_MEM_READONLY) &#123;<br>        <span class="hljs-comment">/* Set the slot size to 0 before setting the slot to the desired</span><br><span class="hljs-comment">         * value. This is needed based on KVM commit 75d61fbc. */</span><br>        mem.memory_size = <span class="hljs-number">0</span>;<br>        ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> err;<br>        &#125;<br>    &#125;<br>    mem.memory_size = slot-&gt;memory_size;<br>    ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>    slot-&gt;old_flags = mem.flags;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里又将 <code>KVMSlot</code> 转换为 <code>kvm_userspace_memory_region</code>，作为<code>ioctl()</code>的参数，交给内核中的 <code>KVM</code> 进行内存的注册【设置<code>GPA-&gt;HVA</code>的映射关系，在内核空间维护并管理 Guest 的内存】。</p>
<p>至此 QEMU 侧负责管理内存的数据结构均已完成初始化，<strong>可以参考下面的图片了解各数据结构之间的对应关系</strong></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127155506.png"></p>
<h3 id="实际内存的分配"><a href="#实际内存的分配" class="headerlink" title="实际内存的分配"></a>实际内存的分配</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127160121.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">void</span> machine-&gt;<span class="hljs-title">init</span><span class="hljs-params">(ram_size, ...)</span></span><br><span class="hljs-function">       └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc_init_pci</span><span class="hljs-params">(ram_size, ...)</span> <span class="hljs-comment">// 初始化虚拟机</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc_init1</span><span class="hljs-params">(system_memory, system_io, ram_size, ...)</span></span><br><span class="hljs-function">                 ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">(pci_memory, <span class="hljs-string">&quot;pci&quot;</span>, ...)</span> <span class="hljs-comment">// pci_memory, rom_memory</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">void</span> <span class="hljs-title">pc_memory_init</span><span class="hljs-params">()</span> <span class="hljs-comment">// 初始化内存，分配实际的物理内存地址</span></span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">()</span> <span class="hljs-comment">// 创建 pc.ram, pc.rom 并分配内存</span></span><br><span class="hljs-function">                      |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |    └─ <span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |         └─ <span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc_from_ptr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |</span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">vmstate_register_ram_global</span><span class="hljs-params">()</span> <span class="hljs-comment">// 将 MR 的 name 写入 RAMBlock 的 idstr</span></span><br><span class="hljs-function">                      |    └─ <span class="hljs-keyword">void</span> <span class="hljs-title">vmstate_register_ram</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |         └─ <span class="hljs-keyword">void</span> <span class="hljs-title">qemu_ram_set_idstr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |</span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_alias</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 初始化 ram_below_4g, ram_above_4g</span></span><br><span class="hljs-function">                      └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_add_subregion</span><span class="hljs-params">()</span> <span class="hljs-comment">// 在 system_memory 中添加 subregions</span></span><br><span class="hljs-function">                           └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_add_subregion_common</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_update_topology</span><span class="hljs-params">()</span> <span class="hljs-comment">// 为 MemoryRegion 生成 FlatView</span></span><br><span class="hljs-function">                                     └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">()</span> <span class="hljs-comment">// as-&gt;current_map = new_view</span></span><br><span class="hljs-function">                                          └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                               └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span> <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">                                                    └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">                                                         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                                              └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br></code></pre></td></tr></table></figure>

<p>之前的回调函数注册、AddressSpace 的初始化，实际上均没有对应的物理内存。【实际的内存是在 RAMBlock 中】</p>
<p>我们再回到 <code>qemu</code> 启动的 <code>main</code> 函数中。接下来的初始化过程会调用 <code>pc_init1</code>。在这里面，对于 <code>CPU</code> 虚拟化，我们会调用 <code>pc_cpus_init</code>。另外，<code>pc_init1</code> 还会调用<code>pc_memory_init</code>，进行内存的虚拟化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram, *option_rom_mr;         <span class="hljs-comment">// 两个实体 MR: pc.ram, pc.rom</span><br>    MemoryRegion *ram_below_4g, *ram_above_4g; <span class="hljs-comment">// 两个别名 MR: ram_below_4g, ram_above_4g</span><br><br>    <span class="hljs-comment">/* Allocate RAM.  We allocate it as a single memory region and use</span><br><span class="hljs-comment">     * aliases to address portions of it, mostly for backwards compatibility</span><br><span class="hljs-comment">     * with older qemus that used qemu_ram_alloc().</span><br><span class="hljs-comment">     */</span><br>    ram = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram)); <span class="hljs-comment">// 创建 ram</span><br>    <span class="hljs-comment">// 分配具体的内存（实际上会创建一个 RAMBlock 并将其 offset 值写入 ram.ram_addr，对应 GPA）</span><br>    memory_region_init_ram(ram, <span class="hljs-string">&quot;pc.ram&quot;</span>, below_4g_mem_size + above_4g_mem_size);<br>    <span class="hljs-comment">// 将 MR 的 name 写入 RAMBlock 的 idstr</span><br>    vmstate_register_ram_global(ram);<br>    *ram_memory = ram;<br><br>    <span class="hljs-comment">// 创建 ram_below_4g 表示 4G 以下的内存</span><br>    ram_below_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_below_4g));<br>    memory_region_init_alias(ram_below_4g, <span class="hljs-string">&quot;ram-below-4g&quot;</span>, ram, <span class="hljs-number">0</span>, below_4g_mem_size);<br>    <span class="hljs-comment">// 将 ram_below_4g 挂在 system_memory 下</span><br>    memory_region_add_subregion(system_memory, <span class="hljs-number">0</span>, ram_below_4g);<br><br>    <span class="hljs-keyword">if</span> (above_4g_mem_size &gt; <span class="hljs-number">0</span>) &#123;<br>        ram_above_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_above_4g));<br>        memory_region_init_alias(ram_above_4g, <span class="hljs-string">&quot;ram-above-4g&quot;</span>, ram, below_4g_mem_size, above_4g_mem_size);<br>        memory_region_add_subregion(system_memory, <span class="hljs-number">0x100000000</span>ULL, ram_above_4g);<br>    &#125;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的重点在于<code>memory_region_init_ram()</code>，它通过<code>qemu_ram_alloc()</code>获取 ram 这个 <code>MemoryRegion</code> 对应的 <code>RAMBlock</code> 的<code>offset</code>，并存入<code>ram.ram_addr</code>，这样就可以在<code>ram_list</code>中根据该字段查找 <code>MR</code> 对应的 <code>RAMBlock</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">(MemoryRegion *mr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size); <span class="hljs-comment">// 填充字段，初始化默认值</span><br>    mr-&gt;ram = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示为 RAM</span><br>    mr-&gt;terminates = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示为实体 MemoryRegion</span><br>    mr-&gt;destructor = memory_region_destructor_ram;<br>    mr-&gt;ram_addr = qemu_ram_alloc(size, mr); <span class="hljs-comment">// 这里保存 RAMBlock 的 offset，即 GPA</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>而 qemu_ram_alloc() 最终会调用 qemu_ram_alloc_from_ptr()，创建一个对应大小 RAMBlock 并分配内存，返回对应的 GPA 地址存入 mr-&gt;ram_addr 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc_from_ptr</span><span class="hljs-params">(<span class="hljs-keyword">ram_addr_t</span> size, <span class="hljs-keyword">void</span> *host,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   MemoryRegion *mr)</span></span><br><span class="hljs-function"></span>&#123;<br>    RAMBlock *new_block; <span class="hljs-comment">// 创建一个 RAMBlock</span><br><br>    size = TARGET_PAGE_ALIGN(size); <span class="hljs-comment">// 页对齐</span><br>    new_block = g_malloc0(<span class="hljs-keyword">sizeof</span>(*new_block)); <span class="hljs-comment">// 初始化 new_block</span><br><br>    new_block-&gt;mr = mr; <span class="hljs-comment">// 将 new_block-&gt; 指向入参的 MemoryRegion</span><br>    new_block-&gt;offset = find_ram_offset(size); <span class="hljs-comment">// 从 ram_list 中的 RAMBlock 之间找到一段可以满足 size 需求的 gap，并返回起始地址的 offset，对应 GPA</span><br>    <span class="hljs-keyword">if</span> (host) &#123; <span class="hljs-comment">// 新建的 RAMBlock host 字段为空，跳过</span><br>        new_block-&gt;host = host;<br>        new_block-&gt;flags |= RAM_PREALLOC_MASK;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mem_path) &#123; <span class="hljs-comment">// 未指定 mem_path</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (__linux__) &amp;&amp; !defined(TARGET_S390X)</span><br>            new_block-&gt;host = file_ram_alloc(new_block, size, mem_path);<br>            <span class="hljs-keyword">if</span> (!new_block-&gt;host) &#123;<br>                new_block-&gt;host = qemu_vmalloc(size);<br>                qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;-mem-path option unsupported\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (xen_enabled()) &#123;<br>                xen_ram_alloc(new_block-&gt;offset, size, mr);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kvm_enabled()) &#123; <span class="hljs-comment">// 从这里继续</span><br>                <span class="hljs-comment">/* some s390/kvm configurations have special constraints */</span><br>                new_block-&gt;host = kvm_vmalloc(size); <span class="hljs-comment">// 实际上还是调用 qemu_vmalloc(size)</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                new_block-&gt;host = qemu_vmalloc(size); <span class="hljs-comment">// 从 QEMU 的线性空间中分配 size 大小的内存，返回 HVA</span><br>            &#125;<br>            qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);<br>        &#125;<br>    &#125;<br>    new_block-&gt;length = size; <span class="hljs-comment">// 将 length 设置为 size</span><br><br>    QLIST_INSERT_HEAD(&amp;ram_list.blocks, new_block, next); <span class="hljs-comment">// 将该 RAMBlock 插入 ram_list 头部</span><br><br>    ram_list.phys_dirty = g_realloc(ram_list.phys_dirty, <span class="hljs-comment">// 重新分配 ram_list.phys_dirty 的内存空间</span><br>                                       last_ram_offset() &gt;&gt; TARGET_PAGE_BITS);<br>    <span class="hljs-built_in">memset</span>(ram_list.phys_dirty + (new_block-&gt;offset &gt;&gt; TARGET_PAGE_BITS),<br>           <span class="hljs-number">0</span>, size &gt;&gt; TARGET_PAGE_BITS);<br>    cpu_physical_memory_set_dirty_range(new_block-&gt;offset, size, <span class="hljs-number">0xff</span>); <span class="hljs-comment">// 对该 RAMBlock 对应的内存标记为 dirty</span><br><br>    qemu_ram_setup_dump(new_block-&gt;host, size);<br><br>    <span class="hljs-keyword">if</span> (kvm_enabled())<br>        kvm_setup_guest_memory(new_block-&gt;host, size);<br><br>    <span class="hljs-keyword">return</span> new_block-&gt;offset;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样一来<code>ram</code>【其实就是<code>system memory</code>，整个<code>Guest</code>物理空间的大小】对应的 <code>RAMBlock</code> 中就分配好了 <code>GPA</code> 和 <code>HVA</code>，就可以<strong>将内存信息同步至 KVM 侧</strong>了。</p>
<p>最后回到<code>pc_memory_init()</code>中，在分配完实际内存后，会先调用<code>memory_region_init_alias()</code>初始化<code>ram_below_4g</code>、<code>ram_above_4g</code>这两个<code>alias</code>，之后调用<code>memory_region_add_subregion()</code>将这两个 <code>alias</code> 指向<code>ram</code>这个实体 <code>MemoryRegion</code>。如下图，该函数最终会触发<code>kvm_region_add()</code>回调，将实际的内存信息传入 <code>KVM</code> 注册。该过程如下图所示，与之前分析的流程相同，此处不再赘述。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163205.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟机的内存管理也是需要用户态的 <code>qemu</code> 和内核态的 <code>KVM</code> 共同完成。为了加速内存映射，需要借助硬件的 <code>EPT</code> 技术。</p>
<h3 id="QEMU-侧"><a href="#QEMU-侧" class="headerlink" title="QEMU 侧"></a>QEMU 侧</h3><ul>
<li><p>创建一系列 <code>MemoryRegion</code>，分别表示 <code>Guest</code> 中的 <code>RAM</code>、<code>ROM</code> 等区域。<code>MemoryRegion</code>之间通过 <code>alias</code> 或 <code>subregions</code> 的方式维护相互之间的关系，从而进一步细化区域的定义</p>
</li>
<li><p>对于一个实体 <code>MemoryRegion</code>（非 <code>alias</code>），在初始化内存的过程中 <code>QEMU</code> 会创建它所对应的 <code>RAMBlock</code>。该 <code>RAMBlock</code> 通过调用<code>qemu_ram_alloc_from_ptr()</code>从 <code>QEMU</code> 的进程地址空间中<strong>以 mmap 的方式分配内存</strong>，并负责<strong>维护该 MemoryRegion 对应内存的起始 GPA/HVA/size 等相关信息</strong>【在<code>qemu_ram_alloc_from_ptr</code>中创建的新<code>RAMBlock</code>有<code>offset</code>、<code>host</code>的赋值，即<code>GPA-&gt;HVA</code>的对应关系】</p>
</li>
<li><p><code>AddressSpace</code> 表示 <code>Guest</code> 的物理地址空间。如果 <code>AddressSpace</code> 中的 <code>MemoryRegion</code> 发生变化，则注册的 <code>listener</code> 会被触发，将所属的 <code>MemoryRegion</code> 树展开生成一维的 <code>FlatView</code>，比较 FlatRange 是否发生了变化。如果是，则调用相应的方法对 <code>MemoryRegionSection</code> 进行检查，更新 <code>QEMU</code> 中的 <code>KVMSlot</code>，同时填充<code>kvm_userspace_memory_region</code>结构体，作为<code>ioctl()</code>的参数更新 <code>KVM</code> 中的<code>kvm_memory_slot</code></p>
</li>
</ul>
<h3 id="KVM-侧"><a href="#KVM-侧" class="headerlink" title="KVM 侧"></a>KVM 侧</h3><ul>
<li><p>当 <code>QEMU</code> 通过<code>ioctl()</code>创建 <code>vcpu</code> 时，调用<code>kvm_mmu_create()</code>初始化 <code>MMU</code> 相关信息。<br>当 <code>KVM</code> 要进入 <code>Guest</code> 前，<code>vcpu_enter_guest()=&gt;kvm_mmu_reload()</code>会将根级页表地址加载到 <code>VMCS</code>，让 <code>Guest</code> 使用该页表</p>
</li>
<li><p>当发生<code>EPT Violation</code> 时，<code>VM-EXIT</code>到 <code>KVM</code> 中。如果是缺页，则根据 <code>GPA</code> 算出 <code>gfn</code>，再根据 <code>gfn</code> 找到对应的 <code>KVMSlot</code>，从中得到对应的 <code>HVA</code>。然后根据 <code>HVA</code> 算出对应的 <code>pfn</code>，确保该 <code>Page</code> 位于内存中。填好缺失的页之后，需要更新 <code>EPT</code>，完善其中缺少的页表项，逐层补全页表</p>
</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163418.png"></p>
<blockquote>
<p>虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即 <code>mmap</code> 分配的虚拟内存空间被访问的时候，先查看 <code>EPT</code> 页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。<br>如果没有映射过，则虚拟机会通过<code>VM-Exit</code>指令回到宿主机模式，通过 <code>handle_ept_violation</code> 补充页表映射。先是通过 <code>handle_mm_fault</code>为虚拟机的物理内存空间分配真正的物理页面，然后通过 <code>__direct_map</code> 添加 <code>EPT</code> 页表映射。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127171031.jpg"></p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="http://xudaxian.fun/2020/09/03/QEMU%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">“QEMU 内存空间虚拟化及内存管理” - B10g | FΓom 许大仙</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LoyenWang/p/13943005.html">【原创】Linux 虚拟化 KVM-Qemu 分析（五）之内存虚拟化 - LoyenWang - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiongwenwu/article/details/58586013">KVM/Qemu 工作原理系列目录_xiongwenwu 的专栏-CSDN 博客_qemu 目录结构</a><br><a target="_blank" rel="noopener" href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" title="QEMU 源码分析-内存虚拟化" target="_blank" rel="external">http://example.com/2022/01/25/QEMU源码分析-内存虚拟化/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">夜云泊</span><small class="ml-1x">软件工程师</small></a></h3>
        <div>分享经验</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/01/27/SSH%E5%8E%9F%E7%90%86/" title="SSH 原理"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/01/19/%E8%A7%A3%E5%86%B3VSCode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%87%E7%A8%8B%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8/" title="解决 VSCode 配置远程连接，过程试图写入的管道不存在"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Dunky-Z" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'gg',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>