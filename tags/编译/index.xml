<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>编译 on PaperMod</title>
    <link>http://localhost:8888/tags/%E7%BC%96%E8%AF%91/</link>
    <description>Recent content in 编译 on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Sun, 08 May 2022 21:32:23 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/tags/%E7%BC%96%E8%AF%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>链接脚本入门</title>
      <link>http://localhost:8888/posts/%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 08 May 2022 21:32:23 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/</guid>
      <description>重定位 位置无关编码 (PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。
位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。
我们在设计一个程序时，会给这个程序指定一个运行地址（链接地址）。就是说我们在编译程序时其实心里是知道我们程序将来被运行时的地址（运行地址）的，而且必须给编译器链接器指定这个地址（链接地址）才行。
最后得到的二进制程序理论上是和你指定的运行地址有关的，将来这个程序被执行时必须放在当时编译链接时给定的那个地址（链接地址）下才行，否则不能运行（就叫位置有关代码）。但是有个别特别的指令他可以跟指定的地址（链接地址）没有关系，也就是说这些代码实际运行时不管放在哪里都能正常运行。
运行地址：由运行时决定的（编译链接时是无法绝对确定运行时地址的）。
链接地址：由程序员在编译链接的过程中，通过Makefile中-Ttext xxx或者在链接脚本中指定的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。
举例：Linux 中的应用程序。gcc hello.c -o hello，这时使用默认的链接地址就是0x0，所以应用程序都是链接在0x0地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享 4G 的虚拟地址空间。所以应用程序都可以链接到 0 地址，因为每个进程都是从 0 地址开始的。（编译时可以不给定链接地址而都使用0x0）
编译链接过程 每个过程的作用 预编译：预编译器执行。替换宏定义，删除注释等工作。 编译：编译器来执行。把源码.c .S编程机器码.o文件。 链接：链接器来执行。把.o文件中的各函数（段）按照一定规则（链接脚本来指定）累积在一起，形成可执行文件。 strip：strip 是把可执行程序中的符号信息给拿掉，以节省空间。（Debug 版本和 Release 版本） objcopy：由可执行程序生成可烧录的镜像bin文件。 编译后生成的段 段就是程序的一部分，我们把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段放在合适的位置。
段名分为 2 种：一种是编译器链接器内部定好的，一种是程序员自己指定的、自定义的段名。 已有段名：
代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西 数据段：（.data），数据段就是 C 语言中有显式初始化为非 0 的全局变量 bss 段：（.bss），又叫 ZI（zero initial）段，就是零初始化段，对应 C 语言中初始化为 0 的全局变量。 自定义段名：段名由程序员自己定义，段的属性和特征也由程序员自己定义。 C 语言中全局变量如果未显式初始化，值是 0。本质就是 C 语言把这类全局变量放在了 bss 段，从而保证了为 0。 C 运行时环境如何保证显式初始化为非 0 的全局变量的值在 main 之前就被赋值了？就是因为它把这类变量放在了.data 段中，而.data 段会在 main 执行之前被处理（初始化）。</description>
    </item>
  </channel>
</rss>
