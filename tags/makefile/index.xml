<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Makefile on PaperMod</title>
    <link>http://localhost:8888/tags/makefile/</link>
    <description>Recent content in Makefile on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Mon, 26 Sep 2022 21:36:18 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/tags/makefile/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Makefile 基础</title>
      <link>http://localhost:8888/posts/makefile%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 26 Sep 2022 21:36:18 +0000</pubDate>
      <guid>http://localhost:8888/posts/makefile%E5%9F%BA%E7%A1%80/</guid>
      <description>目标、依赖、命令 目标就是我们要去 make xxx 的那个 xxx，就是我们最终要生成的东西。 依赖是用来生成目录的原材料 命令就是加工方法，所以 make xxx 的过程其实就是使用命令将依赖加工成目标的过程。 通配符 % 和 Makefile 自动推导 % 是 Makefile 中的通配符，代表一个或几个字母。也就是说%.o就代表所有以.o为结尾的文件。 所谓自动推导其实就是 Makefile 的规则。当 Makefile 需要某一个目标时，他会把这个目标去套规则说明，一旦套上了某个规则说明，则 Makefile 会试图寻找这个规则中的依赖，如果能找到则会执行这个规则用依赖生成目标。 Makefile 中定义和使用变量 Makefile 中定义和使用变量，和 shell 脚本中非常相似。相似的是都没有变量类型，直接定义使用，引用变量时用$var。 伪目标（.PHONY） 伪目标意思是这个目标本身不代表一个文件，执行这个目标不是为了得到某个文件或东西，而是单纯为了执行这个目标下面的命令。 伪目标一般都没有依赖，因为执行伪目标就是为了执行目标下面的命令。既然一定要执行命令了那就不必加依赖，因为不加依赖意思就是无条件执行。 伪目标可以直接写，不影响使用；但是有时候为了明确声明这个目标是伪目标会在伪目标的前面用.PHONY来明确声明它是伪目标。 Makfile 中引用其他 Makefile 有时候 Makefile 总体比较复杂，因此分成好几个 Makefile 来写。然后在主 Makefile 中引用其他的，用 include 指令来引用。引用的效果也是原地展开，和 C 语言中的头文件包含非常相似。 赋值 =最简单的赋值 :=一般也是赋值 以上这两个大部分情况下效果是一样的，但是有时候不一样。用=赋值的变量，在被解析时他的值取决于最后一次赋值时的值，所以你看变量引用的值时不能只往前面看，还要往后面看。用:=来赋值的，则是就地直接解析，只用往前看即可。
?=如果变量前面并没有赋值过则执行这条赋值，如果前面已经赋值过了则本行被忽略。（实验可以看出：所谓的没有赋值过其实就是这个变量没有被定义过） +=用来给一个已经赋值的变量接续赋值，意思就是把这次的值加到原来的值的后面，有点类似于 strcat。（注意一个细节，+=续接的内容和原来的内容之间会自动加一个空格隔开） 注意：Makefile 中并不要求赋值运算符两边一定要有空格或者无空格，这一点比 shell 的格式要求要松一些。
Makefile 的环境变量 makefile 中用 export 导出的就是环境变量。一般情况下要求环境变量名用大写，普通变量名用小写。 环境变量和普通变量不同，可以这样理解：环境变量类似于整个工程中所有 Makefile 之间可以共享的全局变量，而普通变量只是当前本 Makefile 中使用的局部变量。所以要注意：定义了一个环境变量会影响到工程中别的 Makefile 文件，因此要小心。 Makefile 中可能有一些环境变量可能是 makefile 本身自己定义的内部的环境变量或者是当前的执行环境提供的环境变量（譬如我们在 make 执行时给 makefile 传参。make CC=arm-linux-gcc，其实就是给当前 Makefile 传了一个环境变量 CC，值是 arm-linux-gcc。我们在 make 时给 makefile 传的环境变量值优先级最高的，可以覆盖 makefile 中的赋值）。这就好像 C 语言中编译器预定义的宏__LINE__ __FUNCTION__等一样。 Makefile 中使用通配符 *：若干个任意字符 ?</description>
    </item>
    <item>
      <title>Makefile 确定宏定义</title>
      <link>http://localhost:8888/posts/makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Wed, 27 Jul 2022 08:28:03 +0000</pubDate>
      <guid>http://localhost:8888/posts/makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/</guid>
      <description>有时需要通过make编译命令时确定代码中的宏定义，如编译不同的版本只需要使用不同的编译命令即可，而不需要修改内部代码。
当前的需求是代码中有一部分代码通过宏定义来确定编译的是 DIE0 版本还是 DIE1 版本，如果定义了DIE_ORDINAL_0 就使用 DIE0 的基地址，如果未定义就使用 DIE1 的基地址。
#define DIE_ORDINAL_0 #ifdef DIE_ORDINAL_0 #define PERIPH_BASE (SYS_BASE_ADDR_DIE0) #else #define PERIPH_BASE (SYS_BASE_ADDR_DIE1) #endif gcc 命令支持-D宏定义，相当于 C 中的全局#define，在 Makefile 中我们可以通过宏定义来控制源程序的编译。只要在 Makefile 中的 CFLAGS 中通过选项-D 来指定你于定义的宏即可。
CFLAGS += -D DIE_ORDINAL_0 # 在编译的时候加上此选项就可以了 $(CC) $(CFLAGS) $^ -o $@ 这样的话，相当于设置了DIE_ORDINAL_0这个宏定义。但是我们想通过命令行的参数来决定是否使用这个宏定义，可以通过一些简单的方法获取：
ifeq ($(DIE0), y) CFLAGS +=-DDIE_ORDINAL_0 else CFLAGS +=-DDIE_ORDINAL_1 endif $(CC) $(CFLAGS) $^ -o $@ 从命令行找到DIE0这个参数，如果它等于y表示使用DIE_ORDINAL_0。如果不等于y则使用DIE_ORDINAL_1，因为我们代码里没有DIE_ORDINAL_1，所以就相当于没有定义DIE_ORDINAL_0。
命令行示例：
# 编译DIE0 make DIE0=&amp;#34;y&amp;#34; # 编译DIE1 make DIE0=&amp;#34;n&amp;#34; </description>
    </item>
  </channel>
</rss>
