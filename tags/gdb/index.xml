<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>GDB on PaperMod</title>
    <link>http://localhost:8888/tags/gdb/</link>
    <description>Recent content in GDB on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Sun, 14 Aug 2022 14:17:26 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/tags/gdb/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DEBUG 原理</title>
      <link>http://localhost:8888/posts/debug%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 14 Aug 2022 14:17:26 +0000</pubDate>
      <guid>http://localhost:8888/posts/debug%E5%8E%9F%E7%90%86/</guid>
      <description>了解调试原理时看到了一个质量比较高的视频，【蛋饼嵌入式】一起探究调试原理。UP 通俗，形象地讲解了 DEBUG 的一些原理，值得反复观看，但是视频不如文字查阅效率高，遂记录了以下文稿内容。
什么是 JTAG 1985 年，几家半导体厂商为了解决板级测试的问题，成立了 Joint Test Action Group（JTAG）联合测试行动小组，他们希望将测试点和测试电路集成在芯片内部引脚处。同时，留出一个统一协议的接口，大家都能通过这个接口来访问芯片的输入与输出状态。这样就省去了板级测试是的物理接触，同时还能进行逻辑性调试。后来 IEEE 组织，将这个方案制定成了标准 IEEE 1149.1，这就是现在我们常听到的 JTAG 调试。
边界扫描技术 实现 JTAG 调试最重要的一个技术就是边界扫描技术，核心思想是给芯片的每一个输入输出引脚，添加一个移位寄存器单元，也称为边界扫描单元（Boundary Scan Cell，BSC）。通过它一边可以实现对芯片输出数据的截取，另一边可以完成对输入数据的替代。正常运行状态下，这些寄存器又是透明般的存在。
这些位于引脚边界的移位寄存器，还可以串在一起，形成一条边界扫描链，以串行的方式从外部更新扫描单元上的数据，以及对外输出边界扫描单元捕获的数据。如果板上有多个这样的芯片，他们还能以菊花链的形式串联在一起，这样就大大方便了测试的过程。
要实现对内部移位寄存器单元或者说对整个扫描链的访问和操作，便依赖于 JTAG 调试协议和相应的物理接口。JTAG 标准接口包括以下几个部分：
TDI(Test Data In) TDO(Test Data Out) TCLK(Test Clock) TMS(Test Mode Select) TRST(Test Reset)：可选，用于复位 调试逻辑的实现，是通过芯片内部的 TAP（Test Access Port）来完成的。模式状态信号 TMS 配合测试时钟信号 TCLK，以一定的时序进入到 TAP 控制器后，由 TAP 控制器内部的状态机转化为相应的控制动作。从而完成数据的移位，引脚状态的捕获和更新。
设备 ID 寄存器构成的扫描链，板卡一连上调试器，通过对这条扫描链的访问，就能够识别到被调试芯片的信号。存放调试机制相关配置的数据寄存器，所构成的扫描链，后面断点和单步调试时就会用到。以及移位的 BYPASS 寄存器，当调试链路上有多个芯片连接时，来减少总调试链路的长度。
以上都属于数据寄存器构成扫描链，因为想要在他们之间进行切换，需要引入另外的指令寄存器，以及对应的扫描链，这样调试主机将不同的调试命令写到指令寄存器中，就可以选通需要调试的数据链路。数据与指令寄存器两种链路的切换，就通过 TAP 控制器完成。
补充： 如果芯片支持 JTAG 调试，那么芯片上就必须有上述的四个接口，TDI，TDO，TCLK，TMS。 芯片外有个 Adapter 与之 Pin to Pin 连接，负责协议转换，把 USB 的 JTAG 控制信息按 JTAG 协议转换输出，满足协议定义的电气特性。 Adapter 与 Host 连接，Host 可以是我们的 PC，也可以是另一个嵌入式调试器。 Host 上通常需要运行一些软件，如 OpenOCD，负责把 GDB 的高级别命令转换成 JTAG 命令，并通过特定 Adapter 的要求进行打包，调用 OS 提供的 USB/ETH/PCI 驱动发送出去。 GDB 与 OpenOCD 通过一些远程协议，如 TCP/IP，进行通信。这样就能够调试 Chip。</description>
    </item>
    <item>
      <title>CSAPPLAB-Bomb Lab</title>
      <link>http://localhost:8888/posts/csapp-lab-bomb-lab/</link>
      <pubDate>Sun, 29 Aug 2021 18:40:16 +0000</pubDate>
      <guid>http://localhost:8888/posts/csapp-lab-bomb-lab/</guid>
      <description>Tips 缩写注释 CSAPP：Computer Systems A Programmer’s Perspective（深入理解计算机操作系统）。CSAPP（C：P166，O：P278）表示书本的中文版第 166 页，英文原版第 278 页。
寄存器信息 了解寄存器的基本用途，看到一个汇编代码，可以大概了解这个寄存器是在栈中使用的，还是保存参数的，是调用者保存，还是被调用者保存。 GDB 调试过程用到的 GDB 命令可以先参考GDB 调试入门这篇文章。文中所用例子也是摘自与 BombLab 的源码，更容易理解如何使用。还有一定比较重要的是，如何使用 gdb 带参数调试。为了不用每次运行bomb程序都需要重新输入答案，bomb程序可以读取文本信息，在文本文件中写入答案即可免去手动输入。
phase_1 拆弹专家已上线，开干！！！！！！！！！！！！！
(gdb) b phase_1(gdb) b explode_bomb(gdb) disas phase_1Dump of assembler code for function phase_1:&amp;#39;0x0000000000400ee0 &amp;lt;+0&amp;gt;: sub $0x8,%rsp0x0000000000400ee4 &amp;lt;+4&amp;gt;: mov $0x402400,%esi0x0000000000400ee9 &amp;lt;+9&amp;gt;: callq 0x401338 &amp;lt;strings_not_equal&amp;gt;0x0000000000400eee &amp;lt;+14&amp;gt;: test %eax,%eax0x0000000000400ef0 &amp;lt;+16&amp;gt;: je 0x400ef7 &amp;lt;phase_1+23&amp;gt;0x0000000000400ef2 &amp;lt;+18&amp;gt;: callq 0x40143a &amp;lt;explode_bomb&amp;gt;0x0000000000400ef7 &amp;lt;+23&amp;gt;: add $0x8,%rsp0x0000000000400efb &amp;lt;+27&amp;gt;: retq End of assembler dump.</description>
    </item>
    <item>
      <title>GDB 调试入门</title>
      <link>http://localhost:8888/posts/gdb%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 29 Aug 2021 18:40:16 +0000</pubDate>
      <guid>http://localhost:8888/posts/gdb%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/</guid>
      <description>file 加载程序 (gdb) file bomb Reading symbols from bomb... set args 带参数调试 有时候程序不是直接可以运行的，需要加上一些必要的参数。带上参数运行很容易，只要在程序名后加上相应参数即可，但是如何带上参数进行调试呢？这就需要set args命令。
比如在BombLab实验中，我们不可能一次解决所有phase，但是每次重新调试，已经解决的phase还要重新输入一次答案，这就很麻烦，好在这个实验的作者也考虑到了，他支持读取文本。我们可以把答案预先写入一个文本文件中，程序读取已经保存的答案即可跳过相应的phase。
假设我们把答案写入了solutions.txt文件中，首先，我们加载程序，然后通过set args solutions.txt设置运行参数。
(gdb) file bomb Reading symbols from bomb... (gdb) set args solutions.txt (gdb) r Starting program: /home/dominic/learning-linux/bomb/bomb solutions.txt Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! Phase 1 defused. How about the next one? That&amp;#39;s number 2. Keep going! list 查看源码 查看 10 行源码 每条命令显示 10 行代码</description>
    </item>
    <item>
      <title>VSCode 调试 RISC-V 程序</title>
      <link>http://localhost:8888/posts/vscode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Mon, 23 Aug 2021 15:51:51 +0000</pubDate>
      <guid>http://localhost:8888/posts/vscode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/</guid>
      <description>前提 本文主要涉及 VSCode 的相关配置，编译及调试工具需要提前安装好。
已经安装好riscv-toolchain，包括riscv64-unknown-elf-gcc，riscv64-unknown-elf-gdb 已经安装好qemu，包括riscv32-softmmu,riscv32-linux-user,riscv64-softmmu,riscv64-linux-user 已经安装好g++,gdb 调试流程简介 对于我这样的新手，要调试一个项目源码最怕的就是开始，也就是怎么能把项目跑起来。
我们以一个简单的test项目，看看在 VSCode 里怎么跑起来。
拿到源码后，将其以文件夹形式，加入到 VSCode 中，文件 - 打开文件夹 - 选择 test 项目文件夹。项目就会在 VSCode 中打开，但是此时我们还无法编译运行，我们需要在 VSCode 上 构建出一个 C 语言的编译与调试环境。
首先得安装一个插件C/C++，打开插件中心Ctrl+Shit+X，搜索，安装。
然后输入F5，会弹出对话框，选择C++(GDB)，继续选择g++。VSCode 会自动创建.vscode文件夹，已经两个文件launch.json和tasks.json。 launch.json用来配置调试环境，tasks.json主要用来配置编译环境，当然也可以配置其他任务。task.json里配置的每个任务其实就相当于多开一个控制台。
配置tasks.json 因为我们先要编译源码，生成.out或者.exe文件，才能调试，所以先进行编译任务配置。
自动生成的文件是个配置模板，我们可以根据自己的实际情况进行配置，也有一部分可以保持默认。
// tasks.json{// https://code.visualstudio.com/docs/editor/tasks&amp;#34;version&amp;#34;: &amp;#34;2.0.0&amp;#34;,&amp;#34;tasks&amp;#34;: [{// 任务的名字，注意是大小写区分的//会在launch中调用这个名字&amp;#34;label&amp;#34;: &amp;#34;C/C++: g++ build active file&amp;#34;, // 任务执行的是shell&amp;#34;type&amp;#34;: &amp;#34;shell&amp;#34;, // 命令是g++&amp;#34;command&amp;#34;: &amp;#34;g++&amp;#34;, //g++ 后面带的参数&amp;#34;args&amp;#34;: [&amp;#34;&amp;#39;-Wall&amp;#39;&amp;#34;,&amp;#34;-g&amp;#34;, // 生成调试信息，否则无法进入断点&amp;#34;&amp;#39;-std=c++17&amp;#39;&amp;#34;, //使用c++17标准编译&amp;#34;&amp;#39;${file}&amp;#39;&amp;#34;, //当前文件名&amp;#34;-o&amp;#34;, //对象名，不进行编译优化&amp;#34;&amp;#39;${fileBasenameNoExtension}.</description>
    </item>
  </channel>
</rss>
