<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Efficiency on PaperMod</title>
    <link>http://localhost:8888/tags/efficiency/</link>
    <description>Recent content in Efficiency on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 19 Sep 2023 19:51:18 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/tags/efficiency/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ocrmypdf 让 PDF 可搜索</title>
      <link>http://localhost:8888/posts/ocrmypdf-%E8%AE%A9pdf%E5%8F%AF%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Tue, 19 Sep 2023 19:51:18 +0000</pubDate>
      <guid>http://localhost:8888/posts/ocrmypdf-%E8%AE%A9pdf%E5%8F%AF%E6%90%9C%E7%B4%A2/</guid>
      <description>买的一些课程配套资料都是 PDF 格式的，为了防止盗版都事先用的图片转成的 PDF，这样 PDF 里的内容既没法复制也没法搜索，在查找资料里的关键词的时候就很不方便，所以就想着把这些 PDF 转成可搜索的 PDF。找到了一款工具叫做 ocrmypdf，可以把 PDF 转成可搜索的 PDF，而且还支持中文，这里记录一下使用方法。详细使用文档可以参考官方文档 OCRmyPDF documentation。
安装 sudo apt install ocrmypdf 使用 指定 OCR 的语言 安装语言包
sudo apt install tesseract-ocr-chi-sim 查看是否安装成功
$ tesseract --list-langs List of available languages (3): chi_sim eng osd 注意参数 -l 后面的语言包名称是下划线，而不是短横线。
ocrmypdf -l chi_sim input.pdf output.pdf $ ocrmypdf -l chi_sim --redo-ocr input.pdf output.pdf Scanning contents: 100%|██████████████████████████████████████████████████████████████████████████████████████████████████████| 752/752 [00:14&amp;lt;00:00, 51.36page/s] Start processing 24 pages concurrently 33 redoing OCR 26 [tesseract] lots of diacritics - possibly poor OCR 54 [tesseract] lots of diacritics - possibly poor OCR 88 [tesseract] lots of diacritics - possibly poor OCR 119 [tesseract] lots of diacritics - possibly poor OCR 203 [tesseract] lots of diacritics - possibly poor OCR 256 [tesseract] lots of diacritics - possibly poor OCR 265 [tesseract] lots of diacritics - possibly poor OCR 347 [tesseract] lots of diacritics - possibly poor OCR 376 [tesseract] lots of diacritics - possibly poor OCR 383 [tesseract] lots of diacritics - possibly poor OCR 386 [tesseract] lots of diacritics - possibly poor OCR 402 [tesseract] lots of diacritics - possibly poor OCR 404 [tesseract] lots of diacritics - possibly poor OCR 403 [tesseract] lots of diacritics - possibly poor OCR 412 [tesseract] lots of diacritics - possibly poor OCR 415 [tesseract] lots of diacritics - possibly poor OCR 410 [tesseract] lots of diacritics - possibly poor OCR 439 [tesseract] lots of diacritics - possibly poor OCR 519 [tesseract] lots of diacritics - possibly poor OCR 526 [tesseract] lots of diacritics - possibly poor OCR 587 [tesseract] lots of diacritics - possibly poor OCR 591 [tesseract] lots of diacritics - possibly poor OCR 595 [tesseract] lots of diacritics - possibly poor OCR 607 [tesseract] lots of diacritics - possibly poor OCR 644 [tesseract] lots of diacritics - possibly poor OCR 661 [tesseract] lots of diacritics - possibly poor OCR 682 [tesseract] lots of diacritics - possibly poor OCR 720 [tesseract] lots of diacritics - possibly poor OCR 742 [tesseract] lots of diacritics - possibly poor OCR OCR: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 752.</description>
    </item>
    <item>
      <title>如何离线安装 VSCode 插件</title>
      <link>http://localhost:8888/posts/%E5%A6%82%E4%BD%95%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85vscode%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Tue, 29 Aug 2023 20:59:19 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E5%A6%82%E4%BD%95%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85vscode%E6%8F%92%E4%BB%B6/</guid>
      <description>背景简介 在使用 VSCode 的过程中，我们经常会安装一些插件来提高开发效率。但是，由于某些原因，我们可能无法直接访问 VSCode 的插件市场，这时候我们就需要离线安装插件了。
这里存在两种情况，一种是为本地的 VSCode 安装插件，另一种是为远程的 VSCode 安装插件。本文将分别介绍这两种情况下的离线安装方法。
远程 VSCode 也就是 VSCode 的Remote Development功能，可以通过 SSH、Docker、WSL 等方式远程连接到远程主机上的 VSCode。
方法一：使用已安装的插件目录 从已经安装插件的电脑上拷贝所有插件，路径一般为 C:\用户\用户名\.vscode\extensions 拷贝到离线安装的电脑上的 .vscode/extensions 文件夹下即可，重启 VScode 即可安装成功。 对于远程 VSCode 我们需要知道，插件不区分操作系统，所以我们可以在本地的 Windows 上的 VSCode 上安装插件，然后将插件目录压缩后整个拷贝到远程主机上即可。
远程主机上的插件目录一般在 ~/.vscode-server/extensions 下。将压缩的文件解药到这个目录下，重启 VSCode 即可。
方法二：下载离线安装包 vslx 安装 到 VScode 插件中心 搜索需要使用的插件名称
下载对应的拓展程序文件，下载的文件的后缀是.vslx VSCode 中安装 </description>
    </item>
    <item>
      <title>如何使用 GitHub Actions</title>
      <link>http://localhost:8888/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github-actions/</link>
      <pubDate>Fri, 14 Oct 2022 22:08:54 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github-actions/</guid>
      <description>简介 GitHub Actions 是 GitHub 在 2018 年推出的持续集成服务。它可以自动完成一些开发周期内的任务，如 Push 代码时自动编译，Pull 代码时自动执行测试脚本等等。
我了解 GitHub Actions 的契机是，我在 GitHub 上保存了一些 Markdown 文档，我希望每次更新文档后自动使用 Pandoc 转换成 PDF 文档。接下来我们一起学习如何通过 GitHub Actions 实现这样的需求。
首先我们先直观的了解一下它在 GitHub 的位置，如果打开一个仓库，它有图中绿色对号√，或者红色叉号×，说明这个项目配置了 GitHub Actions，绿色表示自动化的流程运行成功了，红色表示失败了。
我们点开Actions按钮就可以查看具体的任务详情。下面我们先学习如何配置一个简单的 GitHub Actions。
配置 GitHub Actions GitHub Actions 可以简单理解为一些自动化脚本，工具，目的就是为了减少重复工作，所以这些工具都可以做成普适性的工具。而 GitHub 官方就开放了一个这类工具的市场，我们可以在上面搜索自己想要的工具。因为初学 GitHub Actions 所以也不知道怎么写配置文件，我们可以直接搜索一个并应用它，看看别人是怎么写的。
我们进入一个自己的仓库，点击Actions，搜索框中搜索PDF，在搜索结果中找到Create PDF · Actions这个工具。如果搜索到点击Configure。如果显示未找到，则点击set up a workflow yourself，同样搜索PDF。
打开详情页面，拉到底，将Example usage。里的内容复制到编辑框中。点击右上角Start commit将会把我们新建的main.yml提交到仓库中。这就相当于创建了一个生成 PDF 的 GitHub Actions。当然每个 Actions 都有一些使用要求，比如这里还要根据介绍，创建几个文件夹，比如从哪个文件夹获取源文件，生成后的 PDF 又会放到哪个文件夹等。这里就不再介绍，我们先了解如何创建一个 Actions。
Workflow 配置 GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.</description>
    </item>
    <item>
      <title>Markdown 表格竖线自动对齐</title>
      <link>http://localhost:8888/posts/markdown%E8%A1%A8%E6%A0%BC%E7%AB%96%E7%BA%BF%E8%87%AA%E5%8A%A8%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Sat, 24 Sep 2022 15:01:41 +0000</pubDate>
      <guid>http://localhost:8888/posts/markdown%E8%A1%A8%E6%A0%BC%E7%AB%96%E7%BA%BF%E8%87%AA%E5%8A%A8%E5%AF%B9%E9%BD%90/</guid>
      <description>需求背景 Markdown 中的表格，只要符合语法就能够正常渲染显示，但是符合语法但是 Markdown 源码却不一定易读。就如以下的这个表格，可以正常显示，但是源码在源文件中竖线不对齐，就阅读困难。
源码：
|诗名|作者|朝代| |-|-|-| |白头吟|卓文君|两汉| |锦瑟|李商隐|唐代| |登科后|孟郊|唐代| 显示效果：
诗名 作者 朝代 白头吟 卓文君 两汉 锦瑟 李商隐 唐代 登科后 孟郊 唐代 我们可以手动将其竖线对齐，如下这样就易读许多：
| 诗名 | 作者 | 朝代 | | ------ | ------ | ---- | | 白头吟 | 卓文君 | 两汉 | | 锦瑟 | 李商隐 | 唐代 | | 登科后 | 孟郊 | 唐代 | 显示效果保持一致。但是如果一个字符一个字符去手动对齐效率太低，也不符合 Markdown 设计初衷。这就用到了额外的插件，能够辅助我们完成这个工作。
Markdown All in One VSCode 插件中心搜索Markdown All in One安装。</description>
    </item>
    <item>
      <title>使用 Markdownlint 对 Markdown 文本格式检查</title>
      <link>http://localhost:8888/posts/%E4%BD%BF%E7%94%A8markdownlint%E5%AF%B9markdown%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5/</link>
      <pubDate>Sat, 17 Sep 2022 11:07:10 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E4%BD%BF%E7%94%A8markdownlint%E5%AF%B9markdown%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5/</guid>
      <description>Markdownlint 简介 Markdown 标记语言旨在易于阅读、编写和理解。它的灵活性既是优点也是缺点。语法众多，因此格式可能不一致。某些构造在所有解析器中都不能很好地工作，应该避免。CommonMark 规范标准化解析器。
Markdownlint 是一个用于 Node.js 的静态分析工具，有一个标准规范，用于强制执行 Markdown 文件的标准和一致性。
Markdownlint 插件使用 markdownlint提供了多种使用场景下的解决方案，如命令行，编辑器甚至 GitHub Action。因为我平时写 Markdown 文档都是使用 VSCode，所以介绍一下 VSCode 下的使用。其他编辑器包括 VIM，Sublime 也都支持，可以前往官网查阅方法。
VSCode 需要下载插件，Ctrl+Shift+X打开插件中心，搜索Markdownlint安装即可。
安装插件后打开 Markdown 文档，如果有不符合规范的语法将会警告标识。如，标题前后没有空行，将会标识：
提示违反了第 22 条规范，第 22 条规范的就是标题前后需要有空行隔开。
目前有 53 条规范，可以在markdownlint/Rules.md查看所有规范的内容。
当然这些规范也都可以自定义是否检查，比如第 24 条规定，文档内不可以有重复的标题，但是我就有重复标题的需求，那该如何关闭这个检查呢，Markdownlint 提供了配置的方式。
Ctrl+Shift+P打开运行窗口，输入 Markdownlint，找到Creat or open the markdownlint configuration file。
创建一个配置文件，并输入以下内容，表示关闭第 24 条规范的检查：
{ &amp;#34;MD024&amp;#34;: false, } 这样文档中将不会有第 24 条规范的检查警告，其他检查同理。
Markdownlint 自定义规则 MD001 - Heading levels should only increment by one level at a time 标题等级一次只能增加一级，不能跨级。</description>
    </item>
    <item>
      <title>VSCode 字体快速切换</title>
      <link>http://localhost:8888/posts/vscode%E5%AD%97%E4%BD%93%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2/</link>
      <pubDate>Mon, 12 Sep 2022 15:05:16 +0000</pubDate>
      <guid>http://localhost:8888/posts/vscode%E5%AD%97%E4%BD%93%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2/</guid>
      <description>需求背景 在写 MD 文档时为了追求美观，表格通常都是对齐的，这就需要字体必须等宽，但是写代码时等宽字体的因为很瘦小，不容易阅读，所以想要一个插件能够在多个字体直接快速切换。万能 VSCode 啥都有，插件中心就有一款专门切换字体的插件Font Switcher。直接搜索安装。
配置与使用 打开配置脚本settings.json，如果以前修改过字体，找到&amp;quot;editor.fontFamily&amp;quot;配置项，如果没有就直接添加。
这是我的字体，添加你们机器上安装的字体，每个逗号间隔都是不同的字体，可以使用Font Switcher切换，需要注意的是，字体名没有空格不需要加单引号，加了也无妨，如果有空格，一定要加引号。
&amp;#34;editor.fontFamily&amp;#34;: &amp;#34;&amp;#39;Sarasa Mono SC&amp;#39;, 微软雅黑，&amp;#39;Noto Sans Mono CJK SC&amp;#39;, &amp;#39;JetBrains Mono&amp;#39;, Consolas, monospace&amp;#34;, Ctrl+Shift+P打开运行窗口，输入Switch Font，选择切换的字体。如图：
![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/15-17-44-dd742307432154f630585e05a1f57956-GIF 2022-9-12 15-17-27-836285.gif)</description>
    </item>
    <item>
      <title>保持 SSH 连接</title>
      <link>http://localhost:8888/posts/%E4%BF%9D%E6%8C%81ssh%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Sat, 13 Aug 2022 20:28:57 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E4%BF%9D%E6%8C%81ssh%E8%BF%9E%E6%8E%A5/</guid>
      <description>SSH 总是被强行中断，尤其是用 VSCode 代码写的好好的，突然刷新窗口，不仅效率低，更惹人恼火。
可以通过配置服务端或客户端的 SSH 来保持 SSH 链接：
方法一：配置服务端 可以在服务端配置，让 server 每隔 30 秒向 client 发送一个 keep-alive 包来保持连接：
vim /etc/ssh/sshd_config ClientAliveInterval 30 ClientAliveCountMax 60 第二行配置表示如果发送 keep-alive 包数量达到 60 次，客户端依然没有反应，则服务端 sshd 断开连接。如果什么都不操作，该配置可以让连接保持 30s*60，30 min
重启本地 ssh
sudo service ssh restart 如果找不到 ssh,”Failed to restart ssh.service: Unit ssh.service not found.” ，需要安装
sudo apt-get install openssh-server 方法二：配置客户端 如果服务端没有权限配置，或者无法配置，可以配置客户端 ssh，使客户端发起的所有会话都保持连接：
vim /etc/ssh/ssh_config ServerAliveInterval 30 ServerAliveCountMax 60 本地 ssh 每隔 30s 向 server 端 sshd 发送 keep-alive 包，如果发送 60 次，server 无回应断开连接。</description>
    </item>
    <item>
      <title>使用 Syncthing 多端丝滑同步与备份</title>
      <link>http://localhost:8888/posts/%E4%BD%BF%E7%94%A8syncthing%E5%A4%9A%E7%AB%AF%E4%B8%9D%E6%BB%91%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A4%87%E4%BB%BD/</link>
      <pubDate>Mon, 01 Aug 2022 22:48:21 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E4%BD%BF%E7%94%A8syncthing%E5%A4%9A%E7%AB%AF%E4%B8%9D%E6%BB%91%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A4%87%E4%BB%BD/</guid>
      <description>折腾背景 一直想找一个能够快速同步手机与电脑数据的工具，因为手机云服务的空间少的可怜，所以习惯隔一段时间将手机里的照片、视频还有一些文件导出到电脑上。但是每次备份文件都得连接数据线，并且没法增量备份，得手动挑选，也还挺麻烦的。
逛 GitHub 时，无意间发现了 Syncthing，几乎符合了我所有的预期。
开源，免费，自己电脑就可以当服务器，以后入了 NAS，可以自己搭建本地服务器。 同步速度快，取决 WIFI 的速度，目前使用 30M/s，基本满速。 多端支持，除了 IOS（反正我也没有 iOS 设备，嘿嘿），几乎全平台支持，包括 NAS 及路由器。 增量同步，再也不用挑文件备份了。 话不多说，开整。
下载安装 直接进入Syncthing官网，下载安装。在 Ubuntu 下安装参考这里。Android 版本下载Syncthing。
接下来以 Windows 与 Android 手机同步为例，下载安装后，打开syncthing.exe，即可打开管理界面，或者浏览器输入http://127.0.0.1:8384也可进入管理界面。
Windows 界面：
Android 界面： 设备配对 Windows 管理页面-&amp;gt;操作-&amp;gt;显示 ID，会显示本机的二维码：
Android 手机打开应用，切换到设备界面，点击右上角加号，点击二维码标识，即可扫描二维码，完成设备添加。
如果正确添加，Windows 管理界面会显示 Android 设备：
Android 同步至 Windows 打开 Android 应用，切换到文件夹界面，点击右上角加号，配置同步的文件夹： 根据下图提示，配置应用，记得保存： 目录列表显示刚刚的配置： 点击打开，开启与远程设备 Windows 同步：
当返回时，Windows 端将会弹出通知，提示有 Android 设备的文件要分享到电脑，点击添加： 至此，Android 同步至 Windows 完成。此时在 Android 设备的文件夹中添加任意文件，都会同步到 Windows。
如果是局域网内，发现设备的速度很慢，可以尝试设置静态的 IP。手机端 -&amp;gt; 设备 -&amp;gt; 链接图标。默认为 dynamic，将其改为 Windows 的 IP 和 syncthing 的端口。如tcp://192.</description>
    </item>
    <item>
      <title>Gerrit 批量添加抄送提醒</title>
      <link>http://localhost:8888/posts/gerrit%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%8A%84%E9%80%81%E6%8F%90%E9%86%92/</link>
      <pubDate>Fri, 29 Jul 2022 13:58:27 +0000</pubDate>
      <guid>http://localhost:8888/posts/gerrit%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%8A%84%E9%80%81%E6%8F%90%E9%86%92/</guid>
      <description>背景 公司使用 Gerrit 作为 Review 平台，但是每次提交代码都需要手动添加 Reviewer，还要抄送组内成员，这种重复性劳动，程序员是绝不能容忍的。gerrit 提供了发送邮件的功能。
解决方法 官方示例：
git push ssh://john.doe@git.example.com:29418/kernel/common HEAD:refs/for/experimental%r=a@a.com,cc=b@o.com 最后的%是个分隔符，r=&#39;a@a.com表示 Reviewer 是a@a.com，cc=b@o.com表示抄送组内成员是b@o.com。
注意！邮箱之间不能有空格！
以一个仓库为例：
git push origin HEAD:refs/for/branch_dev_name%cc=zhangsan@qq.com,cc=lisi@qq.com,cc=wangerma@qq.com,cc=chenwu@qq.com 但是要这么写，岂不是把操作搞更复杂了。
终极办法，打开项目路径下的.git目录。编辑config文件：
原文件里有如下字段：
[core]repositoryformatversion = 0filemode = falsebare = falselogallrefupdates = trueignorecase = true[remote &amp;#34;origin&amp;#34;]url = git@github.com:Dunky-Z/Dunky-Z.github.io.gitfetch = +refs/heads/*:refs/remotes/origin/* 我们可以将远程仓库名换成容易区分的名字，自己随意：
[core]repositoryformatversion = 0filemode = falsebare = falselogallrefupdates = trueignorecase = true[remote &amp;#34;origin&amp;#34;]url = git@github.</description>
    </item>
    <item>
      <title>密码管理器-KeePass</title>
      <link>http://localhost:8888/posts/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8-keepass/</link>
      <pubDate>Sat, 09 Jul 2022 19:11:40 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8-keepass/</guid>
      <description>KeePass 安装 下载与安装
官网： https://keepass.info/download.html
下载完成后进行安装，默认安装位置是：C:\Program Files (x86)\KeePass Password Safe 2文件夹下，可以根据自己需要选择安装路径。
更改中文语言
中文语言包： KeePass-Chinese_Simplified
将语言包下载后复制到安装路径下的Languages文件夹下，默认为：C:\Program Files (x86)\KeePass Password Safe 2\Languages。重启软件。
点击 View-&amp;gt;Change Language. 选择中文简体（Chinese-Simplified）。重启软件，即可完成语言更改。
中文界面：
基本使用 1.创建一个数据库
点击 文件-》新建。弹出对话框为数据库创建管理密码。这个密码是唯一需要记忆的密码。当然如果追求更高的安全性，可以点击显示高级选项，提供更多的密码选项。
2.添加记录
点击添加记录，在弹出的窗口填入相关信息。即可完成密码添加。
如果是第一次使用的网站，第一次注册密码。可以通过密码生成器，生成一个高强度的密码来添加记录。
3.创建一个密码生成模板
正常国内的网站可以使用的密码长度 6-16 位，可以使用大小写，数字，下划线。我们把这些选项勾选，密码长度设置 16 位。
点击保存并给模板设置个名字方便下次使用
如果保存后想更改一下，比如再加个可以使用空格，可以重新勾选刚刚的选项，保存时点击小三角，选择刚刚保存的方案就可以覆盖。
导入 Chrome 已保存的密码
很多小伙伴在使用 KeePass 之前肯定在 Chrome 等浏览器里也保存了很多密码。想将其导入 KeePass 方便管理。Chrome 是可以导出密码的，KeePass 也可以导入密码。
点击浏览器右上角，打开设置界面。找到密码
找到已保存的密码-》导出密码。选择方便找到的路径，保存密码记录。
打开 KeePass，点击文件-》导入，选择 Chrome 浏览器的格式。点击文件夹图标找到刚刚导出的密码文件。
高级配置 KeePass 搭配坚果云实现云同步 登录坚果云创建个人同步文件夹，若没有先注册。
最好单独建一个专门的文件夹
将已经生成的数据库上传到这个文件夹下
点击右上角进入账户信息，点击安全选项：
点击添加应用
输入应用名称，应用名称只是方便区分作用，所以和要同步的应用名称一致就好：
点击生成密码：
此时云盘端配置完成，切回到 KeePass 进行客户端配置。点击文件-》同步-》与网址（URL）同步</description>
    </item>
  </channel>
</rss>
