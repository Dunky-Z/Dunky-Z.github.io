<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>加密算法 on 夜云泊</title>
    <link>https://lifeislife.cn/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</link>
    <description>feedId:57980998056508425+userId:73222296380546048 Recent content in 加密算法 on 夜云泊</description>
    <generator>Hugo -- 0.152.0</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 10 Oct 2022 13:44:32 +0000</lastBuildDate>
    <atom:link href="https://lifeislife.cn/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>加密算法总结</title>
      <link>https://lifeislife.cn/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 10 Oct 2022 13:44:32 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h1 id=&#34;基本概念&#34;&gt;基本概念&lt;/h1&gt;
&lt;h2 id=&#34;明文与密文&#34;&gt;明文与密文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Plaintext，明文，未经加密的消息，任何人都可以读&lt;/li&gt;
&lt;li&gt;Ciphertext，密文，加密后的消息，不可读&lt;/li&gt;
&lt;li&gt;Key，密钥，用于加密和解密（核心是算法）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;加密与解密概念&#34;&gt;加密与解密概念&lt;/h2&gt;
&lt;h3 id=&#34;加密&#34;&gt;加密&lt;/h3&gt;
&lt;p&gt;数据加密 的基本过程，就是对原来为 明文 的文件或数据按 某种算法 进行处理，使其成为 不可读 的一段代码，通常称为“密文”。通过这样的途径，来达到 保护数据 不被 非法人窃取、阅读的目的。&lt;/p&gt;
&lt;h3 id=&#34;解密&#34;&gt;解密&lt;/h3&gt;
&lt;p&gt;加密 的 逆过程 为 解密，即将该 编码信息 转化为其 原来数据 的过程。&lt;/p&gt;
&lt;h2 id=&#34;对称加密和非对称加密&#34;&gt;对称加密和非对称加密&lt;/h2&gt;
&lt;p&gt;加密算法分 &lt;strong&gt;对称加密&lt;/strong&gt; 和 &lt;strong&gt;非对称加密&lt;/strong&gt;，其中对称加密算法的加密与解密 &lt;strong&gt;密钥相同&lt;/strong&gt;，非对称加密算法的加密密钥与解密 &lt;strong&gt;密钥不同&lt;/strong&gt;，此外，还有一类 &lt;strong&gt;不需要密钥&lt;/strong&gt; 的 &lt;strong&gt;散列算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;title&gt;Responsive Image&lt;/title&gt;
    &lt;style&gt;
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    
    &lt;div class=&#34;post-img-view&#34;&gt;
        &lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-00-40-c536814468b9400500824199c2105b28-20221010140039-a6b9ec.png&#34;&gt;
            &lt;img class=&#34;responsive-image&#34; src=&#34;https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-00-40-c536814468b9400500824199c2105b28-20221010140039-a6b9ec.png&#34; alt=&#34;&#34;  style=&#34;margin: 0 auto;&#34;/&gt;
        &lt;/a&gt;
    &lt;/div&gt;
    

    &lt;script&gt;
        document.addEventListener(&#34;DOMContentLoaded&#34;, function() {
            var images = document.querySelectorAll(&#34;.responsive-image&#34;);
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + &#34;px&#34;;
            });
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;title&gt;Responsive Image&lt;/title&gt;
    &lt;style&gt;
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    
    &lt;div class=&#34;post-img-view&#34;&gt;
        &lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-10-59-06393c9fde719e436d8f09dc143e5d73-20221010141058-d38144.png&#34;&gt;
            &lt;img class=&#34;responsive-image&#34; src=&#34;https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-10-59-06393c9fde719e436d8f09dc143e5d73-20221010141058-d38144.png&#34; alt=&#34;&#34;  style=&#34;margin: 0 auto;&#34;/&gt;
        &lt;/a&gt;
    &lt;/div&gt;
    

    &lt;script&gt;
        document.addEventListener(&#34;DOMContentLoaded&#34;, function() {
            var images = document.querySelectorAll(&#34;.responsive-image&#34;);
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + &#34;px&#34;;
            });
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;
&lt;h3 id=&#34;对称加密&#34;&gt;对称加密&lt;/h3&gt;
&lt;p&gt;对称加密算法 是应用较早的加密算法，又称为 &lt;strong&gt;共享密钥加密算法&lt;/strong&gt;。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据加密过程：在对称加密算法中，数据发送方 将 明文 (原始数据) 和 加密密钥 一起经过特殊 加密处理，生成复杂的 加密密文 进行发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据解密过程：数据接收方 收到密文后，若想读取原数据，则需要使用 加密使用的密钥 及相同算法的 逆算法 对加密的密文进行解密，才能使其恢复成 可读明文。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非对称加密&#34;&gt;非对称加密&lt;/h3&gt;
&lt;p&gt;非对称加密算法，又称为 &lt;strong&gt;公开密钥加密算法&lt;/strong&gt;。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。
因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果使用 公钥 对数据 进行加密，只有用对应的 私钥 才能 进行解密。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用 私钥 对数据 进行加密，只有用对应的 公钥 才能 进行解密。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数字签名&#34;&gt;数字签名&lt;/h2&gt;
&lt;p&gt;数字签名，顾名思义，就是用来证明自己身份的一种方式。在使用非对称加密算法通信时，&lt;strong&gt;如何验证发送者是真实的发送者，发送的信息没有篡改&lt;/strong&gt;，就需要数字签名。一套 数字签名 通常定义两种 互补 的运算，一个用于 签名，另一个用于 验证。分别由 发送者 持有能够 代表自己身份 的 私钥（私钥不可泄露），由 接受者 持有与私钥对应的 公钥，能够在 接受 到来自发送者信息时用于 验证 其身份。&lt;/p&gt;
&lt;h1 id=&#34;加密算法详解&#34;&gt;加密算法详解&lt;/h1&gt;
&lt;p&gt;通过以上简介可以了解到，加密算法分为需要秘钥的和不需要秘钥的，需要秘钥的有可以分为对称加密与非对称加密两大类。接来来我们就详细探究一下各个加密算法。&lt;/p&gt;
&lt;h2 id=&#34;哈希算法不可逆&#34;&gt;哈希算法（不可逆）&lt;/h2&gt;
&lt;p&gt;哈希算法可以将任意长度的输入数据，生成固定长度的输出（哈希值）。&lt;/p&gt;
&lt;p&gt;常见的哈希算法有如下：&lt;/p&gt;
&lt;p&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;title&gt;Responsive Image&lt;/title&gt;
    &lt;style&gt;
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    
    &lt;div class=&#34;post-img-view&#34;&gt;
        &lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-40-43-24c6e7e9577cf8f77efcc6c418aad103-20221010144042-761be3.png&#34;&gt;
            &lt;img class=&#34;responsive-image&#34; src=&#34;https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-40-43-24c6e7e9577cf8f77efcc6c418aad103-20221010144042-761be3.png&#34; alt=&#34;&#34;  style=&#34;margin: 0 auto;&#34;/&gt;
        &lt;/a&gt;
    &lt;/div&gt;
    

    &lt;script&gt;
        document.addEventListener(&#34;DOMContentLoaded&#34;, function() {
            var images = document.querySelectorAll(&#34;.responsive-image&#34;);
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + &#34;px&#34;;
            });
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;目前比较常用的是 MD5 和 SHA 系列（比如比特币用的 SHA256 算法，Git 中的 commit hash 用的 SHA1）。&lt;/p&gt;
&lt;h3 id=&#34;md5&#34;&gt;MD5&lt;/h3&gt;
&lt;p&gt;MD5（Message-Digest）典型应用是对一段信息产生 &lt;strong&gt;信息摘要&lt;/strong&gt;，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 &lt;strong&gt;摘要算法&lt;/strong&gt;。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。&lt;/p&gt;
&lt;h3 id=&#34;sha1&#34;&gt;SHA1&lt;/h3&gt;
&lt;p&gt;SHA1(Secure Hash Algorithm) 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 $2 ^{64}$ 位的消息，SHA1 会产生一个 160 位的 消息摘要。&lt;/p&gt;
&lt;h2 id=&#34;对称加密可逆&#34;&gt;对称加密（可逆）&lt;/h2&gt;
&lt;p&gt;对称加密算法是应用比较早的算法，在数据加密和解密的时用的都是同一个密钥，这就造成了密钥管理困难的问题。常见的对称加密算法有 DES、3DES、AES128、AES192、AES256。&lt;/p&gt;
&lt;h3 id=&#34;a51a52及rc4&#34;&gt;A5/1、A5/2及RC4&lt;/h3&gt;
&lt;p&gt;A5/1、A5/2及RC4他们都属于对称加密算法，并都属于流加密。先了解什么是流加密。&lt;/p&gt;
&lt;p&gt;在密码学中，&lt;strong&gt;流加密&lt;/strong&gt;（英语：Stream cipher），是一种对称加密算法，加密和解密双方使用相同伪随机加密数据流（pseudo-random stream）作为密钥，明文数据每次与密钥数据流顺次对应加密，得到密文数据流。实践中通常&lt;strong&gt;把信息中的每一位跟密钥流的每一位进行异或 (xor) 运算来获得密文&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;des&#34;&gt;DES&lt;/h3&gt;
&lt;p&gt;DES(Data Encryption Standard) 是对称加密算法领域中的典型算法，是一种&lt;strong&gt;块加密算法&lt;/strong&gt;(Block cipher)，其密钥默认长度为 56 位。块加密或者叫分组加密，这种加密方法是把明文分成几个固定大小的 block 块，然后分别对其进行加密。&lt;/p&gt;
&lt;p&gt;DES 加密算法是对 &lt;strong&gt;密钥进行保密&lt;/strong&gt;，而 &lt;strong&gt;公开算法&lt;/strong&gt;，包括加密和解密算法。这样，只有掌握了和发送方 相同密钥 的人才能解读由 DES 加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是 &lt;strong&gt;搜索密钥的编码&lt;/strong&gt;。对于 56 位长度的 密钥 来说，如果用 穷举法 来进行搜索的话，其运算次数为 $2 ^{56}$ 次。&lt;/p&gt;
&lt;h3 id=&#34;aes&#34;&gt;AES&lt;/h3&gt;
&lt;p&gt;AES 是美国国家标准技术研究所 NIST 旨在取代 DES 的 21 世纪的加密标准。AES 是块加密算法，也就是说，每次处理的数据是一块（16 字节），当数据不是 16 字节的倍数时填充，这就是所谓的&lt;strong&gt;分组密码&lt;/strong&gt;（区别于基于比特位的流密码），16 字节是分组长度。AES 共有 ECB、CBC 等多种模式。&lt;/p&gt;
&lt;h3 id=&#34;sm4&#34;&gt;SM4&lt;/h3&gt;
&lt;p&gt;SM4 算法于 2012 年被国家密码管理局确定为国家密码行业标准，最初主要用于 WAPI (WLAN Authentication and Privacy Infrastructure) 无线网络中。SM4 算法的出现为将我国商用产品上的密码算法由国际标准替换为国家标准提供了强有力的支撑。随后，SM4 算法被广泛应用于政府办公、公安、银行、税务、电力等信息系统中，其在我国密码行业中占据着极其重要的位置。类似于 DES、AES 算法，SM4 算法也是一种分组密码算法。&lt;/p&gt;
&lt;h2 id=&#34;非对称加密可逆&#34;&gt;非对称加密（可逆）&lt;/h2&gt;
&lt;p&gt;学习非对称加密之前，我们得了解如何进行安全高效地秘钥交换。我们不可能说通信双方在通信之前，先见个面协商一下秘钥 key，这样非常不方便，但是又不能直接把 key 秘钥通过一个不安全的信道发出去，这样就会被攻击者截获。&lt;/p&gt;
&lt;p&gt;所以我们需要有一种方法，&lt;strong&gt;可以让双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥&lt;/strong&gt;。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容，这就是秘钥交换的概念（key exchange）。&lt;/p&gt;
&lt;h3 id=&#34;diffiehellman-key-exchange&#34;&gt;Diffie–Hellman key exchange&lt;/h3&gt;
&lt;p&gt;迪菲-赫尔曼密钥交换（英语：Diffie–Hellman key exchange，缩写为 D-H）是一种安全协议。可以完成上述秘钥交换。&lt;/p&gt;
&lt;p&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;title&gt;Responsive Image&lt;/title&gt;
    &lt;style&gt;
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    
    &lt;div class=&#34;post-img-view&#34;&gt;
        &lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/16-12-34-6c10e628d0058564969403b4f278deee-20221010161233-308a13.png&#34;&gt;
            &lt;img class=&#34;responsive-image&#34; src=&#34;https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/16-12-34-6c10e628d0058564969403b4f278deee-20221010161233-308a13.png&#34; alt=&#34;&#34;  style=&#34;margin: 0 auto;&#34;/&gt;
        &lt;/a&gt;
    &lt;/div&gt;
    

    &lt;script&gt;
        document.addEventListener(&#34;DOMContentLoaded&#34;, function() {
            var images = document.querySelectorAll(&#34;.responsive-image&#34;);
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + &#34;px&#34;;
            });
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通信双方 Alice 和 Bob 个准备一个大的质数，Alice 准备的质数是&lt;code&gt;n=11&lt;/code&gt;, Bob 准备的质数是&lt;code&gt;g=7&lt;/code&gt;，&lt;code&gt;n&lt;/code&gt;和&lt;code&gt;g&lt;/code&gt;是公开的，任何第三方都可以获取到这个信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Alice 准备一个随机自然数&lt;code&gt;x=3&lt;/code&gt;, 除了 Alice 没有人知道&lt;code&gt;x&lt;/code&gt;是多少，Alice 通过计算&lt;code&gt;g&lt;/code&gt;的&lt;code&gt;x&lt;/code&gt;次方并且对 &lt;code&gt;n&lt;/code&gt; 取模，得到结果大 &lt;code&gt;A&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Alice 把计算得到的结果 &lt;code&gt;A=2&lt;/code&gt; 发送给 Bob，这个信息是公开的，任何人可以获取到 &lt;code&gt;A&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bob 同样准备一个随机自然数 &lt;code&gt;y=6&lt;/code&gt;，除了 Bob 没有人知道 &lt;code&gt;y&lt;/code&gt; 是多少，Bob 通过计算 &lt;code&gt;g&lt;/code&gt; 的 &lt;code&gt;y&lt;/code&gt; 次方并且对 &lt;code&gt;n&lt;/code&gt; 取模，得到结果大 &lt;code&gt;B&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bob 把计算结果 &lt;code&gt;B=4&lt;/code&gt;，发送给 Alice，，这个信息是公开的，任何人可以获取到 &lt;code&gt;B&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Alice 拿到 &lt;code&gt;B&lt;/code&gt; 以后，对 &lt;code&gt;B&lt;/code&gt; 求 &lt;code&gt;x&lt;/code&gt; 次方并对 &lt;code&gt;n&lt;/code&gt; 取模，得到 &lt;code&gt;K1=9&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bob 拿到 &lt;code&gt;A&lt;/code&gt; 以后，对 &lt;code&gt;A&lt;/code&gt; 对 &lt;code&gt;y&lt;/code&gt; 次方并对 &lt;code&gt;n&lt;/code&gt; 取模，得到 &lt;code&gt;K2=9&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;K1 == K2&lt;/code&gt;，Alice 和 Bob 可以使用 &lt;code&gt;K1&lt;/code&gt;，&lt;code&gt;K2&lt;/code&gt; 作为 Key 进行通信加密。&lt;/p&gt;
&lt;p&gt;在整个通信过程中，攻击者是无法知道 &lt;code&gt;x&lt;/code&gt;，&lt;code&gt;y&lt;/code&gt; 以及 &lt;code&gt;K1&lt;/code&gt;，&lt;code&gt;K2&lt;/code&gt; 的，或者说计算的困难很大，感兴趣的同学可以在网上找到具体的数学问题，离散对数问题的求解。&lt;/p&gt;
&lt;h3 id=&#34;rsa&#34;&gt;RSA&lt;/h3&gt;
&lt;p&gt;Diffie–Hellman key exchange 发明后不久出现了 RSA，另一个进行公钥交换的算法。它使用了非对称加密算法。&lt;/p&gt;
&lt;p&gt;RSA 加密算法是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。&lt;/p&gt;
&lt;p&gt;RSA 所用到的数学原理可以参考阮一峰老师的文章&lt;a href=&#34;https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&#34;&gt;RSA 算法原理（一）&lt;/a&gt;，文章介绍了 RSA 用到的一些数学定理，不涉及证明，这对于了解 RSA 也就足够了。&lt;/p&gt;
&lt;p&gt;简单介绍一下秘钥是生成过程（摘自&lt;a href=&#34;https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&#34;&gt;RSA 算法原理（二）&lt;/a&gt;）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;随机选择两个不相等的质数 $p$ 和 $q$。爱丽丝选择了$61$和$53$。（实际应用中，这两个质数越大，就越难破解。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算$p$和$q$的乘积$n$。爱丽丝就把 $61$ 和 $53$ 相乘。
$$n = 61×53 = 3233$$&lt;/p&gt;
&lt;p&gt;$n$ 的长度就是密钥长度。$3233$ 写成二进制是 $110010100001$，一共有 $12$ 位，所以这个密钥就是 $12$ 位。实际应用中，RSA 密钥一般是 $1024$ 位，重要场合则为 $2048$ 位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算 $n$ 的欧拉函数$\varphi(n)$。根据公式：
$$\varphi(n) = (p-1)(q-1)$$&lt;/p&gt;
&lt;p&gt;爱丽丝算出$\varphi(3233)$ 等于 $60×52$，即 $3120$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机选择一个整数 $e$，条件是 $1&amp;lt; e &amp;lt; \varphi(n)$，且 $e$ 与$\varphi(n)$ 互质。
爱丽丝就在 $1$ 到 $3120$ 之间，随机选择了 $17$。（实际应用中，常常选择 $65537$。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算 $e$ 对于$\varphi(n)$ 的模反元素 $d$。&lt;/p&gt;
&lt;p&gt;所谓&amp;quot;模反元素&amp;quot;就是指有一个整数 $d$，可以使得 $ed$ 被$\varphi(n)$ 除的余数为 $1$。&lt;/p&gt;
&lt;p&gt;$$ed ≡ 1 (mod \varphi(n))$$
这个式子等价于&lt;/p&gt;
&lt;p&gt;$$ed - 1 = k\varphi(n)$$&lt;/p&gt;
&lt;p&gt;于是，找到模反元素 $d$，实质上就是对下面这个二元一次方程求解。&lt;/p&gt;
&lt;p&gt;$$ex + \varphi(n)y = 1$$&lt;/p&gt;
&lt;p&gt;已知 $e=17$, $\varphi(n)=3120$，&lt;/p&gt;
&lt;p&gt;$$17x + 3120y = 1$$&lt;/p&gt;
&lt;p&gt;这个方程可以用&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95&#34;&gt;扩展欧几里得算法&lt;/a&gt;求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 $(x,y)=(2753,-15)$，即 $d=2753$。&lt;/p&gt;
&lt;p&gt;至此所有计算完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 $n$ 和 $e$ 封装成公钥，$n$ 和 $d$ 封装成私钥。&lt;/p&gt;
&lt;p&gt;在爱丽丝的例子中，$n=3233$，$e=17$，$d=2753$，所以公钥就是 $(3233,17)$，私钥就是$3233, 2753）$。&lt;/p&gt;
&lt;p&gt;实际应用中，公钥和私钥的数据都采用 &lt;code&gt;ASN.1&lt;/code&gt; 格式表达。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RSA 算法为何是可靠的呢？因为该算法基于一个十分简单的数论事实：&lt;strong&gt;将两个大素数相乘十分容易，但想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;回顾上面的密钥生成步骤，一共出现六个数字：&lt;/p&gt;
&lt;p&gt;$$p,q,n,\varphi(n),e,d$$&lt;/p&gt;
&lt;p&gt;这六个数字之中，公钥用到了两个（$n$和$e$），其余四个数字都是不公开的。其中最关键的是$d$，因为$n$和$d$组成了私钥，一旦$d$泄漏，就等于私钥泄漏。&lt;/p&gt;
&lt;p&gt;那么，有无可能在已知$n$和$e$的情况下，推导出$d$？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ed≡1 (mod φ(n))$。只有知道$e$和$φ(n)$，才能算出$d$。&lt;/li&gt;
&lt;li&gt;$φ(n)=(p-1)(q-1)$。只有知道$p$和$q$，才能算出$φ(n)$。&lt;/li&gt;
&lt;li&gt;$n=pq$。只有将$n$因数分解，才能算出 $p$ 和 $q$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论：如果 $n$ 可以被因数分解，$d$ 就可以算出，也就意味着私钥被破解。&lt;/p&gt;
&lt;p&gt;可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。&lt;/p&gt;
&lt;p&gt;举例来说，你可以对 3233 进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12301866845301177551304949
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;58384962720772853569595334
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;79219732245215172640050726
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;36575187452021997864693899
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;56474942774063845925192557
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;32630345373154826850791702
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;61221429134616704292143116
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;02221240479274737794080665
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;351419597459856902143413
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它等于这样两个质数的乘积：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;33478071698956898786044169
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;84821269081770479498371376
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;85689124313889828837938780
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;02287614711652531743087737
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;814467999489
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;　　×
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;36746043666799590428244633
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;79962795263227915816434308
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;76426760322838157396665112
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;79233373417143396810270092
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;798736308917
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;事实上，这大概是人类已经分解的最大整数（232 个十进制位，768 个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长 RSA 密钥就是 768 位。&lt;/p&gt;
&lt;h1 id=&#34;签名与证书&#34;&gt;签名与证书&lt;/h1&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://learn-cryptography.readthedocs.io/zh/latest/basic/&#34;&gt;Learn Cryptography&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844903638117122056&#34;&gt;浅谈常见的七种加密算法及实现 - 掘金&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&#34;&gt;RSA 算法原理（一） - 阮一峰的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&#34;&gt;RSA 算法原理（二） - 阮一峰的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000023445325&#34;&gt;加密解密 - 面试官：说一下你常用的加密算法_个人文章 - SegmentFault 思否&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      <content:encoded><![CDATA[<h1 id="基本概念">基本概念</h1>
<h2 id="明文与密文">明文与密文</h2>
<ul>
<li>Plaintext，明文，未经加密的消息，任何人都可以读</li>
<li>Ciphertext，密文，加密后的消息，不可读</li>
<li>Key，密钥，用于加密和解密（核心是算法）</li>
</ul>
<h2 id="加密与解密概念">加密与解密概念</h2>
<h3 id="加密">加密</h3>
<p>数据加密 的基本过程，就是对原来为 明文 的文件或数据按 某种算法 进行处理，使其成为 不可读 的一段代码，通常称为“密文”。通过这样的途径，来达到 保护数据 不被 非法人窃取、阅读的目的。</p>
<h3 id="解密">解密</h3>
<p>加密 的 逆过程 为 解密，即将该 编码信息 转化为其 原来数据 的过程。</p>
<h2 id="对称加密和非对称加密">对称加密和非对称加密</h2>
<p>加密算法分 <strong>对称加密</strong> 和 <strong>非对称加密</strong>，其中对称加密算法的加密与解密 <strong>密钥相同</strong>，非对称加密算法的加密密钥与解密 <strong>密钥不同</strong>，此外，还有一类 <strong>不需要密钥</strong> 的 <strong>散列算法</strong>。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-00-40-c536814468b9400500824199c2105b28-20221010140039-a6b9ec.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-00-40-c536814468b9400500824199c2105b28-20221010140039-a6b9ec.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-10-59-06393c9fde719e436d8f09dc143e5d73-20221010141058-d38144.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-10-59-06393c9fde719e436d8f09dc143e5d73-20221010141058-d38144.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<h3 id="对称加密">对称加密</h3>
<p>对称加密算法 是应用较早的加密算法，又称为 <strong>共享密钥加密算法</strong>。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。</p>
<ul>
<li>
<p>数据加密过程：在对称加密算法中，数据发送方 将 明文 (原始数据) 和 加密密钥 一起经过特殊 加密处理，生成复杂的 加密密文 进行发送。</p>
</li>
<li>
<p>数据解密过程：数据接收方 收到密文后，若想读取原数据，则需要使用 加密使用的密钥 及相同算法的 逆算法 对加密的密文进行解密，才能使其恢复成 可读明文。</p>
</li>
</ul>
<h3 id="非对称加密">非对称加密</h3>
<p>非对称加密算法，又称为 <strong>公开密钥加密算法</strong>。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。
因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。</p>
<ul>
<li>
<p>如果使用 公钥 对数据 进行加密，只有用对应的 私钥 才能 进行解密。</p>
</li>
<li>
<p>如果使用 私钥 对数据 进行加密，只有用对应的 公钥 才能 进行解密。</p>
</li>
</ul>
<h2 id="数字签名">数字签名</h2>
<p>数字签名，顾名思义，就是用来证明自己身份的一种方式。在使用非对称加密算法通信时，<strong>如何验证发送者是真实的发送者，发送的信息没有篡改</strong>，就需要数字签名。一套 数字签名 通常定义两种 互补 的运算，一个用于 签名，另一个用于 验证。分别由 发送者 持有能够 代表自己身份 的 私钥（私钥不可泄露），由 接受者 持有与私钥对应的 公钥，能够在 接受 到来自发送者信息时用于 验证 其身份。</p>
<h1 id="加密算法详解">加密算法详解</h1>
<p>通过以上简介可以了解到，加密算法分为需要秘钥的和不需要秘钥的，需要秘钥的有可以分为对称加密与非对称加密两大类。接来来我们就详细探究一下各个加密算法。</p>
<h2 id="哈希算法不可逆">哈希算法（不可逆）</h2>
<p>哈希算法可以将任意长度的输入数据，生成固定长度的输出（哈希值）。</p>
<p>常见的哈希算法有如下：</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-40-43-24c6e7e9577cf8f77efcc6c418aad103-20221010144042-761be3.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-40-43-24c6e7e9577cf8f77efcc6c418aad103-20221010144042-761be3.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p>目前比较常用的是 MD5 和 SHA 系列（比如比特币用的 SHA256 算法，Git 中的 commit hash 用的 SHA1）。</p>
<h3 id="md5">MD5</h3>
<p>MD5（Message-Digest）典型应用是对一段信息产生 <strong>信息摘要</strong>，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 <strong>摘要算法</strong>。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。</p>
<h3 id="sha1">SHA1</h3>
<p>SHA1(Secure Hash Algorithm) 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 $2 ^{64}$ 位的消息，SHA1 会产生一个 160 位的 消息摘要。</p>
<h2 id="对称加密可逆">对称加密（可逆）</h2>
<p>对称加密算法是应用比较早的算法，在数据加密和解密的时用的都是同一个密钥，这就造成了密钥管理困难的问题。常见的对称加密算法有 DES、3DES、AES128、AES192、AES256。</p>
<h3 id="a51a52及rc4">A5/1、A5/2及RC4</h3>
<p>A5/1、A5/2及RC4他们都属于对称加密算法，并都属于流加密。先了解什么是流加密。</p>
<p>在密码学中，<strong>流加密</strong>（英语：Stream cipher），是一种对称加密算法，加密和解密双方使用相同伪随机加密数据流（pseudo-random stream）作为密钥，明文数据每次与密钥数据流顺次对应加密，得到密文数据流。实践中通常<strong>把信息中的每一位跟密钥流的每一位进行异或 (xor) 运算来获得密文</strong>。</p>
<h3 id="des">DES</h3>
<p>DES(Data Encryption Standard) 是对称加密算法领域中的典型算法，是一种<strong>块加密算法</strong>(Block cipher)，其密钥默认长度为 56 位。块加密或者叫分组加密，这种加密方法是把明文分成几个固定大小的 block 块，然后分别对其进行加密。</p>
<p>DES 加密算法是对 <strong>密钥进行保密</strong>，而 <strong>公开算法</strong>，包括加密和解密算法。这样，只有掌握了和发送方 相同密钥 的人才能解读由 DES 加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是 <strong>搜索密钥的编码</strong>。对于 56 位长度的 密钥 来说，如果用 穷举法 来进行搜索的话，其运算次数为 $2 ^{56}$ 次。</p>
<h3 id="aes">AES</h3>
<p>AES 是美国国家标准技术研究所 NIST 旨在取代 DES 的 21 世纪的加密标准。AES 是块加密算法，也就是说，每次处理的数据是一块（16 字节），当数据不是 16 字节的倍数时填充，这就是所谓的<strong>分组密码</strong>（区别于基于比特位的流密码），16 字节是分组长度。AES 共有 ECB、CBC 等多种模式。</p>
<h3 id="sm4">SM4</h3>
<p>SM4 算法于 2012 年被国家密码管理局确定为国家密码行业标准，最初主要用于 WAPI (WLAN Authentication and Privacy Infrastructure) 无线网络中。SM4 算法的出现为将我国商用产品上的密码算法由国际标准替换为国家标准提供了强有力的支撑。随后，SM4 算法被广泛应用于政府办公、公安、银行、税务、电力等信息系统中，其在我国密码行业中占据着极其重要的位置。类似于 DES、AES 算法，SM4 算法也是一种分组密码算法。</p>
<h2 id="非对称加密可逆">非对称加密（可逆）</h2>
<p>学习非对称加密之前，我们得了解如何进行安全高效地秘钥交换。我们不可能说通信双方在通信之前，先见个面协商一下秘钥 key，这样非常不方便，但是又不能直接把 key 秘钥通过一个不安全的信道发出去，这样就会被攻击者截获。</p>
<p>所以我们需要有一种方法，<strong>可以让双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥</strong>。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容，这就是秘钥交换的概念（key exchange）。</p>
<h3 id="diffiehellman-key-exchange">Diffie–Hellman key exchange</h3>
<p>迪菲-赫尔曼密钥交换（英语：Diffie–Hellman key exchange，缩写为 D-H）是一种安全协议。可以完成上述秘钥交换。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/16-12-34-6c10e628d0058564969403b4f278deee-20221010161233-308a13.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/16-12-34-6c10e628d0058564969403b4f278deee-20221010161233-308a13.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<ol>
<li>
<p>通信双方 Alice 和 Bob 个准备一个大的质数，Alice 准备的质数是<code>n=11</code>, Bob 准备的质数是<code>g=7</code>，<code>n</code>和<code>g</code>是公开的，任何第三方都可以获取到这个信息。</p>
</li>
<li>
<p>Alice 准备一个随机自然数<code>x=3</code>, 除了 Alice 没有人知道<code>x</code>是多少，Alice 通过计算<code>g</code>的<code>x</code>次方并且对 <code>n</code> 取模，得到结果大 <code>A</code></p>
</li>
<li>
<p>Alice 把计算得到的结果 <code>A=2</code> 发送给 Bob，这个信息是公开的，任何人可以获取到 <code>A</code></p>
</li>
<li>
<p>Bob 同样准备一个随机自然数 <code>y=6</code>，除了 Bob 没有人知道 <code>y</code> 是多少，Bob 通过计算 <code>g</code> 的 <code>y</code> 次方并且对 <code>n</code> 取模，得到结果大 <code>B</code></p>
</li>
<li>
<p>Bob 把计算结果 <code>B=4</code>，发送给 Alice，，这个信息是公开的，任何人可以获取到 <code>B</code></p>
</li>
<li>
<p>Alice 拿到 <code>B</code> 以后，对 <code>B</code> 求 <code>x</code> 次方并对 <code>n</code> 取模，得到 <code>K1=9</code></p>
</li>
<li>
<p>Bob 拿到 <code>A</code> 以后，对 <code>A</code> 对 <code>y</code> 次方并对 <code>n</code> 取模，得到 <code>K2=9</code></p>
</li>
</ol>
<p><code>K1 == K2</code>，Alice 和 Bob 可以使用 <code>K1</code>，<code>K2</code> 作为 Key 进行通信加密。</p>
<p>在整个通信过程中，攻击者是无法知道 <code>x</code>，<code>y</code> 以及 <code>K1</code>，<code>K2</code> 的，或者说计算的困难很大，感兴趣的同学可以在网上找到具体的数学问题，离散对数问题的求解。</p>
<h3 id="rsa">RSA</h3>
<p>Diffie–Hellman key exchange 发明后不久出现了 RSA，另一个进行公钥交换的算法。它使用了非对称加密算法。</p>
<p>RSA 加密算法是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。</p>
<p>RSA 所用到的数学原理可以参考阮一峰老师的文章<a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA 算法原理（一）</a>，文章介绍了 RSA 用到的一些数学定理，不涉及证明，这对于了解 RSA 也就足够了。</p>
<p>简单介绍一下秘钥是生成过程（摘自<a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA 算法原理（二）</a>）：</p>
<ol>
<li>
<p>随机选择两个不相等的质数 $p$ 和 $q$。爱丽丝选择了$61$和$53$。（实际应用中，这两个质数越大，就越难破解。）</p>
</li>
<li>
<p>计算$p$和$q$的乘积$n$。爱丽丝就把 $61$ 和 $53$ 相乘。
$$n = 61×53 = 3233$$</p>
<p>$n$ 的长度就是密钥长度。$3233$ 写成二进制是 $110010100001$，一共有 $12$ 位，所以这个密钥就是 $12$ 位。实际应用中，RSA 密钥一般是 $1024$ 位，重要场合则为 $2048$ 位。</p>
</li>
<li>
<p>计算 $n$ 的欧拉函数$\varphi(n)$。根据公式：
$$\varphi(n) = (p-1)(q-1)$$</p>
<p>爱丽丝算出$\varphi(3233)$ 等于 $60×52$，即 $3120$。</p>
</li>
<li>
<p>随机选择一个整数 $e$，条件是 $1&lt; e &lt; \varphi(n)$，且 $e$ 与$\varphi(n)$ 互质。
爱丽丝就在 $1$ 到 $3120$ 之间，随机选择了 $17$。（实际应用中，常常选择 $65537$。）</p>
</li>
<li>
<p>计算 $e$ 对于$\varphi(n)$ 的模反元素 $d$。</p>
<p>所谓&quot;模反元素&quot;就是指有一个整数 $d$，可以使得 $ed$ 被$\varphi(n)$ 除的余数为 $1$。</p>
<p>$$ed ≡ 1 (mod \varphi(n))$$
这个式子等价于</p>
<p>$$ed - 1 = k\varphi(n)$$</p>
<p>于是，找到模反元素 $d$，实质上就是对下面这个二元一次方程求解。</p>
<p>$$ex + \varphi(n)y = 1$$</p>
<p>已知 $e=17$, $\varphi(n)=3120$，</p>
<p>$$17x + 3120y = 1$$</p>
<p>这个方程可以用<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">扩展欧几里得算法</a>求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 $(x,y)=(2753,-15)$，即 $d=2753$。</p>
<p>至此所有计算完成。</p>
</li>
<li>
<p>将 $n$ 和 $e$ 封装成公钥，$n$ 和 $d$ 封装成私钥。</p>
<p>在爱丽丝的例子中，$n=3233$，$e=17$，$d=2753$，所以公钥就是 $(3233,17)$，私钥就是$3233, 2753）$。</p>
<p>实际应用中，公钥和私钥的数据都采用 <code>ASN.1</code> 格式表达。</p>
</li>
</ol>
<p>RSA 算法为何是可靠的呢？因为该算法基于一个十分简单的数论事实：<strong>将两个大素数相乘十分容易，但想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥</strong>。</p>
<p>回顾上面的密钥生成步骤，一共出现六个数字：</p>
<p>$$p,q,n,\varphi(n),e,d$$</p>
<p>这六个数字之中，公钥用到了两个（$n$和$e$），其余四个数字都是不公开的。其中最关键的是$d$，因为$n$和$d$组成了私钥，一旦$d$泄漏，就等于私钥泄漏。</p>
<p>那么，有无可能在已知$n$和$e$的情况下，推导出$d$？</p>
<ul>
<li>$ed≡1 (mod φ(n))$。只有知道$e$和$φ(n)$，才能算出$d$。</li>
<li>$φ(n)=(p-1)(q-1)$。只有知道$p$和$q$，才能算出$φ(n)$。</li>
<li>$n=pq$。只有将$n$因数分解，才能算出 $p$ 和 $q$。</li>
</ul>
<p>结论：如果 $n$ 可以被因数分解，$d$ 就可以算出，也就意味着私钥被破解。</p>
<p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。</p>
<p>举例来说，你可以对 3233 进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">12301866845301177551304949
</span></span><span class="line"><span class="cl">58384962720772853569595334
</span></span><span class="line"><span class="cl">79219732245215172640050726
</span></span><span class="line"><span class="cl">36575187452021997864693899
</span></span><span class="line"><span class="cl">56474942774063845925192557
</span></span><span class="line"><span class="cl">32630345373154826850791702
</span></span><span class="line"><span class="cl">61221429134616704292143116
</span></span><span class="line"><span class="cl">02221240479274737794080665
</span></span><span class="line"><span class="cl">351419597459856902143413
</span></span></code></pre></div><p>它等于这样两个质数的乘积：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">33478071698956898786044169
</span></span><span class="line"><span class="cl">84821269081770479498371376
</span></span><span class="line"><span class="cl">85689124313889828837938780
</span></span><span class="line"><span class="cl">02287614711652531743087737
</span></span><span class="line"><span class="cl">814467999489
</span></span><span class="line"><span class="cl">　　×
</span></span><span class="line"><span class="cl">36746043666799590428244633
</span></span><span class="line"><span class="cl">79962795263227915816434308
</span></span><span class="line"><span class="cl">76426760322838157396665112
</span></span><span class="line"><span class="cl">79233373417143396810270092
</span></span><span class="line"><span class="cl">798736308917
</span></span></code></pre></div><p>事实上，这大概是人类已经分解的最大整数（232 个十进制位，768 个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长 RSA 密钥就是 768 位。</p>
<h1 id="签名与证书">签名与证书</h1>
<h1 id="参考">参考</h1>
<ol>
<li><a href="https://learn-cryptography.readthedocs.io/zh/latest/basic/">Learn Cryptography</a></li>
<li><a href="https://juejin.cn/post/6844903638117122056">浅谈常见的七种加密算法及实现 - 掘金</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA 算法原理（一） - 阮一峰的网络日志</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA 算法原理（二） - 阮一峰的网络日志</a></li>
<li><a href="https://segmentfault.com/a/1190000023445325">加密解密 - 面试官：说一下你常用的加密算法_个人文章 - SegmentFault 思否</a></li>
</ol>
]]></content:encoded>
    </item>
  </channel>
</rss>
