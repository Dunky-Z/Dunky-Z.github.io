<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Qt on PaperMod</title>
    <link>http://localhost:8888/tags/qt/</link>
    <description>Recent content in Qt on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Fri, 18 Mar 2022 13:50:35 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/tags/qt/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Qt 编译后的程序放到指定目录，屏蔽 qDebug 输出</title>
      <link>http://localhost:8888/posts/qt%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E5%B1%8F%E8%94%BDqdebug%E8%BE%93%E5%87%BA/</link>
      <pubDate>Fri, 18 Mar 2022 13:50:35 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E5%B1%8F%E8%94%BDqdebug%E8%BE%93%E5%87%BA/</guid>
      <description>可执行程序放到指定目录 默认情况下 QtCreator 会将编译链接后的可执行程序与中间生成的文件防盗build-***-文件中，如何能将可执行文件生成在指定目录？
修改.pro:
CONFIG(debug ,debug|release){DESTDIR = ../debug}else{DESTDIR = ../release} debug版本放在../debug目录中，release版本放在../release目录中。
屏蔽 qDebug 输出 CONFIG(debug ,debug|release){DEFINES -= QT_NO_DEBUG_OUTPUT}else{DEFINES += QT_NO_DEBUG_OUTPUT} QT_NO_DEBUG_OUTPUT即为屏蔽 qDebug 输出的宏定义，可以在debug版本中不屏蔽 qDebug 输出，release版本中屏蔽 qDebug 输出。
参考 QT 屏蔽 qDebug()、qWarning() 打印信息_qq_35173114 的博客-CSDN 博客_qwarning QT 的 QDebug 无法输出日志_amwha 的专栏 - 程序员宅基地_qdebug 打印不出来 - 程序员宅基地 Qt Creator 中的.pro 文件的详解_hebbely 的博客-CSDN 博客_qt 的 pro 文件</description>
    </item>
    <item>
      <title>解决 Qt-QObject::connect: Cannot queue arguments of type‘QTextCursor’错误</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt-qobject-connect-cannot-queue-arguments-of-type-qtextcursor%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sat, 04 Dec 2021 11:41:46 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt-qobject-connect-cannot-queue-arguments-of-type-qtextcursor%E9%94%99%E8%AF%AF/</guid>
      <description>保留现场 我在线程中直接调用了 QTextEdit 的 append 函数时，候就会出现下面的错误：
QObject::connect: Cannot queue arguments of type &amp;#39;QTextCursor&amp;#39; (Make sure &amp;#39;QTextCursor&amp;#39; is registered using qRegisterMetaType().) 探究原因 原因是我们不能通过线程来修改 UI，较为安全的修改用户界面的方式是向 UI 窗口发送信号 (signal)，较为简单的方式是使用 Qt threading 类。
解决方法 在窗口类中定义信号和槽，并声明和实现一个接口函数，这个接口函数由线程调用，在接口函数中 emit 一个信号，示例代码如下：
//mainwindow.h signals: void AppendText(const QString &amp;amp;text); private slots: void SlotAppendText(const QString &amp;amp;text); public: void Append(const QString &amp;amp;text); //mainwindow.cpp connect(this,SIGNAL(AppendText(QString)),this,SLOT(SlotAppendText(QString))); void ClassName::Append(const QString &amp;amp;text) { emit AppendText(&amp;#34;ok: string1&amp;#34;); } //thread.cpp void ThreadClassName::SlotAppendText(const QString &amp;amp;text) { mText.append(text); } </description>
    </item>
    <item>
      <title>Qt 跨窗口，控件类传递数据</title>
      <link>http://localhost:8888/posts/qt%E8%B7%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E7%B1%BB%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 02 Dec 2021 10:35:14 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E8%B7%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E7%B1%BB%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</guid>
      <description>问题简介 本文基于【Qt】窗体间传递数据（跨控件跨类），三种情况与处理方法
已知三个窗体，A 为 B C 的父控件，B 与 C 互为兄弟控件 那么参数传递分三种情况：
B 向 A（C 向 A）传递参数 B 向 C（C 向 B）传递参数 A 向 B（A 向 C）传递参数 三个空间关系模型参考如下，
B 向 A（C 向 A）传递参数 //B.h class B { signals: void toA([ParamList]); } //B.cpp B::B() { emit toA([ParamList]); } //A.h class A { private: B *b; private slots: void fromB([ParamList]); } //A.cpp A::A() { b = new B; connect(b, SIGNAL(toA([ParamList])), this, SLOT(fromB([ParamList]))); } void A::fromB([ParamList]) { //get[ParamList] } B 向 C（C 向 B）传递参数 //A.</description>
    </item>
    <item>
      <title>Clang-Format 格式化代码</title>
      <link>http://localhost:8888/posts/clang-format%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Wed, 01 Dec 2021 17:42:45 +0000</pubDate>
      <guid>http://localhost:8888/posts/clang-format%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>安装 Linux sudo apt-get install clang-format windows 每每到这时候就越能感受到用 Linux 作为开发环境的优势，Windows 安装就稍显复杂了。
你可以选择安装完整的 LLVM，在bin目录可以看到clang-format.exe。安装完后，将 bin 目录添加到环境变量中。
你也可以只下载clang-format.exe，从LLVM Snapshot Builds下载安装包。在下载页面的底部。同样你需要将单独下载的文件加入到环境变量中。
使用 入门使用 Linux 可以直接命令行，使用以 LLVM 代码风格格式化main.cpp, 结果直接写到main.cpp
clang g-format -i main.cpp -style=LLVM 进阶配置 如果每次编码都命令行执行一遍那也太麻烦了，而且每次修改也不止一个文件。最好的方式就是每次保存文件时自动格式化。比如 VSCode 已经内置了Clang-Format稍作配置即可实现，接下来介绍几种常见 IDE 如何配置Clang-Format。
VSCode VSCode 最常用，因为内置了Clang-Format也最容易配置。
安装C/C++插件，Ctrl+Shift+X打开应用商店，搜索C/C++找到下图插件，安装后会自动安装Clang-Format程序，无需单独下载。默认安装路径为： C:\Users\(你的用户名)\.vscode\extensions\ms-vscode.cpptools-1.7.1\LLVM\bin\clang-format.exe。 打开设置页面（左下角齿轮 - 设置），搜索format，勾选Format On Save，每次保存文件时自动格式化文档。下方的设置是决定每次格式化是整个文档，还是做过修改的内容。默认是file，对整个文档进行格式化。 仍在设置页面搜索Clang，配置如下。.clang-format文件最后详解。 效果图 QtCreator 安装Beautifier插件：帮助（Help）-关于插件（About Plugins）- Beautifier勾选，重启 QtCreator。 工具（Tool）- Beautifier，配置如图。该配置，保存文档时自动格式化，并选择Clang-Format作为格式化工具。 配置Clang-Format程序路径，如果开头已经apt install安装过，这里会自动补全。 Use predefined style可以选择内置的一些代码风格，如LLVM，Google等。 Use customized style使用自定义的一些代码风格。点击添加（Add）将配置文件粘贴进去即可，具体配置文件见最后。 别忘了点击OK保存。 Eclipse 安装cppstyle插件：Help - Eclipse Marketplace - 搜索cppstyle。</description>
    </item>
    <item>
      <title>解决 QT 点击按钮无响应</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%97%A0%E5%93%8D%E5%BA%94/</link>
      <pubDate>Tue, 16 Nov 2021 17:42:47 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%97%A0%E5%93%8D%E5%BA%94/</guid>
      <description>保留现场 在运行中的界面上点击按钮没有效果，像是按钮上层有其他遮盖层。
探究原因 widget的父控件上又添加了其他Widget，覆盖在了按钮上，因此无法点击。通过new得到的控件，默认显示在比它new的早的控件上面。
解决方法 // 将有按钮的那一层widget置于上层 widget-&amp;gt;raise(); </description>
    </item>
    <item>
      <title>解决 QT 在构造函数中写的控件不显示的问题</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%86%99%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 16 Nov 2021 16:15:26 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%86%99%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>保留现场 在新窗口中的构造函数中添加控件运行后却没有显示
探究原因 新建的工程师 MainWindow 子类工程，没有设置父窗口。
没有将控件的父窗口设置成自己定义的 widget。
#include&amp;lt;QMainWindow&amp;gt; QMainWindow::QMainWindow(QMainWindow*parent) : QMainWindow(parent), ui(new Ui::QMainWindow) { ui-&amp;gt;setupUi(this); QPushButton* button_1 = new QPushButton(&amp;#34;add&amp;#34;); QPushButton* button_1 = new QPushButton(&amp;#34;del&amp;#34;); } 解决方法 方法 1：给按钮控件设置父窗口：QWidget，并且把按钮添加到父窗口中。
#include&amp;lt;QMainWindow&amp;gt; #include&amp;lt;QPushButton&amp;gt; #include&amp;lt;QHBoxLayout&amp;gt; QMainWindow::QMainWindow(QMainWindow*parent) : QMainWindow(parent), ui(new Ui::QMainWindow) { ui-&amp;gt;setupUi(this); QWidget* w = new QWidget(); this-&amp;gt;setCentralWidget(w); QHBoxLayout* hLayout = new QHBoxLayout(); QPushButton* button_1 = new QPushButton(&amp;#34;add&amp;#34;); QPushButton* button_1 = new QPushButton(&amp;#34;del&amp;#34;); hLayout-&amp;gt;addWidget(button_1); hLayout-&amp;gt;addWidget(button_2); w-&amp;gt;setLayout(hLayout); } 方法 2：手动指定父窗口
#include&amp;lt;QMainWindow&amp;gt; #include&amp;lt;QPushButton&amp;gt; #include&amp;lt;QHBoxLayout&amp;gt; QMainWindow::QMainWindow(QMainWindow*parent) : QMainWindow(parent), ui(new Ui::QMainWindow) { ui-&amp;gt;setupUi(this); QPushButton* button_1 = new QPushButton(&amp;#34;add&amp;#34;); QPushButton* button_1 = new QPushButton(&amp;#34;del&amp;#34;); button_1-&amp;gt;setParent(this); button_2-&amp;gt;setParent(this); button_2-&amp;gt;move(300,100); } </description>
    </item>
    <item>
      <title>QWidget 中 update 不执行 paintEvent</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qwidget%E4%B8%ADupdate%E4%B8%8D%E6%89%A7%E8%A1%8Cpaintevent/</link>
      <pubDate>Mon, 15 Nov 2021 18:04:50 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qwidget%E4%B8%ADupdate%E4%B8%8D%E6%89%A7%E8%A1%8Cpaintevent/</guid>
      <description>保留现场 手动执行update()或者repaint()都不能执行paintEvent函数。
探究原因 如果是代码new出来的控件，检查是否正确显示，比如有没有加入到layout中。或者有没有设置父窗口（可能被其他空间遮挡）。
检查控件width或者height大小是否不为 0。如果为 0，也不会出出发paintEvent。
解决方法 参考 QT 在构造函数中写的控件不显示</description>
    </item>
    <item>
      <title>QtCreator 快速添加注释模板</title>
      <link>http://localhost:8888/posts/qtcreator%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Tue, 28 Sep 2021 19:26:03 +0000</pubDate>
      <guid>http://localhost:8888/posts/qtcreator%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/</guid>
      <description>需求 通常函数的注释一般都比较长，而且每个函数注释都格式一致，例如下面的函数注释模板。如果每次写注释都要复制一遍比较麻烦，复制完还要删除多余的字符。但是现有的编辑器一般都支持快捷输入。下面介绍在 QtCreator 中如何快捷输入注释模板。
/* * Description: // 函数功能、性能等的描述 * Input Parameter: // 输入参数说明，包括每个参数的作 * Output Parameter: // 对输出参数的说明。 * Return: // 函数返回值的说明 */ 方法 QtCreator-菜单栏工具（Tool）- 选项（Options）- 文本编辑器（Text Editor）- 片段（Snippets） 组（Group）选择C++-添加（Add） 现在要为我们的触发（Trigger）起个名字，因为是函数注释，我起了个funcom，然后在下方空白框里填入注释模板。Apply 保存。如图 在需要添加注释模板的地方输入funcom即可提示快捷输入，回车即可添加注释模板。 我们可以看到片段里有很多熟悉的内容，比如if else，我们在写代码时输入if else自动补全花括号其实就是在这里设置的。同理，我们还可以设置一些其他需要的快捷输入内容。比如行注释，文件注释，经常使用的代码框架等等。</description>
    </item>
    <item>
      <title>Qt 修改 UI 文件不生效</title>
      <link>http://localhost:8888/posts/qt%E4%BF%AE%E6%94%B9ui%E6%96%87%E4%BB%B6%E4%B8%8D%E7%94%9F%E6%95%88/</link>
      <pubDate>Sun, 26 Sep 2021 09:19:18 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E4%BF%AE%E6%94%B9ui%E6%96%87%E4%BB%B6%E4%B8%8D%E7%94%9F%E6%95%88/</guid>
      <description>保留现场 修改了 UI 文件后，在代码中无法调用新增的内容。
探究原因 导致ui_*.h文件没有更新的原因是源代码中#include ui_*.h的位置和实际生成的位置不同，引用的是老的ui_*.h
解决方法 方法一：
项目设置文件.pro内增加 UI_DIR=./UI，同时删除掉源代码目录中ui_*.h，clear all,-&amp;gt;qmake-&amp;gt;rebuilt all 方法二：</description>
    </item>
    <item>
      <title>QtCreator 修改项目构建目录</title>
      <link>http://localhost:8888/posts/qtcreator%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Sat, 25 Sep 2021 19:17:46 +0000</pubDate>
      <guid>http://localhost:8888/posts/qtcreator%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%9B%AE%E5%BD%95/</guid>
      <description>保留现场 QtCreator 构建项目时，会在统计目录新建一个build-xxx-debug的目录，如果想要自己修改这个目录的位置，名称，该怎么办。
解决方法 仅修改工具（Tool）–&amp;gt;选项 (Options)–&amp;gt;构建和运行 (Build&amp;amp;Run) 中Default build directory：./%{CurrentBuild:Name}是不会生效的。
将工具–&amp;gt;选项–&amp;gt;构建和运行中Default build directory修改为./%{CurrentBuild:Name}（改为你想要的目标目录都行）；
把 QtCreator 关闭，把工程目录下后缀名为.pro.user的文件删掉；
用 QtCreator 打开工程，会提示你创建构建目录，此时提示的就是你修改后的Default build directory中填写的目录；
其中.pro.user文件记录了编译器、构建工具链、构建目录、版本…..等工程编译相关信息，想要更换项目的编译环境，得删除这个文件，由 QtCreator 自动重新创建。</description>
    </item>
    <item>
      <title>Qt 命令行带参数启动 Qt 程序</title>
      <link>http://localhost:8888/posts/qt%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E5%90%AF%E5%8A%A8qt%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Mon, 13 Sep 2021 12:03:44 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E5%90%AF%E5%8A%A8qt%E7%A8%8B%E5%BA%8F/</guid>
      <description>简介 我们经常用到命令行参数，比如最常见的 Linux 命令，显示所有文件ls -a,ls其实就是一个程序，-a就是该程序需要解析的一个参数。那么如何能让 Qt 程序也能解析命令行参数，从命令行启动呢？
Qt 从 5.2 版开始提供了两个类QCommandLineOption和QCommandLineParser来解析应用的命令行参数。
添加程序属性信息，帮助，版本 一个程序启动后，我们会在命令行看到程序的一些简要信息，以及可以使用-v命令显示其版本信息，这些通用的参数以及被 Qt 分装好，可以直接使用。
#include &amp;#34;mainwindow.h&amp;#34; #include &amp;lt;QApplication&amp;gt; #include &amp;lt;QCommandLineParser&amp;gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); QCommandLineParser parser; // 定义解析实例 parser.setApplicationDescription(&amp;#34;TestCommandLine&amp;#34;); // 描述可执行程序的属性 parser.addHelpOption(); // 添加帮助命令 parser.addVersionOption(); // 添加版本选择命令 parser.process(a); // 把用户的命令行的放入解析实例 MainWindow w; w.show(); return a.exec(); } 运行结果：
➜ ./CommandLine -h Usage: ./CommandLine [options] TestCommandLine Options: -h, --help Displays help on commandline options. --help-all Displays help including Qt specific options.</description>
    </item>
    <item>
      <title>Qt 文件系统</title>
      <link>http://localhost:8888/posts/qt%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 31 Aug 2021 20:00:06 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>Qt 通过QIODevice提供了对 I/O 设备的抽象，这些设备具有读写字节块的能力。下面是 I/O 设备的类图：
图中所涉及的类及其用途简要说明如下：
QIODevice：所有I/O设备类的父类，提供了字节块读写的通用操作以及基本接口； QFlie：访问本地文件或者嵌入资源； QTemporaryFile：创建和访问本地文件系统的临时文件； QBuffer：读写QByteArray； QProcess：运行外部程序，处理进程间通讯； QAbstractSocket：所有套接字类的父类； QTcpSocket：TCP协议网络数据传输； QUdpSocket：传输 UDP 报文； QSslSocket：使用 SSL/TLS 传输数据； QFileDevice：Qt5 新增加的类，提供了有关文件操作的通用实现。
QFile 及其相关类 我们通常会将文件路径作为参数传给QFile的构造函数。不过也可以在创建好对象最后，使用setFileName()来修改。QFile需要使用/作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如C:/windows这样的路径在 Windows 平台下同样是可以的。
QFile主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。我们可以使用QDataStream或QTextStream类来读写文件，也可以使用QIODevice类提供的read()、readLine()、readAll()以及write()这样的函数。值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过QFileInfo获取，而不是自己分析文件路径字符串。
在这段代码中，我们首先使用QFile创建了一个文件对象。这个文件名字是 test.txt。只要将这个文件放在同执行路径一致的目录下即可。可以使用QDir::currentPath()来获得应用程序执行时的当前路径。只要将这个文件放在与当前路径一致的目录下即可。然后，我们使用open()函数打开这个文件，打开形式是只读方式，文本格式。这个类似于fopen()的 r 这样的参数。open()函数返回一个 bool 类型，如果打开失败，我们在控制台输出一段提示然后程序退出。否则，我们利用 while 循环，将每一行读到的内容输出。
#include &amp;lt;QWidget&amp;gt; #include &amp;lt;QApplication&amp;gt; #include &amp;lt;QDebug&amp;gt; #include &amp;lt;QFile&amp;gt; #include &amp;lt;QFileInfo&amp;gt; #include &amp;lt;QMainWindow&amp;gt; int main(int argc, char *argv[]) { QApplication app(argc, argv); QFile file(&amp;#34;test.txt&amp;#34;); if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) { qDebug() &amp;lt;&amp;lt; &amp;#34;Open file failed.&amp;#34;; return -1; } else { while (!</description>
    </item>
    <item>
      <title>Qt 绘制系统</title>
      <link>http://localhost:8888/posts/qt%E7%BB%98%E5%88%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 27 Aug 2021 14:39:12 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E7%BB%98%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>本篇文章所涉及代码可在此处查看。
绘制系统简介 Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于QPainter,QPainterDevice和QPaintEngine三个类。
QPainter用来执行绘制的操作；QPaintDevice是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；QPaintEngine提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。
三个类的关系：QPainter-&amp;gt;QPaintEngine-&amp;gt;QPaintDevice。通过这个关系我们也可以知道，QPainter通过QPaintEngine翻译指令在QPaintDevice上绘制。
通过一个实例来了解一下绘制系统的，
//main.h #include &amp;lt;QPainter&amp;gt; #include &amp;lt;QWidget&amp;gt; #include &amp;lt;QPaintEvent&amp;gt; #include &amp;lt;QApplication&amp;gt; #include &amp;lt;QMainWindow&amp;gt; class PaintedWidget : public QWidget { Q_OBJECT public: PaintedWidget(QWidget *parent = 0); protected: void paintEvent(QPaintEvent *); }; //main.cpp #include &amp;#34;paintwidget.h&amp;#34; PaintedWidget::PaintedWidget(QWidget *parent) : QWidget(parent) { resize(800, 600); setWindowTitle(tr(&amp;#34;Paint Demo&amp;#34;)); } void PaintedWidget::paintEvent(QPaintEvent *) { QPainter painter(this); painter.drawLine(20, 20, 700, 20); painter.setPen(Qt::red); painter.drawRect(10, 10, 100, 400); painter.setPen(QPen(Qt::green, 5)); painter.setBrush(Qt::blue); painter.drawEllipse(0, 0, 300, 40); // painter.</description>
    </item>
    <item>
      <title>Qt 模仿登录界面-页面反转效果</title>
      <link>http://localhost:8888/posts/qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E9%A1%B5%E9%9D%A2%E5%8F%8D%E8%BD%AC%E6%95%88%E6%9E%9C/</link>
      <pubDate>Tue, 24 Aug 2021 13:55:37 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E9%A1%B5%E9%9D%A2%E5%8F%8D%E8%BD%AC%E6%95%88%E6%9E%9C/</guid>
      <description>设置一个旋转效果，将登录界面旋转翻个面，设置一些网络参数。
效果 网络参数设置界面布局 网络参数设置界面 //loginnetsetwindow.cpp //初始化标题 void LoginNetSetWindow::initMyTitle() { m_titleBar-&amp;gt;move(0, 0); m_titleBar-&amp;gt;raise(); m_titleBar-&amp;gt;setBackgroundColor(0, 0, 0, true); m_titleBar-&amp;gt;setButtonType(MIN_BUTTON); m_titleBar-&amp;gt;setTitleWidth(this-&amp;gt;width()); m_titleBar-&amp;gt;setMoveParentWindowFlag(false); } void LoginNetSetWindow::initWindow() { QLabel* pBack = new QLabel(this); QMovie *movie = new QMovie(); movie-&amp;gt;setFileName(&amp;#34;:/Resources/NetSetWindow/headBack.gif&amp;#34;); pBack-&amp;gt;setMovie(movie); movie-&amp;gt;start(); pBack-&amp;gt;move(0, 0); connect(ui.pButtonOk, SIGNAL(clicked()), this, SIGNAL(rotateWindow())); connect(ui.pButtonCancel, SIGNAL(clicked()), this, SIGNAL(rotateWindow())); ui.comboBoxNetType-&amp;gt;addItem(QStringLiteral(&amp;#34;不使用代理&amp;#34;)); ui.comboBoxServerType-&amp;gt;addItem(QStringLiteral(&amp;#34;不使用高级选项&amp;#34;)); } void LoginNetSetWindow::paintEvent(QPaintEvent *event) { // 绘制背景图; QPainter painter(this); QPainterPath pathBack; pathBack.setFillRule(Qt::WindingFill); pathBack.addRoundedRect(QRect(0, 0, this-&amp;gt;width(), this-&amp;gt;height()), 3, 3); painter.setRenderHint(QPainter::Antialiasing, true); painter.fillPath(pathBack, QBrush(QColor(235, 242, 249))); QPainterPath pathBottom; pathBottom.</description>
    </item>
    <item>
      <title>Qt 模仿登录界面-交互响应</title>
      <link>http://localhost:8888/posts/qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E4%BA%A4%E4%BA%92%E5%93%8D%E5%BA%94/</link>
      <pubDate>Wed, 18 Aug 2021 13:07:01 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E4%BA%A4%E4%BA%92%E5%93%8D%E5%BA%94/</guid>
      <description>效果预览 设置窗口拖动 因为这个项目中没有将登录界面直接继承MainWindow，而是继承的Dialog类，所以它是不能直接移动的，需要我们自己添加相应的方法。这里实现了三种方法，点击，拖动，释放。
//mytitlebar.cpp // 以下通过 mousePressEvent、mouseMoveEvent、mouseReleaseEvent 三个事件实现了鼠标拖动标题栏移动窗口的效果; void MyTitleBar::mousePressEvent(QMouseEvent *event) { if (m_buttonType == MIN_MAX_BUTTON) { // 在窗口最大化时禁止拖动窗口; if (m_pButtonMax-&amp;gt;isVisible()) { m_isPressed = true; m_startMovePos = event-&amp;gt;globalPos(); } } else { m_isPressed = true; m_startMovePos = event-&amp;gt;globalPos(); } return QWidget::mousePressEvent(event); } void MyTitleBar::mouseMoveEvent(QMouseEvent *event) { if (m_isPressed &amp;amp;&amp;amp; m_isMoveParentWindow) { QPoint movePoint = event-&amp;gt;globalPos() - m_startMovePos; QPoint widgetPos = this-&amp;gt;parentWidget()-&amp;gt;pos() + movePoint; m_startMovePos = event-&amp;gt;globalPos(); this-&amp;gt;parentWidget()-&amp;gt;move(widgetPos.x(), widgetPos.y()); } return QWidget::mouseMoveEvent(event); } void MyTitleBar::mouseReleaseEvent(QMouseEvent *event) { m_isPressed = false; return QWidget::mouseReleaseEvent(event); } globalPos()获取全局的坐标 event-&amp;gt;globalPos()是获取全局的坐标，全局是相对于整个屏幕而言的。还有一个函数pos()获取的是局部坐标，相对于一个widget窗口而言。</description>
    </item>
    <item>
      <title>Qt 模仿登录界面-窗口布局及样式</title>
      <link>http://localhost:8888/posts/qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80%E5%8F%8A%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Tue, 17 Aug 2021 11:30:06 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80%E5%8F%8A%E6%A0%B7%E5%BC%8F/</guid>
      <description>框架类图 效果预览 完整项目及资源文件请在Github查看。
页面布局 初始化标题栏 // 初始化标题栏; void LoginWindow::initMyTitle() { // 因为这里有控件层叠了，所以要注意控件 raise() 方法的调用顺序; m_titleBar-&amp;gt;move(0, 0); m_titleBar-&amp;gt;raise(); m_titleBar-&amp;gt;setBackgroundColor(100, 0, 0, true); m_titleBar-&amp;gt;setButtonType(MIN_BUTTON); m_titleBar-&amp;gt;setTitleWidth(this-&amp;gt;width()); // 这里需要设置成 false，不允许通过标题栏拖动来移动窗口位置，否则会造成窗口位置错误; m_titleBar-&amp;gt;setMoveParentWindowFlag(false); ui-&amp;gt;pButtonArrow-&amp;gt;raise(); } raise()将控件置于顶层 程序在打开后一般都在所有窗体的顶层，打开其他程序后之前的程序就会被放到下一层，在这里，当设置完my_titleBar后对其他控件操作就会把my_titleBar控件覆盖。所有要用raise()方法将其置于顶层。
初始化窗口 // 初始化窗口; void LoginWindow::initWindow() { //背景 GIG 图; QLabel* pBack = new QLabel(this); QMovie *movie = new QMovie(); movie-&amp;gt;setFileName(&amp;#34;:/Resources/LoginWindow/back.gif&amp;#34;); pBack-&amp;gt;setMovie(movie); movie-&amp;gt;start(); pBack-&amp;gt;move(0, 0); //文本框内提示 ui-&amp;gt;accountComboBox-&amp;gt;setEditable(true); QLineEdit* lineEdit = ui-&amp;gt;accountComboBox-&amp;gt;lineEdit(); lineEdit-&amp;gt;setPlaceholderText(QStringLiteral(&amp;#34;QQ 号码/手机/邮箱&amp;#34;)); QRegExp regExp(&amp;#34;[A-Za-z0-9_]{6,30}&amp;#34;); //正则表达式限制用户名输入不能输入汉字 lineEdit-&amp;gt;setValidator(new QRegExpValidator(regExp,this)); ui-&amp;gt;passwordEdit-&amp;gt;setPlaceholderText(QStringLiteral(&amp;#34;密码&amp;#34;)); //密码框中的小键盘按钮; m_keyboardButton = new QPushButton(); m_keyboardButton-&amp;gt;setObjectName(&amp;#34;pButtonKeyboard&amp;#34;); m_keyboardButton-&amp;gt;setFixedSize(QSize(16, 16)); m_keyboardButton-&amp;gt;setCursor(QCursor(Qt::PointingHandCursor));//鼠标放上去变成手形 QHBoxLayout* passwordEditLayout = new QHBoxLayout(); passwordEditLayout-&amp;gt;addStretch(); passwordEditLayout-&amp;gt;addWidget(m_keyboardButton); passwordEditLayout-&amp;gt;setSpacing(0); passwordEditLayout-&amp;gt;setContentsMargins(0, 0, 8, 0); ui-&amp;gt;passwordEdit-&amp;gt;setLayout(passwordEditLayout); //设置密码达到最长时最后一个字符离小键盘图标的距离（12） ui-&amp;gt;passwordEdit-&amp;gt;setTextMargins(0, 0, m_keyboardButton-&amp;gt;width() + 12, 0); //设置头像以及状态图标 ui-&amp;gt;userHead-&amp;gt;setPixmap(QPixmap(&amp;#34;:/Resources/LoginWindow/HeadImage.</description>
    </item>
    <item>
      <title>Qt 添加资源文件（QtCreator）</title>
      <link>http://localhost:8888/posts/qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6qtcreator/</link>
      <pubDate>Thu, 12 Aug 2021 10:23:58 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6qtcreator/</guid>
      <description>QtCreator➜新建文件或项目➜Qt➜Qt Resource File
点击Choose，设置资源文件名和路径。资源文件是一系列文件的集合，比如我要建立一个图片的资源文件，我可以设置img为资源文件名，将来所有图片类资源，都放到这个资源文件里，加入还有音频类的文件，我可以新建一个audio的资源文件，以后所有音频类的文件都放到这个资源文件下。
而不是我想要添加的文件名。
右侧编辑器下方有个Add Prefix(添加前缀)，我们首先要添加文件前缀，前缀就是存放文件的文件夹名，然后添加需要的文件。添加完以后看效果就知道啥意思了。
这么做带来的一个问题是，如果以后我们要更改文件名，比如将 xbl.png 改成 xiabanle.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：
这样，我们可以直接使用:/images/avatar用到这个资源，无需关心图片的真实文件名。</description>
    </item>
    <item>
      <title>Qt 事件</title>
      <link>http://localhost:8888/posts/qt%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Mon, 09 Aug 2021 09:55:07 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E4%BA%8B%E4%BB%B6/</guid>
      <description>本篇文章所涉及代码可在此处查看
事件以及与信号的区别 事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。
事件和信号槽的区别
信号是由具体对象发出，然后马上交给connect函数连接的槽进行处理，如果处理过程中产生了新的信号，将会继续执行新的信号，一直这样递归进行下去。而事件使用一个事件队列对发出的所有事件进行维护，当新的事件产生时会被加到事件队列的尾部。 在运行过程中发现，刚启动时并不会显示任何内容，只有在点击一次后，平面才会显示信息。这是因为QWidget中有一个mouseTracking属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent()才会发出。如果mouseTracking是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出mouseMoveEvent()事件。如果mouseTracking为 true，则mouseMoveEvent()直接可以被发出。知道了这一点，我们就可以在main()函数中直接设置下：
EventLabel *label = new EventLabel;label-&amp;gt;setWindowTitle(&amp;#34;MouseEvent Demo&amp;#34;);label-&amp;gt;resize(300, 200);label-&amp;gt;setMouseTracking(true);label-&amp;gt;show(); 显示效果 事件的接受与忽略 //custombutton.h #include &amp;lt;QDebug&amp;gt; #include &amp;lt;QMouseEvent&amp;gt; #include &amp;lt;QApplication&amp;gt; #include &amp;lt;QPushButton&amp;gt; class CustomButton : public QPushButton { Q_OBJECT private: void onButtonClicked(); public: CustomButton(QWidget *parent = 0); }; //custombutton.cpp #include &amp;#34;custombutton.h&amp;#34; CustomButton::CustomButton(QWidget *parent) : QPushButton(parent) { connect(this, &amp;amp;CustomButton::clicked, this, &amp;amp;CustomButton::onButtonClicked); } void CustomButton::onButtonClicked() { qDebug() &amp;lt;&amp;lt; &amp;#34;You clicked this!&amp;#34;; } //main02.</description>
    </item>
    <item>
      <title>Qt 对话框</title>
      <link>http://localhost:8888/posts/qt%E5%AF%B9%E8%AF%9D%E6%A1%86/</link>
      <pubDate>Thu, 05 Aug 2021 10:11:33 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E5%AF%B9%E8%AF%9D%E6%A1%86/</guid>
      <description>本篇文章所涉及代码，可在此处查看
Qt 中使用 QDialog 类实现对话框。就像主窗口一样，我们通常会设计一个类继承 QDialog。QDialog（及其子类，以及所有 Qt::Dialog 类型的类）的对于其 parent 指针都有额外的解释：
如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。
顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。
对话框分为模态对话框和非模态对话框。所谓模态对话框，就是会阻塞同一应用程序中其它窗口的输入。模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。
与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。
Qt 支持模态对话框和非模态对话框。其中，Qt 有两种级别的模态对话框：应用程序级别的模态和窗口级别的模态，默认是应用程序级别的模态。应用程序级别的模态是指，当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。窗口级别的模态是指，该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。
消息对话框 QMessageBox 文件对话框 QFileDialog &amp;lsquo;QTextEdit&amp;rsquo; Does not name a type 需要包含头文件
#include &amp;lt;QTextEdit&amp;gt; Qt 需要包含的头文件实在太多了。
可能添加了头文件仍然报同样的错，没有搜索到相关的解答。
我的做法是：
确保在.pro文件中加入QT += widgets和CONFIG += c++11 将包含库文件语句都放到头文件.h中 </description>
    </item>
    <item>
      <title>Git 中添加 gitignore 并更新远程仓库</title>
      <link>http://localhost:8888/posts/git%E4%B8%AD%E6%B7%BB%E5%8A%A0gitignore%E5%B9%B6%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</link>
      <pubDate>Wed, 04 Aug 2021 14:09:20 +0000</pubDate>
      <guid>http://localhost:8888/posts/git%E4%B8%AD%E6%B7%BB%E5%8A%A0gitignore%E5%B9%B6%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</guid>
      <description>gitignore 的作用 在使用Git版本控制时，必须要用.gitignore这个文件来告诉Git那些文件或目录不需要添加到版本控制中。通俗点说，就是不需要git push到远程仓库。
在平时开发过程中，开发目录下会有各种格式的文件，比如 C 语言除了.c源码，还会有.o目标文件，没有后缀的可执行程序等等，假如你要进行深度学习类的开发，如图像识别，需要训练大量数据，如果这些训练数据也到跟踪管理，那push一次就可以下班回家了。
但是我们怎么让Git知道哪些文件需要跟踪，哪些文件不需要呢，这时候.gitignore文件就起作用了。
常用规则 简单介绍一下常用的规则，虽然后面有现成的模板，但是我们还是了解一下常用规则，能看得懂.gitignore里写了啥。也方便自己编写一些规则适应自己的工作。
/test/ # 过滤整个test文件夹*.o # 过滤所有.o文件/test/hello.o # 过滤test文件夹下hello.o这个文件!src/ # 不过滤src这个文件夹!*.c # 不过滤.c文件 通过 gitignore 文件更新远程仓库 上面说到我们在不同环境下需要制定不同的规则，但是每次都要重新写一遍，又或者不知道制定什么样的规则，还是挺麻烦的。
首先推荐一个.gitignore模板仓库，在平时工作学习中遇到的各种语言环境下的模板都能找到。这是广大开发人员总结的一些规则。
最近在学习Qt，在所有模板中搜索关键字，找到了Qt.gitignore这个模板打开并复制，在自己本地仓库里新建一个.gitignore文件，将复制的内容粘贴进去。
现在就要解决如何更新远程仓库的内容，因为我在使用.gitignore文件之前已经向远程push过了，现在需要删除不需要的文件。
git rm -r --cached . rm就是Linux下常用的删除命令，-r表示递归删除，--cached表示需要在本地端（工作区）保留文件，.表示所有文件。
git add . # 重新添加所有文件到暂存区，然后提交，推送git commit -m &amp;#34;update&amp;#34;git push </description>
    </item>
    <item>
      <title>Qt 添加资源文件</title>
      <link>http://localhost:8888/posts/qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 04 Aug 2021 11:34:10 +0000</pubDate>
      <guid>http://localhost:8888/posts/qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</guid>
      <description> 本文是学习【Qt 学习之路】的学习笔记，源码非原创。Github同步本文更改的代码。
在建立 Qt 学习代码仓时，推送到远程的代码比较乱，所以用gitignore文件屏蔽了一些。相关方法在这里。
资源文件 Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。
使用 QtCreator 的相关方法，讲得也很清楚了，就不赘述了。
不使用 QtCreator 添加资源文件 在使用命令行编译运行时，并不能像在 QtCreator 中一样，可以自动的生成一个.qrc文件，这就需要我们自己去编写。从原文的讲解中我们也知道，它就是一个XML描述文件，里面定义了文件位置等信息。如原文中的.qrc文件：
&amp;lt;RCC&amp;gt;&amp;lt;qresource prefix=&amp;#34;/images&amp;#34;&amp;gt;&amp;lt;file alias=&amp;#34;doc-open&amp;#34;&amp;gt;document-open.png&amp;lt;/file&amp;gt;&amp;lt;/qresource&amp;gt;&amp;lt;/RCC&amp;gt; 其中
&amp;lt;RCC&amp;gt;&amp;lt;qresource&amp;gt;&amp;lt;/qresource&amp;gt;&amp;lt;/RCC&amp;gt; 是固定的标记，再往中间加东西。如果学过html语言就很容易理解。其中prefix=&amp;quot;/images&amp;quot;就是自动加上前缀/images，因为图片在images目录下，每次都加这个路径太麻烦，太长。
alias=&amp;quot;doc-open&amp;quot;意思是将document-open.png这个文件起个别名，原来的太长了。下次再用document-open.png就只需要用doc-open就行了。
我们知道了这些，就可以编写一个自己的.qrc文件了。我也自己下载了一个打开文件的图标open.png，文件比较少，就和代码放在同一个目录下了。我们将其命名为ico.qrc，这个文件中以后都存放有关图标的资源，我们开始编写：
&amp;lt;RCC&amp;gt;&amp;lt;qresource&amp;gt;&amp;lt;file&amp;gt;open.png&amp;lt;/file&amp;gt;&amp;lt;/qresource&amp;gt;&amp;lt;/RCC&amp;gt; 因为添加资源后需要更新.pro文件才能正常编译，所以需要在.pro中加入RESOURCES 信息，就在.pro文件最后一行加入：
RESOURCES += ico.qrc 然后输入命令
qmake MainWindow.promake clean #因为之前可能make过，先清理一遍make./MainWindow 如果一切顺利，将会得到下面的窗口： Reference https://www.devbean.net/2012/08/qt-study-road-2-action/ </description>
    </item>
    <item>
      <title>Linux(Ubuntu) 环境下安装 Qt</title>
      <link>http://localhost:8888/posts/linux-ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85qt/</link>
      <pubDate>Tue, 27 Jul 2021 16:34:50 +0000</pubDate>
      <guid>http://localhost:8888/posts/linux-ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85qt/</guid>
      <description>真蠢，之前费那么大劲，只要一句命令就完事了
下载安装 sudo apt install qtcreator 但是在用命令行构建 project 时可能会报错
qmake -projectcould not find a Qt installation of &amp;#39;&amp;#39; 这时候需要
sudo apt-get install qt5-default 好了可以愉快玩耍了。
瞎折腾
下载 Qt 从 Qt5.15.0 起，对于开源用户，Qt 官方不再提供独立安装文件，且不再有 bug 修复版本（比如 Qt5.15.1），如果从官网下载，需要自己编译。虽然想试试编译，但是虚拟机刚开始开的空间太小了，还是另寻他法吧。以后有机会再来编译试试新功能。若读者有兴趣可以从官网下载源码并编译。或者参考官方的编译教程，从 GitHub 上下载。
国内有一些镜像站，提供 qt 镜像下载： 清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/ 中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/ 北京理工大学：https://mirrors.cnnic.cn/qt/
以清华大学的镜像为例，找到archive/qt/5.14/5.14.0/qt-opensource-linux-x64-5.14.0.run，点击即可开始下载。
qt 5.15 已经不提供安装包，想要最新版本，只能下 5.14，但是 5.14.2 下载没资源，下不动，如果遇到下不动的情况换一个版本吧
安装 Qt 下载的.run文件双击是无法安装的，因为它还没有可执行的权限，需要我们赋给它执行权限，打开终端进入安装包的目录。
chmod +x filename.run chmod命令是控制用户对文件的权限修改的命令，x是可执行权限的参数。 执行以上命令后就可以直接双击安装了。
网上一些教程可以跳过登录，我没找到跳过按钮，需要注册一个账号才能继续安装。 安装目录一般选择在/opt目录下 安装的附加组件最好都选择，以免后期使用再安装麻烦。Qt Creator 肯定要装的。 安装依赖库 apt-get install g++apt-get install libgl1-mesa-devapt-get install libqt4-devapt-get install build-essential # Build Essential，它是一个元软件包，可让您在Ubuntu中安装和使用c ++工具。sudo apt install qt5-default # 如果要将Qt 5用作默认的Qt Creator版本需要安装，否则会报 qmake: could not find a Qt installation of &amp;#39;&amp;#39;的错误 使用 Qt Creator 创建第一个程序 使用 Qt Creator 创建 首先我们先创建一个不带窗口的 HelloWorld 程序，测试安装是否成功，打开 Qt Creator-文件 - 新建文件或项目，选择 Non-Qt Project-Plain C++ Application。 接下来就设置项目名等，一直下一步。完成后就可以在编辑器看到如下 点击左下角运行按钮就可以得到如下： 再创建一个带窗口的 HelloWorld，在选择模板时选择 Application-Qt Widgets Application。一路点下一步就可以完成创建，运行后就可得到一个灰白的 HelloWorld 窗口。</description>
    </item>
  </channel>
</rss>
