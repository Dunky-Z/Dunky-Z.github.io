<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>标签: Linux - 如云泊</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">










<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="../../../../css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="如云泊" type="application/atom+xml">
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="../../../../index.html">
                
                <img src="../../../../images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5>#Linux</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/09/12/%E8%A7%A3%E5%86%B3Linux%E4%B8%8B%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC/" itemprop="url">Linux 下切换 Python 版本</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-09-12T06:05:17.000Z" itemprop="datePublished">9月 12 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            6 分钟 读完 (约 840 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>用过 Python 的都知道，Python 是不向后兼容的，也就是 Python3.X 开发的程序，使用 Python2.X 环境就无法正常运行。因为很多语法都改变了。现在接触到的大部分 Python 程序都是 Python3.X 开发的，但是偶尔也会遇到使用 Python2.X 的时候。这就需要灵活切换版本。</p>
<p>一般 Linux 的各个发行版都预装了 Python2.X。我使用的 Debian 就预装了 Python2.7。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python -V<br>Python 2.7.16<br></code></pre></td></tr></table></figure>

<p>但是我同时也安装了 Python3.7</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls /usr/bin | grep <span class="hljs-string">&quot;python*&quot;</span><br>dh_python2<br>python<br>python2<br>python2.7<br>python3<br>python3.7<br>python3.7m<br>python3m<br></code></pre></td></tr></table></figure>

<h2 id="alias-修改别名"><a href="#alias-修改别名" class="headerlink" title="alias 修改别名"></a>alias 修改别名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">alias</span> python=/usr/bin/python3<br>$ python -V<br>Python 3.7.3  <br></code></pre></td></tr></table></figure>

<p>上面的别名修改只对当前终端有效。如果要使每个窗口都使用这个别名，将别名加入<code>~/.bashrc</code>，如 zsh 是则是<code>~/.zshrc</code>。</p>
<h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>和修改别名类似</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s python /usr/bin/python3<br></code></pre></td></tr></table></figure>

<h2 id="update-alternatives"><a href="#update-alternatives" class="headerlink" title="update-alternatives"></a>update-alternatives</h2><p><code>update-alternatives</code>是 Debian 系统提供的一个工具，Ubuntu 是基于 Debian 的，所以 Ubuntu 也可以使用，其他发行版没有该工具。它可以用来方便快捷地切换应用版本，不仅仅用来切换 Python，其他应用程序有多个版本的也可以使用该工具。</p>
<p><code>update-alternatives</code>本质也是建立软链接，只不过有了统一的管理，首先我们需要使用<code>--install</code>参数，添加一些候选项，也就是执行<code>python</code>这个命令时，它可以有哪些选择，在这里就是<code>python3.7.3</code>和<code>python2.7.16</code>两个选择。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># --install &lt;链接&gt; &lt;名称&gt; &lt;路径&gt; &lt;优先级&gt;</span><br>sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2<br>sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.7 1<br></code></pre></td></tr></table></figure>

<p><strong>注意</strong>，这里的<code>/usr/bin/python</code>链接文件，两个可选项必须是一样的，这样这个链接文件才可以选择两个不同的可选项去链接。</p>
<p><code>python</code>是在命令行执行的命令。<code>/usr/bin/python2.7</code>是执行<code>python</code>命令后调用具体哪个版本。最后的数字<code>2</code>是优先级，也就是<code>python2.7</code>比<code>python3.7</code>优先级高，如果不指定版本，那么默认就是使用<code>python2</code>。</p>
<p>我们再查看一下版本信息，发现是<code>python2.7.16</code>。说明是默认版本。并且<code>python</code>已被链接到我们管理的软链接上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python -V<br>Python 2.7.16<br><br>$ ll /usr/bin  | grep <span class="hljs-string">&quot;python&quot;</span><br>lrwxrwxrwx 1 root   python -&gt; /etc/alternatives/python<br></code></pre></td></tr></table></figure>

<p>查看<code>python</code>的可选配置，可以看到有两个可选配置，默认是<code>python2</code>，第一列是序号，如果我们想切换到<code>python3</code>，对应的数字<code>2</code>即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">root at RISCX <span class="hljs-keyword">in</span> ~<br>$ update-alternatives --config python<br>There are 2 choices <span class="hljs-keyword">for</span> the alternative python (providing /usr/bin/python).<br><br>  Selection    Path                Priority   Status<br>------------------------------------------------------------<br>* 0            /usr/bin/python2.7   2         auto mode<br>  1            /usr/bin/python2.7   2         manual mode<br>  2            /usr/bin/python3.7   1         manual mode<br><br>Press &lt;enter&gt; to keep the current choice[*], or <span class="hljs-built_in">type</span> selection number:2<br>update-alternatives: using /usr/bin/python3.7 to provide /usr/bin/python (python) <span class="hljs-keyword">in</span> manual mode<br></code></pre></td></tr></table></figure>

<p>再次查看版本信息，发现已经切换成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python -V<br>Python 3.7.3<br></code></pre></td></tr></table></figure>

<blockquote>
<p>执行<code>update-alternatives</code>经常会导致我的终端<strong>回车失效</strong>，可以参考<a target="_blank" rel="noopener" href="https://dunky-z.github.io/2022/09/12/%E8%A7%A3%E5%86%B3Linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E9%94%AE%E5%8F%98%E6%88%90%E5%AD%97%E7%AC%A6M/">解决 Linux 终端回车键变成字符 M</a></p>
</blockquote>
<p><code>--remove</code>，删除可选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-alternatives --remove python /usr/bin/python2.7<br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/09/10/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-nohup%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/" itemprop="url">每天学命令-nohup 后台运行</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-09-10T09:14:58.000Z" itemprop="datePublished">9月 10 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/">每天学命令</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            5 分钟 读完 (约 776 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>使用 MobaXertm 连接服务器后，想要在运行一个下载任务，使用<code>&amp;</code>挂在后台后，退出 MobaXterm，后台的任务也随之中断，于是搜到这个<code>nohup</code>命令，可以完成我的需求。</p>
<p><code>nohup</code>意思是 No Hang Up，不要挂起的意思，即使退出终端也不会中断任务。</p>
<p>为了方便以后查阅，这里总结一下关于后台运行相关的命令。首先是最常用的<code>&amp;</code>符号。</p>
<h2 id="amp-后台运行"><a href="#amp-后台运行" class="headerlink" title="&amp; 后台运行"></a>&amp; 后台运行</h2><p>比如执行编译任务时通常会占用终端前台，这时候无法再执行其他命令，除非再开一个终端，对于有 GUI 界面时，再开一个终端很方便，但是如果是服务器就只能再想办法了。 <code>&amp;</code>可以将命令执行过程放在后台运行，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make  &gt;  make.log  2&gt;&amp;1  &amp; <br>[1] 16586<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>2&gt;&amp;1</code> 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了<code>make.log</code>文件，即将标准出错也输出到<code>make.log</code>文件中。最后一个<code>&amp;</code>，是让该命令在后台执行。<br>试想<code>2&gt;1</code>代表什么，<code>2</code>与<code>&gt;</code>结合代表错误重定向，而<code>1</code>则代表错误重定向到一个文件<code>1</code>，而不代表标准输出；换成<code>2&gt;&amp;1</code>，<code>&amp;</code>与<code>1</code>结合就代表标准输出了，就变成错误重定向到标准输出。</p>
</blockquote>
<p>在后台运行<code>make</code>进行编译，并将输出结果（错误和正常输出）都保存到<code>make.log</code>文件中，提交任务成功后，会显示进程 ID，编译的进程 ID 为 <code>16586</code>。</p>
<p>有了进程 ID 我们可以监控，也可以中断进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看进程状态</span><br>ps -ef | grep 16586<br><span class="hljs-comment"># 中断进程</span><br><span class="hljs-built_in">kill</span> -9 16586<br></code></pre></td></tr></table></figure>

<p>但是使用 <code>&amp;</code>时关闭终端后，进程也会随之关闭。如果想要在后台持续运行程序，就需要<code>nohup</code>命令。</p>
<h2 id="nohup-使用"><a href="#nohup-使用" class="headerlink" title="nohup 使用"></a>nohup 使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">$ nohup make  &gt;  make.log  2&gt;&amp;1  &amp; <br>[1] 112233<br></code></pre></td></tr></table></figure>

<p>命令功能同上，但是终端关闭，后台程序也会继续执行。</p>
<p><strong>NOTE</strong>：终端关闭，是指带 GUI 的界面里终端，如果使用 SSH 等登陆，比如使用 MobaXterm，一个 session 相当于一个登陆账户，如果异常退出了这个账户，那么后台执行的程序也会中断。如果需要继续执行，需要正常退出账户，执行<code>exit</code>命令。</p>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">fg</span>        <span class="hljs-comment"># 将后台中的命令调至前台继续运行</span><br><span class="hljs-built_in">bg</span>        <span class="hljs-comment"># 将一个在后台暂停的命令，变成继续执行 (在后台执行)</span><br><span class="hljs-built_in">jobs</span>      <span class="hljs-comment"># 查看当前有多少在后台运行的命令</span><br><span class="hljs-built_in">kill</span> %num <span class="hljs-comment"># 终止进程num</span><br>&amp;         <span class="hljs-comment"># 加在命令后可以将其置于后台运行</span><br>ctrl + z  <span class="hljs-comment"># 置于后台，并且暂停不可执行</span><br>ctrl + c  <span class="hljs-comment"># 终止前台进程</span><br>ctrl + \  <span class="hljs-comment"># 退出</span><br>ctrl + d  <span class="hljs-comment"># 结束当前输入(即用户不再给当前程序发出指令)，那么Linux通常将结束当前程序</span><br><br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/09/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E5%8F%B0NAS%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url">从零开始搭建一台 NAS 存储服务器</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-09-10T03:37:47.000Z" itemprop="datePublished">9月 10 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/">工欲善其事必先利其器</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 读完 (约 8466 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>技术没学多少，教程下满了硬盘，一直想专门部署 NAS 来存文件，但是一来要花钱，二来搭建 NAS 没有经验怕部署不好，没有现在硬盘直连舒适，所以将就用吧。</p>
<p>自从有天忘了忘了休眠电脑，一个自动备份任务开启，在 40 度的高温天，满速跑了一天，下班回来硬盘直接报废。这就加速我折腾部署 NAS 的进程。</p>
<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>威联通的几款中意的 NAS 放购物车很久了，如果硬盘没有这么早坏掉，可能在双十一就买整机了，现在离双十一还早，硬件价格都不便宜，想来想去还是买二手硬件攒一台更划算。如果买整机，硬盘加 NAS 主机就得五千大洋，只是用来存文件，部署个 Jellyfin 看电影用，属实奢侈了。</p>
<p>￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥</p>
<p>买二手就得从零开始学。生命不休，折腾不止。经过一次完整的 NAS 攒机过程发现，其实 NAS 就是安装了专用系统的一台电脑而已。这个专用系统就是面向网络存储开发的，如群晖，威联通，开源的 OMV，FreeNAS 等等。</p>
<p>既然是一台电脑，其实攒 NAS 就和攒电脑一样，选配好以下几大件即可。</p>
<ul>
<li>CPU</li>
<li>主板</li>
<li>散热器</li>
<li>机箱</li>
<li>内存</li>
<li>电源</li>
<li>机箱风扇</li>
</ul>
<p>下面分别介绍在攒机过程中遇到的一些概念，参数到底是什么意思。</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h4 id="CPU-型号字母数字都是什么意思"><a href="#CPU-型号字母数字都是什么意思" class="headerlink" title="CPU 型号字母数字都是什么意思"></a>CPU 型号字母数字都是什么意思</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/19-03-26-07978c9e6aae76e3d1a4ac48df0521f1-20220910190326-c46d16.png"></p>
<ul>
<li><strong>Intel</strong> 是英特尔的英文名称，也是目前热门的 CPU 品牌；</li>
<li>“酷睿”代表英特尔品牌下面向普通消费者的一个 CPU 系列，一般划分为 Core（酷睿）、Pentium（奔腾）、Celeron（赛扬）、Xeon（至强）、Atom（凌动）等；</li>
<li><strong>i5</strong> 代表这款 CPU 定位中端，在其下面还有 i3，在其上面还有 i7 和 i9，同一代中，数字越大，性能越强；但是不同代 - 数之间，性能不能直接相比，比如 12 代的 i5 在理论性能上是强于 10 代 i7 的。</li>
<li><strong>12</strong> 代表这款 CPU 的代数，说明其已经发展到第十二代了，数字越大越新；</li>
<li><strong>600</strong> 这三位数字代表 Intel SKU 型号划分，一般来说 Core i7 有固定几个 SKU，比方说 700；Core i5有600/500/400；Core i3有300/100等等，一般来说数字越大说明隶属的Core系列越高级，同级别下比较，数字越大频率越高，换句话说性能就越强，比方说Core i5-8600 默认 3.1GHz，睿频 4.3GHz，比 Core i5-8500 默认 3.0GHz，睿频 4.1GHz 要强。</li>
<li><strong>K</strong> 带 K 的表示不锁频，可以配合 Z 系列主板进行超频操作，适合会超频玩家使用，比方说 i7-12700K，i5-12600K 等</li>
<li><strong>F</strong> 带 F 的表示不带集成显卡，<strong>你必须配合独立显卡使用</strong>；</li>
</ul>
<p>当然，除了例子中的这种情况，我们还会遇到其它 CPU 型号的后缀：</p>
<ul>
<li><strong>K</strong>：表示支持超频且内置核显的 CPU 型号，例如型号：i5-12600K、i7-12700K；</li>
<li><strong>F</strong>：表示无内置核显，例如型号：i5-12400F、i7-12700F；</li>
<li><strong>KF</strong>：表示支持超频且无内置核显的 CPU 型号，例如型号：i5-12600KF，i7-12700KF。</li>
<li><strong>T</strong>：表示低功耗版，相同型号下功耗更低，性能也差一些，例如型号：i7-10700T；</li>
<li><strong>X/XE</strong>：表示至尊旗舰级，例如型号：i9-10980XE。</li>
<li><strong>KS</strong>：可以理解为官方超频版，提升了主频的版本，例如 i9-9900K 和 i9-9900KS，i9-9900KS 出厂的主频要高于 K，例如型号：i9-9900KS。</li>
<li><strong>U</strong>：低电压，性能弱些但功耗低，通常出现在轻薄本中，举例型号：i7 10510U；</li>
<li><strong>H</strong>：标压，性能强，通常出现在游戏本中，举例型号：i5-11300H</li>
<li><strong>Y</strong>：超低电压，性能很弱功耗非常低，通常出现在轻薄本中，举例型号：i3-10110Y；</li>
<li><strong>HK</strong>：一般使用在 Intel 高端发烧级 CPU 上，可超频，举例型号：i9-11980HK；</li>
<li><strong>G</strong>：G1、G4 以及 G7 等，G 后面的数字表示核显性能强弱，数字越大代表核显性能越强，通常数字小于 4 的是集成的普通超高清 (UHD) 核显，大于等于 4 的是集成的高性能锐炬 (Iris) 核显。Intel 移动版 CPU 后缀，举例型号：i5-1155G7、i3-1115G4、i3-1005G1；</li>
<li><strong>HQ</strong>：标准电压，Q 板载四核，早期的老后缀，举例型号：i7-7700HQ；</li>
<li><strong>MQ</strong>：标准电压，Q 插拔四核，早期的老后缀，举例型号：i7-4810MQ；</li>
<li><strong>M</strong>：早期后缀 M 就是移动端 CPU，只是为了与台式机区别开，举例型号：i7-2620M。</li>
</ul>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><h4 id="ATX，Micro-ATX，Mini-ITX-区别"><a href="#ATX，Micro-ATX，Mini-ITX-区别" class="headerlink" title="ATX，Micro-ATX，Mini-ITX 区别"></a>ATX，Micro-ATX，Mini-ITX 区别</h4><p>在了解买啥主板时，不免会看到各种 TX，比如我买的这块七彩虹 B460iTX 主板，简称就是七彩虹 B460i，还有不带最后字母<code>i</code>的。他们有啥区别呢？其实这就是表示了主板的尺寸。主板尺寸常见的有三种尺寸：</p>
<ul>
<li><p>标准-ATX：30.5 厘米 x 24.4 厘米</p>
</li>
<li><p>Micro-ATX：24.4 cm x 24.4 cm</p>
</li>
<li><p>Mini-ITX：17 厘米 x 17 厘米</p>
</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/17-03-20-6cc06a3d6fbf9247c002ff2aacbb89bd-20220910170319-1e2047.png"></p>
<p>一般攒机会用标准 ATX，或者 MATX 也很常用，而 ITX 就常被用来搭建低功耗的服务器，如我们要搭建的 NAS。因为它是 7*24 小时不间断工作的，功耗是需要多考虑的。</p>
<h3 id="散热器"><a href="#散热器" class="headerlink" title="散热器"></a>散热器</h3><h4 id="风冷与水冷"><a href="#风冷与水冷" class="headerlink" title="风冷与水冷"></a>风冷与水冷</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-02-33-f393351f39da51508625fc8283335b1c-20220911100231-f4fd24.png"></p>
<p>风冷就是散热鳍片加风扇。散热鳍片会穿入铜管，铜管与下方底座相连，底座与 CPU 直接接触。CPU 热量铜管底座传导给铜管，铜管传导给散热鳍片，散热鳍片铜管风扇散热。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-04-38-a5cb1d964c6f3dd6fc71c2bca88d4369-20220911100437-034a9d.png"></p>
<p>水冷就是水冷头加风扇。简单理解就是风冷的铜管换成了液体。液体流动传导比铜管更快。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-05-10-47f4e854323ea9e8d86896342153705a-20220911100509-80682d.png"></p>
<p>各有优缺点，风冷更安全，比较简单，性能上限比较低，而水冷在外观、性能方面有很大的优势，缺点就是相对比较贵，还有漏液风险，不过现在的水冷漏液概率很小。细分的话风冷还有下压式，下压式比较适合 itx 小机箱，而塔式就适合普通机箱，水冷也分一体式水冷和分体式水冷，常见的都是一体式水冷。</p>
<h3 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h3><h4 id="塔式，机架与刀片区别"><a href="#塔式，机架与刀片区别" class="headerlink" title="塔式，机架与刀片区别"></a>塔式，机架与刀片区别</h4><p>塔式服务器外形和普通家用服务器相差不多，塔式主机在主板扩展上有优势，一般预留接口较多，方便扩展。适用于入门和工作站。</p>
<p>机架服务器的外观安装工业标准统一设计，需要配合机柜统一使用，主要用于企业服务器密集部署。机架服务器因为需要密集紧凑，所以在设计时会非常紧凑，充分利用有限的空间。机架服务器宽度 19 英寸，高度以 U 为单位 (1U=1.75 英寸 =44.45 毫米）.</p>
<p>刀片服务器的主体结构是主体机箱中可以有许多热拔插的主板，每一块主板都可以独立运行自己的系统，这些主板可以集合成一个服务器集群，在集群模式下可以连接起来提供更好的网络以及共享资源。</p>
<h4 id="全塔，中塔与小塔区别"><a href="#全塔，中塔与小塔区别" class="headerlink" title="全塔，中塔与小塔区别"></a>全塔，中塔与小塔区别</h4><p>形容的是机箱的大小。</p>
<p>普通机箱，只能放 mATX 主板和一个标准电源，仅有 1-2 个光驱位；</p>
<p>中塔机箱 AT，X 主板甚至是 EATX 主板和一个标准电源，拥有 3-4 个光驱位；</p>
<p>全塔机箱，可以在主板上下的位置都安放一个电源，一共放两个电源拥有 4 个以上的光驱位。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/22-48-02-b90a4e4404769b82bc4d601d082bdf72-20220910224802-d6b6f5.png"></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h3 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h3><h4 id="全模组，半模组与非模组区别"><a href="#全模组，半模组与非模组区别" class="headerlink" title="全模组，半模组与非模组区别"></a>全模组，半模组与非模组区别</h4><p>总结一句话就是能不能拔掉不需要的供电线，能拔多少。</p>
<h5 id="非模组"><a href="#非模组" class="headerlink" title="非模组"></a>非模组</h5><p>一个都不能拔，电源线直接从电源内部引出，输出线缆固定，无法进行扩展。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/22-23-12-6d2af37077c958056be73653cfffd322-20220910222311-675160.png"></p>
<h5 id="半模组"><a href="#半模组" class="headerlink" title="半模组"></a>半模组</h5><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/22-32-37-16daab986b991e007eeff650353e0479-20220910223236-f0ab87.png"></p>
<p>能拔一部分，输出设计上既有非模组电源的直出线，又有全模组电源的扩展接口。</p>
<h5 id="全模组"><a href="#全模组" class="headerlink" title="全模组"></a>全模组</h5><p>能全拔，所有线缆都能按需插上。因为一般一块主板不会把所有电源线都用上，这样只需要插上自己需要的线缆即可，可以保证走线清楚，机箱清爽。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/22-20-52-266a816bdbffa27b7d2ad02eabb07a52-20220910222051-61c37f.png"></p>
<h4 id="金牌，银牌和铜牌啥区别"><a href="#金牌，银牌和铜牌啥区别" class="headerlink" title="金牌，银牌和铜牌啥区别"></a>金牌，银牌和铜牌啥区别</h4><p>金牌，银牌，铜牌指的是电源的转换效率。有钛金、白金、金牌、银牌、铜牌、白牌等档次，档次越高，转换效率也越高，但成本也越高，功率越小，相对成本也越高。每个“牌”对应的攻略转换或者参数也是不同的。</p>
<p>白牌：最低要求是 20-100% 负载下，转换效率必须达到 80%；</p>
<p>铜牌：与上同条件大于等于 82%，85%@50% 负载；</p>
<p>银牌：大于等于 85%，88%@50% 负载；</p>
<p>金牌：大于等于 87%，90%@50% 负载；</p>
<p>白金牌：90%@20% 负载、92%@50% 负载、89%@100% 负载。</p>
<p>钛金牌：要求 10%、20%、50%、100% 负载下的效率分别为 90%、94%、96%、92%。</p>
<blockquote>
<p>举个例子：<br>500w 金牌和 500w 铜牌，都能带动 500w 功耗的电脑。金牌电源在 100% 负载时，转换率超过 87%，可以算一下，500/0.87=575w 耗电。<br>铜牌 100% 负载转换率超过 82% 500/0.82=610w耗电，简单说就是好电源省电。</p>
</blockquote>
<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><h4 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h4><h4 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h4><h5 id="垂直盘-PMR-与叠瓦盘-SMR-区别"><a href="#垂直盘-PMR-与叠瓦盘-SMR-区别" class="headerlink" title="垂直盘 PMR 与叠瓦盘 SMR 区别"></a>垂直盘 PMR 与叠瓦盘 SMR 区别</h5><blockquote>
<p>作者：一起学点什么<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/369882964/answer/2227127605">https://www.zhihu.com/question/369882964/answer/2227127605</a></p>
</blockquote>
<p>垂直磁记录（Perpendicular magnetic recording，PMR），也称为传统磁性记录 (conventional magnetic recording，CMR)，由于 SMR 其实也是垂直式磁记录的一种，只是相较于垂直磁记录方式磁盘优化了写入密度，因此为了避免被认为所有垂直磁记录的硬盘都是 SMR 硬盘，大家也习惯把非 SMR 的垂直机械盘称为 CMR。</p>
<p>最开始由于硬盘容量提升的需求，磁性记录颗粒的尺寸需要不断下降，导致出现了电磁学上的超顺磁效应（超顺磁性：当某些具有磁性的颗粒小于某个尺寸时，外场产生的磁取向力太小而无法抵抗热扰动的干扰，而导致其磁化性质与顺磁体（通俗来说就是指材料对磁场响应很弱的磁）相似。），这就限制了硬盘容量提升的潜力。</p>
<p>之前硬盘厂商使用纵向（平行，Longitudinal Magnetic Recording，LMR）读写技术，磁性记录颗粒的易磁化方向相对于碟片是平行的，颗粒沿着碟片圆周以端对端排列，所以便有机会出现 SS（南）和 NN（北）的互斥排列。当颗粒的尺寸不断下降而密度不断提升，在室温的情况下颗粒便会对随机的热运动异常敏感，失去稳定性，导致出现比特（0 和 1）翻转的现象，记录的数据因此被破坏。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-37-25-bcc8863e8c481995128e5057ef677657-v2-0c0c8d0fa144f9492a3f4599bcff3fa2_720w-d47981.jpeg" alt="平行读写方式和垂直读写方式" title="
平行读写方式和垂直读写方式"></p>
<p>而为了解决以上问题，后来就开发出了垂直磁记录技术（Perpendicular Recording）的硬盘，这种硬盘中的磁性记录颗粒的易磁化方向相对于碟片是垂直的，允许使用单极磁头配合磁记录介质下的软磁层将信息写入磁记录介质中，这样采用具有相同饱和磁化强度的材料所制备的垂直写入磁头，能产生远多于传统写入磁头所能产生的磁场。更大的写入磁场允许我们使用具有更高磁各向异性的材料来制备磁记录介质，而磁各向异性越强，出现超顺磁性效应的临界体积就越小，因此，碟片中的存储密度可以在一定程度内得到进一步的提高。</p>
<p>但是这样虽然提高了硬盘的存储密度，但是很快也就达到了瓶颈，工程师又开始想新的方法来提高硬盘的存储密度，这就诞生了大家都知道的 SMR 叠瓦盘。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-37-44-9854e0b7be55864a3c8d88d85706ae3e-v2-70621980e9aa04789beee8ac77360de4_720w-bdb6ea.jpeg" alt="传统垂直读写硬盘的写入磁头和读写磁头的宽度" title="传统垂直读写硬盘的写入磁头和读写磁头的宽度"></p>
<p>叠瓦式机械硬盘（Shingled magnetic recording，SMR，直译为分层磁记录）：也是一种用于硬盘驱动器的磁存储数据记录技术，可提高存储密度和每个驱动器的整体存储容量。常规的硬盘驱动器通过写入彼此平行而不重叠的磁道来记录数据，例如 PMR。而叠瓦磁记录技术的硬盘写入的新磁道则与先前写入的磁道部分重叠，从而使先前的磁道更窄，因此能拥有更高的磁道密度，进而提高磁盘容量。使用叠瓦磁技术的磁道相互重叠，与用作屋顶的瓦片堆叠方式类似。之所以能这样做是因为磁盘写入磁头由于物理上的原因比读取磁头宽上许多，因而由正常方式写入的磁道宽度远比读取磁头所需的磁道宽度来得宽，此外为了避免磁道间相互干扰，磁道和磁道之间其实还有一部分空隙，因此读取信息的磁道仅占所有磁道的很小一部分，很大的磁盘空间都被浪费了，只是因为技术原因我们不能将写入磁头制作的和读取磁头一样小。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-38-47-933fcaeee57c194da4f9583cf2298ab8-v2-d64bf87cc1454f8ec91a398abfbbedc6_720w-d978c7.jpeg" alt="CMR 硬盘原理" title="CMR硬盘原理"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-38-58-83f62c2d4e2e8cbcdec45f6befd1be96-v2-6f1171496af614dea6c148afe5953a43_720w-c5eb05.jpeg"></p>
<p>由于磁道存在重叠，叠瓦式磁盘的写入过程较为复杂。如果我们随机写入一个磁道，由于写入磁头的宽度比磁道宽，因此写入会影响到临近磁道，如果这个临近磁道有数据，这些数据就也需要依次重写以免数据被破坏，依此类推。因此，SMR 磁盘一般分成很多块只能追加数据（顺序写入）的区域（Zone），这和固态硬盘的闪存页管理类似。使用“设备管理”（device-managed）方式的 SMR 磁盘通过内部固件处理了 SMR 磁盘复杂的写入问题，从而对用户封装了 SMR 磁盘的复杂性，令用户可以像使用 PMR 硬盘一样随机写入 SMR 硬盘。其他 SMR 磁盘则使用“主机管理”（host-managed）方式，需要操作系统识别 SMR 磁盘并拥有能对 SMR 磁盘进行正确顺序写入的驱动程序才能被正常使用。</p>
<p>叠瓦盘相较于垂直盘性能也有一定下降，因为传统的 CMR 硬盘磁道之间不会互相干扰，写入数据时可以任意进行写入，而叠瓦盘由于在一个磁道写入数据时不可避免会影响相邻的磁道，需要将下一磁道的数据先拿出（暂时放入硬盘 CMR 缓冲区）再进行写入，而恢复下一磁道的数据则又会对下下磁道的数据进行影响，则又需要先取出下下磁道的数据，因此完成传统垂直硬盘一次的写入操作，叠瓦式硬盘则需要多次的写入，同样的数据量需要更多的写入操作，也会增大损坏的概率。</p>
<h2 id="配件选购"><a href="#配件选购" class="headerlink" title="配件选购"></a>配件选购</h2><table>
<thead>
<tr>
<th align="center">配件</th>
<th align="center">型号</th>
<th align="center">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主板</td>
<td align="center">七彩虹 B460-ITX</td>
<td align="center">300^1^</td>
</tr>
<tr>
<td align="center">CPU</td>
<td align="center">I3-10100</td>
<td align="center">600^1^</td>
</tr>
<tr>
<td align="center">机箱</td>
<td align="center">Invasion X5</td>
<td align="center">330^1^</td>
</tr>
<tr>
<td align="center">电源</td>
<td align="center">振华冰山金蝶 550W</td>
<td align="center">300^1^</td>
</tr>
<tr>
<td align="center">硬盘</td>
<td align="center">西数 HC550</td>
<td align="center">1390</td>
</tr>
<tr>
<td align="center">SSD</td>
<td align="center">xxxxx</td>
<td align="center">旧电脑拆的</td>
</tr>
<tr>
<td align="center">散热器</td>
<td align="center">利民 AX120 RSE</td>
<td align="center">74</td>
</tr>
<tr>
<td align="center">内存条</td>
<td align="center">酷兽 DDR4 16G</td>
<td align="center">245</td>
</tr>
<tr>
<td align="center"><strong>合计</strong></td>
<td align="center"></td>
<td align="center"><strong>3239</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>1.表示二手价格</p>
</blockquote>
<h3 id="主板-1"><a href="#主板-1" class="headerlink" title="主板"></a>主板</h3><p>刚入门其实最头疼的就是到底买什么型号，因为各个配件之间又有兼容问题，比如相中了一款 ITX 的机箱，但是主板却是 ATX 的，主板都放不进机箱里，这就很麻烦。所以我们首先要确定一个配件，其余配件都安装这个配件的规格去买，并且都要适配这个配件。那么这个配件最好的选择就是主板。</p>
<p>我们先确定自己要买一个什么样的主板，让所有其他的配件都适配这个主板。选择主板的好处是，主板上各个接口就能体现出这台 NAS 的性能。不至于配件买的太离谱。</p>
<h3 id="机箱-1"><a href="#机箱-1" class="headerlink" title="机箱"></a>机箱</h3><p>微型机箱买 ITX 板，MINI 机箱买 M-ATX 板和 ITX 板，中塔机箱买 ATX 板。因为 NAS 是个服务器，可能会永远被放在墙角，所以颜值不重要，实用才是王道，买一个盘位多实用性强的就行。</p>
<p>在前期准备时看到很多推荐迎广的机箱，本来决定要买它，但是了解到 NAS 的本质就是一台电脑主机时，意识到为何不买个电脑机箱？为何要选择成品的机箱？虽然成品的 NAS 机箱有硬盘位，可热插拔。但是我为啥要去插拔服务器上的硬盘？</p>
<p>当我有这个意识后，我的选择一下子多了起来，我最终选了逛淘宝偶然看的 Invasion 机箱。十分简约的外形，甚至还有玻璃侧罩，四格金属硬盘架专为 NAS 打造。只要不到三百块。于是立马转头打开小黄鱼，一搜还真有转卖的，升级版的 8 格硬盘架只要 330。收到货后也很满意，几乎是全新的，玻璃膜都没有撕，还送了俩风扇。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/10/22/4d93dc601559f515fbe2a0e261eb2776.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/10/22/0264f7b051cac66705feee6e3441dd52.png"></p>
<h3 id="CPU-1"><a href="#CPU-1" class="headerlink" title="CPU"></a>CPU</h3><p>选择 CPU 对于小白来说最重要的就是要选择带核显的 CPU，因为 NAS 上显卡其实没必要，CPU 的核显就绰绰有余了，如果既没有显卡也没有核显就会无法亮机。所以选择 CPU 时要选择带核显的，也就是 Intel 的 CPU 型号不带<code>F</code>的，比如我最终选择的 I3-10100。AMD 的 CPU 型号标识我也没弄清楚，可以自己搜索一下自己想要的 CPU 是否有核显。</p>
<p>其次就是功耗，因为 NAS 要 7*24 小时运行，所以选择性能低一点的 CPU 就好了，另外就是需要关注 CPU 是否有音视频解码的能力。因为平时爱折腾，想着以后指不定在 NAS 上折腾些啥，所以选择了性能不算低的 I3-10100。两个月体验下来，性能还是过剩了，日常基本上都处于待机状态，只有周末看电影会用一下，CPU 利用率很低，好在日常功耗只有 30W。-</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/10/22/6e6ec183f0c08fc29eb6b01410090dce.png"></p>
<h2 id="安装-OVM-OpenMediaVaultt"><a href="#安装-OVM-OpenMediaVaultt" class="headerlink" title="安装 OVM (OpenMediaVaultt)"></a>安装 OVM (OpenMediaVaultt)</h2><p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FJ411s7xR?spm_id_from=333.999.0.0&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">蜗牛星际安装开源 NAS 系统 Openmediavault 及初始化配置（司波图）——OMV 系列教程 01</a></p>
<h3 id="为什么选择它"><a href="#为什么选择它" class="headerlink" title="为什么选择它"></a>为什么选择它</h3><p>OpenMediaVault（以下均简称 OMV）是除 FreeNAS 外目前使用最广泛的开源 NAS 系统。</p>
<h3 id="预备软件下载"><a href="#预备软件下载" class="headerlink" title="预备软件下载"></a>预备软件下载</h3><p><a target="_blank" rel="noopener" href="https://www.openmediavault.org/download.html">下载 OpenMediaVaultt 系统</a>，我选择的是 ISO 格式 Old Stable 版本，虽然想用最新的版本，但是第一次安装没有成功，选择了旧版本安装成功了。</p>
<p><a target="_blank" rel="noopener" href="https://www.wepe.com.cn/">下载 微 PE 工具箱</a>，用来格式化系统盘，如果是新买的系统盘就不需要下载。</p>
<p><a target="_blank" rel="noopener" href="https://rufus.ie/zh/">下载 Rufus 轻松创建 USB 启动盘</a>，这个必须要用的。</p>
<h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>需要一个容量大于 4G 的 U 盘，用 Rufus 将 OMV 写入 U 盘即可。安装时会从 U 盘启动，然后将系统安装到插在主板上的系统盘内。</p>
<p>启动盘制作就不详细说了，都是一键式操作。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/14-36-53-d083a346dc428783efefcddcb2a46001-20220911143652-19d632.png"></p>
<p><strong>制作完后进入 U 盘内查看是否写入成功</strong>，U 盘内是否有文件，或者查看一下 U 盘使用大小，如果比系统 ISO 大小还小，那肯定没有写成功。我就制作了三遍才发现没有写成功，虽然能看到启动选项，但是进入安装就黑屏，因为根本没有可以安装的文件。</p>
<p>如果没有制作成功，尝试<strong>格式化</strong>U 盘后重新制作。</p>
<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>参考视频即可，很详细。</p>
<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git</span></span><br><span class="line">sudo apt install git</span><br><span class="line"><span class="comment"># python</span></span><br><span class="line">sudo apt install python</span><br><span class="line"><span class="comment"># vim</span></span><br><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure>

<h2 id="Docker-配置"><a href="#Docker-配置" class="headerlink" title="Docker 配置"></a>Docker 配置</h2><h3 id="安装-Portainer-管理容器"><a href="#安装-Portainer-管理容器" class="headerlink" title="安装 Portainer 管理容器"></a>安装 Portainer 管理容器</h3><h3 id="更换国内镜像源"><a href="#更换国内镜像源" class="headerlink" title="更换国内镜像源"></a>更换国内镜像源</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/18-55-03-a846141c4a3997752a278ef1c604c554-20220910185502-99a3e2.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/18-58-15-eefc8207a6905d28a7b76e0a142f18d5-20220910185815-3b0c01.png"></p>
<ul>
<li>网易 <code>http://hub-mirror.c.163.com</code></li>
<li>ustc <code>http://docker.mirrors.ustc.edu.cn</code></li>
<li>阿里云 <code>http://&lt;你的 ID&gt;.mirror.aliyuncs.com</code></li>
<li>或者使用一位网友提供的    <code>http://1nj0zren.mirror.aliyuncs.com</code></li>
</ul>
<p>因为可能有朋友看了比较老的教程（比如我，:( ），可能会用到一些停止服务的进行，如：</p>
<ul>
<li><code>https://dockerhub.azk8s.cn</code></li>
<li><code>https://reg-mirror.qiniu.com</code></li>
<li><code>https://registry.docker-cn.com</code></li>
</ul>
<p>如果无法拉取镜像，检查是否用了这几个，如果用了请换镜像源。</p>
<h3 id="安装-Jellyfin-部署影音服务器"><a href="#安装-Jellyfin-部署影音服务器" class="headerlink" title="安装 Jellyfin 部署影音服务器"></a>安装 Jellyfin 部署影音服务器</h3><h3 id="安装-Transmission-下载"><a href="#安装-Transmission-下载" class="headerlink" title="安装 Transmission 下载"></a>安装 Transmission 下载</h3><h3 id="安装-qBittorrent-下载"><a href="#安装-qBittorrent-下载" class="headerlink" title="安装 qBittorrent 下载"></a>安装 qBittorrent 下载</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/16-06-33-65041d0b29059db114c6bd10b20ab2f2-20220911160632-a3bdd5.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/16-07-40-0ace26a48fbe6b421fdc1ad168d752f9-20220911160739-66337b.png"></p>
<h4 id="添加-tracker-list"><a href="#添加-tracker-list" class="headerlink" title="添加 tracker list"></a>添加 tracker list</h4><p><a target="_blank" rel="noopener" href="https://github.com/ngosang/trackerslist">ngosang/trackerslist: Updated list of public BitTorrent trackers</a></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/19-58-26-68faa5378bc8e252b13251e864575545-20220910195825-1f3492.png"></p>
<h3 id="安装-Jackett-搜索种子"><a href="#安装-Jackett-搜索种子" class="headerlink" title="安装 Jackett 搜索种子"></a>安装 Jackett 搜索种子</h3><p>Docker 中安装，选择网易的镜像，阿里的镜像太旧了。</p>
<p>配置端口号<code>9117</code>，映射两个路径即可。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/15-24-34-0d1575f2892b0426b6885e28d550337e-20220911152433-8a2a1d.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/15-27-11-008863a6cee878d735268752cf4b7ffa-20220911152710-5366dc.png"></p>
<p>安装过程参考<a target="_blank" rel="noopener" href="https://github.com/qbittorrent/search-plugins/wiki/How-to-configure-Jackett-plugin">How to configure Jackett plugin</a>。</p>
<p>点击<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/qbittorrent/search-plugins/master/nova3/engines/jackett.py">这里下载源码</a>，复制全文并保存为<code>jackett.py</code>文件。</p>
<p>如果按照以上安装 qBittorrent 那么保存路径为共享文件夹下<code>appdata/qBittorrent/nova3/engines/</code>。</p>
<p>如果没找到，找找是否有以下路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.<span class="built_in">local</span>/share/data/qBittorrent/nova3/engines/</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">~/.<span class="built_in">local</span>/share/qBittorrent/nova3/engines/</span><br></pre></td></tr></table></figure>

<p>再在相同路径下，新建一个配置文件<code>jackett.json</code>，写入以下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;api_key&quot;</span>: <span class="string">&quot;YOUR_API_KEY_HERE&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;tracker_first&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="comment">// 如果你登录 OMV 的地址是 192.168.0.1</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://192.168.0.1:9117&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装-Hlink-硬链接持续做种"><a href="#安装-Hlink-硬链接持续做种" class="headerlink" title="安装 Hlink 硬链接持续做种"></a>安装 Hlink 硬链接持续做种</h3><p>下载的文件名太过杂乱，可以用 TMM 等刮削工具刮削，重命名，建立影音库。但是重命名后就无法做种。想起了 Linux 有硬链接功能，在<a target="_blank" rel="noopener" href="https://dunky-z.github.io/2021/08/03/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/">每天学命令-ln 软硬链接</a>这篇文章中有详细说明。简言之就是创建的硬链接可以任意<strong>修改文件名</strong>，看上去是一份拷贝，但是<strong>实际不占用硬盘空间</strong>。</p>
<p>下载的文件太多，又是文件夹嵌套，手动创建比较麻烦，有人专门为这个需求开源了一个项目<a target="_blank" rel="noopener" href="https://hlink.likun.me/">hlink</a>，可以批量创建硬链接。这里还是以使用 Docker 为例。</p>
<h4 id="配置-Docker"><a href="#配置-Docker" class="headerlink" title="配置 Docker"></a>配置 Docker</h4><p>镜像名：likun7981/hlink<br>端口号：9090<br>目录映射：/media :  /root/sharedfolder<br>环境变量：HLINK_HOME：/root/sharedfolder/appdata/hlink  选择自己放配置文件的目录即可</p>
<blockquote>
<p>/root/sharedfolder 是我挂载的硬盘的根目录，建议映射根目录，不要创建多个目录，比如映射/root/sharedfolder/movie 和/root/sharedfolder/music。因为硬链接不支持跨盘符创建，虽然我们本地 music 和 movie 是在一个盘符，但是这样<strong>映射在容器中就是两个盘</strong>，就会无法创建硬链接，所以只映射一个根目录。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/10-23-24-4ece9b26e4043a836b1fa2a2781600b9-20220912102324-27d38f.png"></p>
</blockquote>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/09-41-48-1cd8143da0c9ffaca54a212f2ffd670e-20220912094147-3cc75f.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/09-41-15-50e436e132411b5528505e58911d636b-20220912094115-081991.png"></p>
<h4 id="配置-Hlink"><a href="#配置-Hlink" class="headerlink" title="配置 Hlink"></a>配置 Hlink</h4><p>浏览器输入 IP:9090，打开配置界面。</p>
<p>添加一个新配置，注释十分详细，就不赘述了，但是路径一定要写对，可以新建两个测试目录，测试一下是否能够创建成功。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/10-32-40-510edbcdcf05ffe8054b5581ed7c9057-20220912103239-8b23ae.png"></p>
<p>两个重要配置解释：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * /media 是容器里的目录，因为我只映射了一个目录，所以这就是容器的根目录</span></span><br><span class="line"><span class="comment"> * 对应到我主机，就是/root/sharedfolder 这个目录</span></span><br><span class="line"><span class="comment"> * 所以/media/downloads/qbittorrent/qbcomplete/movie</span></span><br><span class="line"><span class="comment"> * 就是/root/sharedfolder/downloads/qbittorrent/qbcomplete/movie</span></span><br><span class="line"><span class="comment"> * 后一个路径/media/media/movie同理</span></span><br><span class="line"><span class="comment"> * 等价于/root/sharedfolder/media/movie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 前一个路径是下载的路径，这里的文件都是不能重命名整理的</span></span><br><span class="line"><span class="comment">  * 后一个路径是影音库的路径，hlink 执行完会在这里创建相同的文件链接</span></span><br><span class="line"><span class="comment">  * 这个链接可以任意修改，移动，删除</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  pathsMapping: &#123;</span><br><span class="line">      &#x27;/media/downloads/qbittorrent/qbcomplete/movie&#x27;: &#x27;/media/media/movie&#x27;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 true 打开缓存，这样即使影音库里的文件被删除，移动</span></span><br><span class="line"><span class="comment"> * 也不会创建新的硬链接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">openCache: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<p>缓存的文件信息在右上角<strong>编辑缓存</strong>可以查看，如果已经执行过创建硬链接但是没有显示，<code>Shfit+F5</code>刷新界面重试。</p>
<h2 id="踩坑记录-1"><a href="#踩坑记录-1" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="主板无法识别固态硬盘"><a href="#主板无法识别固态硬盘" class="headerlink" title="主板无法识别固态硬盘"></a>主板无法识别固态硬盘</h3><p>因为想利用上三年前从笔记本上拆下来的固态，但没注意接口的协议。主板现在大多默认支持 NEVe 协议，但是我的硬盘是很久之前的 SATA 协议。这块 B460i 主板默认支持 NVMe 协议的，但是也支持 SATA 协议，需要更改跳帽。</p>
<p>找了半天图片没有找到一样的，官网的图片是和说明书上的一样是拨动开关形式的，但是我买的二手的是跳帽（哭），不会是买到假的了吧。开关全部拨到左边才支持 SATA 协议。用跳帽也是一样，必须都连接的是左边两个引脚。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/16-11-07-355ce9f2442639e47b0e24f9773b2e84-20220910161106-f6986f.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/16-09-53-5ceae123a355652ef1f45bb0e9b72dd9-20220910160952-9c6773.png"></p>
<h3 id="无法识别-U-盘启动盘"><a href="#无法识别-U-盘启动盘" class="headerlink" title="无法识别 U 盘启动盘"></a>无法识别 U 盘启动盘</h3><p>引导模式有两种 UEFI 和 Legacy，这个在做启动盘时就确定了。如果主板使用的 UEFI 模式，而启动盘制作的是 Legacy 模式，就无法识别，需要在 Bios 里找到启动模式选择的相关选项，配置可以使用 Legacy 模式或者 UEFI。（记录这些时已经不想再进 Bios 了所以也没有图片，总之要配置引导方式，避免过滤了一些引导方式导致 U 盘无法识别）</p>
<h3 id="不同网段设备无法互通"><a href="#不同网段设备无法互通" class="headerlink" title="不同网段设备无法互通"></a>不同网段设备无法互通</h3><h3 id="OVM-无法挂载移动硬盘"><a href="#OVM-无法挂载移动硬盘" class="headerlink" title="OVM 无法挂载移动硬盘"></a>OVM 无法挂载移动硬盘</h3><p>报错：The filesystem label contains blanks. Please remove them by renaming the filesystem to be able to mount it.</p>
<p>移动硬盘名里有空格，插到 Windows 上重命名一下即可。</p>
<h3 id="ifconfig-not-found"><a href="#ifconfig-not-found" class="headerlink" title="ifconfig not found"></a>ifconfig not found</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ifconfig</span></span><br><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure>

<h3 id="ll-not-found"><a href="#ll-not-found" class="headerlink" title="ll not found"></a>ll not found</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment"># 找到 #alias ll=’ls -l’，去掉前面的#就可以了。</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/498113584">CPU 型号解读：教你 CPU 型号后缀怎么看？CPU 型号后面的字母和数字区别是什么？ - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://einverne.github.io/post/2018/12/build-nas-from-scratch.html">从零开始搭建 NAS: 硬件篇 | Verne in GitHub</a></li>
<li><a target="_blank" rel="noopener" href="https://einverne.github.io/post/2020/02/build-nas-from-scratch-software.html">从零搭建一台 NAS：软件篇 | Verne in GitHub</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mahoon411/article/details/106963398">Intel CPU 型号解读以及如何粗略判断 Intel CPU 的性能 (i3、i5、i7 以及 CPU 的代数)_吮指原味张的博客-CSDN 博客_cpu 代数</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.zuiyu1818.cn/posts/NAS_qBittorrent.html">NAS | 群晖安装 qBittorrent 套件并优化设置、替换 UI（非 docker 安装） | 醉渔小站</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/405fe33b9032">Docker 中国源 - 简书</a></li>
<li><a target="_blank" rel="noopener" href="http://www.antec.com.cn/index.php?m=content&c=index&a=show&catid=41&id=57">金牌 铜牌 什么区别呀？ - 电源 - Antec 网站</a></li>
<li><a target="_blank" rel="noopener" href="https://www.tspweb.com/key/%E9%93%9C%E7%89%8C%E7%94%B5%E6%BA%90%E5%92%8C%E9%87%91%E7%89%8C%E7%94%B5%E6%BA%90%E7%9A%84%E5%8C%BA%E5%88%AB.html">机·科普贴：电脑电源金、银、铜牌到底是什么意思？_铜牌电源和金牌电源的区别 - 调色盘网络</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50797978">【非模组电源，半模组电源，全模组电源有什么区别？】 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://post.smzdm.com/p/awx49n72/">电源全模组和非模组究竟有什么区别？_电脑电源_什么值得买</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25592446">浅谈组装机机箱的选择（篇一：大小） - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://howthere.org/zh-hant/%E5%93%AA%E7%A8%AE-pc-%E6%A9%9F%E7%AE%B1%E5%B0%BA%E5%AF%B8%E6%9C%80%E9%81%A9%E5%90%88%E6%82%A8%E7%9A%84%E4%B8%8B%E4%B8%80%E5%80%8B%E7%89%88%E6%9C%AC%EF%BC%9F">哪種 PC 機箱尺寸最適合您的下一個版本？ - HowThere</a></li>
<li><a target="_blank" rel="noopener" href="https://www.expreview.com/49306-all.html">199 元风冷/水冷散热器简单对比：谁才是你的爱 - 超能网</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FJ411s7xR?spm_id_from=333.999.0.0&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">【教程】蜗牛星际安装开源 NAS 系统 Openmediavault 及初始化配置（司波图）——OMV 系列教程 01_哔哩哔哩_bilibili</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/qbittorrent/search-plugins/wiki/How-to-configure-Jackett-plugin">How to configure Jackett plugin · qbittorrent/search-plugins Wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aa411R7hn?spm_id_from=333.337.search-card.all.click&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">安装 NAS Tools，打造自动化观影、追剧系统，NAS 媒体库整理工具，威联通 Docker 版 NAS Tools 安装教程~feat.威联通 HS 264_哔哩哔哩_bilibili</a></li>
<li><a target="_blank" rel="noopener" href="https://hlink.likun.me/">Home | hlink</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/09/05/Linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E5%8F%98%E6%88%90-M/" itemprop="url">Linux 终端回车变成^M</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-09-05T07:37:58.000Z" itemprop="datePublished">9月 5 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            几秒 读完 (约 39 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>终端执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">stty sane<br></code></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/441744/pressing-enter-produces-m-instead-of-a-newline#comment578102_441744">command line - Pressing enter produces ^M instead of a newline - Ask Ubuntu</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/09/05/Linux%E5%88%87%E6%8D%A2%E4%B8%8D%E5%90%8CPython%E7%89%88%E6%9C%AC/" itemprop="url">Linux 切换不同 Python 版本</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-09-05T07:31:27.000Z" itemprop="datePublished">9月 5 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            几秒 读完 (约 0 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/07/23/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6/" itemprop="url">每天学命令-生成指定大小文件</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-07-23T08:14:38.000Z" itemprop="datePublished">7月 23 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/">每天学命令</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 分钟 读完 (约 1075 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>在测试下载速度，或者测试加解密文件，亦或者制作文件系统时都需要一些指定大小的文件。Linux 有一些命令可以快速完成这样的任务。接下来介绍几个好用的命令。</p>
<h3 id="空洞文件"><a href="#空洞文件" class="headerlink" title="空洞文件"></a>空洞文件</h3><p>在 Unix 文件操作中，操作文件的位移量可以大于文件的当前长度，在下一次写操作时，就会把文件撑大（Extend），在文件里创建空洞（Hole），没有被实际写入的部分都是 0。空洞文件是否占用实际磁盘空间由文件系统觉得，<strong>Linux 中空洞文件不占用实际磁盘空间</strong>。</p>
<h2 id="fallocate"><a href="#fallocate" class="headerlink" title="fallocate"></a>fallocate</h2><p><code>fallocate</code>用于将块预分配给文件。对于支持<code>fallocate</code>系统调用的文件系统，这可以通过分配块并将其标记为未初始化来快速完成，因此不需要对数据块进行 I/O 操作。这是创建文件而不是用零填充的更快的方法。大文件几乎可以立即创建，而不必等待任何 I/O 操作完成。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallocate [-n] [-o offset] -l length filename</span><br></pre></td></tr></table></figure>

<ul>
<li><code>d</code>: 检测零并替换为空洞。</li>
<li><code>-n</code>：指定文件的大小，单位为字节。</li>
<li><code>-o</code>：指定文件的偏移量，可以跟二进制$2^{N}$后缀<code>KiB</code>，<code>MiB</code>，<code>GiB</code>，<code>TiB</code>，<code>PiB</code>和<code>EiB</code>（<code>iB</code>为可选，例如，<code>K</code>的含义与<code>KiB</code>的含义相同或后缀<code>KB</code>，<code>MB</code>，<code>GB</code>，<code>PB</code>和<code>EB</code>的十进制（$10^{N}$）。</li>
<li><code>-l</code>：指定文件的大小，单位同上。</li>
<li><code>-p, --punch-hole</code>: 将某个范围替换为空洞 (连带打开 -n)。</li>
<li><code>filename</code>：指定文件名。</li>
</ul>
<p>示例：<br>分配一个大小为<code>512MB</code>的文件，文件名为<code>efi.img</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallocate -l 512M efi.img</span><br></pre></td></tr></table></figure>

<p>将<code>efi.img</code>文件中的<code>0</code>替换为空洞：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallocate -d efi.img</span><br></pre></td></tr></table></figure>

<p>从偏移 128M 的位置挖一个 10M 大小的洞</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallocate -p -o 128M  -l 10M  efi.img</span><br></pre></td></tr></table></figure>

<h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>Linux <code>dd</code> 命令用于读取、转换并输出数据。<code>dd</code> 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出</p>
<blockquote>
<p>dd 的原意为 data duplicator，但由于 dd 属于较低阶的资料处理工具，通常都会以管理者（root）权限来执行，如果稍有不慎，也很容易造成严重的后果（例如整颗硬碟的资料不见等等），所以有些人也把 dd 取名为 data destroyer。<a target="_blank" rel="noopener" href="https://blog.gtwang.org/linux/dd-command-examples/">dd 指令教学与实用范例，备份与回复资料的小工具 - GT Wang</a></p>
</blockquote>
<ul>
<li><code>if=FILE</code>     : 指定输入文件，若不指定则从标注输入读取。这里指定为/dev/zero 是 Linux 的一个伪文件，它可以产生连续不断的 null 流（二进制的 0）。</li>
<li><code>of=FILE</code>      : 指定输出文件，若不指定则输出到标准输出。</li>
<li><code>bs=BYTES</code>     : 每次读写的字节数，可以使用单位 K、M、G 等等。另外输入输出可以分别用 ibs、obs 指定，若使用 bs，则表示是 ibs 和 obs 都是用该参数。</li>
<li><code>count=BLOCKS</code> : 读取的 block 数，block 的大小由 ibs 指定。</li>
</ul>
<p>示例：<br>生成一个<code>1g</code>大小的文件，内容全为<code>0</code>，块大小为<code>1M</code>，文件名为<code>efi.img</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=efi.img bs=1M count=1024</span><br></pre></td></tr></table></figure>

<p>生成一个<code>1g</code>大小的文件，内容为随机数，块大小为<code>10M</code>，文件名为<code>efi.img</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/urandom of=efi.img bs=10M count=1024</span><br></pre></td></tr></table></figure>

<h2 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h2><ul>
<li><code>-s</code>：指定文件的大小，可以跟二进制$2^{N}$后缀<code>KiB</code>，<code>MiB</code>，<code>GiB</code>，<code>TiB</code>，<code>PiB</code>和<code>EiB</code>（<code>iB</code>为可选，例如，<code>K</code>的含义与<code>KiB</code>的含义相同或后缀<code>KB</code>，<code>MB</code>，<code>GB</code>，<code>PB</code>和<code>EB</code>的十进制（$10^{N}$）。</li>
</ul>
<p>示例：<br>生成一个 100M 大小的文件，文件名为<code>efi.img</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate -s 100M efi.img</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://lrita.github.io/images/posts/filesystem/Linux_File_Hole_And_Sparse_Files.pdf">Linux 文件空洞与稀疏文件</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/07/17/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" itemprop="url">理解虚拟内存</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-07-17T13:45:20.000Z" itemprop="datePublished">7月 17 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            38 分钟 读完 (约 5728 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="为什么需要虚拟内存？"><a href="#为什么需要虚拟内存？" class="headerlink" title="为什么需要虚拟内存？"></a>为什么需要虚拟内存？</h2><p>CPU 访问内存的最自然的方式就是使用物理地址，这种方式称为<strong>物理寻址</strong>。1，计算机中并不是只有一个程序在运行，如果它们都是用物理寻址的方式，那么所有程序必须在链接之前确定好自己所用到的内存范围，否则两个程序就可能会发生冲突。2，程序大于内存的问题早在上世纪六十年代就出现，后来出现了<strong>覆盖技术</strong>（Overlay），把程序分割成许多片段。程序开始执行时，将覆盖管理模块装入内存，该管理模块立即装入并运行覆盖 0。执行完成后，覆盖 0 通知管理模块装入覆盖 1，或者占用覆盖 0 的上方位置（如果有空间），或者占用覆盖 0（如果没有空间）。把一个大程序分割成小的、模块化的片段是非常费时和枯燥的，并且易于出错。很少程序员擅长使用覆盖技术。</p>
<p>为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟内存</strong>(VM)。主要有三个功能：</p>
<ul>
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它<strong>高效地使用了主存</strong>。</li>
<li>它为每个进程提供了一致的地址空间，从而<strong>简化了内存管理</strong>。</li>
<li>它<strong>保护了每个进程</strong>的地址空间不被其他进程破坏。</li>
</ul>
<h2 id="什么是虚拟寻址？"><a href="#什么是虚拟寻址？" class="headerlink" title="什么是虚拟寻址？"></a>什么是虚拟寻址？</h2><p>如果主存被分为长度为$M$的单字节大小的数组，每个字节都对应一个物理地址，CPU 通过这个唯一的地址访问主存，这样的方式就是<strong>物理寻址</strong>。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207212125636.png"><br>现代处理器使用<strong>虚拟寻址</strong>的方式。CPU 通过生成的<strong>虚拟地址</strong>来访问内存，这个地址在送到内存之前会被转换成<strong>物理地址</strong>。这个过程称为<strong>地址翻译</strong>。CPU 芯片上叫做<strong>内存管理单元</strong>（Memory Management Unit, MMU）的专用硬件，利用存放在主存中的<strong>查询表</strong>来动态翻译虚拟地址，该表的内容由操作系统管理。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207212128486.png"></p>
<h2 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h2><p>概念上而言，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是<strong>字节数组</strong>。每个字节都有一个唯一的虚拟地址作为数组的索引。磁盘上活动的数组内容被缓存在主存中。在存储器结构中，较低层次上的磁盘的数据被分割成块，这些块作为和较高层次的主存之间的传输单元。<strong>主存作为虚拟内存的缓存</strong>。</p>
<p>虚拟内存被分割为大小固定的块，这些块叫<strong>虚拟页</strong>（Virtual Page，VP），类似的物理内存也有<strong>物理页</strong>(Physical Page, PP)。虚拟页有三种不同的状态：</p>
<ul>
<li>未分配：VM 系统还未分配 (或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就<strong>不占用任何磁盘空间</strong>。</li>
<li>已缓存：当前已缓存在物理内存中的已分配页。</li>
<li>未缓存：未缓存在物理内存中的已分配页。</li>
</ul>
<p>为了有助于清晰理解存储层次结构中不同的缓存概念，我们将使用术语<strong>SRAM</strong>缓存来表示位于 CPU 和主存之间的 Ll、L2 和 L3 <strong>高速缓存</strong>，并且用术语 <strong>DRAM</strong> 缓存来表示<strong>虚拟内存系统的缓存</strong>，它在主存中缓存虚拟页。</p>
<p>在存储层次结构中，DRAM 缓存的位置对它的组织结构有很大的影响。回想一下，DRAM 比 SRAM 要慢大约 10 倍，而磁盘要比 DRAM 慢大约 100000 多倍。因此，<strong>DRAM 缓存中的不命中比起 SRAM 缓存中的不命中要昂贵得多</strong>。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。（这些替换算法超出了我们的讨论范围）。最后，因为对磁盘的访问时间很长，<strong>DRAM 缓存总是使用写回，而不是直写</strong>。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟内存系统可以完成以下这些功能，</p>
<ul>
<li>判定一个虚拟页是否缓存在 DRAM 中的某个地方；</li>
<li>可以确定这个虚拟页存放在哪个物理页中；</li>
<li>如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。</li>
</ul>
<p>这些功能是由<strong>软硬件联合提供的</strong>，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和一个<strong>存放在物理内存中叫做页表</strong>（page table）的数据结构。页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<p>图 9-4 展示了一个页表的基本组织结构。页表就是一个页表条目（Page Table Entry，PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p>PTE 由两部分组成：</p>
<ul>
<li>有效位：表明了该虚拟页当前是否被缓存在 DRAM 中；</li>
<li>地址：表示 DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208122157633.png"></p>
<h3 id="页命中与缺页"><a href="#页命中与缺页" class="headerlink" title="页命中与缺页"></a>页命中与缺页</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208130940717.png">l</p>
<p>当 CPU 访问已被缓存的地址时，就叫做<strong>页命中</strong>。如访问上图 VP2，虚拟地址索引到 PTE2，此时有效位为 1，地址翻译硬件就知道该地址被缓存了。</p>
<p>当 CPU 访问未被缓存的地址时，会导致<strong>缺页</strong>。如访问上图的 VP3，虚拟地址索引到 PTE3，此时有效位为 0，地址翻译硬件就知道该地址未被缓存，需要从磁盘中读取。</p>
<p>这时会触发一个<strong>缺页异常</strong>。<strong>缺页异常调用内核中的缺页异常处理程序</strong>，该程序会选择一个牺牲页，在此例中就是存放在 PP 3 中的 VP 4。如果 VP 4 已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改 VP 4 的页表条目，反映出 VP 4 不再缓存在主存中这一事实。</p>
<p>接下来，内核从磁盘复制 VP 3 到内存中的 PP 3，更新 PTE 3，随后返回。当异常处理程序返回时，它会<strong>重新启动导致缺页的指令</strong>，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP 3 已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图 9-7 展示了在缺页之后我们的示例页表的状态。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131434643.png"></p>
<p>在虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做<strong>交换</strong>（swapping）或者<strong>页面调度</strong>（paging）。页从磁盘换入（或者页面调入）DRAM 和从 DRAM 换出（或者页面调出）磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度（demand paging）。</p>
<h2 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h2><p>之前我们只讨论了一个页表的情况，但是实际上操作系统为<strong>每个进程都分配了一个独立的页表</strong>。多个虚拟页面可以映射到同一个共享物理页面上。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131441255.png"></p>
<p>按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。特别地，VM 简化了链接和加载、代码和数据共享，以及应用程序的内存分配。</p>
<ul>
<li><strong>简化链接</strong>。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而<strong>不管代码和数据实际存放在物理内存的何处</strong>。例如，一个给定的 Linux 系统上的每个进程都使用类似的内存格式。对于 64 位地址空间，代码段总是从虚拟地址 0x400000 开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，<strong>允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的</strong>。</li>
<li><strong>简化加载</strong>。虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中 .text 和 .data 节加载到一个新创建的进程中，Linux 加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。有趣的是，加载器从不从磁盘到内存实际复制任何数据。在每个页初次被引用时，要么是 CPU 取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作内存映射（memory mapping）。Linux 提供一个称为 mmap 的系统调用，允许应用程序自己做内存映射。</li>
<li><strong>简化共享</strong>。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。</li>
<li><strong>简化内存分配</strong>。虚拟内存为向用户进程提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如调用 malloc 的结果），<strong>操作系统分配一个适当数字（例如 k）个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的 k 个任意的物理页面</strong>。由于页表工作的方式，操作系统没有必要分配 k 个连续的物理内存页面。<strong>页面可以随机地分散在物理内存中</strong>。</li>
</ul>
<h2 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h2><p>操作系统中的用户程序不应该修改只读的代码段，也不应该读取或者修改内核中的代码和数据结构或者访问私有的以及其他的进程的内存，如果无法对用户进程的内存访问进行限制，攻击者就可以访问和修改其他进程的内存影响系统的安全。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131522719.png"></p>
<p>通过在页表中添加页面的保护属性，可以让操作系统在页面被访问时进行检查，如果页面被保护为只读，则操作系统会报错。</p>
<p>在图 9-10 这个示例中，每个 PTE 中已经添加了三个许可位。SUP 位表示进程是否必须运行在内核（超级用户）模式下才能访问该页。运行在内核模式中的进程可以访问任何页面，但是运行在用户模式中的进程只允许访问那些 SUP 为 0 的页面。READ 位和 WRITE 位控制对页面的读和写访问。例如，如果进程 i 运行在用户模式下，那么它有读 VP 0 和读写 VP 1 的权限。然而，不允许它访问 VP 2。</p>
<p>如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell 一般将这种异常报告为<strong>段错误</strong>（segmentation fault）。</p>
<h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>基本参数</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$$\small N=2^n$$</td>
<td align="left">虚拟地址空间中的地址数量</td>
</tr>
<tr>
<td align="left">$$\small M=2^m$$</td>
<td align="left">物理地址空间中的地址数量</td>
</tr>
<tr>
<td align="left">$$\small P=2^p$$</td>
<td align="left">页的大小（字节）</td>
</tr>
</tbody></table>
<p>虚拟地址（VA）的组成部分</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">VPO</td>
<td align="left">虚拟页面偏移量（字节）</td>
</tr>
<tr>
<td align="left">VPN</td>
<td align="left">虚拟页号</td>
</tr>
<tr>
<td align="left">TLBI</td>
<td align="left">TLB 索引</td>
</tr>
<tr>
<td align="left">TLBT</td>
<td align="left">TLB 标记</td>
</tr>
</tbody></table>
<p>物理地址（PA）的组成部分</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PPO</td>
<td align="left">物理页面偏移量（字节）</td>
</tr>
<tr>
<td align="left">PPN</td>
<td align="left">物理页号</td>
</tr>
<tr>
<td align="left">CO</td>
<td align="left">缓冲块内的字节偏移量</td>
</tr>
<tr>
<td align="left">CI</td>
<td align="left">高速缓存索引</td>
</tr>
<tr>
<td align="left">CT</td>
<td align="left">高速缓存标记</td>
</tr>
</tbody></table>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131527131.png"></p>
<p>图 9-12 展示了 MMU 如何利用页表来实现地址翻译。CPU 中的一个控制寄存器，<strong>页表基址寄存器</strong>（Page Table Base Register，PTBR）指向当前页表。$n$ 位的虚拟地址包含两个部分：一个 $p$ 位的<strong>虚拟页面偏移</strong>（Virtual Page Offset，VPO）和一个$\small (n-p)$位的<strong>虚拟页号</strong>（Virtual Page Number，VPN）。MMU 利用 VPN 来选择适当的 PTE。例如，VPN 0 选择 PTE 0，VPN 1 选择 PTE 1，以此类推。将页表条目中<strong>物理页号</strong>（Physical Page Number，PPN）和虚拟地址中的 VP。串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是 P 字节的，所以<strong>物理页面偏移（Physical Page Offset，PPO）和 VPO 是相同的</strong>。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131527491.png"></p>
<p>图 9-13a 展示了当页面命中时，CPU 硬件执行的步骤。</p>
<ul>
<li>第 1 步：处理器生成一个<br>虚拟地址，并把它传送给 MMU。</li>
<li>第 2 步：MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。</li>
<li>第 3 步：高速缓存/主存向 MMU 返回 PTE。</li>
<li>第 4 步：MMU 构造物理地址，并把它传送给高速缓存/主存。</li>
<li>第 5 步：高速缓存/主存返回所请求的数据字给处理器。</li>
</ul>
<p>页面命中完全是由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成，如图 9-13b 所示。</p>
<ul>
<li>第 1 - 3 步：和图 9-13a 中的第 1 步到第 3 步相同。</li>
<li>第 4 步：PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。</li>
<li>第 5 步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li>
<li>第 6 步：缺页处理程序页面调入新的页面，并更新内存中的 PTE。</li>
<li>第 7 步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给 MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，在 MMU 执行了图 9-13b 中的步骤之后，主存就会将所请求字返回给处理器。</li>
</ul>
<h3 id="利用-TLB-加速地址翻译"><a href="#利用-TLB-加速地址翻译" class="headerlink" title="利用 TLB 加速地址翻译"></a>利用 TLB 加速地址翻译</h3><p>每次 CPU 访问一个虚拟地址，MMU 就必须查找 PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。如果 PTE 碰巧缓存在 L1 中，那么开销就下降到 1 个或 2 个周期。为了消除这样的开销，在 MMU 中包括了一个关于 PTE 的小的缓存，称为<strong>翻译后备缓冲器</strong>（Translation Lookaside Buffer，TLB）。</p>
<p>TLB 是一个小的、虚拟寻址的缓存，其中<strong>每一行都保存着一个由单个 PTE 组成的块</strong>。TLB 通常有高度的相联度。如图 9-15 所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果 TLB 有$\small T = 2^t$个组，那么 <strong>TLB 索引</strong>（TLBI）是由 VPN 的 $t$ 个最低位组成的，而 <strong>TLB 标记</strong>（TLBT）是由 VPN 中剩余的位组成的。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131546427.png"></p>
<p>图 9-16a 展示了当 TLB 命中时（通常情况）所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的 MMU 中执行的，因此非常快。</p>
<ul>
<li>第 1 步：CPU 产生一个虚拟地址。</li>
<li>第 2 - 3 步：MMU 从 TLB 中取出相应的 PTE。</li>
<li>第 4 步：MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</li>
<li>第 5 步：高速缓存/主存将所请求的数据字返回给 CPU。</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131547576.png"></p>
<p>当 TLB 不命中时，MMU 必须从 L1 缓存中取出相应的 PTE，如图 9-16b 所示。新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了。</p>
<p>页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。</p>
<p>那怎么办呢？我们可以试着将页表再分页，4G 的空间需要 4M 的页表来存储映射。我们把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K。</p>
<p>页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置。</p>
<p>这样加起来正好 32 位，也就是用前 10 位定位到页目录表中的一项。将这一项对应的页表取出来共 1k 项，再用中间 10 位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后 12 位定位到页中的具体位置访问数据。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129192245.png"></p>
<p>你可能会问，如果这样的话，映射 4GB 地址空间就需要 4MB+4KB 的内存，这样不是更大 了吗？当然如果页是满的，当时是更大了，但是，我们往往不会为一个进程分配那么多内 存。<br>比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完 整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省多了</p>
<p>当然对于 64 位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间<br>页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。也就是一级页表，二级页表，三级页表，四级页表。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131820091.png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/07/16/C%E8%AF%AD%E8%A8%80getopt-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/" itemprop="url">C 语言 getopt() 函数的用法</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-07-16T14:42:03.000Z" itemprop="datePublished">7月 16 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 分钟 读完 (约 1088 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>在做<a target="_blank" rel="noopener" href="https://dunky-z.github.io/2022/07/11/CSAPP-LAB-Cache-Lab/">CSAPP_LAB-Cache Lab</a>时，实验要求对输入参数进行处理，如程序<code>csim</code>执行需要 4 个参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim -s 4 -E 6 -b 4 -t &lt;tracefile&gt;<br></code></pre></td></tr></table></figure>

<p>原先想通过字符串解析，一个个处理，但是看到了其他参考代码后发现了一个更简单的方法，可以通过<code>getopt()</code>函数来解析参数。</p>
<p>函数的功能：解析命令行参数。<br>头文件 <code>#include &lt;unistd.h&gt;</code></p>
<p>在学习函数前需要了解与该函数相关的四个变量：</p>
<ul>
<li><p><code>int opterr</code>：控制是否输出错误；<br>如果此变量的值非零，则 <code>getopt</code> 在遇到未知选项字符或缺少必需参数的选项时将错误消息打印到标准错误流 (终端)。该值默认为非零。如果将此变量设置为零，<code>getopt</code> 不会打印任何消息，但仍会返回问号<code>?</code>提示错误。</p>
</li>
<li><p><code>int optopt</code>：保存未知的选项；<br>当 <code>getopt</code> 遇到未知选项字符或缺少必需参数的选项时，它将该选项字符存储在此变量中。</p>
</li>
<li><p><code>int optind</code>：指向下一个要处理的参数；<br>此变量由 <code>getopt</code> 设置为要处理的 <code>argv</code> 数组的下一个元素的索引。一旦 <code>getopt</code> 找到所有选项参数，就可以使用此变量来确定其余非选项参数的开始位置。该变量的初始值为 1。</p>
</li>
<li><p><code>char * optarg</code>：保存选项参数；<br>对于那些接受参数的选项，此变量由 <code>getopt</code> 设置为指向选项参数的值。</p>
</li>
</ul>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * options)</span></span>;<br></code></pre></td></tr></table></figure>

<p>参数解析：</p>
<ul>
<li>参数<code>argc</code> 和<code>argv</code> 是由<code>main()</code>传递的参数个数和内容。</li>
<li><code>options</code> 参数是一个字符串，它指定对该程序有效的选项字符。此字符串中的选项字符后面可以跟一个冒号（<code>:</code>），表示它需要一个<strong>必需的参数</strong>，这个参数可以与选项连写也可以空格分开，如<code>-a13 or  -a 13</code>。如果选项字符后跟两个冒号（<code>::</code>），则其参数是<strong>可选的</strong>，如果有参数，那么参数不能与选项分割，如只能写成<code>-a13</code>而不能写成<code>-a 13</code>；这是一个 GNU 扩展。</li>
</ul>
<p>实例：</p>
<p>下面是一个示例，展示了通常如何使用 <code>getopt</code>。需要注意的关键点是：</p>
<ul>
<li>通常，<code>getopt</code> 在循环中被调用。当 <code>getopt</code> 返回 <code>-1</code> 表示没有更多选项存在时，循环终止。</li>
<li><code>switch</code> 语句用于调度 <code>getopt</code> 的返回值。在典型使用中，每种情况只设置一个稍后在程序中使用的变量。</li>
<li>第二个循环用于处理剩余的非选项参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> aflag = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> bflag = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">char</span> *cvalue = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">int</span> index;<br>  <span class="hljs-keyword">int</span> c;<br><br>  opterr = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> ((c = getopt (argc, argv, <span class="hljs-string">&quot;abc:&quot;</span>)) != <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">switch</span> (c)<br>      &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>        aflag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>        bflag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>        cvalue = optarg;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (optopt == <span class="hljs-string">&#x27;c&#x27;</span>)<br>          <span class="hljs-built_in">fprintf</span> (<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Option -%c requires an argument.\n&quot;</span>, optopt);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isprint</span> (optopt))<br>          <span class="hljs-built_in">fprintf</span> (<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unknown option `-%c&#x27;.\n&quot;</span>, optopt);<br>        <span class="hljs-keyword">else</span><br>          <span class="hljs-built_in">fprintf</span> (<span class="hljs-built_in">stderr</span>,<br>                   <span class="hljs-string">&quot;Unknown option character `\\x%x&#x27;.\n&quot;</span>,<br>                   optopt);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">abort</span> ();<br>      &#125;<br><br>  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;aflag = %d, bflag = %d, cvalue = %s\n&quot;</span>,<br>          aflag, bflag, cvalue);<br><br>  <span class="hljs-keyword">for</span> (index = optind; index &lt; argc; index++)<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Non-option argument %s\n&quot;</span>, argv[index]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以下是一些示例，展示了该程序使用不同的参数组合打印的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C">% testopt<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br><br><span class="hljs-comment">// 选项可以用空格分割</span><br>% testopt -a -b<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">1</span>, cvalue = (null)<br><br><span class="hljs-comment">// 也可以连写</span><br>% testopt -ab<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">1</span>, cvalue = (null)<br><br><span class="hljs-comment">// 必选参数，可以用空格分割</span><br>% testopt -c foo<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = foo<br><br><span class="hljs-comment">// 必选参数，可以连写</span><br>% testopt -cfoo<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = foo<br><br><span class="hljs-comment">// 没有对应的选项</span><br>% testopt arg1<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument arg1<br><br><span class="hljs-comment">// -a选项没有需要处理的参数，所以arg1无法处理</span><br>% testopt -a arg1<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument arg1<br><br>% testopt -c foo arg1<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = foo<br>Non-option argument arg1<br><br>% testopt -a -- -b<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument -b<br><br>% testopt -a -<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument -<br></code></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huangxiaohu_coder/article/details/7475156">原来命令行参数处理可以这么写-getopt？_huangxiaohu_coder 的博客-CSDN 博客</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingergege/p/5914218.html">Linux 下 getopt() 函数的简单使用 - 青儿哥哥 - 博客园</a><br><a target="_blank" rel="noopener" href="http://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html">Using Getopt (The GNU C Library)</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/07/12/%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E5%90%AF%E7%94%A8ACPI%E7%9A%84%E5%86%85%E6%A0%B8/" itemprop="url">构建和测试 RISC-V 架构下启用 ACPI 的内核</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-07-12T07:06:51.000Z" itemprop="datePublished">7月 12 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            11 分钟 读完 (约 1585 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>参考自<a target="_blank" rel="noopener" href="https://github.com/riscv-non-isa/riscv-acpi/wiki/PoC-:-How-to-build-and-test-ACPI-enabled-kernel">PoC : How to build and test ACPI enabled kernel · riscv-non-isa/riscv-acpi Wiki</a></p>
</blockquote>
<h2 id="准备环境及工具链"><a href="#准备环境及工具链" class="headerlink" title="准备环境及工具链"></a>准备环境及工具链</h2><ol>
<li><p>安装 RISC-V 工具链，需下载原发行版。好在 apt 可以安装。</p>
<blockquote>
<p>如果报错：riscv64-linux-gnu-gcc: error: unrecognized command line option ‘-mno-relax’; did you mean ‘-Wno-vla’?，多半是工具链原因，请按照以下方法安装！！！</p>
</blockquote>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt remove gcc-riscv64-linux-gnu<br>sudo apt install gcc-8-riscv64-linux-gnu<br></code></pre></td></tr></table></figure></li>
<li><p>安装必要的三方库，以下为Ubuntu下的命令，其他平台可以参考<a target="_blank" rel="noopener" href="https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html#prerequisites">这个文档</a>。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \<br>                gawk build-essential bison flex texinfo gperf libtool patchutils bc \<br>                zlib1g-dev libexpat-dev git<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>可能无法一次搭建成功，一些环境变量会经常用到，所以干脆把所有环境变量放到<code>.bashrc</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vim ~/.bashrc<br><span class="hljs-comment"># 添加以下内容</span><br><span class="hljs-built_in">export</span> WORK_DIR=~/riscv64-acpi<br><span class="hljs-built_in">export</span> GCC5_RISCV64_PREFIX=riscv64-unknown-elf-<br><span class="hljs-built_in">export</span> MAINSPACE=~/riscv64-acpi/tianocore<br><span class="hljs-built_in">export</span> PACKAGES_PATH=<span class="hljs-variable">$MAINSPACE</span>/edk2:<span class="hljs-variable">$MAINSPACE</span>/edk2-platforms<br><span class="hljs-built_in">export</span> EDK_TOOLS_PATH=<span class="hljs-variable">$MAINSPACE</span>/edk2/BaseTools<br><br></code></pre></td></tr></table></figure>

<p>首先，创建一个工作目录，我们将在其中下载并构建所有源代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">source</span> ~/.bashrc<br>WORK_DIR=<span class="hljs-variable">$PWD</span>/riscv64-acpi<br>mkdir -p <span class="hljs-variable">$WORK_DIR</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span><br></code></pre></td></tr></table></figure>

<p>然后下载所有需要的源，它们是：<a target="_blank" rel="noopener" href="https://github.com/ventanamicro/qemu/tree/dev-upstream">qemu</a>、<a target="_blank" rel="noopener" href="https://github.com/ventanamicro/opensbi/tree/dev-upstream">opensbi</a>、<a target="_blank" rel="noopener" href="https://github.com/ventanamicro/edk2/tree/dev-upstream">edk2</a>、<a target="_blank" rel="noopener" href="https://github.com/ventanamicro/edk2-platforms/tree/dev-upstream">edk2-platforms</a>、<a target="_blank" rel="noopener" href="https://github.com/ventanamicro/linux/tree/dev-upstream">linux</a>。</p>
<p>下载地址更换成了加速镜像源，原来地址下载太慢，容易中断。下载地址更换成了加速镜像源，原来地址下载太慢，容易中断。有两个项目包含子模块，下载容易出错，所以<code>--depth=1</code>舍弃了多余的提交记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">clone</span> --branch dev-upstream  https://hub.fastgit.xyz/ventanamicro/qemu.git qemu<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream  https://hub.fastgit.xyz/ventanamicro/opensbi.git opensbi<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream --recurse-submodules --depth=1  https://hub.fastgit.xyz/ventanamicro/edk2.git tianocore/edk2<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream --recurse-submodules --depth=1  https://hub.fastgit.xyz/ventanamicro/edk2-platforms.git  tianocore/edk2-platforms<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream  https://hub.fastgit.xyz/ventanamicro/linux.git linux<br></code></pre></td></tr></table></figure>

<h2 id="编译构建"><a href="#编译构建" class="headerlink" title="编译构建"></a>编译构建</h2><h3 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/qemu<br>./configure --target-list=riscv64-softmmu<br>make -j $(nproc)<br></code></pre></td></tr></table></figure>

<h3 id="OPENSBI"><a href="#OPENSBI" class="headerlink" title="OPENSBI"></a>OPENSBI</h3><blockquote>
<p>此处我们使用以<code>riscv64-unknown-elf-</code>为前缀的版本，则表示该版本GCC工具链会使用newlib作为C运行库。原文使用<code>riscv64-linux-gnu-</code>，表示GCC工具链会使用Linux的Glibc作为C运行库。但是本人未编译成功。故后面编译工具均使用<code>riscv64-unknown-elf-</code>，与原文不同。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/opensbi<br>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- make PLATFORM=generic<br></code></pre></td></tr></table></figure>

<h3 id="EDK2-固件"><a href="#EDK2-固件" class="headerlink" title="EDK2 固件"></a>EDK2 固件</h3><blockquote>
<p>此处原文里设置了一些环境变量在开头我们设置了，请不要重新设置，尤其不能<code>export WORKSPACE=pwd</code>，因为与源码脚本的WORKSPACE冲突。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/tianocore<br><span class="hljs-built_in">source</span> edk2/edksetup.sh<br>make -C edk2/BaseTools clean<br>make -C edk2/BaseTools<br>make -C edk2/BaseTools/Source/C<br><span class="hljs-built_in">source</span> edk2/edksetup.sh BaseTools<br><span class="hljs-comment"># 原文使用 -buildtarget RELEASE。但是提示 Not supported target RELEASE</span><br>build -a RISCV64 -b DEBUG -D FW_BASE_ADDRESS=0x80200000 -D EDK2_PAYLOAD_OFFSET -p Platform/Qemu/RiscvVirt/RiscvVirt.dsc -t GCC5<br></code></pre></td></tr></table></figure>

<h4 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h4><ol>
<li><p><strong>StoreCurrentConfiguration:7: no such file or directory: /home/user/riscv64-acpi/tianocore/Conf/BuildEnv.sh</strong></p>
<p> 不要设置<code>export WORKSPACE=pwd</code>！！！如果所有方法都不可行，直接把路径写死<code>export CONF_PATH=$WORK_DIR/tianocore/edk2/Conf</code></p>
</li>
<li><p><strong>uuid/uuid.h: No such file or directory</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install uuid-dev<br></code></pre></td></tr></table></figure></li>
<li><p><strong>Not supported target RELEASE</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 将build命令改为如下，使用DEBUG版本。</span><br>build -a RISCV64 -b DEBUG -D FW_BASE_ADDRESS=0x80200000 -D EDK2_PAYLOAD_OFFSET -p Platform/Qemu/RiscvVirt/RiscvVirt.dsc -t GCC5<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/linux<br>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- defconfig<br>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- -j $(nproc)<br></code></pre></td></tr></table></figure>

<h3 id="Rootfs"><a href="#Rootfs" class="headerlink" title="Rootfs"></a>Rootfs</h3><p>您可以使用您选择的任何 rootfs。此示例使用 buildroot。</p>
<blockquote>
<p>此步耗时较久，与网络环境有关，如果网络不好可能按小时算。容易中断，需要重新下载。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/<br>git <span class="hljs-built_in">clone</span> https://hub.fastgit.xyz/buildroot/buildroot.git<br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/buildroot<br>make qemu_riscv64_virt_defconfig<br>make rootfs-cpio<br></code></pre></td></tr></table></figure>

<h2 id="创建-EFI-分区并复制文件"><a href="#创建-EFI-分区并复制文件" class="headerlink" title="创建 EFI 分区并复制文件"></a>创建 EFI 分区并复制文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash">fallocate -l 512M efi.img<br>sgdisk -n 1:34: -t 1:EF00 <span class="hljs-variable">$WORK_DIR</span>/efi.img<br>sudo losetup -fP <span class="hljs-variable">$WORK_DIR</span>/efi.img<br>loopdev=`losetup -j <span class="hljs-variable">$WORK_DIR</span>/efi.img | awk -F: <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`<br>efi_part=<span class="hljs-string">&quot;<span class="hljs-variable">$loopdev</span>&quot;</span>p1<br>sudo mkfs.msdos <span class="hljs-variable">$efi_part</span><br>mkdir -p /tmp/mnt<br>sudo mount <span class="hljs-variable">$efi_part</span> /tmp/mnt/<br>sudo cp <span class="hljs-variable">$WORK_DIR</span>/linux/arch/riscv/boot/Image /tmp/mnt/<br>sudo umount /tmp/mnt<br>sudo losetup -D <span class="hljs-variable">$loopdev</span><br></code></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="使用-virtio-blk-磁盘"><a href="#使用-virtio-blk-磁盘" class="headerlink" title="使用 virtio-blk 磁盘"></a>使用 virtio-blk 磁盘</h3><blockquote>
<p>原文参数<code>-drive file=$WORK_DIR/buildroot/output/images/rootfs.ext2,format=raw,id=hd0</code>需要更改如下。因为在编译 Rootfs 时的命令是<code>make rootfs-cpio</code>所以生成的是<code>rootfs.cpio</code>。无法找到<code>rootfs.ext2</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-variable">$WORK_DIR</span>/qemu/build/qemu-system-riscv64 -nographic \<br>-machine virt,aclint=on,aia=aplic-imsic,acpi=on -cpu rv64,sscofpmf=<span class="hljs-literal">true</span> -smp 8  -m 2G  \<br>-bios <span class="hljs-variable">$WORK_DIR</span>/opensbi/build/platform/generic/firmware/fw_jump.elf \<br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd  \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.cpio,format=raw,id=hd0 \<br>-device virtio-blk-device,drive=hd0 \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/efi.img,format=raw,id=hd1 \<br>-device virtio-blk-device,drive=hd1 \<br>-device virtio-net-device,netdev=usernet \<br>-netdev user,id=usernet,hostfwd=tcp::9990-:22<br></code></pre></td></tr></table></figure>

<h4 id="ERROR-1"><a href="#ERROR-1" class="headerlink" title="ERROR"></a>ERROR</h4><ol>
<li><p>无法找到<code>rootfs.ext2</code></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 因为在编译 Rootfs 时的命令是 make rootfs-cpio 所以生成的是 rootfs.cpio</span><br><span class="hljs-comment"># 原文参数</span><br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.ext2,format=raw,id=hd0 \<br><span class="hljs-comment"># 修改为</span><br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.cpio,format=raw,id=hd0 \<br></code></pre></td></tr></table></figure></li>
<li><p>无法找到<code>RISCVVIRT.fd</code></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 因为编译 EDK2 固件时，参数是-b DEBUG 版本，原文是 RELEASE 版本，这两个版本路径不一样，所以找不到</span><br><span class="hljs-comment"># 原文参数</span><br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/RELEASE_GCC5/FV/RISCVVIRT.fd  \<br><span class="hljs-comment"># 修改为</span><br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd  \<br></code></pre></td></tr></table></figure></li>
</ol>
<p>At EFI Shell:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Shell&gt; fs0:\Image root=/dev/vdb console=ttyS0 rootwait earlycon<br></code></pre></td></tr></table></figure>

<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713153915.bmp"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713153932.bmp"></p>
<h3 id="使用-virtio-scsi-磁盘"><a href="#使用-virtio-scsi-磁盘" class="headerlink" title="使用 virtio-scsi 磁盘"></a>使用 virtio-scsi 磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-variable">$WORK_DIR</span>/qemu/build/qemu-system-riscv64 -nographic \<br>-machine virt,aclint=on,aia=aplic-imsic,acpi=on -cpu rv64,ssofpmf=<span class="hljs-literal">true</span> -smp 8  -m 2G \<br>-bios <span class="hljs-variable">$WORK_DIR</span>/opensbi/build/platform/generic/firmware/fw_jump.elf \<br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd  \<br>-device virtio-scsi-pci,id=scsi0,num_queues=4 \<br>-device scsi-hd,drive=drive0,bus=scsi0.0,channel=0,scsi-id=0,lun=0 \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.cpio,format=raw,<span class="hljs-keyword">if</span>=none,id=drive0 \<br>-device virtio-scsi-pci,id=scsi1,num_queues=4 \<br>-device scsi-hd,drive=drive1,bus=scsi0.0,channel=0,scsi-id=1,lun=0 \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/efi.img,format=raw,<span class="hljs-keyword">if</span>=none,id=drive1 \<br>-device virtio-net-device,netdev=usernet \<br>-netdev user,id=usernet,hostfwd=tcp::9990-:22<br></code></pre></td></tr></table></figure>

<p>At EFI Shell:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Shell&gt; fs0:\Image root=/dev/sda console=ttyS0 rootwait earlycon<br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/07/11/CSAPP-LAB-Cache-Lab/" itemprop="url">CSAPP-LAB-Cache Lab</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-07-11T01:55:39.000Z" itemprop="datePublished">7月 11 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/CSAPP-Lab/">CSAPP-Lab</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            11 分钟 读完 (约 1644 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>开始这个实验前，需要学习《CSAPP 第六章-存储器层次结构》的相关内容，与缓存相关的内容，我也做了相关的<a target="_blank" rel="noopener" href="https://dunky-z.github.io/2022/07/10/CPU-Cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/">CPU Cache 高速缓存学习记录</a>可以参考。</p>
<p>实验相关的文件可以从<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/labs.html">CS:APP3e, Bryant and O’Hallaron</a>下载。</p>
<p>其中，</p>
<ul>
<li>README：介绍实验目的和实验要求，以及实验的相关文件。需要注意的是，必须在 64-bit x86-64 system 上运行实验。需要安装 Valgrind 工具。</li>
<li>Writeup：实验指导。</li>
<li>Release Notes：版本发布信息。</li>
<li>Self-Study Handout：<strong>需要下载的压缩包</strong>，里面包含了待修改的源码文件等。</li>
</ul>
<p>下载 Self-Study Handout 并解压，得到如下文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── cachelab.c    <span class="hljs-comment"># 一些辅助函数，如打印输出等，不需要修改</span><br>├── cachelab.h    <span class="hljs-comment"># 同上</span><br>├── csim.c        <span class="hljs-comment"># 需要完善的主文件，需要在这里模拟Cache</span><br>├── csim-ref      <span class="hljs-comment"># 已经编译好的程序，我们模拟的Cache需要与这个程序运行的结果保持一致</span><br>├── driver.py     <span class="hljs-comment"># 驱动程序，运行 test-csim 和 test-trans</span><br>├── Makefile      <span class="hljs-comment"># 用来编译csim程序</span><br>├── README        <span class="hljs-comment"># </span><br>├── test-csim     <span class="hljs-comment"># 测试缓存模拟器</span><br>├── test-trans.c  <span class="hljs-comment"># 测试转置功能</span><br>├── tracegen.c    <span class="hljs-comment"># test-trans 辅助程序</span><br>├── traces        <span class="hljs-comment"># test-csim.c 使用的跟踪文件</span><br>│   ├── dave.trace<br>│   ├── long.trace<br>│   ├── trans.trace<br>│   ├── yi2.trace<br>│   └── yi.trace<br>└── trans.c<br></code></pre></td></tr></table></figure>

<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711145159.png"></p>
<h2 id="Part-A-——-Writing-A-Cache-Simulator"><a href="#Part-A-——-Writing-A-Cache-Simulator" class="headerlink" title="Part A —— Writing A Cache Simulator"></a>Part A —— Writing A Cache Simulator</h2><p>在 Part A，我们将在 <code>csim.c</code> 中编写一个缓存模拟器，它将 <code>valgrind</code> 内存跟踪作为输入，在此跟踪上模拟高速缓存的命中/未命中行为，并输出命中、未命中和驱逐的总数。</p>
<p>这里的输入由<code>valgrind</code>通过以下命令生成的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l<br></code></pre></td></tr></table></figure>

<p><code>--log-fd=1</code>表示将输出输出到标准输出；<br><code>--tool=lackey</code>：Lackey 是一个简单的 Valgrind 工具，可进行各种基本程序测量；<br><code>--trace-mem=yes</code>：Lackey 的一个参数，启用后，Lackey 会打印程序几乎所有内存访问的大小和地址；<br><code>ls -l</code>：是一个简单的程序，可以查看当前目录下的文件列表。<br>也就是检测<code>ls -l</code>程序在运行时访问内存的情况。</p>
<p>执行结果像下面的形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># [space]operation address,size</span><br>I  0400639c,4<br> L 1ffeffec00,8<br>I  040063a0,2<br> S 1ffeffea50,8<br>I  040063a2,4<br> L 1ffeffebf0,8<br>I  040063a6,3<br>I  040063a9,3<br> L 1ffeffebf8,4<br>I  040063ac,7<br></code></pre></td></tr></table></figure>

<p>操作字段表示内存访问的类型：<code>I</code>表示指令加载，<code>L</code>表示数据加载，<code>S</code>表示数据存储，<code>M</code>表示数据修改（即，数据加载后跟数据存储） ）。每个<code>I</code>之前都没有空格。每个<code>M</code>、<code>L</code>和<code>S</code>之前总是有一个空格。地址字段指定一个 <code>64</code> 位的十六进制内存地址。 <code>size</code> 字段指定操作访问的字节数。</p>
<p>了解这些基础后，<strong>我们最主要的是要明确，我们需要实现一个什么样的程序，这个程序具体有哪些参数，怎么执行的</strong>。<code>csim-ref</code>是已经完成的可执行文件，它的用法是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>-h</code>：打印帮助信息；</li>
<li><code>-v</code>：显示详细信息，如是 I，L 还是 M；</li>
<li><code>-s &lt;s&gt;</code>：组索引位数（$S=2^{s}$组个数）；</li>
<li><code>-E &lt;E&gt;</code>：关联性（每组的行数）；</li>
<li><code>-b &lt;b&gt;</code>：块位数（$B=2^{b}$ 是块大小）；</li>
<li><code>-t &lt;tracefile&gt;</code>：valgrind 生成的文件；</li>
</ul>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace<br>hits:4 misses:5 evictions:3<br></code></pre></td></tr></table></figure>

<p>如果显示详细信息可以执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace<br>L 10,1 miss<br>M 20,1 miss hit<br>L 22,1 hit<br>S 18,1 hit<br>L 110,1 miss eviction<br>L 210,1 miss eviction<br>M 12,1 miss eviction hit<br>hits:4 misses:5 evictions:3<br></code></pre></td></tr></table></figure>

<p>我们的目的就是要完善<code>csim.c</code>，使其能够使用上面相同的参数，得到与<code>csim-ref</code>相同的结果。<br><a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">Cache Lab Implementa/on and Blocking</a>这份 PPT 里有一些实验指导，可以参考。<br>首先需要解决的就是如何处理输入的参数，我们可以使用 PPT 里提到的<code>getopt</code>库来解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;cachelab.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;getopt.h&quot;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> S; <span class="hljs-comment">// 组个数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s; <span class="hljs-comment">// 组占的位数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> E;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> B;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> hits = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> misses = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> evictions = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CacheLine</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> tag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CacheLine</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CacheLine</span> *<span class="hljs-title">prev</span>;</span><br>&#125; CacheLine;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Cache</span> &#123;</span><br>    CacheLine *head;<br>    CacheLine *tail;<br>    <span class="hljs-keyword">int</span> *size;<br>&#125; Cache;<br><br><span class="hljs-keyword">static</span> Cache *cache;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parse_option</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **fileName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> option;<br>    <span class="hljs-keyword">while</span> ((option = getopt(argc, argv, <span class="hljs-string">&quot;s:E:b:t:&quot;</span>)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">switch</span> (option) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>            s = atoi(optarg);<br>            <span class="hljs-comment">// 传入的参数为占用的bit，需要转换为10进制</span><br>            S = <span class="hljs-number">1</span> &lt;&lt; s;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>            E = atoi(optarg);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>            B = atoi(optarg);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            <span class="hljs-built_in">strcpy</span>(*fileName, optarg);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialize_cache</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cache = <span class="hljs-built_in">malloc</span>(S * <span class="hljs-keyword">sizeof</span>(*cache));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<br>        cache[i].head = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CacheLine));<br>        cache[i].tail = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CacheLine));<br><br>        cache[i].head-&gt;next = cache[i].tail;<br>        cache[i].tail-&gt;prev = cache[i].head;<br>        (cache[i].size) = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>        *(cache[i].size) = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * @breif Add a new CacheLine to the Cache first line</span><br><span class="hljs-comment"> * @param nodeToDel CacheLine to be deleted</span><br><span class="hljs-comment"> * @param curLru  Current Cache</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert_first_line</span><span class="hljs-params">(CacheLine *node, Cache *curLru)</span></span><br><span class="hljs-function"></span>&#123;<br>    node-&gt;next = curLru-&gt;head-&gt;next;<br>    node-&gt;prev = curLru-&gt;head;<br><br>    curLru-&gt;head-&gt;next-&gt;prev = node;<br>    curLru-&gt;head-&gt;next = node;<br><br>    *(curLru-&gt;size) = *(curLru-&gt;size) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evict</span><span class="hljs-params">(CacheLine *nodeToDel, Cache *curLru)</span></span><br><span class="hljs-function"></span>&#123;<br>    nodeToDel-&gt;next-&gt;prev = nodeToDel-&gt;prev;<br>    nodeToDel-&gt;prev-&gt;next = nodeToDel-&gt;next;<br>    *(curLru-&gt;size) = *(curLru-&gt;size) - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> address)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0xFFFFFFFF</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> maskSet = mask &gt;&gt; (<span class="hljs-number">32</span> - s);<br>    <span class="hljs-comment">// 取出组索引</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> targetSet = ((maskSet) &amp; (address &gt;&gt; B));<br>    <span class="hljs-comment">// 取出标记</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> targetTag = address &gt;&gt; (s + B);<br><br>    Cache curLru = cache[targetSet];<br><br>    <span class="hljs-comment">// 查找是否存与当前标记位相同的缓存行</span><br>    CacheLine *cur = curLru.head-&gt;next;<br>    <span class="hljs-keyword">bool</span> found = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur != curLru.tail) &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;tag == targetTag) &#123;<br>            found = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (found) &#123;<br>        hits++;<br>        evict(cur, &amp;curLru);<br>        insert_first_line(cur, &amp;curLru);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; hit!, set: %d \n&quot;</span>, targetSet);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        CacheLine *newNode = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CacheLine));<br>        newNode-&gt;tag = targetTag;<br>        <span class="hljs-keyword">if</span> (*(curLru.size) == E) &#123; <span class="hljs-comment">// 如果缓存已满，则删除最后一个缓存行</span><br>            evict(curLru.tail-&gt;prev, &amp;curLru);<br>            insert_first_line(newNode, &amp;curLru);<br>            evictions++;<br>            misses++;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; evic &amp;&amp; miss set:%d\n&quot;</span>, targetSet);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            misses++;<br>            insert_first_line(newNode, &amp;curLru);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; miss %d\n&quot;</span>, targetSet);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cache_simulate</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fileName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 分配并初始化S组缓存</span><br>    initialize_cache();<br><br>    FILE *file = fopen(fileName, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">char</span> op;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(file, <span class="hljs-string">&quot; %c %x,%d&quot;</span>, &amp;op, &amp;address, &amp;size) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c, %x %d\n&quot;</span>, op, address, size);<br>        <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>            update(address);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:<br>            update(address);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>            update(address);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *fileName = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br><br>    parse_option(argc, argv, &amp;fileName);<br>    cache_simulate(fileName);<br>    printSummary(hits, misses, evictions);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="../2/">上一页</a>
    </div>
    <div class="pagination-next">
        <a href="../4/">下一页</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="../../">1</a></li>
        
        <li><a class="pagination-link" href="../2/">2</a></li>
        
        <li><a class="pagination-link is-current" href="">3</a></li>
        
        <li><a class="pagination-link" href="../4/">4</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="../9/">9</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2024 Dominic&nbsp;
                powered_by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>




<script src="../../../../js/script.js"></script>


    
</body>
</html>