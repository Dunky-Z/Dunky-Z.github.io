<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8888&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Linux | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:8888/tags/linux/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:8888/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:8888/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:8888/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:8888/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:8888/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:8888/tags/linux/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:8888/tags/linux/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:8888/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:8888/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:8888/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:8888/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:8888/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:8888/tags/">Tags</a></div>
  <h1>
    Linux
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Linux 操作系统-进程间通信
    </h2>
  </header>
  <div class="entry-content">
    <p>Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。
进程间通信概述 管道 在学 Linux 命令时就有管道在这个概念，比如下面这个命令
ps -ef | -grep root | xargs kill -9 将上一个命令的输出作为下一个命令的输入，数据只能向一个方向流动；双方需要互相通信时，需要建立起两个管道。
管道有两种类型：匿名管道和命名管道。上面提到的命令中|表示的管道即匿名管道 pipe。用完即销毁，自动创建，自动销毁。
使用mkfifo显示创建的是命名管道 fifo，
mkfifo hello hello即是管道名称，类型为p，就是pipe，接下来就可以在管道里写入东西，
# echo &#34;hello world&#34; &gt; hello 光写入还不行，只有有另一个进程读取了内容才完成一次信息交换，才完成一次通信，
# cat &lt; hello hello world 这种方式通信效率低，无法频繁通信。
消息队列 类似于日常沟通使用的邮件，有一定格式，有个收件列表，列表上的用户都可以反复在原邮件基础上回复，达到频繁交流的目的。这种模型就是消息队列模型。
共享内存 共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。
每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存空间映射到不同的物理内存中去。这个进程访问 A 地址和另一个进程访问 A 地址，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。
但是，咱们是不是可以变通一下，拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。
使用shmget函数创建一个共享内存，
//key_t key: 唯一定位一个共享内存对象 //size_t size: 共享内存大小 //int flag: 如果是 IPC_CREAT 表示创建新的共享内存空间 int shmget(key_t key, size_t size, int flag); 创建完毕之后，我们可以通过 ipcs 命令查看这个共享内存。...</p>
  </div>
  <footer class="entry-footer"><span title='2021-08-14 09:46:39 +0000 UTC'>August 14, 2021</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to Linux 操作系统-进程间通信" href="http://localhost:8888/posts/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">每天学命令-rename 批量重命名
    </h2>
  </header>
  <div class="entry-content">
    <p>Commands rename [options] &#34;s/oldname/newname/&#34; file 格式就很容易看出来怎么用的，就是/不能丢。
-v 将重命名的内容都打印到标准输出，v 可以看成 verbose-n 测试会重命名的内容，将结果都打印，但是并不真正执行重命名的过程-f force 会覆盖本地已经存在的文件-h -m -V 分别为帮助，帮助，版本-e 比较复杂，可以通过该选项，写一些脚本来做一些复杂的事情 Examples 替换文件名中的特定字段 rename &#34;s/AA/aa/&#34; * # 把文件名中的AA替换成aa 修改文件后缀 rename &#34;s/.html/.php/&#34; * # 把.html 后缀的改成 .php后缀rename &#34;s/.png/.jpg/&#34; * # 将 png 改为 jpg 添加后缀 rename &#34;s/$/.txt/&#34; * # 把所有的文件名都以txt结尾 $正则表达式中表示结尾。
保留部分文件名 假如需要在批量修改的时候保留部分文件名，可以使用引用\1 ，比如有下面格式的文件，只想保留日期部分。
Screenshot from 2019-01-02 15-56-49.jpgrename -n &#34;s/Screenshot from ([0-9\\- ]&#43;).jpg/\1.jpg/&#34; * 将() 匹配的内容取出来放到替换部分。</p>
  </div>
  <footer class="entry-footer"><span title='2021-08-13 18:40:16 +0000 UTC'>August 13, 2021</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 每天学命令-rename 批量重命名" href="http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-rename%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">每天学命令-apt 安装卸载软件
    </h2>
  </header>
  <div class="entry-content">
    <p>这个命令应该是我们平时用的最多的命令之一了，应该早就拿出来讲一下的。但是平时用的太多，总感觉自己都会用了，但是仔细看了所有命令，还是有一些比较实用但是没记住的命令。
apt的全称是Advanced Packaging Tool是 Linux 系统下的一款安装包管理工具。APT 可以自动下载、配置和安装二进制或源代码格式软件包，简化了 Unix 系统上管理软件的过程。
APT 主要由以下几个命令组成：
apt-getapt-cacheapt-file Commands 搜索软件包 apt search python3 安装软件包 apt install python3 更新源 sudo apt install update 更新软件 执行完 update 命令后，就可以使用 apt upgrade 来升级软件包了。执行命令后系统会提示有几个软件需要升级。在得到你的同意后，系统即开始自动下载安装软件包。
sudo apt install upgrade 卸载软件 apt remove python3 # 移除软件包，但是保留配置文件apt purge python3 #移除软件包并移除配置apt autoremove # 移除孤立的并不被依赖的软件包 列出软件清单 apt list </p>
  </div>
  <footer class="entry-footer"><span title='2021-08-12 18:42:39 +0000 UTC'>August 12, 2021</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 每天学命令-apt 安装卸载软件" href="http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-apt%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">每天学命令-kill 这个进程
    </h2>
  </header>
  <div class="entry-content">
    <p>对于在前台运行的程序，我们可以用Ctrl&#43;C来终止运行，但是在后台的程序就必须用kill命令来终止了。
Command -l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称-a 当处理当前进程时，不限制命令名和进程号的对应关系-p 指定 kill 命令只打印相关进程的进程号，而不发送任何信号-s 指定发送信号-u 指定用户 Examples 查看所有信号 ➜ kill -lHUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS 常用信号
HUP 1 终端断线INT 2 中断（同 Ctrl &#43; C）QUIT 3 退出（同 Ctrl &#43; \）TERM 15 终止KILL 9 强制终止CONT 18 继续（与 STOP 相反， fg/bg 命令）STOP 19 暂停（同 Ctrl &#43; Z） 用 ps 查找进程，然后用 kill 杀掉 ps -ef | grep &#39;program&#39;kill PID 无条件彻底杀死进程 kill –9 PID 杀死指定用户所有进程 kill -9 $(ps -ef | grep username)kill -u username </p>
  </div>
  <footer class="entry-footer"><span title='2021-08-11 15:22:40 +0000 UTC'>August 11, 2021</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 每天学命令-kill 这个进程" href="http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-kill%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">进程间通信（IPC）之信号（Signal）
    </h2>
  </header>
  <div class="entry-content">
    <p>关于进程间通信的概述可以查看Linux 操作系统 - 进程间通信，代码同步在这里。
本文通过实例介绍通过共享内存实现进程间通信。
简介 信号就像实际生产过程中的应急预案，发生了某个异常就会启动特定的应急预案，为了响应各类异常情况，所以就定义了很多个信号，信号的名称是在头文件signal.h中定义的，信号都以SIG开头，常用的信号并不多，常用的信号如下：
SIGALRM #时钟定时信号, 计算的是实际的时间或时钟时间SIGHUP #终端的挂断或进程死亡SIGINT #来自键盘的中断信号SIGKILL #用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。SIGPIPE #管道破裂SIGTERM #程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理SIGUSR1,SIGUSR2 #留给用户使用 实例 #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; void signalHandler(int sig) { printf(&#34;\nOps! - I got signal %d\n&#34;, sig); // 恢复终端中断信号 SIGINT 的默认行为 (void)signal(SIGINT, SIG_DFL); } int main() { // 改变终端中断信号 SIGINT 的默认行为，使之执行 ouch 函数 // 而不是终止程序的执行 (void)signal(SIGINT, signalHandler); while (1) { printf(&#34;Hello World!\n&#34;); sleep(1); } return 0; } 我们可以用signal()函数处理指定的信号，主要通过忽略和恢复其默认行为来工作。signal() 函数的原型如下：...</p>
  </div>
  <footer class="entry-footer"><span title='2021-08-11 10:59:22 +0000 UTC'>August 11, 2021</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 进程间通信（IPC）之信号（Signal）" href="http://localhost:8888/posts/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc%E4%B9%8B%E4%BF%A1%E5%8F%B7signal/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:8888/tags/linux/page/12/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:8888/tags/linux/page/14/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:8888/">PaperMod</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
