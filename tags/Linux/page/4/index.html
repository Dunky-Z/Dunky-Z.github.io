<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>Tag: Linux - 如云泊</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">










<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="../../../../css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="如云泊" type="application/atom+xml">
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="../../../../index.html">
                
                <img src="../../../../images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5>#Linux</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/06/09/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-watch%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/" itemprop="url">每天学命令-watch 周期执行命令</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-06-09T14:50:54.000Z" itemprop="datePublished">6月 9 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/">每天学命令</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 分钟 lesen (Über 219 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>watch 命令的功能如其名，可以监视命令的执行结果。它实现的原理就是每隔一段时间执行一次命令，然后显示结果。他的用途很广，具体怎么用就靠想象力了。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">n <span class="hljs-comment"># 或--interval  watch默认每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。</span></span><br><span class="ruby"></span>-<span class="ruby">d <span class="hljs-comment"># 或--differences  用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。</span></span><br><span class="ruby"></span>-<span class="ruby">t <span class="hljs-comment"># 或-no-title  会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。</span></span><br><span class="ruby"></span>-<span class="ruby">h <span class="hljs-comment"># 或--help # 查看帮助文档</span></span><br></code></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">watch</span> -d <span class="hljs-string">&#x27;ls -l | grep tmp&#x27;</span>       <span class="hljs-comment"># 监测当前目录中 scf&#x27; 的文件的变化</span><br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/05/23/CPU%E4%BA%B2%E5%92%8C%E6%80%A7%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%BA%B2%E5%92%8C%E6%80%A7/" itemprop="url">CPU 亲和性与中断亲和性</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-05-23T14:38:14.000Z" itemprop="datePublished">5月 23 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            35 分钟 lesen (Über 5283 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HwDqCk8vtMdSEVSCLHAsbg">超线程技术 (Hyper-Threading)</a>：就是利用特殊的硬件指令，把两个逻辑内核 (CPU core) 模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了 CPU 的闲置时间，提高的 CPU 的运行效率。</p>
<p>我们常听到的双核四线程/四核八线程指的就是支持超线程技术的CPU.</p>
<p><strong>物理 CPU</strong>：机器上安装的实际 CPU, 比如说你的主板上安装了一个 8 核 CPU，那么物理 CPU 个数就是 1 个，所以物理 CPU 个数就是主板上安装的 CPU 个数。</p>
<p><strong>逻辑 CPU</strong>：一般情况，我们认为一颗 CPU 可以有多核，加上 Intel 的超线程技术 (HT), 可以在逻辑上再分一倍数量的 CPU core 出来；</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">逻辑<span class="hljs-meta">CPU</span>数量 = 物理<span class="hljs-meta">CPU</span>数量 x <span class="hljs-meta">CPU</span> cores x <span class="hljs-number">2</span>(如果支持并开启HT) //前提是<span class="hljs-meta">CPU</span>的型号一致，如果不一致只能一个一个的加起来，不用直接乘以物理<span class="hljs-meta">CPU</span>数量<br>//比如你的电脑安装了一块<span class="hljs-number">4</span>核<span class="hljs-meta">CPU</span>，并且支持且开启了超线程（HT）技术，那么逻辑<span class="hljs-meta">CPU</span>数量 = <span class="hljs-number">1</span> × <span class="hljs-number">4</span> × <span class="hljs-number">2</span> = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>

<p><strong>Linux 下查看 CPU 相关信息</strong>, CPU 的信息主要都在<code>/proc/cupinfo</code>中。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># 查看物理CPU个数<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;physical id&quot;</span>|<span class="hljs-keyword">sort</span> -u|wc -l<br><span class="hljs-number">32</span><br><br># 查看每个物理CPU中core的个数(即核数)<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;cpu cores&quot;</span>|uniq<br><span class="hljs-number">1</span><br># 或者<br>➜    cat <span class="hljs-regexp">/proc/</span>cpuinfo | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;process&#x27;</span> | <span class="hljs-keyword">sort</span> | uniq | wc -l<br><span class="hljs-number">1</span><br><br># 查看逻辑CPU的个数<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;processor&quot;</span>|wc -l<br><span class="hljs-number">32</span><br><br># 查看CPU的名称型号<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;name&quot;</span>|cut -f2 -d:|uniq<br>Intel Xeon Processor (Skylake, IBRS)<br></code></pre></td></tr></table></figure>

<p><strong>Linux 查看某个进程运行在哪个逻辑 CPU 上</strong></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -eo pid,<span class="hljs-keyword">args</span>,psr<br></code></pre></td></tr></table></figure>

<ul>
<li><code>pid</code>：进程 ID</li>
<li><code>args</code>：该进程执行时传入的命令行参数</li>
<li><code>psr</code>：分配给进程的逻辑 CPU</li>
</ul>
<p>例子：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle">➜  ps -eo pid,args,psr | <span class="hljs-keyword">grep</span> firefox<br><span class="hljs-number">20118</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -n  <span class="hljs-number">13</span><br><span class="hljs-number">20208</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c   <span class="hljs-number">9</span><br><span class="hljs-number">20266</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">29</span><br><span class="hljs-number">20329</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">24</span><br><span class="hljs-number">20499</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c   <span class="hljs-number">7</span><br><span class="hljs-number">20565</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">15</span><br><span class="hljs-number">20596</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">24</span><br><span class="hljs-number">20760</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">18</span><br><span class="hljs-number">22110</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">27</span><br><span class="hljs-number">25857</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">28</span><br><span class="hljs-number">26347</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">19</span><br><span class="hljs-number">26899</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">29</span><br></code></pre></td></tr></table></figure>

<p><strong>Linux 查看线程的 TID</strong></p>
<p>TID 就是 Thread ID，他和 POSIX 中<code>pthread_t</code>表示的线程 ID 完全不是同一个东西。</p>
<p>Linux 中的 POSIX 线程库实现的线程其实也是一个轻量级进程 (LWP),这个 TID 就是这个线程的真实 PID.</p>
<p>但是又不能通过<code>getpid()</code>函数获取，Linux 中定义了<code>gettid()</code>这个接口，但是通常都是未实现的，所以需要使用下面的方式获取 TID。</p>
<p>使用 API 获取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span>  </span><br><span class="hljs-keyword">pid_t</span> tid;<br>tid = <span class="hljs-built_in">syscall</span>(__NR_gettid); <span class="hljs-comment">// or syscall(SYS_gettid)  </span><br></code></pre></td></tr></table></figure>

<p>命令行方式获取：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 3种方法(推荐第三种方法)</span><br>➜  <span class="hljs-built_in">ps</span> <span class="hljs-literal">-efL</span> | grep prog_name<br>➜  <span class="hljs-built_in">ls</span> /proc/pid/task      //文件夹名即TID<br>➜  <span class="hljs-built_in">ps</span> <span class="hljs-literal">-To</span> <span class="hljs-string">&#x27;pid,lwp,psr,cmd&#x27;</span> <span class="hljs-literal">-p</span> PID<br></code></pre></td></tr></table></figure>

<h2 id="什么是-CPU-亲和性"><a href="#什么是-CPU-亲和性" class="headerlink" title="什么是 CPU 亲和性"></a>什么是 CPU 亲和性</h2><p>CPU 的亲和性 (Affinity)，属于一种调度属性，可以绑定进程到指定 CPU 上。 换句话说，就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器。</p>
<p>为何会出现这种技术？在 SMP(Symmetric Multi-Processing 对称多处理) 架构下，调度器会试图保持进程在相同的 CPU 上运行，这意味着进程通常不会在处理器之间频繁迁移，进程迁移的频率小就意味着产生的负载小。</p>
<p>又如，每个 CPU 本身自己会有缓存，缓存着进程使用的信息，而进程可能会被操作系统调度到其他 CPU 上，如此，CPU 缓存命中率就低了，当绑定 CPU 后，程序就会一直在指定的 CPU 跑，不会由操作系统调度到其他 CPU 上，性能有一定的提高。</p>
<p><strong>软亲和性</strong>:  就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，Linux 内核进程调度器天生就具有被称为 软 CPU 亲和性（affinity）的特性，这意味着进程通常不会在处理器之间频繁迁移。这种状态正是我们希望的，因为进程迁移的频率小就意味着产生的负载小。</p>
<p><strong>硬亲和性</strong>：简单来说就是利用 Linux 内核提供给用户的 API，强行将进程或者线程绑定到某一个指定的 CPU 核运行。</p>
<p>CPU affinity 使用位掩码 (bitmask) 表示，每一位都表示一个 CPU, 置 1 表示”绑定”。最低位表示第一个逻辑 CPU, 最高位表示最后一个逻辑 CPU。</p>
<p>CPU affinity 典型的表示方法是使用 16 进制，具体如下。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">0b00000000000000000000000000000001<br><span class="hljs-section">= 0x00000001</span><br>表示 processor #0<br><br>0b00000000000000000000000001010101<br><span class="hljs-section">= 0x00000055</span><br>表示 processors #0, #2, #4, #6<br><br>0b11111111111111111111111111111111<br><span class="hljs-section">= 0xFFFFFFFF</span><br>表示所有 processors (#0 through #31)<br></code></pre></td></tr></table></figure>

<h2 id="使用taskset命令设置-CPU-亲和性"><a href="#使用taskset命令设置-CPU-亲和性" class="headerlink" title="使用taskset命令设置 CPU 亲和性"></a>使用<code>taskset</code>命令设置 CPU 亲和性</h2><p><strong>命令行形式</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">taskset <span class="hljs-selector-attr">[options]</span> <span class="hljs-attribute">mask</span> command <span class="hljs-selector-attr">[arg]</span>...<br>taskset <span class="hljs-selector-attr">[options]</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-selector-attr">[mask]</span> pid<br></code></pre></td></tr></table></figure>

<p><strong>参数解析</strong><br>[OPTIONS]taskset 的可选参数</p>
<ul>
<li><p><code>-a, --all-tasks</code> (旧版本中没有这个选项)</p>
<pre><code class="hljs">  这个选项涉及到了linux中TID的概念,他会将一个进程中所有的TID都执行一次CPU亲和性设置.
  TID 就是 Thread ID，他和 POSIX 中 pthread_t 表示的线程 ID 完全不是同一个东西。
  Linux中的POSIX线程库实现的线程其实也是一个进程(LWP),这个TID就是这个线程的真实PID.
</code></pre>
</li>
<li><p><code>-p, --pid</code></p>
<pre><code class="hljs">  操作已存在的PID,而不是加载一个新的程序
</code></pre>
</li>
<li><p><code>-c, --cpu-list</code></p>
<pre><code class="hljs">        声明CPU的亲和力使用数字表示而不是用位掩码表示. 例如 0,5,7,9-11.
</code></pre>
</li>
<li><p><code>-h, --help</code></p>
<pre><code class="hljs">  显示帮助信息
</code></pre>
</li>
<li><p><code>-V, --version</code></p>
<pre><code class="hljs">  显示版本信息
</code></pre>
</li>
<li><p><code>mask</code> : cpu 亲和性，当没有<code>-c</code>选项时，其值前无论有没有<code>0x</code>标记都是 16 进制的，当有<code>-c</code>选项时，其值是十进制的。</p>
</li>
<li><p><code>command</code> : 命令或者可执行程序</p>
</li>
<li><p><code>pid</code> : 进程 ID，可以通过<code>ps/top/pidof</code>等命令获取</p>
</li>
</ul>
<p><code>[arg]</code> command 的参数</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="使用指定的-CPU-亲和性运行一个新程序"><a href="#使用指定的-CPU-亲和性运行一个新程序" class="headerlink" title="使用指定的 CPU 亲和性运行一个新程序"></a>使用指定的 CPU 亲和性运行一个新程序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskset [-c] mask <span class="hljs-built_in">command</span> [arg]...<br><span class="hljs-comment"># 举例: 使用CPU0运行ls命令显示/etc/init.d下的所有内容</span><br>taskset -c 0 ls -al /etc/init.d/<br></code></pre></td></tr></table></figure>

<h4 id="显示已经运行的进程的-CPU-亲和性"><a href="#显示已经运行的进程的-CPU-亲和性" class="headerlink" title="显示已经运行的进程的 CPU 亲和性"></a>显示已经运行的进程的 CPU 亲和性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskset -p pid<br><span class="hljs-comment"># 举例:查看init进程(PID=1)的CPU亲和性</span><br>taskset -p 1<br></code></pre></td></tr></table></figure>

<h4 id="改变已经运行进程的-CPU-亲和性"><a href="#改变已经运行进程的-CPU-亲和性" class="headerlink" title="改变已经运行进程的 CPU 亲和性"></a>改变已经运行进程的 CPU 亲和性</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq">taskset -p[c] mask pid<br>举例:打开<span class="hljs-number">2</span>个终端,在第一个终端运行<span class="hljs-built_in">top</span>命令,第二个终端中<br> 　　首先运行:[~]# ps -eo pid,args,psr | <span class="hljs-type">grep</span> <span class="hljs-built_in">top</span> #获取<span class="hljs-built_in">top</span>命令的pid和其所运行的CPU号<br> 　　其次运行:[~]# taskset -cp 新的CPU号 pid       #更改<span class="hljs-built_in">top</span>命令运行的CPU号<br> 　　最后运行:[~]# ps -eo pid,args,psr | <span class="hljs-type">grep</span> <span class="hljs-built_in">top</span> #查看是否更改成功<br></code></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">ps</span> <span class="hljs-string">-eo</span> <span class="hljs-string">pid,args,psr</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">top</span><br><span class="hljs-number">2501 </span><span class="hljs-string">nautilus-desktop</span>             <span class="hljs-number">24</span><br><span class="hljs-number">2634</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">18</span><br><span class="hljs-number">2658</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">11</span><br><span class="hljs-number">23848</span> <span class="hljs-string">top</span>                           <span class="hljs-number">6</span><br><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">taskset</span> <span class="hljs-string">-cp</span> <span class="hljs-number">10</span> <span class="hljs-number">23848</span><br><span class="hljs-string">pid</span> <span class="hljs-number">23848</span><span class="hljs-string">&#x27;s current affinity list: 0-31</span><br><span class="hljs-string">pid 23848&#x27;</span><span class="hljs-attr">s new affinity list:</span> <span class="hljs-number">10</span><br><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">ps</span> <span class="hljs-string">-eo</span> <span class="hljs-string">pid,args,psr</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">top</span><br> <span class="hljs-number">2501 </span><span class="hljs-string">nautilus-desktop</span>             <span class="hljs-number">24</span><br> <span class="hljs-number">2634</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">18</span><br> <span class="hljs-number">2658</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">11</span><br><span class="hljs-number">23848</span> <span class="hljs-string">top</span>                          <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>一个用户要设定一个进程的 CPU 亲和性，如果目标进程是该用户的，则可以设置，如果是其他用户的，则会设置失败，提示 Operation not permitted.当然 root 用户没有任何限制。<br>任何用户都可以获取任意一个进程的 CPU 亲和性。</p>
</blockquote>
<h2 id="程序-API-实现硬亲和性"><a href="#程序-API-实现硬亲和性" class="headerlink" title="程序 API 实现硬亲和性"></a>程序 API 实现硬亲和性</h2><p>以下实验使用的源码可以从<a target="_blank" rel="noopener" href="https://github.com/Dunky-Z/learning-linux/tree/main/Affinity">这个仓库</a>获取。</p>
<p>以下是一些设置亲和性时会用到的宏定义及函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span> <span class="hljs-comment">//注意&lt;pthread.h&gt;包含&lt;sched.h&gt;</span></span><br><br><span class="hljs-comment">/* MACRO */</span><br>        <span class="hljs-comment">// 对 CPU 集初始化，将其设置为空集</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_ZERO</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_ZERO_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 将 CPU 加入到 CPU 集中</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_SET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_SET_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 将 CPU 从 CPU 集中移除</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_CLR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_CLR_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 判断 CPU 是否在 CPU 集中</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_ISSET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_ISSET_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 计算 CPU 集的大小</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_COUNT</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_COUNT_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// The following macros perform logical operations on CPU sets </span><br>        <span class="hljs-comment">/* Store the logical AND of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_AND</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_AND_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Store the logical OR of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_OR</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_OR_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Store  the logical XOR of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_XOR</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_XOR_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Test whether two CPU set contain exactly the same CPUs. */</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_EQUAL</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *set1, <span class="hljs-keyword">cpu_set_t</span> *set2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_EQUAL_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *set1, <span class="hljs-keyword">cpu_set_t</span> *set2)</span></span>;<br>    <br>    <span class="hljs-comment">/* The following macros are used to allocate and deallocate CPU sets: */</span><br>        <span class="hljs-comment">/* Allocate a CPU set large enough to hold CPUs in the range 0 to num_cpus-1 */</span><br>        <span class="hljs-function"><span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-title">CPU_ALLOC</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num_cpus)</span></span>;<br>    <br>        <span class="hljs-comment">/* Return the size in bytes of the CPU set that would be needed to  hold  CPUs  in the  range 0 to num_cpus-1. </span><br><span class="hljs-comment">           This macro provides the value that can be used for the setsize argument in the CPU_*_S() macros */</span><br>        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">CPU_ALLOC_SIZE</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num_cpus)</span></span>;<br>        <br>        <span class="hljs-comment">/* Free a CPU set previously allocated by CPU_ALLOC(). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_FREE</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br><br><span class="hljs-comment">/* API */</span><br>    <span class="hljs-comment">/*该函数设置进程为 pid 的这个进程，让它运行在 mask 所设定的 CPU 上。如果 pid 的值为 0,</span><br><span class="hljs-comment">    *则表示指定的是当前进程，使当前进程运行在 mask 所设定的那些 CPU 上.</span><br><span class="hljs-comment">    *第二个参数 cpusetsize 是 mask 所指定的数的长度。通常设定为 sizeof(cpu_set_t).</span><br><span class="hljs-comment">    *如果当前 pid 所指定的进程此时没有运行在 mask 所指定的任意一个 CPU 上，</span><br><span class="hljs-comment">    *则该指定的进程会从其它 CPU 上迁移到 mask 的指定的一个 CPU 上运行.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sched_setaffinity</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *mask)</span></span>;<br>    <span class="hljs-comment">/*该函数获得 pid 所指示的进程的 CPU 位掩码，并将该掩码返回到 mask 所指向的结构中.</span><br><span class="hljs-comment">    *即获得指定 pid 当前可以运行在哪些 CPU 上.</span><br><span class="hljs-comment">    *同样，如果 pid 的值为 0.也表示的是当前进程</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sched_getaffinity</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *mask)</span></span>;<br>    <br>    <span class="hljs-comment">/* set CPU affinity attribute in thread attributes object */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_attr_setaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_attr_t</span> *attr, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">const</span> <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <span class="hljs-comment">/* get CPU affinity attribute in thread attributes object */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_attr_getaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_attr_t</span> *attr, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <br>    <span class="hljs-comment">/* set CPU affinity of a thread */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_setaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">const</span> <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <span class="hljs-comment">/* get CPU affinity of a thread */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_getaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br></code></pre></td></tr></table></figure>

<p>程序中会使用<code>syscall</code>来获取一些内核数据，<code>syscall</code>是执行一个系统调用，根据指定的参数<code>number</code>和所有系统调用的接口来确定调用哪个系统调用，用于用户空间跟内核之间的数据交换，下面是<code>syscall</code>函数原型及一些常用的<code>number</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//syscall - indirect system call</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE         <span class="hljs-comment">/* See feature_test_macros(7) */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span>   <span class="hljs-comment">/* For SYS_xxx definitions */</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number, ...)</span></span>;<br><br><span class="hljs-comment">// 查看缓存内存页面的大小；打印用%ld 长整型。</span><br>sysconf(_SC_PAGESIZE);  <br><span class="hljs-comment">// 查看内存的总页数；打印用%ld 长整型。</span><br>sysconf(_SC_PHYS_PAGES) <br><span class="hljs-comment">// 查看可以利用的总页数；打印用%ld 长整型。</span><br>sysconf(_SC_AVPHYS_PAGES) <br><span class="hljs-comment">// 查看 CPU 的个数；打印用%ld 长整。</span><br>sysconf(_SC_NPROCESSORS_CONF) <br><span class="hljs-comment">// 查看在使用的 CPU 个数；打印用%ld 长整。</span><br>sysconf(_SC_NPROCESSORS_ONLN) <br><span class="hljs-comment">// 计算内存大小。</span><br>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)sysconf(_SC_PAGESIZE) * (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)sysconf(_SC_PHYS_PAGES) <br><span class="hljs-comment">// 查看最大登录名长度；打印用%ld 长整。</span><br>sysconf(_SC_LOGIN_NAME_MAX) <br><span class="hljs-comment">// 查看最大主机长度；打印用%ld 长整。</span><br>sysconf(_SC_HOST_NAME_MAX) <br><span class="hljs-comment">// 每个进程运行时打开的文件数目；打印用%ld 长整。</span><br>sysconf(_SC_OPEN_MAX)  <br><span class="hljs-comment">// 查看每秒中跑过的运算速率；打印用%ld 长整。</span><br>sysconf(_SC_CLK_TCK) <br><br></code></pre></td></tr></table></figure>

<h3 id="使用-2-种方式-带和不带-S-后缀的宏-获取当前进程的-CPU-亲和性"><a href="#使用-2-种方式-带和不带-S-后缀的宏-获取当前进程的-CPU-亲和性" class="headerlink" title="使用 2 种方式 (带和不带_S 后缀的宏) 获取当前进程的 CPU 亲和性"></a>使用 2 种方式 (带和不带_S 后缀的宏) 获取当前进程的 CPU 亲和性</h3><p>相关的宏通常都分为 2 种，一种是带<code>_S</code>后缀的，一种不是不带<code>_S</code>后缀的，从声明上看带<code>_S</code>后缀的宏都多出一个参数 <code>setsize</code>。</p>
<p>从功能上看他们的区别是带<code>_S</code>后缀的宏是用于操作动态申请的<code>CPU set(s)</code>，所谓的动态申请其实就是使用宏 <code>CPU_ALLOC</code> 申请，</p>
<p>参数 <code>setsize</code> 可以是通过宏 <code>CPU_ALLOC_SIZE</code> 获得，两者的用法详见下面的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> WITH_S</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WITH_S</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> *pmask;<br>    <span class="hljs-keyword">size_t</span> cpusize;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 获取逻辑 CPU 个数 */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br><br>    pmask = CPU_ALLOC(nrcpus);<br>    cpusize = CPU_ALLOC_SIZE(nrcpus);<br>    CPU_ZERO_S(cpusize, pmask);<br><br>    <span class="hljs-comment">/* 获取 CPU 亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, cpusize, pmask) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        CPU_FREE(pmask);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET_S(i, cpusize, pmask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    CPU_FREE(pmask);<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br><br>    CPU_ZERO(&amp;mask);<br><br>    <span class="hljs-comment">/* 获取 CPU 亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取逻辑 CPU 个数 */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(i, &amp;mask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs delphi"># 直接运行，不设置亲和性，获取CPU亲和性为所有CPU都会被设置<br>➜  Affinity git:(main)   ./bin/main <br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#5</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#6</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#7</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#8</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#9</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#10</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#11</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#12</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#13</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#14</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#15</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#16</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#17</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#18</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#19</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#20</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#21</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#22</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#23</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#24</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#25</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#26</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#27</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#28</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#29</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#30</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#31</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>xffffffff<br><br># 使用taskset设置亲和性，将main程序绑定到第<span class="hljs-number">1</span>个CPU上，mask转化为<span class="hljs-number">16</span>进制为<span class="hljs-number">0</span>x1<br>➜  Affinity git:(main)  taskset <span class="hljs-number">1</span> ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>x1<br><br># 使用taskset设置亲和性，将main程序绑定到第<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>个CPU上，mask转化为<span class="hljs-number">16</span>进制为<span class="hljs-number">0</span>x55<br>➜  Affinity git:(main)  taskset <span class="hljs-number">55</span> ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#6</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>x55<br><br># 使用taskset设置亲和性，将main程序绑定到第<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>个CPU上，mask转化为<span class="hljs-number">16</span>进制为<span class="hljs-number">0</span>xf<br>➜  Affinity git:(main)  taskset F ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>xf<br></code></pre></td></tr></table></figure>

<h3 id="设置进程的-CPU-亲和性后再获取显示-CPU-亲和性"><a href="#设置进程的-CPU-亲和性后再获取显示-CPU-亲和性" class="headerlink" title="设置进程的 CPU 亲和性后再获取显示 CPU 亲和性"></a>设置进程的 CPU 亲和性后再获取显示 CPU 亲和性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span> <span class="hljs-comment">/* sysconf */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">/* exit */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br>    <br>    CPU_ZERO(&amp;mask);<br>    <br>    CPU_SET(<span class="hljs-number">0</span>, &amp;mask); <span class="hljs-comment">/* add CPU0 to cpu set */</span><br>    CPU_SET(<span class="hljs-number">2</span>, &amp;mask); <span class="hljs-comment">/* add CPU2 to cpu set */</span><br>    CPU_SET(<span class="hljs-number">3</span>, &amp;mask); <span class="hljs-comment">/* add CPU3 to cpu set */</span><br><br>    <span class="hljs-comment">/* 设置 CPU 亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_setaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) <br>    &#123;   <br>        perror(<span class="hljs-string">&quot;sched_setaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <br>    CPU_ZERO(&amp;mask);<br>    <br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) <br>    &#123;   <br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>       <span class="hljs-comment">/* get logical cpu number */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(i, &amp;mask))<br>        &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i); <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">➜  Affinity git:(main) ✗ ./bin/main <br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>xd<br></code></pre></td></tr></table></figure>

<h3 id="设置线程的-CPU-属性后再获取显示-CPU-亲和性"><a href="#设置线程的-CPU-属性后再获取显示-CPU-亲和性" class="headerlink" title="设置线程的 CPU 属性后再获取显示 CPU 亲和性"></a>设置线程的 CPU 属性后再获取显示 CPU 亲和性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span> <span class="hljs-comment">//不用再包含&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> handle_error_en(en, msg) \</span><br><span class="hljs-meta">        do &#123; errno = en; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> s, j;<br>    <span class="hljs-keyword">cpu_set_t</span> cpuset;<br>    <span class="hljs-keyword">pthread_t</span> thread;<br>    <br>    thread = pthread_self();<br>    <br>    <span class="hljs-comment">/* Set affinity mask to include CPUs 0 to 7 */</span><br>    CPU_ZERO(&amp;cpuset);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>        CPU_SET(j, &amp;cpuset);<br>    <br>    s = pthread_setaffinity_np(thread, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;cpuset);<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>    &#123;<br>        handle_error_en(s, <span class="hljs-string">&quot;pthread_setaffinity_np&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* Check the actual affinity mask assigned to the thread */</span><br>    s = pthread_getaffinity_np(thread, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;cpuset);<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>    &#123;<br>        handle_error_en(s, <span class="hljs-string">&quot;pthread_getaffinity_np&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Set returned by pthread_getaffinity_np() contained:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; CPU_SETSIZE; j++) <span class="hljs-comment">//CPU_SETSIZE 是定义在&lt;sched.h&gt;中的宏，通常是 1024</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(j, &amp;cpuset))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    CPU %d\n&quot;</span>, j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gams">➜  Affinity git:(main) ./bin/main<br><span class="hljs-keyword">Set</span> returned <span class="hljs-comment">by pthread_getaffinity_np() contained:</span><br>    CPU <span class="hljs-comment">0</span><br>    CPU <span class="hljs-comment">1</span><br>    CPU <span class="hljs-comment">2</span><br>    CPU <span class="hljs-comment">3</span><br>    CPU <span class="hljs-comment">4</span><br>    CPU <span class="hljs-comment">5</span><br>    CPU <span class="hljs-comment">6</span><br>    CPU <span class="hljs-comment">7</span><br></code></pre></td></tr></table></figure>

<h3 id="使用-seched-setaffinity-设置线程的-CPU-亲和性"><a href="#使用-seched-setaffinity-设置线程的-CPU-亲和性" class="headerlink" title="使用 seched_setaffinity 设置线程的 CPU 亲和性"></a>使用 seched_setaffinity 设置线程的 CPU 亲和性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span> <span class="hljs-comment">// syscall</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> tid;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br>    <br>    CPU_ZERO(&amp;mask);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;mask); <span class="hljs-comment">/* add CPU0 to cpu set */</span><br>    CPU_SET(<span class="hljs-number">2</span>, &amp;mask); <span class="hljs-comment">/* add CPU2 to cpu set */</span><br><br>    <span class="hljs-comment">// 获取线程 id</span><br>    tid = syscall(__NR_gettid); <span class="hljs-comment">// or syscall(SYS_gettid);</span><br><br>    <span class="hljs-comment">// 对指定线程 id 设置 CPU 亲和性</span><br>    <span class="hljs-keyword">if</span> (sched_setaffinity(tid, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) <br>    &#123;<br>        perror(<span class="hljs-string">&quot;sched_setaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(i, &amp;mask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">➜  Affinity git:(main) ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br></code></pre></td></tr></table></figure>

<h2 id="什么是中断亲和性"><a href="#什么是中断亲和性" class="headerlink" title="什么是中断亲和性"></a>什么是中断亲和性</h2><p>计算机中，中断是一种电信号，由硬件产生并直接送到中断控制器上，再由中断控制器向 CPU 发送中断信号，CPU 检测到信号后，中断当前工作转而处理中断信号。CPU 会通知操作系统已经产生中断，操作系统就会对中断进行处理。<br>这里有篇推文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247484717&idx=1&sn=2c1dd6c389c8476eb4fd178c714eaafc&scene=21#wechat_redirect">CPU 明明 8 个核，网卡为啥拼命折腾一号核？</a>生动的解释了中断亲和性。</p>
<p>默认情况下，Linux 中断响应会被平均分配到所有 CPU 核心上，势必会发生写新的数据和指令缓存，并与 CPU 核心上原有进程产生冲突，造成中断响应延迟，影响进程处理时间。为了解决这个问题，可以将中断（或进程）绑定到指定 CPU 核心上，中断（或进程）所需要指令代码和数据有更大概率位于指定 CPU 本地数据和指令缓存内，而不必进行新的写缓存，从而提高中断响应（或进程）的处理速度。</p>
<h2 id="中断亲和性的使用场景"><a href="#中断亲和性的使用场景" class="headerlink" title="中断亲和性的使用场景"></a>中断亲和性的使用场景</h2><p>对于文件服务器、Web 服务器，把不同的网卡 IRQ 均衡绑定到不同的 CPU 上将会减轻某 CP 的负载，提高多个 CPU 整体处理中断的能力; 对于数据库服务器，把磁盘控制器绑到一个 CPU、把网卡绑定到另一个 CPU 将会提高数据库的响应时间、优化性能。<br>合理的根据自己的生产环境和应用的特点来平衡 IRQ 中断有助于提高系统的整体吞吐能力和性能。</p>
<h2 id="中断绑定流程"><a href="#中断绑定流程" class="headerlink" title="中断绑定流程"></a>中断绑定流程</h2><ol>
<li><p>关闭中断平衡守护进程<br>中断平衡守护进程（irqbalance daemon）会周期性地将中断平均地公平地分配给各个 CPU 核心，默认开启。为了实现中断绑定，首先需要将中断平衡守护进程关闭。</p>
<ul>
<li><code>systemctl status irqbalance</code>查看守护进程的运行状态</li>
</ul>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ systemctl status irqbalance<br><br>● irqbalance.service - irqbalance daemon<br>Loaded: loaded (/lib/systemd/system/irqbalance.service; enabled; vendor preset: <span class="hljs-built_in">enable</span><br>Active: active (running) since Thu 2022-05-19 14:46:20 CST; 1 weeks 1 days ago<br>Main PID: 1062 (irqbalance)<br>    Tasks: 2 (<span class="hljs-built_in">limit</span>: 4915)<br>CGroup: /system.slice/irqbalance.service<br>        └─1062 /usr/sbin/irqbalance --foreground<br><br>5月 19 14:46:20 zdd systemd[1]: Started irqbalance daemon.<br></code></pre></td></tr></table></figure>

<ul>
<li><code>systemctl stop irqbalance</code>关闭中断平衡守护进程，中断响应默认都会由 CPU0 核心处理。或者<code>systemctl disable irqbalance</code>取消中断平衡守护进程开机重启。因为关闭中断平衡守护进程过于强硬，可以在不关闭中断平衡守护进程条件下，让某些 CPU 核心脱离中断平衡守护进程的管理。</li>
</ul>
</li>
<li><p>绑定中断<br>中断绑定时，需要关闭系统中断平衡守护进程<code>systemctl stop irqbalance</code>计算机当前各种中断响应情况在 <code>/proc/interrupts</code> 文件中。</p>
<p> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205281336182.png"><br> 第一列是中断 ID 号，CPU N 列是中断在第 n 个 CPU 核心上的响应次数，倒数第二列是中断类型，最后一列是描述。  </p>
<p> 利用 echo 命令将 CPU 掩码写入 <code>/proc/irq/中断 ID/smp_affinity</code> 文件中，即可实现修改某一中断的 CPU 亲和性。例如  </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> 0x0004 &gt; /proc/irq /50/smp_affinity<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lubinlew/p/cpu_affinity.html">Linux 中 CPU 亲和性 (affinity) - LubinLew - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15302006/3075968">操作系统底层技术——CPU 亲和性_mb60ed33cfc44fa 的技术博客_51CTO 博客</a><br><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15484754/4907846">linux 进程、线程与 CPU 的亲和性（affinity）_wx61d68abba262d 的技术博客_51CTO 博客</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247484717&idx=1&sn=2c1dd6c389c8476eb4fd178c714eaafc&scene=21#wechat_redirect">CPU 明明 8 个核，网卡为啥拼命折腾一号核？</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Processor_affinity">Processor affinity - Wikipedia</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HwDqCk8vtMdSEVSCLHAsbg">什么？一个核同时执行两个线程？</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wenqiang/p/6049978.html#!comments">linux 进程、线程与 CPU 的亲和性（affinity） - zhangwju - 博客园</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/03/09/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-QOM/" itemprop="url">QEMU 源码分析-QOM</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-03-09T08:02:19.000Z" itemprop="datePublished">3月 9 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/QEMU-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">QEMU 源码分析</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            16 分钟 lesen (Über 2413 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="QOM-简介"><a href="#QOM-简介" class="headerlink" title="QOM 简介"></a>QOM 简介</h2><p>QOM(QEMU Object Model) 是 QEMU 的一个模块，用于描述虚拟机的结构，包括虚拟机的 CPU、内存、硬盘、网络、输入输出设备等。QEMU 为了方便整个系统的构建，实现了自己的一套的面向对象机制，也就是 QOM(QEMU Object Model)。它能够方便的表示各个设备（Device）与总线（Bus）之间的关系。</p>
<p>这个模型主要包含四个结构体：</p>
<ul>
<li>Object: 是所有对象的 基类 Base Object</li>
<li>ObjectClass: 是所有类对象的基类</li>
<li>TypeInfo：是用户用来定义一个 Type 的工具型的数据结构</li>
<li>TypeImpl：TypeInfo 抽象数据结构，TypeInfo 的属性与 TypeImpl 的属性对应</li>
</ul>
<p>在 QEMU 里要初始化一个对象需要完成四步：</p>
<ul>
<li>将 TypeInfo 注册 TypeImpl</li>
<li>实例化 Class（ObjectClass）</li>
<li>实例化 Object</li>
<li>添加 Property</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-09-19-4995177f1aeb782fadaf586f8f5c8b32-qemu-QOM%E5%88%86%E6%9E%90.drawio%20-2--1a4eac.png"></p>
<h2 id="QOM-中的面向对象"><a href="#QOM-中的面向对象" class="headerlink" title="QOM 中的面向对象"></a>QOM 中的面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 QEMU 中通过 <strong>TypeInfo</strong> 来定义一个类。</p>
<p>例如 <code>x86_base_cpu_type_info</code> 就是一个 <code>class</code>，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_base_cpu_type_info = &#123;<br>        .name = X86_CPU_TYPE_NAME(<span class="hljs-string">&quot;base&quot;</span>),<br>        .parent = TYPE_X86_CPU,<br>        .class_init = x86_cpu_base_class_init,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>利用结构体包含来实现继承</strong>。这应该是所有的语言实现继承的方法，在 C++ 中，结构体包含的操作被语言内部实现了，而 C 语言需要自己实现。</p>
<p>例如 <code>x86_cpu_type_info</code> 的 <code>parent</code> 是 <code>cpu_type_info</code>, 他们的结构体分别是 <code>X86CPU</code> 和 <code>CPUState</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_cpu_type_info = &#123;<br>    .name = TYPE_X86_CPU,<br>    .parent = TYPE_CPU,<br>  <span class="hljs-comment">// ...</span><br>    .instance_size = <span class="hljs-keyword">sizeof</span>(X86CPU),<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo cpu_type_info = &#123;<br>    .name = TYPE_CPU,<br>    .parent = TYPE_DEVICE,<br>  <span class="hljs-comment">// ...</span><br>    .instance_size = <span class="hljs-keyword">sizeof</span>(CPUState),<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在 <code>X86CPU</code> 中包含一个 <code>CPUState</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPU</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    CPUState parent_obj;<br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br><br>    CPUNegativeOffsetState neg;<br></code></pre></td></tr></table></figure>

<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态成员变量可以在类的多个对象中访问，但是要在类外声明。<strong>不同对象访问的其实是同一个实体，静态成员变量被多个对象共享</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_cpu_type_info = &#123;<br>    .name = TYPE_X86_CPU,<br>    .parent = TYPE_CPU,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(X86CPU),<br>    .instance_init = x86_cpu_initfn,<br>    .instance_post_init = x86_cpu_post_initfn,<br><br>    .abstract = <span class="hljs-literal">true</span>,<br>    .class_size = <span class="hljs-keyword">sizeof</span>(X86CPUClass),<br>    .class_init = x86_cpu_common_class_init,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其中 <code>X86CPU</code> 描述的是非静态成员，而 <code>X86CPUClass</code> 描述的是静态的成员。也就是说<code>class_init</code>初始化静态成员，<code>instance_init</code>初始化非静态成员。</p>
<p>那么何时初始化静态成员呢？首先得告诉系统，咱有<code>class_init</code>这个初始化函数，等需要的时候随时可以调用它初始化，所有先解决如何将这个初始化函数注册到系统中？</p>
<p>在<code>target/i386/cpu.c</code>最后使用了<code>type_init</code>。在<code>qemu/include/qemu/module.h</code>中有一个<code>type_init</code>宏定义，除了<code>type_init</code>还有其他宏，比如<code>block_init</code>，<code>opts_init</code>等。每个宏都表示一类<code>module</code>，通过<code>module_init</code>构造出来。我们展开这个宏，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __attribute__((constructor))<br>do_qemu_init_x86_cpu_register_types(<span class="hljs-keyword">void</span>) &#123;<br>  register_module_init(x86_cpu_register_types, MODULE_INIT_QOM);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过 <code>gcc</code> 扩展属性<code>__attribute__((constructor))</code>可以让 <code>do_qemu_init_x86_cpu_register_types</code> 在运行 <code>main</code> 函数之前运行。 <code>register_module_init</code> 会让 <code>x86_cpu_register_types</code> 这个函数挂载到 <code>init_type_list[MODULE_INIT_QOM]</code> 这个链表上。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210907133931.svg"></p>
<p>到底，所有的 <code>TypeInfo</code> 通过 <code>type_init</code> 都被放到 <code>type_table</code> 上了，之后通过 <code>Typeinfo</code> 的名称调用 <code>type_table_lookup</code> 获取到 <code>TypeImpl</code> 了。</p>
<p>到这里，将<code>TYPE_X86_CPU</code>注册进类系统，包括其初始化函数，这部分也就是 QEMU 中类型的构造。那么何时调用静态成员初始化函数呢？也就是类型的初始化。</p>
<p>静态成员是所有的对象公用的，其初始化显然要发生在所有的对象初始化之前。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">main<br>    qemu_init <br>        select_machine <br>            object_class_get_list <br>                object_class_foreach <br>                    g_hash_table_foreach <br>                        object_class_foreach_tramp <br>                            type_initialize <br>                                type_initialize <br>                                    x86_cpu_common_class_init <br></code></pre></td></tr></table></figure>

<p><code>select_machine</code> 需要获取所有的 <code>TYPE_MACHINE</code> 的 <code>class</code>, 其首先会调用所有的<code>class_list</code>，其会遍历 <code>type_table</code>，遍历的过程中会顺带 <code>type_initialize</code> 所有的 <code>TypeImpl</code> 进而调用的 <code>class_init</code>。</p>
<p>说完类型的初始化，再讲一下对象的初始化，也就是初始化非静态成员，也就是<code>instance_init</code>在何时被调用？</p>
<p>对象初始化，通过调用 <code>object_new</code> 来实现初始化。</p>
<ul>
<li><code>object_initialize_with_type</code><ul>
<li>初始化一个空的 :<code>Object::properties</code></li>
<li><code>object_init_with_type</code><ul>
<li>如果 <code>object</code> 有 <code>parent</code>，那么调用 <code>object_init_with_type</code> 首先初始化 <code>parent</code> 的</li>
<li>调用<code>TypeImpl::instance_init</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">main <br>    qemu_init <br>        qmp_x_exit_preconfig <br>            qemu_init_board <br>                machine_run_board_init <br>                    pc_init_v6_1 <br>                        pc_init1 <br>                            x86_cpus_init <br>                                x86_cpu_new <br>                                    object_new <br>                                        object_new_with_type <br>                                            object_initialize_with_type <br>                                                object_init_with_type <br>                                                    x86_cpu_initfn <br></code></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。为了实现多态，QOM 实现了一个非常重要的功能，就是动态类型转换。我们可以使用相关的函数，将一个<code>Object</code>的指针在运行时转换为子类对象的指针，可以将一个<code>ObjectClass</code>的指针在运行时转换为子类的指针。这样就可以调用子类中定义的函数指针来完成相应的功能。</p>
<p>QEMU 定义了一些列的宏封来进行动态类型转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//include/qom/object.h</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_INSTANCE_CHECKER:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the instance type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED InstanceType * \</span><br><span class="hljs-meta">    OBJ_NAME(const void *obj) \</span><br><span class="hljs-meta">    &#123; return OBJECT_CHECK(InstanceType, obj, TYPENAME); &#125;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_CLASS_CHECKERS:</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the class type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED ClassType * \</span><br><span class="hljs-meta">    OBJ_NAME##_GET_CLASS(const void *obj) \</span><br><span class="hljs-meta">    &#123; return OBJECT_GET_CLASS(ClassType, obj, TYPENAME); &#125; \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED ClassType * \</span><br><span class="hljs-meta">    OBJ_NAME##_CLASS(const void *klass) \</span><br><span class="hljs-meta">    &#123; return OBJECT_CLASS_CHECK(ClassType, klass, TYPENAME); &#125;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_OBJ_CHECKERS:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the three standard type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_OBJ_CHECKERS(InstanceType, ClassType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @MODULE_OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro is typically used in a header file, and will:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   - create the typedefs for the object and class structs</span><br><span class="hljs-comment"> *   - register the type for use with g_autoptr</span><br><span class="hljs-comment"> *   - provide three standard type cast functions</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The object struct and class struct need to be declared manually.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_DECLARE_TYPE(InstanceType, ClassType, MODULE_OBJ_NAME) \</span><br><span class="hljs-meta">    typedef struct InstanceType InstanceType; \</span><br><span class="hljs-meta">    typedef struct ClassType ClassType; \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    G_DEFINE_AUTOPTR_CLEANUP_FUNC(InstanceType, object_unref) \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    DECLARE_OBJ_CHECKERS(InstanceType, ClassType, \</span><br><span class="hljs-meta">                         MODULE_OBJ_NAME, TYPE_##MODULE_OBJ_NAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT:</span><br><span class="hljs-comment"> * @obj: A derivative of #Object</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Converts an object to a #Object.  Since all objects are #Objects,</span><br><span class="hljs-comment"> * this function will always succeed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT(obj) \</span><br><span class="hljs-meta">    ((Object *)(obj))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CLASS:</span><br><span class="hljs-comment"> * @class: A derivative of #ObjectClass.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Converts a class to an #ObjectClass.  Since all objects are #Objects,</span><br><span class="hljs-comment"> * this function will always succeed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CLASS(class) \</span><br><span class="hljs-meta">    ((ObjectClass *)(class))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CHECK:</span><br><span class="hljs-comment"> * @type: The C type to use for the return value.</span><br><span class="hljs-comment"> * @obj: A derivative of @type to cast.</span><br><span class="hljs-comment"> * @name: The QOM typename of @type</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A type safe version of @object_dynamic_cast_assert.  Typically each class</span><br><span class="hljs-comment"> * will define a macro based on this type to perform type safe dynamic_casts to</span><br><span class="hljs-comment"> * this object type.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If an invalid object is passed to this function, a run time assert will be</span><br><span class="hljs-comment"> * generated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CHECK(type, obj, name) \</span><br><span class="hljs-meta">    ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \</span><br><span class="hljs-meta">                                        __FILE__, __LINE__, __func__))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CLASS_CHECK:</span><br><span class="hljs-comment"> * @class_type: The C type to use for the return value.</span><br><span class="hljs-comment"> * @class: A derivative class of @class_type to cast.</span><br><span class="hljs-comment"> * @name: the QOM typename of @class_type.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A type safe version of @object_class_dynamic_cast_assert.  This macro is</span><br><span class="hljs-comment"> * typically wrapped by each type to perform type safe casts of a class to a</span><br><span class="hljs-comment"> * specific class type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CLASS_CHECK(class_type, class, name) \</span><br><span class="hljs-meta">    ((class_type *)object_class_dynamic_cast_assert(OBJECT_CLASS(class), (name), \</span><br><span class="hljs-meta">                                               __FILE__, __LINE__, __func__))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_GET_CLASS:</span><br><span class="hljs-comment"> * @class: The C type to use for the return value.</span><br><span class="hljs-comment"> * @obj: The object to obtain the class for.</span><br><span class="hljs-comment"> * @name: The QOM typename of @obj.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function will return a specific class for a given object.  Its generally</span><br><span class="hljs-comment"> * used by each type to provide a type safe macro to get a specific class type</span><br><span class="hljs-comment"> * from an object.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_GET_CLASS(class, obj, name) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(class, object_get_class(OBJECT(obj)), name)</span><br><br></code></pre></td></tr></table></figure>

<p>以<code>OBJECT_DECLARE_TYPE(X86CPU, X86CPUClass, X86_CPU)</code>为例，宏展开如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPU</span> <span class="hljs-title">X86CPU</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPUClass</span> <span class="hljs-title">X86CPUClass</span>;</span><br>G_DEFINE_AUTOPTR_CLEANUP_FUNC(X86CPU, object_unref)<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPU *<span class="hljs-title">X86_CPU</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPU *)object_dynamic_cast_assert(<br>      ((Object *)(obj)), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPUClass *<span class="hljs-title">X86_CPU_GET_CLASS</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPUClass *)object_class_dynamic_cast_assert(<br>      ((ObjectClass *)(object_get_class(((Object *)(obj))))), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPUClass *<span class="hljs-title">X86_CPU_CLASS</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *klass)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPUClass *)object_class_dynamic_cast_assert(<br>      ((ObjectClass *)(klass)), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>OBJECT_DECLARE_TYPE</code>通常在头文件中使用，效果是：</p>
<ul>
<li>创建了<code>X86CPU</code>和<code>X86CPUClass</code>的<code>typedef</code></li>
<li>用<code>G_DEFINE_AUTOPTR_CLEANUP_FUNC</code>注册类型</li>
<li>创建了三个类型转换函数<ul>
<li><code>X86_CPU</code> : 将任何一个 <code>object</code> 指针 转换为 <code>X86CPU</code>（Object 转子对象）</li>
<li><code>X86_CPU_GET_CLASS</code> : 根据 <code>object</code> 指针获取到 <code>X86CPUClass</code></li>
<li><code>X86_CPU_CLASS</code> : 根据 <code>ObjectClass</code> 指针转换到 <code>X86CPUClass</code>（基类转子类）</li>
</ul>
</li>
</ul>
<p>这里的转换依赖内存布局，子类型的第一个成员总是基类型。子类转基类就很容易，只需要强制类型转换就可以实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://martins3.github.io/qemu/qom.html#init">QEMU 中的面向对象 : QOM | Deep Dark Fantasy</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4a9d26abb44d">浅谈 QEMU 的对象系统 - 简书</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url">QEMU 源码分析-内存虚拟化</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-25T05:42:11.000Z" itemprop="datePublished">1月 25 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/QEMU-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">QEMU 源码分析</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 lesen (Über 10654 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>1.大部分转载自<a target="_blank" rel="noopener" href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a><br>2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改<br>3.部分内容根据自己理解补充添加</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：</p>
<ul>
<li>虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间；</li>
<li>虚拟机里面的物理内存（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存；</li>
<li>物理机的虚拟内存（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间；</li>
<li>物理机的物理内存（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。</li>
</ul>
<p>内存虚拟化的关键在于维护 <code>GPA</code> 到 <code>HVA</code> 的映射关系。</p>
<h2 id="页面分配和映射的两种方式"><a href="#页面分配和映射的两种方式" class="headerlink" title="页面分配和映射的两种方式"></a>页面分配和映射的两种方式</h2><p>要搞清楚 QEMU system emulation 的仿真架构，首先对于 Host OS，将 QEMU 作为进程启动，然后对于 QEMU 进程，会仿真各种硬件和运行 Guest OS，在这层 OS 上运行要全系统模拟的应用程序，因此对于 Guest OS 管理的内存要实现到 QEMU 进程的虚拟空间的转换需要 softMMU（即需要对 GPA 到 HVA 进行转换）。从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。</p>
<h3 id="影子页表-Shadow-Page-Table，SPT"><a href="#影子页表-Shadow-Page-Table，SPT" class="headerlink" title="影子页表 Shadow Page Table，SPT"></a>影子页表 Shadow Page Table，SPT</h3><p>第一种方式就是软件的方式，影子页表（Shadow Page Table）。</p>
<p>KVM 通过维护记录 GVA-&gt;HPA 的影子页表 SPT，减少了地址转换带来的开销，可以直接将 GVA 转换为 HPA。</p>
<p>内存映射要通过页表来管理，页表地址应该放在 CR3 寄存器里面。在软件虚拟化的内存转换中，GVA 到 GPA 的转换通过查询 CR3 寄存器来完成，CR3 中保存了 Guest 的页表基地址，然后载入 MMU 中进行地址转换。</p>
<p>在加入了 SPT 技术后，当 Guest 访问 CR3 时，KVM 会捕获到这个操作 EXIT_REASON_CR_ACCESS，之后 KVM 会载入特殊的 CR3 和影子页表，欺骗 Guest 这就是真实的 CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。</p>
<blockquote>
<p>本来的过程是，客户机要通过 cr3 找到客户机的页表，实现从 GVA 到 GPA 的转换，然后在宿主机上，要通过 cr3 找到宿主机的页表，实现从 HVA 到 HPA 的转换。<br>为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。<br>在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。</p>
</blockquote>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124192700.png"></p>
<p>为了快速检索 Guest 页表对应的影子页表，KVM 为每个客户机维护了一个 hash 表来进行客户机页表到影子页表之间的映射。对于每一个 Guest 来说，其页目录和页表都有唯一的 GPA，通过页目录/页表的 GPA 就可以在哈希链表中快速地找到对应的影子页目录/页表。</p>
<p>当 Guest 切换进程时，Guest 会把待切换进程的页表基址载入 CR3，而 KVM 将会截获这一特权指令。KVM 在哈希表中找到与此页表基址对应的影子页表基址，载入 Guest CR3，使 Guest 在恢复运行时 CR3 实际指向的是新切换进程对应的影子页表。</p>
<p>影子页表的引入，减少了 GVA-&gt;HPA 的转换开销，但是缺点在于需要为 Guest 的每个进程都维护一个影子页表，这将带来很大的内存开销。同时影子页表的建立是很耗时的，如果 Guest 的进程过多，将导致影子页表频繁切换。</p>
<p>因此 Intel 和 AMD 在此基础上提供了基于硬件的虚拟化技术 EPT。</p>
<h3 id="扩展页表-Extent-Page-Table，EPT"><a href="#扩展页表-Extent-Page-Table，EPT" class="headerlink" title="扩展页表 Extent Page Table，EPT"></a>扩展页表 Extent Page Table，EPT</h3><p>Intel 的 EPT（Extent Page Table）技术和 AMD 的 NPT（Nest Page Table）技术都对内存虚拟化提供了硬件支持。这两种技术原理类似，都是在硬件层面上实现 GVA 到 HPA 之间的转换。下面就以 EPT 为例分析一下 KVM 基于硬件辅助的内存虚拟化实现。</p>
<p>EPT 在原有客户机页表对客户机虚拟地址 GVA 到客户机物理地址 GPA 映射的基础上，又引入了 EPT 页表来实现客户机物理地址 GPA 到宿主机物理地址 HPA 的另一次映射。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。</p>
<p>即 EPT 技术采用了在两级页表结构，即原有 Guest OS 页表对 <strong>GVA-&gt;GPA</strong> 映射的基础上，又引入了 EPT 页表来实现 <strong>GPA-&gt;HPA</strong> 的另一次映射，这<strong>两次地址映射都是由硬件自动完成</strong>。</p>
<p>有了 EPT，在<strong>GPA-&gt;HPA</strong>转换的过程中，缺页会产生 EPT 缺页异常。KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。</p>
<p>KVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。</p>
<p>这里，我们重点看第二种方式。因为使用了 EPT 之后，客户机里面的页表映射，也即从 GVA 到 GPA 的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而 EPT 重点帮我们解决的就是从 GPA 到 HPA 的转换问题。因为要经过两次页表，所以 EPT 又 tdp(two dimentional paging)。</p>
<p>EPT 的页表结构也是分为四层，EPT Pointer（EPTP）指向 PML4 的首地址。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124194059.png"></p>
<h2 id="QEMU-的主要工作"><a href="#QEMU-的主要工作" class="headerlink" title="QEMU 的主要工作"></a>QEMU 的主要工作</h2><p>内存虚拟化的目的就是让虚拟机能够无缝的访问内存。有了 Intel EPT 的支持后，CPU 在 VMX non-root 状态时进行内存访问会再做一次 EPT 转换。在这个过程中，QEMU 会负责以下内容：</p>
<p>首先需要从自己的进程地址空间中申请内存用于 Guest<br>需要将上一步中申请到的内存的虚拟地址（HVA）和 Guest 的物理地址之间的映射关系传递给 KVM（kernel），即 GPA-&gt;HVA<br>需要组织一系列的数据结构来管理虚拟内存空间，并在内存拓扑结构更改时将最新的内存信息同步至 KVM 中</p>
<h2 id="QEMU-和-KVM-的工作分界"><a href="#QEMU-和-KVM-的工作分界" class="headerlink" title="QEMU 和 KVM 的工作分界"></a>QEMU 和 KVM 的工作分界</h2><p>QEMU 和 KVM 之间是通过 KVM 提供的 ioctl() 接口进行交互的。在内核的 kvm_vm_ioctl() 中，<strong>设置虚拟机内存</strong>的系统调用【kernel 就是一系列系统调用函数接口和处理逻辑，其中有个处理”创建/设置虚拟机内存“的系统调用接口】为  <code>VM_SET_USER_MEMORY_REGION</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">kvm_vm_ioctl</span><span class="hljs-params">(struct file *filp,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ioctl, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">case</span> KVM_SET_USER_MEMORY_REGION: &#123; <span class="hljs-comment">// 在 KVM 中注册用户空间传入的内存信息</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">kvm_userspace_mem</span>;</span><br><br>        r = -EFAULT;<br>         <span class="hljs-comment">// 将传入的数据结构复制到内核空间</span><br>        <span class="hljs-keyword">if</span> (copy_from_user(&amp;kvm_userspace_mem, argp, <span class="hljs-keyword">sizeof</span> kvm_userspace_mem))<br>            <span class="hljs-keyword">goto</span> out;<br><br>         <span class="hljs-comment">// 实际进行处理的函数</span><br>        r = kvm_vm_ioctl_set_memory_region(kvm, &amp;kvm_userspace_mem, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (r)<br>            <span class="hljs-keyword">goto</span> out;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里需要传递的参数类型为 <code>kvm_userspace_memory_region</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* for KVM_SET_USER_MEMORY_REGION */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;            <span class="hljs-comment">// slot 编号 [参考：https://www.cnblogs.com/LoyenWang/p/11922887.html]</span><br>    __u32 flags;           <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    __u64 guest_phys_addr; <span class="hljs-comment">// Guest 物理地址，即 GPA</span><br>    __u64 memory_size;     <span class="hljs-comment">// 内存大小，单位 bytes</span><br>    __u64 userspace_addr;  <span class="hljs-comment">// 从 QEMU 进程地址空间中分配内存的起始地址，即 HVA</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>KVM_SET_USER_MEMORY_REGION</code>这个 <code>ioctl</code> 主要目的就是设置<code>GPA-&gt;HVA</code>的映射关系，KVM 会继续调用<code>kvm_vm_ioctl_set_memory_region()</code>，在内核空间维护并管理 Guest 的内存。</p>
<h2 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h2><h3 id="AddressSpace"><a href="#AddressSpace" class="headerlink" title="AddressSpace"></a>AddressSpace</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>QEMU 用 AddressSpace 结构体表示 Guest 中 CPU/设备看到的内存【也就是Guest OS 可以在 QEMU 进程虚存中用到的所有内存，是 MemoryRegion 的集合，即 GPA 的整体】，类似于物理机中地址空间的概念，但在这里表示的是 Guest 的一段地址空间，如内存地址空间 <code>address_space_memory</code> 、<code>I/O</code> 地址空间<code>address_space_io</code>，它在 QEMU 源码<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSpace</span> &#123;</span><br>    <span class="hljs-comment">/* private: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-keyword">char</span> *name;<br>    MemoryRegion *root;<br><br>    <span class="hljs-comment">/* Accessed via RCU.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatView</span> *<span class="hljs-title">current_map</span>;</span><br><br>    <span class="hljs-keyword">int</span> ioeventfd_nb;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionIoeventfd</span> *<span class="hljs-title">ioeventfds</span>;</span><br>    QTAILQ_HEAD(, MemoryListener) listeners;<br>    QTAILQ_ENTRY(AddressSpace) address_spaces_link;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每个 AddressSpace 一般包含一系列的 MemoryRegion：<code>root</code>指针指向根级 MemoryRegion，而 root 可能有自己的若干个 sub-regions（子节点），于是形成树状结构。这些 MemoryRegion 通过树连接起来，树的根即为 AddressSpace 的 root 域。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>另外，QEMU 中有两个全局的静态 AddressSpace，在 memory.c 中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> AddressSpace address_space_memory; <span class="hljs-comment">// 内存地址空间</span><br><span class="hljs-keyword">static</span> AddressSpace address_space_io;     <span class="hljs-comment">// I/O 地址空间</span><br></code></pre></td></tr></table></figure>

<p>其 root 域分别指向之后会提到的两个 MemoryRegion 类型变量：system_memory、system_io。</p>
<h3 id="MemoryRegion"><a href="#MemoryRegion" class="headerlink" title="MemoryRegion"></a>MemoryRegion</h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>MemoryRegion</code> 表示在 <code>Guest Memory Layout</code> 中的一段内存区域【也就是单元级 GPA 的概念，Guest OS 可以管理到的那些 Guest 物理内存单元】，它是联系 <code>GPA</code> 和 <code>RAMBlocks</code>（描述真实内存）之间的桥梁，在<code>memory.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> &#123;</span><br>    <span class="hljs-comment">/* All fields are private - violators will be prosecuted */</span><br>    <span class="hljs-keyword">const</span> MemoryRegionOps *ops;      <span class="hljs-comment">// 回调函数集合</span><br>    <span class="hljs-keyword">void</span> *opaque;<br>    MemoryRegion *parent;            <span class="hljs-comment">// 父 MemoryRegion 指针</span><br>    Int128 size;                     <span class="hljs-comment">// 该区域内存的大小</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> addr;         <span class="hljs-comment">// 在 Address Space 中的地址，即 HVA</span><br>    <span class="hljs-keyword">void</span> (*destructor)(MemoryRegion *mr);<br>    <span class="hljs-keyword">ram_addr_t</span> ram_addr;             <span class="hljs-comment">// MemoryRegion 的起始地址，即 GPA</span><br>    <span class="hljs-keyword">bool</span> subpage;<br>    <span class="hljs-keyword">bool</span> terminates;<br>    <span class="hljs-keyword">bool</span> readable;<br>    <span class="hljs-keyword">bool</span> ram;                        <span class="hljs-comment">// 是否表示 RAM</span><br>    <span class="hljs-keyword">bool</span> readonly; <span class="hljs-comment">/* For RAM regions */</span><br>    <span class="hljs-keyword">bool</span> enabled;                    <span class="hljs-comment">// 是否已经通知 KVM 使用这段内存</span><br>    <span class="hljs-keyword">bool</span> rom_device;<br>    <span class="hljs-keyword">bool</span> warning_printed; <span class="hljs-comment">/* For reservations */</span><br>    MemoryRegion *alias;             <span class="hljs-comment">// 是否为 MemoryRegion alias</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> alias_offset; <span class="hljs-comment">// 若为 alias，在原 MemoryRegion 中的 offset</span><br>    <span class="hljs-keyword">unsigned</span> priority;<br>    <span class="hljs-keyword">bool</span> may_overlap;<br>    QTAILQ_HEAD(subregions, MemoryRegion) subregions; <span class="hljs-comment">// 子区域链表头</span><br>    QTAILQ_ENTRY(MemoryRegion) subregions_link;       <span class="hljs-comment">// 子区域链表节点</span><br>    QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;       <span class="hljs-comment">// MemoryRegion 的名字，调试时使用</span><br>    <span class="hljs-keyword">uint8_t</span> dirty_log_mask; <span class="hljs-comment">// 表示哪一种 dirty map 被使用，共分三种</span><br>    <span class="hljs-keyword">unsigned</span> ioeventfd_nb;<br>    MemoryRegionIoeventfd *ioeventfds;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><p>在 QEMU 的 exec.c 中也定义了两个静态的 MemoryRegion 指针变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> MemoryRegion *system_memory; <span class="hljs-comment">// 内存 MemoryRegion，对应 address_space_memory</span><br><span class="hljs-keyword">static</span> MemoryRegion *system_io;     <span class="hljs-comment">// I/O MemoryRegion，对应 address_space_io</span><br></code></pre></td></tr></table></figure>

<p>与两个全局 AddressSpace 对应，即 AddressSpace 的 root 域指向这两个 MemoryRegion。</p>
<h4 id="MemoryRegion-的类型"><a href="#MemoryRegion-的类型" class="headerlink" title="MemoryRegion 的类型"></a>MemoryRegion 的类型</h4><p>MemoryRegion 有多种类型，可以表示一段 RAM、ROM、MMIO、alias(别名)。</p>
<p>若为 alias 则表示一个 MemoryRegion 的部分区域，例如，QEMU 会为 pc.ram 这个表示 RAM 的 MemoryRegion 添加两个 alias：ram-below-4g 和 ram-above-4g，之后会看到具体的代码实例。</p>
<p>另外，MemoryRegion 也可以表示一个 container，这就表示它只是其他若干个 MemoryRegion 的容器。</p>
<p>那么要如何创建不同类型的 <code>MemoryRegion</code> 呢？</p>
<p>在 QEMU 中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将 MemoryRegion 划分为以下三种类型：</p>
<ul>
<li>根级 MemoryRegion：直接通过 memory_region_init 初始化，没有自己的内存，用于管理 subregion，例如 system_memory：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    mr-&gt;ops = <span class="hljs-literal">NULL</span>;<br>    mr-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    mr-&gt;size = int128_make64(size);<br>    <span class="hljs-keyword">if</span> (size == UINT64_MAX) &#123;<br>        mr-&gt;size = int128_2_64();<br>    &#125;<br>    mr-&gt;addr = <span class="hljs-number">0</span>;<br>    mr-&gt;subpage = <span class="hljs-literal">false</span>;<br>    mr-&gt;enabled = <span class="hljs-literal">true</span>;<br>    mr-&gt;terminates = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 非实体 MemoryRegion，搜索时会继续前往其 subregions</span><br>    mr-&gt;ram = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 根级 MemoryRegion 不分配内存</span><br>    mr-&gt;readable = <span class="hljs-literal">true</span>;<br>    mr-&gt;readonly = <span class="hljs-literal">false</span>;<br>    mr-&gt;rom_device = <span class="hljs-literal">false</span>;<br>    mr-&gt;destructor = memory_region_destructor_none;<br>    mr-&gt;priority = <span class="hljs-number">0</span>;<br>    mr-&gt;may_overlap = <span class="hljs-literal">false</span>;<br>    mr-&gt;alias = <span class="hljs-literal">NULL</span>;<br>    QTAILQ_INIT(&amp;mr-&gt;subregions);<br>    <span class="hljs-built_in">memset</span>(&amp;mr-&gt;subregions_link, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> mr-&gt;subregions_link);<br>    QTAILQ_INIT(&amp;mr-&gt;coalesced);<br>    mr-&gt;name = g_strdup(name);<br>    mr-&gt;dirty_log_mask = <span class="hljs-number">0</span>;<br>    mr-&gt;ioeventfd_nb = <span class="hljs-number">0</span>;<br>    mr-&gt;ioeventfds = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到 mr-&gt;addr 被设置为 0，而 mr-&gt;ram_addr 则并没有初始化。</p>
<ul>
<li>实体 <code>MemoryRegion</code>：通过<code>memory_region_init_ram()</code>初始化，有自己的内存（从 QEMU 进程地址空间中分配），大小为<code>size</code>，例如<code>ram_memory</code>、 <code>pci_memory</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram, *option_rom_mr;<br>    <span class="hljs-comment">/* ...*/</span><br><br>    <span class="hljs-comment">/* Allocate RAM.  We allocate it as a single memory region and use</span><br><span class="hljs-comment">     * aliases to address portions of it, mostly for backwards compatibility</span><br><span class="hljs-comment">     * with older qemus that used qemu_ram_alloc().</span><br><span class="hljs-comment">     */</span><br>    ram = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram));<br>    <span class="hljs-comment">// 调用 memory_region_init_ram 对 ram_memory 进行初始化</span><br>    memory_region_init_ram(ram, <span class="hljs-string">&quot;pc.ram&quot;</span>, below_4g_mem_size + above_4g_mem_size);<br>    vmstate_register_ram_global(ram);<br>    *ram_memory = ram;<br><br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size);<br>    mr-&gt;ram = <span class="hljs-literal">true</span>;<br>    mr-&gt;terminates = <span class="hljs-literal">true</span>;<br>    mr-&gt;destructor = memory_region_destructor_ram;<br>    mr-&gt;ram_addr = qemu_ram_alloc(size, mr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里是先调用了<code>memory_region_init()</code>，之后设置 <code>RAM</code> 属性，并继续调用<code>qemu_ram_alloc()</code>分配内存。</p>
<ul>
<li>别名 <code>MemoryRegion</code>：通过<code>memory_region_init_alias()</code> 初始化，没有自己的内存，表示实体 <code>MemoryRegion</code> 的一部分。通过 <code>alias</code> 成员指向实体 <code>MemoryRegion</code>，<code>alias_offset</code>为在实体 <code>MemoryRegion</code> 中的偏移量，例如<code>ram_below_4g</code>、<code>ram_above_4g</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram_below_4g, *ram_above_4g;<br>    <span class="hljs-comment">/* ... */</span><br>    ram_below_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_below_4g));<br>    <span class="hljs-comment">// 调用 memory_region_init_alias 对 ram_below_4g 进行初始化</span><br>    memory_region_init_alias(ram_below_4g, <span class="hljs-string">&quot;ram-below-4g&quot;</span>, ram, <span class="hljs-number">0</span>, below_4g_mem_size);<br>    <span class="hljs-comment">/* ..</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_alias</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                              MemoryRegion *orig,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">target_phys_addr_t</span> offset,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size);<br>    mr-&gt;alias = orig; <span class="hljs-comment">// 指向实体 MemoryRegion</span><br>    mr-&gt;alias_offset = offset; <span class="hljs-comment">//通过 offset 得到实体的某一个部分</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="RAMBlock"><a href="#RAMBlock" class="headerlink" title="RAMBlock"></a>RAMBlock</h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>MemoryRegion</code> 用来描述一段逻辑层面上的内存区域，而记录实际分配的内存地址信息的结构体则是 <code>RAMBlock</code>，在<code>ramblock.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RAMBlock</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> *<span class="hljs-title">mr</span>;</span><br>    <span class="hljs-keyword">uint8_t</span> *host;<br>    <span class="hljs-keyword">uint8_t</span> *colo_cache; <span class="hljs-comment">/* For colo, VM&#x27;s ram cache */</span><br>    <span class="hljs-keyword">ram_addr_t</span> offset;<br>    <span class="hljs-keyword">ram_addr_t</span> used_length;<br>    <span class="hljs-keyword">ram_addr_t</span> max_length;<br>    <span class="hljs-keyword">void</span> (*resized)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">uint64_t</span> length, <span class="hljs-keyword">void</span> *host);<br>    <span class="hljs-keyword">uint32_t</span> flags;<br>    <span class="hljs-comment">/* Protected by iothread lock.  */</span><br>    <span class="hljs-keyword">char</span> idstr[<span class="hljs-number">256</span>];<br>    <span class="hljs-comment">/* RCU-enabled, writes protected by the ramlist lock */</span><br>    QLIST_ENTRY(RAMBlock) next;<br>    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;<br>    <span class="hljs-keyword">int</span> fd;<br>    <span class="hljs-keyword">size_t</span> page_size;<br>    <span class="hljs-comment">/* dirty bitmap used during migration */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *bmap;<br>    <span class="hljs-comment">/* bitmap of already received pages in postcopy */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *receivedmap;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * bitmap to track already cleared dirty bitmap.  When the bit is</span><br><span class="hljs-comment">     * set, it means the corresponding memory chunk needs a log-clear.</span><br><span class="hljs-comment">     * Set this up to non-NULL to enable the capability to postpone</span><br><span class="hljs-comment">     * and split clearing of dirty bitmap on the remote node (e.g.,</span><br><span class="hljs-comment">     * KVM).  The bitmap will be set only when doing global sync.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> this bitmap is different comparing to the other bitmaps</span><br><span class="hljs-comment">     * in that one bit can represent multiple guest pages (which is</span><br><span class="hljs-comment">     * decided by the `clear_bmap_shift&#x27; variable below).  On</span><br><span class="hljs-comment">     * destination side, this should always be NULL, and the variable</span><br><span class="hljs-comment">     * `clear_bmap_shift&#x27; is meaningless.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *clear_bmap;<br>    <span class="hljs-keyword">uint8_t</span> clear_bmap_shift;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * RAM block length that corresponds to the used_length on the migration</span><br><span class="hljs-comment">     * source (after RAM block sizes were synchronized). Especially, after</span><br><span class="hljs-comment">     * starting to run the guest, used_length and postcopy_length can differ.</span><br><span class="hljs-comment">     * Used to register/unregister uffd handlers and as the size of the received</span><br><span class="hljs-comment">     * bitmap. Receiving any page beyond this length will bail out, as it</span><br><span class="hljs-comment">     * could not have been valid on the source.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">ram_addr_t</span> postcopy_length;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>可以看到在 <code>RAMBlock</code> 中 host 和 offset 域分别对应了 <code>HVA</code> 和<code>GPA</code>，因此也可以说 <code>RAMBlock</code> 中存储了<code>GPA-&gt;HVA</code>的映射关系，另外每一个 <code>RAMBlock</code> 都会指向其所属的 <code>MemoryRegion</code>。</p>
<h4 id="全局变量-ram-list"><a href="#全局变量-ram-list" class="headerlink" title="全局变量 ram_list"></a>全局变量 ram_list</h4><p>QEMU 在<code>ramlist.h</code>中定义了一个全局变量<code>ram_list</code>，以链表的形式维护了所有的 <code>RAMBlock</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RAMList</span> &#123;</span><br>    QemuMutex mutex;<br>    RAMBlock *mru_block;<br>    <span class="hljs-comment">/* RCU-enabled, writes protected by the ramlist lock. */</span><br>    QLIST_HEAD(, RAMBlock) blocks;<br>    DirtyMemoryBlocks *dirty_memory[DIRTY_MEMORY_NUM];<br>    <span class="hljs-keyword">uint32_t</span> version;<br>    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;<br>&#125; RAMList;<br><span class="hljs-keyword">extern</span> RAMList ram_list;<br></code></pre></td></tr></table></figure>

<p>每一个新分配的 <code>RAMBlock</code> 都会被插入到<code>ram_list</code>的头部。如需查找地址所对应的 <code>RAMBlock</code>，则需要遍历<code>ram_list</code>，当目标地址落在当前<code>RAMBlock</code>的地址区间时，该 <code>RAMBlock</code> 即为查找目标。</p>
<h4 id="AS、MR、RAMBlock-之间的关系"><a href="#AS、MR、RAMBlock-之间的关系" class="headerlink" title="AS、MR、RAMBlock 之间的关系"></a>AS、MR、RAMBlock 之间的关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225155936.png"></p>
<h3 id="FlatView"><a href="#FlatView" class="headerlink" title="FlatView"></a>FlatView</h3><p>AddressSpace 的 root 域及其子树共同构成了 Guest 的物理地址空间，但这些都是在 QEMU 侧定义的。要传入 KVM 进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其<strong>转换为一个“平坦”的地址模</strong>型，也就是一个从零开始、只包含地址信息的数据结构，这在 QEMU 中通过 <strong>FlatView</strong> 来表示。每个 AddressSpace 都有一个与之对应的 FlatView 指针 current_map，表示其对应的平面展开视图。</p>
<h4 id="结构体定义-3"><a href="#结构体定义-3" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>FlatView</code> 在<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* Flattened global view of current active memory hierarchy.  Kept in sorted</span><br><span class="hljs-comment"> * order.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatView</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-keyword">unsigned</span> ref;<br>    FlatRange *ranges;      <span class="hljs-comment">// 对应的 FlatRange 数组</span><br>    <span class="hljs-keyword">unsigned</span> nr;            <span class="hljs-comment">// FlatRange 的数目</span><br>    <span class="hljs-keyword">unsigned</span> nr_allocated;  <span class="hljs-comment">// 当前数组的项数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSpaceDispatch</span> *<span class="hljs-title">dispatch</span>;</span><br>    MemoryRegion *root;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其中，<code>ranges</code>是一个数组，记录了 <code>FlatView</code> 下所有的 <code>FlatRange</code>。</p>
<h4 id="FlatRange"><a href="#FlatRange" class="headerlink" title="FlatRange"></a>FlatRange</h4><p>在 <code>FlatView</code> 中，<code>FlatRange</code> 表示在 <code>FlatView</code> 中的一段内存范围，同样在<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Range of memory in the global map.  Addresses are absolute. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatRange</span> &#123;</span><br>    MemoryRegion *mr;           <span class="hljs-comment">// 指向所属的 MemoryRegion</span><br>    hwaddr offset_in_region;    <span class="hljs-comment">// 在全局 MemoryRegion 中的 offset，对应 GPA</span><br>    AddrRange addr;             <span class="hljs-comment">// 代表的地址区间，对应 HVA</span><br>    <span class="hljs-keyword">uint8_t</span> dirty_log_mask;<br>    <span class="hljs-keyword">bool</span> romd_mode;<br>    <span class="hljs-keyword">bool</span> readonly;<br>    <span class="hljs-keyword">bool</span> nonvolatile;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每个 <code>FlatRange</code> 对应一段虚拟机物理地址区间，各个 <code>FlatRange</code> 不会重叠，<strong>按照地址的顺序保存在数组中</strong>，具体的地址范围由一个 <code>AddrRange</code> 结构来描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * AddrRange 用于表示 FlatRange 的起始地址及大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddrRange</span> &#123;</span><br>    Int128 start;<br>    Int128 size;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="MemoryRegionSection"><a href="#MemoryRegionSection" class="headerlink" title="MemoryRegionSection"></a>MemoryRegionSection</h3><h4 id="结构体定义-4"><a href="#结构体定义-4" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>在 <code>QEMU</code> 中，还有几个起到中介作用的结构体，<code>MemoryRegionSection</code> 就是其中之一。</p>
<p>之前介绍的 <code>FlatRange</code> 代表一个物理地址空间的片段，偏向于描述在 <code>Host</code> 侧即 <strong>AddressSpace 中的分布【Guest 的物理空间】</strong>，而 <code>MemoryRegionSection</code> 则代表在 <code>Guest</code> 侧即 <strong>MemoryRegion 中的片段</strong>。<code>MemoryRegionSection</code> 在<code>memory.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MemoryRegionSection: describes a fragment of a #MemoryRegion</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @mr: the region, or %NULL if empty</span><br><span class="hljs-comment"> * @address_space: the address space the region is mapped in</span><br><span class="hljs-comment"> * @offset_within_region: the beginning of the section, relative to @mr&#x27;s start</span><br><span class="hljs-comment"> * @size: the size of the section; will not exceed @mr&#x27;s boundaries</span><br><span class="hljs-comment"> * @offset_within_address_space: the address of the first byte of the section</span><br><span class="hljs-comment"> *     relative to the region&#x27;s address space</span><br><span class="hljs-comment"> * @readonly: writes to this section are ignored</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//只是起到描述的作用，描述了是哪个 AddressSpace 的 MemoryRegion，</span><br> <span class="hljs-comment">//并且在 MemoryRegion 中的 offset，和在 AddressSpace 展开为平坦内存的 offset</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionSection</span> &#123;</span>  <br>    MemoryRegion *mr;                               <span class="hljs-comment">// 所属的 MemoryRegion</span><br>    MemoryRegion *address_space;                    <span class="hljs-comment">// 关联的 AddressSpace</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> offset_within_region;        <span class="hljs-comment">// 在 MemoryRegion 内部的 offset</span><br>    <span class="hljs-keyword">uint64_t</span> size;                                  <span class="hljs-comment">// Section 的大小</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> offset_within_address_space; <span class="hljs-comment">// 在 AddressSpace 内部的 offset</span><br>    <span class="hljs-keyword">bool</span> readonly;                                  <span class="hljs-comment">// 是否为只读</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>offset_within_region</code>：在所属 <code>MemoryRegion</code> 中的<code>offset</code>。一个<code>AddressSpace</code> 可能由多个 <code>MemoryRegion</code> 组成，因此该 <code>offset</code> 是局部的</li>
<li><code>offset_within_address_space</code>：在所属 <code>AddressSpace</code> 中的 <code>offset</code>，它是全局的</li>
</ul>
<h4 id="和其他数据结构之间的关系"><a href="#和其他数据结构之间的关系" class="headerlink" title="和其他数据结构之间的关系"></a>和其他数据结构之间的关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125110422.png"></p>
<ul>
<li><code>AddressSpace</code> 的<code>root</code>指向对应的根级<code>MemoryRegion</code>，<code>current_map</code>指向<code>AddressSpace</code> 的<code>root</code>通过<code>generate_memory_topology()</code>生成的 <code>FlatView</code></li>
<li><code>FlatView</code> 中的<code>ranges</code>数组表示该<code>MemoryRegion</code> 所表示的<code>Guest</code>地址区间【GPA 的整个平坦物理空间】，并按照地址的顺序进行排列</li>
<li><code>MemoryRegionSection</code> 由<code>ranges</code>数组中的 <code>FlatRange</code> 对应生成，作为注册到 <code>KVM</code>中的基本单位</li>
</ul>
<hr>
<p><code>QEMU</code> 在用户空间申请内存后，需要将内存信息通过一系列系统调用传入内核空间的 <code>KVM</code>，由 <code>KVM</code> 侧进行管理，因此 <code>QEMU</code> 侧也定义了一些用于向 <code>KVM</code> 传递参数的结构体。</p>
<p>以下为<code>KVM</code>相关的数据结构。</p>
<h3 id="KVMSlot"><a href="#KVMSlot" class="headerlink" title="KVMSlot"></a>KVMSlot</h3><p><code>在 kvm_init.h</code>中定义，是 <code>KVM</code> 中内存管理的基本单位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KVMSlot</span></span><br><span class="hljs-class">&#123;</span><br>    hwaddr start_addr; <span class="hljs-comment">// Guest 物理地址，GPA</span><br>    <span class="hljs-keyword">ram_addr_t</span> memory_size;        <span class="hljs-comment">// 内存大小</span><br>    <span class="hljs-keyword">void</span> *ram; <span class="hljs-comment">// QEMU 用户空间地址，HVA</span><br>    <span class="hljs-keyword">int</span> slot;  <span class="hljs-comment">// Slot 编号</span><br>    <span class="hljs-keyword">int</span> flags; <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    <span class="hljs-comment">/* Dirty bitmap cache for the slot */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *dirty_bmap;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> dirty_bmap_size;<br>    <span class="hljs-comment">/* Cache of the address space ID */</span><br>    <span class="hljs-keyword">int</span> as_id;<br>    <span class="hljs-comment">/* Cache of the offset in ram address space */</span><br>    <span class="hljs-keyword">ram_addr_t</span> ram_start_offset;<br>&#125; KVMSlot;<br></code></pre></td></tr></table></figure>

<p><code>KVMSlot</code> 类似于内存插槽的概念。</p>
<h3 id="kvm-userspace-memory-region"><a href="#kvm-userspace-memory-region" class="headerlink" title="kvm_userspace_memory_region"></a>kvm_userspace_memory_region</h3><p>调用<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>时需要向 <code>KVM</code> 传递的参数，在<code>kvm.h</code>中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* for KVM_SET_USER_MEMORY_REGION */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;            <span class="hljs-comment">// slot 编号</span><br>    __u32 flags;           <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    __u64 guest_phys_addr; <span class="hljs-comment">// Guest 物理地址，GPA</span><br>    __u64 memory_size;     <span class="hljs-comment">// 内存大小，bytes</span><br>    __u64 userspace_addr;  <span class="hljs-comment">// 从 QEMU 进程空间分配的起始地址，HVA</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="MemoryListener"><a href="#MemoryListener" class="headerlink" title="MemoryListener"></a>MemoryListener</h3><h4 id="结构体定义-5"><a href="#结构体定义-5" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>为了监控虚拟机的物理地址访问，对于每一个 <code>AddressSpace</code>，都会有一个 <code>MemoryListener</code> 与之对应。每当物理映射<code>GPA-&gt;HVA</code>发生改变时，就会回调这些函数。<strong>MemoryListener</strong> 是对一些事件的<strong>回调函数合集</strong>，在<code>memory.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MemoryListener: callbacks structure for updates to the physical memory map</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Allows a component to adjust to changes in the guest-visible memory map.</span><br><span class="hljs-comment"> * Use with memory_listener_register() and memory_listener_unregister().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryListener</span> &#123;</span><br>    <span class="hljs-keyword">void</span> (*begin)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*commit)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*region_add)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*region_del)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*region_nop)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_start)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_stop)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_sync)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_global_start)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*log_global_stop)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*eventfd_add)(MemoryListener *listener, MemoryRegionSection *section,<br>                        <span class="hljs-keyword">bool</span> match_data, <span class="hljs-keyword">uint64_t</span> data, EventNotifier *e);<br>    <span class="hljs-keyword">void</span> (*eventfd_del)(MemoryListener *listener, MemoryRegionSection *section,<br>                        <span class="hljs-keyword">bool</span> match_data, <span class="hljs-keyword">uint64_t</span> data, EventNotifier *e);<br>    <span class="hljs-comment">/* Lower = earlier (during add), later (during del) */</span><br>    <span class="hljs-keyword">unsigned</span> priority;<br>    MemoryRegion *address_space_filter;<br>    QTAILQ_ENTRY(MemoryListener) link;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="全局变量-memory-listeners"><a href="#全局变量-memory-listeners" class="headerlink" title="全局变量 memory_listeners"></a>全局变量 memory_listeners</h4><p>所有的 <code>MemoryListener</code> 都会挂在全局变量<code>memory_listeners</code>链表上，在<code>memory.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">QTAILQ_HEAD</span><span class="hljs-params">(, MemoryListener)</span> memory_listeners</span><br><span class="hljs-function">    </span>= QTAILQ_HEAD_INITIALIZER(memory_listeners);<br></code></pre></td></tr></table></figure>

<p>在<code>memory.c</code>中枚举了<code>ListenerDirection</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ListenerDirection</span> &#123;</span> Forward, Reverse &#125;;<br></code></pre></td></tr></table></figure>

<h3 id="重要数据结构总览"><a href="#重要数据结构总览" class="headerlink" title="重要数据结构总览"></a>重要数据结构总览</h3><table>
<thead>
<tr>
<th align="center">结构体名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AddressSpace</td>
<td align="left">VM 能看到的一段地址空间，偏向 Host 侧【注意指的是偏向】</td>
</tr>
<tr>
<td align="center">MemoryRegion</td>
<td align="left">地址空间中一段逻辑层面的内存区域，偏向 Guest 侧</td>
</tr>
<tr>
<td align="center">RAMBlock</td>
<td align="left">记录实际分配的内存地址信息，存储了 GPA-&gt;HVA 的映射关系</td>
</tr>
<tr>
<td align="center">FlatView</td>
<td align="left">MemoryRegion 对应的平面展开视图，包含一个 FlatRange 类型的 ranges 数组</td>
</tr>
<tr>
<td align="center">FlatRange</td>
<td align="left">对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中</td>
</tr>
<tr>
<td align="center">MemoryRegionSection</td>
<td align="left">表示 MemoryRegion 中的片段</td>
</tr>
<tr>
<td align="center">MemoryListener</td>
<td align="left">回调函数集合</td>
</tr>
<tr>
<td align="center">KVMSlot</td>
<td align="left">KVM 中内存管理的基本单位，表示一个内存插槽</td>
</tr>
<tr>
<td align="center">kvm_userspace_memory_region</td>
<td align="left">调用 ioctl(KVM_SET_USER_MEMORY_REGION) 时需要向 KVM 传递的参数</td>
</tr>
</tbody></table>
<h2 id="具体实现机制"><a href="#具体实现机制" class="headerlink" title="具体实现机制"></a>具体实现机制</h2><p>QEMU 的内存申请流程大致可分为三个部分：回调函数的注册、AddressSpace 的初始化、实际内存的分配。下面将根据在 vl.c 的 main() 函数中的调用顺序分别介绍。</p>
<h3 id="回调函数的注册"><a href="#回调函数的注册" class="headerlink" title="回调函数的注册"></a>回调函数的注册</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125133808.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">configure_accelerator</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       └─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">()</span>                                     <span class="hljs-comment">// 初始化 KVM</span></span><br><span class="hljs-function">            ├─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_ioctl</span><span class="hljs-params">(KVM_CREATE_VM)</span>                  <span class="hljs-comment">// 创建 VM</span></span><br><span class="hljs-function">            ├─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_arch_init</span><span class="hljs-params">()</span>                           <span class="hljs-comment">// 针对不同的架构进行初始化</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">()</span>               <span class="hljs-comment">// 注册 kvm_memory_listener</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">()</span> <span class="hljs-comment">// 调用 region_add 回调</span></span><br><span class="hljs-function">                      └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span>        <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">                           └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">                                └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                     └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br></code></pre></td></tr></table></figure>

<p>进入<code>configure_accelerator()</code>后，<code>QEMU</code>会先调用<code>configure_accelerator()</code>设置 <code>KVM</code> 的加速支持，之后进入<code>kvm_init()</code>。该函数主要完成对 KVM 的初始化，包括一些常规检查如 <code>CPU</code> 个数、<code>KVM</code> 版本等，之后通过<code>kvm_ioctl(KVM_CREATE_VM)</code>与内核交互，创建 <code>KVM</code> 虚拟机。在<code>kvm_init()</code>的最后，会调用<code>memory_listener_register()</code>注册<code>kvm_memory_listener</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">(MachineState *ms)</span></span><br><span class="hljs-function"></span>&#123;<br>    MachineClass *mc = MACHINE_GET_CLASS(ms);<br>    <span class="hljs-comment">// 打开/dev/kvm</span><br>    s-&gt;fd = qemu_open_old(<span class="hljs-string">&quot;/dev/kvm&quot;</span>, O_RDWR);<br>    <span class="hljs-comment">// 创建 VM</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        ret = kvm_ioctl(s, KVM_CREATE_VM, type);<br>    &#125; <span class="hljs-keyword">while</span> (ret == -EINTR);<br><span class="hljs-comment">/* ... */</span><br>    ret = kvm_arch_init(s); <span class="hljs-comment">// 针对不同的架构进行初始化</span><br><br>    <span class="hljs-comment">// 对于以下 AddressSpace，设置其对应的 listener</span><br>    kvm_memory_listener_register(s, &amp;s-&gt;memory_listener,<br>                                 &amp;address_space_memory, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;kvm-memory&quot;</span>);<br>    memory_listener_register(&amp;kvm_coalesced_pio_listener,<br>                             &amp;address_space_io);<br><span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">(MemoryListener *listener, AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryListener *other = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* Only one of them can be defined for a listener */</span><br>    assert(!(listener-&gt;log_sync &amp;&amp; listener-&gt;log_sync_global));<br><br>    listener-&gt;address_space = as;<br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;memory_listeners)<br>        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;memory_listeners)-&gt;priority) &#123;<br>        QTAILQ_INSERT_TAIL(&amp;memory_listeners, listener, link);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        QTAILQ_FOREACH(other, &amp;memory_listeners, link) &#123;<br>            <span class="hljs-keyword">if</span> (listener-&gt;priority &lt; other-&gt;priority) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        QTAILQ_INSERT_BEFORE(other, listener, link);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;as-&gt;listeners)<br>        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;as-&gt;listeners)-&gt;priority) &#123;<br>        QTAILQ_INSERT_TAIL(&amp;as-&gt;listeners, listener, link_as);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        QTAILQ_FOREACH(other, &amp;as-&gt;listeners, link_as) &#123;<br>            <span class="hljs-keyword">if</span> (listener-&gt;priority &lt; other-&gt;priority) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        QTAILQ_INSERT_BEFORE(other, listener, link_as);<br>    &#125;<br><br>    listener_add_address_space(listener, as);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后的<code>listener_add_address_space()</code>主要是将 listener 注册到其对应的 <code>AddressSpace</code> 上，并根据 <code>AddressSpace</code> 对应的 <code>FlatRange</code> 数组，生成 <code>MemoryRegionSection</code>【<code>MemoryRegionSection</code>就像是为<code>FlatRange</code>数组设置的一种中介表示，便于传入<code>KVM</code>，因为传入<code>KVM</code>应该是对平坦内存的一种表示】，并注册到 <code>KVM</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">(MemoryListener *listener,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    FlatView *view;<br>    FlatRange *fr;<br><br>    <span class="hljs-keyword">if</span> (listener-&gt;begin) &#123;<br>        listener-&gt;begin(listener);<br>    &#125;<br>    <span class="hljs-comment">/* 开启内存脏页记录 */</span><br>    <span class="hljs-keyword">if</span> (global_dirty_tracking) &#123;<br>        <span class="hljs-keyword">if</span> (listener-&gt;log_global_start) &#123;<br>            listener-&gt;log_global_start(listener);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 遍历 AddressSpace 对应的 FlatRange 数组，并将其转换成 MemoryRegionSection */</span><br>    view = address_space_get_flatview(as);<br>    FOR_EACH_FLAT_RANGE(fr, view) &#123;<br>        MemoryRegionSection section = section_from_flat_range(fr, view);<br>        <span class="hljs-comment">/* 将 section 所代表的内存区域注册到 KVM 中 */</span><br>        <span class="hljs-keyword">if</span> (listener-&gt;region_add) &#123;<br>            listener-&gt;region_add(listener, &amp;section);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fr-&gt;dirty_log_mask &amp;&amp; listener-&gt;log_start) &#123;<br>            listener-&gt;log_start(listener, &amp;section, <span class="hljs-number">0</span>, fr-&gt;dirty_log_mask);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (listener-&gt;commit) &#123;<br>        listener-&gt;commit(listener);<br>    &#125;<br>    flatview_unref(view);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于此时 <code>AddressSapce</code> 尚未初始化，所以此处的循环为空，仅是在全局注册了<code>kvm_memory_listener</code>。最后调用了<code>kvm_memory_listener-&gt;region_add()</code>，对应的实现是<code>kvm_region_add()</code>，该函数最终会通过<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>，将 <code>QEMU</code> 侧申请的内存信息传入 <code>KVM</code> 进行注册，这里的流程会在下一部分进行分析。</p>
<h3 id="AddressSpace-的初始化"><a href="#AddressSpace-的初始化" class="headerlink" title="AddressSpace 的初始化"></a>AddressSpace 的初始化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125154841.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">void</span> <span class="hljs-title">cpu_exec_init_all</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       ├─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_map_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 初始化 system_memory/io 这两个全局 MemoryRegion</span></span><br><span class="hljs-function">       |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">set_system_memory_map</span><span class="hljs-params">()</span> <span class="hljs-comment">// address_space_memory-&gt;root = system_memory</span></span><br><span class="hljs-function">       |    |    └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_update_topology</span><span class="hljs-params">()</span>        <span class="hljs-comment">// 为 MemoryRegion 生成 FlatView</span></span><br><span class="hljs-function">       |    |         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">()</span>   <span class="hljs-comment">// as-&gt;current_map = new_view</span></span><br><span class="hljs-function">       |    |              └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    |                   └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span>        <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">       |    |                        └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">       |    |                             └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    |                                  └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br><span class="hljs-function">       |    |</span><br><span class="hljs-function">       |    └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">()</span> <span class="hljs-comment">// 注册对应的 MemoryListener</span></span><br><span class="hljs-function">       |         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |</span><br><span class="hljs-function">       └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io_mem_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_io</span><span class="hljs-params">()</span> <span class="hljs-comment">// ram/rom/unassigned/notdirty/subpage-ram/watch</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>第一部分在全局注册了<code>kvm_memory_listener</code>，但由于<code>AddressSpace</code> 尚未初始化，实际上并未向 <code>KVM</code> 中注册任何实际的内存信息。<code>QEMU</code> 在<code>main()</code>函数中会继续调用<code>cpu_exec_init_all()</code>对<code>AddressSpace</code>进行初始化，该函数实际上是对两个 <code>init</code> 函数的封装调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cpu_exec_init_all</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    qemu_mutex_init(&amp;ram_list.mutex);<br>    <span class="hljs-comment">/* The data structures we set up here depend on knowing the page size,</span><br><span class="hljs-comment">     * so no more changes can be made after this point.</span><br><span class="hljs-comment">     * In an ideal world, nothing we did before we had finished the</span><br><span class="hljs-comment">     * machine setup would care about the target page size, and we could</span><br><span class="hljs-comment">     * do this much later, rather than requiring board models to state</span><br><span class="hljs-comment">     * up front what their requirements are.</span><br><span class="hljs-comment">     */</span><br>    finalize_target_page_bits();<br>    io_mem_init();      <span class="hljs-comment">// 初始化六个I/O MemoryRegion</span><br>    memory_map_init(); <span class="hljs-comment">// 初始化两个全局 AddressSpace，以及对应的 MemoryRegion、FlatView</span><br>    qemu_mutex_init(&amp;map_client_list_lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先来看<code>memory_map_init()</code>，主要用来初始化两个全局的系统地址空间<code>system_memory</code>、<code>system_io</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_map_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    system_memory = g_malloc(<span class="hljs-keyword">sizeof</span>(*system_memory));<br>    <span class="hljs-comment">// 1. 初始化 system_memory</span><br>    memory_region_init(system_memory, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;system&quot;</span>, UINT64_MAX);<br>    <span class="hljs-comment">// 2. 设置 address_space_memory 关联 system_memory</span><br>    <span class="hljs-comment">// 这两个都是全局变量，也就是把内存地址空间和 IO 地址空间于对应的 MemoryRegion 联系起来 </span><br>    <span class="hljs-comment">//及其对应的 FlatView</span><br>    address_space_init(&amp;address_space_memory, system_memory, <span class="hljs-string">&quot;memory&quot;</span>);<br><br>    system_io = g_malloc(<span class="hljs-keyword">sizeof</span>(*system_io));<br>    <span class="hljs-comment">// 1. 初始化 system_io  </span><br>    memory_region_init_io(system_io, <span class="hljs-literal">NULL</span>, &amp;unassigned_io_ops, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;io&quot;</span>,<br>                          <span class="hljs-number">65536</span>);<br>    <span class="hljs-comment">// 2. 设置 address_space_io 关联 system_io </span><br>    <span class="hljs-comment">// 及其对应的 FlatView</span><br>    address_space_init(&amp;address_space_io, system_io, <span class="hljs-string">&quot;I/O&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里比较重要的是<code>address_space_init()</code>，先设置 <code>AddressSpace</code> 对应的 <code>MemoryRegion</code>，之后根据<code>system_memory</code>更新<code>address_space_memory</code>对应的 <code>FlatView</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">address_space_init</span><span class="hljs-params">(AddressSpace *as, MemoryRegion *root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_ref(root);<br>    <span class="hljs-comment">// 将 address_space_memory 的 root 域指向 system_memory</span><br>    as-&gt;root = root;        <br>    as-&gt;current_map = <span class="hljs-literal">NULL</span>;<br>    as-&gt;ioeventfd_nb = <span class="hljs-number">0</span>;<br>    as-&gt;ioeventfds = <span class="hljs-literal">NULL</span>;<br>    QTAILQ_INIT(&amp;as-&gt;listeners);<br>    QTAILQ_INSERT_TAIL(&amp;address_spaces, as, address_spaces_link);<br>    as-&gt;name = g_strdup(name ? name : <span class="hljs-string">&quot;anonymous&quot;</span>);<br>    <span class="hljs-comment">// 根据 system_memory 更新 address_space_memory 对应的 FlatView</span><br>    address_space_update_topology(as);  <br>    address_space_update_ioeventfds(as);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>address_space_update_topology()</code>会继续调用<code>generate_memory_topology()</code>生成 <code>AddressSpace</code> 对应的 <code>FlatView</code>视图：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">(AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);<br><br>    flatviews_init();<br>    <span class="hljs-keyword">if</span> (!g_hash_table_lookup(flat_views, physmr)) &#123;<br>        generate_memory_topology(physmr);<br>    &#125;<br>    address_space_set_flatview(as);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>address_space_update_topology()</code>会先调用<code>generate_memory_topology()</code>生成<code>system_memory</code>更新后的视图<code>new_view</code>，再将<code>address_space_memory</code>的<code>current_map</code>指向这个<code>new_view</code>，最后销毁<code>old_view</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_set_flatview</span><span class="hljs-params">(AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    FlatView *old_view = address_space_to_flatview(as);<br>    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);<br>    FlatView *new_view = g_hash_table_lookup(flat_views, physmr);<br><br>    assert(new_view);<br><br>    <span class="hljs-keyword">if</span> (old_view == new_view) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_ref(old_view);<br>    &#125;<br><br>    flatview_ref(new_view);<br><br>    <span class="hljs-keyword">if</span> (!QTAILQ_EMPTY(&amp;as-&gt;listeners)) &#123;<br>        FlatView tmpview = &#123; .nr = <span class="hljs-number">0</span> &#125;, *old_view2 = old_view;<br><br>        <span class="hljs-keyword">if</span> (!old_view2) &#123;<br>            old_view2 = &amp;tmpview;<br>        &#125;<br>        address_space_update_topology_pass(as, old_view2, new_view, <span class="hljs-literal">false</span>);<br>        address_space_update_topology_pass(as, old_view2, new_view, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Writes are protected by the BQL.  */</span><br>    qatomic_rcu_set(&amp;as-&gt;current_map, new_view);<br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_unref(old_view);<br>    &#125;<br><br>    <span class="hljs-comment">/* Note that all the old MemoryRegions are still alive up to this</span><br><span class="hljs-comment">     * point.  This relieves most MemoryListeners from the need to</span><br><span class="hljs-comment">     * ref/unref the MemoryRegions they get---unless they use them</span><br><span class="hljs-comment">     * outside the iothread mutex, in which case precise reference</span><br><span class="hljs-comment">     * counting is necessary.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_unref(old_view);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>address_space_update_topology_pass()</code>的最后，会调用<code>MEMORY_LISTENER_UPDATE_REGION</code>这个宏，触发<code>region_add</code>对应的回调函数<code>kvm_region_add()</code>。</p>
<p>这个宏在<code>memory.c</code>中定义，会将 <code>FlatView</code> 中的 <code>FlatRange</code> 转换为 <code>MemoryRegionSection</code>，作为入参传递给<code>kvm_region_add()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* No need to ref/unref .mr, the FlatRange keeps it alive.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...)  \</span><br><span class="hljs-meta">    do &#123;                                                                \</span><br><span class="hljs-meta">        MemoryRegionSection mrs = section_from_flat_range(fr,           \</span><br><span class="hljs-meta">                address_space_to_flatview(as));                         \</span><br><span class="hljs-meta">        MEMORY_LISTENER_CALL(as, callback, dir, &amp;mrs, ##_args);         \</span><br><span class="hljs-meta">    &#125; while(0)</span><br></code></pre></td></tr></table></figure>

<p>而<code>kvm_region_add()</code>实际上是对<code>kvm_set_phys_mem()</code>的封装调用。该函数比较复杂，会根据传入的<code>section</code>填充 KVMSlot，再传递给<code>kvm_set_user_memory_region()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">(KVMMemoryListener *kml, KVMSlot *slot, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">new</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    KVMState *s = kvm_state;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">mem</span>;</span><br>    <span class="hljs-keyword">int</span> ret;<br><br>    <span class="hljs-comment">// 根据 KVMSlot 填充 kvm_userspace_memory_region</span><br>    mem.slot = slot-&gt;slot | (kml-&gt;as_id &lt;&lt; <span class="hljs-number">16</span>);<br>    mem.guest_phys_addr = slot-&gt;start_addr;<br>    mem.userspace_addr = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)slot-&gt;ram;<br>    mem.flags = slot-&gt;flags;<br><br>    <span class="hljs-keyword">if</span> (slot-&gt;memory_size &amp;&amp; !<span class="hljs-keyword">new</span> &amp;&amp; (mem.flags ^ slot-&gt;old_flags) &amp; KVM_MEM_READONLY) &#123;<br>        <span class="hljs-comment">/* Set the slot size to 0 before setting the slot to the desired</span><br><span class="hljs-comment">         * value. This is needed based on KVM commit 75d61fbc. */</span><br>        mem.memory_size = <span class="hljs-number">0</span>;<br>        ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> err;<br>        &#125;<br>    &#125;<br>    mem.memory_size = slot-&gt;memory_size;<br>    ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>    slot-&gt;old_flags = mem.flags;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里又将 <code>KVMSlot</code> 转换为 <code>kvm_userspace_memory_region</code>，作为<code>ioctl()</code>的参数，交给内核中的 <code>KVM</code> 进行内存的注册【设置<code>GPA-&gt;HVA</code>的映射关系，在内核空间维护并管理 Guest 的内存】。</p>
<p>至此 QEMU 侧负责管理内存的数据结构均已完成初始化，<strong>可以参考下面的图片了解各数据结构之间的对应关系</strong></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127155506.png"></p>
<h3 id="实际内存的分配"><a href="#实际内存的分配" class="headerlink" title="实际内存的分配"></a>实际内存的分配</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127160121.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">void</span> machine-&gt;<span class="hljs-title">init</span><span class="hljs-params">(ram_size, ...)</span></span><br><span class="hljs-function">       └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc_init_pci</span><span class="hljs-params">(ram_size, ...)</span> <span class="hljs-comment">// 初始化虚拟机</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc_init1</span><span class="hljs-params">(system_memory, system_io, ram_size, ...)</span></span><br><span class="hljs-function">                 ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">(pci_memory, <span class="hljs-string">&quot;pci&quot;</span>, ...)</span> <span class="hljs-comment">// pci_memory, rom_memory</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">void</span> <span class="hljs-title">pc_memory_init</span><span class="hljs-params">()</span> <span class="hljs-comment">// 初始化内存，分配实际的物理内存地址</span></span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">()</span> <span class="hljs-comment">// 创建 pc.ram, pc.rom 并分配内存</span></span><br><span class="hljs-function">                      |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |    └─ <span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |         └─ <span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc_from_ptr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |</span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">vmstate_register_ram_global</span><span class="hljs-params">()</span> <span class="hljs-comment">// 将 MR 的 name 写入 RAMBlock 的 idstr</span></span><br><span class="hljs-function">                      |    └─ <span class="hljs-keyword">void</span> <span class="hljs-title">vmstate_register_ram</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |         └─ <span class="hljs-keyword">void</span> <span class="hljs-title">qemu_ram_set_idstr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |</span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_alias</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 初始化 ram_below_4g, ram_above_4g</span></span><br><span class="hljs-function">                      └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_add_subregion</span><span class="hljs-params">()</span> <span class="hljs-comment">// 在 system_memory 中添加 subregions</span></span><br><span class="hljs-function">                           └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_add_subregion_common</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_update_topology</span><span class="hljs-params">()</span> <span class="hljs-comment">// 为 MemoryRegion 生成 FlatView</span></span><br><span class="hljs-function">                                     └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">()</span> <span class="hljs-comment">// as-&gt;current_map = new_view</span></span><br><span class="hljs-function">                                          └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                               └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span> <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">                                                    └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">                                                         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                                              └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br></code></pre></td></tr></table></figure>

<p>之前的回调函数注册、AddressSpace 的初始化，实际上均没有对应的物理内存。【实际的内存是在 RAMBlock 中】</p>
<p>我们再回到 <code>qemu</code> 启动的 <code>main</code> 函数中。接下来的初始化过程会调用 <code>pc_init1</code>。在这里面，对于 <code>CPU</code> 虚拟化，我们会调用 <code>pc_cpus_init</code>。另外，<code>pc_init1</code> 还会调用<code>pc_memory_init</code>，进行内存的虚拟化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram, *option_rom_mr;         <span class="hljs-comment">// 两个实体 MR: pc.ram, pc.rom</span><br>    MemoryRegion *ram_below_4g, *ram_above_4g; <span class="hljs-comment">// 两个别名 MR: ram_below_4g, ram_above_4g</span><br><br>    <span class="hljs-comment">/* Allocate RAM.  We allocate it as a single memory region and use</span><br><span class="hljs-comment">     * aliases to address portions of it, mostly for backwards compatibility</span><br><span class="hljs-comment">     * with older qemus that used qemu_ram_alloc().</span><br><span class="hljs-comment">     */</span><br>    ram = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram)); <span class="hljs-comment">// 创建 ram</span><br>    <span class="hljs-comment">// 分配具体的内存（实际上会创建一个 RAMBlock 并将其 offset 值写入 ram.ram_addr，对应 GPA）</span><br>    memory_region_init_ram(ram, <span class="hljs-string">&quot;pc.ram&quot;</span>, below_4g_mem_size + above_4g_mem_size);<br>    <span class="hljs-comment">// 将 MR 的 name 写入 RAMBlock 的 idstr</span><br>    vmstate_register_ram_global(ram);<br>    *ram_memory = ram;<br><br>    <span class="hljs-comment">// 创建 ram_below_4g 表示 4G 以下的内存</span><br>    ram_below_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_below_4g));<br>    memory_region_init_alias(ram_below_4g, <span class="hljs-string">&quot;ram-below-4g&quot;</span>, ram, <span class="hljs-number">0</span>, below_4g_mem_size);<br>    <span class="hljs-comment">// 将 ram_below_4g 挂在 system_memory 下</span><br>    memory_region_add_subregion(system_memory, <span class="hljs-number">0</span>, ram_below_4g);<br><br>    <span class="hljs-keyword">if</span> (above_4g_mem_size &gt; <span class="hljs-number">0</span>) &#123;<br>        ram_above_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_above_4g));<br>        memory_region_init_alias(ram_above_4g, <span class="hljs-string">&quot;ram-above-4g&quot;</span>, ram, below_4g_mem_size, above_4g_mem_size);<br>        memory_region_add_subregion(system_memory, <span class="hljs-number">0x100000000</span>ULL, ram_above_4g);<br>    &#125;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的重点在于<code>memory_region_init_ram()</code>，它通过<code>qemu_ram_alloc()</code>获取 ram 这个 <code>MemoryRegion</code> 对应的 <code>RAMBlock</code> 的<code>offset</code>，并存入<code>ram.ram_addr</code>，这样就可以在<code>ram_list</code>中根据该字段查找 <code>MR</code> 对应的 <code>RAMBlock</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">(MemoryRegion *mr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size); <span class="hljs-comment">// 填充字段，初始化默认值</span><br>    mr-&gt;ram = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示为 RAM</span><br>    mr-&gt;terminates = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示为实体 MemoryRegion</span><br>    mr-&gt;destructor = memory_region_destructor_ram;<br>    mr-&gt;ram_addr = qemu_ram_alloc(size, mr); <span class="hljs-comment">// 这里保存 RAMBlock 的 offset，即 GPA</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>而 qemu_ram_alloc() 最终会调用 qemu_ram_alloc_from_ptr()，创建一个对应大小 RAMBlock 并分配内存，返回对应的 GPA 地址存入 mr-&gt;ram_addr 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc_from_ptr</span><span class="hljs-params">(<span class="hljs-keyword">ram_addr_t</span> size, <span class="hljs-keyword">void</span> *host,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   MemoryRegion *mr)</span></span><br><span class="hljs-function"></span>&#123;<br>    RAMBlock *new_block; <span class="hljs-comment">// 创建一个 RAMBlock</span><br><br>    size = TARGET_PAGE_ALIGN(size); <span class="hljs-comment">// 页对齐</span><br>    new_block = g_malloc0(<span class="hljs-keyword">sizeof</span>(*new_block)); <span class="hljs-comment">// 初始化 new_block</span><br><br>    new_block-&gt;mr = mr; <span class="hljs-comment">// 将 new_block-&gt; 指向入参的 MemoryRegion</span><br>    new_block-&gt;offset = find_ram_offset(size); <span class="hljs-comment">// 从 ram_list 中的 RAMBlock 之间找到一段可以满足 size 需求的 gap，并返回起始地址的 offset，对应 GPA</span><br>    <span class="hljs-keyword">if</span> (host) &#123; <span class="hljs-comment">// 新建的 RAMBlock host 字段为空，跳过</span><br>        new_block-&gt;host = host;<br>        new_block-&gt;flags |= RAM_PREALLOC_MASK;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mem_path) &#123; <span class="hljs-comment">// 未指定 mem_path</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (__linux__) &amp;&amp; !defined(TARGET_S390X)</span><br>            new_block-&gt;host = file_ram_alloc(new_block, size, mem_path);<br>            <span class="hljs-keyword">if</span> (!new_block-&gt;host) &#123;<br>                new_block-&gt;host = qemu_vmalloc(size);<br>                qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;-mem-path option unsupported\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (xen_enabled()) &#123;<br>                xen_ram_alloc(new_block-&gt;offset, size, mr);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kvm_enabled()) &#123; <span class="hljs-comment">// 从这里继续</span><br>                <span class="hljs-comment">/* some s390/kvm configurations have special constraints */</span><br>                new_block-&gt;host = kvm_vmalloc(size); <span class="hljs-comment">// 实际上还是调用 qemu_vmalloc(size)</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                new_block-&gt;host = qemu_vmalloc(size); <span class="hljs-comment">// 从 QEMU 的线性空间中分配 size 大小的内存，返回 HVA</span><br>            &#125;<br>            qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);<br>        &#125;<br>    &#125;<br>    new_block-&gt;length = size; <span class="hljs-comment">// 将 length 设置为 size</span><br><br>    QLIST_INSERT_HEAD(&amp;ram_list.blocks, new_block, next); <span class="hljs-comment">// 将该 RAMBlock 插入 ram_list 头部</span><br><br>    ram_list.phys_dirty = g_realloc(ram_list.phys_dirty, <span class="hljs-comment">// 重新分配 ram_list.phys_dirty 的内存空间</span><br>                                       last_ram_offset() &gt;&gt; TARGET_PAGE_BITS);<br>    <span class="hljs-built_in">memset</span>(ram_list.phys_dirty + (new_block-&gt;offset &gt;&gt; TARGET_PAGE_BITS),<br>           <span class="hljs-number">0</span>, size &gt;&gt; TARGET_PAGE_BITS);<br>    cpu_physical_memory_set_dirty_range(new_block-&gt;offset, size, <span class="hljs-number">0xff</span>); <span class="hljs-comment">// 对该 RAMBlock 对应的内存标记为 dirty</span><br><br>    qemu_ram_setup_dump(new_block-&gt;host, size);<br><br>    <span class="hljs-keyword">if</span> (kvm_enabled())<br>        kvm_setup_guest_memory(new_block-&gt;host, size);<br><br>    <span class="hljs-keyword">return</span> new_block-&gt;offset;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样一来<code>ram</code>【其实就是<code>system memory</code>，整个<code>Guest</code>物理空间的大小】对应的 <code>RAMBlock</code> 中就分配好了 <code>GPA</code> 和 <code>HVA</code>，就可以<strong>将内存信息同步至 KVM 侧</strong>了。</p>
<p>最后回到<code>pc_memory_init()</code>中，在分配完实际内存后，会先调用<code>memory_region_init_alias()</code>初始化<code>ram_below_4g</code>、<code>ram_above_4g</code>这两个<code>alias</code>，之后调用<code>memory_region_add_subregion()</code>将这两个 <code>alias</code> 指向<code>ram</code>这个实体 <code>MemoryRegion</code>。如下图，该函数最终会触发<code>kvm_region_add()</code>回调，将实际的内存信息传入 <code>KVM</code> 注册。该过程如下图所示，与之前分析的流程相同，此处不再赘述。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163205.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟机的内存管理也是需要用户态的 <code>qemu</code> 和内核态的 <code>KVM</code> 共同完成。为了加速内存映射，需要借助硬件的 <code>EPT</code> 技术。</p>
<h3 id="QEMU-侧"><a href="#QEMU-侧" class="headerlink" title="QEMU 侧"></a>QEMU 侧</h3><ul>
<li><p>创建一系列 <code>MemoryRegion</code>，分别表示 <code>Guest</code> 中的 <code>RAM</code>、<code>ROM</code> 等区域。<code>MemoryRegion</code>之间通过 <code>alias</code> 或 <code>subregions</code> 的方式维护相互之间的关系，从而进一步细化区域的定义</p>
</li>
<li><p>对于一个实体 <code>MemoryRegion</code>（非 <code>alias</code>），在初始化内存的过程中 <code>QEMU</code> 会创建它所对应的 <code>RAMBlock</code>。该 <code>RAMBlock</code> 通过调用<code>qemu_ram_alloc_from_ptr()</code>从 <code>QEMU</code> 的进程地址空间中<strong>以 mmap 的方式分配内存</strong>，并负责<strong>维护该 MemoryRegion 对应内存的起始 GPA/HVA/size 等相关信息</strong>【在<code>qemu_ram_alloc_from_ptr</code>中创建的新<code>RAMBlock</code>有<code>offset</code>、<code>host</code>的赋值，即<code>GPA-&gt;HVA</code>的对应关系】</p>
</li>
<li><p><code>AddressSpace</code> 表示 <code>Guest</code> 的物理地址空间。如果 <code>AddressSpace</code> 中的 <code>MemoryRegion</code> 发生变化，则注册的 <code>listener</code> 会被触发，将所属的 <code>MemoryRegion</code> 树展开生成一维的 <code>FlatView</code>，比较 FlatRange 是否发生了变化。如果是，则调用相应的方法对 <code>MemoryRegionSection</code> 进行检查，更新 <code>QEMU</code> 中的 <code>KVMSlot</code>，同时填充<code>kvm_userspace_memory_region</code>结构体，作为<code>ioctl()</code>的参数更新 <code>KVM</code> 中的<code>kvm_memory_slot</code></p>
</li>
</ul>
<h3 id="KVM-侧"><a href="#KVM-侧" class="headerlink" title="KVM 侧"></a>KVM 侧</h3><ul>
<li><p>当 <code>QEMU</code> 通过<code>ioctl()</code>创建 <code>vcpu</code> 时，调用<code>kvm_mmu_create()</code>初始化 <code>MMU</code> 相关信息。<br>当 <code>KVM</code> 要进入 <code>Guest</code> 前，<code>vcpu_enter_guest()=&gt;kvm_mmu_reload()</code>会将根级页表地址加载到 <code>VMCS</code>，让 <code>Guest</code> 使用该页表</p>
</li>
<li><p>当发生<code>EPT Violation</code> 时，<code>VM-EXIT</code>到 <code>KVM</code> 中。如果是缺页，则根据 <code>GPA</code> 算出 <code>gfn</code>，再根据 <code>gfn</code> 找到对应的 <code>KVMSlot</code>，从中得到对应的 <code>HVA</code>。然后根据 <code>HVA</code> 算出对应的 <code>pfn</code>，确保该 <code>Page</code> 位于内存中。填好缺失的页之后，需要更新 <code>EPT</code>，完善其中缺少的页表项，逐层补全页表</p>
</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163418.png"></p>
<blockquote>
<p>虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即 <code>mmap</code> 分配的虚拟内存空间被访问的时候，先查看 <code>EPT</code> 页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。<br>如果没有映射过，则虚拟机会通过<code>VM-Exit</code>指令回到宿主机模式，通过 <code>handle_ept_violation</code> 补充页表映射。先是通过 <code>handle_mm_fault</code>为虚拟机的物理内存空间分配真正的物理页面，然后通过 <code>__direct_map</code> 添加 <code>EPT</code> 页表映射。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127171031.jpg"></p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="http://xudaxian.fun/2020/09/03/QEMU%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">“QEMU 内存空间虚拟化及内存管理” - B10g | FΓom 许大仙</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LoyenWang/p/13943005.html">【原创】Linux 虚拟化 KVM-Qemu 分析（五）之内存虚拟化 - LoyenWang - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiongwenwu/article/details/58586013">KVM/Qemu 工作原理系列目录_xiongwenwu 的专栏-CSDN 博客_qemu 目录结构</a><br><a target="_blank" rel="noopener" href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/01/17/Linux%E5%B8%A7%E7%BC%93%E5%86%B2/" itemprop="url">Linux 帧缓冲</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-17T09:38:04.000Z" itemprop="datePublished">1月 17 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            26 分钟 lesen (Über 3950 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220118092227.png"></p>
<h2 id="帧缓冲主要结构"><a href="#帧缓冲主要结构" class="headerlink" title="帧缓冲主要结构"></a>帧缓冲主要结构</h2><ul>
<li><p>fb_info<br>  该结构体记录当前帧缓冲设备的状态信息，如果系统中有多个帧缓冲设备，就需要两个fb_info结构，这个结构只在内核中可以看到，对用户空间不可见。</p>
</li>
<li><p>fb_var_screeninfo<br>  该结构体记录指定的帧缓冲设备和显示模式中可以被修改的信息，其中包括显示器分辨率等信息。</p>
</li>
<li><p>fb_fix_screeninfo<br>  该结构体表示帧缓冲设备中一些不能修改的参数，包括特定的显示模式，屏幕缓冲区的物理地址，显示缓冲区的长度信息。</p>
</li>
<li><p>fb_ops<br>  LCD底层硬件操作接口集。比如<code>fb_open</code>、<code>fb_release</code>、<code>fb_read</code>、<code>fb_write</code>、<code>fb_ioctl</code>、<code>fb_mmap</code>等：</p>
</li>
<li><p>fb_cmap<br>  <code>fb_cmap</code>指定颜色映射，用于以内核可以理解的方式存储用户的颜色定义。</p>
</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220117192106.png"></p>
<h2 id="帧缓冲显示原理"><a href="#帧缓冲显示原理" class="headerlink" title="帧缓冲显示原理"></a>帧缓冲显示原理</h2><p>帧缓冲设备是一种显示抽象的设备，也可以被理解为它是一个内存区域，上面的应用程序可以直接对显示缓冲区进行读和写操作，就像访问文件的通用接口一样，用户可以认为帧缓冲是一块内存，能读取数据的内存块也可以向这个内存写入数据，因此显示器显示图形界面实际上根据根据的是指定的内存数据块内的数据。</p>
<p>帧缓冲的显示缓冲区位于 Linux 内核地址空间，应用程序不能直接访问内核地址空间，在 Linux 中，只有一个内存的内核地址空间映射到用户地址空间才可以由用户访问，内存的映射是通过<code>MMAP</code>函数实现的在 Linux 中。对于帧缓冲，虚拟地址是通过内存映射的方法将显示缓冲区内核地址映射到用户空间的，然后用户可以通过读和写这部分的虚拟地址来访问显示缓冲区，在屏幕上绘图。</p>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><p>使用帧缓冲之前应该首先确定 Linux 系统上已安装了帧缓冲驱动，可以在目录<code>/dev/</code>下查找<code>fb*</code>如，<code>/dev/fb0, /dev/fb1</code>等设备来确定是否安装。如果没有需要安装一个帧缓冲驱动的模块到内核，或者重新编译内核生成一个带帧缓冲模块的镜像。</p>
<p>使用帧缓冲需要进入控制台模式，即纯命令行的模式进行编程。一般可以通过快捷键<code>CTRL+ALT+F1</code>进入控制台模式，<code>CTRL+ALT+F7</code>切回图形窗口。如果控制台模式没有登录，可以<code>CTRL+ALT+F6</code>尝试登录。</p>
<p>因硬件显示设备的物理显示区是通过帧缓存区操作，而帧缓存区是处于内核空间，应用程序不能随意操作，此时可以通过系统调用<code>mmap</code>把帧缓存映射到用户空间，在用户空间中创建出帧缓存映射区（用户图像数据缓存区），以后只需把用户图像数据写入到帧缓存映射区就可在硬件设备上显示图像。</p>
<p>具体实现流程如下：</p>
<h3 id="打开帧缓冲设备-dev-f0"><a href="#打开帧缓冲设备-dev-f0" class="headerlink" title="打开帧缓冲设备/dev/f0"></a>打开帧缓冲设备<code>/dev/f0</code></h3><p>在Linux的/dev目录的寻找b*设备文件然后使用读写模式打开它，Linux 系统将使用通用的<code>open</code>系统调用来完成功能， <code>open</code>的功能原型如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflags)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>Path</code>是准备打开的文件或设备的路径参数；</li>
<li><code>oflags</code>指定打开文件时使用的参数；</li>
<li><code>flags</code>参数的指定，是通过组合文件访问模式和其他的可选模式一起的，可以支持多个模式或，参数必须是指定下列文件的访问模式。<ul>
<li>只读：O_RDONLLY</li>
<li>只写：O_WRONLY</li>
<li>读写：O_RDWR</li>
</ul>
</li>
</ul>
<p>简而言之， <code>open</code>函数建立设备文件的访问路径。如果操作成功，它返回一个文件描述符，只是一个文件描述符，它将不使用其他任何正在运行的进程共享。如果两个程序同时打开相同的文件，将得到两个不同的文件描述符。如果他们执行文件写入操作，他们将操作每个文件描述符，不会发生冲突，写完之后退出。他们的数据不会互相交织在一起的，但会互相的彼此覆盖 (后写完的内容覆盖前面写的内容)，两个程序来读取和写入的文件位置看似一样但是有各自不同拷贝所以不会发生交织。如果<code>open</code>调用未能返回<code>1</code>，则将全局变量<code>errno</code>设置为指示失败的原因。</p>
<h3 id="通过系统调用ioctl函数获得帧设备相关信息"><a href="#通过系统调用ioctl函数获得帧设备相关信息" class="headerlink" title="通过系统调用ioctl函数获得帧设备相关信息"></a>通过系统调用<code>ioctl</code>函数获得帧设备相关信息</h3><p>通过顿缓冲文件描述符，屏幕的分辨率、颜色深度等信息可以被获得，帧缓冲驱动中存放了这些对应的信息，必须使用 Linux 系统调用<code>ioctl</code>首先将帧缓冲的文件描述符和<code>fb_var_screeninfo</code> 结构体对应起来。</p>
<p>结构体<code>fb_var_screeninfo</code>包含以下三个重要数据结构：</p>
<ul>
<li>屏幕的 x 方向分辨率，像素作为单位。</li>
<li>屏幕的 Y 方向分辨率，像素作为单位。</li>
<li>屏幕的像素颜色深度，每个像素用多少比特数表示。</li>
</ul>
<p><code>ioctl</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> __request, ...)</span> __THROW</span>;<br></code></pre></td></tr></table></figure>

<p><code>ioctl</code>调用实现访问设备驱动各种各样的配置信息功能，它提供了一个控制设备的行为和配置底层服务接口的驱动函数，各种设备驱动程序，例如套接字和系统终端，还有磁带机都有<code>ioctl</code>命令可以支持。</p>
<ul>
<li><code>__fd</code>：<code>ioctl</code>命令中是该帧缓冲的文件描述符；</li>
<li><code>__request</code>：<code>ioctl</code>函数将要执行的命令，实现参数给定的对象描述符中指定的函数操作，各种设备支持的功能是有差异的<ul>
<li><code>FBIOGET_VSCREENINFO</code>命令字返回与Framebuffer有关的固定的信息；</li>
<li><code>FBIOGET_VSCREENINFO</code>命令字返回与 Framebuffer 有关的可变的信息；</li>
</ul>
</li>
<li>第三个参数是一个指针用来指向结构体<code>fb_var_screeninfo</code>。</li>
</ul>
<p>最后使用者可以通过结构体<code>fb_var_screeninfo</code>来获得屏幕的分辨率和颜色位深和其他重要的屏幕信息。根据这些信息可以计算屏幕缓冲区的大小：屏幕缓冲区大小 (以字节为单位) = 屏幕宽度x高度x屏幕颜色深度/8</p>
<h3 id="帧缓冲映射"><a href="#帧缓冲映射" class="headerlink" title="帧缓冲映射"></a>帧缓冲映射</h3><p>在进行帧缓冲的<code>MMAP</code>映射之前，要先得到帧缓冲文件描述符，才能像屏幕上面显示，必须首先将缓冲区的内核地址映射映射到用户地址空间。Linux 系统将使用<code>MMAP</code>系统调用完成功能，<code>MMAP</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">mmap</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *__addr, <span class="hljs-keyword">size_t</span> __len, <span class="hljs-keyword">int</span> __prot,</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-keyword">int</span> __flags, <span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">__off_t</span> __offset)</span> __THROW</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>__addr</code>：返回一个指向<code>mmap</code>函数的内存区域的指针，与内容相关的文件指针，通过指针可以访问帧缓冲区的内存区域。</p>
</li>
<li><p><code>__len</code>：可以请求使用特定内存地址，通过设置地址参数，如果值为<code>0</code>，将自动分配指针，这是推荐的做法，否则会降低程序的可移植性，因为不同的系统可用的地址范围是不一样的。</p>
</li>
<li><p><code>__prot</code>：设置内存访问的权限设定，通过端口相关的参数定义，位的定义值如下：</p>
<ul>
<li><code>PORT_EXEC</code>:允许内存段的执行。</li>
<li><code>PORT_NONE</code>:无法访问内存段。</li>
<li><code>PORT_READ</code>:允许读取内存段。</li>
<li><code>PORT_WRITE</code>:允许编写内存段。</li>
</ul>
</li>
<li><p><code>__flags</code>：改变控制参数标志，能够影响该内存段的作用域，如下所示：</p>
<ul>
<li><code>MAP_FIXED</code>:内存段必须位于addr中指定的地址。</li>
<li><code>MAP_SHARED</code>:内存的修改保存到一个文件中。</li>
<li><code>MAP_PRIVATE</code>:内存段是私人的，变化仅在本地范围内有效。</li>
</ul>
</li>
<li><p><code>__fd</code>：是通过一个<code>open</code>调用得到的访问文件的描述符。</p>
</li>
<li><p><code>offset</code>：用于指定访问数据的开始偏移量在内存段中，和访问普通文件使用方式是相同的，再指定文件描述符参数，以及访问的数据长度参数即可。</p>
</li>
</ul>
<h3 id="读写帧缓冲"><a href="#读写帧缓冲" class="headerlink" title="读写帧缓冲"></a>读写帧缓冲</h3><p><code>MMAP</code>返回的指针，可以访问到帧缓冲内存区，可以定位到屏幕缓冲区具体为每个显示像素的位置，通过读函数调用读取对应的位置数据在帧缓冲内存中，相反写操作对应于内存的写入数据可以显示内容写到屏幕上。</p>
<h3 id="解除帧缓冲映射"><a href="#解除帧缓冲映射" class="headerlink" title="解除帧缓冲映射"></a>解除帧缓冲映射</h3><p>在绘图完成后，帧缓冲文件描述符必须被释放之前，解除帧缓冲区的地址映射，使用 Linux 系统调用完成<code>mmap</code>函数的逆函数实现，即是<code>munmap</code>，函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *__addr, <span class="hljs-keyword">size_t</span> __len)</span> __THROW</span>;<br></code></pre></td></tr></table></figure>

<p><code>addr</code>参数应该与调用<code>MMAP</code>时指定的参数值一致， <code>len</code>参数也应该与之前调用<code>MMAP</code>时指定的<code>len</code>参数保持一致。</p>
<p><code>mmap</code>调用返回<code>0</code>成功，失败则返回<code>1</code>，同时将全局变量<code>erno</code>设置为指示失败的原因。</p>
<h3 id="调用close关闭设备"><a href="#调用close关闭设备" class="headerlink" title="调用close关闭设备"></a>调用<code>close</code>关闭设备</h3><p>使用帧缓冲设备后，应关闭相应的文件描述符，使用 Linux 系统标准的函数完成关闭功能，<code>close</code>函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">close</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> __fd)</span></span>;<br></code></pre></td></tr></table></figure>

<p><code>close</code>的参数和在开始调用<code>open</code>时指定的参数一致，文件描述符释放后可以重用，结束调用成功返回<code>0</code>，失败返回<code>1</code>。</p>
<h2 id="帧缓冲实例"><a href="#帧缓冲实例" class="headerlink" title="帧缓冲实例"></a>帧缓冲实例</h2><p>以下代码摘自<a target="_blank" rel="noopener" href="https://github.com/xianjimli/linux-framebuffer-tools">xianjimli/linux-framebuffer-tools: linux framebuffer tool</a>，演示了帧缓冲设备的使用流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">fb_info_t</span> *<span class="hljs-title">linux_fb_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint32_t</span>                 size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">fb_info_t</span>               *fb   = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_fix_screeninfo</span> <span class="hljs-title">fix</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_var_screeninfo</span> <span class="hljs-title">var</span>;</span><br>    return_value_if_fail(filename != <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    fb = (<span class="hljs-keyword">fb_info_t</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">fb_info_t</span>));<br>    return_value_if_fail(fb != <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 打开帧缓冲设备，O_RDWR 读写模式</span><br>    fb-&gt;fd = open(filename, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fb-&gt;fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        log_debug(<span class="hljs-string">&quot;open %s failed(%d)\n&quot;</span>, filename, errno);<br>        <span class="hljs-built_in">free</span>(fb);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">// 通过系统调用 ioctl 函数获得帧设备相关信息</span><br>    <span class="hljs-comment">// FBIOGET_FSCREENINFO 命令字返回与 Framebuffer 有关的固定的信息</span><br>    <span class="hljs-keyword">if</span> (ioctl(fb-&gt;fd, FBIOGET_FSCREENINFO, &amp;fix) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> fail;<br>    <span class="hljs-comment">//命令字返回与 Framebuffer 有关的可变的信息</span><br>    <span class="hljs-keyword">if</span> (ioctl(fb-&gt;fd, FBIOGET_VSCREENINFO, &amp;var) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> fail;<br><br>    var.xoffset = <span class="hljs-number">0</span>;<br>    var.yoffset = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 显示</span><br>    ioctl(fb-&gt;fd, FBIOPAN_DISPLAY, &amp;(var));<br><br>    log_debug(<span class="hljs-string">&quot;fb_info_t: %s\n&quot;</span>, filename);<br>    log_debug(<span class="hljs-string">&quot;fb_info_t: xres=%d yres=%d bits_per_pixel=%d mem_size=%d\n&quot;</span>, var.xres, var.yres,<br>              var.bits_per_pixel, fb_size(fb));<br>    log_debug(<span class="hljs-string">&quot;fb_info_t: red(%d %d) green(%d %d) blue(%d %d)\n&quot;</span>, var.red.offset, var.red.length,<br>              var.green.offset, var.green.length, var.blue.offset, var.blue.length);<br><br>    fb-&gt;w           = var.xres;<br>    fb-&gt;h           = var.yres;<br>    fb-&gt;bpp         = var.bits_per_pixel / <span class="hljs-number">8</span>;<br>    fb-&gt;line_length = fix.line_length;<br><br>    size = fb_size(fb);<br>    <span class="hljs-comment">// 帧缓冲映射</span><br>    <span class="hljs-comment">// PROT_READ | PROT_WRITE:可读写</span><br>    <span class="hljs-comment">// MAP_SHARED：内存的修改保存到一个文件</span><br>    fb-&gt;data = (<span class="hljs-keyword">uint8_t</span> *)mmap(<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fb-&gt;fd, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (fb-&gt;data == MAP_FAILED)<br>    &#123;<br>        log_debug(<span class="hljs-string">&quot;map framebuffer failed.\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br><br>    log_debug(<span class="hljs-string">&quot;line_length=%d mem_size=%d\n&quot;</span>, fix.line_length, fb_size(fb));<br>    log_debug(<span class="hljs-string">&quot;xres_virtual =%d yres_virtual=%d xpanstep=%d ywrapstep=%d\n&quot;</span>, var.xres_virtual,<br>              var.yres_virtual, fix.xpanstep, fix.ywrapstep);<br><br>    <span class="hljs-keyword">return</span> fb;<br>fail:<br>    log_debug(<span class="hljs-string">&quot;%s is not a framebuffer.\n&quot;</span>, filename);<br>    close(fb-&gt;fd);<br>    <span class="hljs-built_in">free</span>(fb);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>感兴趣可以下载源码编译运行，其中<code>/bin/fbshow</code>可以使用帧缓冲设备显示图片。图形界面下直接运行可能提示无法运行，需要<code>Chrtl+Alt+F1</code>切换到控制台模式。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220120202118.png"></p>
<h2 id="LCD-与-Framebuffer-的关系"><a href="#LCD-与-Framebuffer-的关系" class="headerlink" title="LCD 与 Framebuffer 的关系"></a>LCD 与 Framebuffer 的关系</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225141549.jpg"></p>
<p>LCD 控制器首先通过 VDEN 信号，使能。接下来根据 VCLK 时钟信号，在像素点上“喷涂”不同的颜色（打个比方），控制器有 VD（video data）信号，传送不同颜色信息。每来一个时钟信号，就向右移动一个像素，根据行同步信号 HSYNC，就从最右边移动到最左边。当移动到右下角时根据垂直同步信号 VSYNC。</p>
<p>那么问题来了，不同颜色的信息从哪里来？就是从上文介绍的 Framebuffer 中来的。</p>
<p>很多人都会说操纵 LCD 显示就是操纵 FrameBuffer，表面上来看是这样的。实际上是 FrameBuffer 就是 Linux 内核驱动申请的一片内存空间，然后 LCD 内有一片 sram，CPU 内部有个 LCD 控制器，它有个单独的 dma 用来将 FrameBuffer 中的数据拷贝到 LCD 的 sram 中去 拷贝到 LCD 的 sram 中的数据就会显示在 LCD 上，LCD 驱动和 FrameBuffer 驱动没有必然的联系，它只是驱动 LCD 正常工作的，比如有信号传过来，那么 LCD 驱动负责把信号转成显示屏上的内容，至于什么内容这就是应用层要处理的。</p>
<blockquote>
<p>静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。<br>DMA（Direct Memory Access），直接内存访问。使用 DMA 的好处就是它不需要 CPU 的干预而直接服务外设，这样 CPU 就可以去处理别的事务，从而提高系统的效率。</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://carlyleliu.github.io/2021/Linux%E9%A9%B1%E5%8A%A8%E4%B9%8BFramebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">Linux 驱动之 Framebuffer 子系统 | 量子范式</a><br><a target="_blank" rel="noopener" href="https://www.codenong.com/cs106598190/">Linux 驱动开发（9）——- framebuffer 驱动详解 | 码农家园</a><br><a target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201502&filename=1015587486.nh&uniplatform=NZKPT&v=KNvhApgKTzqH-mWxqP6f8BkbDR9mSjPHz8PfaxqDg2f1j30XqnHzSDsvwoqz-CbX">嵌入式系统中帧缓冲显示模块的设计与实现 - 中国知网</a><br><a target="_blank" rel="noopener" href="https://github.com/tsuibin/research/tree/master/framebuffer/fivechess/fivechess-0.1">research/framebuffer/fivechess/fivechess-0.1 at master · tsuibin/research</a><br><a target="_blank" rel="noopener" href="https://www.shangmayuan.com/a/f67d260756ce42258a9ed4ef.html">五子棋 framebuffer 版 - 尚码园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/article/details/12096483">FrameBuffer 驱动程序分析_深入剖析 Android 系统-CSDN 博客_framebuffer</a><br><a target="_blank" rel="noopener" href="https://github.com/xianjimli/linux-framebuffer-tools">xianjimli/linux-framebuffer-tools: linux framebuffer tool</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HW411L76t?p=2">韦东山_嵌入式 Linux_第 2 期_Linux 高级驱动视频教程_免费试看版_哔哩哔哩_bilibili</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356443723">Linux LCD Frambuffer 基础介绍和使用（1） - 知乎</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/01/10/Linux%E5%AE%89%E8%A3%85nodejs/" itemprop="url">Linux 安装 Node.js 以及 hexo</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-10T03:51:50.000Z" itemprop="datePublished">1月 10 2022</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 lesen (Über 258 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="安装-Node-js-过程"><a href="#安装-Node-js-过程" class="headerlink" title="安装 Node.js 过程"></a>安装 Node.js 过程</h2><p>进入该网站<a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/download/">下载 | Node.js</a><br>也可以进入该网站下载历史版本，<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js</a></p>
<p>进入 download 目录，</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> download<br><span class="hljs-attribute">wget</span> https://nodejs.org/dist/v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>/node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span>.tar.xz  -O nodejs.tar.xz<br></code></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -xvf node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span>.tar.xz<br></code></pre></td></tr></table></figure>

<p>改名 Node.js</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span> nodejs<br></code></pre></td></tr></table></figure>

<p>将 npm，node 两个程序建立软连接，能够全局可用</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln -s <span class="hljs-regexp">/download/</span>nodejs<span class="hljs-regexp">/bin/</span>npm <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span> <br><br>ln -s <span class="hljs-regexp">/download/</span>nodejs<span class="hljs-regexp">/bin/</span>node <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span><br></code></pre></td></tr></table></figure>

<p>检查是否安装</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br><br>npm -v<br></code></pre></td></tr></table></figure>

<h2 id="安装-hexo-过程"><a href="#安装-hexo-过程" class="headerlink" title="安装 hexo 过程"></a>安装 hexo 过程</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm i hexo-<span class="hljs-keyword">cli</span> -g<br>hexo -v<br></code></pre></td></tr></table></figure>

<p>如果出现命令未找到到错误，说明 hexo 还未加入全局变量。<br>将下面命令加入</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim ~/.bashrc<br>export PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nodejs/</span>lib<span class="hljs-regexp">/node_modules/</span>hexo-cli<span class="hljs-regexp">/bin/</span>:<span class="hljs-variable">$PATH</span> <br></code></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js</a><br><a target="_blank" rel="noopener" href="https://learnku.com/articles/32767">Linux 安装 Node.js | F2E 前端技术论坛</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000024422534">Linux 下安装 node 及 npm - SegmentFault 思否</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35668237">超详细 Hexo+Github 博客搭建小白教程 - 知乎</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2022/01/05/%E8%A7%A3%E5%86%B3unable-to-install-libpng12-so-0/" itemprop="url">解决 unable to install libpng12.so.0</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-01-05T05:01:47.000Z" itemprop="datePublished">1月 5 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/Bug-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">Bug 踩坑记录</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 lesen (Über 363 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><code>apt</code>工具损坏了，在修复时使用了<code>sudo apt-get install -f</code>命令，中途会提示需要安装<code>libpng12-0</code>，但是始终无法安装，会提示如下错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Unpacking libpng12-0:amd64 (1.2.50-2+deb8u3) ... dpkg: error <br>processing archive libpng12-0_1.2.50-2+deb8u3_amd64.deb <br>(--install): unable to install new version of <span class="hljs-string">&#x27;/usr/lib/</span><br><span class="hljs-string">x86_64-linux-gnu/libpng12.so.0&#x27;</span>: No such file or directory <br>Errors were encountered <span class="hljs-keyword">while</span> processing: libpng12-0_1.2.50-2<br>+deb8u3_amd64.deb<br><br></code></pre></td></tr></table></figure>

<h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>具体原因未知，网上答案众说纷纭。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>这个问题遇到的人还挺多的，解决方法也各不相同，我先说我自己最终解决的方法。</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol>
<li><p>将软件源更换成中科院的源，使用 Linux 自带的<strong>软件和更新</strong>工具，具体方法参考<a target="_blank" rel="noopener" href="https://dunky-z.github.io/2021/07/30/%E6%9B%B4%E6%8D%A2Ubuntu%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/">这篇文章</a>。更换完之后可以重新尝试安装，有人换源后即可成功安装。</p>
</li>
<li><p>如果未能安装成功，可能曾经手动添加过软件源，将其删除。</p>
 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 将所有内容注释</span><br>vim <span class="hljs-regexp">/etc/</span>apt/sources.list<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol>
<li><p>下载已安装的库文件<code>libpng12.so.0</code>，可以从<a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/pf9cAPjuqfn">该链接</a>下载。</p>
</li>
<li><p>将该文件复制到它本该安装的位置。</p>
 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> cp libpng<span class="hljs-number">12</span>.so.<span class="hljs-number">0</span> /usr/lib/x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>-linux-gnu/<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-built_in"> add-apt-repository </span>ppa:linuxuprising/libpng12<br>sudo apt update<br>sudo apt install libpng12-0<br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2021/12/24/VSCode%E4%BD%BF%E7%94%A8sftp%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%87%B3%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url">VSCode 使用 sftp 插件上传本地文件至局域网服务器</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-12-24T03:39:03.000Z" itemprop="datePublished">12月 24 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/%E4%B8%87%E8%83%BD-VSCode/">万能 VSCode</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 lesen (Über 574 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>测试代码时经常需要上传文件至服务器端运行，每次上传都需要通过第三方传输工具如 FileZilla，有了<code>SFTP</code>插件，可以直接在 VSCode 上编译成功后，一键上传本地文件。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>打开插件中心，搜索<code>sftp</code>，安装量最高的就是我们需要的插件，点击安装。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104114810.png"></p>
<h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><p>插件安装完成后，输入快捷键<code>Control + Shift + P</code> 弹出命令面板，然后输入<code>sftp:config</code>，回车，当前工程的<code>.vscode</code>文件夹下就会自动生成一个<code>sftp.json</code>文件，我们需要在这个文件里配置的内容可以是：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.xxx&quot;</span>, <span class="hljs-comment">//服务器 ip</span><br>  <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp 模式是 22</span><br>  <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>  <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>  <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;ftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>  <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">&quot;privateKeyPath&quot;</span>: <span class="hljs-literal">null</span>,   <span class="hljs-comment">//存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件）</span><br>  <span class="hljs-attr">&quot;passphrase&quot;</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">&quot;passive&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;interactiveAuth&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;remotePath&quot;</span>: <span class="hljs-string">&quot;/root/node/build/&quot;</span>, <span class="hljs-comment">//服务器上的文件地址</span><br>  <span class="hljs-attr">&quot;context&quot;</span>: <span class="hljs-string">&quot;./server/build&quot;</span>,      <span class="hljs-comment">//本地的文件地址</span><br>  <span class="hljs-attr">&quot;uploadOnSave&quot;</span>: <span class="hljs-literal">true</span>,             <span class="hljs-comment">//监听保存并上传</span><br>  <span class="hljs-attr">&quot;syncMode&quot;</span>: <span class="hljs-string">&quot;update&quot;</span>,<br>  <span class="hljs-attr">&quot;watcher&quot;</span>: &#123;<br>    <span class="hljs-comment">//监听外部文件</span><br>    <span class="hljs-attr">&quot;files&quot;</span>: <span class="hljs-literal">false</span>,                 <span class="hljs-comment">//外部文件的绝对路径</span><br>    <span class="hljs-attr">&quot;autoUpload&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;autoDelete&quot;</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;ignore&quot;</span>: [<br>    <span class="hljs-comment">//指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹</span><br>    <span class="hljs-comment">//注意每一行后面有逗号，最后一行没有逗号</span><br>    <span class="hljs-comment">//忽略项</span><br>    <span class="hljs-string">&quot;**/.vscode/**&quot;</span>,<br>    <span class="hljs-string">&quot;**/.git/**&quot;</span>,<br>    <span class="hljs-string">&quot;**/.DS_Store&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><ul>
<li><p>可以直接右击文件，选择<code>Upload</code>，会将文件上传至配置好的<code>remotePath</code>。</p>
</li>
<li><p>可以<code>Control + Shift + P</code>输入<code>sftp</code>，选择想要执行的命令，命令都是字面意思，不多做解释。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104115716.png"></p>
</li>
<li><p>如果有多个 IP 需要配置，可以在<code>sftp.json</code>文件中，通过方括号<code>[]</code>添加。比如</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>    &#123;<br>    <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.01&quot;</span>, <span class="hljs-comment">//服务器 ip</span><br>    <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp模式是22</span><br>    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>    <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;sftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>    <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>    &#125;,<br>    &#123;<br>    <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.02&quot;</span>, <span class="hljs-comment">//服务器 ip</span><br>    <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp模式是22</span><br>    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>    <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;sftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>    <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>    &#125;,<br>    &#123;<br>    <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.03&quot;</span>, <span class="hljs-comment">//服务器 ip</span><br>    <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp模式是22</span><br>    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>    <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;sftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>    <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>    &#125;<br>]<br></code></pre></td></tr></table></figure></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2021/12/04/%E8%A7%A3%E5%86%B3Linux%E5%90%AF%E5%8A%A8%E5%87%BA%E7%8E%B0fsck-exited-with-status-code-4/" itemprop="url">解决 Linux 启动出现 fsck exited with status code 4</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-12-04T02:18:09.000Z" itemprop="datePublished">12月 4 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/Bug-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">Bug 踩坑记录</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 分钟 lesen (Über 146 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112041102634.png"></p>
<h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>磁盘检测不能通过，可能是因为系统突然断电或其它未正常关闭系统导致。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>根据提示可以看到是<code>dev/sda5</code>这个扇区出现了异常，所以通过<code>fsck</code>命令修复文件系统。<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-fsck.html">详细命令解释</a>。</p>
<p>将<code>sda5</code>改为自己损坏的扇区即可，等待一段时间修复完成后，输入<code>exit</code>即可重启。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fsck -y  /dev/sda5<br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../../../2021/12/01/Clang-Format%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/" itemprop="url">Clang-Format 格式化代码</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-12-01T09:42:45.000Z" itemprop="datePublished">12月 1 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/">工欲善其事必先利其器</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            16 分钟 lesen (Über 2353 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install clang-format<br></code></pre></td></tr></table></figure>

<h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>每每到这时候就越能感受到用 Linux 作为开发环境的优势，Windows 安装就稍显复杂了。</p>
<ol>
<li><p>你可以选择安装完整的 LLVM，在<code>bin</code>目录可以看到<code>clang-format.exe</code>。安装完后，将 <code>bin</code> 目录<strong>添加到环境变量</strong>中。</p>
</li>
<li><p>你也可以只下载<code>clang-format.exe</code>，从<a target="_blank" rel="noopener" href="https://llvm.org/builds/">LLVM Snapshot Builds</a>下载安装包。在下载页面的底部。同样你需要将单独下载的文件<strong>加入到环境变量</strong>中。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208271559281.png"></p>
</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h3><p>Linux 可以直接命令行，使用以 LLVM 代码风格格式化<code>main.cpp</code>, 结果直接写到<code>main.cpp</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang g-format -i main.cpp -style=LLVM<br></code></pre></td></tr></table></figure>

<h3 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h3><p>如果每次编码都命令行执行一遍那也太麻烦了，而且每次修改也不止一个文件。最好的方式就是每次保存文件时自动格式化。比如 VSCode 已经内置了<code>Clang-Format</code>稍作配置即可实现，接下来介绍几种常见 IDE 如何配置<code>Clang-Format</code>。</p>
<h4 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h4><p>VSCode 最常用，因为内置了<code>Clang-Format</code>也最容易配置。</p>
<ul>
<li>安装<code>C/C++</code>插件，<code>Ctrl+Shift+X</code>打开应用商店，搜索<code>C/C++</code>找到下图插件，安装后会自动安装<code>Clang-Format</code>程序，无需单独下载。默认安装路径为：<br><code>C:\Users\(你的用户名)\.vscode\extensions\ms-vscode.cpptools-1.7.1\LLVM\bin\clang-format.exe</code>。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012311818.png"></li>
<li>打开设置页面（左下角齿轮 - 设置），搜索<code>format</code>，勾选<code>Format On Save</code>，每次保存文件时自动格式化文档。下方的设置是决定每次格式化是整个文档，还是做过修改的内容。默认是<code>file</code>，对整个文档进行格式化。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012304766.png"></li>
<li>仍在设置页面搜索<code>Clang</code>，配置如下。<code>.clang-format</code>文件最后详解。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012321838.png"></li>
<li>效果图<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012327867.gif"></li>
</ul>
<h4 id="QtCreator"><a href="#QtCreator" class="headerlink" title="QtCreator"></a>QtCreator</h4><ul>
<li>安装<code>Beautifier</code>插件：帮助（<code>Help</code>）-关于插件（<code>About Plugins</code>）- <code>Beautifier</code>勾选，重启 QtCreator。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202183720.png"></li>
<li>工具（Tool）- <code>Beautifier</code>，配置如图。该配置，保存文档时自动格式化，并选择<code>Clang-Format</code>作为格式化工具。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202184119.png"><br>配置<code>Clang-Format</code>程序路径，如果开头已经<code>apt install</code>安装过，这里会自动补全。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202184247.png"></li>
<li><code>Use predefined style</code>可以选择内置的一些代码风格，如<code>LLVM</code>，<code>Google</code>等。</li>
<li><code>Use customized style</code>使用自定义的一些代码风格。点击添加（<code>Add</code>）将配置文件粘贴进去即可，具体配置文件见最后。</li>
<li>别忘了点击<code>OK</code>保存。</li>
</ul>
<h4 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h4><ul>
<li><p>安装<code>cppstyle</code>插件：Help - Eclipse Marketplace - 搜索<code>cppstyle</code>。</p>
</li>
<li><p>下载<code>cpplint</code>。<br>  可以去github上下载<a target="_blank" rel="noopener" href="https://github.com/google/styleguide">cpplint的源码</a>，下载完之后解压放到某个目录下。</p>
</li>
<li><p>在<code>Window</code> - <code>Preferences</code> - <code>C/C++</code> - <code>CppStyle</code>页面把<code>clang-format</code>的路径添加进去，然后把<code>cpplint</code>的目录指向刚才下载的<code>styleguide</code>目录下的<code>cpplint/cpplint.py</code>就可以了。勾选下面的<code>Enable cpplint</code>，<code>Run clang-format on file save</code>，然后点击<code>Apply and Close</code>保存修改并退出。如下图所示。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202190912.png"></p>
</li>
<li><p>此时再保存代码，将会出现如下错误，因为我们还未给当前项目编写配置文件<code>.clang-format</code>。将最后一章提到的配置文件放到当前项目的下即可，程序会自动搜索。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Cannot find .clang-format or _clang-format configuration file under any level parent directories of path.<br>Clang-format will default to Google style.<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置简介"><a href="#配置简介" class="headerlink" title="配置简介"></a>配置简介</h2><p>上文多次提到了<code>.clang-format</code>配置文件，该文件决定了代码如何格式化，现在来介绍如何使用该文件。</p>
<h3 id="导出-clang-format文件"><a href="#导出-clang-format文件" class="headerlink" title="导出.clang-format文件"></a>导出<code>.clang-format</code>文件</h3><p>如果重新编写一份配置文件，需要考虑的东西太多，<code>clang-format</code>内置了一些常见风格，我们可以根据已有的配置文件稍作修改，形成自己的代码风格。所以我们先导出一份内置的配置文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang-format -style=可选格式名 -dump-config &gt; .clang-format<br><span class="hljs-comment"># 可选格式最好写预设那那几个写最接近你想要的格式。比如我想要接近 Google C++ style 的。我就写-style=google</span><br></code></pre></td></tr></table></figure>

<h3 id="各个选项的含义"><a href="#各个选项的含义" class="headerlink" title="各个选项的含义"></a>各个选项的含义</h3><p>这里给出了配置的含义，感兴趣也可以查看官方文档，还提供了一些有案例，描述更清晰。</p>
<p>一些比较明显的代码分格区别</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># 括号是分行，还是不分行，只有当 BreakBeforeBraces 设置为 Custom 时才有效<br>BraceWrapping:<br>  AfterCaseLabel:  <span class="hljs-literal">true</span><br>  # <span class="hljs-keyword">class</span> 定义后面<br>  <span class="hljs-symbol">AfterClass:      <span class="hljs-symbol">true</span></span><br>  # 控制语句后面<br>  <span class="hljs-symbol">AfterControlStatement: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterEnum:       <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterFunction:   <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterNamespace:  <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterObjCDeclaration: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterStruct:     <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterUnion:      <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterExternBlock: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">BeforeCatch:     <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">BeforeElse:      <span class="hljs-symbol">true</span></span><br>  # 缩进大括号，<span class="hljs-symbol">if</span> <span class="hljs-symbol">else</span> 语句后面的括号缩进<br>  <span class="hljs-symbol">IndentBraces:    <span class="hljs-symbol">false</span></span><br>  <span class="hljs-symbol">SplitEmptyFunction: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">SplitEmptyRecord: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">SplitEmptyNamespace: <span class="hljs-symbol">true</span></span><br><span class="hljs-symbol">BreakBeforeBinaryOperators: <span class="hljs-symbol">None</span></span><br><span class="hljs-symbol">BreakBeforeBraces: <span class="hljs-symbol">Custom</span></span><br><br># <span class="hljs-symbol">tab</span> 宽度<br><span class="hljs-symbol">TabWidth: <span class="hljs-symbol">4</span></span><br><br># 换行缩进字符数<br><span class="hljs-symbol">IndentWidth:     <span class="hljs-symbol">4</span></span><br><br># 宏定义对齐<br><span class="hljs-symbol">AlignConsecutiveMacros: <span class="hljs-symbol">AcrossEmptyLinesAndComments</span></span><br></code></pre></td></tr></table></figure>

<p>基于LLVM代码风格修改的个人使用版本：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">Language:</span>        <span class="hljs-string">Cpp</span><br><span class="hljs-comment"># BasedOnStyle:  LLVM</span><br><span class="hljs-attr">AccessModifierOffset:</span> <span class="hljs-number">-2</span><br><span class="hljs-attr">AlignAfterOpenBracket:</span> <span class="hljs-string">Align</span><br><span class="hljs-comment"># 宏定义对齐</span><br><span class="hljs-attr">AlignConsecutiveMacros:</span> <span class="hljs-string">AcrossEmptyLinesAndComments</span><br><span class="hljs-attr">AlignConsecutiveAssignments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignConsecutiveDeclarations:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignConsecutiveBitFields:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignEscapedNewlines:</span> <span class="hljs-string">Right</span><br><span class="hljs-attr">AlignOperands:</span>   <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignTrailingComments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowAllArgumentsOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowAllConstructorInitializersOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowShortBlocksOnASingleLine:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 是否允许短方法单行，只有一行的函数将不会分行，直接写在函数名后</span><br><span class="hljs-attr">AllowShortFunctionsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">AllowShortLambdasOnASingleLine:</span> <span class="hljs-string">All</span><br><span class="hljs-attr">AllowShortIfStatementsOnASingleLine:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">AllowShortLoopsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">AlwaysBreakAfterDefinitionReturnType:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">AlwaysBreakAfterReturnType:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">AlwaysBreakTemplateDeclarations:</span> <span class="hljs-string">MultiLine</span><br><span class="hljs-attr">BinPackArguments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">BinPackParameters:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 括号是分行，还是不分行，只有当 BreakBeforeBraces 设置为 Custom 时才有效</span><br><span class="hljs-attr">BraceWrapping:</span><br>  <span class="hljs-attr">AfterCaseLabel:</span>  <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># class 定义后面</span><br>  <span class="hljs-attr">AfterClass:</span>      <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 控制语句后面</span><br>  <span class="hljs-attr">AfterControlStatement:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterEnum:</span>       <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterFunction:</span>   <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterNamespace:</span>  <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterObjCDeclaration:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterStruct:</span>     <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterUnion:</span>      <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterExternBlock:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">BeforeCatch:</span>     <span class="hljs-literal">true</span><br>  <span class="hljs-attr">BeforeElse:</span>      <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 缩进大括号</span><br>  <span class="hljs-attr">IndentBraces:</span>    <span class="hljs-literal">false</span><br>  <span class="hljs-attr">SplitEmptyFunction:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">SplitEmptyRecord:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">SplitEmptyNamespace:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">BreakBeforeBinaryOperators:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">BreakBeforeBraces:</span> <span class="hljs-string">Custom</span><br><span class="hljs-attr">BreakBeforeInheritanceComma:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">BreakInheritanceList:</span> <span class="hljs-string">BeforeColon</span><br><span class="hljs-attr">BreakBeforeTernaryOperators:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">BreakConstructorInitializersBeforeComma:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">BreakConstructorInitializers:</span> <span class="hljs-string">BeforeColon</span><br><span class="hljs-attr">BreakAfterJavaFieldAnnotations:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">BreakStringLiterals:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">ColumnLimit:</span>     <span class="hljs-number">100</span><br><span class="hljs-attr">CommentPragmas:</span>  <span class="hljs-string">&#x27;^ IWYU pragma:&#x27;</span><br><span class="hljs-attr">CompactNamespaces:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">ConstructorInitializerAllOnOneLineOrOnePerLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">ConstructorInitializerIndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">ContinuationIndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">Cpp11BracedListStyle:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">DeriveLineEnding:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">DerivePointerAlignment:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">DisableFormat:</span>   <span class="hljs-literal">false</span><br><span class="hljs-attr">ExperimentalAutoDetectBinPacking:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">FixNamespaceComments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">ForEachMacros:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">foreach</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Q_FOREACH</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">BOOST_FOREACH</span><br><span class="hljs-attr">IncludeBlocks:</span>   <span class="hljs-string">Preserve</span><br><span class="hljs-attr">IncludeCategories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span>           <span class="hljs-string">&#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span><br>    <span class="hljs-attr">Priority:</span>        <span class="hljs-number">2</span><br>    <span class="hljs-attr">SortPriority:</span>    <span class="hljs-number">0</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span>           <span class="hljs-string">&#x27;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#x27;</span><br>    <span class="hljs-attr">Priority:</span>        <span class="hljs-number">3</span><br>    <span class="hljs-attr">SortPriority:</span>    <span class="hljs-number">0</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span>           <span class="hljs-string">&#x27;.*&#x27;</span><br>    <span class="hljs-attr">Priority:</span>        <span class="hljs-number">1</span><br>    <span class="hljs-attr">SortPriority:</span>    <span class="hljs-number">0</span><br><span class="hljs-attr">IncludeIsMainRegex:</span> <span class="hljs-string">&#x27;(Test)?$&#x27;</span><br><span class="hljs-attr">IncludeIsMainSourceRegex:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">IndentCaseLabels:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">IndentGotoLabels:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">IndentPPDirectives:</span> <span class="hljs-string">None</span><br><span class="hljs-comment"># 换行缩进字符数</span><br><span class="hljs-attr">IndentWidth:</span>     <span class="hljs-number">4</span><br><span class="hljs-attr">IndentWrappedFunctionNames:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">JavaScriptQuotes:</span> <span class="hljs-string">Leave</span><br><span class="hljs-attr">JavaScriptWrapImports:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">KeepEmptyLinesAtTheStartOfBlocks:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">MacroBlockBegin:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">MacroBlockEnd:</span>   <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">MaxEmptyLinesToKeep:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">NamespaceIndentation:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">ObjCBinPackProtocolList:</span> <span class="hljs-string">Auto</span><br><span class="hljs-attr">ObjCBlockIndentWidth:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">ObjCSpaceAfterProperty:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">ObjCSpaceBeforeProtocolList:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">PenaltyBreakAssignment:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="hljs-number">19</span><br><span class="hljs-attr">PenaltyBreakComment:</span> <span class="hljs-number">300</span><br><span class="hljs-attr">PenaltyBreakFirstLessLess:</span> <span class="hljs-number">120</span><br><span class="hljs-attr">PenaltyBreakString:</span> <span class="hljs-number">1000</span><br><span class="hljs-attr">PenaltyBreakTemplateDeclaration:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">PenaltyExcessCharacter:</span> <span class="hljs-number">1000000</span><br><span class="hljs-attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="hljs-number">60</span><br><span class="hljs-attr">PointerAlignment:</span> <span class="hljs-string">Right</span><br><span class="hljs-attr">ReflowComments:</span>  <span class="hljs-literal">true</span><br><span class="hljs-attr">SortIncludes:</span>    <span class="hljs-literal">true</span><br><span class="hljs-attr">SortUsingDeclarations:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceAfterCStyleCast:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceAfterLogicalNot:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceAfterTemplateKeyword:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeAssignmentOperators:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeCpp11BracedList:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceBeforeCtorInitializerColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeInheritanceColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeParens:</span> <span class="hljs-string">ControlStatements</span><br><span class="hljs-attr">SpaceBeforeRangeBasedForLoopColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceInEmptyBlock:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceInEmptyParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesBeforeTrailingComments:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">SpacesInAngles:</span>  <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInConditionalStatement:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInContainerLiterals:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpacesInCStyleCastParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInSquareBrackets:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceBeforeSquareBrackets:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">Standard:</span>        <span class="hljs-string">Latest</span><br><span class="hljs-attr">StatementMacros:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Q_UNUSED</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">QT_REQUIRE_VERSION</span><br><span class="hljs-attr">TabWidth:</span>        <span class="hljs-number">8</span><br><span class="hljs-attr">UseCRLF:</span>         <span class="hljs-literal">false</span><br><span class="hljs-attr">UseTab:</span>          <span class="hljs-string">Never</span><br><span class="hljs-string">...</span><br><br></code></pre></td></tr></table></figure>

<h3 id="格式化最新的commit代码"><a href="#格式化最新的commit代码" class="headerlink" title="格式化最新的commit代码"></a>格式化最新的commit代码</h3><p><code>clang-format</code>还提供一个<code>clang-format-diff.py</code>脚本，用来格式化<code>patch</code>，<code>code review</code>提交代码前，跑一遍下面的代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 格式化最新的 commit，并直接在原文件上修改<br>git diff -U0 HEAD^ | clang-format-diff.py -i -p1<br></code></pre></td></tr></table></figure>

<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="如何看懂官方文档并编写配置文件"><a href="#如何看懂官方文档并编写配置文件" class="headerlink" title="如何看懂官方文档并编写配置文件"></a>如何看懂官方文档并编写配置文件</h4><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">官方文档</a>里有各种设置的示例代码，即使不知道想要的格式化是哪个配置参数，翻一翻官方文档是示例大概率能找到。那么找到了想要的配置参数，如何在文件里配置呢？</p>
<p>以宏定义对齐为例。我们想要宏定义的值保持对齐的状态，如下一节图片所示。可以翻一遍官方文档，可以发现这个示例代码对应的参数可能是我们想要的，<code>AlignConsecutiveMacros</code>翻译为<strong>对齐连续的宏定义</strong>。那应该八九不离十了。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112202021134.png"></p>
<p>找到了参数如何编写配置文件呢？可以继续看这个参数下面的更多示例，每一个示例都对应一个配置可能值<code>Possible values</code>。</p>
<ul>
<li><p><code>ACS_None</code> (in configuration: <code>None</code>)<br>Do not align macro definitions on consecutive lines.<br><code>ACS_None</code>为这个配置的缩写，<code>None</code>表示在配置文件里的值。该配置表示不对宏定义进行对齐操作，在配置文件里可以添加如下：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">AlignConsecutiveMacros:</span> None<br></code></pre></td></tr></table></figure></li>
<li><p><code>ACS_Consecutive</code> (in configuration: <code>Consecutive</code>)<br>Align macro definitions on consecutive lines. This will result in formattings like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SHORT_NAME       42</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LONGER_NAME      0x007f</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EVEN_LONGER_NAME (2)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> foo(x) (x * x)</span><br><span class="hljs-comment">/* some comment */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bar(y, z) (y + z)</span><br></code></pre></td></tr></table></figure>

<p><code>ACS_Consecutive</code>为这个配置的缩写，<code>Consecutive</code>表示在配置文件里的值。该配置表示对连续的宏定义进行对齐，在配置文件里可以添加如下：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">AlignConsecutiveMacros:</span> Consecutive<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="宏定义对齐失效"><a href="#宏定义对齐失效" class="headerlink" title="宏定义对齐失效"></a>宏定义对齐失效</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 宏定义对齐</span><br><span class="hljs-symbol">AlignConsecutiveMacros:</span> AcrossEmptyLinesAndComments<br></code></pre></td></tr></table></figure>

<p>使用宏定义对齐更详细的配置，可以<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">参考官方文档</a>。使用该配置一定要使用等宽的字体，否则配置生效但是显示不正确。<br>比如我是用<strong>微软雅黑</strong>字体作为编码字体，因为该字体每个字符不等宽，导致格式化正确，但是显示不正确。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112201954096.png"></p>
<p>如果将字体换位等宽字体如常用的<strong>Consolas</strong>，就可以正常显示。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112201958869.png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="../3/">Vorheriges</a>
    </div>
    <div class="pagination-next">
        <a href="../5/">Nächstes</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="../../">1</a></li>
        
        <li><a class="pagination-link" href="../2/">2</a></li>
        
        <li><a class="pagination-link" href="../3/">3</a></li>
        
        <li><a class="pagination-link is-current" href="">4</a></li>
        
        <li><a class="pagination-link" href="../5/">5</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="../9/">9</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2024 Dominic&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>




<script src="../../../../js/script.js"></script>


    
</body>
</html>