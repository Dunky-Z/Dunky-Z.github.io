<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Kernel on PaperMod</title>
    <link>http://localhost:8888/tags/kernel/</link>
    <description>Recent content in Kernel on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Sat, 13 Jan 2024 22:00:16 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/tags/kernel/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux内核模块校验机制</title>
      <link>http://localhost:8888/posts/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 13 Jan 2024 22:00:16 +0000</pubDate>
      <guid>http://localhost:8888/posts/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/</guid>
      <description>初学 Linux 内核或者第一次编译使用内核模块时经常会遇到类似这样的错误：
insmod: ERROR: could not insert module kvm.ko: Invalid module format 这个报错通常由于当前插入kvm.ko的version magic版本信息与正在运行的 kernel 的version magic版本不一致导致的。
内核校验模块的流程 我们从问题出发，看看内核是如何校验模块的。搜索了内核源码，找到了在函数check_version中抛出了disagrees about version of symbol错误信息，我们根据源码来回溯一下整个过程。
// kernel/module.c static int check_version(const struct load_info *info, const char *symname, struct module *mod, const s32 *crc) { Elf_Shdr *sechdrs = info-&amp;gt;sechdrs; unsigned int versindex = info-&amp;gt;index.vers; unsigned int i, num_versions; struct modversion_info *versions; /* Exporting module didn&amp;#39;t supply crcs? OK, we&amp;#39;re already tainted. */ if (!</description>
    </item>
    <item>
      <title>构建和测试 RISC-V 架构下启用 ACPI 的内核</title>
      <link>http://localhost:8888/posts/%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95risc-v%E6%9E%B6%E6%9E%84%E4%B8%8B%E5%90%AF%E7%94%A8acpi%E7%9A%84%E5%86%85%E6%A0%B8/</link>
      <pubDate>Tue, 12 Jul 2022 15:06:51 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95risc-v%E6%9E%B6%E6%9E%84%E4%B8%8B%E5%90%AF%E7%94%A8acpi%E7%9A%84%E5%86%85%E6%A0%B8/</guid>
      <description>参考自PoC : How to build and test ACPI enabled kernel · riscv-non-isa/riscv-acpi Wiki
准备环境及工具链 安装 RISC-V 工具链，需下载原发行版。好在 apt 可以安装。
如果报错：riscv64-linux-gnu-gcc: error: unrecognized command line option ‘-mno-relax’; did you mean ‘-Wno-vla’?，多半是工具链原因，请按照以下方法安装！！！
sudo apt remove gcc-riscv64-linux-gnu sudo apt install gcc-8-riscv64-linux-gnu 安装必要的三方库，以下为Ubuntu下的命令，其他平台可以参考这个文档。
sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \ gawk build-essential bison flex texinfo gperf libtool patchutils bc \ zlib1g-dev libexpat-dev git 下载源码 可能无法一次搭建成功，一些环境变量会经常用到，所以干脆把所有环境变量放到.bashrc。
vim ~/.bashrc # 添加以下内容 export WORK_DIR=~/riscv64-acpi export GCC5_RISCV64_PREFIX=riscv64-unknown-elf- export MAINSPACE=~/riscv64-acpi/tianocore export PACKAGES_PATH=$MAINSPACE/edk2:$MAINSPACE/edk2-platforms export EDK_TOOLS_PATH=$MAINSPACE/edk2/BaseTools 首先，创建一个工作目录，我们将在其中下载并构建所有源代码。</description>
    </item>
  </channel>
</rss>
