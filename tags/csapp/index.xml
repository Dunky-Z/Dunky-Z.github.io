<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CSAPP on PaperMod</title>
    <link>http://localhost:8888/tags/csapp/</link>
    <description>Recent content in CSAPP on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Mon, 11 Jul 2022 09:55:39 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/tags/csapp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CSAPP-LAB-Cache Lab</title>
      <link>http://localhost:8888/posts/csapp-lab-cache-lab/</link>
      <pubDate>Mon, 11 Jul 2022 09:55:39 +0000</pubDate>
      <guid>http://localhost:8888/posts/csapp-lab-cache-lab/</guid>
      <description>预备知识 开始这个实验前，需要学习《CSAPP 第六章-存储器层次结构》的相关内容，与缓存相关的内容，我也做了相关的CPU Cache 高速缓存学习记录可以参考。
实验相关的文件可以从CS:APP3e, Bryant and O&amp;rsquo;Hallaron下载。
其中，
README：介绍实验目的和实验要求，以及实验的相关文件。需要注意的是，必须在 64-bit x86-64 system 上运行实验。需要安装 Valgrind 工具。 Writeup：实验指导。 Release Notes：版本发布信息。 Self-Study Handout：需要下载的压缩包，里面包含了待修改的源码文件等。 下载 Self-Study Handout 并解压，得到如下文件：
├── cachelab.c # 一些辅助函数，如打印输出等，不需要修改 ├── cachelab.h # 同上 ├── csim.c # 需要完善的主文件，需要在这里模拟Cache ├── csim-ref # 已经编译好的程序，我们模拟的Cache需要与这个程序运行的结果保持一致 ├── driver.py # 驱动程序，运行 test-csim 和 test-trans ├── Makefile # 用来编译csim程序 ├── README # ├── test-csim # 测试缓存模拟器 ├── test-trans.c # 测试转置功能 ├── tracegen.c # test-trans 辅助程序 ├── traces # test-csim.</description>
    </item>
    <item>
      <title>CSAPPLAB-Bomb Lab</title>
      <link>http://localhost:8888/posts/csapp-lab-bomb-lab/</link>
      <pubDate>Sun, 29 Aug 2021 18:40:16 +0000</pubDate>
      <guid>http://localhost:8888/posts/csapp-lab-bomb-lab/</guid>
      <description>Tips 缩写注释 CSAPP：Computer Systems A Programmer’s Perspective（深入理解计算机操作系统）。CSAPP（C：P166，O：P278）表示书本的中文版第 166 页，英文原版第 278 页。
寄存器信息 了解寄存器的基本用途，看到一个汇编代码，可以大概了解这个寄存器是在栈中使用的，还是保存参数的，是调用者保存，还是被调用者保存。 GDB 调试过程用到的 GDB 命令可以先参考GDB 调试入门这篇文章。文中所用例子也是摘自与 BombLab 的源码，更容易理解如何使用。还有一定比较重要的是，如何使用 gdb 带参数调试。为了不用每次运行bomb程序都需要重新输入答案，bomb程序可以读取文本信息，在文本文件中写入答案即可免去手动输入。
phase_1 拆弹专家已上线，开干！！！！！！！！！！！！！
(gdb) b phase_1(gdb) b explode_bomb(gdb) disas phase_1Dump of assembler code for function phase_1:&amp;#39;0x0000000000400ee0 &amp;lt;+0&amp;gt;: sub $0x8,%rsp0x0000000000400ee4 &amp;lt;+4&amp;gt;: mov $0x402400,%esi0x0000000000400ee9 &amp;lt;+9&amp;gt;: callq 0x401338 &amp;lt;strings_not_equal&amp;gt;0x0000000000400eee &amp;lt;+14&amp;gt;: test %eax,%eax0x0000000000400ef0 &amp;lt;+16&amp;gt;: je 0x400ef7 &amp;lt;phase_1+23&amp;gt;0x0000000000400ef2 &amp;lt;+18&amp;gt;: callq 0x40143a &amp;lt;explode_bomb&amp;gt;0x0000000000400ef7 &amp;lt;+23&amp;gt;: add $0x8,%rsp0x0000000000400efb &amp;lt;+27&amp;gt;: retq End of assembler dump.</description>
    </item>
    <item>
      <title>GDB 调试入门</title>
      <link>http://localhost:8888/posts/gdb%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 29 Aug 2021 18:40:16 +0000</pubDate>
      <guid>http://localhost:8888/posts/gdb%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/</guid>
      <description>file 加载程序 (gdb) file bomb Reading symbols from bomb... set args 带参数调试 有时候程序不是直接可以运行的，需要加上一些必要的参数。带上参数运行很容易，只要在程序名后加上相应参数即可，但是如何带上参数进行调试呢？这就需要set args命令。
比如在BombLab实验中，我们不可能一次解决所有phase，但是每次重新调试，已经解决的phase还要重新输入一次答案，这就很麻烦，好在这个实验的作者也考虑到了，他支持读取文本。我们可以把答案预先写入一个文本文件中，程序读取已经保存的答案即可跳过相应的phase。
假设我们把答案写入了solutions.txt文件中，首先，我们加载程序，然后通过set args solutions.txt设置运行参数。
(gdb) file bomb Reading symbols from bomb... (gdb) set args solutions.txt (gdb) r Starting program: /home/dominic/learning-linux/bomb/bomb solutions.txt Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! Phase 1 defused. How about the next one? That&amp;#39;s number 2. Keep going! list 查看源码 查看 10 行源码 每条命令显示 10 行代码</description>
    </item>
  </channel>
</rss>
