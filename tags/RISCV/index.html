<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>Tag: RISCV - 如云泊</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">










<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="../../css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="如云泊" type="application/atom+xml">
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="../../index.html">
                
                <img src="../../images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5>#RISCV</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/08/29/RISC-V%E5%85%A5%E9%97%A8-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" itemprop="url">RISC-V 入门 - 系统调用</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-08-29T05:16:03.000Z" itemprop="datePublished">8月 29 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/RISC-V-%E5%85%A5%E9%97%A8/">RISC-V 入门</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            6 分钟 lesen (Über 881 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><p>目前为止的学习过程中，所有的程序都是运行在 Machine 模式下，但是在哪决定程序运行在什么模式下的呢？</p>
<p>在学习抢占式多任务时，我们有了创建任务的概念，在汇编代码中有这么一段，使用到了<code>mstatus</code>寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm"># Notice: default mstatus is 0<br># Set mstatus.MPP to 3, so we still run in Machine mode after MRET.<br># Set mstatus.MPIE to 1, so MRET will enable the interrupt.<br>li t0, 3 &lt;&lt; 11 | 1 &lt;&lt; 7<br>csrr a1, mstatus     # a1 = mstatus<br>or t0, t0, a1          # t0 = t0 | a1<br>csrw mstatus, t0     # mstatus = t0<br><br>j start_kernel  # hart 0 jump to c<br></code></pre></td></tr></table></figure>

<p><code>mret</code>返回后，是根据寄存器<code>mstatus</code>的<code>MPP</code>来决定接来来是处于什么模式，我们在上面将<code>MPP</code>配置为<code>3</code>， <code>MPP</code>的功能是 <strong>记录 Machine 模式下，前一个，特权级</strong>。这里解实现了在<code>mret</code>之后将模式设置为 Machine 模式（3）。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-00-30-55f75636e01aeb7bd76220a1a3ff47b9-20220830150029-154a85.png"></p>
<p>因为<code>mstatus</code>上电后默认为全 0，所以如果不对其设置，那么在<code>mret</code>之后，就是运行在用户态（0）。</p>
<p>如果想让程序跑在用户态，只要不对齐设置，保持默认即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm"># Notice: default mstatus is 0<br># Set mstatus.MPP to 3, so we still run in Machine mode after MRET.<br># Set mstatus.MPIE to 1, so MRET will enable the interrupt.<br>li t0, 1 &lt;&lt; 7<br>csrr a1, mstatus     # a1 = mstatus<br>or t0, t0, a1          # t0 = t0 | a1<br>csrw mstatus, t0     # mstatus = t0<br><br>j start_kernel  # hart 0 jump to c<br></code></pre></td></tr></table></figure>

<p>为什么需要系统调用？因为在用户态一些资源（寄存器）的访问是受限的，所以需要封装一些函数，这些函数里会进行模式切换，然后访问需要的资源。</p>
<p>那么如何进行模式的切换呢？这就需要<code>ecall</code>指令。它本质上是触发了异常，就会进入到 Machine 模式处理异常，在 Machine 模式下就相当于在内核态了，就没有访问资源的限制了。</p>
<h2 id="系统模式的切换"><a href="#系统模式的切换" class="headerlink" title="系统模式的切换"></a>系统模式的切换</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-27-34-3c336196c43c6f6ccbefca72d74ae3c7-20220830152733-8bbc12.png"></p>
<p><code>ECALL</code>指令实际就是主动触发异常，根据<code>ECALL</code>的权限级别产生不同的异常码，如下图：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-29-47-4836183d7fc588d43a989f57e39e3dbd-20220830152946-759ff3.png"></p>
<p>从 User 模式调用<code>ECALL</code>异常码等于 8，从 Supervisor 模式调用异常码等于 9，从 Machine 模式调用异常码等于 11。</p>
<p>异常产生时<code>epc</code>寄存器的值存放的是<code>ECALL</code>指令本身的地址。</p>
<blockquote>
<p>如果想触发完异常接着往下执行，需要在异常处理逻辑里把 epc 寄存器值改为下一条指令地址，否则会进入死循环。</p>
</blockquote>
<h2 id="系统调用的执行流程"><a href="#系统调用的执行流程" class="headerlink" title="系统调用的执行流程"></a>系统调用的执行流程</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-33-19-a180df2c96fd165b60b1455fa75521bd-20220830153318-348272.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-45-13-4425120671c06b5cf849f87c25ef7ded-20220830154512-70af22.png"></p>
<h2 id="系统调用的传参"><a href="#系统调用的传参" class="headerlink" title="系统调用的传参"></a>系统调用的传参</h2><p>系统调用作为操作系统的对外接口，由操作系统的实现负责定义。参考 Linux 的系统调用，RVOS 定义系统调用的传参规则如下：</p>
<ul>
<li>系统调用号放在<code>a7</code>中</li>
<li>系统调用参数使用<code>a0-a5</code></li>
<li>返回值使用<code>a0</code></li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-49-21-6db764f87f585532caa83f56319e642a-20220830154920-a8bcc3.png"></p>
<h2 id="系统调用的封装"><a href="#系统调用的封装" class="headerlink" title="系统调用的封装"></a>系统调用的封装</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-54-13-7949945c24c3873b0d2360a1b4ee6edd-20220830155412-895328.png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/08/26/RISC-V%E5%85%A5%E9%97%A8-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E4%B8%8E%E9%94%81/" itemprop="url">RISC-V 入门 - 任务切换与锁</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-08-26T07:15:34.000Z" itemprop="datePublished">8月 26 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/RISC-V-%E5%85%A5%E9%97%A8/">RISC-V 入门</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            15 分钟 lesen (Über 2227 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h1><h2 id="任务简介"><a href="#任务简介" class="headerlink" title="任务简介"></a>任务简介</h2><h3 id="多任务与上下文"><a href="#多任务与上下文" class="headerlink" title="多任务与上下文"></a>多任务与上下文</h3><p>任务就是一个指令执行流。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220826151826.png"></p>
<p>如果有多个 HART，那就可以同时执行多个指令执行流。</p>
<p>协作式多任务</p>
<p>协作式环境下，下一个任务被调度的前提是当前任务主动放弃处理器。</p>
<p>抢占式多任务</p>
<p>抢占式环境下，操作系统完全决定任务调度方案，操作系统可以剥夺当前任务对处理器的使用，将处理器提供给其它任务。</p>
<h2 id="协作式多任务"><a href="#协作式多任务" class="headerlink" title="协作式多任务"></a>协作式多任务</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-09-51-b76ed5f4ea873bd1530963a096aaa8e3-20220828140950-e37c6b.png"></p>
<p>切换过程需要完成：</p>
<ul>
<li>保存上文（保存上一个任务的寄存器信息）</li>
<li>恢复下文（恢复下一个任务的寄存器信息）</li>
</ul>
<p>CPU 中有 32 个寄存器，保存各种状态，在切换过程中我们主要关注两个寄存器：<code>ra(x1) 存放返回地址</code>，<code>mscratch 一个特权寄存器，指向当前处理的任务</code>。</p>
<h3 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h3><p>初始化寄存器，根据调用约定，<code>ra</code>都初始化为任务的第一条指令地址。<code>mscratch</code>开始指向 Task A。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-18-23-20b781289e8722e343e09f63910e5991-20220828141822-f0be20.png"></p>
<p>Task A 稳定执行，当他想要放弃 CPU 时，就会执行 <code>call swithc_to</code>指令。执行<code>call</code>的过程中，就会把当前指令的下一条指令的地址放到 CPU 的<code>ra</code>寄存器。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-21-23-1c9725267e1afd49dcc75e21da78c2e4-20220828142122-246130.png"></p>
<p>接下里跳转到<code>swithc_to</code>函数执行，该函数是切换上下文的核心函数。首先<strong>保存上文</strong>，将 CPU 中的寄存器信息全部保存：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-23-39-71d991190cae709f0135d994f9ccd7e2-20220828142338-67c814.png"></p>
<p><strong>切换</strong><code>mscratch</code>指针到下一个任务 Task B：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-24-41-47c1a159644584da7b435cbc5d7a2e56-20220828142440-398b0f.png"></p>
<p><strong>恢复下文</strong>：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-25-21-b5c57f4cd4d127e11679113987238f06-20220828142520-570733.png"></p>
<p>当<code>swithc_to</code>函数执行到<code>return</code>时，接下来执行的指令就是 CPU 中<code>ra</code>保存的那条指令，也就是地址为<code>j</code>指令，这就是 Task B 的第一条指令，这样就完成了任务的切换。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-28-34-62e744963f90c6a45930b7ec91c4960a-20220828142833-60e64d.png"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="切换核心函数-switch-to"><a href="#切换核心函数-switch-to" class="headerlink" title="切换核心函数 switch_to"></a>切换核心函数 switch_to</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">switch_to:</span><br><span class="line"> csrrw t6, mscratch, t6 # swap t6 and mscratch</span><br><span class="line"> beqz t6, 1f   # Notice: previous task may be NULL</span><br><span class="line"> reg_save t6   # save context of prev task</span><br><span class="line">                        # 把CPU的信息保存到内存</span><br><span class="line"></span><br><span class="line"> # Save the actual t6 register, which we swapped into</span><br><span class="line"> # mscratch</span><br><span class="line"> mv t5, t6  # t5 points to the context of current task</span><br><span class="line"> csrr t6, mscratch # read t6 back from mscratch</span><br><span class="line"> sw t6, 120(t5) # save t6 with t5 as base</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line"> # switch mscratch to point to the context of the next task</span><br><span class="line"> csrw mscratch, a0</span><br><span class="line"></span><br><span class="line"> # Restore all GP registers</span><br><span class="line"> # Use t6 to point to the context of the new task</span><br><span class="line"> mv t6, a0</span><br><span class="line"> reg_restore t6      # 把内存里的信息恢复到CPU</span><br><span class="line"></span><br><span class="line"> # Do actual context switching.</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<h4 id="创建和初始化第一号任务"><a href="#创建和初始化第一号任务" class="headerlink" title="创建和初始化第一号任务"></a>创建和初始化第一号任务</h4><p>使用结构体<code>context</code>保存上下文中寄存器的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line"> <span class="comment">/* ignore x0 */</span></span><br><span class="line"> <span class="keyword">reg_t</span> ra;</span><br><span class="line"> <span class="keyword">reg_t</span> sp;</span><br><span class="line"> <span class="keyword">reg_t</span> gp;</span><br><span class="line"> <span class="keyword">reg_t</span> tp;</span><br><span class="line"> <span class="keyword">reg_t</span> t0;</span><br><span class="line"> <span class="keyword">reg_t</span> t1;</span><br><span class="line"> <span class="keyword">reg_t</span> t2;</span><br><span class="line"> <span class="keyword">reg_t</span> s0;</span><br><span class="line"> <span class="keyword">reg_t</span> s1;</span><br><span class="line"> <span class="keyword">reg_t</span> a0;</span><br><span class="line"> <span class="keyword">reg_t</span> a1;</span><br><span class="line"> <span class="keyword">reg_t</span> a2;</span><br><span class="line"> <span class="keyword">reg_t</span> a3;</span><br><span class="line"> <span class="keyword">reg_t</span> a4;</span><br><span class="line"> <span class="keyword">reg_t</span> a5;</span><br><span class="line"> <span class="keyword">reg_t</span> a6;</span><br><span class="line"> <span class="keyword">reg_t</span> a7;</span><br><span class="line"> <span class="keyword">reg_t</span> s2;</span><br><span class="line"> <span class="keyword">reg_t</span> s3;</span><br><span class="line"> <span class="keyword">reg_t</span> s4;</span><br><span class="line"> <span class="keyword">reg_t</span> s5;</span><br><span class="line"> <span class="keyword">reg_t</span> s6;</span><br><span class="line"> <span class="keyword">reg_t</span> s7;</span><br><span class="line"> <span class="keyword">reg_t</span> s8;</span><br><span class="line"> <span class="keyword">reg_t</span> s9;</span><br><span class="line"> <span class="keyword">reg_t</span> s10;</span><br><span class="line"> <span class="keyword">reg_t</span> s11;</span><br><span class="line"> <span class="keyword">reg_t</span> t3;</span><br><span class="line"> <span class="keyword">reg_t</span> t4;</span><br><span class="line"> <span class="keyword">reg_t</span> t5;</span><br><span class="line"> <span class="keyword">reg_t</span> t6;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 1024</span></span><br><span class="line"><span class="keyword">uint8_t</span> task_stack[STACK_SIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">ctx_task</span>;</span></span><br></pre></td></tr></table></figure>

<p>写一个任务函数，功能就是每隔<code>1000</code> 滴答打印一句话。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user_task0</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> uart_puts(<span class="string">&quot;Task 0: Created!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  uart_puts(<span class="string">&quot;Task 0: Running...\n&quot;</span>);</span><br><span class="line">  task_delay(<span class="number">1000</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化任务，需要初始化栈，并把任务的首地址保存到<code>context</code>的<code>ra</code>寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> w_mscratch(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> ctx_task.sp = (<span class="keyword">reg_t</span>) &amp;task_stack[STACK_SIZE - <span class="number">1</span>];</span><br><span class="line"> ctx_task.ra = (<span class="keyword">reg_t</span>) user_task0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切换到第一个用户任务"><a href="#切换到第一个用户任务" class="headerlink" title="切换到第一个用户任务"></a>切换到第一个用户任务</h4><p><code>switch_to</code>函数的参数就是上下文，当执行到<code>ret</code>时也就切换到了<code>user_task0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">next</span> =</span> &amp;ctx_task;</span><br><span class="line"> switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是单任务的情况，如果是多任务时，就用数组保存多个<code>context</code>，最大支持 10 个任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TASKS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE 1024</span></span><br><span class="line"><span class="keyword">uint8_t</span> task_stack[MAX_TASKS][STACK_SIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">ctx_tasks</span>[<span class="title">MAX_TASKS</span>];</span></span><br></pre></td></tr></table></figure>

<p>使用简单的求模取余的方式确定下一个任务是哪一个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * _top is used to mark the max available position of ctx_tasks</span></span><br><span class="line"><span class="comment"> * _current is used to point to the context of current task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _current = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * implment a simple cycle FIFO schedular</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_top &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  panic(<span class="string">&quot;Num of task should be greater than zero!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> _current = (_current + <span class="number">1</span>) % _top;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">next</span> =</span> &amp;(ctx_tasks[_current]);</span><br><span class="line"> switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为多个任务协作，需要一个函数来表示主动放弃 CPU：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DESCRIPTION</span></span><br><span class="line"><span class="comment"> *  task_yield()  causes the calling task to relinquish the CPU and a new </span></span><br><span class="line"><span class="comment"> *  task gets to run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_yield</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用关系"><a href="#调用关系" class="headerlink" title="调用关系"></a>调用关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/16-43-26-148e18481402d4cbebda0b8cf437ea9a-20220828164325-f03e61.png"></p>
<h2 id="抢占式多任务"><a href="#抢占式多任务" class="headerlink" title="抢占式多任务"></a>抢占式多任务</h2><p>抢占式多任务：抢占式环境下，操作系统完全决定任务调度方案，操作系统可以剥夺当前任务对处理器的使用，将处理器提供给其他任务。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/18-26-19-d09627e0016250e4dd00e93a6d816ccc-20220828182618-7b140d.png"></p>
<p>对 MSIP 写入 1 时触发 软中断，写入 0 时表示对中断进行应答，也就是处理完了软中断。</p>
<h1 id="任务同步与锁"><a href="#任务同步与锁" class="headerlink" title="任务同步与锁"></a>任务同步与锁</h1><h2 id="并发与同步"><a href="#并发与同步" class="headerlink" title="并发与同步"></a>并发与同步</h2><p>并发：多个控制流同时执行</p>
<ul>
<li>多处理器多任务</li>
<li>单处理器多任务</li>
<li>单处理器任务 + 中断</li>
</ul>
<p>同步：为了保证在并发执行的环境中各个控制流可以有效执行而采用的一种编程技术</p>
<h2 id="临界区、锁与死锁"><a href="#临界区、锁与死锁" class="headerlink" title="临界区、锁与死锁"></a>临界区、锁与死锁</h2><p>临界区：在并发的程序执行环境中，所谓临界区指的是一个会访问<strong>共享资源</strong>的<strong>指令片段</strong>，而且当这样的多个指令片段同时访问某个共享资源时可能会引发问题。</p>
<p>在并发环境下为了有效控制临界区的执行（同步），我们要做的是当有一个控制流进入临界区时，其他相关控制流必须等待。</p>
<p>锁：一种常见的用来实现同步的技术</p>
<ul>
<li>不可睡眠锁</li>
<li>可睡眠锁</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/20-20-57-50e42984517b60ca08ec0dff17bc634f-20220828202056-fdd4f5.png"></p>
<p>当发生中断时，右边的任务获取 CPU 资源，开始执行，但是获取锁时发现当前已经处于锁定状态，所以就处于等待状态。</p>
<p>当下一个中断发生，左侧任务回去 CPU 后会继续执行，实际上左侧任务也不必等待，他可以一直执行，因为右侧任务一直无法获取锁。</p>
<p>当然，右侧任务也可以一直触发中断，让左侧任务让出 CPU。也就是左侧任务逻辑上可以一直运行，但是实际还是会被打断。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/20-22-25-783fb565f517c52bef12807070e8c0df-20220828202224-b7ec1e.png"></p>
<p>当左侧任务执行完释放锁，右侧任务就可以获取锁，并正常执行下去。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/20-28-29-39d640fb2c0f9ea420f9d8ceca38c8e2-20220828202828-bb9696.png"></p>
<p>死锁：当控制流执行路径中会涉及多个锁，并且这些控制流执行路径获取的顺序不同时就可能发送死锁。</p>
<p>解决死锁：</p>
<ul>
<li>调整获取锁的顺序，比如保持一致</li>
<li>尽可能防止任务在持有一把锁同时申请其他锁</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/21-27-17-2a3d0048acc7b4a3d63b46b7fd67aa59-20220828212715-480a91.png"></p>
<p>不能从 C 语言的层面去理解锁，应该要从指令级别去理解。上面的这种上锁方式是有问题的。</p>
<p>如果两个控制流同时加锁，就可能同时获取了锁，因为在汇编指令级别，每条指令执行也是需要时间的：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/21-33-11-e1ad7600b03b294097a9fe9b52ac2cd6-20220828213310-65b79a.png"></p>
<p>AMOSWAP</p>
<pre><code class="asm">loop:
    lw a4, -20(s0)  # 参数1
    li a5, 1        # 参数 2
    amoswap.w.aq a5, a5, (a4)   # 将a5与a4指向的内存的值进行交换
                                # 将 1 与 a4 交换，表示如果原来上锁（1）那就什么都没做
                                # 如果原来没上锁（0）那就立即上锁 
    mv a3, a5
    bnez a3,loop

![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/21-38-57-b7cece2166dba14bd128970cefdd2702-20220828213857-b116cd.png)
</code></pre>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2022/08/23/RISC-V%E5%85%A5%E9%97%A8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url">RISC-V 入门 - 内存管理</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-08-23T14:33:11.000Z" itemprop="datePublished">8月 23 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/RISC-V-%E5%85%A5%E9%97%A8/">RISC-V 入门</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            8 分钟 lesen (Über 1230 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>如何计算堆的大小，只有算出可用空间才能对其管理。</p>
<p>ENTRY</p>
<p>功能：用于设置入口点，即程序中执行的第一条指令<br>symbol 参数是一个符号的名称</p>
<p>OUTPUT_ARCH</p>
<p>功能：指定输出文件所适用的计算机体系架构</p>
<blockquote>
<p>为什么用 riscv64-unknown-elf-gcc，但是编译出来的文件是 32 位程序？<br>riscv64 是 host 是 64 位系统，编译 target 是由 gcc 的参数决定</p>
</blockquote>
<p>MEMORY</p>
<p>功能：用于描述目标机器上内存区域的位置，大小和相关</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">MEMORY<br>&#123;<br>    <span class="hljs-comment">/* 内存类型为ROM，起始地址0，长度256K */</span><br>    rom(rx):<span class="hljs-attr">ORIGIN</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">LENGTH</span> = <span class="hljs-number">256</span>K<br>    <span class="hljs-comment">/* 内存类型为RAM，起始地址0x40000000，长度4M */</span><br>    ram(!rx):<span class="hljs-attr">org</span> = <span class="hljs-number">0</span>x40000000, <span class="hljs-attr">l</span> = <span class="hljs-number">4</span>M<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>TODO：括号里的 rx 含义是？</p>
</blockquote>
<p>SECTION</p>
<p>功能：告诉链接器如何将 input sections 映射到 output sections，以及如何将 output sections 放置到内存中。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">SECTION<br>&#123;<br>    <span class="hljs-string">.=0x0000</span>;<br>    <span class="hljs-string">.text</span>:&#123;*<span class="hljs-params">(.text)</span>&#125;<br>    <span class="hljs-string">.=0x8000000</span>;<br>    <span class="hljs-string">.data</span>:&#123;*<span class="hljs-params">(.data)</span>&#125;<br>    <span class="hljs-string">.bss</span>:&#123;*<span class="hljs-params">(.bss)</span>&#125;<br>&#125;&gt;ram<br></code></pre></td></tr></table></figure>

<p>PROVIDE</p>
<p>功能：</p>
<ul>
<li>可以在 Linker Script 中定义符号（Symbols）</li>
<li>每个符号包括一个名字（name) 和一个对应的地址值（address）</li>
<li>在代码中可以访问这些符号，等同于访问一个地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">.bss :&#123;<br> PROVIDE(_bss_start = .);    /* 当前地址赋值给符号_bss_start */<br> *(.sbss .sbss.*)<br> *(.bss .bss.*)<br> *(COMMON)<br> PROVIDE(_bss_end = .);<br>&#125; &gt;ram<br>   PROVIDE(_memory_start = ORIGIN(ram));<br>PROVIDE(_memory_end = ORIGIN(ram) + LENGTH(ram));<br><br>PROVIDE(_heap_start = _bss_end); /* 堆空间就是接在了bss段之后，所以堆开始地址就是bss结束地址 */ <br>PROVIDE(_heap_size = _memory_end - _heap_start); /* 计算堆大小 */ <br></code></pre></td></tr></table></figure>

<p><code>.global</code>表示全局变量，<code>.word</code>表示定义变量，下面的代码就是定义一些全局变量，方便在 C 代码中使用。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">/* mem.S */</span> <br><span class="hljs-meta">.section</span> .rodata<br><span class="hljs-meta">.global</span> HEAP_START<br><span class="hljs-symbol">HEAP_START:</span> <span class="hljs-meta">.word</span> _heap_start<br><br><span class="hljs-meta">.global</span> HEAP_SIZE<br><span class="hljs-symbol">HEAP_SIZE:</span> <span class="hljs-meta">.word</span> _heap_size<br><br><span class="hljs-meta">.global</span> TEXT_START<br><span class="hljs-symbol">TEXT_START:</span> <span class="hljs-meta">.word</span> _text_start<br><br><span class="hljs-meta">.global</span> TEXT_END<br><span class="hljs-symbol">TEXT_END:</span> <span class="hljs-meta">.word</span> _text_end<br><br><span class="hljs-meta">.global</span> DATA_START<br><span class="hljs-symbol">DATA_START:</span> <span class="hljs-meta">.word</span> _data_start<br><br><span class="hljs-meta">.global</span> DATA_END<br><span class="hljs-symbol">DATA_END:</span> <span class="hljs-meta">.word</span> _data_end<br><br><span class="hljs-meta">.global</span> RODATA_START<br><span class="hljs-symbol">RODATA_START:</span> <span class="hljs-meta">.word</span> _rodata_start<br><br><span class="hljs-meta">.global</span> RODATA_END<br><span class="hljs-symbol">RODATA_END:</span> <span class="hljs-meta">.word</span> _rodata_end<br><br><span class="hljs-meta">.global</span> <span class="hljs-keyword">BSS_START</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BSS_START: </span><span class="hljs-meta">.word</span> _bss_start<br><br><span class="hljs-meta">.global</span> <span class="hljs-keyword">BSS_END</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BSS_END: </span><span class="hljs-meta">.word</span> _bss_end<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Following global vars are defined in mem.S</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> TEXT_START;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> TEXT_END;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> DATA_START;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> DATA_END;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> RODATA_START;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> RODATA_END;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> BSS_START;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> BSS_END;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> HEAP_START;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> HEAP_SIZE;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint32_t</span> _num_pages = _num_pages = (HEAP_SIZE / PAGE_SIZE) - <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure>

<p>实现 Page 级别的内存分配与释放</p>
<p>日常使用的操作系统，都是以字节为单位分配空间，但是为了教学方便，RVOS 是以 Page 为单位分配内存。</p>
<p>数据结构设计</p>
<h3 id="数组方式管理"><a href="#数组方式管理" class="headerlink" title="数组方式管理"></a>数组方式管理</h3><p>将内存模拟为一个连续的数组，数组的前部预留 8 个 Page 来管理其余的内存。目前考虑管理的状态有：</p>
<ul>
<li>这 Page 是否被使用了</li>
<li>这个 Page 是不是最后一块分配的内存，方便我们释放内存时找到最后一块分配的内存</li>
</ul>
<p>我们可以使用一个 8 bit 的<code>flag</code>来记录这些信息，<code>flag bit[0]</code>表示是否已使用，<code>flag bit[1]</code>表示是否是最后一个分配的页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Page Descriptor </span><br><span class="hljs-comment"> * flags:</span><br><span class="hljs-comment"> * - bit 0: flag if this page is taken(allocated)</span><br><span class="hljs-comment"> * - bit 1: flag if this page is the last page of the memory block allocated</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br> <span class="hljs-keyword">uint8_t</span> flags;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>也就是每一个 Page 都由一个 8 bit 的结构体<code>struct Page</code>管理，我们总共分配了 8 个 Page 用来管理，一个 Page 占 4K，那么我们可以一个管理$8 \times 4096 = 32768$个 Page。那就刚好可以管理$32768 \times 4096 = 134217728 \text{bit}$内存=128M。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/2022/08/25/19-31-49-8eed060ecd2399b0c7b8bc8dba19ca01-20220825193148-7df975.png"></p>
<p>Page 分配与释放接口设计</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配连续n个可用物理页</span><br><span class="hljs-comment"> * - npages: 需要分配的页的个数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">page_alloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> npages)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">/* Note we are searching the page descriptor bitmaps. */</span><br> <span class="hljs-keyword">int</span> found = <span class="hljs-number">0</span>;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page_i</span> =</span> (struct Page *)HEAP_START;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (_num_pages - npages); i++) &#123;<br>  <span class="hljs-keyword">if</span> (_is_free(page_i)) &#123;<br>   found = <span class="hljs-number">1</span>;<br>   <span class="hljs-comment">/* </span><br><span class="hljs-comment">    * 找到第一个可用Page，继续判断是否有N个连续可用page</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page_j</span> =</span> page_i;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; (i + npages); j++) &#123;<br>    <span class="hljs-keyword">if</span> (!_is_free(page_j)) &#123;<br>     found = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">break</span>;<br>    &#125;<br>    page_j++;<br>   &#125;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 找到了连续的N个可用page，将N个page设置为已分配状态</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">if</span> (found) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page_k</span> =</span> page_i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; (i + npages); k++) &#123;<br>     _set_flag(page_k, PAGE_TAKEN);<br>     page_k++;<br>    &#125;<br>    page_k--;<br>    _set_flag(page_k, PAGE_LAST);<br>                <span class="hljs-comment">// 返回可用page首地址</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)(_alloc_start + i * PAGE_SIZE);<br>   &#125;<br>  &#125;<br>  page_i++;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 释放已分配的物理页</span><br><span class="hljs-comment"> * - p: 待释放的首地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">page_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * 判断非法输入，p不能为空或者超出最大可分配大小</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">if</span> (!p || (<span class="hljs-keyword">uint32_t</span>)p &gt;= _alloc_end) &#123;<br>  <span class="hljs-keyword">return</span>;<br> &#125;<br> <span class="hljs-comment">/* 计算出这个首地址p所在的page的描述符，也就是找到第几个描述符在管理这块内存 */</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> (struct Page *)HEAP_START;<br> page += ((<span class="hljs-keyword">uint32_t</span>)p - _alloc_start)/ PAGE_SIZE;<br> <span class="hljs-comment">/* 循环清空标识 */</span><br> <span class="hljs-keyword">while</span> (!_is_free(page)) &#123;<br>  <span class="hljs-keyword">if</span> (_is_last(page)) &#123;<br>   _clear(page);<br>   <span class="hljs-keyword">break</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>   _clear(page);<br>   page++;;<br>  &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/12/30/RISC-V%E5%85%A5%E9%97%A8-Trap%E5%92%8CException/" itemprop="url">RISC-V 入门-Trap</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-12-30T05:42:34.000Z" itemprop="datePublished">12月 30 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/RISC-V-%E5%85%A5%E9%97%A8/">RISC-V 入门</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            26 分钟 lesen (Über 3935 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="Trap-简介"><a href="#Trap-简介" class="headerlink" title="Trap 简介"></a>Trap 简介</h1><h2 id="控制流（Control-Flow）和-Trap"><a href="#控制流（Control-Flow）和-Trap" class="headerlink" title="控制流（Control Flow）和 Trap"></a>控制流（Control Flow）和 Trap</h2><ul>
<li>控制流（Control Flow）<br>从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列<br>$$a_0,a_1,\dotsb,a_{n-1}$$<br>每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。</li>
<li>异常控制流（Exceptional Control Flow, ECF）<br>系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。<ul>
<li>exception</li>
<li>interrupt</li>
</ul>
</li>
</ul>
<p>RISC-V 把 <code>ECF</code> 统称为 <code>Trap</code>。</p>
<h2 id="RISC-V-Trap-处理中涉及的寄存器"><a href="#RISC-V-Trap-处理中涉及的寄存器" class="headerlink" title="RISC-V Trap 处理中涉及的寄存器"></a>RISC-V Trap 处理中涉及的寄存器</h2><table>
<thead>
<tr>
<th align="center">寄存器</th>
<th align="center">全称</th>
<th align="left">用途说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mtvec</td>
<td align="center">Machine Trap-Vector Base-Address</td>
<td align="left">它保存发生异常时处理器需要跳转到的地址。</td>
</tr>
<tr>
<td align="center">mepc</td>
<td align="center">Machine Exception Program Counter</td>
<td align="left">当 trap 发生时，hart 会将发生 trap 所对应的指令的地址值（pc）保存在 mepc 中。</td>
</tr>
<tr>
<td align="center">mcause</td>
<td align="center">Machine Cause</td>
<td align="left">当 trap 发生时，hart 会设置该寄存器通知我们 trap 发生的原因。</td>
</tr>
<tr>
<td align="center">mtval</td>
<td align="center">Machine Trap Value</td>
<td align="left">它保存了 exception 发生时的附加信息：譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身，对于其他异常，它的值为 0。</td>
</tr>
<tr>
<td align="center">mstatus</td>
<td align="center">Machine Status</td>
<td align="left">用于跟踪和控制 hart 的当前操作状态（特别地，包括关闭和打开全局中断）。</td>
</tr>
<tr>
<td align="center">mscratch</td>
<td align="center">Machine Scratch</td>
<td align="left">Machine 模式下专用寄存器，我们可以自己定义其用法，譬如用该寄存器保存当前在 hart 上运行的 task 的上下文（context）的地址。</td>
</tr>
</tbody></table>
<h3 id="mtvec（Machine-Trap-Vector-Base-Address）"><a href="#mtvec（Machine-Trap-Vector-Base-Address）" class="headerlink" title="mtvec（Machine Trap-Vector Base-Address）"></a>mtvec（Machine Trap-Vector Base-Address）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104173734.png"></p>
<blockquote>
<p>WARL: Write Any Values, Read Legal Values</p>
</blockquote>
<ul>
<li><p>BASE：trap 入口函数的基地址，必须保证四字节对齐；</p>
</li>
<li><p>MODE：进一步用于控制入口函数的地址配置方式：</p>
<ul>
<li><p>Direct，所有异常和中断发生后，PC都跳转到BASE指定的地址处；</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201041945310.png"></p>
<p>通常中断处理函数内部会有<code>switch case</code>条件语句，通过不同的中断采用不同的处理方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">reg_t</span> <span class="hljs-title">trap_handler</span><span class="hljs-params">(<span class="hljs-keyword">reg_t</span> epc, <span class="hljs-keyword">reg_t</span> cause)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">reg_t</span> return_pc = epc;<br>    <span class="hljs-keyword">reg_t</span> cause_code = cause &amp; <span class="hljs-number">0xfff</span>;<br>    <br>    <span class="hljs-keyword">if</span> (cause &amp; <span class="hljs-number">0x80000000</span>) &#123;<br>        <span class="hljs-comment">/* Asynchronous trap - interrupt */</span><br>        <span class="hljs-keyword">switch</span> (cause_code) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            uart_puts(<span class="hljs-string">&quot;software interruption!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>            uart_puts(<span class="hljs-string">&quot;timer interruption!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:<br>            uart_puts(<span class="hljs-string">&quot;external interruption!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            uart_puts(<span class="hljs-string">&quot;unknown async exception!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Synchronous trap - exception */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sync exceptions!, code = %d\n&quot;</span>, cause_code);<br>        panic(<span class="hljs-string">&quot;OOPS! What can I do!&quot;</span>);<br>        <span class="hljs-comment">//return_pc += 4;</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> return_pc;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Vectored，异常的处理方式同上，但是中断的入口地址以数组方式排列；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asm">trap_vector:<br>    # save context(registers).<br>    csrrw t6, mscratch, t6 # swap t6 and mscratch<br>    reg_save t6<br><br>    # Save the actual t6 register, which we swapped into<br>    # mscratch<br>    mv t5, t6  # t5 points to the context of current task<br>    csrr t6, mscratch # read t6 back from mscratch<br>    sw t6, 120(t5) # save t6 with t5 as base<br><br>    # Restore the context pointer into mscratch<br>    csrw mscratch, t5<br><br>    # call the C trap handler in trap.c<br>    csrr a0, mepc<br>    csrr a1, mcause<br>    call trap_handler<br><br>    # trap_handler will return the return address via a0.<br>    csrw mepc, a0<br><br>    # restore context(registers).<br>    csrr t6, mscratch<br>    reg_restore t6<br><br>    # return to whatever we were doing before trap.<br>    mret<br></code></pre></td></tr></table></figure>

<p>MODE可取值如下：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104174219.png"></p>
</li>
</ul>
</li>
</ul>
<p>采用<code>Vectored</code>方式效率更高。</p>
<h3 id="mepc（Machine-Exception-Program-Counter）"><a href="#mepc（Machine-Exception-Program-Counter）" class="headerlink" title="mepc（Machine Exception Program Counter）"></a>mepc（Machine Exception Program Counter）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201041958237.png"></p>
<p>当<code>trap</code>发生时，<code>pc</code>会被替换为 <code>mtvec</code>设定的地址，同时<code>hart</code> 会设置<code>mepc</code>为当前指令或者下一条指令的地址（处理异常时，mepc 为当前指令的地址，处理中断时，mepc 为下一条指令的地址）。</p>
<p>当我们需要退出<code>trap</code> 时可以调用特殊的 <code>mret</code> 指令，该指令会将<code>mepc</code>中的值恢复到<code>pc</code>中（实现返回的效果）；</p>
<p>在处理 <code>trap</code> 的程序中我们可以修改 <code>mepc</code> 的值达到改变<code>mret</code> 返回地址的目的。</p>
<h3 id="mcause（Machine-Cause）"><a href="#mcause（Machine-Cause）" class="headerlink" title="mcause（Machine Cause）"></a>mcause（Machine Cause）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042012549.png"></p>
<p>当 <code>trap</code> 发生时，<code>hart</code> 会设置该寄存器通知我们 <code>trap</code> 发生的原因。</p>
<p>最高位 <code>Interrupt</code> 为 1 时标识了当前 <code>trap</code> 为<code>interrupt</code>，否则是<code>exception</code>。</p>
<p>剩余的 <code>Exception Code</code> 用于标识具体的<code>interrupt</code>或者<code>exception</code> 的种类。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042014689.png"></p>
<h3 id="mtval（Machine-Trap-Value）"><a href="#mtval（Machine-Trap-Value）" class="headerlink" title="mtval（Machine Trap Value）"></a>mtval（Machine Trap Value）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042016744.png"></p>
<p>当 <code>trap</code> 发生时，除了通过<code>mcause</code> 可以获取<code>exception</code>的种类 <code>code</code> 值外，<code>hart</code> 还提供了 <code>mtval</code> 来提供<code>exception</code> 的其他信息来辅助我们执行更进一步的操作。</p>
<p>具体的辅助信息由特定的硬件实现定义，RISC-V 规范没有定义具体的值。但规范定义了一些行为，譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身等。</p>
<h3 id="mstatus（Machine-Status）"><a href="#mstatus（Machine-Status）" class="headerlink" title="mstatus（Machine Status）"></a>mstatus（Machine Status）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042020644.png"></p>
<p>寄存器各个位可以大致分为以下三类，其中<code>x</code>可以为<code>U,S,M</code>。表示用户模式以及两种特权模式。</p>
<ul>
<li><p><code>xIE</code>（x=M/S/U）: 分别用于打开（1）或者关闭（0）M/S/U 模式下的全局中断。当 <code>trap</code> 发生时，<code>hart</code>会自动将 <code>xIE</code> 设置为 0。</p>
</li>
<li><p><code>xPIE</code>（x=M/S/U）:当 <code>trap</code> 发生时用于保存 <code>trap</code> 发生之前的 <code>xIE</code> 值。</p>
</li>
<li><p><code>xPP</code>（x=M/S）:当 <code>trap</code> 发生时用于保存 <code>trap</code> 发生之前的权限级别值。注意没有 <code>UPP</code>。因为异常只会从低权限向高权限跳转，通常低权限如<code>user</code>模式，会被置于上方，高权限如内核一般都会画在下方，这也解释了异常，中断处理为什么叫<code>trap</code>，因为是向下陷入的过程。</p>
</li>
<li><p>其他标志位涉及内存访问权限、虚拟内存控制等，暂不考虑。</p>
</li>
</ul>
<h2 id="Trap-处理流程"><a href="#Trap-处理流程" class="headerlink" title="Trap 处理流程"></a>Trap 处理流程</h2><blockquote>
<p>主要为 Exception，下一章详解 Interrupt。</p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将<code>trap</code>的基地址写入寄存器，</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042053570.png"></p>
<h3 id="Top-Half"><a href="#Top-Half" class="headerlink" title="Top Half"></a>Top Half</h3><ol>
<li>把 <code>mstatus</code> 的 <code>MIE</code> 值复制到 <code>MPIE</code> 中，清除 <code>mstatus</code>中的 <code>MIE</code> 标志位，效果是中断被禁止。</li>
<li>设置<code>mepc</code>，同时<code>PC</code>被设置为 <code>mtvec</code>。（需要注意的是，对于<code>exception</code>， <code>mepc</code>指向导致异常的指令；对于 <code>interrupt</code>，它指向被中断的指令的下一条指令的位置。）</li>
<li>根据 <code>trap</code> 的种类设置 <code>mcause</code>，并根据需要为<code>mtval</code>设置附加信息。</li>
<li>将 <code>trap</code> 发生之前的权限模式保存在 <code>mstatus</code> 的 <code>MPP</code> 域中，再把<code>hart</code> 权限模式更改为 <code>M</code>（也就是说无论在任何 <code>Level</code> 下触发<code>trap</code>，<code>hart</code> 首先切换到 <code>Machine</code> 模式）。</li>
</ol>
<h3 id="Bottom-Half"><a href="#Bottom-Half" class="headerlink" title="Bottom Half"></a>Bottom Half</h3><ol>
<li>保存（save）当前控制流的上下文信息（利用 <code>mscratch</code>）；</li>
<li>调用 C 语言的 <code>trap handler</code>;</li>
<li>从 <code>trap handler</code> 函数返回，<code>mepc</code>的值有可能需要调整；</li>
<li>恢复（restore）上下文的信息；</li>
<li>执行<code>MRET</code>指令返回到 <code>trap</code>之前的状态。</li>
</ol>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">trap_vector</span>:<br> <span class="hljs-comment"># save context(registers).</span><br> <span class="hljs-attribute">csrrw</span> t<span class="hljs-number">6</span>, mscratch, t<span class="hljs-number">6</span> # swap t<span class="hljs-number">6</span> and mscratch<br> <span class="hljs-attribute">reg_save</span> t<span class="hljs-number">6</span><br><br> <span class="hljs-comment"># Save the actual t6 register, which we swapped into</span><br> <span class="hljs-comment"># mscratch</span><br> <span class="hljs-attribute">mv</span> t<span class="hljs-number">5</span>, t<span class="hljs-number">6</span>  # t<span class="hljs-number">5</span> points to the context of current task<br> <span class="hljs-attribute">csrr</span> t<span class="hljs-number">6</span>, mscratch # read t<span class="hljs-number">6</span> back from mscratch<br> <span class="hljs-attribute">sw</span> t<span class="hljs-number">6</span>, <span class="hljs-number">120</span>(t<span class="hljs-number">5</span>) # save t<span class="hljs-number">6</span> with t<span class="hljs-number">5</span> as base<br><br> <span class="hljs-comment"># Restore the context pointer into mscratch</span><br> <span class="hljs-attribute">csrw</span> mscratch, t<span class="hljs-number">5</span><br><br> <span class="hljs-comment"># call the C trap handler in trap.c</span><br> <span class="hljs-attribute">csrr</span> a<span class="hljs-number">0</span>, mepc<br> <span class="hljs-attribute">csrr</span> a<span class="hljs-number">1</span>, mcause<br> <span class="hljs-attribute">call</span> trap_handler<br><br> <span class="hljs-comment"># trap_handler will return the return address via a0.</span><br> <span class="hljs-attribute">csrw</span> mepc, a<span class="hljs-number">0</span><br><br> <span class="hljs-comment"># restore context(registers).</span><br> <span class="hljs-attribute">csrr</span> t<span class="hljs-number">6</span>, mscratch<br> <span class="hljs-attribute">reg_restore</span> t<span class="hljs-number">6</span><br><br> <span class="hljs-comment"># return to whatever we were doing before trap.</span><br> <span class="hljs-attribute">mret</span><br></code></pre></td></tr></table></figure>

<h3 id="退出-trap：编程调用-MRET-指令"><a href="#退出-trap：编程调用-MRET-指令" class="headerlink" title="退出 trap：编程调用 MRET 指令"></a>退出 trap：编程调用 MRET 指令</h3><p>针对不同权限级别下如何退出 trap 有各自的返回指令<code>xRET</code>（x = M/S/U）。以在 <code>M</code> 模式下执行<code>mret</code> 指令为例，会执行如下操作：</p>
<ul>
<li>当前 <code>Hart 的权限级别 = mstatus.MPP</code>；<code>mstatus.MPP = U</code>（如果 hart 不支持 U 则为 M）</li>
<li><code>mstatus.MIE = mstatus.MPIE</code>; <code>mstatus.MPIE = 1</code></li>
<li><code>pc = mepc</code></li>
</ul>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><ul>
<li><p>本地（Local）中断</p>
<ul>
<li>软中断software interrupt</li>
<li>定时器中断 timer interrupt</li>
</ul>
</li>
<li><p>全局（Global）中断</p>
<ul>
<li>外部中断 externel interrupt</li>
</ul>
</li>
</ul>
<h2 id="RISC-V-中断编程中涉及的寄存器"><a href="#RISC-V-中断编程中涉及的寄存器" class="headerlink" title="RISC-V 中断编程中涉及的寄存器"></a>RISC-V 中断编程中涉及的寄存器</h2><table>
<thead>
<tr>
<th align="center">寄存器</th>
<th align="center">全称</th>
<th align="left">用途说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mie</td>
<td align="center">Machine Interrupt Enable</td>
<td align="left">用于进一步控制（打开和关闭）software interrupt/timer interrupt/external interrupt</td>
</tr>
<tr>
<td align="center">mip</td>
<td align="center">Machine Interrupt Pending</td>
<td align="left">它列出目前已发生等待处理的中断。</td>
</tr>
</tbody></table>
<h3 id="mie-Machine-Interrupt-Enable"><a href="#mie-Machine-Interrupt-Enable" class="headerlink" title="mie(Machine Interrupt Enable)"></a>mie(Machine Interrupt Enable)</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042159268.png"></p>
<p>打开（1）或者关闭（0）M/S/U 模式下对应的 External/Timer/Software 中断。</p>
<h3 id="mip-Machine-Interrupt-Pending"><a href="#mip-Machine-Interrupt-Pending" class="headerlink" title="mip(Machine Interrupt Pending)"></a>mip(Machine Interrupt Pending)</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042200772.png"></p>
<p>获取当前 M/S/U 模式下对应的 External/Timer/Software 中断是否发生。</p>
<h2 id="中断处理流程"><a href="#中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程</h2><h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><ol>
<li>把 <code>mstatus</code> 的 <code>MIE</code> 值复制到 <code>MPIE</code> 中，清除 <code>mstatus</code> 中的 MIE 标志位，效果是中断被禁止。</li>
<li>当前的 <code>PC</code> 的下一条指令地址被复制到 <code>mepc</code> 中，同时 <code>PC</code> 被设置为<code>mtvec</code>。注意如果我们设置 <code>mtvec.MODE = vetcored</code>，<code>PC =mtvec.BASE + 4 × exception-code</code>。</li>
<li>根据 <code>interrupt</code> 的种类设置 <code>mcause</code>，并根据需要为 <code>mtval</code> 设置附加信息。</li>
<li>将 <code>trap</code> 发生之前的权限模式保存在 <code>mstatus</code> 的 <code>MPP</code> 域中，再把<code>hart</code> 权限模式更改为 <code>M</code>。</li>
</ol>
<h3 id="退出中断"><a href="#退出中断" class="headerlink" title="退出中断"></a>退出中断</h3><p>以在 M 模式下执行 mret 指令为例，会执行如下操作：</p>
<ul>
<li>当前 Hart 的权限级别 = mstatus.MPP; mstatus.MPP= U（如果 hart 不支持 U 则为 M）</li>
<li>mstatus.MIE = mstatus.MPIE; mstatus.MPIE = 1</li>
<li>pc = mepc</li>
</ul>
<h1 id="PLIC（Platform-Level-Interrupt-Controller）"><a href="#PLIC（Platform-Level-Interrupt-Controller）" class="headerlink" title="PLIC（Platform-Level Interrupt Controller）"></a>PLIC（Platform-Level Interrupt Controller）</h1><h2 id="PLIC-简介"><a href="#PLIC-简介" class="headerlink" title="PLIC 简介"></a>PLIC 简介</h2><p>HART 只能处理一个中断，PLIC 相当于一个控制中心，它通过中断类型，优先级等等来选出一个需要处理的中断。协调多个中断，服务一个 HART。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042206664.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART0_IRQ = <span class="hljs-number">10</span>, <span class="hljs-comment">//Interrupt Source ID</span><br>    RTC_IRQ = <span class="hljs-number">11</span>,<br>    VIRTIO_IRQ = <span class="hljs-number">1</span>, <span class="hljs-comment">/* 1 to 8 */</span><br>    VIRTIO_COUNT = <span class="hljs-number">8</span>, <br>    PCIE_IRQ = <span class="hljs-number">0x20</span>, <span class="hljs-comment">/* 32 to 35 */</span><br>    VIRTIO_NDEV = <span class="hljs-number">0x35</span> <span class="hljs-comment">/* Arbitrary maximum number of interrupts */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>Interrupt Source ID 范围：1 ~ 53（0x35）</li>
<li>0 预留不用</li>
</ul>
<p><code>PLIC</code>本身也是一个外设，RISC-V 规范规定，<code>PLIC</code> 的寄存器编址采用内存映射（memory map）方式。每个寄存器的宽度为 32-bit。</p>
<p>具体寄存器编址采用 <code>base + offset</code> 的格式，且 <code>base</code> 由各个特定<code>platform</code> 自己定义。针对 <code>QEMU-virt</code>，其 <code>PLIC</code> 的设计参考了<code>FU540-C000</code>，<code>base</code> 为 <code>0x0c000000</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> MemMapEntry virt_memmap[] = &#123;<br>    [VIRT_DEBUG] =       &#123;        <span class="hljs-number">0x0</span>,         <span class="hljs-number">0x100</span> &#125;,<br>    [VIRT_MROM] =        &#123;     <span class="hljs-number">0x1000</span>,        <span class="hljs-number">0xf000</span> &#125;,<br>    [VIRT_TEST] =        &#123;   <span class="hljs-number">0x100000</span>,        <span class="hljs-number">0x1000</span> &#125;,<br>    [VIRT_RTC] =         &#123;   <span class="hljs-number">0x101000</span>,        <span class="hljs-number">0x1000</span> &#125;,<br>    [VIRT_CLINT] =       &#123;  <span class="hljs-number">0x2000000</span>,       <span class="hljs-number">0x10000</span> &#125;,<br>    [VIRT_ACLINT_SSWI] = &#123;  <span class="hljs-number">0x2F00000</span>,        <span class="hljs-number">0x4000</span> &#125;,<br>    [VIRT_PCIE_PIO] =    &#123;  <span class="hljs-number">0x3000000</span>,       <span class="hljs-number">0x10000</span> &#125;,<br>    [VIRT_PLIC] =        &#123;  <span class="hljs-number">0xc000000</span>, VIRT_PLIC_SIZE(VIRT_CPUS_MAX * <span class="hljs-number">2</span>) &#125;,<br>    [VIRT_UART0] =       &#123; <span class="hljs-number">0x10000000</span>,         <span class="hljs-number">0x100</span> &#125;,<br>    [VIRT_VIRTIO] =      &#123; <span class="hljs-number">0x10001000</span>,        <span class="hljs-number">0x1000</span> &#125;,<br>    [VIRT_FW_CFG] =      &#123; <span class="hljs-number">0x10100000</span>,          <span class="hljs-number">0x18</span> &#125;,<br>    [VIRT_FLASH] =       &#123; <span class="hljs-number">0x20000000</span>,     <span class="hljs-number">0x4000000</span> &#125;,<br>    [VIRT_PCIE_ECAM] =   &#123; <span class="hljs-number">0x30000000</span>,    <span class="hljs-number">0x10000000</span> &#125;,<br>    [VIRT_PCIE_MMIO] =   &#123; <span class="hljs-number">0x40000000</span>,    <span class="hljs-number">0x40000000</span> &#125;,<br>    [VIRT_DRAM] =        &#123; <span class="hljs-number">0x80000000</span>,           <span class="hljs-number">0x0</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="PLIC-编程接口-寄存器"><a href="#PLIC-编程接口-寄存器" class="headerlink" title="PLIC 编程接口 - 寄存器"></a>PLIC 编程接口 - 寄存器</h2><h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><p>功能：设置某一路中断源的优先级<br>内存映射地址：<code>BASE + (interrupt-id) * 4</code></p>
<ul>
<li>每个 <code>PLIC</code> 中断源对应一个寄存器，用于配置该中断源的优先级。</li>
<li><code>QEMU-virt</code> 支持 7 个优先级。0 表示对该中断源禁用中断。其余优先级，1 最低，7 最高。</li>
<li>如果两个中断源优先级相同，则根据中断源的 ID 值进一步区分优先级，ID 值越小的优先级越高。</li>
</ul>
<h3 id="Pending"><a href="#Pending" class="headerlink" title="Pending"></a>Pending</h3><p>功能：用于指示某一路中断源是否发生<br>内存映射地址：<code>BASE + 0x1000 + ((interrupt-id) / 32) * 4</code></p>
<ul>
<li>每个 <code>PLIC</code> 包含 2 个 32 位的 <code>Pending</code> 寄存器，因为总共有 54 个中断源，每一个 <code>bit</code> 对应一个中断源，如果为 1 表示该中断源上发生了中断（进入<code>Pending</code> 状态），有待 <code>hart</code> 处理，否则表示该中断源上当前无中断发生。</li>
<li><code>Pending</code> 寄存器中断的 <code>Pending</code> 状态可以通过<code>claim</code> 方式清除。</li>
<li>第一个 <code>Pending</code> 寄存器的第 0 位对应不存在的 0 号中断源，其值永远为 0。</li>
</ul>
<h3 id="Enable"><a href="#Enable" class="headerlink" title="Enable"></a>Enable</h3><p>功能：针对某个 <code>hart</code> 开启或者关闭某一路中断源<br>内存映射地址：<code>BASE + 0x2000 + (hart) * 0x80</code></p>
<ul>
<li>每个 <code>Hart</code> 有 2 个 <code>Enable</code> 寄存器（<code>Enable1</code> 和 <code>Enable2</code>）用于针对该<code>Hart</code> 启动或者关闭某路中断源。</li>
<li>每个中断源对应 <code>Enable</code> 寄存器的一个 <code>bit</code>，其中<code>Enable1</code> 负责控制 1 ~ 31 号中断源；<code>Enable2</code> 负责控制 <code>32 ~ 53</code> 号中断源。将对应的 <code>bit</code> 位设置为 1 表示使能该中断源，否则表示关闭该中断源。</li>
</ul>
<h3 id="Threshold"><a href="#Threshold" class="headerlink" title="Threshold"></a>Threshold</h3><p>功能：针对某个 hart 设置中断源优先级的阈值<br>内存映射地址：<code>BASE + 0x200000 + (hart) * 0x1000</code></p>
<ul>
<li>每个 <code>Hart</code> 有 1 个 <code>Threshold</code> 寄存器用于设置中断优先级的阈值。</li>
<li>所有小于或者等于（&lt;=）该阈值的中断源即使发生了也会被 <code>PLIC</code> 丢弃。特别地，当阈值为 0 时允许所有中断源上发生的中断；当阈值为 7 时丢弃所有中断源上发生的中断。</li>
</ul>
<h3 id="Claim-Complete"><a href="#Claim-Complete" class="headerlink" title="Claim/Complete"></a>Claim/Complete</h3><p>功能：如下<br>内存映射地址：<code>BASE + 0x200004 + (hart) * 0x1000</code></p>
<ul>
<li><code>Claim</code> 和 <code>Complete</code> 是同一个寄存器，每个 <code>Hart</code> 一个。</li>
<li>对该寄存器执行读操作称之为 <code>Claim</code>，即获取当前发生的最高优先级的中断源<code>ID</code>。<code>Claim</code> 成功后会清除对应的 <code>Pending</code> 位。</li>
<li>对该寄存器执行写操作称之为 <code>Complete</code>。所谓 <code>Complete</code>指的是通知<code>PLIC</code> 对该路中断的处理已经结束。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">external_interrupt_handler</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">int</span> irq = plic_claim(); <span class="hljs-comment">//</span><br><br> <span class="hljs-keyword">if</span> (irq == UART0_IRQ)&#123;<br>        uart_isr();<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (irq) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unexpected interrupt irq = %d\n&quot;</span>, irq);<br> &#125;<br> <br> <span class="hljs-keyword">if</span> (irq) &#123;<br>  plic_complete(irq); <span class="hljs-comment">//</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/17-56-05-db617fc7aad1c476c3c38e4ee44a770b-20220828175604-f9d5e6.png"></p>
<h1 id="CLINT-（Core-Local-INTerruptor）"><a href="#CLINT-（Core-Local-INTerruptor）" class="headerlink" title="CLINT （Core Local INTerruptor）"></a>CLINT （Core Local INTerruptor）</h1><p>定时器中断，属于本地中断的一种，由芯片内部<code>CLINT</code>设备产生的中断。</p>
<ul>
<li>RISC-V 规范规定，CLINT 的寄存器编址采用内存映射（memory map）方式。</li>
<li>具体寄存器编址采用<code>base + offset</code>的格式，且 <code>base</code> 由各个特定 <code>platform</code> 自己定义。针对 <code>QEMU-virt</code>，其 CLINT 的设计参考了 <code>SFIVE</code>，<code>base</code> 为 <code>0x2000000</code>。</li>
</ul>
<h2 id="CLINT-编程接口-寄存器-Timer-部分"><a href="#CLINT-编程接口-寄存器-Timer-部分" class="headerlink" title="CLINT 编程接口 - 寄存器 (Timer 部分)"></a>CLINT 编程接口 - 寄存器 (Timer 部分)</h2><h3 id="mtime"><a href="#mtime" class="headerlink" title="mtime"></a>mtime</h3><p>功能：<code>real-time</code> 计数器（counter）<br>内存映射地址：<code>BASE + 0xbff8</code></p>
<ul>
<li>由晶振产生，系统全局唯一，在 <code>RV32</code> 和 <code>RV64</code> 上都是 64-bit。系统必须保证该计数器的值始终按照一个固定的频率递增。</li>
<li>上电复位时，硬件负责将 <code>mtime</code> 的值恢复为 0。</li>
</ul>
<h3 id="mtimecmp"><a href="#mtimecmp" class="headerlink" title="mtimecmp"></a>mtimecmp</h3><p>功能：定时器比较寄存器<br>内存映射地址：<code>BASE + 0x4000 + (hart) * 8)</code></p>
<ul>
<li><p>每个 <code>hart</code> 一个 <code>mtimecmp</code> 寄存器，64-bit。</p>
</li>
<li><p>上电复位时，系统不负责设置 mt`imecmp 的初值。</p>
</li>
<li><p>当<code>mtime &gt;= mtimecmp</code> 时，<code>CLINT</code> 会产生一个 <code>timer</code> 中断。如果要使能该中断需要保证全局中断打开并且<code>mie.MTIE</code> 标志位置 <code>1</code>。</p>
</li>
<li><p>当 <code>timer</code> 中断发生时，<code>hart</code> 会设置 <code>mip.MTIP</code>，程序可以在 <code>mtimecmp</code> 中写入新的值清除<code>mip.MTIP</code>。</p>
</li>
</ul>
<h2 id="时钟节拍-tick"><a href="#时钟节拍-tick" class="headerlink" title="时钟节拍 tick"></a>时钟节拍 tick</h2><ul>
<li>操作系统中最小的时间单位；</li>
<li><code>Tick</code> 的单位（周期）由硬件定时器的周期决定<br>（通常为 1 ~ 100ms）；</li>
<li><code>Tick</code> 周期越小，也就是<code>1s</code>内产生的中断越多，系统的精度越高，但开销越大。</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/10/20/RISC-V%E5%85%A5%E9%97%A8-RVOS%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/" itemprop="url">RISC-V 入门-RVOS 系统引导</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-10-20T15:13:40.000Z" itemprop="datePublished">10月 20 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/RISC-V-%E5%85%A5%E9%97%A8/">RISC-V 入门</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            11 分钟 lesen (Über 1700 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="操作系统定义与分类"><a href="#操作系统定义与分类" class="headerlink" title="操作系统定义与分类"></a>操作系统定义与分类</h2><p>操作系统（英语：Operating System，缩写：OS）是一组系统软件程序，狭义上就是内核如 Linux，广义上就是内核加一组软件组成的发行包，如 Ubuntu，Debian：  </p>
<p>• 主管并控制计算机操作、运用和运行硬件、软件资源  </p>
<p>• 提供公共服务来组织用户交互。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816201351.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816201945.png"></p>
<h2 id="硬件的基本概念"><a href="#硬件的基本概念" class="headerlink" title="硬件的基本概念"></a>硬件的基本概念</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202320868.png"></p>
<ul>
<li>Hart</li>
<li>Platform<br>不能说是个板子，应该理解为芯片。早期的板子就是一块芯片加上各种外设，但是随着技术发展，板子越来越小，外设却并没有变少，是因为外设都被集成到了芯片中。当所有外设都被集成，那么芯片就是 platform。</li>
<li>SoC(System on Chip)<br>片上系统</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202328649.png"></p>
<p>QEMU 模拟 virt 这个平台，这个平台有八个 Hart。</p>
<h2 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202331403.png"></p>
<p>为了方便访问外设，现在主流的 platform 会对外设的内存地址做一个映射。映射到 platform 的真实物理地址。对真实物理地址进行操作时，就是对外设的地址进行操作。</p>
<p>物理地址从最低位到最高位都被分配给了各种外设。</p>
<h2 id="引导过程介绍"><a href="#引导过程介绍" class="headerlink" title="引导过程介绍"></a>引导过程介绍</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202342918.png"></p>
<p>通电后，会先到箭头所指的地址，这个地址就是对应的 ROM 外设首地址。ROM 相当于一个小硬盘，断电后不会丢失数据。这里面固化了一些指令。</p>
<p>主要就是跳转指令，运行到 kernel 段继续执行。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212317389.png"></p>
<p>八核同时会执行这个过程。</p>
<p>以上是硬件的部分过程，软件该如何写？</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212320524.png"></p>
<p>为了简化学习流程和降低调试难度，目前只支持单核，其余七个核处于空转状态。</p>
<h3 id="如何判断当前-Hart-是不是第一个？"><a href="#如何判断当前-Hart-是不是第一个？" class="headerlink" title="如何判断当前 Hart 是不是第一个？"></a>如何判断当前 Hart 是不是第一个？</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212323556.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212325328.png"></p>
<p>这些寄存器必须使用以下的指令读写：</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212325081.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212327552.png"></p>
<p>以上指令就是将寄存器值进行一次<strong>交换</strong>，只不过这个过程是原子性的，不能被打断。</p>
<p><code>CSRRW</code>经常会用在伪指令<code>CSRW</code>中，完整指令中，第一步向<code>x0</code>写入数据，就是空操作，第二步将<code>rs</code>写入<code>csr</code>。这个伪指令就是完成了一个写入<code>csr</code>的操作。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212333753.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212335906.png"></p>
<p><code>mhartid</code>就是<code>machine hart id</code>。</p>
<p>学习以上几个指令，就可以完成判断 hart 是否为第一个的工作了，</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212337619.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">csrr t0, mhartid    #读寄存器值<br>mv tp, t0           #<br>bnez t0, park       # 跳转指令，不等于 0 就跳转到 park 标签<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 6502">wfi<br>休眠指令<br></code></pre></td></tr></table></figure>

<h3 id="如何初始化栈空间"><a href="#如何初始化栈空间" class="headerlink" title="如何初始化栈空间"></a>如何初始化栈空间</h3><h3 id="如何跳转到-C-语言环境"><a href="#如何跳转到-C-语言环境" class="headerlink" title="如何跳转到 C 语言环境"></a>如何跳转到 C 语言环境</h3><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs 6502"># start.S<br>#include &quot;platform.h&quot;<br><br>    # size of each hart&#x27;s stack is 1024 bytes<br>    .equ    STACK_SIZE, 1024<br><br>    .global    _start<br><br>    .text<br>_start:<br>    # park harts with id != 0<br>    csrr    t0, mhartid     # read current hart id<br>    mv      tp, t0          # keep CPU&#x27;s hartid in its tp for later usage.<br>    bnez    t0, park        # if we&#x27;re not on the hart 0<br>                            # we park the hart<br>    # Setup stacks, the stack grows from bottom to top, so we put the<br>    # stack pointer to the very end of the stack range.<br>    slli    t0, t0, 10      # shift left the hart id by 1024<br><br>    ###### 初始化栈空间 ######<br>    # set the initial stack pointer to the end of the first stack space<br>    la      sp, stacks + STACK_SIZE    <br>    # move the current hart stack pointer to its place in the stack space<br>    add     sp, sp, t0       <br>    ###### 初始化栈空间  ######<br>    <br>    ###### 跳转到C语言环境 ######<br>    j       start_kernel     # hart 0 jump to c, start_kernel is the entry point of the kernel<br>    ###### 跳转到C语言环境 ######<br><br>park:<br>    wfi<br>    j    park<br><br>stacks:<br>    # allocate space for all the harts stacks<br>    .skip    STACK_SIZE * MAXNUM_CPU <br>    .end                # End of file<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_kernel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;&#125;; <span class="hljs-comment">// stop here!</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="通过-UART-打印信息"><a href="#通过-UART-打印信息" class="headerlink" title="通过 UART 打印信息"></a>通过 UART 打印信息</h2><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211022171638.png"></p>
<p>真实的硬件开发是有一个快开发板，但是这个课程里使用的是 QEMU 来模拟开发板的硬件环境。如果要在程序里打印一段信息，正常的情况是在开发板上连接显示器，但是这里是通过将信息用串口传到主机上，然后用主机的屏幕显示信息。</p>
<p>串口线里是有两根线，负责收信息和发信息。</p>
<h3 id="UART-特点"><a href="#UART-特点" class="headerlink" title="UART 特点"></a>UART 特点</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211022172156.png"></p>
<ul>
<li>并行就是需要多根线，比如有两根线，那么就可以一次发送两位。但是串行节省材料。</li>
<li>数据通信就会涉及同步的问题，同步的话需要一根时钟线来协商好发送时间和接收时间。而 UART 使用异步，发送的数据不仅仅是真实的数据，还会带有一些标识信息。这些标识可以判断出是收还是发。</li>
</ul>
<h3 id="物理接口"><a href="#物理接口" class="headerlink" title="物理接口"></a>物理接口</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252233134.png"></p>
<h3 id="UART-通讯协议"><a href="#UART-通讯协议" class="headerlink" title="UART 通讯协议"></a>UART 通讯协议</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252235270.png"></p>
<p>图示中横轴可以表示时间，纵轴表示高低电平。</p>
<p>在需要发送数据时，会进行“下拉”1bit，1bit 持续的时间就是波特率分之一秒。</p>
<p>数据在发送过程中可能会受到干扰，会产生畸变，所以需要检验位来判断是否发生畸变。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252246423.png"></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252305528.png"></p>
<p>在软件中，配置 UART 就是配置寄存器的信息。</p>
<p>在板子上有个元器件叫晶振（crystal），他会产生固定频率的时钟。一种是 1.8432MHZ，一种是 7.3728MHZ。想要获得指定的输出频率就需要对寄存器进行配置。查表可以得到配置信息。比如获得 38.4K 频率的输出，就要配置寄存器值为 3。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252310435.png"></p>
<p>LCR 寄存器功能比较多，将第 7 位设置为 1 就是用来设置波特率。</p>
<p>图中<code>DLL</code>和<code>DLM</code>寄存器就是需要配置的寄存器。因为 UART 寄存器都是 8 位的，将值<code>0x0003</code>高位<code>0x00</code>存在<code>DLM</code>中，将低位<code>0x03</code>存入<code>DLL</code>。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/10/16/RISC-V%E5%85%A5%E9%97%A8-RISC-V%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/" itemprop="url">RISC-V 入门-RISC-V 汇编语言编程</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-10-16T15:26:42.000Z" itemprop="datePublished">10月 16 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/RISC-V-%E5%85%A5%E9%97%A8/">RISC-V 入门</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            19 分钟 lesen (Über 2778 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="汇编语法介绍"><a href="#汇编语法介绍" class="headerlink" title="汇编语法介绍"></a>汇编语法介绍</h2><p>一条典型的 RISC-V 汇编语句由三个部分组成<code>[label:][operation][comment]</code>。<br>后缀<code>.s</code>和<code>.S</code>区别：后者纯汇编。</p>
<ul>
<li>label(标号)</li>
<li>operation 可以有以下多种类型：<ul>
<li>instruction (指令) ：直接对应二进制机器指令的宇符串</li>
<li>pseudo-instruction (伪指令) ：为了提高编写代码的效率，可以用一条伪指令指示汇编器产生多条实际的指令 (instructions)。</li>
<li>directive (指示/伪操作) ：通过类似指令的形式(以”.”开头),通知汇编器如何控制代码的产生等，不对应具体的指令。</li>
<li>macro：采用.macro/.endm 自定义的宏<br>例子</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">.macro do_nothing  # directive<br>  nop    # pseudo-instruction<br>  nop    # pseudo-instruction<br>.endm      # directive<br><br>  .text    # directive<br>  .global _start  # directive<br>_start:     # Label<br>  li x6, 5  # pseudo-instruction<br>  li x7, 4  # pseudo-instruction<br>  add x5, x6, x7  # instruction<br>  do_nothing  # Calling macro<br>stop:  j stop    # statement in one line<br><br>  .end    # End of file<br></code></pre></td></tr></table></figure>

<ul>
<li>comment（注释）以<code>#</code>开头到行尾</li>
</ul>
<h2 id="RISC-V-汇编指令总览"><a href="#RISC-V-汇编指令总览" class="headerlink" title="RISC-V 汇编指令总览"></a>RISC-V 汇编指令总览</h2><h3 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h3><ul>
<li>寄存器<ul>
<li>32个通用寄存器,<code>x0 ~ x31</code>（注意：本章节课程仅涉及RV32I的通用寄存器组）；</li>
<li>在 RISC-V 中，Hart 在执行算术逻辑运算时所操作的数据必须直接来自寄存器。</li>
</ul>
</li>
<li>内存<ul>
<li>Hart可以执行在寄存器和内存之间的数据读写操作；</li>
<li>读写操作使用字节 (Byte) 为基本单位进行寻址；</li>
<li>RV32可以访问最多<code>2^32</code>个字节的内存空间。</li>
</ul>
</li>
</ul>
<h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826142737.png"></p>
<p>指令长度：32bit，本文讨论的都是 RV32 指令集</p>
<p>指令对齐：指令加载到内存是以 32bit 对齐</p>
<p><code>funct3</code>、<code>funct7</code>和<code>opcode</code>一起决定指令类型，<code>funct3</code>表示占 3bit，<code>funct7</code>占 7bit。</p>
<p><code>opcode</code>映射关系：</p>
<ul>
<li>[1:0] 永远为 11</li>
<li>[4:2] 为下图横轴</li>
<li>[6:5] 为下图纵轴，三部分决定指令的类型。</li>
</ul>
<p>以<code>BEQ</code>指令为例<code>opcode=1100011</code>。<code>[4:2]=000</code>，<code>[6:5]=11</code>查表可得<code>BEQ</code>指令类型为<code>BRANCH</code>。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220811194125.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220811194216.png" alt="The RISC-V Instruction Set Manual"></p>
<h4 id="小端序"><a href="#小端序" class="headerlink" title="小端序"></a>小端序</h4><ul>
<li>主机字节序 (HBO-Host Byte Order)</li>
<li>一个多字节整数在计算机内存中存储的字节顺序称主机字节序 (HBO- Host Byte Order，或者叫本地字节序)</li>
<li>不同类型 CPU 的 HBO 不同，这与 CPU 的设计有关。分为大端序 (Big-Endian) 和小端序 (Little-Endian)</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826144713.png"></p>
<h4 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220811195352.png"></p>
<p><code>rd</code>（register destination）目标寄存器，<code>rs</code>（register source）源寄存器，大小都是 5bit，因为可以表示<code>2^5=32</code>寄存器。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220811195422.png"></p>
<h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>算数指令只包含加减，不包含乘除，乘除运算有专门的扩展。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108262335167.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108262343942.png"></p>
<p>数据传送顺序是由后向前，和正常的编码习惯类似。</p>
<h4 id="SUB-Substract"><a href="#SUB-Substract" class="headerlink" title="SUB Substract"></a>SUB Substract</h4><p><strong>练习</strong></p>
<p>现知道某条 RISC-V 的机器指令在内存中的值为<code>b3 05 95 00</code>,从左往右为从低地址到高地址，单位为字节，请将其翻译为对应的汇编指令。</p>
<ul>
<li>确定字节序<br>在 RISC-V 中存放是小端序，根据题意真正指令应该是<code>00 95 05 b3</code></li>
<li>转换二进制<br>机器码是二进制，所以需要将上述指令值转换为二进制，可得<code>0000000 01001 01010 000 01011 0110011</code></li>
<li>查阅手册<br>查阅<code>The RISC-V Instruction Set Manual Volume I: Unprivileged ISA</code>找到<code>RV32/64G Instruction Set Listings</code>指令表格，低 7 位是<code>opcode</code>，查表可得<code>0110011</code>对应操作码有多个<code>SLLI SRAI SUB</code>等等，此时再看最高位<code>00000000</code>,可以确定是<code>ADD</code>指令</li>
<li>将分割的二进制转成十进制<br><code>0000000 9 10 000 11 010011</code>-&gt;<code>ADD x11 x10 x9</code></li>
</ul>
<h4 id="ADDI-ADD-Immediate"><a href="#ADDI-ADD-Immediate" class="headerlink" title="ADDI ADD Immediate"></a>ADDI ADD Immediate</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918102935.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104115.png"></p>
<h4 id="LUI-Load-Upper-Immediate"><a href="#LUI-Load-Upper-Immediate" class="headerlink" title="LUI Load Upper Immediate"></a>LUI Load Upper Immediate</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104625.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104556.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104911.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104929.png"></p>
<h4 id="LI"><a href="#LI" class="headerlink" title="LI"></a>LI</h4><p><img src="https://secure2.wostatic.cn/static/j4jbakqQTGuyjHGDqXsnAf/image.png"></p>
<h4 id="AUIPC"><a href="#AUIPC" class="headerlink" title="AUIPC"></a>AUIPC</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816133111.png"></p>
<p>经常用于构造一个相对地址。</p>
<h4 id="LA"><a href="#LA" class="headerlink" title="LA"></a>LA</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816133406.png"></p>
<h4 id="基于算术运算指令实现的其他伪指令"><a href="#基于算术运算指令实现的其他伪指令" class="headerlink" title="基于算术运算指令实现的其他伪指令"></a>基于算术运算指令实现的其他伪指令</h4><p><code>x0</code>寄存器具有特殊含义，往里写数据没有意义<br><code>NOP</code>指令主要为了占位，空转</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918103237.png"></p>
<h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816133744.png"></p>
<h4 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h4><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 6502">10101010<br>11111111(-1)<br>--------  XOR<br>01010101<br></code></pre></td></tr></table></figure>

<h3 id="移位运算指令"><a href="#移位运算指令" class="headerlink" title="移位运算指令"></a>移位运算指令</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816134208.png"></p>
<h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><p>只有右移，没有左移。左移会把最高位覆盖。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816134425.png"></p>
<figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 6502">10001000 &gt;&gt; 2<br>= 11100001<br></code></pre></td></tr></table></figure>

<h3 id="内存读写指令"><a href="#内存读写指令" class="headerlink" title="内存读写指令"></a>内存读写指令</h3><p>加载，内存读，将数据从内存读入寄存器</p>
<p>Store，内存写，将数据从寄存器写出到内存</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816134941.png"></p>
<blockquote>
<p>为何对 word 的 加载 不区分无符号和有符号方式 (RV32)？RV32 下寄存器是 4 字节，加载 word 也是 4 字节，自然不需要扩展。</p>
</blockquote>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816135526.png"></p>
<blockquote>
<p>为何 store 不区分有符号还是无符号？因为从目的地址只有 1 字节，不管是写 1 字节，2 字节，还是 4 字节，都只用到最低的 1 字节。不需要考虑符号</p>
</blockquote>
<blockquote>
<p>立即数分两个地方存，为了解码效率</p>
</blockquote>
<h3 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211008115038.png"></p>
<p>指令格式中的立即数 (imm) 存放有些奇怪，第 [1-4] 位和第 [11] 位放在一起，第 [5-10] 位和第 [12] 位放在一起。这是为了迎合硬件处理效率，编程时不需要考虑立即数存储方式。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816145400.png"></p>
<h3 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816152941.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816152959.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816153100.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  a = a+b;<br>  <span class="hljs-keyword">return</span>;   <span class="hljs-comment">// jalr x0 0(x5)  当前指令的下一条指令存到x0中，并跳转到（0 + x5)，也就是sum的下一条指令</span><br>&#125;<br><br><span class="hljs-keyword">void</span> _start()<br>&#123;<br>  sum(); <span class="hljs-comment">// jal x5 sum  把sum的下一条指令存到x5，然后跳转到sum</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如何解决长距离跳转？使用 AUIPC 来构建一个大数，配合 JALR 使用。如  auipc x6,imm-20  jalr x1,x6,imm-12</p>
</blockquote>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816162732.png"></p>
<h2 id="RISC-V-指令寻址模式总结"><a href="#RISC-V-指令寻址模式总结" class="headerlink" title="RISC-V 指令寻址模式总结"></a>RISC-V 指令寻址模式总结</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816162913.png"></p>
<h2 id="汇编函数调用约定"><a href="#汇编函数调用约定" class="headerlink" title="汇编函数调用约定"></a>汇编函数调用约定</h2><h3 id="函数调用过程概述"><a href="#函数调用过程概述" class="headerlink" title="函数调用过程概述"></a>函数调用过程概述</h3><p>栈（stack）数据结构，在函数调用过程中会用来保存变量，函数地址等等。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162130267.png"></p>
<p>栈帧里保存的变量是自动变量，会被内存自动释放。</p>
<p>为何要有调用者与被调用者保存的概念</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162137133.png"></p>
<p>函数调用过程中就会有参数和返回值的传递，自己写的函数可能由别人来调用，如果没有约定好某个参数存放位置，就不能够顺利执行函数。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162144447.png"></p>
<p>因为寄存器需要经常在编程中使用，所以 ABI 名就是寄存器的别名。</p>
<blockquote>
<p>这些寄存器其实都可以设置成被调用者保存，也就是在被调用函数中保存一遍为啥还要分这么多<br>答：因为保存一遍效率低</p>
</blockquote>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162209273.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162217164.gif"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162234551.png"></p>
<h4 id="尾调用实例"><a href="#尾调用实例" class="headerlink" title="尾调用实例"></a>尾调用实例</h4><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs 6502"># Calling Convention<br># Demo to create a leaf routine<br>#<br># void _start()<br># &#123;<br>#     // calling leaf routine<br>#     square(3);<br># &#125;<br>#<br># int square(int num)<br># &#123;<br>#     return num * num;<br># &#125;<br><br>  .text        # Define beginning of text section<br>  .global  _start    # Define entry _start<br><br>_start:<br>  la sp, stack_end  # prepare stack for calling functions<br><br>  li a0, 3      # pass 3 to square<br>  call square     # call square<br><br>  # the time return here, a0 should stores the result<br>stop:<br>  j stop        # Infinite loop to stop execution<br><br># int square(int num)<br>square:<br>  # prologue<br>  addi sp, sp, -8     # reserve space for local variables<br>  sw s0, 0(sp)     # save s0<br>  sw s1, 4(sp)      # save s1<br><br>  # `mul a0, a0, a0` should be fine,<br>  # programing as below just to demo we can contine use the stack<br>  mv s0, a0           # s0 = a0<br>  mul s1, s0, s0      # s1 = s0 * s0<br>  mv a0, s1        # a0 = s1<br><br>  # epilogue<br>  lw s0, 0(sp)      # restore s0<br>  lw s1, 4(sp)     # restore s1<br>  addi sp, sp, 8      # release space for local variables<br>  <br>  ret          # return from function<br><br>  # add nop here just for demo in gdb<br>  nop <br><br>  # allocate stack space<br>stack_start:<br>  .rept 10     # reserve 10 words for stack<br>  .word 0     # fill with 0<br>  .endr        # end of repeat<br>stack_end: <br><br>  .end      # End of file<br><br><br><br></code></pre></td></tr></table></figure>

<h4 id="非尾调用实例"><a href="#非尾调用实例" class="headerlink" title="非尾调用实例"></a>非尾调用实例</h4><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs 6502"># Calling Convention<br># Demo how to write nested routines<br>#<br># void _start()<br># &#123;<br>#     // calling nested routine<br>#     aa_bb(3, 4);<br># &#125;<br>#<br># int aa_bb(int a, int b)<br># &#123;<br>#     return square(a) + square(b);<br># &#125;<br>#<br># int square(int num)<br># &#123;<br>#     return num * num;<br># &#125;<br><br>  .text        # Define beginning of text section<br>  .global  _start    # Define entry _start<br><br>_start:<br>  la sp, stack_end  # prepare stack for calling functions<br><br>  # aa_bb(3, 4);<br>  li a0, 3      # load argument a<br>  li a1, 4      # load argument b<br>  call aa_bb       # call aa_bb<br><br>stop:<br>  j stop      # Infinite loop to stop execution<br><br># int aa_bb(int a, int b)<br># return a^2 + b^2<br>aa_bb:<br>  # prologue<br>  addi sp, sp, -16  # decrement stack pointer by 16 bytes<br>  sw s0, 0(sp)    # save s0<br>  sw s1, 4(sp)    # save s1<br>  sw s2, 8(sp)    # save s2<br>  sw ra, 12(sp)    # save ra<br>  <br>  # cp and store the input params<br>  mv s0, a0      # copy a to s0<br>  mv s1, a1      # copy b to s1<br><br>  # sum will be stored in s2 and is initialized as zero<br>  li s2, 0      # initialize s2 to zero<br><br>  mv a0, s0      # copy s0 to a0<br>  jal square      # call square<br>  add s2, s2, a0    # add a0 to s2<br>  <br>  mv a0, s1      # copy s1 to a0<br>  jal square      # call square<br>  add s2, s2, a0    # add a0 to s2<br>  <br>  mv a0, s2      # copy s2 to a0<br><br>  # epilogue<br>  lw s0, 0(sp)    # restore s0<br>  lw s1, 4(sp)    # restore s1    <br>  lw s2, 8(sp)    # restore s2<br>  lw ra, 12(sp)    # restore ra<br>  addi sp, sp, 16    # increment stack pointer by 16 bytes<br>  ret          # return from aa_bb<br><br># int square(int num)<br>square:<br>  # prologue<br>  addi sp, sp, -8    # decrement stack pointer by 8 bytes<br>  sw s0, 0(sp)    # save s0<br>  sw s1, 4(sp)    # save s1<br><br>  # `mul a0, a0, a0` should be fine,<br>  # programing as below just to demo we can contine use the stack<br>  mv s0, a0      # copy a to s0<br>  mul s1, s0, s0    # s1 = a * a<br>  mv a0, s1      # copy s1 to a0<br><br>  # epilogue<br>  lw s0, 0(sp)    # restore s0      <br>  lw s1, 4(sp)    # restore s1<br>  addi sp, sp, 8    # increment stack pointer by 8 bytes<br>  <br>  ret          # return from square<br>  <br>  # add nop here just for demo in gdb<br>  nop            <br><br>  # allocate stack space<br>stack_start:<br>  .rept 10      # allocate 10 words of stack space<br>  .word 0        # initialize stack space to 0<br>  .endr        # end of stack allocation<br>stack_end:<br>  .end      # End of file<br><br></code></pre></td></tr></table></figure>

<h2 id="汇编与-C-混合编程"><a href="#汇编与-C-混合编程" class="headerlink" title="汇编与 C 混合编程"></a>汇编与 C 混合编程</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>遵守 ABI（Abstract Binary Interface）的规定</p>
<ul>
<li>数据类型大小，布局，对齐</li>
<li>函数调用约定</li>
<li>系统调用约定<br>等等</li>
</ul>
<p>RISC-V 函数调用约定规定</p>
<ul>
<li>函数参数采用寄存器<code>a0-a7</code></li>
<li>函数返回值采用寄存器<code>a0,a1</code></li>
</ul>
<h3 id="汇编嵌入-C-语言"><a href="#汇编嵌入-C-语言" class="headerlink" title="汇编嵌入 C 语言"></a>汇编嵌入 C 语言</h3><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs 6502"># ASM call C<br><br>  .text      # Define beginning of text section<br>  .global  _start    # Define entry _start<br>  .global  foo    # foo is a C function defined in test.c<br><br>_start:<br>  la sp, stack_end  # prepare stack for calling functions<br><br>  # RISC-V uses a0 ~ a7 to transfer parameters<br>  li a0, 1<br>  li a1, 2<br>  call foo    #调用了C语言函数<br>  # RISC-V uses a0 &amp; a1 to transfer return value<br>  # check value of a0<br><br>stop:<br>  j stop      # Infinite loop to stop execution<br><br>  nop      # just for demo effect<br><br>stack_start:<br>  .rept 10<br>  .word 0<br>  .endr<br>stack_end:<br><br>  .end      # End of file<br><br></code></pre></td></tr></table></figure>

<p><code>call foo</code>就是在调用 C 语言函数，<code>foo</code>。<br><code>.global foo</code>告诉编译器<code>foo</code>函数定义在外面。</p>
<h3 id="C-语言嵌入汇编"><a href="#C-语言嵌入汇编" class="headerlink" title="C 语言嵌入汇编"></a>C 语言嵌入汇编</h3><p>下图中为简化写法</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162347033.png"></p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162342119.png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/26/RISC-V%E5%85%A5%E9%97%A8-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url">RISC-V 入门 - 计算机基础</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-26T05:42:34.000Z" itemprop="datePublished">8月 26 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/RISC-V-%E5%85%A5%E9%97%A8/">RISC-V 入门</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 lesen (Über 355 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机硬件基础"><a href="#计算机硬件基础" class="headerlink" title="计算机硬件基础"></a>计算机硬件基础</h3><p>两大硬件架构</p>
<ul>
<li><p>冯诺依曼架构</p>
<ul>
<li><p>一根总线，开销小，控制逻辑实现简单</p>
</li>
<li><p>执行效率低</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211529332.png"></p>
<ul>
<li><p>哈佛架构</p>
<ul>
<li>与上一架构相反</li>
</ul>
</li>
</ul>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211529619.png"></p>
<h3 id="程序的存储与执行"><a href="#程序的存储与执行" class="headerlink" title="程序的存储与执行"></a>程序的存储与执行</h3><p><code>.c</code>文件经过编译链接，生成<code>.out</code>文件。加载到内存中，到控制单元运行。进行取值，译码，执行。</p>
<p>晶振发出脉冲。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211621792.png"></p>
<h3 id="语言的设计与进化"><a href="#语言的设计与进化" class="headerlink" title="语言的设计与进化"></a>语言的设计与进化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211735861.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211736944.png"><br>上图是冯诺依曼架构，特点就是指令与数据放在一起。黄色部分表示指令，绿色部分表示数据。我们来看看指令是如何执行的。<br><code>ProgramCounter</code>指到右图内存的第一条指令，程序开始执行。将第一条 指令读入指令寄存器。然后将指令解码，根据之前的规定，我们可以知道这条指令是将<code>0100(二进制即 5)</code>位置的数据，<code>00(load)</code>到<code>00(Register 0)</code>中。下面的指令一次类推，每次取指，<code>Program Counter</code>移动一次。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211743999.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211719114.png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="../../2021/08/23/VSCode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/" itemprop="url">VSCode 调试 RISC-V 程序</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-08-23T07:51:51.000Z" itemprop="datePublished">8月 23 2021</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../categories/%E4%B8%87%E8%83%BD-VSCode/">万能 VSCode</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            12 分钟 lesen (Über 1808 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>本文主要涉及 VSCode 的相关配置，编译及调试工具需要提前安装好。</p>
<ul>
<li>已经安装好<code>riscv-toolchain</code>，包括<code>riscv64-unknown-elf-gcc</code>，<code>riscv64-unknown-elf-gdb</code></li>
<li>已经安装好<code>qemu</code>，包括<code>riscv32-softmmu,riscv32-linux-user,riscv64-softmmu,riscv64-linux-user</code></li>
<li>已经安装好<code>g++</code>,<code>gdb</code></li>
</ul>
<h2 id="调试流程简介"><a href="#调试流程简介" class="headerlink" title="调试流程简介"></a>调试流程简介</h2><p>对于我这样的新手，要调试一个项目源码最怕的就是开始，也就是怎么能把项目跑起来。</p>
<p>我们以一个简单的<code>test</code>项目，看看在 VSCode 里怎么跑起来。</p>
<p>拿到源码后，将其以文件夹形式，加入到 VSCode 中，<code>文件 - 打开文件夹 - 选择 test 项目文件夹</code>。项目就会在 VSCode 中打开，但是此时我们还无法编译运行，我们需要在 VSCode 上<br>构建出一个 C 语言的编译与调试环境。</p>
<p>首先得安装一个插件<code>C/C++</code>，打开插件中心<code>Ctrl+Shit+X</code>，搜索，安装。</p>
<p>然后输入<code>F5</code>，会弹出对话框，选择<code>C++(GDB)</code>，继续选择<code>g++</code>。VSCode 会自动创建<code>.vscode</code>文件夹，已经两个文件<code>launch.json</code>和<code>tasks.json</code>。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210823193157.png"></p>
<p><code>launch.json</code>用来配置调试环境，<code>tasks.json</code>主要用来配置编译环境，当然也可以配置其他任务。<code>task.json</code>里配置的每个任务其实就相当于多开一个控制台。</p>
<h2 id="配置tasks-json"><a href="#配置tasks-json" class="headerlink" title="配置tasks.json"></a>配置<code>tasks.json</code></h2><p>因为我们先要编译源码，生成<code>.out</code>或者<code>.exe</code>文件，才能调试，所以先进行编译任务配置。</p>
<p>自动生成的文件是个配置模板，我们可以根据自己的实际情况进行配置，也有一部分可以保持默认。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// tasks.json</span><br>&#123;<br>    <span class="hljs-comment">// https://code.visualstudio.com/docs/editor/tasks</span><br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>        &#123;<br>             <span class="hljs-comment">// 任务的名字，注意是大小写区分的</span><br>             <span class="hljs-comment">//会在launch中调用这个名字</span><br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++: g++ build active file&quot;</span>, <br>             <span class="hljs-comment">// 任务执行的是shell</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>, <br>             <span class="hljs-comment">// 命令是g++</span><br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;g++&quot;</span>, <br>             <span class="hljs-comment">//g++ 后面带的参数</span><br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;&#x27;-Wall&#x27;&quot;</span>,<br>                <span class="hljs-string">&quot;-g&quot;</span>,           <span class="hljs-comment">// 生成调试信息，否则无法进入断点</span><br>                <span class="hljs-string">&quot;&#x27;-std=c++17&#x27;&quot;</span>,     <span class="hljs-comment">//使用c++17标准编译</span><br>                <span class="hljs-string">&quot;&#x27;$&#123;file&#125;&#x27;&quot;</span>,        <span class="hljs-comment">//当前文件名</span><br>                <span class="hljs-string">&quot;-o&quot;</span>,               <span class="hljs-comment">//对象名，不进行编译优化</span><br>                <span class="hljs-string">&quot;&#x27;$&#123;fileBasenameNoExtension&#125;.exe&#x27;&quot;</span>,  <span class="hljs-comment">//当前文件名（去掉扩展名）</span><br>            ],<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果项目是通过 Makefile 编译的，那就更加简单，只需要配置一个任务即可。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>    &#123;<br>       <span class="hljs-comment">//任务的名字方便执行</span><br>      <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Make Project&quot;</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>      <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>,<br>      <span class="hljs-attr">&quot;args&quot;</span>:[<br>          <span class="hljs-comment">//8线程编译</span><br>          <span class="hljs-string">&quot;-j8&quot;</span>,<br>      ],<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行该任务时就会执行<code>make</code>命令进行编译。</p>
<h2 id="配置launch-json"><a href="#配置launch-json" class="headerlink" title="配置launch.json"></a>配置<code>launch.json</code></h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// launch.json</span><br><br>&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-comment">//调试任务的名字</span><br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;g++ - Build and debug active file&quot;</span>, <br>            <span class="hljs-comment">//在launch之前运行的任务名，这个名字一定要跟tasks.json中的任务名字大小写一致</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;C/C++: g++ build active file&quot;</span>,  <br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-comment">//需要运行的是当前打开文件的目录中，</span><br>            <span class="hljs-comment">//名字和当前文件相同，但扩展名为exe的程序</span><br>            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>, <br>            <span class="hljs-attr">&quot;args&quot;</span>: [],<br>            <span class="hljs-comment">// 选为true则会在打开控制台后停滞，暂时不执行程序</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-comment">// 当前工作路径：当前文件所在的工作空间</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;</span>: [],<br>            <span class="hljs-comment">// 是否使用外部控制台</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,  <br>            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;<br>            ]<br>        &#125;]<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>经过以上配置后，我们打开<code>main.cpp</code>文件，在<code>cout</code>处打一个断点，按<code>F5</code>，即可编译，运行，调试。一定要打开<code>main.cpp</code>文件，不能随便打开文件就开始哦。因为我们在配置时使用了一些预定义，比如<code>$&#123;file&#125;</code>表示当前文件，所以只有打开需要调试的文件才能开始。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210823201621.png"></p>
<p>程序将会在<code>cout</code>语句停下来。</p>
<p>我们可以注意一下界面下方的控制台，可以更直观了解<code>launch.jason</code>和<code>tasks.jason</code>。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210823202012.png"></p>
<p>右边的框，就是我们在<code>tasks.jason</code>中配置的任务，左边的框就是我们在<code>tasks.jason</code>中<code>command</code>以及<code>args</code>的内容，他就是帮我们提前写好编译的选项。然后在 shell 中运行。</p>
<h2 id="编译调试-RISC-V-程序"><a href="#编译调试-RISC-V-程序" class="headerlink" title="编译调试 RISC-V 程序"></a>编译调试 RISC-V 程序</h2><p>了解以上这些，就可以按需配置所需的环境了。我们还是从<code>tasks.jason</code>开始。因为开发用的电脑是<code>x86</code>的，所以先要编译出<code>riscv</code>的程序，再用模拟器模拟出<code>rsicv</code>的环境，然后在模拟的环境中运行程序，最后才能开始调试。</p>
<p>假设已经安装好开头所提到的工具。首先配置<code>tasks.jason</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-comment">// 编译当前代码</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++(RISCV): Build active file&quot;</span>,<br>            <span class="hljs-comment">// 编译器的位置</span><br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;/opt/riscv/bin/riscv64-unknown-elf-g++&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-Wall&quot;</span>, <span class="hljs-comment">// 开启所有警告</span><br>                <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-comment">// 生成调试信息s</span><br>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>,<br>                <span class="hljs-string">&quot;-o&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span> <span class="hljs-comment">// 我选择将可执行文件放在debug目录下</span><br>            ],<br>            <span class="hljs-comment">// 当前工作路径：执行当前命令时所在的路径</span><br>            <span class="hljs-attr">&quot;options&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>            &#125;,<br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span>: [<br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-comment">// 启动qemu供调试器连接</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Run Qemu Server(RISCV)&quot;</span>,<br>            <span class="hljs-attr">&quot;dependsOn&quot;</span>: <span class="hljs-string">&quot;C/C++(RISCV): Build active file&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;qemu-system-riscv64&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-g&quot;</span>,<br>                <span class="hljs-string">&quot;65500&quot;</span>, <span class="hljs-comment">// gdb端口，自己定义</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>            ],<br>        &#125;,<br>        &#123;<br>            <span class="hljs-comment">// 有时候qemu有可能没法退出，故编写一个任务用于强行结束qemu进程</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Kill Qemu Server(RISCV)&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;ps -C qemu-riscv64 --no-headers | cut -d \\  -f 1 | xargs kill -9&quot;</span>,<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>tasks.jason</code>是可以配置多个任务的，第一个任务用来编译成<code>riscv</code>架构下的程序，第二个任务用来启动 qemu，让程序在 qemu 上运行起来。</p>
<p>第一个任务中，<code>command</code>就是配置编译器<code>riscv64-unkonown-elf-gcc</code>的属性，第二个任务中，<code>command</code>是配置 qemu 模拟器<code>qemu-system-riscv32</code>的属性。第三个任务中，用来配置结束 qemu 模拟器的命令。</p>
<p>接下来配置<code>launch.jason</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;</span>: [<br>        &#123; <br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;C/C++(RISCV) - Debug Active File&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [],<br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;</span>: [],<br>            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;<br>            ],<br>            <span class="hljs-comment">// RISC-V工具链中的gdb</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;/opt/riscv/bin/riscv64-unknown-elf-gdb&quot;</span>, <br>            <span class="hljs-comment">// 这里需要与task.json中定义的端口一致</span><br>            <span class="hljs-attr">&quot;miDebuggerServerAddress&quot;</span>: <span class="hljs-string">&quot;localhost:65500&quot;</span> <br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在配置<code>x86</code>下的调试环境时，<code>launch.jason</code>中有个<code>&quot;preLaunchTask&quot;: &quot;C/C++: g++ build active file&quot;</code>，属性，这个属性的目的是在启动调试之前，先执行任务名字为<code>&quot;C/C++: g++ build active file&quot;</code>任务，也是就编译的任务。</p>
<p>因为启动 qemu 会导致阻塞，所以这里没有加<code>preLaunchTask</code>，在启动调试之前，先把 qemu 运行起来。输入<code>Ctrl+Shift+P</code>，打开 VSCode 命令行。输入<code>Run Task</code>，</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824094556.png"></p>
<p>点击第一个，选择任务，我们可以看到出现的三个任务就是我们在<code>tasks.jason</code>中配置的三个任务。选择第一个 Build，编译出程序，再重复操作，选择第三个执行 QEMU 任务。</p>
<p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824094609.png"></p>
<h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/variables-reference#_predefined-variables">官网</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    
</article>




    
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2024 Dominic&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>




<script src="../../js/script.js"></script>


    
</body>
</html>