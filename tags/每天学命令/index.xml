<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>每天学命令 on PaperMod</title>
    <link>http://localhost:8888/tags/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/</link>
    <description>Recent content in 每天学命令 on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Sun, 04 Dec 2022 16:32:59 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/tags/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>每天学命令-chown 修改文件拥有者</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-chown%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8B%A5%E6%9C%89%E8%80%85/</link>
      <pubDate>Sun, 04 Dec 2022 16:32:59 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-chown%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8B%A5%E6%9C%89%E8%80%85/</guid>
      <description>chown 命令用来变更文件或目录的拥有者或所属群组，通过 chown 改变文件的拥有者和群组。用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的文件列表，文件名也支持通配符。
命令格式 chown [选项] [用户或组] [文件或目录] -c或--changes #效果类似“-v”参数，但仅回报更改的部分； -f或--quite或—-silent #不显示错误信息； -h或--no-dereference #只对符号连接的文件作修改，而不更改其他任何相关文件； -R或--recursive #递归处理，将指定目录下的所有文件及子目录一并处理； -v或--version #显示指令执行过程； --dereference #效果和“-h”参数相同； --help #在线帮助 --reference=&amp;lt;参考文件或目录&amp;gt; #把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同； --version #显示版本信息。 实例 将文件test.md拥有者改为nic
chown nic test.md 将目录/home/nic/develop及其下面的所有文件、子目录的文件拥有者改为nic
chown -R nic /home/nic/develop </description>
    </item>
    <item>
      <title>每天学命令-tree 显示目录结构</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-tree%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 04 Dec 2022 16:31:54 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-tree%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid>
      <description>-a #显示所有文件 -d #只显示目录（名称） -l #显示链接文件的原始文件 -f #显示所列出的文件或目录的完整目录路径 -i #不以阶梯的形式显示文件或目录名称 -q #将控制字符以?字符代替，显示文件和目录名称 -N #直接显示文件或目录的名称 -p #显示每个文件的权限信息 -u #显示文件所有者或者uid -g #显示文件所属组或者gid -s #显示每个文件的大小信息 -h #以可读的方式显示文件的大小信息 -D #显示最后修改日期 -v #按字母数字正序显示文件 -r #按字母数字倒序显示文件 -t #按最后时间排序显示文件 -C #在文件和目录列表上加上色彩，便于区分文件类型 -P pattern #只显示匹配正则表式的文件或目录名称 -I pattern #与上结果相反 实例 显示当前目录及其子目录下的文件及目录名称
$ tree . ├── CODE_OF_CONDUCT.md ├── CONTRIBUTING.md ├── Fedora-35 │ ├── Dockerfile │ └── Readme.md ├── LICENSE ├── README.md ├── Ubuntu-20 │ ├── Dockerfile │ ├── Readme.md │ ├── init_edkrepo_conf.</description>
    </item>
    <item>
      <title>每天学命令-chattr 修改文件与目录属性防止误删除</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-chattr%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7%E9%98%B2%E6%AD%A2%E8%AF%AF%E5%88%A0%E9%99%A4/</link>
      <pubDate>Sun, 25 Sep 2022 11:20:35 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-chattr%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7%E9%98%B2%E6%AD%A2%E8%AF%AF%E5%88%A0%E9%99%A4/</guid>
      <description>使用背景 chattr命令可以修改 Linux 的文件属性，在类 Unix 等发行版中，该命令能够有效防止文件和目录被意外的删除或修改。文件在 Linux 中被描述为一个数据结构，chattr 命令在大多数现代 Linux 操作系统中是可用的，可以修改文件属性，一旦定义文件的隐藏属性，那么该文件的拥有者和 root 用户也无权操作该文件，只能解除文件的隐藏属性。这就可以有效的避免被误删除。
命令格式 一个完整的命令一般由命令 (chattr)，可选项 (option)，操作符 (operator) 与属性 (attribute) 组成：
chattr [option] [operator] [attribute] file [option] 可选项：
-R， 递归更改目录及其内容的属性。 -V， 详细说明chattr的输出并打印程序版本。 -f， 隐藏大多数错误消息。 [operator] 操作符：
+，追加指定属性到文件已存在属性中 -， 删除指定属性 =，直接设置文件属性为指定属性 [attribute] 属性如下：
a， 只能向文件中添加数据 A，不更新文件或目录的最后访问时间 i， 文件或目录不可改变 使用实例 lsattr 命令检查文件已有属性 -d：如果目标是目录，只会列出目录本身的隐藏属性，而不会列出所含文件或子目录的隐藏属性信息 -R：作用于目录时，会显示所有的子目录和文件的隐藏信息 $ lsattr clash --------------e------- clash/glados.yaml --------------e------- clash/clash-linux-386-v1.10.0 --------------e------- clash/Country.mmdb --------------e------- clash/cache.db --------------e------- clash/clash-linux-amd64-v1.10.0 --------------e------- clash/dashboard $ lsattr -d clash --------------e------- clash $ lsattr -R clash --------------e------- clash/glados.</description>
    </item>
    <item>
      <title>每天学命令-nohup 后台运行</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-nohup%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</link>
      <pubDate>Sat, 10 Sep 2022 17:14:58 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-nohup%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</guid>
      <description>使用 MobaXertm 连接服务器后，想要在运行一个下载任务，使用&amp;amp;挂在后台后，退出 MobaXterm，后台的任务也随之中断，于是搜到这个nohup命令，可以完成我的需求。
nohup意思是 No Hang Up，不要挂起的意思，即使退出终端也不会中断任务。
为了方便以后查阅，这里总结一下关于后台运行相关的命令。首先是最常用的&amp;amp;符号。
&amp;amp; 后台运行 比如执行编译任务时通常会占用终端前台，这时候无法再执行其他命令，除非再开一个终端，对于有 GUI 界面时，再开一个终端很方便，但是如果是服务器就只能再想办法了。 &amp;amp;可以将命令执行过程放在后台运行，如：
$ make &amp;gt; make.log 2&amp;gt;&amp;amp;1 &amp;amp; [1] 16586 2&amp;gt;&amp;amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了make.log文件，即将标准出错也输出到make.log文件中。最后一个&amp;amp;，是让该命令在后台执行。 试想2&amp;gt;1代表什么，2与&amp;gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&amp;gt;&amp;amp;1，&amp;amp;与1结合就代表标准输出了，就变成错误重定向到标准输出。
在后台运行make进行编译，并将输出结果（错误和正常输出）都保存到make.log文件中，提交任务成功后，会显示进程 ID，编译的进程 ID 为 16586。
有了进程 ID 我们可以监控，也可以中断进程：
# 查看进程状态 ps -ef | grep 16586 # 中断进程 kill -9 16586 但是使用 &amp;amp;时关闭终端后，进程也会随之关闭。如果想要在后台持续运行程序，就需要nohup命令。
nohup 使用 $ nohup make &amp;gt; make.log 2&amp;gt;&amp;amp;1 &amp;amp; [1] 112233 命令功能同上，但是终端关闭，后台程序也会继续执行。
NOTE：终端关闭，是指带 GUI 的界面里终端，如果使用 SSH 等登陆，比如使用 MobaXterm，一个 session 相当于一个登陆账户，如果异常退出了这个账户，那么后台执行的程序也会中断。如果需要继续执行，需要正常退出账户，执行exit命令。
汇总 fg # 将后台中的命令调至前台继续运行 bg # 将一个在后台暂停的命令，变成继续执行 (在后台执行) jobs # 查看当前有多少在后台运行的命令 kill %num # 终止进程num &amp;amp; # 加在命令后可以将其置于后台运行 ctrl + z # 置于后台，并且暂停不可执行 ctrl + c # 终止前台进程 ctrl + \ # 退出 ctrl + d # 结束当前输入(即用户不再给当前程序发出指令)，那么Linux通常将结束当前程序 </description>
    </item>
    <item>
      <title>每天学命令-生成指定大小文件</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sat, 23 Jul 2022 16:14:38 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6/</guid>
      <description>使用背景 在测试下载速度，或者测试加解密文件，亦或者制作文件系统时都需要一些指定大小的文件。Linux 有一些命令可以快速完成这样的任务。接下来介绍几个好用的命令。
空洞文件 在 Unix 文件操作中，操作文件的位移量可以大于文件的当前长度，在下一次写操作时，就会把文件撑大（Extend），在文件里创建空洞（Hole），没有被实际写入的部分都是 0。空洞文件是否占用实际磁盘空间由文件系统觉得，Linux 中空洞文件不占用实际磁盘空间。
fallocate fallocate用于将块预分配给文件。对于支持fallocate系统调用的文件系统，这可以通过分配块并将其标记为未初始化来快速完成，因此不需要对数据块进行 I/O 操作。这是创建文件而不是用零填充的更快的方法。大文件几乎可以立即创建，而不必等待任何 I/O 操作完成。
语法：
fallocate [-n] [-o offset] -l length filename d: 检测零并替换为空洞。 -n：指定文件的大小，单位为字节。 -o：指定文件的偏移量，可以跟二进制$2^{N}$后缀KiB，MiB，GiB，TiB，PiB和EiB（iB为可选，例如，K的含义与KiB的含义相同或后缀KB，MB，GB，PB和EB的十进制（$10^{N}$）。 -l：指定文件的大小，单位同上。 -p, --punch-hole: 将某个范围替换为空洞 (连带打开 -n)。 filename：指定文件名。 示例： 分配一个大小为512MB的文件，文件名为efi.img：
fallocate -l 512M efi.img 将efi.img文件中的0替换为空洞：
fallocate -d efi.img 从偏移 128M 的位置挖一个 10M 大小的洞
fallocate -p -o 128M -l 10M efi.img dd Linux dd 命令用于读取、转换并输出数据。dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出
dd 的原意为 data duplicator，但由于 dd 属于较低阶的资料处理工具，通常都会以管理者（root）权限来执行，如果稍有不慎，也很容易造成严重的后果（例如整颗硬碟的资料不见等等），所以有些人也把 dd 取名为 data destroyer。dd 指令教学与实用范例，备份与回复资料的小工具 - GT Wang</description>
    </item>
    <item>
      <title>每天学命令-watch 周期执行命令</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-watch%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 09 Jun 2022 22:50:54 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-watch%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</guid>
      <description>功能 watch 命令的功能如其名，可以监视命令的执行结果。它实现的原理就是每隔一段时间执行一次命令，然后显示结果。他的用途很广，具体怎么用就靠想象力了。
命令参数 -n # 或--interval watch默认每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。-d # 或--differences 用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。-t # 或-no-title 会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。-h # 或--help # 查看帮助文档 实例 watch -d &amp;#39;ls -l | grep tmp&amp;#39; # 监测当前目录中 scf&amp;#39; 的文件的变化 </description>
    </item>
    <item>
      <title>每天学命令-rename 批量重命名</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-rename%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/</link>
      <pubDate>Fri, 13 Aug 2021 18:40:16 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-rename%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/</guid>
      <description>Commands rename [options] &amp;#34;s/oldname/newname/&amp;#34; file 格式就很容易看出来怎么用的，就是/不能丢。
-v 将重命名的内容都打印到标准输出，v 可以看成 verbose-n 测试会重命名的内容，将结果都打印，但是并不真正执行重命名的过程-f force 会覆盖本地已经存在的文件-h -m -V 分别为帮助，帮助，版本-e 比较复杂，可以通过该选项，写一些脚本来做一些复杂的事情 Examples 替换文件名中的特定字段 rename &amp;#34;s/AA/aa/&amp;#34; * # 把文件名中的AA替换成aa 修改文件后缀 rename &amp;#34;s/.html/.php/&amp;#34; * # 把.html 后缀的改成 .php后缀rename &amp;#34;s/.png/.jpg/&amp;#34; * # 将 png 改为 jpg 添加后缀 rename &amp;#34;s/$/.txt/&amp;#34; * # 把所有的文件名都以txt结尾 $正则表达式中表示结尾。
保留部分文件名 假如需要在批量修改的时候保留部分文件名，可以使用引用\1 ，比如有下面格式的文件，只想保留日期部分。
Screenshot from 2019-01-02 15-56-49.jpgrename -n &amp;#34;s/Screenshot from ([0-9\\- ]+).jpg/\1.jpg/&amp;#34; * 将() 匹配的内容取出来放到替换部分。</description>
    </item>
    <item>
      <title>每天学命令-apt 安装卸载软件</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-apt%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Thu, 12 Aug 2021 18:42:39 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-apt%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/</guid>
      <description>这个命令应该是我们平时用的最多的命令之一了，应该早就拿出来讲一下的。但是平时用的太多，总感觉自己都会用了，但是仔细看了所有命令，还是有一些比较实用但是没记住的命令。
apt的全称是Advanced Packaging Tool是 Linux 系统下的一款安装包管理工具。APT 可以自动下载、配置和安装二进制或源代码格式软件包，简化了 Unix 系统上管理软件的过程。
APT 主要由以下几个命令组成：
apt-getapt-cacheapt-file Commands 搜索软件包 apt search python3 安装软件包 apt install python3 更新源 sudo apt install update 更新软件 执行完 update 命令后，就可以使用 apt upgrade 来升级软件包了。执行命令后系统会提示有几个软件需要升级。在得到你的同意后，系统即开始自动下载安装软件包。
sudo apt install upgrade 卸载软件 apt remove python3 # 移除软件包，但是保留配置文件apt purge python3 #移除软件包并移除配置apt autoremove # 移除孤立的并不被依赖的软件包 列出软件清单 apt list </description>
    </item>
    <item>
      <title>每天学命令-kill 这个进程</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-kill%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Wed, 11 Aug 2021 15:22:40 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-kill%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B/</guid>
      <description>对于在前台运行的程序，我们可以用Ctrl+C来终止运行，但是在后台的程序就必须用kill命令来终止了。
Command -l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称-a 当处理当前进程时，不限制命令名和进程号的对应关系-p 指定 kill 命令只打印相关进程的进程号，而不发送任何信号-s 指定发送信号-u 指定用户 Examples 查看所有信号 ➜ kill -lHUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS 常用信号
HUP 1 终端断线INT 2 中断（同 Ctrl + C）QUIT 3 退出（同 Ctrl + \）TERM 15 终止KILL 9 强制终止CONT 18 继续（与 STOP 相反， fg/bg 命令）STOP 19 暂停（同 Ctrl + Z） 用 ps 查找进程，然后用 kill 杀掉 ps -ef | grep &amp;#39;program&amp;#39;kill PID 无条件彻底杀死进程 kill –9 PID 杀死指定用户所有进程 kill -9 $(ps -ef | grep username)kill -u username </description>
    </item>
    <item>
      <title>每天学命令-ar 多文件归档为一个文件</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ar%E5%A4%9A%E6%96%87%E4%BB%B6%E5%BD%92%E6%A1%A3%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 10 Aug 2021 11:33:49 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ar%E5%A4%9A%E6%96%87%E4%BB%B6%E5%BD%92%E6%A1%A3%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/</guid>
      <description>现在我们有solution.c,solution.h两个文件，他们实现了某一个功能，自成一个模块。在其他项目中也可复用。我们就可以把它做成库文件。ar命令就可以将锁哥文件整合成一个库文件，也可以从一个库中单独提取出某一个文件。
Commands -d 删除备存文件中的成员文件。-m 变更成员文件在备存文件中的次序。-p 显示备存文件中的成员文件内容。-q 将文件附加在备存文件末端。-r 将文件插入备存文件中。-t 显示备存文件中所包含的文件。-x 自备存文件中取出成员文件。 Examples 打包文件 将solution.c solution.h两个文件打包成solution.bak，并显示详细信息
➜ ar rv solution.bak solution.c solution.har: 正在创建 solution.baka - solution.ca - solution.h 显示打包文件内容 ➜ ar t solution.bak solution.csolution.h </description>
    </item>
    <item>
      <title>每日学命令-ps 显示进程状态</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E6%97%A5%E5%AD%A6%E5%91%BD%E4%BB%A4-ps%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</link>
      <pubDate>Mon, 09 Aug 2021 19:37:38 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E6%97%A5%E5%AD%A6%E5%91%BD%E4%BB%A4-ps%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</guid>
      <description>ps命令显示的信息类似于 Windows 的任务管理器。也是参数超级多的一个命令，所以就不列参数了，需要查看时直接搜索，这里列举一下实例。
使用实例 显示当前执行的所有程序
➜ ~ ps -a PID TTY TIME CMD 879 tty2 00:03:43 Xorg 990 tty2 00:00:00 gnome-session-b 2653 pts/0 00:00:00 zsh 12365 pts/0 00:00:00 ps 显示所有程序
➜ ~ ps -A PID TTY TIME CMD 1 ? 00:00:01 systemd 2 ? 00:00:00 kthreadd 3 ? 00:00:00 rcu_gp 4 ? 00:00:00 rcu_par_gp 6 ? 00:00:00 kworker/0:0H-kblockd 9 ? 00:00:00 mm_percpu_wq 10 ? 00:00:00 ksoftirqd/0 11 ? 00:00:02 rcu_sched 12 ?</description>
    </item>
    <item>
      <title>每天学命令-scp 远程拷贝文件</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-scp%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 06 Aug 2021 20:05:56 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-scp%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</guid>
      <description>看到同事要安装自己编译一天的库，本想传授一下“踩坑经验”，结果他用scp命令直接从已经安装好的电脑里复制了一份。心里一万只 XXX 在奔腾。
早知道先学学这个命令了。
可选参数 参数 功能 -1 强制 scp 命令使用协议 ssh1 -2 强制 scp 命令使用协议 ssh2 -4 强制 scp 命令使用协议 ssh2 -6 强制 scp 命令只使用 IPv6 寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩 -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条 -r 递归复制整个目录 -v 详细方式显示输出 -P 注意是大写的 P, port 是指定数据传输用到的端口号 使用实例 复制文件
scp local_file rmot_usr@rmot_ip:rmot_folderscp /opt/soft/ root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz </description>
    </item>
    <item>
      <title>每天学命令-grep 文本搜索</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-grep%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Thu, 05 Aug 2021 19:27:48 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-grep%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</guid>
      <description>grep全称global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来。这名字就怪吓人，如果熟练掌握正则表达式，配上这命令 Linux 里可以横着走了。
这个命令参数实在太多，加上正则表达式估计一张纸不够。那就直接上实例吧。
使用实例 在当前目录中，查找后缀带有cpp字样的文中包含test字符串的文件，并打印所在行
grep test *cppgrep --colorauto test *cpp # 用颜色标记 通过&amp;quot;-v&amp;quot;参数可以打印出不符合条件行的内容。
grep -v test *cpp 系统报警显示了时间，但是日志文件太大无法直接 cat 查看。(查询含有特定文本的文件，并拿到这些文本所在的行)。-n 或 --line-number 可以显示符合样式的那一行之前，标示出该行的列数编号。
grep -n &amp;#39;2019-10-24 00:01:11&amp;#39; *.log grep 静默输出，不会输出任何信息，如果命令运行成功返回 0，失败则返回非 0 值。一般用于条件测试。
grep -q &amp;#34;test&amp;#34; filename 在多级目录中对文本进行递归搜索
grep &amp;#34;text&amp;#34; . -r -n 配合管道，查找指定的进程信息
ps -ef | grep svn 查找指定的进程个数，-c计数
ps -ef | grep svn -c 常用正则表达式通配符
通配符 功能 c* 将匹配 0 个（即空白）或多个字符 c（c 为任一字符） .</description>
    </item>
    <item>
      <title>每天学命令-cat 可以查看文件的小猫咪</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-cat%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%8C%AB%E5%92%AA/</link>
      <pubDate>Wed, 04 Aug 2021 09:57:51 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-cat%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%8C%AB%E5%92%AA/</guid>
      <description>cat 可以将文件的内容方便地输出到屏幕上。但是它的全称concatenate意为“连接”，连接文件也是它的重要功能之一，很多人可能都不常用。只记得输出文件内容了。
可选参数 -n 或 --number #由 1 开始对所有输出的行数编号。-b 或 --number-nonblank #和 -n 相似，只不过对于空白行不编号。-s 或 --squeeze-blank #当遇到有连续两行以上的空白行，就代换为一行的空白行。-v 或 --show-nonprinting #使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。-E 或 --show-ends # 在每行结束处显示 $。-T 或 --show-tabs: #将 TAB 字符显示为 ^I。-A, --show-all #等价于 -vET。-e #等价于&amp;#34;-vE&amp;#34;选项；-t #等价于&amp;#34;-vT&amp;#34;选项； 使用实例 将文件内容输出到屏幕
➜ ~ cat test.txt This is firt line!This is second line!This is third line!This is fourth line!</description>
    </item>
    <item>
      <title>每天学命令-ln 软硬链接</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Tue, 03 Aug 2021 11:57:02 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/</guid>
      <description>Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。这有点像 Windows 环境下的快捷方式。介绍命令前了解一下软链接，硬链接具体是什么。
硬链接 Hard Link 在 Linux 系统中，每个文件对应一个 inode，文件的内容在存储在 inode 指向的 data block 中。要读取该文件的内容，需要通过文件所在的目录中记录的文件名找到文件的 inode 号，然后通过 inode 找到存储文件内容的 data block。当然多个文件名可以指向同一个inode。
使用ll命令显示文件的详细信息，-i参数显示其结点信息，其中最前面的一串数字就是inode信息。我们以/opt/test.txt文件为例，查看其结点信息。
dominic@hanhan:/opt$ ll -i test.txt 2498138 -rw-r--r-- 1 root root 4 8月 3 12:16 test.txt 使用 ln 命令在/opt/temp目录下创建一个 test.txt 文件的硬链接，然后观察其文件属性：
dominic@hanhan:/opt/temp$ sudo ln ../test.txt .dominic@hanhan:/opt/temp$ ll -i ../test.txt test.txt 2498138 -rw-r--r-- 2 root root 4 8月 3 12:16 ../test.txt2498138 -rw-r--r-- 2 root root 4 8月 3 12:16 test.</description>
    </item>
    <item>
      <title>每天学命令-ed 行编辑器</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ed%E8%A1%8C%E7%BC%96%E8%BE%91%E5%99%A8/</link>
      <pubDate>Mon, 02 Aug 2021 09:57:10 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ed%E8%A1%8C%E7%BC%96%E8%BE%91%E5%99%A8/</guid>
      <description>ed命令是文本编辑器，用于文本编辑。
ed是 Linux 中功能最简单的文本编辑程序，一次仅能编辑一行而非全屏幕方式的操作。很多命令和vim相似，平时开发中并不常用，但是在编辑大文本时还是会用到。
学学无妨毕竟这是 Unix 系统三大要件（编辑器，汇编器和 shell）之一。
ed编辑器有两种模式：命令模式和输入模式。命令模式下输入a,i,c,d可以进入对应的编辑模式，接下来可以输入任何想要输入的内容，输入完毕或者要切换命令时，可以输入.退出输入模式。
Commands a #添加到行i #添加到行首c #改变行d #删除行 Line Address . #buffer 中 当前行$ #最后一行n #第 n 行，行的范围是 [0,$]- or ^ #前一行-n or ^n #前 n 行+ or +n #后一行及后n行, or % #全部行，等同于 1,$; #当前行到最后一行 .,$/re/ #下一个包含正则 re 的行?re? #上一个包含正则 re 的行 使用实例 dominic@hanhan:~$ ed # 进入编辑模式This is a test text!</description>
    </item>
    <item>
      <title>每天学命令-wc 统计文件有多少字多少行</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-wc%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AD%97%E5%A4%9A%E5%B0%91%E8%A1%8C/</link>
      <pubDate>Fri, 30 Jul 2021 17:26:39 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-wc%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AD%97%E5%A4%9A%E5%B0%91%E8%A1%8C/</guid>
      <description>想知道自己代码写了多少行，可以一个wc命令搞定。
可选参数 -l：仅列出行； -w：仅列出多少字 (英文单字)； -m：多少字符 使用实例 统计hello.c文件夹下文件总共多少行
$ wc -l hello.c 14 hello.c 统计文件夹下文件的个数
ls -l | grep &amp;#34;^-&amp;#34; | wc -l 统计当前目录下文件的个数（包括子目录）
ls -lR| grep &amp;#34;^-&amp;#34; | wc -l 查看目录下文件夹 (目录) 的个数（包括子目录）
ls -lR | grep &amp;#34;^d&amp;#34; | wc -l 过滤ls的输出信息，只保留一般文件，只保留目录是grep &amp;quot;^d&amp;quot;。 </description>
    </item>
    <item>
      <title>每天学命令-find 查找文件</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-find%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 29 Jul 2021 11:05:43 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-find%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</guid>
      <description>命令格式 find [path] [expression] 在path下查找expression表示的文件
常用命令 一般常见就是自己不知道写的某个文件或者文件夹放哪里了，又或者只记住部分文件名。以下几个命令就能帮到你。
按文件名查找 find -name filename(查找结果显示路径)或者 find filename(查找结果不显示路径)find hello.cpp #当前目录下精确查找hello.cpp文件find hello #当前目录下精确查找hello文件find hello* #当前目录下模糊查找以hello为前缀的文件 按类型查找 这就是为查找文件夹用的。
find -type [fdlcb] name [fdlcb]都是类型，d就是目录，文件夹类型。
find / -type d -name &amp;#34;helloworld&amp;#34; #查找名为helloworld的文件夹 按文件名查找 以下就详细介绍一些参数
find -name &amp;#34;hello.cpp&amp;#34; # 搜索文件名，大小写敏感find -iname &amp;#34;hello.cpp&amp;#34; #大小写不敏感 按文件大小查找 find [path] -size 50Mfind / -size 10M # 查找系统中大小等于10M的文件find / -size +50M # 查找系统中大小大于50M的文件find / -size -30M # 查找系统中大小小于30M的文件 按时间来查找文件 Linux 会存储下面的时间：</description>
    </item>
    <item>
      <title>每天学命令-df/du查看磁盘剩余空间</title>
      <link>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-df-du%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Wed, 28 Jul 2021 10:13:58 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-df-du%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4/</guid>
      <description>df全称disk filesystem ，以磁盘分区为单位查看文件系统，可以查看磁盘文件占用空间，磁盘剩余空间等信息。
命令格式 df [] [] 可选参数 -a 全部文件系统列表-h 方便阅读方式显示-H 等于“-h”，但是计算式，1K=1000，而不是 1K=1024-i 显示 inode 信息-k 区块为 1024 字节-l 只显示本地文件系统-m 区块为 1048576 字节--no-sync 忽略 sync 命令-P 输出格式为 POSIX--sync 在取得磁盘信息前，先执行 sync 命令-T 文件系统类型 使用实例 df -T显示包含文件系统，类型，可用大小，已用大小，挂载点等信息。
dominic@hanhan:~$ df -T文件系统 类型 1K-块 已用 可用 已用% 挂载点udev devtmpfs 1985056 0 1985056 0% /devtmpfs tmpfs 403036 1304 401732 1% /run/dev/sda5 ext4 50824704 20826256 27386992 44% /tmpfs tmpfs 2015172 0 2015172 0% /dev/shmtmpfs tmpfs 5120 4 5116 1% /run/locktmpfs tmpfs 2015172 0 2015172 0% /sys/fs/cgroup/dev/loop0 squashfs 56832 56832 0 100% /snap/core18/1988/dev/loop1 squashfs 56832 56832 0 100% /snap/core18/2074 du全称disk usage可以查看文件，文件夹占用情况。</description>
    </item>
  </channel>
</rss>
