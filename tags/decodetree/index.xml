<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Decodetree on 夜云泊</title>
    <link>https://lifeislife.cn/tags/decodetree/</link>
    <description>Recent content in Decodetree on 夜云泊</description>
    <generator>Hugo -- 0.134.1</generator>
    <language>zh</language>
    <atom:link href="https://lifeislife.cn/tags/decodetree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>QEMU Decodetree详解</title>
      <link>https://lifeislife.cn/posts/qemu-decodetree%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/qemu-decodetree%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;p&gt;QEMU 在 decode 指令的时候，需要调用各平台所定义的 instruction decoders 来解析指令。如在 ARM 平台下，就定义了：&lt;code&gt;disas_arm_insn()&lt;/code&gt;、&lt;code&gt;disas_thumb_insn()&lt;/code&gt; 及 &lt;code&gt;disas_thumb2_insn()&lt;/code&gt; 等来分别负责 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>QEMU 在 decode 指令的时候，需要调用各平台所定义的 instruction decoders 来解析指令。如在 ARM 平台下，就定义了：<code>disas_arm_insn()</code>、<code>disas_thumb_insn()</code> 及 <code>disas_thumb2_insn()</code> 等来分别负责 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。</p>
<p>而 <code>Decodetree</code> 则是由 <code>Bastian Koppelmann</code> 于 2017 年在 移植 RISC-V QEMU 的时候所提出来的机制 (详见：<a href="https://lists.gnu.org/archive/html/qemu-devel/2017-07/msg07735.html">讨论邮件1</a>、<a href="https://lists.gnu.org/archive/html/qemu-devel/2017-10/msg05046.html">讨论邮件2</a>)。提出该机制主要是因为过往的 instruction decoders (如：ARM) 都是采用一堆 <code>switch-case</code> 来做判断。不仅难阅读，也难以维护。</p>
<p>因此 <code>Bastian Koppelmann</code> 就提出了 <code>Decodetree</code> 的机制，开发者只需要通过 <code>Decodetree</code> 的语法定义各个指令的格式，便可交由 <code>Decodetree</code> 来动态生成对应包含 <code>switch-case</code> 的 instruction decoder <code>.c</code> 文档。</p>
<p><code>Decodetree</code> 特别适合像 RISC-V 这种具有<strong>固定指令格式</strong>的 ISA。</p>
<ul>
<li>因为各字段都在固定的位置，(如 RISC-V 的 <code>opcode</code> 都是固定在 <code>bits[6..0]</code> 的位置)。</li>
</ul>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F18%2F5a051d22c43a2ce34069fecd2e4fb8c0.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F18%2F5a051d22c43a2ce34069fecd2e4fb8c0.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p><code>Decodetree</code> 其实是由 Python script (<code>./scripts/decodetree.py</code>) 所生成的。使用文档可以参考：<code>./docs/devel/decodetree.rst</code>，里面有详细定义了其语法的格式。QEMU 在编译时，会调用 <code>Decodetree</code>，根据各平台所定义的 decode 文档，动态生成对应的 decoder。</p>
<ul>
<li>
<p>如 RISC-V 的 instruction decoders 就是被定义在：<code>./target/riscv/*.decode</code> 中。其 <code>Makefile.obj</code> 就有如下的声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">DECODETREE = $(SRC_PATH)/scripts/decodetree.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">decode32-y = $(SRC_PATH)/target/riscv/insn32.decode
</span></span><span class="line"><span class="cl">decode32-$(TARGET_RISCV64) += $(SRC_PATH)/target/riscv/insn32-64.decode
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">target/riscv/decode_insn32.inc.c: $(decode32-y) $(DECODETREE)
</span></span><span class="line"><span class="cl">	$(call quiet-command, \
</span></span><span class="line"><span class="cl">	  $(PYTHON) $(DECODETREE) -o $@ --static-decode decode_insn32 \
</span></span><span class="line"><span class="cl">          $(decode32-y), &#34;GEN&#34;, $(TARGET_DIR)$@)
</span></span></code></pre></div></li>
</ul>
<p><code>Decodetree</code> 的语法共分为：Fields、Argument Sets、Formats、Patterns 五部分。本文将介绍如何通过 <code>Decodetree</code> 的语法，来动态生成一个指令的 decoder。</p>
<h2 id="field">Field</h2>
<p><code>Field</code> 定义如何取出一指令中，各<strong>字段</strong> (eg: <code>rd</code>, <code>rs1</code>, <code>rs2</code>, <code>imm</code>) 的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">field_def     := &#39;%&#39; identifier ( unnamed_field )* ( !function=identifier )?
</span></span><span class="line"><span class="cl">unnamed_field := number &#39;:&#39; ( &#39;s&#39; ) number
</span></span></code></pre></div><p>其语法由 <code>%</code> 开头，随后紧接着一个 <code>identifier</code> 及零个或多个 <code>unamed_field</code>，并可再加上可选的 <code>!function</code>。</p>
<ul>
<li><code>identifier</code> 可由开发者自定，如：<code>rd</code>、<code>imm</code>… 等。</li>
<li><code>unamed_field</code> 定义了该字段的所在比特。第一个数字定义了该字段的 <code>least-significant bit position</code>，第二个数字则定义了该字段的<code>比特长度</code>。另外可加上可选的 <code>s</code> 字符来标明在取出该字段后，是否需要做 符号扩展。
<ul>
<li>Eg：<code>%rd 7:5</code> 代表 <code>rd</code> 占了指令中 bits 7 ~ bits 11 的位置 (insn[11:7])，共 5 bits。</li>
</ul>
</li>
<li><code>!function</code> 定义在截取出该字段的值后，所会再调用的 function。</li>
</ul>
<p><code>Field</code> (32-bits 指令) 最后会生成对应的 <code>extract32()</code> 及 <code>sextract32()</code> 代码，以用来取得指令中各字段的值：</p>
<h3 id="field-示例">Field 示例</h3>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Input</th>
          <th style="text-align: left">Generated code</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">%disp 0:s16</td>
          <td style="text-align: left">sextract(i, 0, 16)</td>
      </tr>
      <tr>
          <td style="text-align: left">%imm9 16:6 10:3</td>
          <td style="text-align: left">extract(i, 16, 6) &laquo; 3</td>
      </tr>
      <tr>
          <td style="text-align: left">%disp12 0:s1 1:1 2:10</td>
          <td style="text-align: left">sextract(i, 0, 1) &laquo; 11</td>
      </tr>
      <tr>
          <td style="text-align: left">%shimm8 5:s8 13:1 !function=expand_shimm8</td>
          <td style="text-align: left">expand_shimm8(sextract(i, 5, 8)) &laquo; 1</td>
      </tr>
  </tbody>
</table>
<p>以 RISC-V 的 <code>U-type</code> 指令为例：</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F18%2Ffb558390c2c5a8c8b9e1645d90cabfc8.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F18%2Ffb558390c2c5a8c8b9e1645d90cabfc8.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p>其中，<code>imm</code> 占 <code>insn[31:12]</code>，共20位，<code>rd</code> 占 <code>insn[11:7]</code>，且 <code>imm</code> 需要做 符号扩展 后 <code>左移 12 位</code> (<code>20-bit immediate is shifted left by 12 bits to form U immediates</code>)。因此，如果我们要定义 RISC-V 的 <code>U-type</code> 指令，则可以声明成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">%rd       7:5
</span></span><span class="line"><span class="cl">%imm_u    12:s20                 !function=ex_shift_12
</span></span></code></pre></div><blockquote>
<p>20 表示占 20 bits</p>
</blockquote>
<p>最后会生成如下的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn32_extract_u</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_u</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">=</span> <span class="nf">ex_shift_12</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nf">sextract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><code>static void decode_insn32_extract_u()</code> 是由下文 Format 定义所生成的，而 <code>arg_u *a</code> 则是由 Argument Set 定义所生成的，将会在后面的部分再做说明。</p>
</blockquote>
<p>可以看到：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">=</span> <span class="nf">ex_shift_12</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nf">sextract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li>
<p><code>a-&gt;imm</code> 是由 <code>insn[31:12]</code> 所取得并做符号扩展，且会再调用 <code>ex_shift_12()</code> 来 <code>左移 12 个 bits</code>。</p>
<ul>
<li>
<p>P.S. RISC-V 的 <code>ex_shift_12()</code> 是通过定义在<code>./target/riscv/translate.c</code> 中 <code>EX_SH</code> 这个 macro 所展开的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define EX_SH(amount) \
</span></span></span><span class="line"><span class="cl"><span class="cp">    static int ex_shift_##amount(DisasContext *ctx, int imm) \
</span></span></span><span class="line"><span class="cl"><span class="cp">    {                                         \
</span></span></span><span class="line"><span class="cl"><span class="cp">        return imm &lt;&lt; amount;                 \
</span></span></span><span class="line"><span class="cl"><span class="cp">    }
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="nf">EX_SH</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">EX_SH</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">EX_SH</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">EX_SH</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">EX_SH</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><code>a-&gt;rd</code> 是由 <code>insn[11:7]</code> 所取得。</p>
</li>
</ul>
<p>此外，在 <code>Decodetree</code> 的 spec 中也有提到，我们可以通过只定义 <code>!function</code> 来直接调用该 function。在这种情况下，只有 <code>DisasContext</code> 会被传入该 function。</p>
<p>如 ARM Thumb <code>./target/arm/t16.decode</code> 就有定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl"># Set S if the instruction is outside of an IT block.
</span></span><span class="line"><span class="cl">%s               !function=t16_setflags
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">disas_t16_extract_addsub_2i</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_s_rri_rot</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rn</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="nf">t16_setflags</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>请注意，未包含任何 <code>unnamed_fields</code> 或 <code>!function</code> 的 <code>Field</code> 会被视为错误。</p>
<hr>
<h2 id="argument-set">Argument Set</h2>
<p><code>Argument Set</code> 定义用来保存从指令中所截取出来各字段的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">args_def    := &#39;&amp;&#39; identifier ( args_elt )+ ( !extern )?
</span></span><span class="line"><span class="cl">args_elt    := identifier
</span></span></code></pre></div><p>其语法由 <code>&amp;</code> 开头，随后紧接着一个或多个的 <code>identifier</code> ，并可再加上可选的 <code>!extern</code> 。</p>
<ul>
<li><code>identifier</code> 可由开发者自订，如：<code>regs</code>、<code>loadstore</code>… 等。</li>
<li><code>!extern</code> 则表示是否在其他地方已经由其他的 decoder 定义过。如果有该字段，就<strong>不会</strong>再次生成对应的 <code>argument set struct</code>。</li>
</ul>
<h3 id="argument-set-示例">Argument Set 示例</h3>
<p>例1：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">&amp;ampreg3 ra rb rc
</span></span></code></pre></div><p>会生成以下的 <code>argument set struct</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ra</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">arg_reg3</span><span class="p">;</span>
</span></span></code></pre></div><p>例2：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">&amp;loadstore reg base offset
</span></span></code></pre></div><p>则会生成以下的 <code>argument set struct</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">arg_loadstore</span><span class="p">;</span>
</span></span></code></pre></div><p>因此，以刚刚的 RISC-V <code>U-type</code> 指令为例，我们需要从指令中截取 <code>imm</code> 及 <code>rd</code> 字段的值，可以声明其 <code>argument set</code> 如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">&amp;u    imm rd
</span></span></code></pre></div><p>最后会生成以下的 <code>argument set struct</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">imm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">arg_u</span><span class="p">;</span>
</span></span></code></pre></div><p>此 <code>argument set struct</code> 会被传入由 <code>Format</code> 定义所生成的 extract function：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn32_extract_u</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_u</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">=</span> <span class="nf">ex_shift_12</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nf">sextract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>所传入的<code>arg_u</code> 会保存从指令中截取出的 <code>imm</code> 及 <code>rd</code> 字段的值，待后续使用。</p>
<h2 id="format">Format</h2>
<p><code>Format</code> 定义了指令的格式 (如 RISC-V 中的 <code>R</code>、<code>I</code>、<code>S</code>、<code>B</code>、<code>U</code>、<code>J-type</code>)，并会生成对应的 decode function。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">fmt_def      := &#39;@&#39; identifier ( fmt_elt )+
</span></span><span class="line"><span class="cl">fmt_elt      := fixedbit_elt | field_elt | field_ref | args_ref
</span></span><span class="line"><span class="cl">fixedbit_elt := [01.-]+
</span></span><span class="line"><span class="cl">field_elt    := identifier &#39;:&#39; &#39;s&#39;? number
</span></span><span class="line"><span class="cl">field_ref    := &#39;%&#39; identifier | identifier &#39;=&#39; &#39;%&#39; identifier
</span></span><span class="line"><span class="cl">args_ref     := &#39;&amp;&#39; identifier
</span></span></code></pre></div><p>其语法由 <code>@</code> 开头，随后紧接着一个 <code>identifier</code> 及一个以上的 <code>fmt_elt</code>。</p>
<ul>
<li>
<p><code>identifier</code> 可由开发者自订，如：<code>opr</code>、<code>opi</code>… 等。</p>
</li>
<li>
<p><code>fmt_elt</code> 则可以采用以下不同的语法：</p>
<ul>
<li>
<p><code>fixedbit_elt</code> 包含一个或多个 <code>0</code>、<code>1</code>、<code>.</code>、<code>-</code>，每一个代表指令中的 1 个 bit。</p>
<ul>
<li><code>.</code> 代表该 bit 可以用 <code>0</code> 或是 <code>1</code> 来表示。</li>
<li><code>-</code> 代表该 bit 完全被忽略。</li>
</ul>
</li>
<li>
<p><code>field_elt</code> 可以用 Field 的语法来声明。</p>
<ul>
<li>Eg：<code>ra:5</code>、<code>rb:5</code>、<code>lit:8</code></li>
</ul>
</li>
<li>
<p><code>field_ref</code> 有下列两种格式 (以下范例参考上文所定义之 Field)：</p>
<ul>
<li>
<p><code>'%' identifier</code>：直接参考一个被定义过的 <code>Field</code>。</p>
<ul>
<li>
<p>如：<code>%rd</code>，会生成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><code>identifier '=' '%' identifier</code>：直接参考一个被定义过的 <code>Field</code>，但通过第一个 <code>identifier</code> 来重命名其所对应的 <code>argument</code> 名称。此方式可以用来指定不同的 <code>argument</code> 名称来参考至同一个 <code>Field</code>。</p>
<ul>
<li>
<p>如：<code>my_rd=%rd</code>，会生成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">a</span><span class="o">-&gt;</span><span class="n">my_rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> 
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>args_ref</code> 指定所传入 decode function 的 <code>Argument Set</code>。若没有指定 <code>args_ref</code> 的话，<code>Decodetree</code> 会根据 <code>field_elt</code> 或 <code>field_ref</code> 自动生成一个 <code>Argument Set</code>。此外，一个 <code>Format</code> 最多只能包含一个 <code>args_ref</code>。</p>
</li>
</ul>
</li>
</ul>
<p>当 <code>fixedbit_elt</code> 或 <code>field_ref</code> 被定义时，该 <code>Foramt</code> 的所有的 bits 都必须被定义 (可通过 <code>fixedbit_elt</code> 或 <code>.</code> 来定义各个 bits，<code>空格</code>会被忽略)。</p>
<h3 id="format-示例">Format 示例</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">@opi    ...... ra:5 lit:8    1 ....... rc:5
</span></span></code></pre></div><p>定义了 <code>op1</code> 这个 <code>Format</code>，其中：</p>
<ul>
<li>insn[31:26] 可为 <code>0</code> 或 <code>1</code>。</li>
<li>insn[25:21] 为 <code>ra</code>。</li>
<li>insn[20:13] 为 <code>lit</code>。</li>
<li>insn[12] 固定为 <code>1</code>。</li>
<li>insn[11:5] 可为 <code>0</code> 或 <code>1</code>。</li>
<li>insn[4:0] 为 <code>rc</code>。</li>
</ul>
<p>此 <code>Format</code> 会生成以下的 decode function：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">lit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ra</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">arg_decode_insn320</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn32_extract_opi</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_decode_insn320</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">ra</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">lit</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rc</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>由于我们没有指定 <code>args_ref</code>，因此 <code>Decodetree</code> 根据了 <code>field_elt</code> 的定义，自动生成了 <code>arg_decode_insn320</code> 这个 <code>Argument Set</code>。</p>
<p>以 RISC-V <code>I-type</code> 指令为例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl"># Fields:
</span></span><span class="line"><span class="cl">%rs1       15:5
</span></span><span class="line"><span class="cl">%rd        7:5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># immediates:
</span></span><span class="line"><span class="cl">%imm_i    20:s12
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Argment sets:
</span></span><span class="line"><span class="cl">&amp;i    imm rs1 rd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@i       ........ ........ ........ ........ &amp;i      imm=%imm_i     %rs1 %rd
</span></span></code></pre></div><p>定义了 <code>i</code> 这个 <code>Format</code>，其中：</p>
<ul>
<li>insn[31:20] 为 <code>imm</code>，且为 符号扩展。</li>
<li>insn[19:5] 为 <code>rs1</code>。</li>
<li>insn[11:7] 为 <code>rd</code>。</li>
</ul>
<p>此外，我们可以看到：</p>
<ul>
<li>此 <code>Format</code> 指定了 <code>Argument Set</code>：<code>&amp;i</code>。 <code>&amp;i</code> 中必须包含所有有用到的 <code>arguments</code> (也就是：<code>imm</code>、<code>rs1</code> 及 <code>rd</code>)</li>
<li><code>imm</code> 是通过重命名的方式来参考 <code>%imm_i</code> 这个 <code>Field</code>。</li>
</ul>
<p>此范例会生成以下的 decode function：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">imm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rs1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">arg_i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn32extract_i</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_i</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">=</span> <span class="nf">sextract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rs1</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>相比于第一个范例，由于这次我们有指定 <code>args_ref</code>：<code>&amp;i</code>，因此对应的 <code>arg_i</code> 会被传入 decode function。</p>
<hr>
<p>回到先前的 RISC-V <code>U-type</code> 指令，我们可以如同 <code>I-type</code> 指令定义其格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl"># Fields:
</span></span><span class="line"><span class="cl">%rd        7:5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># immediates:
</span></span><span class="line"><span class="cl">%imm_u    12:s20                 !function=ex_shift_12
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Argument sets:
</span></span><span class="line"><span class="cl">&amp;u    imm rd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@u       ....................      ..... ....... &amp;u      imm=%imm_u          %rd
</span></span></code></pre></div><p>定义了 <code>u</code> 这个 <code>Format</code>，其中：</p>
<ul>
<li>insn[31:12] 为 <code>imm</code>，且为 符号扩展。</li>
<li>insn[11:7] 为 <code>rd</code>。</li>
</ul>
<p>会生成以下的 decode function：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">imm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">arg_u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn32_extract_u</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_u</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">=</span> <span class="nf">ex_shift_12</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nf">sextract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们可以看到：</p>
<ul>
<li>此 <code>Format</code> 指定了 <code>Argument Set</code>：<code>&amp;u</code>。 <code>&amp;u</code> 中必须包含所有有用到的 <code>arguments</code> (也就是：<code>imm</code>、<code>rd</code>)</li>
<li><code>imm</code> 是通过重命名的方式来参考 <code>%imm_u</code> 这个 <code>Field</code>。</li>
</ul>
<h2 id="pattern">Pattern</h2>
<p><code>Pattern</code> 实际定义了一个指令的 decode 方式。<code>Decodetree</code> 会根据 <code>Patterns</code> 的定义，来动态产生出对应的 <code>switch-case</code> decode 判断分支。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">pat_def      := identifier ( pat_elt )+
</span></span><span class="line"><span class="cl">pat_elt      := fixedbit_elt | field_elt | field_ref | args_ref | fmt_ref | const_elt
</span></span><span class="line"><span class="cl">fmt_ref      := &#39;@&#39; identifier
</span></span><span class="line"><span class="cl">const_elt    := identifier &#39;=&#39; number
</span></span></code></pre></div><p>其语法由用户所定义的 <code>identifier</code>，随后紧接着一个以上的 <code>pat_elt</code>。</p>
<ul>
<li>
<p><code>identifier</code> 可由开发者自订，如：<code>addl_r</code>、<code>addli</code> … 等。</p>
</li>
<li>
<p><code>pat_elt</code> 则可以采用以下不同的语法：</p>
<ul>
<li><code>fixedbit_elt</code> 与在 <code>Format</code> 中 <code>fixedbit_elt</code> 的定义相同。</li>
<li><code>field_elt</code> 与在 <code>Format</code> 中 <code>field_elt</code> 的定义相同。</li>
<li><code>field_ref</code> 与在 <code>Format</code> 中 <code>field_ref</code> 的定义相同。</li>
<li><code>args_ref</code> 与在 <code>Format</code> 中 <code>args_ref</code> 的定义相同。</li>
<li><code>fmt_ref</code> 直接参考一个被定义过的Format。</li>
<li><code>const_elt</code> 可以直接指定某一个 <code>argument</code> 的值。</li>
</ul>
</li>
</ul>
<p>由于 <code>Pattern</code> 实际定义了一个指令的 decode 方式，因此<strong>所有的 bits</strong> 及 <strong>arguments (如果有参考 args_ref 的话)</strong>  都必须明确的被定义，如果在搭配了所有的 <code>pat_elt</code> 后还有未定义的 bits 或是 arguments 的话，<code>Decodetree</code> 便会报错。</p>
<p>此外，<code>Pattern</code> 所产生出来的 decoder，最后还会调用对应的 <code>translator function</code>。<code>translator function</code> 需开发者自行定义。</p>
<h3 id="pattern-示例">Pattern 示例</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">addl_i   010000 ..... ..... .... 0000000 ..... @opi
</span></span></code></pre></div><p>定义了 <code>addl_i</code> 这个指令的 <code>Pattern</code>，其中：</p>
<ul>
<li>insn[31:26] 为 <code>010000</code>。</li>
<li>insn[11:5] 为 <code>0000000</code>。</li>
<li>参考了 Format 示例中 定义的 <code>@opi</code> <code>Format</code>。</li>
<li>由于 <code>Pattern</code> 的<strong>所有 bits</strong> 都必须明确的被定义，因此 <code>@opi</code> 必须包含其余 <code>insn[25:12]</code> 及 <code>insn[4:0]</code> 的格式定义，否则 <code>Decodetree</code> 便会报错。</li>
</ul>
<p>最后 <code>addl_i</code> 的 decoder 还会调用 <code>trans_addl_i()</code> 这个 <code>translator function</code>。</p>
<p>搭配之前介绍的 Fields、Argument Sets 及 Formats，让我们再看几个完整的例子应该会更清楚 <code>Decodetree</code> 是怎产生一个指令的 decoder 的。</p>
<p>首先是 RISC-V 的 <code>lui</code> 及 <code>auipc</code> 指令：</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F19%2F922be39211d73158159edf9993a2c906.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F19%2F922be39211d73158159edf9993a2c906.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl"># Fields:
</span></span><span class="line"><span class="cl">%rd        7:5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># immediates:
</span></span><span class="line"><span class="cl">%imm_u    12:s20                 !function=ex_shift_12
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Argument sets:
</span></span><span class="line"><span class="cl">&amp;u    imm rd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Formats:
</span></span><span class="line"><span class="cl">@u       ....................      ..... ....... &amp;u      imm=%imm_u          %rd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Patterns
</span></span><span class="line"><span class="cl">lui      ....................       ..... 0110111 @u
</span></span><span class="line"><span class="cl">auipc    ....................       ..... 0010111 @u
</span></span></code></pre></div><p>会产生以下 <code>lui</code> 及 <code>auipc</code> 的 decoder：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">imm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">arg_u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn32_extract_u</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_u</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">=</span> <span class="nf">ex_shift_12</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nf">sextract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">decode_insn32</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">arg_u</span> <span class="n">f_u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">decode_insn32_extract_u</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_u</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x0000007f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mh">0x00000017</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">trans_auipc</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_u</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mh">0x00000037</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">trans_lui</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_u</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>回顾到目前为止所介绍的：</p>
<ul>
<li>
<p><code>Argument Sets</code>：<code>&amp;u</code> 这个 <code>argument set</code> 包含了 <code>imm</code> 及 <code>rd</code> 这两个 <code>arguments</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">imm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">arg_u</span><span class="p">;</span>
</span></span></code></pre></div></li>
<li>
<p><code>Fields</code>： <code>imm</code> 及 <code>rd</code> 分别位在 insn[31:12] 及 insn[11:7]，且 <code>imm</code> 为 符号扩展。最后在截取出 <code>imm</code> 的值后，还会调用 <code>ex_shift_12()</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">=</span> <span class="nf">ex_shift_12</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nf">sextract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span></code></pre></div></li>
<li>
<p><code>Formats</code>：<code>@u</code> 定义了 RISC-V <code>U-type</code> 指令的格式</p>
<ul>
<li>参考了 <code>&amp;u</code> 这个 <code>Argument Set</code>，因此 decode function 会传入 <code>arg_u</code> 作为参数。</li>
<li>insn[31:12] 参考了 <code>imm_u</code> 这个 <code>Field</code> (并重命名为 <code>imm</code>)</li>
<li>insn[11:7] 参考了 <code>rd</code> 这个 <code>Field</code>。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn32_extract_u</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_u</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">=</span> <span class="nf">ex_shift_12</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nf">sextract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p><code>Patterns</code>：</p>
<ul>
<li><code>lui</code> 的 <code>opcode</code> (insn[6:0]) 为 <code>0010111</code>，也就是 <code>0x17</code>，在产生出来的 <code>switch-case</code> 中可以看到其对应的 <code>case</code>。</li>
<li><code>lui</code> 的 decoder 最后调用了 <code>trans_lui()</code>，并传入 <code>DisasContext</code> 及经由 <code>decode_insn32_extract_u()</code> 所解析出来的 <code>arg_u</code>。</li>
<li><code>auipc</code> 的 <code>opcode</code> (insn[6:0]) 为 <code>0110111</code>，也就是 <code>0x37</code>，在产生出来的 <code>switch-case</code> 中可以看到其对应的 <code>case</code>。</li>
<li><code>auipc</code> 的 decoder 最后调用了 <code>trans_auipc()</code>，并传入 <code>DisasContext</code> 及经由 <code>decode_insn32_extract_u()</code> 所解析出来的 <code>arg_u</code>。</li>
<li>P.S. 这边由于 <code>Decodetree</code> 发现 <code>lui</code> 及 <code>auipc</code> 可以共用 <code>decode_insn32_extract_u()</code>，因此将其提到了 <code>switch-case</code> 之外。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">decode_insn32</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">arg_u</span> <span class="n">f_u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">decode_insn32_extract_u</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_u</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x0000007f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mh">0x00000017</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">trans_auipc</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_u</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mh">0x00000037</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">trans_lui</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_u</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们另外可以发现，<code>Pattern</code> + <code>Format</code> 把所有的 32-bits 都给了明确的定义：</p>
<ul>
<li><code>Pattern</code> 定义了 <code>opcode</code> (insn[6:0])。</li>
<li><code>Format</code> 参考了 <code>imm</code> (insn[31:12]) 及 <code>rd</code> (insn[11:7])。</li>
</ul>
<p>如果有任何未明确定义的 bits 的话，<code>Decodetree</code> 便会报错，例如如果我们将 <code>lui</code> 的 <code>opcode</code> 最高 2 个 bits (insn[6:5]) 由 <code>01</code> 改成 <code>..</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">lui      ....................       ..... ..10111 @u
</span></span></code></pre></div><p><code>Decodetree</code> 在解析时，便会报错：</p>
<blockquote>
<p>./insn32.decode:17: error: (‘bits left unspecified (0x00000060)’,)</p>
</blockquote>
<p><code>Decodetree</code> 提醒我们，insn[6:5] (<code>0x00000060</code>) 尚未给出明确定义，并会显示出其错误的行数。</p>
<p><code>trans_lui()</code> 和 <code>trans_auipc()</code> 被定义在 <code>target/riscv/insn_trans/trans_rvi.inc.c</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">trans_lui</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_lui</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">tcg_gen_movi_tl</span><span class="p">(</span><span class="n">cpu_gpr</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">],</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">trans_auipc</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_auipc</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">tcg_gen_movi_tl</span><span class="p">(</span><span class="n">cpu_gpr</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">],</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pc_next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到 <code>trans_*()</code> 负责实际指令的业务逻辑及产生对应的 <code>TCG codes</code>。</p>
</li>
</ul>
<p>如同先前所介绍，<code>Patterns</code> 的 <code>pat_elt</code> 也可以采用 <code>field_elt</code> 语法，如 RISC-V 的 <code>fence</code> 指令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">fence    ---- pred:4 succ:4 ----- 000 ----- 0001111
</span></span></code></pre></div><ul>
<li>insn[27:24] 为 <code>pred</code>。</li>
<li>insn[23:20] 为 <code>succ</code>。</li>
<li>insn[14:12] 固定为 <code>000</code>。</li>
<li>insn[6:0] 为 <code>opcode</code> (<code>0001111</code>)。</li>
<li>没有参考任何的 <code>Format</code>。</li>
<li>剩下的 insn[31:28]、insn[19:15]、insn[11:7] 被声明为 <code>-</code>，因此就算没有被明确定义也没有关系。</li>
</ul>
<p>所生成 <code>fence</code> 的 decoder 如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">pred</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">succ</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">arg_decode_insn320</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn32_extract_decode_insn32_Fmt_0</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_decode_insn320</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">pred</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">succ</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">decode_insn32</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">arg_decode_insn320</span> <span class="n">f_decode_insn320</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">decode_insn32_extract_decode_insn32_Fmt_0</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_decode_insn320</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x0000707f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mh">0x0000000f</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">trans_fence</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_decode_insn320</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>值得注意的是，虽然这次我们没有参考任何的 <code>Argument Set</code>，但 <code>Decodetree</code> 还是替我们生成了一个包含 <code>pred</code> 和 <code>succ</code> 的 <code>arg_decode_insn320</code> 。</p>
<p><code>trans_fence()</code> 同样是被定义在 <code>./target/riscv/insn_trans/trans_rvi.inc.c</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">trans_fence</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_fence</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="nf">tcg_gen_mb</span><span class="p">(</span><span class="n">TCG_MO_ALL</span> <span class="o">|</span> <span class="n">TCG_BAR_SC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="pattern-groups">Pattern Groups</h2>
<p><code>Pattern Groups</code> 由一个以上的 <code>Patterns</code> 所组成，其主要差别是不同 <code>Patterns</code> 之间的 bits 可以 overlap。当同组中有多个 <code>Patterns</code> 时，会依据该组中各 <code>Pattern</code> 的声明顺序依序判断目前的指令是否符合其定义。除此之外，当符合的 <code>Pattern</code> 其 <code>trans_*()</code> 回传值为 <code>false</code> 时，也会被视为<strong>不相符</strong>，而继续判断该组中的下一个 <code>Pattern</code>。因此 <code>Pattern Groups</code> 非常适合将多个相似格式的指令给组成同一个 <code>Pattern Group</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">group    := &#39;{&#39; ( pat_def | group )+ &#39;}&#39;
</span></span></code></pre></div><p>各 <code>Pattern Group</code> 以 <code>{</code> 开头，并以 <code>}</code> 结尾，且允许 <code>nested pattern groups</code> 的存在，其他语法皆与 <code>Pattern</code> 相同。</p>
<h3 id="pattern-group-示例">Pattern Group 示例</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  {
</span></span><span class="line"><span class="cl">    nop   000010 ----- ----- 0000 001001 0 00000
</span></span><span class="line"><span class="cl">    copy  000010 00000 r1:5  0000 001001 0 rt:5
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  or      000010 rt2:5 r1:5  cf:4 001001 0 rt:5
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>会产生以下的 decoder：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">switch</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0xfc000fe0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="mh">0x08000240</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x0000f000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x0000001f</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">            <span class="nf">extract_decode_Fmt_0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_decode0</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">trans_nop</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_decode0</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">((</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x03e00000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">          <span class="nf">extract_decode_Fmt_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_decode1</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="nf">trans_copy</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_decode1</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				　
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">extract_decode_Fmt_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_decode2</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">trans_or</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_decode2</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当指令的值符合 <code>nop</code> 及 <code>copy</code> 这个内层 <code>Pattern Group</code> 时，会先判断该指令是否符合 <code>nop</code> 指令的定义，且 <code>trans_nop()</code> 的回传值为 <code>true</code>。否则的话，就会继续判断是否符合同组中的 <code>copy</code> 指令。若都不符，就会再判断是否符合外层 <code>Pattern Group</code> 的 <code>or</code> 指令。若仍不符，才会回传 <code>false</code> 表示 decode 失败。</p>
<p>与单纯使用 <code>Pattern</code> 最大不同的是，当一 <code>Pattern</code> 的 <code>trans_*()</code> 回传值为 <code>false</code> 时，不会直接回传 <code>false</code> (代表 decode 失败)，而是会接续着判断后续的 <code>Patterns</code> 是否相符。</p>
<p>RISC-V Compressed-Extension 中的 <code>c.ebreak</code>、<code>c.jalr</code>、及 <code>c.add</code> 指令，由于这三个指令的格式非常相似，因此非常适合使用 <code>Pattern Group</code> 来定义：</p>
<p>RISC-V spec. 中定义：</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F19%2F722c64cc1a321ef23fab81e722a24154.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F19%2F722c64cc1a321ef23fab81e722a24154.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<ul>
<li><code>C.EBREAK</code>指令与<code>C.ADD</code>指令共享相同的<code>opcode</code>，但是<code>rd</code>和<code>rs2</code>都为<code>zero</code>，因此也可以使用<code>CR</code>格式。</li>
<li><code>C.JALR</code>指令只有在<code>rs1≠x0</code>时才有效；当<code>rs1=x0</code>时，对应的代码点是<code>C.EBREAK</code>指令。</li>
<li><code>C.ADD</code>指令只有在<code>rs2≠x0</code>时才有效；当<code>rs2=x0</code>时，对应的代码点是<code>C.JALR</code>和<code>C.EBREAK</code>指令。具有<code>rs2̸=x0</code>和<code>rd=x0</code>的代码点是<code>HINTs</code>。</li>
</ul>
<p><code>c.ebreak</code>、<code>c.jalr</code>、<code>c.add</code> 三个指令：</p>
<ul>
<li>insn[15:13]、insn[12]、insn[1:0] 的值皆相同。</li>
<li>当 insn[11:7] 且 insn[6:2] 的值皆为 <code>0</code> (<code>rs1=0</code> 且 <code>rs2=0</code>) 时为 <code>c.ebreak</code> 指令。</li>
<li>当只有 insn[11:7] 的值为 <code>0</code> (<code>rs1=0</code> 且 <code>rs2≠0</code>) 时为 <code>c.jalr</code> 指令。</li>
<li>否则为 <code>c.add</code> 指令 (<code>rs1≠x0</code> 且 <code>rs2≠0</code>)。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl"># Fields
</span></span><span class="line"><span class="cl">%rd        7:5
</span></span><span class="line"><span class="cl">%rs2_5     2:5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Argument Sets
</span></span><span class="line"><span class="cl">&amp;r         rd rs1 rs2   !extern
</span></span><span class="line"><span class="cl">&amp;i         imm rs1 rd   !extern
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Formats
</span></span><span class="line"><span class="cl">@cr        ....  ..... .....  .. &amp;r      rs2=%rs2_5       rs1=%rd     %rd
</span></span><span class="line"><span class="cl">@c_jalr    ... . .....  ..... .. &amp;i      imm=0 rs1=%rd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Pattern Groups
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  ebreak          100 1  00000  00000 10
</span></span><span class="line"><span class="cl">  jalr            100 1  .....  00000 10 @c_jalr rd=1  # C.JALR
</span></span><span class="line"><span class="cl">  add             100 1  .....  ..... 10 @cr
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>所生成的 decoder 如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn16_extract_c_jalr</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_i</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">imm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rs1</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn16_extract_cr</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_r</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rs2</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rs1</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nf">extract32</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_insn16_extract_decode_insn16_Fmt_2</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">arg_decode_insn162</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">decode_insn16</span><span class="p">(</span><span class="n">DisasContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">insn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">arg_decode_insn162</span> <span class="n">f_decode_insn162</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">arg_i</span> <span class="n">f_i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">arg_r</span> <span class="n">f_r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x0000f003</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mh">0x00009002</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x00000ffc</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">            <span class="nf">decode_insn16_extract_decode_insn16_Fmt_2</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_decode_insn162</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">trans_ebreak</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_decode_insn162</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x0000007c</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">            <span class="nf">decode_insn16_extract_c_jalr</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_i</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">u</span><span class="p">.</span><span class="n">f_i</span><span class="p">.</span><span class="n">rd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">trans_jalr</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_i</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="nf">decode_insn16_extract_cr</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_r</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">trans_add</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">f_r</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当指令格式符合 <code>c.ebreak</code>、<code>c.jalr</code>、<code>c.add</code> 的 <code>Pattern Group</code> 时，会依序判断该指令是否符合 <code>c.ebreak</code>、<code>c.jalr</code>、<code>c.add</code> 的定义以及其对应的 <code>trans_*()</code>。</p>
<p>另外值得一提的是，在 <code>c_jalr</code> <code>Format</code> 和 <code>jalr</code> <code>Pattern</code> 中有分别指定其 <code>imm</code> 及 <code>rd</code> 的值为 <code>0</code>，所生成的 codes 也会分别在对应的地方将该值设为 <code>0</code> (见 codes 注解说明)。</p>
<h2 id="总结">总结</h2>
<p>以上就是 <code>Decodetree</code> 的语法说明。通过 <code>Decodetree</code>，我们不用再像以前以样写一大包的 <code>switch-case</code> 来 decode 指令。将不同类型的指令写至不同的 decode 档，不仅方便维护，阅读起来也更为容易。</p>
<hr>
<ul>
<li><code>--translate</code>：translator function 的 prefix，默认为 <code>trans</code>。一旦指定后，translator function 的 scope 就不会再是 <code>static</code>。</li>
<li><code>--decode</code>：decode function 的 prefix，默认为 <code>decode</code>，且 scope 为 <code>static</code>。一旦指定后，decode function 的 scope 就不会再是 <code>static</code>。</li>
<li><code>--static-decode</code>：如同 <code>--decode</code>，不过 decode function 的 scope 仍维持为 <code>static</code>。</li>
<li><code>-o</code> / <code>--output</code>：指定生成的 decoder <code>.c</code> 档路径。</li>
<li><code>-w</code> / <code>--insnwidth</code>：指令长度，eg：<code>32</code> or <code>16</code>，默认为 <code>32</code>。</li>
<li><code>--varinsnwidth</code>：指令为不定长度。</li>
<li><code>最后一个参数</code>为输入的 decode 档路径。</li>
</ul>
<p>运行范例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">./decodetree.py -o target/riscv/decode_insn16.inc.c --static-decode decode_insn16 \
</span></span><span class="line"><span class="cl">    -w 16 ./insn16.decode
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">static inline int32_t sextract32(uint32_t value, int start, int length){    assert(start &gt;= 0 &amp;&amp; length &gt; 0 &amp;&amp; length &lt;= 32 - start);        return ((int32_t)(value &lt;&lt; (32 - length - start))) &gt;&gt; (32 - length);}
</span></span></code></pre></div>]]></content:encoded>
    </item>
  </channel>
</rss>
