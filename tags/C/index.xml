<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C on 夜云泊</title>
    <link>https://lifeislife.cn/tags/c/</link>
    <description>Recent content in C on 夜云泊</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 16 Aug 2022 11:42:24 +0000</lastBuildDate>
    <atom:link href="https://lifeislife.cn/tags/c/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解决 cast from pointer to integer of different size</title>
      <link>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3cast-from-pointer-to-integer-of-different-size/</link>
      <pubDate>Tue, 16 Aug 2022 11:42:24 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3cast-from-pointer-to-integer-of-different-size/</guid>
      <description>保留现场 1 2 3 4 5 void* foo(void *dst, ...) { // some code unsigned int offset = (unsigned int) dst % 8; // warning here! // some code continue... } 写驱动程序时经常会直接对地址进行修改，配置寄存器的值，也会将地址的值作为</description>
    </item>
    <item>
      <title>Makefile 确定宏定义</title>
      <link>https://lifeislife.cn/posts/makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Wed, 27 Jul 2022 08:28:03 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/</guid>
      <description>有时需要通过make编译命令时确定代码中的宏定义，如编译不同的版本只需要使用不同的编译命令即可，而不需要修改内部代码。 当前的需求是代码中有一</description>
    </item>
    <item>
      <title>C 语言 getopt() 函数的用法</title>
      <link>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80getopt-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sat, 16 Jul 2022 22:42:03 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80getopt-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>在做CSAPP_LAB-Cache Lab时，实验要求对输入参数进行处理，如程序csim执行需要 4 个参数： 1 ./csim -s 4 -E 6 -b 4 -t &amp;lt;tracefile&amp;gt; 原先想通过字符串</description>
    </item>
    <item>
      <title>C语言数组/结构体/结构体数组/联合体初始化</title>
      <link>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84-%E7%BB%93%E6%9E%84%E4%BD%93-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-%E8%81%94%E5%90%88%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Thu, 30 Jun 2022 15:30:41 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84-%E7%BB%93%E6%9E%84%E4%BD%93-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-%E8%81%94%E5%90%88%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>数组初始化 1 2 3 4 int arr[6] = { [0]=5, [1]=6, [3] =10, [4]=11 }; 或 int arr[6] = { [0]=5, 6, [3] =10, 11 }; 或 int arr[6] = { [3] =10, 11, [0]=5, 6 }; (指定顺序可变) 均等效于：int arr[6] = {5, 6, 0, 10, 11, 0}; Note: 若在某个</description>
    </item>
    <item>
      <title>C 语言实现简单有限状态机</title>
      <link>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</link>
      <pubDate>Sun, 15 May 2022 12:41:30 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</guid>
      <description>简介 常说的状态机是有限状态机 FSM，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。 三个特征： 状态总数（state）是有</description>
    </item>
    <item>
      <title>C 语言中的变长数组与零长数组</title>
      <link>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 11 Feb 2022 21:09:35 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84/</guid>
      <description>变长数组 想必很多学习 C 语言的人都会在书上看到，数组在初始化时必须要确定长度（维度），也就是说定义数组时，维度一定要用常量。但是在编程中很多人</description>
    </item>
    <item>
      <title>C 程序内存区域分配</title>
      <link>https://lifeislife.cn/posts/c%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D/</link>
      <pubDate>Wed, 22 Dec 2021 09:16:25 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/c%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D/</guid>
      <description></description>
    </item>
    <item>
      <title>解决 C 语言 undefined reference to pthread_join</title>
      <link>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3c%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/</link>
      <pubDate>Wed, 17 Nov 2021 19:30:20 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3c%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/</guid>
      <description>保留现场 undefined reference to sleep同样的问题。 在使用 C 语言线程函数时，需要包含#include &amp;lt;pthread&amp;gt;，编译时就会报这种错误。 探</description>
    </item>
    <item>
      <title>解决 expected identifier before‘(’token</title>
      <link>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3expected-identifier-before---token/</link>
      <pubDate>Fri, 12 Nov 2021 19:34:54 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3expected-identifier-before---token/</guid>
      <description>保留现场 比如在一个枚举类型中，会告诉你某行有这种错误。又或者，在一个宏定义语句中出现这种错误。 探究原因 一般来说，出现这种情况，是语句中有些定</description>
    </item>
    <item>
      <title>C 语言复杂声明</title>
      <link>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Fri, 22 Oct 2021 11:02:58 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/</guid>
      <description>C 语言常常因为声明的语法问题而受到人们的批评，特别是涉及到函数指针的语法。C 语言的语法力图使声明和使用相一致。对于简单的情况，C 语言的做法是</description>
    </item>
    <item>
      <title>解决 gcc 编译后 fflush 失效</title>
      <link>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/</link>
      <pubDate>Thu, 21 Oct 2021 09:56:51 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/</guid>
      <description>保留现场 使用scanf()获取输入时，因为涉及键盘缓冲区的问题，每次输入后想要把缓冲清空，但是在 gcc 编译后，使用fflush无法清空缓冲区。 探</description>
    </item>
    <item>
      <title>解决 Segmentation fault (core dumped)</title>
      <link>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3segmentation-fault-core-dumped/</link>
      <pubDate>Wed, 20 Oct 2021 14:23:02 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3segmentation-fault-core-dumped/</guid>
      <description>相关概念 Core 在使用半导体作为内存的材料前，人类是利用线圈当作内存的材料（发明者为王安），线圈就叫作 core ，用线圈做的内存就叫作 core memory。如今</description>
    </item>
    <item>
      <title>C 语言可变参数</title>
      <link>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</link>
      <pubDate>Tue, 12 Oct 2021 11:21:49 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</guid>
      <description>学习过程中查看了printf()源码，遇到了这样的函数定义， 1 2 3 4 5 6 7 8 9 10 11 void printf(char *fmt, ...){ char buf[256]; va_list args; memset(buf, 0, sizeof(buf)); va_start(args, fmt); vsprint(buf, fmt, args); va_end(args); puts(buf); } 参数中的三个点号，就</description>
    </item>
    <item>
      <title>解决 Undefined reference to 问题</title>
      <link>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3undefined-reference-to%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 17 Sep 2021 11:14:30 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3undefined-reference-to%E9%97%AE%E9%A2%98/</guid>
      <description>链接时缺失了相关目标文件 这是最典型最常见的情况。比如新添加了一个模块fun.h fun.c两个文件，其他文件中使用了这个模块里的函数，如果编译</description>
    </item>
    <item>
      <title>C/C&#43;&#43;如何避免过多使用全局变量</title>
      <link>https://lifeislife.cn/posts/c-c-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</link>
      <pubDate>Fri, 17 Sep 2021 10:49:15 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/c-c-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</guid>
      <description>‘ 具体实例可以参考Marc Pony 指针传参 C 语言中，全局变量用结构体封装，设计函数时，将参数以结构体指针形式传入。 定义获取变量的方法/函数 定义一个</description>
    </item>
    <item>
      <title>C 语言 sizeof(结构体) 到底有多大</title>
      <link>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80sizeof-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%A4%A7/</link>
      <pubDate>Wed, 15 Sep 2021 18:38:07 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80sizeof-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%A4%A7/</guid>
      <description>C 语言中各个数据类型的大小 类型 大小 范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或</description>
    </item>
    <item>
      <title>C 语言预处理</title>
      <link>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 09 Sep 2021 14:10:40 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</guid>
      <description>什么是预处理 C 语言通过预处理器提供了一些语言功能。从概念上讲，预处理器是编译过程中单独执行的第一个步骤。两个最常用的预处理器指令是：#inc</description>
    </item>
    <item>
      <title>解决 expected &#39;char * const*&#39; but argument is of type &#39;char **&#39;</title>
      <link>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/</link>
      <pubDate>Wed, 08 Sep 2021 19:07:27 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/</guid>
      <description>在使用exec系列函数时，execle，execv，execvp三个函数，都可以使用char *arg[]传入启动参数。以下面的程序为例， 1 2</description>
    </item>
  </channel>
</rss>
