<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C on PaperMod</title>
    <link>http://localhost:8888/tags/c/</link>
    <description>Recent content in C on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 16 Aug 2022 11:42:24 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/tags/c/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解决 cast from pointer to integer of different size</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3cast-from-pointer-to-integer-of-different-size/</link>
      <pubDate>Tue, 16 Aug 2022 11:42:24 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3cast-from-pointer-to-integer-of-different-size/</guid>
      <description>保留现场 void* foo(void *dst, ...) { // some code unsigned int offset = (unsigned int) dst % 8; // warning here! // some code continue... } 写驱动程序时经常会直接对地址进行修改，配置寄存器的值，也会将地址的值作为数据进行传递，这就会遇到一个问题，指针强转成整型，类型不匹配数据丢失的问题。
探究原因 出现这个警告的原因是，将void*类型强转成unsigned int是不可移植的。什么叫不可移植呢？
我们知道指针类型，在 32 位系统下是 4 字节，在 64 位系统下是 8 字节，而unsigned int不管在什么系统下都是是 4 字节，所以，如果将void*类型强转成unsigned int，在 64 位系统下就没有足够的空间保存真正的数据。
解决方法 粗暴地用double来接收 先接收，再截断：
void* foo(void *dst, ...) { // some code unsigned int offset = (unsigned int)(unsigned double) dst % 8; // warning here! // some code continue.</description>
    </item>
    <item>
      <title>Makefile 确定宏定义</title>
      <link>http://localhost:8888/posts/makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Wed, 27 Jul 2022 08:28:03 +0000</pubDate>
      <guid>http://localhost:8888/posts/makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/</guid>
      <description>有时需要通过make编译命令时确定代码中的宏定义，如编译不同的版本只需要使用不同的编译命令即可，而不需要修改内部代码。
当前的需求是代码中有一部分代码通过宏定义来确定编译的是 DIE0 版本还是 DIE1 版本，如果定义了DIE_ORDINAL_0 就使用 DIE0 的基地址，如果未定义就使用 DIE1 的基地址。
#define DIE_ORDINAL_0 #ifdef DIE_ORDINAL_0 #define PERIPH_BASE (SYS_BASE_ADDR_DIE0) #else #define PERIPH_BASE (SYS_BASE_ADDR_DIE1) #endif gcc 命令支持-D宏定义，相当于 C 中的全局#define，在 Makefile 中我们可以通过宏定义来控制源程序的编译。只要在 Makefile 中的 CFLAGS 中通过选项-D 来指定你于定义的宏即可。
CFLAGS += -D DIE_ORDINAL_0 # 在编译的时候加上此选项就可以了 $(CC) $(CFLAGS) $^ -o $@ 这样的话，相当于设置了DIE_ORDINAL_0这个宏定义。但是我们想通过命令行的参数来决定是否使用这个宏定义，可以通过一些简单的方法获取：
ifeq ($(DIE0), y) CFLAGS +=-DDIE_ORDINAL_0 else CFLAGS +=-DDIE_ORDINAL_1 endif $(CC) $(CFLAGS) $^ -o $@ 从命令行找到DIE0这个参数，如果它等于y表示使用DIE_ORDINAL_0。如果不等于y则使用DIE_ORDINAL_1，因为我们代码里没有DIE_ORDINAL_1，所以就相当于没有定义DIE_ORDINAL_0。
命令行示例：
# 编译DIE0 make DIE0=&amp;#34;y&amp;#34; # 编译DIE1 make DIE0=&amp;#34;n&amp;#34; </description>
    </item>
    <item>
      <title>C 语言 getopt() 函数的用法</title>
      <link>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80getopt-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sat, 16 Jul 2022 22:42:03 +0000</pubDate>
      <guid>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80getopt-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>在做CSAPP_LAB-Cache Lab时，实验要求对输入参数进行处理，如程序csim执行需要 4 个参数：
./csim -s 4 -E 6 -b 4 -t &amp;lt;tracefile&amp;gt; 原先想通过字符串解析，一个个处理，但是看到了其他参考代码后发现了一个更简单的方法，可以通过getopt()函数来解析参数。
函数的功能：解析命令行参数。 头文件 #include &amp;lt;unistd.h&amp;gt;
在学习函数前需要了解与该函数相关的四个变量：
int opterr：控制是否输出错误； 如果此变量的值非零，则 getopt 在遇到未知选项字符或缺少必需参数的选项时将错误消息打印到标准错误流 (终端)。该值默认为非零。如果将此变量设置为零，getopt 不会打印任何消息，但仍会返回问号?提示错误。
int optopt：保存未知的选项； 当 getopt 遇到未知选项字符或缺少必需参数的选项时，它将该选项字符存储在此变量中。
int optind：指向下一个要处理的参数； 此变量由 getopt 设置为要处理的 argv 数组的下一个元素的索引。一旦 getopt 找到所有选项参数，就可以使用此变量来确定其余非选项参数的开始位置。该变量的初始值为 1。
char * optarg：保存选项参数； 对于那些接受参数的选项，此变量由 getopt 设置为指向选项参数的值。
函数原型：
int getopt(int argc, char * const argv[], const char * options); 参数解析：
参数argc 和argv 是由main()传递的参数个数和内容。 options 参数是一个字符串，它指定对该程序有效的选项字符。此字符串中的选项字符后面可以跟一个冒号（:），表示它需要一个必需的参数，这个参数可以与选项连写也可以空格分开，如-a13 or -a 13。如果选项字符后跟两个冒号（::），则其参数是可选的，如果有参数，那么参数不能与选项分割，如只能写成-a13而不能写成-a 13；这是一个 GNU 扩展。 实例：</description>
    </item>
    <item>
      <title>C语言数组/结构体/结构体数组/联合体初始化</title>
      <link>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84-%E7%BB%93%E6%9E%84%E4%BD%93-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-%E8%81%94%E5%90%88%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Thu, 30 Jun 2022 15:30:41 +0000</pubDate>
      <guid>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84-%E7%BB%93%E6%9E%84%E4%BD%93-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-%E8%81%94%E5%90%88%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>数组初始化 int arr[6] = { [0]=5, [1]=6, [3] =10, [4]=11 }; 或 int arr[6] = { [0]=5, 6, [3] =10, 11 }; 或 int arr[6] = { [3] =10, 11, [0]=5, 6 }; (指定顺序可变) 均等效于：int arr[6] = {5, 6, 0, 10, 11, 0}; Note:
若在某个指定初始化项目后跟有不至一个值，如[3]=10,11。则多出的数值用于对后续的数组元素进行初始化，即数值 11 用来初始化 arr[4]。 C 数组初始化一个或多个元素后，未初始化的元素将被自动地初始化为 0 或 NULL(针对指针变量)。未经过任何初始化的数组，所有元素的值都是不确定的。 GNU C 还支持[first … last]=value(…两侧有空格) 的形式，将该范围内的若干元素初始化为相同值。如：
int arr[]={ [0 ... 3]=1, [4 ... 5]=2, [6 ... 9] =3}; 或 int arr[]={ [0 .</description>
    </item>
    <item>
      <title>C 语言实现简单有限状态机</title>
      <link>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</link>
      <pubDate>Sun, 15 May 2022 12:41:30 +0000</pubDate>
      <guid>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</guid>
      <description>简介 常说的状态机是有限状态机 FSM，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。 三个特征：
状态总数（state）是有限的。 任一时刻，只处在一种状态之中。 某种条件下，会从一种状态转变（transition）到另一种状态。 设计状态机的关键点：当前状态、外部输入、下一个状态。
状态机分类 Moore 型状态机 Moore 型状态机特点是：输出只与当前状态有关（与输入信号无关）。相对简单，考虑状态机的下一个状态时只需要考虑它的当前状态就行了。
Mealy 型状态机 Mealy 型状态机的特点是：输出不只和当前状态有关，还与输入信号有关。状态机接收到一个输入信号需要跳转到下一个状态时，状态机综合考虑 2 个条件（当前状态、输入值）后才决定跳转到哪个状态。
实现一个简单的状态机 代码参考AstarLight/FSM-framework。
以小明的一天设计出一个状态机，下图为状态转移图：
首先，有限状态机的状态是有限的，我们可以定义一天中的状态：
enum { GET_UP, GO_TO_SCHOOL, HAVE_LUNCH, DO_HOMEWORK, SLEEP, }; 状态机在没有事件的驱动下就是一潭死水，所以我们还需要定义出一些会发生的事件，去驱动状态机的运转：
enum { EVENT1 = 1, EVENT2, EVENT3, }; 再定义一些在某个状态下需要处理的动作，也就是函数：
void GetUp() { // do something printf(&amp;#34;xiao ming gets up!\n&amp;#34;); } void Go2School() { // do something printf(&amp;#34;xiao ming goes to school!\n&amp;#34;); } void HaveLunch() { // do something printf(&amp;#34;xiao ming has lunch!</description>
    </item>
    <item>
      <title>C 语言中的变长数组与零长数组</title>
      <link>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 11 Feb 2022 21:09:35 +0000</pubDate>
      <guid>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84/</guid>
      <description>变长数组 想必很多学习 C 语言的人都会在书上看到，数组在初始化时必须要确定长度（维度），也就是说定义数组时，维度一定要用常量。但是在编程中很多人肯定发现了，及时像下面这样写，编译器也不会报错。
int n; int array[n]; 这是怎么回事？难道以前我学的是错的吗？当然不是。最官方的解释应该是 C 语言的规范和编译器的规范说明了。
在 ISO/IEC9899 标准的 6.7.5.2 Array declarators 中明确说明了数组的长度可以为变量的，称为变长数组（VLA，variable length array）。（注：这里的变长指的是数组的长度是在运行时才能决定，但一旦决定在数组的生命周期内就不会再变。） 在 GCC 标准规范的 6.19 Arrays of Variable Length 中指出，作为编译器扩展，GCC 在 C90 模式和 C++ 编译器下遵守 ISO C99 关于变长数组的规范。 原来这种语法确实是 C 语言规范，GCC 非常完美的支持了 ISO C99。但是在 C99 之前的 C 语言中，变长数组的语法是不存在的。
这种变长数组有什么好处呢？它可以实现与alloca函数一样的效果，在栈上进行动态的空间分配，并且在函数返回时自动释放内存，无需手动释放。
alloca 函数用来在栈上分配空间，当函数返回时自动释放，无需手动再去释放；
可变数组示例： 所有可变修改 (VM) 类型的声明必须在块范围或函数原型范围内。使用 static 或 extern 存储类说明符声明的数组对象不能具有可变长度数组 (VLA) 类型。但是，使用静态存储类说明符声明的对象可以具有 VM 类型（即，指向 VLA 类型的指针）。最后，使用 VM 类型声明的所有标识符都必须是普通标识符，因此不能是结构或联合的成员。
extern int n; int A[n]; // Error - file scope VLA.</description>
    </item>
    <item>
      <title>C 程序内存区域分配</title>
      <link>http://localhost:8888/posts/c%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D/</link>
      <pubDate>Wed, 22 Dec 2021 09:16:25 +0000</pubDate>
      <guid>http://localhost:8888/posts/c%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D/</guid>
      <description></description>
    </item>
    <item>
      <title>解决 C 语言 undefined reference to pthread_join</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3c%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/</link>
      <pubDate>Wed, 17 Nov 2021 19:30:20 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3c%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/</guid>
      <description>保留现场 undefined reference to sleep同样的问题。 在使用 C 语言线程函数时，需要包含#include &amp;lt;pthread&amp;gt;，编译时就会报这种错误。
探究原因 pthread 库不是 Linux 系统默认的库，连接时需要使用静态库 libpthread.a，所以在使用pthread_create()创建线程，以及调用pthread_atfork()函数建立fork处理程序时，需要链接该库。
解决方法 gcc thread.c -o thread -lpthread 如果是Makefile配置的编译条件，在Makefile文件中加上如下：
CFLAGS += -lpthread </description>
    </item>
    <item>
      <title>解决 expected identifier before‘(’token</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3expected-identifier-before---token/</link>
      <pubDate>Fri, 12 Nov 2021 19:34:54 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3expected-identifier-before---token/</guid>
      <description>保留现场 比如在一个枚举类型中，会告诉你某行有这种错误。又或者，在一个宏定义语句中出现这种错误。
探究原因 一般来说，出现这种情况，是语句中有些定义的名字发生了冲突。
解决方法 定位错误位置，搜索是否有同名的函数，变量等等。改个名字。</description>
    </item>
    <item>
      <title>C 语言复杂声明</title>
      <link>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Fri, 22 Oct 2021 11:02:58 +0000</pubDate>
      <guid>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/</guid>
      <description>C 语言常常因为声明的语法问题而受到人们的批评，特别是涉及到函数指针的语法。C 语言的语法力图使声明和使用相一致。对于简单的情况，C 语言的做法是很有效的，但是，如果情况比较复杂，则容易让人混淆，原因在于，C 语言的声明不能从左至右阅读，而且使用了太多的圆括号。 在 C 中，声明的形式为（dcl 是 declaration 的简写）：
dcl: optional *&amp;#39;s direct-dcl（含有可选&amp;#34;*&amp;#34;的direct-dcl）direct-dcl name(dcl)direct-dcl()direct-dcl[optional size] 简而言之，声明符dc1(可以理解成间接声明) 就是前面可能带有多个*的direcr-dclo。direct-dcl可以是name、由一对圆括号括起来的dcl、后面跟有一对圆括号的direct-dcl、后面跟有用方括号括起来的表示可选长度的direc-dcl。
根据该规则进行逆向解析，就可以得到正确的声明。简化一下：TypeName Declarator;其中，Declarator就是声明中的那个name。当你遇到任何你不能理解的声明时，这个法则就是救命稻草。最简单的例子：
int aInt; 这里，int是TypeName，aInt是Declarator。
再说明一下结合紧密度。在声或定义变量时，可以使用一些修饰比如*，[]，()等。()（非函数声明中的()）具有最高的紧密度，其次才是函数和数组的()和[]。
没有*的声明称为直接声明（direct-dcl），而有*称为声明（dcl）。直接声明要比声明结合的紧。分解声明时，先读出结合紧的。在这里，我把direct-dcl称为更紧的结合，它比dcl结合得紧。
最后，需要你用英语来读出这个声明。对于[]，应该读成array of。
对于复杂的定义，可以将其分解。比如T (*p)()可以分解成T D1()，D1读作：function returning T。其中D1是*p。那么该声明应该读成：p is a poniter to。二者合在一起，就变成了 p is a pointer to function returning T，即：p是指向返回T类对象的函数的指针。
再看一个稍微复杂的示例：
T (*pfa[])(); 根据dcl和direct-dcl，可以分解成T1 D1（因为结合紧密度），T1也就是T ()，那么应该读作： D1 is function returning T。
D1又可以写成T2 D2，其中T2是T1 []，可以分解成T1 D2[]，读作：array of D2 function returning T。
D2是指针，读作：pointers to。那么整个 T (*pfa[])() 应该读作：pfa is an array of pointers to function returning T，即：pfa是个存放指向返回 T 类对象函数的指针的数组。</description>
    </item>
    <item>
      <title>解决 gcc 编译后 fflush 失效</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/</link>
      <pubDate>Thu, 21 Oct 2021 09:56:51 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/</guid>
      <description>保留现场 使用scanf()获取输入时，因为涉及键盘缓冲区的问题，每次输入后想要把缓冲清空，但是在 gcc 编译后，使用fflush无法清空缓冲区。
探究原因 C 标准 (ISO/IEC 9899:1999 standard) 规定fflush(stdin)操作是未定义的&amp;lt;参看《ISO/IEC 9899:1999 standard》p270&amp;gt;;。也就是说不一定能实现刷新功能，但有的编译器可能不遵循标准，对fflush(stdin)操作不予警告，并且有时可能产生正确的结果，但最好不要这样使用。
解决方法 通过 while 循环把输入流中的余留数据“吃”掉：
int c; while ((c=getchar()) != ‘\n’ &amp;amp;&amp;amp; c != EOF); </description>
    </item>
    <item>
      <title>解决 Segmentation fault (core dumped)</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3segmentation-fault-core-dumped/</link>
      <pubDate>Wed, 20 Oct 2021 14:23:02 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3segmentation-fault-core-dumped/</guid>
      <description>相关概念 Core 在使用半导体作为内存的材料前，人类是利用线圈当作内存的材料（发明者为王安），线圈就叫作 core ，用线圈做的内存就叫作 core memory。如今，半导体工业澎勃发展，已经没有人用core memory 了，不过，在许多情况下，人们还是把记忆体叫作 core 。
Core dump 我们在开发（或使用）一个程序时，最怕的就是程序莫明其妙地宕掉。虽然系统没事，但我们下次仍可能遇到相同的问题。于是这时操作系统就会把程序宕掉时的内存内容 dump 出来（现在通常是写在一个叫 core 的 file 里面），让我们做为参考。这个动作就叫作 core dump。
如何获取 Core 文件 1、在一些 Linux 版本下，默认是不产生core文件的，首先可以查看一下系统core文件的大小限制：
$:~/segfault$ ulimit -c0 2、可以看到默认设置情况下，本机 Linux 环境下发生段错误时不会自动生成core文件，下面设置下core文件的大小限制（单位为 KB）：
$:~/segfault$ ulimit -c 1024$:~/segfault$ ulimit -c1024 3、重新运行程序，如果发生段错误，就会生成core文件。
出现段错误的可能原因 访问不存在的内存地址 #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; void main() { int *ptr = NULL; *ptr = 0; } 访问系统保护的内存地址 #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; void main() { int *ptr = (int *)0; *ptr = 100; } 访问只读的内存地址 #include&amp;lt;stdio.</description>
    </item>
    <item>
      <title>C 语言可变参数</title>
      <link>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</link>
      <pubDate>Tue, 12 Oct 2021 11:21:49 +0000</pubDate>
      <guid>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</guid>
      <description>学习过程中查看了printf()源码，遇到了这样的函数定义，
void printf(char *fmt, ...){ char buf[256]; va_list args; memset(buf, 0, sizeof(buf)); va_start(args, fmt); vsprint(buf, fmt, args); va_end(args); puts(buf); } 参数中的三个点号，就是 C 语言中可变参数的标识。这样的函数称为可变参数函数。这种函数需要固定数量的强制参数（mandatory argument），后面是数量可变的可选参数（optional argument）。
这种函数必须至少有一个强制参数。可选参数的类型可以变化。可选参数的数量由强制参数的值决定，或由用来定义可选参数列表的特殊值决定。
C 语言中最常用的可变参数函数例子是printf（）和 scanf（）。这两个函数都有一个强制参数，即格式化字符串。格式化字符串中的转换修饰符决定了可选参数的数量和类型。
可变参数函数要获取可选参数时，必须通过一个类型为 va_list 的对象，它包含了参数信息。这种类型的对象也称为参数指针（argument pointer），它包含了栈中至少一个参数的位置。可以使用这个参数指针从一个可选参数移动到下一个可选参数，由此，函数就可以获取所有的可选参数。va_list 类型被定义在头文件 stdarg.h 中。
当编写支持参数数量可变的函数时，必须用 va_list 类型定义参数指针，以获取可选参数。在下面的讨论中，va_list 对象被命名为 argptr。可以用 4个宏来处理该参数指针，这些宏都定义在头文件 stdarg.h 中：
宏 va_start 使用第一个可选参数的位置来初始化 argptr 参数指针。该宏的第二个参数必须是该函数最后一个有名称参数的名称。必须先调用该宏，才可以开始使用可选参数。
void va_start(va_list argptr, lastparam); 展开宏 va_arg 会得到当前 argptr 所引用的可选参数，也会将 argptr 移动到列表中的下一个参数。宏 va_arg 的第二个参数是刚刚被读入的参数的类型。
type va_arg(va_list argptr, type); 当不再需要使用参数指针时，必须调用宏 va_end。如果想使用宏 va_start 或者宏 va_copy 来重新初始化一个之前用过的参数指针，也必须先调用宏 va_end。va_end被定义为空。它只是为实现与 va_start 配对 (实现代码对称和&amp;quot;代码自注释&amp;quot;(根据代码就能知道功能，不需要额外注释) 功能)</description>
    </item>
    <item>
      <title>解决 Undefined reference to 问题</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3undefined-reference-to%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 17 Sep 2021 11:14:30 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3undefined-reference-to%E9%97%AE%E9%A2%98/</guid>
      <description>链接时缺失了相关目标文件 这是最典型最常见的情况。比如新添加了一个模块fun.h fun.c两个文件，其他文件中使用了这个模块里的函数，如果编译时忘记加上这两个文件，调用fun模块函数的地方，就会报undefined reference错误。
这个问题在编辑器中一般不容易发现，因为头文件包含是正确的，编辑器能够找到相关的函数及其实现，所以在编写代码时不会报错。
链接时缺少相关的库文件 这个原因和上一条类似，我们在调用静态库中的函数时，编译时如果没有将静态库一起编译，就会报同样的错误。
链接的库文件中又使用了另一个库文件 在使用第三方库时，一定要在编译中加入第三方库的路径。
多个库文件链接顺序问题 在链接命令中给出所依赖的库时，需要注意库之间的依赖顺序，依赖其他库的库一定要放到被依赖库的前面，这样才能真正避免 undefined reference 的错误，完成编译链接。
声明与实现不一致 这个原因也比较典型，注意排查声明与实现的参数是否一致，返回值是否一致。
在 c++代码中链接 c 语言的库 在C++代码中，调用了C语言库的函数，因此链接的时候找不到，解决方法是在相关文件添加一个extern &amp;quot;C&amp;quot;的声明即可。
总结 顾名思义，这个错误就是未定义你使用的内容导致的。所以要排查使用的内容是否能够被正确“找到”。使用的时候有没有声明，有没有定义，声明与定义是否一致，编译时能否正确链接等等。
相关参考 &amp;ldquo;undefined reference to&amp;rdquo; 问题汇总及解决方法</description>
    </item>
    <item>
      <title>C/C&#43;&#43;如何避免过多使用全局变量</title>
      <link>http://localhost:8888/posts/c-c-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</link>
      <pubDate>Fri, 17 Sep 2021 10:49:15 +0000</pubDate>
      <guid>http://localhost:8888/posts/c-c-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</guid>
      <description>‘
具体实例可以参考Marc Pony
指针传参 C 语言中，全局变量用结构体封装，设计函数时，将参数以结构体指针形式传入。
定义获取变量的方法/函数 定义一个函数以get/set全局变量，利用static变量，将全局变量作用域限定于该函数，将全局变量隐藏起来。
善用static 把全局变量定义在某一个 .c 文件中，并定义为 static 类型，然后定义一系列操作这个变量的函数，头文件里面只有操作函数，没有变量的声明</description>
    </item>
    <item>
      <title>C 语言 sizeof(结构体) 到底有多大</title>
      <link>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80sizeof-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%A4%A7/</link>
      <pubDate>Wed, 15 Sep 2021 18:38:07 +0000</pubDate>
      <guid>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80sizeof-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%A4%A7/</guid>
      <description>C 语言中各个数据类型的大小 类型 大小 范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 结构体 (struct) 待分析，需要考虑字节对齐 联合 (union) 所有成员中最长的 枚举 (enum) 根据数据类型 单层结构体大小 如果结构体中的成员数据类型相同，这样的情况最简单，结构体大小=数据类型*数据个数。</description>
    </item>
    <item>
      <title>C 语言预处理</title>
      <link>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 09 Sep 2021 14:10:40 +0000</pubDate>
      <guid>http://localhost:8888/posts/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</guid>
      <description>什么是预处理 C 语言通过预处理器提供了一些语言功能。从概念上讲，预处理器是编译过程中单独执行的第一个步骤。两个最常用的预处理器指令是：#include 指令 (用于在编译期间把指定文件的内容包含进当前文件中) 和 #define 指令 (用任意字符序列替代一个标记)。
为啥要进行预先处理呢？如果要深入的了解的话可以参考《程序员的自我修养：链接、装载与库》这本书。这里举一个非常常见的例子，假如我们编写跨平台的程序时，我们就需要考虑不同平台的系统库是不同的，如果只包含了一个平台下的库文件，换个平台编译就可能出错。这时候就需要在编译前进行预处理。
有重要的预处理器指令：
指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else #if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器中 条件编译 #if #if 整型常量表达式1 程序段1 #elif 整型常量表达式2 程序段2 #elif 整型常量表达式3 程序段3 #else 程序段4 #endif 它的意思是：如常“表达式 1”的值为真（非 0），就对“程序段 1”进行编译，否则就计算“表达式 2”，结果为真的话就对“程序段 2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else 。这一点和 if else 非常类似。
需要注意的是， #if 命令要求判断条件为整型常量表达式，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行。这是 #if 和 if 的一个重要区别。</description>
    </item>
    <item>
      <title>解决 expected &#39;char * const*&#39; but argument is of type &#39;char **&#39;</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/</link>
      <pubDate>Wed, 08 Sep 2021 19:07:27 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/</guid>
      <description>在使用exec系列函数时，execle，execv，execvp三个函数，都可以使用char *arg[]传入启动参数。以下面的程序为例，
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; int main(void) { int ret; char *argv[] = {&amp;#34;ls&amp;#34;,&amp;#34;-l&amp;#34;,NULL}; ret = execvp(&amp;#34;ls&amp;#34;,argv); if(ret == -1) perror(&amp;#34;execl error&amp;#34;); return 0; } 编译时就会出现一下，警告，
expected &amp;#39;char * const*&amp;#39; but argument is of type &amp;#39;const char **&amp;#39; 因为项目中不允许警告产生，所以编译选项是-Werror，所有警告都会被升级成错误。编译时就会产生如下提示，
ccl : all warnings being treated as errors 如果是平时练习，改一下编译选项，把这个警告忽略就行，但是现在只能解决。
出现这个问题就是因为定义数组时char *argv[]类型是char **。但是execvp()函数签名是execvp(const char *file, char *const argv[]);第二个参数的类型是char * const *。
本以为直接将变量定义更改成char * const argv[]就行了，但是它等价于const char **，所以仍然不能和函数签名匹配。
实在没办法只能改成如下：
#include &amp;lt;stdio.</description>
    </item>
  </channel>
</rss>
