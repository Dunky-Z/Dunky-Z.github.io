<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>AXI on 夜云泊</title>
    <link>https://lifeislife.cn/tags/axi/</link>
    <description>Recent content in AXI on 夜云泊</description>
    <generator>Hugo -- 0.133.1</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 17 May 2022 21:16:45 +0000</lastBuildDate>
    <atom:link href="https://lifeislife.cn/tags/axi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AMBA 总线协议-AXI 协议</title>
      <link>https://lifeislife.cn/posts/amba%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE-axi%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Tue, 17 May 2022 21:16:45 +0000</pubDate>
      <guid>https://lifeislife.cn/posts/amba%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE-axi%E5%8D%8F%E8%AE%AE/</guid>
      <description>AXI 组成部分： AXI4 协议中包含五种信道，通道之间相互独立且存在差别，通过通道进行通信之前需要使用 VALID/READY 进行握手，Read 和 Write 根据 Master 定义： 读地址信道（R</description>
      <content:encoded><![CDATA[<h2 id="axi">AXI</h2>
<p>组成部分：</p>
<p>AXI4 协议中包含五种信道，通道之间相互独立且存在差别，通过通道进行通信之前需要使用 VALID/READY 进行握手，Read 和 Write 根据 Master 定义：</p>
<ul>
<li>读地址信道（Read Address Channel）</li>
<li>写地址信道（Write Address Channel）</li>
<li>读数据信道（Read Data Channel）</li>
<li>写数据信道（Write Data Channel）</li>
<li>写响应信道（Write Response Channel）</li>
</ul>
<p>还有两种 Component</p>
<ul>
<li>Master component</li>
<li>Slave component</li>
</ul>
<p>通信由 Master 发起，Master 可以对 Slave 进行读数据（read）或写（write）数据。每次读写操作都需要一个地址，读地址信道（Read Address Channel）和写地址信道（Write Address Channel）用于传输地址。在写完数据后，Master 需要确认 Slave 有没有收完数据，Slave 收到完整数据后，会通过写响应信道（Write Response Channel）给 Master 一个反馈（completion），表示写操作已经完成。</p>
<h3 id="validready-握手机制">VALID/READY 握手机制</h3>
<p>AXI 五个信道相互独立，但是使用同一个握手机制来实现信息传递。</p>
<p>在握手机制中，通信双方分别扮演<strong>发送方</strong>(Source) 和<strong>接收方</strong>（Destination），两者的操作（技能）并不相同。</p>
<p><strong>发送方</strong>置高 <strong>VALID</strong> 信号表示发送方已经将数据，地址或者控制信息已经就绪，并保持于消息总线上。</p>
<p><strong>接收方</strong>置高 <strong>READY</strong> 信号表示接收方已经做好接收的准备。</p>
<p>当双方的 VALID/READY 信号同时为高，在时钟 ACLK 上升沿，完成一次数据传输。所有数据传输完毕后，双方同时置低自己的信号。</p>
<p>每个通道都有自己的 VALID /READY 握手信号对：</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516200137.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516200137.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p>在握手过程中，还会用到 LAST 信号。LAST 信号存在 Write Data Channel 和 Read Data Channel 中，分别表示为 WLAST 和 RLAST，用于标记 burst 的最后一次数据传输，当 slave 接收到 LAST 信号后，说明本次数据传输完成。</p>
<h4 id="双向流控">双向流控</h4>
<p>所谓的<strong>双向流控</strong>机制，指的是发送方通过置起 VALID 信号控制发送的时机与速度，接收方也可以通过 READY 信号的置起与否控制接收速度。</p>
<p>发送方拥有传输的主动权，但接收方在不具备接收能力时，也能够置低信号停止传输，反压发送方。</p>
<h4 id="握手过程分析">握手过程分析</h4>
<blockquote>
<p>图中 INFORMATION 信号无底色区域表示此时数据已经准备好，已经有新的数据到达。</p>
</blockquote>
<p><strong>VALID 信号先到</strong></p>
<p>发送方 VALID 信号早早就到了，但是接收方的 READY 信号在 T2 之前都没有发送。可能接收方在接收其他数据，或者被堵在数据通路上。</p>
<p>过了 T2 后，READY 信号到来，此时开始传输，直到 T3 结束，传输完成。</p>
<p>这里也体现了双向流控机制，发送方的 VALID 信号只要置高，再握手完成之前都不能置低，必须等到接收方 READY 信号置高。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201556.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201556.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p><strong>READY 信号先到</strong></p>
<p>READY 信号很自由，可以等待 VALID 信号到来再做响应，但也完全可以在 VALID 信号到来前就置高，表示接收端已经做好准备了。</p>
<p>而且，READY 信号与 VALID 不同，接收方可以置起 READY 之后在 VALID 置高之前都可以随时再置低 READY 信号。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201616.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201616.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p><strong>信号同时同时到达</strong></p>
<p>这个最简单，两个信号都等着一个时钟上升沿就完成传输了。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201647.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201647.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<h4 id="握手信号之间的依赖关系">握手信号之间的依赖关系</h4>
<p>为了防止死锁发生，信号之间要遵循一些规矩，举例来说，如上面提到的 READY 信号依赖 VALID 信号，但是 VALID 信号不能根据 READY 信号来判断是否数据已准备好，否则将会造成死锁。下面详细解释读写过程中需要遵循的依赖关系。</p>
<ul>
<li>单箭头指向的两个信号，信号的置高，低没有顺序要求。</li>
<li>双箭头表示箭头所指对象应迟于箭头出发信号发送。</li>
</ul>
<p><strong>Read transaction dependencies</strong></p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517100503.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517100503.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<ul>
<li>Master 不得等待 Slave 置高 ARREADY</li>
<li>Slave 可以在置高 ARREADY 之前等待 ARVALID 置高</li>
<li>Slave 能够在 ARVALID 置高之前先置高 ARREADY</li>
<li>Slave 必须等待 ARVALID 和 ARREADY 都被置高，然后才置高 RVALID 以表示有效数据可用</li>
<li>在置高 RVALID 之前，Slave 不得等待 Master 置高 RREADY</li>
<li>Master 可以在置高 RREADY 之前等待 RVALID 被置高</li>
<li>Master 可以在 RVALID 被置高之前置高 RREADY</li>
</ul>
<p><strong>Write transaction dependencies</strong></p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517100647.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517100647.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<ul>
<li>在置高 AWVALID 或 WVALID 之前，Master 不得等待 Slave 置高 AWREADY 或 WREADY</li>
<li>Slave 可以在置高 AWREADY 之前等待 AWVALID 或 WVALID，或两者都等待</li>
<li>Slave 可以在 AWVALID 或 WVALID 或两者都被置高之前置高 AWREADY</li>
<li>在置高 WREADY 之前，Slave 可以等待 AWVALID 或 WVALID，或两者都等待</li>
<li>Slave 可以在 AWVALID 或 WVALID 或两者都被置高之前置高 WREADY</li>
<li>在置高 BVALID 之前，Slave 必须等待 WVALID 和 WREADY 都被置高
<ul>
<li>Slave还必须在置高 BVALID 之前等待 WLAST 被置高，因为写入响应 BRESP 必须在写入事务的最后一次数据传输之后才发出信号</li>
</ul>
</li>
<li>在置高 BVALID 之前，Slave 不得等待 Master 置高 BREADY</li>
<li>Master 可以在置高 BREADY 之前等待 BVALID</li>
<li>Master 可以在 BVALID 被置高之前置高 BREADY</li>
</ul>
<h3 id="地址结构address-structure">地址结构（Address structure）</h3>
<p>AXI 协议是基于 Burst 的，地址结构里声明了一些传输过程中需要的信号，如起始地址，burst 传输长度，传输模式等等。</p>
<h4 id="burst">Burst</h4>
<p>在介绍 Burst transfer 之前，需要解释一下什么是 Burst。在手册的术语表中，与 AXI 传输相关的有三个概念，分别是 transfer(beat)、burst、transaction。</p>
<ul>
<li><strong>AXI Transaction</strong>：the complete set of required operations on the AXI bus form the AXI Transaction.表示传输一段数据 (AXI burst) 所需的一整套操作；</li>
<li><strong>AXI Burst</strong>：any required payload data is transferred as an AXI Burst.表示 AXI 待传数据；</li>
<li><strong>AXI Beats</strong>：a burst can comprise multiple data transfers, or AXI Beats.表示 AXI burst 的组成，一个 Beat 就是一个 transfer。</li>
</ul>
<p>三者的关系：在 AXI 传输事务（Transaction）中，数据以突发传输（Burst）的形式组织。一次突发传输中可以包含一至多个数据（Transfer）。每个 transfer 因为使用一个周期，又被称为一拍数据（Beat）。</p>
<p>$$
\text{Transaction} = M <em>\text{Burst} ,M \geq 1 \
\text{Burst} = N</em> \text{Transfer( or Beat)} ,N \geq 1
$$</p>
<p>在地址通道中有三个信号控制进行控制，包括：</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516151233.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516151233.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p><strong>ARLEN(Burst Length)</strong></p>
<p>指一次突发传输中包含的数据传输 (transfer) 数量，在协议中使用 AxLen 信号控制。在 AXI4 中，INCR 类型最大支持长度为 256，其他类型最大长度为 16。而 AXI3 中这一数字无论何种模式均为 16。因此 AXI4 中 AxLen 信号位宽为 8bit，AXI3 中的 AxLen 则仅需要 4bit。</p>
<p><strong>ARSIZE(Burst Size)</strong></p>
<p>指传输中的数据位宽，具体地，是每周期传输数据的字节数量，在协议中使用 AXSIZE 信号控制。<strong>突发传输数据宽度不能超过数据总线本身的位宽</strong>。而当数据总线位宽大于突发传输宽度时，将根据协议的相关规定，将数据在部分数据线上传输。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516154710.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516154710.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p><strong>ARBURST(Burst Type)</strong></p>
<p>Burst Type：AXI 协议中支持不同的 Burst 传输类型，主要分 FIXED、INCR、WRAP。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516144318.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516144318.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<ul>
<li><strong>FIXED 传输为地址固定传输</strong>，所有传输都会写在同一个地址中。主要应用在 FIFO 的传输中，因为 FIFO 为先入先出，只需要往同一个地址写数据即可。</li>
<li><strong>INCR 传输为地址递增传输</strong>，可根据具体的配置有固定长度递增和非定长递增。<strong>大部分的数据传输都是使用这种方式</strong>，尤其是在内存访问中，可以大大提高效率。</li>
<li><strong>WRAP 传输为地址回环传输</strong>，在一定长度后会回环到起始地址。主要应用在 Cache 操作中，因为 cache 是按照 cache line 进行操作，采用 wrap 传输可以方便的实现从内存中取回整个 cache line。</li>
</ul>
<p>AXI burst 读操作：<strong>master 只需要发送 burst 的起始地址</strong>，slave 会根据 burst 的起始地址与 burst 场地自动进行地址计算，将对应的数据与响应发送到 master 侧。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516143930.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516143930.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p>AXI burst 写操作中，<strong>也只需要发送 burst 写的起始地址</strong>，slave 只需要接受起始地址，然后根据传输的长度将数据传输到对应的地址缓存中。只需要进行一次握手就可以实现地址通道的请求传输，避免系统总线的占用。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516144030.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516144030.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<h3 id="数据结构data-read-and-write-structure">数据结构（Data read and write structure）</h3>
<p>读写数据结构中声明了几种数据传输方式。</p>
<p>在介绍这些传输方式之前，需要了解<strong>WSTRB(Write strobes) 写选通信号</strong>。写选通信号 WSTRB 允许在写数据总线上进行 稀疏数据 传输。每个写选通信号对应写数据总线上的一个字节。当写选通断言时，表示写数据总线上对应的字节通道中包含将被更新到 memory 的有效信息。</p>
<p>写数据总线上每 8 位具有一个写选通位，因此 WSTRB[n] 对应  WDATA[(8 x n) + 7 : (8 x n)]。默认情况下 WSTRB = 0xFFFF。也就是所有通路都是通的。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516162105.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516162105.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<h4 id="narrow-transfer">Narrow Transfer</h4>
<p>当本次传输中数据位宽小于通道本身的数据位宽时，称为<strong>窄位宽数据传输</strong>，或者直接翻译成<strong>窄传输</strong>。如下图，传输总线为 32bit，但是每次只传了 8 bit。</p>
<p>窄传输就是<strong>通过 STRB 信号指定有效传输数据的位宽来实现</strong>。针对一些特定的寄存器读写，或者在不同数据位宽的总线传输中会使用窄传输操作。如图，第一次传输时，WSTRB 信号为 0x01，WSTRB = b'001，表示 WDATA[7:0] 数据有效。</p>
<p>需要注意<strong>在多笔连续的窄传输操作中，STRB 会随着地址递增进行响应的变化</strong>，这样方便在系统设计使用中可以方便的将窄传输合并，从而提升系统传输效率。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516162805.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516162805.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<h4 id="unaligned-transfer">Unaligned Transfer</h4>
<p>AXI 协议规定单次 burst 传输中的数据，其地址不能跨越 4KB 边界。也就是在传输过程中会进行 4K 对齐。但是在某些时候，会期望在非对齐的地址开始一个突发，即非对齐传输。</p>
<blockquote>
<p>协议中之所以规定一个 burst 不能跨越 4K 边界是为了避免一次 burst 访问两个 slave（每个 slave 的地址空间是 4K/1K 对齐的）。4K 对齐最大原因是系统中定义一个 page 大小是 4K，而所谓的 4K 边界是指低 12bit 为 0 的地址。</p>
</blockquote>
<p>非对齐传输是指<strong>有些传输指令不是按照 word 对齐，而是按照 Byte 对齐进行传输</strong>。起始地址可能是任意的地址。如下图中，起始地址为 0x1，则在系统上需要按照非对齐的方式进行传输。<strong>第一次传输采用 strb 信号指定对应的 Byte 有效，后面的传输可以按照正常的传输进行</strong>。</p>
<p>下图是一些传输示例，有阴影的格子表示当前字节不会被传输。</p>
<p>图一为正常的对齐传输，传输起始地址为 0x00。</p>
<p>图二为非对齐传输，起始地址为 0x01，第一个格子对应的 WSTRB = b'1110。</p>
<p>图三同上，只是 Burst length 为 5。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516171247.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516171247.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
<p>图四也为非对齐传输，起始地址为 0x07。对应的 WSTRB = b'1000。</p>
<p>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Image</title>
    <style>
        .post-img-view {
            text-align: center;
        }
        .responsive-image {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    
    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516171348.png">
            <img class="responsive-image" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516171348.png" alt=""  style="margin: 0 auto;"/>
        </a>
    </div>
    

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var images = document.querySelectorAll(".responsive-image");
            var maxHeight = window.innerHeight / 3;
            images.forEach(function(image) {
                image.style.maxHeight = maxHeight + "px";
            });
        });
    </script>
</body>
</html></p>
]]></content:encoded>
    </item>
  </channel>
</rss>
