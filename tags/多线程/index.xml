<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>多线程 on PaperMod</title>
    <link>http://localhost:8888/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content in 多线程 on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Fri, 08 Sep 2023 10:01:20 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>uCore 实验第 5 章 - 进程及进程管理</title>
      <link>http://localhost:8888/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC5%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 08 Sep 2023 10:01:20 +0000</pubDate>
      <guid>http://localhost:8888/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC5%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</guid>
      <description>首先，.section .data 表示定义了一个数据段，在这个段中定义了一系列的全局变量。其中，_app_num 是一个标签，表示一个 64 位的整数，初始值为 23。接下来是一系列的标签，分别代表了应用程序的起始地址，每个标签都是 64 位的整数。
接着，.section .data 后面又出现了一个标签 _app_names，它是一个字符串数组，包含了一组字符串，分别命名为 &amp;ldquo;ch2b_exit&amp;rdquo;、&amp;ldquo;ch2b_hello_world&amp;rdquo;、&amp;ldquo;ch2b_power&amp;rdquo; 等等。这些字符串名字对应了前面定义的应用程序的起始地址。
再往下，出现了一个标签 INIT_PROC，它是一个字符串，表示初始化进程的名称，值为 &amp;ldquo;usershell&amp;rdquo;。
之后，每个应用程序都有自己的标签和段名，比如 app_0_start、app_1_start 等等。每个标签都包含一个指令 .incbin，它用于将一个二进制文件（以字符串形式指定文件路径）插入到当前段中。
进程初始化分析 scheduler() fetch_task() // 获取下一个要执行的进程 swtch(&amp;amp;curenv-&amp;gt;context, nextenv-&amp;gt;context) // 切换到下一个进程上下文 // Per-process state struct proc { enum procstate state; // 进程状态 int pid; // 进程 ID uint64 ustack; // 进程用户栈虚拟地址 (用户页表) uint64 kstack; // 进程内核栈虚拟地址 (内核页表) struct trapframe *trapframe; // 进程中断帧 struct context context; // 用于保存进程内核态的寄存器信息，进程切换时使用 pagetable_t pagetable; // User page table uint64 max_page; uint64 program_brk; uint64 heap_bottom; struct proc * parent; // Parent process uint64 exit_code; struct file * files[FD_BUFFER_SIZE]; uint32 syscall_times[MAX_SYSCALL_NUM]; // 系统调用次数统计 uint64 start_time; // 进程开始运行时间 struct vma vmas[NVMA]; // 虚拟内存区域 }; wait 系统调用的功能 wait 系统调用是用于处理子进程终止状态的系统调用。其主要功能是等待子进程的终止，并获取子进程的退出状态信息。在操作系统中，当一个父进程创建了一个子进程后，通常会使用 wait 来等待子进程的终止，以便进行后续的处理，如回收子进程的资源或获取其运行结果。</description>
    </item>
  </channel>
</rss>
