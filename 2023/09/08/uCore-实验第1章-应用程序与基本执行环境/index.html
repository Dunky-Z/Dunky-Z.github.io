<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>uCore-实验第 1 章 - 应用程序与基本执行环境 - 如云泊</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">










<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="../../../../css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="如云泊" type="application/atom+xml">
</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="../../../../index.html">
                
                <img src="../../../../images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            uCore-实验第 1 章 - 应用程序与基本执行环境
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2023-09-08T02:45:14.000Z" itemprop="datePublished">9月 8 2023</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="../../../../categories/uCore-%E5%AE%9E%E9%AA%8C/">uCore 实验</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            40 分钟 读完 (约 6065 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="了解系统调用"><a href="#了解系统调用" class="headerlink" title="了解系统调用"></a>了解系统调用</h1><p>操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送请求，来执行一些必须由操作系统来完成的任务，例如读取文件、创建进程、分配内存等。</p>
<p>通俗地说，可以把操作系统看作一个巨大的服务员，而应用程序就像是顾客。应用程序不能直接访问硬件或执行特权操作，因为这样可能会导致系统不稳定或不安全。所以，应用程序需要通过系统调用来与操作系统进行交互，请求操作系统代表它完成某些任务。</p>
<p>当应用程序需要操作系统执行特定的功能时，它会调用适当的系统调用函数，并传递参数给它。然后操作系统会接收到这个请求，并根据请求的类型和参数来执行相应的操作。完成后，操作系统会将执行结果返回给应用程序。</p>
<p><strong>在 RISC-V 架构中</strong>，系统调用是通过使用特定的指令来实现的。具体来说，RISC-V 架构提供了一个称为 <code>ecall</code>（environment call）的指令来触发系统调用。</p>
<p>要使用 syscall，在 RISC-V 汇编代码中可以通过以下步骤来完成：</p>
<ol>
<li>将系统调用编号（syscall number）放入寄存器 a7 中，该编号对应于所需的系统调用功能。</li>
<li>将系统调用所需的参数放入其他相应的寄存器中。例如，参数传递给文件读取系统调用可能需要将文件描述符放入 a0 寄存器，缓冲区地址放入 a1 寄存器，以及读取的字节数放入 a2 寄存器。</li>
<li>执行 ecall 指令。这会触发操作系统处理当前运行的程序的系统调用请求。</li>
<li>操作系统接收到系统调用请求后，根据寄存器 a7 中的系统调用编号和其他寄存器中的参数来执行相应的操作。</li>
<li>当操作系统完成系统调用请求时，它将结果放入适当的寄存器中，通常是 a0 寄存器。</li>
<li>程序继续执行，可以检查结果并进行后续的处理。</li>
</ol>
<p>需要注意的是，具体的系统调用编号以及参数的传递方式会根据操作系统的实现而有所不同。所以在编写 RISC-V 汇编代码时，需要参考操作系统的相关文档来了解具体的系统调用接口和参数传递方式。</p>
<h1 id="makr-run-之后发生了什么？"><a href="#makr-run-之后发生了什么？" class="headerlink" title="makr run 之后发生了什么？"></a>makr run 之后发生了什么？</h1><p>当执行<code>make run</code>命令后，以下是运行流程的概述：</p>
<ol>
<li><p>内核代码编译：执行<code>make run</code>会触发 Makefile 中的相应规则，从而编译生成内核（kernel）二进制文件。</p>
</li>
<li><p>加载 kernel 并启动 QEMU：根据 QEMUOPTS 变量指定的参数，QEMU 加载生成的 kernel 二进制文件，并启动模拟器。</p>
</li>
<li><p>引导代码执行：在模拟器启动后，CPU 的通用寄存器被清零，程序计数器（PC）指向 0x1000 的位置，这里有硬件固化的一小段引导代码。该引导代码会迅速跳转到 0x80000000 处的 RustSBI（Rust Supervisor Binary Interface）。</p>
</li>
<li><p>RustSBI 完成硬件初始化：RustSBI 是一个用于与操作系统进行交互的接口层。在跳转到 RustSBI 之后，它会完成必要的硬件初始化工作。</p>
</li>
<li><p>执行操作系统第一条指令：RustSBI 在完成硬件初始化后，会跳转到 kernel 二进制文件所在内存位置 0x80200000 处，并开始执行我们操作系统的第一条指令。</p>
</li>
</ol>
<p>综上所述，执行<code>make run</code>命令会完成内核的编译和加载，启动 QEMU 虚拟机，并经过引导代码和 RustSBI 的处理，最终开始执行操作系统的第一条指令。</p>
<h1 id="了解链接脚本"><a href="#了解链接脚本" class="headerlink" title="了解链接脚本"></a>了解链接脚本</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># kernel.ld</span><br><span class="line">BASE_ADDRESS = 0x80200000;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">   . = BASE_ADDRESS;</span><br><span class="line">   skernel = .;</span><br><span class="line"></span><br><span class="line">   stext = .;</span><br><span class="line">   .text : &#123;</span><br><span class="line">      *(.text.entry)   # 第一行代码</span><br><span class="line">      *(.text .text.*)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kernel-ld-中的-BASE-ADDRESS-0x80200000-指定了内核的加载地址，这个地址哪来的？"><a href="#kernel-ld-中的-BASE-ADDRESS-0x80200000-指定了内核的加载地址，这个地址哪来的？" class="headerlink" title="kernel.ld 中的 BASE_ADDRESS = 0x80200000 指定了内核的加载地址，这个地址哪来的？"></a>kernel.ld 中的 <code>BASE_ADDRESS = 0x80200000</code> 指定了内核的加载地址，这个地址哪来的？</h2><p>以下内容摘自参考<a target="_blank" rel="noopener" href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/3first-instruction-in-kernel1.html">rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</a>：</p>
<p>在 Qemu 模拟的 virt 硬件平台上，物理内存的起始物理地址为 <code>0x80000000</code>，物理内存的默认大小为 128MiB，它可以通过 <code>-m</code> 选项进行配置。如果使用默认配置的 128MiB 物理内存则对应的物理地址区间为 <code>[0x80000000,0x88000000)</code> 。如果使用上面给出的命令启动 Qemu，那么在 Qemu 开始执行任何指令之前，首先把两个文件加载到 Qemu 的物理内存中：即作把作为 bootloader 的 rustsbi-qemu.bin 加载到物理内存以物理地址 <code>0x80000000</code> 开头的区域上，同时把内核镜像 <code>os.bin</code> 加载到以物理地址 <code>0x80200000</code> 开头的区域上。</p>
<p>为什么加载到这两个位置呢？这与 Qemu 模拟计算机加电启动后的运行流程有关。一般来说，计算机加电之后的启动流程可以分成若干个阶段，每个阶段均由一层软件或 固件 负责，每一层软件或固件的功能是进行它应当承担的初始化工作，并在此之后跳转到下一层软件或固件的入口地址，也就是将计算机的控制权移交给了下一层软件或固件。Qemu 模拟的启动流程则可以分为三个阶段：第一个阶段由固化在 Qemu 内的一小段汇编程序负责；第二个阶段由 bootloader 负责；第三个阶段则由内核镜像负责。</p>
<p>第一阶段：将必要的文件载入到 Qemu 物理内存之后，Qemu CPU 的程序计数器（PC, Program Counter）会被初始化为 0x1000，因此 Qemu 实际执行的第一条指令位于物理地址 0x1000，接下来它将执行寥寥数条指令并跳转到物理地址 <code>0x80000000</code> 对应的指令处并进入第二阶段。从后面的调试过程可以看出，该地址 <code>0x80000000</code> 被固化在 Qemu 中，作为 Qemu 的使用者，我们在不触及 Qemu 源代码的情况下无法进行更改。</p>
<p>第二阶段：由于 Qemu 的第一阶段固定跳转到 <code>0x80000000</code>，我们需要将负责第二阶段的 bootloader rustsbi-qemu.bin 放在以物理地址 <code>0x80000000</code> 开头的物理内存中，这样就能保证 <code>0x80000000</code> 处正好保存 bootloader 的第一条指令。在这一阶段，bootloader 负责对计算机进行一些初始化工作，并跳转到下一阶段软件的入口，在 Qemu 上即可实现将计算机控制权移交给我们的内核镜像 os.bin。这里需要注意的是，对于不同的 bootloader 而言，下一阶段软件的入口不一定相同，而且获取这一信息的方式和时间点也不同：入口地址可能是一个预先约定好的固定的值，也有可能是在 bootloader 运行期间才动态获取到的值。我们选用的 RustSBI 则是将下一阶段的入口地址预先约定为固定的 0x80200000，在 RustSBI 的初始化工作完成之后，它会跳转到该地址并将计算机控制权移交给下一阶段的软件——也即我们的内核镜像。</p>
<p>第三阶段：为了正确地和上一阶段的 RustSBI 对接，我们需要保证内核的第一条指令位于物理地址 <code>0x80200000</code> 处。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 0x80200000 开头的区域上。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核，也就达到了本节的目标。</p>
<blockquote>
<p>以上过程是 QEMU 中的启动流程，真实计算机的加电启动流程大致如下：<br>第一阶段：加电后 CPU 的 PC 寄存器被设置为计算机内部只读存储器（ROM，Read-only Memory）的物理地址，随后 CPU 开始运行 ROM 内的软件。我们一般将该软件称为固件（Firmware），它的功能是对 CPU 进行一些初始化操作，将后续阶段的 bootloader 的代码、数据从硬盘载入到物理内存，最后跳转到适当的地址将计算机控制权转移给 bootloader。它大致对应于 Qemu 启动的第一阶段，即在物理地址 0x1000 处放置的若干条指令。可以看到 Qemu 上的固件非常简单，因为它并不需要负责将 bootloader 从硬盘加载到物理内存中，这个任务此前已经由 Qemu 自身完成了。<br>第二阶段：bootloader 同样完成一些 CPU 的初始化工作，将操作系统镜像从硬盘加载到物理内存中，最后跳转到适当地址将控制权转移给操作系统。可以看到一般情况下 bootloader 需要完成一些数据加载工作，这也就是它名字中 loader 的来源。它对应于 Qemu 启动的第二阶段。在 Qemu 中，我们使用的 RustSBI 功能较弱，它并没有能力完成加载的工作，内核镜像实际上是和 bootloader 一起在 Qemu 启动之前加载到物理内存中的。<br>第三阶段：控制权被转移给操作系统。由于篇幅所限后面我们就不再赘述了。<br>值得一提的是，为了让计算机的启动更加灵活，bootloader 目前可能非常复杂：它可能也分为多个阶段，并且能管理一些硬件资源，从复杂性上它已接近一个传统意义上的操作系统。</p>
</blockquote>
<h1 id="终端是如何控制颜色的？"><a href="#终端是如何控制颜色的？" class="headerlink" title="终端是如何控制颜色的？"></a>终端是如何控制颜色的？</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LOG_COLOR</span> &#123;</span></span><br><span class="line">	RED = <span class="number">31</span>,</span><br><span class="line">	GREEN = <span class="number">32</span>,</span><br><span class="line">	BLUE = <span class="number">34</span>,</span><br><span class="line">	GRAY = <span class="number">90</span>,</span><br><span class="line">	YELLOW = <span class="number">93</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_LOG_ERROR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errorf(fmt, ...)                                               \</span></span><br><span class="line"><span class="meta">	do &#123;                                                               \</span></span><br><span class="line"><span class="meta">		int tid = threadid();                                          \</span></span><br><span class="line"><span class="meta">		printf(<span class="meta-string">&quot;\x1b[%dm[%s %d]&quot;</span> fmt <span class="meta-string">&quot;\x1b[0m\n&quot;</span>, RED, <span class="meta-string">&quot;ERROR&quot;</span>, tid,   \</span></span><br><span class="line"><span class="meta">		       ##__VA_ARGS__);                                         \</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br></pre></td></tr></table></figure>

<p>ANSI 转义码是一种用于控制终端输出的特殊字符序列。它们由<code>\x1b</code>（或<code>\033</code>）开头，后面跟着一系列数字和分号组成。</p>
<p>ANSI 转义码中的数字部分用于指定不同的控制操作，如设置文本颜色、背景颜色、光标位置等等。其中，用于设置颜色的转义码包括三个主要的部分：<code>\x1b[颜色代码m</code>。</p>
<p>具体来说，<code>\x1b[</code>表示开始使用控制序列，接下来的数字代表不同的颜色代码，最后的<code>m</code>表示结束控制序列。例如，<code>\x1b[31m</code>表示将文本颜色设置为红色，而<code>\x1b[0m</code>用于重置所有属性为默认值。</p>
<p>当终端遇到这样的转义序列时，它会解析并执行相应的控制操作，从而实现对文本颜色、背景颜色和其他属性的控制。</p>
<p>需要注意的是，不同的终端可能支持不同的 ANSI 转义码，并且不同操作系统也可能有不同的实现。因此，在编写使用 ANSI 转义码的代码时，建议先测试并确保其在目标终端上正常工作。</p>
<p>更多详细解释可以参考文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/790fc612aaa5">终端颜色控制 - 简书</a>。</p>
<h1 id="应用程序输出字符会调用-SBI-服务，SBI-中发生了什么？"><a href="#应用程序输出字符会调用-SBI-服务，SBI-中发生了什么？" class="headerlink" title="应用程序输出字符会调用 SBI 服务，SBI 中发生了什么？"></a>应用程序输出字符会调用 SBI 服务，SBI 中发生了什么？</h1><blockquote>
<p>因为对 Rust 语言不熟悉，所以这里的分析是基于 C 语言的 OpenSBI 来分析的，他们的逻辑是一样的。如果有熟悉 Rust 的可以查看 <a target="_blank" rel="noopener" href="https://github.com/rustsbi/rustsbi/blob/main/src/instance.rs">RustSBI 源码</a></p>
</blockquote>
<p>根据指导书中的解释以及阅读代码，我们知道调用了 <code>printf</code> 最终实际上是调用了 <code>sbi_call</code>。那么 <code>sbi_call</code> 是如何实现的呢？因为我是做驱动开发以及固件开发的，也经常需要使用 OpenSBI，所想多问一句，OpenSBI 是如何实现的呢？OpenSBI 是如何提供服务的呢？它是如何打印出字符的呢？</p>
<h2 id="内核中的-SBI-调用"><a href="#内核中的-SBI-调用" class="headerlink" title="内核中的 SBI 调用"></a>内核中的 SBI 调用</h2><p>我们先看一下内核中的 <code>sbi_call</code> 都做了写啥。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uCore-Tutorial-Code-2023S/os/sbi.c</span></span><br><span class="line"><span class="keyword">const</span> uint64 SBI_CONSOLE_PUTCHAR = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">console_putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sbi_call(SBI_CONSOLE_PUTCHAR, c, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uCore-Tutorial-Code-2023S/os/sbi.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">inline</span> <span class="title">sbi_call</span><span class="params">(uint64 which, uint64 arg0, uint64 arg1, uint64 arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用寄存器变量来保存参数值和系统调用编号</span></span><br><span class="line">    <span class="function"><span class="keyword">register</span> uint64 a0 <span class="title">asm</span><span class="params">(<span class="string">&quot;a0&quot;</span>)</span> </span>= arg0;  <span class="comment">// 将 &#x27;arg0&#x27; 的值保存在寄存器 &#x27;a0&#x27; 中</span></span><br><span class="line">    <span class="function"><span class="keyword">register</span> uint64 a1 <span class="title">asm</span><span class="params">(<span class="string">&quot;a1&quot;</span>)</span> </span>= arg1;  <span class="comment">// 将 &#x27;arg1&#x27; 的值保存在寄存器 &#x27;a1&#x27; 中</span></span><br><span class="line">    <span class="function"><span class="keyword">register</span> uint64 a2 <span class="title">asm</span><span class="params">(<span class="string">&quot;a2&quot;</span>)</span> </span>= arg2;  <span class="comment">// 将 &#x27;arg2&#x27; 的值保存在寄存器 &#x27;a2&#x27; 中</span></span><br><span class="line">    <span class="function"><span class="keyword">register</span> uint64 a7 <span class="title">asm</span><span class="params">(<span class="string">&quot;a7&quot;</span>)</span> </span>= which; <span class="comment">// 将 &#x27;which&#x27; 的值保存在寄存器 &#x27;a7&#x27; 中</span></span><br><span class="line">    <span class="comment">// 内联汇编代码使用 ecall 指令进行系统调用</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;ecall&quot;</span>  <span class="comment">// 使用 ecall 指令进行系统调用</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 在这段代码中，指令 &quot;ecall&quot; 的输入参数是寄存器 a0 a1 a2 和 a7，输出参数是寄存器 a0</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;=r&quot;</span>(a0)  <span class="comment">// 输出操作数：将返回值存储在变量 &#x27;a0&#x27; 中</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;r&quot;</span>(a0), <span class="string">&quot;r&quot;</span>(a1), <span class="string">&quot;r&quot;</span>(a2), <span class="string">&quot;r&quot;</span>(a7)  <span class="comment">// 输入操作数：传递参数和系统调用编号</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;memory&quot;</span>  <span class="comment">//  &quot;memory&quot; 标志告诉编译器，这条指令可能会修改内存中的数据，需要进行内存屏障操作来保证数据的正确性。 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a0;  <span class="comment">// 返回存储在变量 &#x27;a0&#x27; 中的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>那么 OpenSBI 如何提供服务？在<code>include/sbi/sbi_ecall.h</code>这种定义了每个<code>ecall</code>服务全局变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/sbi/sbi_ecall.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_base</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_legacy</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_time</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_rfence</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_ipi</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_vendor</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_hsm</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_srst</span>;</span></span><br></pre></td></tr></table></figure>

<p>在<code>lib/sbi/sbi_ecall.c</code>中注册了所有的<code>ecall</code>服务，并将其加到链表<code>ecall_exts_list</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbi_ecall_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> *<span class="title">ext</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sbi_ecall_exts_size; i++) &#123;</span><br><span class="line">		ext = sbi_ecall_exts[i];</span><br><span class="line">		ret = sbi_ecall_register_extension(ext);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbi_ecall_register_extension</span><span class="params">(struct sbi_ecall_extension *ext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ext || (ext-&gt;extid_end &lt; ext-&gt;extid_start) || !ext-&gt;handle)</span><br><span class="line">		<span class="keyword">return</span> SBI_EINVAL;</span><br><span class="line"></span><br><span class="line">	sbi_list_for_each_entry(t, &amp;ecall_exts_list, head) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start = t-&gt;extid_start;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> end = t-&gt;extid_end;</span><br><span class="line">		<span class="keyword">if</span> (end &lt; ext-&gt;extid_start || ext-&gt;extid_end &lt; start)</span><br><span class="line">			<span class="comment">/* no overlap */</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> SBI_EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SBI_INIT_LIST_HEAD(&amp;ext-&gt;head);</span><br><span class="line">	sbi_list_add_tail(&amp;ext-&gt;head, &amp;ecall_exts_list);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Iterate over list of given type</span></span><br><span class="line"><span class="comment"> * @param pos the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @param head the head for your list.</span></span><br><span class="line"><span class="comment"> * @param member the name of the list_struct within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sbi_list_for_each_entry(pos, head, member) \</span></span><br><span class="line"><span class="meta">	for (pos = sbi_list_entry((head)-&gt;next, typeof(*pos), member);	\</span></span><br><span class="line"><span class="meta">	     &amp;pos-&gt;member != (head); 	\</span></span><br><span class="line"><span class="meta">	     pos = sbi_list_entry(pos-&gt;member.next, typeof(*pos), member))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么服务 id 如何和相对应的服务绑定的呢？以<code>ecall_time</code>为例，查看其结构体原型<code>struct sbi_ecall_extension</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/sbi/sbi_ecall.h: 23</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbi_dlist</span> <span class="title">head</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> extid_start;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> extid_end;</span><br><span class="line">	<span class="keyword">int</span> (* probe)(<span class="keyword">unsigned</span> <span class="keyword">long</span> extid, <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_val);</span><br><span class="line">	<span class="keyword">int</span> (* handle)(<span class="keyword">unsigned</span> <span class="keyword">long</span> extid, <span class="keyword">unsigned</span> <span class="keyword">long</span> funcid,</span><br><span class="line">		       <span class="keyword">const</span> struct sbi_trap_regs *regs,</span><br><span class="line">		       <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_val,</span><br><span class="line">		       struct sbi_trap_info *out_trap);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到有 <code>extid_start</code>、<code>extid_end</code> 和 <code>handle</code>。</p>
<p>目前 OpenSBI 逐步将每个服务的实现都放在了<code>lib/sbi</code>单独文件中，以<code>ecall_time</code>为例，其实现在<code>lib/sbi/sbi_ecall_time.c</code>中。单独为其绑定回调处理函数<code>sbi_ecall_time_handler</code>。但是还有很多服务的实现还是放在了<code>lib/sbi/sbi_ecall_legacy.c</code>中，后续应该会逐步迁移。我们上文使用的<code>SBI_CONSOLE_PUTCHAR</code>服务就是在这里实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/sbi/sbi_ecall_legacy.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbi_ecall_extension</span> <span class="title">ecall_legacy</span> =</span> &#123;</span><br><span class="line">	.extid_start = SBI_EXT_0_1_SET_TIMER,</span><br><span class="line">	.extid_end = SBI_EXT_0_1_SHUTDOWN,</span><br><span class="line">	.handle = sbi_ecall_legacy_handler,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sbi_ecall_legacy_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> extid, <span class="keyword">unsigned</span> <span class="keyword">long</span> funcid,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">const</span> struct sbi_trap_regs *regs,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_val,</span></span></span><br><span class="line"><span class="params"><span class="function">				    struct sbi_trap_info *out_trap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbi_tlb_info</span> <span class="title">tlb_info</span>;</span></span><br><span class="line">	u32 source_hart = current_hartid();</span><br><span class="line">	ulong hmask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (extid) &#123;</span><br><span class="line">	<span class="keyword">case</span> SBI_EXT_0_1_SET_TIMER:</span><br><span class="line">		sbi_timer_event_start((u64)regs-&gt;a0);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SBI_EXT_0_1_CONSOLE_PUTCHAR:</span><br><span class="line">		sbi_putc(regs-&gt;a0);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SBI_EXT_0_1_CONSOLE_GETCHAR:</span><br><span class="line">		ret = sbi_getc();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就把 <code>id</code> 与相应的服务函数绑定。一个<code>extid</code>对应一个<code>handler</code>。</p>
<p>我们可以在找到<code>SBI_EXT_0_1_CONSOLE_PUTCHAR</code>的值，是与 Linux 内核里定义的值是一致的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/sbi/sbi_ecall_interface.h</span></span><br><span class="line"><span class="comment">/* SBI Extension IDs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SBI_EXT_0_1_CONSOLE_PUTCHAR		0x1</span></span><br></pre></td></tr></table></figure>

<h2 id="ecall-服务调用流程"><a href="#ecall-服务调用流程" class="headerlink" title="ecall 服务调用流程"></a>ecall 服务调用流程</h2><ol>
<li><p>在 <code>firmware/fw_base.S</code> 中注册了 <code>Machine Mode</code> 的 <code>trap handler</code>，即 <code>sbi_trap_handler</code>；</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">_start_warm:</span><br><span class="line">    /* Setup trap handler */</span><br><span class="line">    la	a4, _trap_handler</span><br><span class="line">    csrw	CSR_MTVEC, a4  /* CSR_MTVEC = _trap_handler */</span><br><span class="line"></span><br><span class="line">_trap_handler:</span><br><span class="line">    TRAP_SAVE_AND_SETUP_SP_T0</span><br><span class="line"></span><br><span class="line">    TRAP_SAVE_MEPC_MSTATUS 0</span><br><span class="line"></span><br><span class="line">    TRAP_SAVE_GENERAL_REGS_EXCEPT_SP_T0</span><br><span class="line"></span><br><span class="line">    TRAP_CALL_C_ROUTINE</span><br><span class="line"></span><br><span class="line">    TRAP_RESTORE_GENERAL_REGS_EXCEPT_SP_T0</span><br><span class="line"></span><br><span class="line">    TRAP_RESTORE_MEPC_MSTATUS 0</span><br><span class="line"></span><br><span class="line">    TRAP_RESTORE_SP_T0</span><br><span class="line"></span><br><span class="line">    mret</span><br><span class="line"></span><br><span class="line">.macro	TRAP_CALL_C_ROUTINE</span><br><span class="line">    /* Call C routine */</span><br><span class="line">    add	a0, sp, zero</span><br><span class="line">    call	sbi_trap_handler</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>lib/sbi/sbi_trap.c</code> 中定义了 <code>sbi_trap_handler</code>，处理各种 <code>mcause</code>，比如 <code>Illegal Instructions</code>，<code>Misaligned Load &amp; Store</code>, <code>Supervisor &amp; Machine Ecall</code> 等。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/sbi/sbi_trap.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbi_trap_handler</span><span class="params">(struct sbi_trap_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mcause) &#123;</span><br><span class="line">    <span class="keyword">case</span> CAUSE_ILLEGAL_INSTRUCTION:</span><br><span class="line">        rc  = sbi_illegal_insn_handler(mtval, regs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CAUSE_MISALIGNED_LOAD:</span><br><span class="line">        rc = sbi_misaligned_load_handler(mtval, mtval2, mtinst, regs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CAUSE_MISALIGNED_STORE:</span><br><span class="line">        rc  = sbi_misaligned_store_handler(mtval, mtval2, mtinst, regs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CAUSE_SUPERVISOR_ECALL:</span><br><span class="line">    <span class="keyword">case</span> CAUSE_MACHINE_ECALL:</span><br><span class="line">        rc  = sbi_ecall_handler(regs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* If the trap came from S or U mode, redirect it there */</span></span><br><span class="line">        trap.epc = regs-&gt;mepc;</span><br><span class="line">        trap.cause = mcause;</span><br><span class="line">        trap.tval = mtval;</span><br><span class="line">        trap.tval2 = mtval2;</span><br><span class="line">        trap.tinst = mtinst;</span><br><span class="line">        rc = sbi_trap_redirect(regs, &amp;trap);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>lib/sbi/sbi_ecall.c</code> 中定义了处理 <code>ecall mcause</code> 的 <code>sbi_ecall_handler</code>，它遍历上面 <code>ecall_exts_list</code> 中注册的各种 <code>ecall</code> 服务。</p>
</li>
<li><p><code>sbi_ecall_handler</code> 根据 Linux 内核传递的 <code>ext (extension id)</code> 找到链表中对应的 <code>ecall</code> 服务，执行其中的 <code>handle</code> 函数，该函数根据 <code>fid</code> 执行具体的服务内容。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/sbi/sbi_ecall.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbi_ecall_handler</span><span class="params">(struct sbi_trap_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> extension_id = regs-&gt;a7;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> func_id = regs-&gt;a6;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sbi_trap_info</span> <span class="title">trap</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> out_val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有 ecall 服务</span></span><br><span class="line">    ext = sbi_ecall_find_extension(extension_id);</span><br><span class="line">    <span class="keyword">if</span> (ext &amp;&amp; ext-&gt;handle) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了就执行</span></span><br><span class="line">        ret = ext-&gt;handle(extension_id, func_id,</span><br><span class="line">                regs, &amp;out_val, &amp;trap);</span><br><span class="line">        <span class="keyword">if</span> (extension_id &gt;= SBI_EXT_0_1_SET_TIMER &amp;&amp;</span><br><span class="line">            extension_id &lt;= SBI_EXT_0_1_SHUTDOWN)</span><br><span class="line">            is_0_1_spec = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = SBI_ENOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 我们可以发现 <code>extension_id</code> 就是 a7 寄存器，他和我们在 uCore OS 中定义的 <code>SBI_EXT_0_1_CONSOLE_PUTCHAR</code> 是一致的。</p>
</li>
</ol>
<h1 id="程序的内存布局与编译流程"><a href="#程序的内存布局与编译流程" class="headerlink" title="程序的内存布局与编译流程"></a>程序的内存布局与编译流程</h1><h2 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h2><h1 id="uCore-的编译系统"><a href="#uCore-的编译系统" class="headerlink" title="uCore 的编译系统"></a>uCore 的编译系统</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean build user</span></span><br><span class="line"><span class="comment"># 设置伪目标clean、build和user，可以通过命令make来执行这些目标</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: build_kernel</span></span><br><span class="line"><span class="comment"># 默认目标为build_kernel，即执行build_kernel目标下的指令</span></span><br><span class="line"></span><br><span class="line">LOG ?= error</span><br><span class="line"><span class="comment"># 定义一个变量LOG，默认值是error</span></span><br><span class="line"></span><br><span class="line">K = os</span><br><span class="line">TOOLPREFIX = riscv64-unknown-elf-</span><br><span class="line"></span><br><span class="line">CC = <span class="variable">$(TOOLPREFIX)</span>gcc</span><br><span class="line">AS = <span class="variable">$(TOOLPREFIX)</span>gcc</span><br><span class="line">LD = <span class="variable">$(TOOLPREFIX)</span>ld</span><br><span class="line">OBJCOPY = <span class="variable">$(TOOLPREFIX)</span>objcopy</span><br><span class="line">OBJDUMP = <span class="variable">$(TOOLPREFIX)</span>objdump</span><br><span class="line">PY = python3</span><br><span class="line">GDB = <span class="variable">$(TOOLPREFIX)</span>gdb</span><br><span class="line">CP = cp</span><br><span class="line"></span><br><span class="line">MKDIR_P = mkdir -p</span><br><span class="line"></span><br><span class="line">BUILDDIR = build</span><br><span class="line"></span><br><span class="line">C_SRCS = <span class="variable">$(<span class="built_in">wildcard</span> $K/*.c)</span></span><br><span class="line"><span class="comment"># 定义一个变量C_SRCS，使用wildcard函数匹配所有以.c为后缀的文件，并存储在$K目录下</span></span><br><span class="line"></span><br><span class="line">AS_SRCS = <span class="variable">$(<span class="built_in">wildcard</span> $K/*.S)</span></span><br><span class="line"><span class="comment"># 定义一个变量AS_SRCS，使用wildcard函数匹配所有以.S为后缀的文件，并存储在$K目录下</span></span><br><span class="line"></span><br><span class="line">C_OBJS = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BUILDDIR)</span>/, $(<span class="built_in">addsuffix</span> .o, $(<span class="built_in">basename</span> <span class="variable">$(C_SRCS)</span>)</span>))</span><br><span class="line"><span class="comment"># 定义一个变量C_OBJS，通过addprefix和addsuffix函数将$(C_SRCS)中的路径替换为$(BUILDDIR)，并将后缀修改为.o</span></span><br><span class="line"></span><br><span class="line">AS_OBJS = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BUILDDIR)</span>/, $(<span class="built_in">addsuffix</span> .o, $(<span class="built_in">basename</span> <span class="variable">$(AS_SRCS)</span>)</span>))</span><br><span class="line"><span class="comment"># 定义一个变量AS_OBJS，通过addprefix和addsuffix函数将$(AS_SRCS)中的路径替换为$(BUILDDIR)，并将后缀修改为.o</span></span><br><span class="line"></span><br><span class="line">OBJS = <span class="variable">$(C_OBJS)</span> <span class="variable">$(AS_OBJS)</span></span><br><span class="line"><span class="comment"># 定义一个变量OBJS，其值为$(C_OBJS)和$(AS_OBJS)的组合</span></span><br><span class="line"></span><br><span class="line">HEADER_DEP = <span class="variable">$(<span class="built_in">addsuffix</span> .d, $(<span class="built_in">basename</span> <span class="variable">$(C_OBJS)</span>)</span>)</span><br><span class="line"><span class="comment"># 定义一个变量HEADER_DEP，通过addsuffix函数将$(C_OBJS)中的后缀修改为.d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(HEADER_DEP)</span></span><br><span class="line"><span class="comment"># 包含$(HEADER_DEP)中的.d文件</span></span><br><span class="line"></span><br><span class="line">CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb</span><br><span class="line"><span class="comment"># 定义一个变量CFLAGS，并赋值为-Wall -Werror -O -fno-omit-frame-pointer -ggdb</span></span><br><span class="line"></span><br><span class="line">CFLAGS += -MD</span><br><span class="line"><span class="comment"># 将-MD选项追加到CFLAGS变量中，用于自动生成依赖关系文件</span></span><br><span class="line"></span><br><span class="line">CFLAGS += -mcmodel=medany</span><br><span class="line"><span class="comment"># 将-mcmodel=medany选项追加到CFLAGS变量中，用于指定内存模型</span></span><br><span class="line"></span><br><span class="line">CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax</span><br><span class="line"><span class="comment"># 将-ffreestanding -fno-common -nostdlib -mno-relax选项追加到CFLAGS变量中，用于编译无操作系统环境下的程序</span></span><br><span class="line"></span><br><span class="line">CFLAGS += -I$K</span><br><span class="line"><span class="comment"># 将-I$K选项追加到CFLAGS变量中，用于指定头文件搜索路径为$K目录下</span></span><br><span class="line"></span><br><span class="line">CFLAGS += <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span></span><br><span class="line"><span class="comment"># 将$(CC) -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector命令执行结果追加到CFLAGS变量中，用于禁用栈保护机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(LOG)</span>, error)</span><br><span class="line">CFLAGS += -D LOG_LEVEL_ERROR</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(LOG)</span>, warn)</span><br><span class="line">CFLAGS += -D LOG_LEVEL_WARN</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(LOG)</span>, info)</span><br><span class="line">CFLAGS += -D LOG_LEVEL_INFO</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(LOG)</span>, debug)</span><br><span class="line">CFLAGS += -D LOG_LEVEL_DEBUG</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(LOG)</span>, trace)</span><br><span class="line">CFLAGS += -D LOG_LEVEL_TRACE</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># 根据$(LOG)变量的值，向CFLAGS变量追加相应的预处理器选项，相当于添加了一个宏定义，log.h中的LOG_LEVEL_ERROR等宏定义会根据这个宏定义来决定是否生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable PIE when possible (for Ubuntu 16.10 toolchain)</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> -dumpspecs 2&gt;/dev/null | grep -e &#x27;[^f]no-pie&#x27;)</span>,)</span><br><span class="line">CFLAGS += -fno-pie -no-pie</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> -dumpspecs 2&gt;/dev/null | grep -e &#x27;[^f]nopie&#x27;)</span>,)</span><br><span class="line">CFLAGS += -fno-pie -nopie</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># 根据系统环境判断是否支持PIE（位置无关执行）选项，并根据情况向CFLAGS变量追加相应的选项</span></span><br><span class="line"></span><br><span class="line">LDFLAGS = -z max-page-size=4096</span><br><span class="line"><span class="comment"># 定义一个变量LDFLAGS，并赋值为-z max-page-size=4096</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(AS_OBJS)</span>: <span class="variable">$(BUILDDIR)</span>/$K/%.o : $K/%.S</span><br><span class="line">    @mkdir -p $(@D)</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 规则：生成$(AS_OBJS)目标所需的依赖文件$(BUILDDIR)/$K/%.o，依赖于$K/%.S，并通过$(CC)命令编译生成目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(C_OBJS)</span>: <span class="variable">$(BUILDDIR)</span>/$K/%.o : $K/%.c  <span class="variable">$(BUILDDIR)</span>/$K/%.d</span><br><span class="line">    @mkdir -p $(@D)</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 规则：生成$(C_OBJS)目标所需的依赖文件$(BUILDDIR)/$K/%.o，依赖于$K/%.c和$(BUILDDIR)/$K/%.d，并通过$(CC)命令编译生成目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(HEADER_DEP)</span>: <span class="variable">$(BUILDDIR)</span>/$K/%.d : $K/%.c</span><br><span class="line">    @mkdir -p $(@D)</span><br><span class="line">    @set -e; rm -f <span class="variable">$@</span>; <span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> <span class="variable">$(INCLUDEFLAGS)</span> &gt; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">        sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>; \</span><br><span class="line">        rm -f <span class="variable">$@</span>.$$$$</span><br><span class="line"><span class="comment"># 规则：生成$(HEADER_DEP)目标所需的依赖文件$(BUILDDIR)/$K/%.d，依赖于$K/%.c，并通过$(CC)命令生成依赖关系文件</span></span><br><span class="line"></span><br><span class="line"><span class="section">build: build/kernel</span></span><br><span class="line"><span class="comment"># 定义一个目标build，其依赖于build/kernel</span></span><br><span class="line"></span><br><span class="line"><span class="section">build/kernel: <span class="variable">$(OBJS)</span></span></span><br><span class="line">    <span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T os/kernel.ld -o <span class="variable">$(BUILDDIR)</span>/kernel <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(BUILDDIR)</span>/kernel &gt; <span class="variable">$(BUILDDIR)</span>/kernel.asm</span><br><span class="line">    <span class="variable">$(OBJDUMP)</span> -t <span class="variable">$(BUILDDIR)</span>/kernel | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(BUILDDIR)</span>/kernel.sym</span><br><span class="line">    @echo &#x27;Build kernel done&#x27;</span><br><span class="line"><span class="comment"># 规则：生成build/kernel目标，依赖于$(OBJS)，通过$(LD)命令连接生成kernel，并通过$(OBJDUMP)命令生成汇编文件和符号表</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(BUILDDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BOARD</span></span><br><span class="line">BOARD		?= qemu</span><br><span class="line">SBI			?= rustsbi</span><br><span class="line">BOOTLOADER	:= ./bootloader/rustsbi-qemu.bin</span><br><span class="line"></span><br><span class="line">QEMU = qemu-system-riscv64</span><br><span class="line">QEMUOPTS = \</span><br><span class="line">	-nographic \</span><br><span class="line">	-machine virt \</span><br><span class="line">	-bios <span class="variable">$(BOOTLOADER)</span> \</span><br><span class="line">	-kernel build/kernel	\</span><br><span class="line"></span><br><span class="line"><span class="section">run: build/kernel</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># QEMU&#x27;s gdb stub command line changed in 0.11</span></span><br><span class="line">QEMUGDB = <span class="variable">$(<span class="built_in">shell</span> <span class="built_in">if</span> <span class="variable">$(QEMU)</span> -help | grep -q &#x27;^-gdb&#x27;; \</span></span><br><span class="line"><span class="variable">	then echo &quot;-gdb tcp::15234&quot;; \</span></span><br><span class="line"><span class="variable">	else echo &quot;-s -p 15234&quot;; fi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动QEMU并通过GDB调试，此时QEMu会进入后台运行，并暂停执行，等待GDB连接</span></span><br><span class="line"><span class="comment"># 连接的GDB端口为15234</span></span><br><span class="line"><span class="section">debug: build/kernel .gdbinit</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span> -S <span class="variable">$(QEMUGDB)</span> &amp;</span><br><span class="line">	sleep 1</span><br><span class="line">	<span class="variable">$(GDB)</span></span><br></pre></td></tr></table></figure>

<p>编译、运行 uCore 的一些常用命令有如下一些，涉及了后续章节中引入的测试用例中的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">make run</span><br><span class="line">make debug</span><br><span class="line">make clean</span><br><span class="line"><span class="comment"># 编译测试用例的前四章</span></span><br><span class="line">make user CHAPTER=4 LOG=trace</span><br><span class="line"><span class="comment"># 编译测试用例的第四章</span></span><br><span class="line">make user CHAPTER=4_only LOG=trace</span><br><span class="line"><span class="comment"># 只运行测试用例的第四章</span></span><br><span class="line">make <span class="built_in">test</span> CHAPTER=4_only    </span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>makefile 和 qemu</p>
<p>AS = $(TOOLPREFIX)gas  &gt; AS = $(TOOLPREFIX)as</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/790fc612aaa5">终端颜色控制 - 简书</a></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="../../../../tags/Linux/">#Linux</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="../../../../tags/RISC-V/">#RISC-V</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="../../../../tags/OS/">#OS</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="../../../../tags/uCore/">#uCore</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="../../../../tags/Lab/">#Lab</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="../uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC0%E7%AB%A0-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">uCore-实验第 0 章 - 实验环境搭建</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="../uCore-%E5%AE%9E%E9%AA%8C%E7%AC%AC5%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">uCore 实验第 5 章 - 进程及进程管理</a>
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2024 Dominic&nbsp;
                powered_by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>




<script src="../../../../js/script.js"></script>


    
</body>
</html>