[{"content":"微信小程序开发不仅仅是写代码，还涉及服务器购买、域名备案、小程序备案、认证等一系列流程性工作。本文记录了从零开始开发微信小程序的完整流程，包括踩坑记录和注意事项，希望能帮助其他开发者少走弯路。\n服务器购买 选择云服务商 常见的云服务商有：\n阿里云（推荐） 腾讯云 华为云 百度云 服务器配置建议 小型个人小程序推荐配置：\nCPU：1核或2核 内存：2GB 带宽：1-3Mbps 系统盘：40GB 操作系统：CentOS 7.x 或 Ubuntu 18.04+ 费用参考：\n新用户通常有优惠，年费在100-500元不等 建议先购买1年，测试稳定后再续费 购买注意事项 选择离目标用户较近的地域节点，可以降低延迟 新用户可关注各大云平台的首购优惠 学生用户可申请学生优惠 注意查看带宽费用，避免后期流量费用过高 域名购买 购买域名1元起_.xin首年0元_域名优惠活动-阿里云权益中心\n选择合适的域名 小程序用户看不到域名，所以选择便宜的即可。用生日组合纯数字.xyz域名最便宜。\n选购技巧：\n选择一个最便宜的域名时，注册时选择2年看看后期续费费用 如果一年18元，两年120元，说明第二年费用恢复原价，太贵了不要买 推荐选择续费价格稳定的域名后缀 常见便宜域名后缀：\n.xyz：首年最便宜，但续费可能较贵 .top：价格适中 .site：价格适中 .club：价格适中 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 创建信息模板 下单时创建一个新的信息模板，避免之前创建过的填的信息不完善。购买之后会直接提交到域名注册局审核，信息不完善容易审核不通过。\n\u003c!DOCTYPE html\u003e Responsive Image 信息模板填写注意事项：\n姓名必须与身份证一致 地址填写详细，精确到门牌号 电话号码保持畅通，可能会接到审核电话 邮箱填写常用邮箱 域名实名认证 等待几小时（一般在6小时内），域名注册局实名认证成功，即可进行下一步备案。\n实名认证材料：\n个人：身份证正反面照片 企业：营业执照、法人身份证 ICP备案 点击网站备案_ICP备案_备案迁移_App备案_小程序备案_备案-阿里云开始备案。\n准备材料 需要准备身份证，根据提示填写个人信息即可。\n所需材料清单：\n身份证正反面照片（清晰、完整） 手持身份证照片 幕布照片（部分云服务商需要） 域名证书 服务器证明（购买凭证） 备案流程 填写备案信息\n主体信息（个人或企业信息） 网站信息（网站名称、域名等） 接入信息（服务器信息） 上传资料\n按要求上传各类证件照片 确保照片清晰可见 真实性核验\n部分地区需要视频核验 按照要求进行人脸识别 提交审核\n云服务商初审（1-2个工作日） 管局审核（3-20个工作日，各地不同） 重要提醒 不能和小程序备案同步进行！ ICP备案同一个主体（人）只能进行一个备案，需要当前备案结束后才能进行下一个。\n备案时长：\n首次备案：通常需要10-20个工作日 不同省份审核时间不同 遇到节假日会延长 备案网站命名规范：\n个人网站不能包含企业、行业等字样 不能涉及新闻、出版、教育、医疗等需要前置审批的内容 建议使用通用名称，如\u0026quot;XX个人博客\u0026quot;、\u0026ldquo;XX个人网站\u0026rdquo; 小程序备案 访问微信小程序公众平台进行备案。\n备案流程 补充小程序信息\n小程序名称 简介 服务类目 服务范围等 先提交微信官方审核\n微信会审核小程序信息是否合规 审核时间通常为1-3个工作日 审核通过自动提交到工信部审核\n工信部审核通过后，小程序备案完成 审核时间通常为7-20个工作日 审核不通过的处理\n审核不通过会电话联系，告知需要修改的地方 注意：电话会被小米手机标记为广告电话，请在提交审核这几天及时接听广告电话，避免错过！ 小程序平台会站内信告知需要修改的地方，但是不如电话里说的清楚 电话中不明白的可以及时问，但是错过电话就打不回去了 个人小程序备案说明 重要提示： 普通小工具类小程序不需要公司也不需要营业执照，用身份证提交就行。\n但是小程序备注需要注明：给自己使用。\n示例：\n比如我开发了一个Strava贴纸合成到照片的小程序 我的备注是：用于给自己将两张图片合成为一张图片 备注填写技巧：\n明确说明是个人使用 功能描述简洁明了 避免涉及商业用途 避免涉及社交、支付等敏感功能 小程序备案常见问题 Q1: 个人小程序可以选择哪些类目？\n工具类（如计算器、记事本） 生活服务类（非商业） 体育类 教育类（非学历教育） Q2: 个人小程序有哪些限制？\n不能涉及支付功能 不能涉及社交功能 不能涉及直播功能 不能发布商业广告 Q3: 小程序备案失败常见原因\n备注未说明个人使用 功能超出个人类目范围 服务器未备案或备案信息不一致 小程序名称不符合规范 小程序认证 小程序认证分为个人认证和企业认证，两者权限有较大差异。\n个人小程序（未认证） 限制：\n无法使用微信支付 无法使用卡券功能 无法使用附近的小程序 部分接口受限 每日访问用户数有上限 优势：\n免费 审核流程简单 适合个人学习和小工具开发 企业认证 认证费用： 300元/年（微信官方收取）\n所需材料：\n营业执照 法人身份证 对公账户信息（或法人微信支付） 企业邮箱 认证流程：\n登录小程序后台，点击\u0026quot;微信认证\u0026quot; 填写企业信息 上传营业执照等资料 选择认证方式： 对公账户打款验证（0.01元，需1-3个工作日） 法人微信扫码验证（即时验证，推荐） 等待审核（通常1-3个工作日） 企业认证的优势：\n开通微信支付功能 提升用户信任度 解锁更多API接口 无访问用户数限制 可以使用附近的小程序功能 可以发布卡券 认证注意事项 企业认证必须是已注册的企业，个体工商户也可以 年审： 企业认证每年需要重新认证，费用300元 认证后不可更改主体，请谨慎选择 认证信息要真实，虚假信息会导致认证失败甚至封号 开发环境配置 下载微信开发者工具 访问微信开发者工具下载页面，根据操作系统下载对应版本。\n支持平台：\nWindows 64位 macOS Linux 申请AppID 登录微信公众平台 进入小程序后台 在\u0026quot;开发\u0026quot; -\u0026gt; \u0026ldquo;开发管理\u0026rdquo; -\u0026gt; \u0026ldquo;开发设置\u0026quot;中查看AppID 复制AppID备用 创建第一个小程序项目 打开微信开发者工具 扫码登录 选择\u0026quot;小程序项目\u0026rdquo; 点击\u0026quot;+\u0026ldquo;创建项目 填写项目信息： 项目名称 目录（选择一个空文件夹） AppID（填写之前复制的AppID） 开发模式（选择\u0026quot;小程序\u0026rdquo;） 后端服务（选择\u0026quot;不使用云服务\u0026quot;，如需要后期可更改） 点击\u0026quot;新建\u0026quot; 服务器配置 配置服务器域名 小程序只能与配置过的服务器域名进行网络通信。\n配置步骤：\n登录微信公众平台 进入\u0026quot;开发\u0026quot; -\u0026gt; \u0026ldquo;开发管理\u0026rdquo; -\u0026gt; \u0026ldquo;开发设置\u0026rdquo; -\u0026gt; \u0026ldquo;服务器域名\u0026rdquo; 点击\u0026quot;修改\u0026quot; 分别配置： request合法域名（用于wx.request） socket合法域名（用于wx.connectSocket） uploadFile合法域名（用于wx.uploadFile） downloadFile合法域名（用于wx.downloadFile） 域名要求：\n必须是HTTPS协议 域名必须备案 域名不能使用IP地址 域名不能带端口号 一个月内最多修改5次 SSL证书申请 免费证书来源：\nLet\u0026rsquo;s Encrypt（推荐，免费，90天有效期） 阿里云免费证书（1年有效期） 腾讯云免费证书（1年有效期） 证书申请步骤（以阿里云为例）：\n登录阿里云控制台 搜索\u0026quot;SSL证书\u0026quot; 选择\u0026quot;免费证书\u0026quot; 填写域名信息 选择DNS验证或文件验证 完成验证后下载证书 在服务器上配置证书（Nginx/Apache） Nginx配置示例 server { listen 443 ssl; server_name yourdomain.com; ssl_certificate /path/to/cert.pem; ssl_certificate_key /path/to/key.pem; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_pass http://localhost:3000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } # HTTP自动跳转HTTPS server { listen 80; server_name yourdomain.com; return 301 https://$server_name$request_uri; } 小程序发布流程 代码开发 在微信开发者工具中进行开发 使用模拟器和真机预览测试 确保代码符合微信小程序规范 代码上传 在开发者工具中点击\u0026quot;上传\u0026quot; 填写版本号和项目备注 上传成功后可以在小程序后台看到 用户隐私保护指引设置 必须要设置这一项，否则上线后小程序还是会有问题，但是这些问题在调试版本里都不会出现。\n进入账号设置： \u003c!DOCTYPE html\u003e Responsive Image 拉到底部找到用户隐私保护指引\n\u003c!DOCTYPE html\u003e Responsive Image 填写完需要审核，耐心等待。\n为了能弹出对话框让用户同意隐私获取，需要在app.json中加入这行代码：\n\u0026#34;__usePrivacyCheck__\u0026#34;: true 这样小程序会在使用到获取隐私的接口时自动弹出来。\n如果你的小程序定制化程度高，你也可以选择在你想要的时候弹出来，那么你需要参考官方文档微信公众平台，自行修改。\n提交审核 登录微信公众平台 进入\u0026quot;版本管理\u0026quot; 选择刚上传的版本 点击\u0026quot;提交审核\u0026quot; 填写审核信息： 配置功能页面（至少添加一个页面） 填写测试账号（如有登录功能） 补充说明 提交等待审核 审核时长：\n一般1-7个工作日 首次审核可能较慢 节假日会延长 审核不通过处理 常见驳回原因：\n服务类目不符 涉及未开放的接口 功能描述与实际不符 页面存在违规内容 测试账号无法登录 处理方法：\n查看驳回原因 根据原因修改代码或说明 重新提交审核 发布上线 审核通过后：\n在\u0026quot;版本管理\u0026quot;中找到已通过审核的版本 点击\u0026quot;发布\u0026quot; 确认发布 等待几分钟，小程序即可被用户搜索和使用 开发注意事项 开发规范 代码规范\n使用ES6语法 保持代码简洁易读 合理使用组件化开发 添加必要的注释 性能优化\n图片压缩，使用webp格式 合理使用分包加载 避免频繁的setData操作 及时清理定时器和监听器 用户体验\n添加loading提示 处理网络异常情况 优化首屏加载速度 适配不同机型 常见问题 Q1: 开发时如何调试HTTPS请求？\n开发者工具中可以勾选\u0026quot;不校验合法域名\u0026quot; 但上线前必须配置好合法域名 Q2: 如何处理跨域问题？\n小程序不存在跨域问题 但需要在服务器域名白名单中 Q3: 小程序包大小限制？\n主包不能超过2MB 所有分包总大小不能超过20MB（使用分包优化后可达到更大） Q4: 如何快速预览真机效果？\n点击\u0026quot;预览\u0026quot;生成二维码 微信扫码即可在手机上预览 总结 微信小程序开发涉及的流程比较多，需要耐心完成每一步。主要流程总结如下：\n✅ 购买服务器和域名（注意选择性价比高的） ✅ ICP备案（10-20个工作日，不能与小程序备案同时进行） ✅ 小程序备案（7-20个工作日，个人备案注意备注\u0026quot;给自己使用\u0026quot;） ✅ 小程序认证（企业认证300元/年，个人可不认证） ✅ 配置开发环境（下载开发者工具，申请AppID） ✅ 配置服务器域名（申请SSL证书，配置HTTPS） ✅ 开发与测试（遵循开发规范，注意性能优化） ✅ 提交审核与发布（耐心等待审核，及时处理驳回） 时间规划建议：\n备案阶段：预留1个月时间 开发阶段：根据项目复杂度安排 审核发布：预留1周时间 预算建议（个人小程序）：\n服务器：100-500元/年 域名：10-100元/年 SSL证书：免费 小程序注册：免费（个人） 小程序认证：可选（企业300元/年） 希望这篇文章能帮助到正在开发小程序的朋友们，祝大家开发顺利！如有问题欢迎交流讨论。\n","permalink":"https://lifeislife.cn/posts/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e微信小程序开发不仅仅是写代码，还涉及服务器购买、域名备案、小程序备案、认证等一系列流程性工作。本文记录了从零开始开发微信小程序的完整流程，包括踩坑记录和注意事项，希望能帮助其他开发者少走弯路。\u003c/p\u003e","title":"微信小程序开发完整流程指南"},{"content":"问题背景 在使用阿里云轻量服务器时，经常会遇到一个令人头疼的问题：默认配置没有 Swap 交换空间。当运行内存占用较高的应用（如编译项目、运行 CI/CD 流程、部署应用等）时，服务器经常会因为内存不足而卡死或无响应。\n我在每次执行 Deploy 部署操作时都会遇到这个问题，机器直接卡死，无法继续工作。通过配置 Swap 交换空间，成功缓解了这一问题，现在运行稳定多了。\n什么是 Swap？ Swap（交换空间）是 Linux 系统中的一种虚拟内存技术。当物理内存（RAM）不足时，系统会将暂时不用的数据从内存转移到硬盘上的 Swap 空间，从而释放内存供其他程序使用。虽然 Swap 的读写速度比物理内存慢，但它可以有效防止系统因内存不足而崩溃。\n配置步骤 1. 检查当前 Swap 状态 首先，我们需要确认系统当前是否已经配置了 Swap：\nfree -h swapon --show 如果 Swap 行显示为 0，说明系统没有配置交换空间。\n2. 创建 Swap 文件 根据服务器内存大小，建议创建与内存容量相等或稍大的 Swap 空间。以 2GB 内存的服务器为例，创建 2GB 的 Swap 文件：\n# 方法一：使用 fallocate 快速创建（推荐） sudo fallocate -l 2G /swapfile # 方法二：如果 fallocate 命令不可用，使用 dd 命令 sudo dd if=/dev/zero of=/swapfile bs=1G count=2 说明：\n/swapfile 是 Swap 文件的路径，可以根据需要修改 2G 表示创建 2GB 大小的文件 fallocate 命令速度更快，优先使用 3. 设置文件权限 为了安全，Swap 文件应该只允许 root 用户读写：\nsudo chmod 600 /swapfile 4. 格式化为 Swap 格式 将创建的文件格式化为 Swap 交换空间：\nsudo mkswap /swapfile 5. 启用 Swap 激活刚刚创建的 Swap 文件：\nsudo swapon /swapfile 6. 验证 Swap 是否生效 再次查看内存和 Swap 状态：\nfree -h 输出示例：\ntotal used free shared buff/cache available Mem: 2.0G 1.2G 100M 10M 700M 600M Swap: 2.0G 0B 2.0G 可以看到 Swap 一行已经显示 2.0G，说明配置成功。\n7. 配置开机自动挂载 为了让 Swap 在系统重启后自动生效，需要将其写入 /etc/fstab 文件：\necho \u0026#39;/swapfile none swap sw 0 0\u0026#39; | sudo tee -a /etc/fstab 验证 /etc/fstab 配置是否正确：\ncat /etc/fstab 优化建议 调整 Swappiness 参数（可选） swappiness 参数控制系统使用 Swap 的积极程度，取值范围 0-100：\n0：尽可能不使用 Swap，只在内存完全不足时使用 60（默认值）：平衡使用物理内存和 Swap 100：积极使用 Swap 对于内存较小的服务器，建议将 swappiness 设置为 10-30，避免过度使用 Swap 导致性能下降：\n# 查看当前 swappiness 值 cat /proc/sys/vm/swappiness # 临时修改（重启后失效） sudo sysctl vm.swappiness=10 # 永久修改 echo \u0026#39;vm.swappiness=10\u0026#39; | sudo tee -a /etc/sysctl.conf sudo sysctl -p 注意事项 硬盘空间占用：Swap 文件会占用硬盘空间，创建前请确保有足够的磁盘空间 性能影响：虽然 Swap 可以缓解内存不足问题，但过度使用会导致系统变慢，因为硬盘读写速度远低于内存 监控使用情况：建议定期监控 Swap 的使用情况，如果经常大量使用 Swap，说明需要升级服务器配置或优化应用 监控 Swap 使用情况 实时查看内存和 Swap 状态 # 查看内存使用情况 free -h # 持续监控（每 2 秒刷新一次） watch -n 2 free -h 查看哪些进程在使用 Swap for file in /proc/*/status ; do awk \u0026#39;/VmSwap|Name/{printf $2 \u0026#34; \u0026#34; $3}END{ print \u0026#34;\u0026#34;}\u0026#39; $file; done | sort -k 2 -n -r | head -10 删除 Swap（如需移除） 如果以后需要删除 Swap 配置，可以执行以下步骤：\n# 1. 关闭 Swap sudo swapoff /swapfile # 2. 从 /etc/fstab 中删除对应行 sudo sed -i \u0026#39;/\\/swapfile/d\u0026#39; /etc/fstab # 3. 删除 Swap 文件 sudo rm /swapfile 总结 配置 Swap 是解决小内存服务器运行大型应用的有效方案。虽然不能完全替代物理内存，但可以在一定程度上缓解内存不足导致的系统卡死问题。对于阿里云轻量服务器这类默认没有 Swap 的环境，强烈建议配置 Swap 以提高系统稳定性。\n当然，如果应用长期大量使用 Swap，最根本的解决方案还是升级服务器配置或优化应用程序的内存使用。\n","permalink":"https://lifeislife.cn/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E8%BD%BB%E9%87%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEswap%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/","summary":"\u003ch2 id=\"问题背景\"\u003e问题背景\u003c/h2\u003e\n\u003cp\u003e在使用阿里云轻量服务器时，经常会遇到一个令人头疼的问题：\u003cstrong\u003e默认配置没有 Swap 交换空间\u003c/strong\u003e。当运行内存占用较高的应用（如编译项目、运行 CI/CD 流程、部署应用等）时，服务器经常会因为内存不足而卡死或无响应。\u003c/p\u003e","title":"阿里云轻量服务器配置Swap解决内存不足"},{"content":"在开发应用时,我们经常需要实现数据同步功能。例如我之前开发的表单填写工具(QuickFillForm),如果不保存到网盘,换个浏览器数据就丢失了;但如果接入 OneDrive 同步,用户就能在各个设备上无缝使用。本文将以这个实际案例为例,详细说明如何申请和配置 OneDrive API,帮助开发者快速实现网盘同步功能。\n应用场景 OneDrive API 适用于以下开发场景:\n跨设备数据同步: 浏览器插件、桌面应用的配置和数据同步 文件备份与恢复: 自动备份用户数据到云端,支持一键恢复 协作与分享: 实现文件共享、多人协作编辑功能 离线访问: 支持离线读取数据,在线自动同步 前置准备 在开始之前,你需要准备:\n✅ Microsoft 账号(个人账号或工作/学校账号均可) ✅ 开发环境(本文以浏览器插件为例) ✅ 基础的 JavaScript/API 调用知识 💡 提示: OneDrive API 提供了免费的开发者配额,个人应用完全够用。\n第一步: 注册 Azure 应用 1.1 访问 Azure Portal 打开浏览器,访问 Azure Portal 使用你的 Microsoft 账号登录 个人账号(如 Outlook、Hotmail 邮箱) 工作或学校账号(如公司/学校提供的 Office 365 账号) 如果没有 Azure 账号,可以免费注册 📌 注意: 即使没有 Azure 订阅,也可以注册应用。免费账号足够用于开发测试。\n1.2 进入应用注册页面 在 Azure Portal 首页的搜索栏中输入 \u0026ldquo;Azure Active Directory\u0026rdquo; 或 \u0026ldquo;Microsoft Entra ID\u0026rdquo; 点击搜索结果中的 Azure Active Directory 服务 在左侧菜单中找到 \u0026ldquo;应用注册\u0026rdquo; (App registrations) 点击顶部的 \u0026quot;+ 新注册\u0026quot; (New registration) 按钮 \u003c!DOCTYPE html\u003e Responsive Image 1.3 填写应用基本信息 在应用注册页面,需要填写以下关键信息:\n应用名称 字段: 名称 (Name) 示例: QuickFillForm Extension 或 我的数据同步应用 说明: 这是应用的显示名称,用户授权时会看到此名称 支持的账户类型 选择应用的用户范围,推荐选择:\n✅ 任何组织目录(任何 Azure AD 目录 - 多租户)中的帐户和个人 Microsoft 帐户(例如,Skype、Xbox) 英文选项: Accounts in any organizational directory (Any Azure AD directory - Multitenant) and personal Microsoft accounts (e.g. Skype, Xbox) 为什么选择这个选项?\n支持个人 Microsoft 账号(最广泛的用户群) 支持企业和学校账号 不限制组织,任何人都可以使用你的应用 其他选项说明:\n仅此组织目录: 仅限你的组织内部使用 任何组织目录: 仅限企业/学校账号,不支持个人账号 仅个人 Microsoft 账户: 仅支持个人账号 重定向 URI (Redirect URI) 这是 OAuth 认证完成后的回调地址,不同应用类型配置不同:\n浏览器插件 (Chrome/Edge):\n平台类型: Web URI 格式: https://\u0026lt;YOUR_EXTENSION_ID\u0026gt;.chromiumapp.org/onedrive 临时示例: https://abcdefghijklmnopqrstuvwxyz123456.chromiumapp.org/onedrive Web 应用:\n平台类型: Web URI 格式: https://yourdomain.com/callback 本地开发: http://localhost:3000/callback 桌面应用:\n平台类型: 公共客户端/本机 URI 格式: https://login.microsoftonline.com/common/oauth2/nativeclient ⚠️ 重要: 浏览器插件的 Extension ID 需要在插件安装后才能获取,稍后我们会更新这个配置。可以先填写一个临时值,或者留空后面再添加。\n1.4 完成注册 确认信息无误后,点击页面底部的 \u0026ldquo;注册\u0026rdquo; (Register) 按钮。\n注册成功后,会自动跳转到应用的 概述 (Overview) 页面,这里显示了应用的基本信息和重要 ID。\n第二步: 配置 API 权限 注册完应用后,需要为应用添加访问 OneDrive 的权限。\n2.1 进入 API 权限页面 在应用详情页面的左侧菜单中,点击 \u0026ldquo;API 权限\u0026rdquo; (API permissions) 你会看到默认已经添加了 User.Read 权限(这是用于读取用户基本信息的权限) 2.2 添加 Microsoft Graph 权限 点击页面中的 \u0026quot;+ 添加权限\u0026quot; (Add a permission) 按钮 在右侧弹出的面板中,点击 \u0026ldquo;Microsoft Graph\u0026rdquo; 选择 \u0026ldquo;委托的权限\u0026rdquo; (Delegated permissions) 💡 权限类型说明:\n委托的权限 (Delegated permissions): 应用代表已登录用户访问数据,需要用户授权 应用程序权限 (Application permissions): 应用以自己的身份访问数据,无需用户登录,需要管理员同意 2.3 选择所需权限 在搜索框中搜索并勾选以下权限:\nFiles.ReadWrite.AppFolder (推荐) 权限名称: Files.ReadWrite.AppFolder 权限级别: 委托的权限 作用: 允许应用读写应用专用文件夹中的文件 优势: 最安全的权限,应用只能访问自己创建的 Apps/\u0026lt;AppName\u0026gt; 文件夹 适用场景: 大多数应用数据同步场景 示例存储路径:\nOneDrive/ └── Apps/ └── QuickFillForm/ ├── quickfillform-data.json └── backup/ offline_access (必需) 权限名称: offline_access 权限级别: 委托的权限 作用: 允许应用在用户离线时访问数据 用途: 获取刷新令牌(refresh token),在访问令牌过期后自动续期 Files.ReadWrite.All (可选,不推荐) 权限名称: Files.ReadWrite.All 权限级别: 委托的权限 作用: 允许应用读写用户的所有文件 风险: 权限范围过大,可能引起用户担忧 适用场景: 需要访问用户整个 OneDrive 的应用(如文件管理器) 2.4 确认添加权限 勾选好权限后,点击底部的 \u0026ldquo;添加权限\u0026rdquo; (Add permissions) 按钮 返回 API 权限页面,确认列表中显示以下权限: ✅ User.Read (默认) ✅ Files.ReadWrite.AppFolder ✅ offline_access 2.5 授予管理员同意 (可选) 如果你是组织管理员,可以点击 \u0026ldquo;为 [组织名称] 授予管理员同意\u0026rdquo; 按钮 对于个人账号或公共应用,此步骤可以跳过 用户首次使用时会看到授权页面,点击\u0026quot;接受\u0026quot;即可 第三步: 获取应用凭据 3.1 复制 Client ID (应用程序 ID) 在应用详情页面的 \u0026ldquo;概述\u0026rdquo; (Overview) 选项卡中 找到 \u0026ldquo;应用程序(客户端) ID\u0026rdquo; (Application (client) ID) 这是一个 GUID 格式的字符串,类似: 12345678-1234-1234-1234-123456789abc 点击旁边的复制图标,将 Client ID 保存到安全的地方 🔒 安全提示: Client ID 是公开信息,可以在前端代码中使用。但不要将它与 Client Secret 混淆。\n3.2 是否需要 Client Secret? 对于不同类型的应用,Client Secret 的需求不同:\n应用类型 是否需要 Client Secret 原因 浏览器插件 ❌ 不需要 使用隐式授权流程或 PKCE 单页应用 (SPA) ❌ 不需要 前端代码无法安全存储密钥 Web 应用 (有后端) ✅ 需要 在服务器端安全存储 桌面/移动应用 ❌ 不需要 使用 PKCE 授权流程 如果需要 Client Secret,创建方法如下:\n在左侧菜单中点击 \u0026ldquo;证书和密码\u0026rdquo; (Certificates \u0026amp; secrets) 点击 \u0026quot;+ 新客户端密码\u0026quot; (New client secret) 输入描述(如 \u0026ldquo;生产环境密钥\u0026rdquo;),选择过期时间 点击 \u0026ldquo;添加\u0026rdquo; (Add) 立即复制密钥值,此密钥只显示一次 ⚠️ 警告: Client Secret 是敏感信息,必须妥善保管,不能提交到代码仓库。\n3.3 配置身份验证设置 在左侧菜单点击 \u0026ldquo;身份验证\u0026rdquo; (Authentication) 确认 重定向 URI 已正确添加 向下滚动到 \u0026ldquo;隐式授权和混合流\u0026rdquo; (Implicit grant and hybrid flows) 部分 对于浏览器插件或 SPA,需要启用:\n✅ 勾选 \u0026ldquo;访问令牌\u0026rdquo; (Access tokens) ✅ 勾选 \u0026ldquo;ID 令牌\u0026rdquo; (ID tokens) 对于使用授权码流程的应用,可以不勾选上述选项\n点击页面底部的 \u0026ldquo;保存\u0026rdquo; (Save) 按钮 第四步: 配置应用代码 以浏览器插件为例,说明如何在代码中配置 OneDrive API。\n4.1 获取浏览器插件的 Extension ID 如果你正在开发浏览器插件:\n打开 Chrome 或 Edge 浏览器 访问 chrome://extensions/ (Chrome) 或 edge://extensions/ (Edge) 开启右上角的 \u0026ldquo;开发者模式\u0026rdquo; (Developer mode) 点击 \u0026ldquo;加载已解压的扩展程序\u0026rdquo; (Load unpacked) 选择你的插件项目文件夹 安装成功后,在插件卡片上找到 \u0026ldquo;ID\u0026rdquo; 字段,复制扩展 ID 类似: abcdefghijklmnopqrstuvwxyz123456 4.2 更新 Azure 重定向 URI 返回 Azure Portal 的应用注册页面 进入 \u0026ldquo;身份验证\u0026rdquo; (Authentication) 更新或添加重定向 URI: https://abcdefghijklmnopqrstuvwxyz123456.chromiumapp.org/onedrive 将 abcdefghijklmnopqrstuvwxyz123456 替换为实际的扩展 ID 点击 \u0026ldquo;保存\u0026rdquo; (Save) 4.3 在代码中配置 Client ID 以 QuickFillForm 插件为例,在 onedrive-sync.js 文件中配置:\nclass OneDriveSync { constructor() { // 替换为你的 Azure 应用程序 ID (Client ID) this.clientId = \u0026#39;12345678-1234-1234-1234-123456789abc\u0026#39;; // 获取当前插件的 ID this.redirectUri = `https://${chrome.runtime.id}.chromiumapp.org/onedrive`; // Microsoft Graph API 端点 this.graphEndpoint = \u0026#39;https://graph.microsoft.com/v1.0\u0026#39;; // 应用专用文件夹路径 this.appFolderPath = \u0026#39;/me/drive/special/approot\u0026#39;; // 请求的权限范围 this.scopes = [ \u0026#39;Files.ReadWrite.AppFolder\u0026#39;, \u0026#39;offline_access\u0026#39; ]; } // 获取访问令牌 async getAccessToken() { return new Promise((resolve, reject) =\u0026gt; { chrome.identity.launchWebAuthFlow({ url: this.getAuthUrl(), interactive: true }, (redirectUrl) =\u0026gt; { if (chrome.runtime.lastError) { reject(chrome.runtime.lastError); return; } // 从回调 URL 中提取 access_token const url = new URL(redirectUrl); const token = url.hash.match(/access_token=([^\u0026amp;]*)/)?.[1]; if (token) { resolve(token); } else { reject(new Error(\u0026#39;无法获取访问令牌\u0026#39;)); } }); }); } // 构建授权 URL getAuthUrl() { const params = new URLSearchParams({ client_id: this.clientId, response_type: \u0026#39;token\u0026#39;, redirect_uri: this.redirectUri, scope: this.scopes.join(\u0026#39; \u0026#39;), response_mode: \u0026#39;fragment\u0026#39; }); return `https://login.microsoftonline.com/common/oauth2/v2.0/authorize?${params}`; } // 上传文件到 OneDrive async uploadFile(fileName, content) { const token = await this.getAccessToken(); const response = await fetch( `${this.graphEndpoint}${this.appFolderPath}:/${fileName}:/content`, { method: \u0026#39;PUT\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(content) } ); if (!response.ok) { throw new Error(`上传失败: ${response.statusText}`); } return await response.json(); } // 从 OneDrive 下载文件 async downloadFile(fileName) { const token = await this.getAccessToken(); const response = await fetch( `${this.graphEndpoint}${this.appFolderPath}:/${fileName}:/content`, { headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}` } } ); if (!response.ok) { throw new Error(`下载失败: ${response.statusText}`); } return await response.json(); } } // 使用示例 const onedriveSync = new OneDriveSync(); // 上传数据 onedriveSync.uploadFile(\u0026#39;data.json\u0026#39;, { key: \u0026#39;value\u0026#39; }) .then(() =\u0026gt; console.log(\u0026#39;上传成功\u0026#39;)) .catch(err =\u0026gt; console.error(\u0026#39;上传失败:\u0026#39;, err)); // 下载数据 onedriveSync.downloadFile(\u0026#39;data.json\u0026#39;) .then(data =\u0026gt; console.log(\u0026#39;下载的数据:\u0026#39;, data)) .catch(err =\u0026gt; console.error(\u0026#39;下载失败:\u0026#39;, err)); 4.4 Web 应用配置示例 对于传统 Web 应用(有后端),使用授权码流程更安全:\n// 前端代码 function loginWithOneDrive() { const clientId = \u0026#39;YOUR_CLIENT_ID\u0026#39;; const redirectUri = \u0026#39;https://yourdomain.com/callback\u0026#39;; const scopes = \u0026#39;Files.ReadWrite.AppFolder offline_access\u0026#39;; const authUrl = `https://login.microsoftonline.com/common/oauth2/v2.0/authorize?` + `client_id=${clientId}` + `\u0026amp;response_type=code` + `\u0026amp;redirect_uri=${encodeURIComponent(redirectUri)}` + `\u0026amp;scope=${encodeURIComponent(scopes)}`; window.location.href = authUrl; } // 后端代码 (Node.js Express 示例) app.get(\u0026#39;/callback\u0026#39;, async (req, res) =\u0026gt; { const code = req.query.code; // 用授权码换取访问令牌 const tokenResponse = await fetch(\u0026#39;https://login.microsoftonline.com/common/oauth2/v2.0/token\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; }, body: new URLSearchParams({ client_id: process.env.CLIENT_ID, client_secret: process.env.CLIENT_SECRET, code: code, redirect_uri: \u0026#39;https://yourdomain.com/callback\u0026#39;, grant_type: \u0026#39;authorization_code\u0026#39; }) }); const tokenData = await tokenResponse.json(); // 保存 access_token 和 refresh_token req.session.accessToken = tokenData.access_token; req.session.refreshToken = tokenData.refresh_token; res.redirect(\u0026#39;/dashboard\u0026#39;); }); 4.5 配置 manifest.json (浏览器插件) 在插件的 manifest.json 中添加必要的权限:\n{ \u0026#34;manifest_version\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;QuickFillForm\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;permissions\u0026#34;: [ \u0026#34;identity\u0026#34;, \u0026#34;storage\u0026#34; ], \u0026#34;host_permissions\u0026#34;: [ \u0026#34;https://login.microsoftonline.com/*\u0026#34;, \u0026#34;https://graph.microsoft.com/*\u0026#34; ], \u0026#34;oauth2\u0026#34;: { \u0026#34;client_id\u0026#34;: \u0026#34;12345678-1234-1234-1234-123456789abc.chromiumapp.org\u0026#34;, \u0026#34;scopes\u0026#34;: [ \u0026#34;Files.ReadWrite.AppFolder\u0026#34;, \u0026#34;offline_access\u0026#34; ] } } 第五步: 测试同步功能 5.1 测试用户认证 在应用中触发 OneDrive 登录流程 浏览器会打开 Microsoft 登录页面 输入 Microsoft 账号和密码登录 首次使用会看到权限请求页面: 显示应用名称 列出请求的权限 显示应用发布者信息 点击 \u0026ldquo;接受\u0026rdquo; (Accept) 按钮授权 5.2 测试文件上传 浏览器插件示例:\n// 测试上传功能 async function testUpload() { const testData = { name: \u0026#39;张三\u0026#39;, email: \u0026#39;zhangsan@example.com\u0026#39;, phone: \u0026#39;13800138000\u0026#39; }; try { const result = await onedriveSync.uploadFile(\u0026#39;test-data.json\u0026#39;, testData); console.log(\u0026#39;✅ 上传成功:\u0026#39;, result); } catch (error) { console.error(\u0026#39;❌ 上传失败:\u0026#39;, error); } } testUpload(); 5.3 测试文件下载 // 测试下载功能 async function testDownload() { try { const data = await onedriveSync.downloadFile(\u0026#39;test-data.json\u0026#39;); console.log(\u0026#39;✅ 下载成功:\u0026#39;, data); } catch (error) { console.error(\u0026#39;❌ 下载失败:\u0026#39;, error); } } testDownload(); 5.4 验证文件存储位置 登录 OneDrive 网页版 在左侧菜单中找到 \u0026ldquo;应用\u0026rdquo; (Apps) 文件夹 进入你的应用文件夹,例如 Apps/QuickFillForm/ 确认文件已成功上传 5.5 测试跨设备同步 在设备 A 上传数据 在设备 B 上登录同一 Microsoft 账号 下载数据,验证是否与设备 A 一致 修改数据后再次上传 在设备 A 上下载,验证是否更新 常见问题与解决方案 Q1: 无法获取访问令牌 错误信息:\nAADSTS50011: The redirect URI specified in the request does not match 原因分析:\nClient ID 配置错误 重定向 URI 不匹配 Extension ID 更改后未更新 Azure 配置 解决方案:\n检查代码中的 clientId 是否正确复制\n// 错误: 多余的空格或特殊字符 this.clientId = \u0026#39;12345678-1234-1234-1234-123456789abc \u0026#39;; // 正确 this.clientId = \u0026#39;12345678-1234-1234-1234-123456789abc\u0026#39;; 确认 Azure 应用注册中的重定向 URI 与代码完全一致\nAzure 配置: https://abcdefg123456.chromiumapp.org/onedrive 代码配置: https://abcdefg123456.chromiumapp.org/onedrive 注意区分大小写和尾部斜杠 保存配置后等待 2-5 分钟让配置生效\nQ2: 权限被拒绝,无法读写文件 错误信息:\n403 Forbidden: Access denied 原因分析:\n权限未正确添加 用户未授权 使用了错误的 API 端点 解决方案:\n在 Azure Portal 检查是否已添加 Files.ReadWrite.AppFolder 权限 清除用户授权,重新登录并同意权限 // 清除缓存的令牌 chrome.identity.clearAllCachedAuthTokens(() =\u0026gt; { console.log(\u0026#39;已清除缓存,请重新登录\u0026#39;); }); 确认使用正确的 API 路径: // 正确: 使用应用专用文件夹 const path = \u0026#39;/me/drive/special/approot:/data.json:/content\u0026#39;; // 错误: 使用根目录 (需要 Files.ReadWrite.All 权限) const path = \u0026#39;/me/drive/root:/data.json:/content\u0026#39;; Q3: 访问令牌过期 错误信息:\n401 Unauthorized: The access token has expired 原因分析:\nAccess Token 默认有效期 1 小时 未实现 Refresh Token 自动刷新机制 解决方案:\n实现令牌刷新逻辑:\nclass OneDriveSync { constructor() { this.accessToken = null; this.refreshToken = null; this.tokenExpiry = null; } // 获取有效的访问令牌 async getValidAccessToken() { // 如果令牌未过期,直接返回 if (this.accessToken \u0026amp;\u0026amp; this.tokenExpiry \u0026gt; Date.now()) { return this.accessToken; } // 如果有刷新令牌,尝试刷新 if (this.refreshToken) { return await this.refreshAccessToken(); } // 否则重新登录 return await this.getAccessToken(); } // 刷新访问令牌 async refreshAccessToken() { const response = await fetch(\u0026#39;https://login.microsoftonline.com/common/oauth2/v2.0/token\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; }, body: new URLSearchParams({ client_id: this.clientId, refresh_token: this.refreshToken, grant_type: \u0026#39;refresh_token\u0026#39; }) }); const data = await response.json(); this.accessToken = data.access_token; this.refreshToken = data.refresh_token; this.tokenExpiry = Date.now() + (data.expires_in * 1000); // 保存到本地存储 chrome.storage.local.set({ onedrive_access_token: this.accessToken, onedrive_refresh_token: this.refreshToken, onedrive_token_expiry: this.tokenExpiry }); return this.accessToken; } } Q4: 找不到扩展 ID 解决方案:\n访问浏览器的扩展管理页面: Chrome: chrome://extensions/ Edge: edge://extensions/ 确保已开启\u0026quot;开发者模式\u0026quot; Extension ID 显示在扩展卡片上,格式类似: ID: abcdefghijklmnopqrstuvwxyz123456 如果是已发布的扩展,可以在 Chrome Web Store 的 URL 中找到: https://chrome.google.com/webstore/detail/extension-name/abcdefghijklmnopqrstuvwxyz123456 Q5: 文件上传成功但在 OneDrive 中找不到 原因分析:\n使用了应用专用文件夹,路径在 Apps/\u0026lt;AppName\u0026gt;/ 下 OneDrive 网页版界面可能有延迟 文件名或路径错误 解决方案:\n在 OneDrive 网页版中,导航到: OneDrive → 应用 (Apps) → QuickFillForm 等待 1-2 分钟,刷新页面 使用 API 查询文件是否存在: // 列出应用文件夹中的所有文件 async function listFiles() { const token = await onedriveSync.getValidAccessToken(); const response = await fetch( \u0026#39;https://graph.microsoft.com/v1.0/me/drive/special/approot/children\u0026#39;, { headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}` } } ); const data = await response.json(); console.log(\u0026#39;文件列表:\u0026#39;, data.value); } Q6: 跨域请求被阻止 (CORS) 错误信息:\nAccess to fetch at \u0026#39;https://graph.microsoft.com/...\u0026#39; has been blocked by CORS policy 原因分析:\n在普通网页中直接请求 Graph API 未在 manifest.json 中配置 host_permissions 解决方案:\n方案一: 使用后端代理 (推荐)\n// 前端调用后端 API fetch(\u0026#39;/api/onedrive/upload\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: JSON.stringify(data) }); // 后端转发到 Microsoft Graph app.post(\u0026#39;/api/onedrive/upload\u0026#39;, async (req, res) =\u0026gt; { const response = await fetch(\u0026#39;https://graph.microsoft.com/v1.0/...\u0026#39;, { headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${accessToken}` } }); // ... }); 方案二: 浏览器插件配置\n{ \u0026#34;host_permissions\u0026#34;: [ \u0026#34;https://login.microsoftonline.com/*\u0026#34;, \u0026#34;https://graph.microsoft.com/*\u0026#34; ] } Q7: 授权页面显示\u0026quot;需要管理员审批\u0026quot; 错误信息:\nAADSTS65001: The user or administrator has not consented to use the application 原因分析:\n组织策略要求管理员批准应用 请求的权限需要管理员同意 解决方案:\n如果你是管理员,在 Azure Portal 中授予管理员同意 如果不是管理员,联系 IT 部门批准应用 使用个人 Microsoft 账号测试(个人账号无需管理员同意) 减少权限请求,只使用委托权限而不是应用权限 安全最佳实践 1. 保护 Client Secret // ❌ 错误: 在前端代码中硬编码密钥 const clientSecret = \u0026#39;your-secret-key-123456\u0026#39;; // ✅ 正确: 在后端使用环境变量 const clientSecret = process.env.AZURE_CLIENT_SECRET; 2. 使用最小权限原则 // ❌ 错误: 请求过多权限 const scopes = [ \u0026#39;Files.ReadWrite.All\u0026#39;, \u0026#39;Mail.Read\u0026#39;, \u0026#39;Contacts.ReadWrite\u0026#39; ]; // ✅ 正确: 只请求必需的权限 const scopes = [ \u0026#39;Files.ReadWrite.AppFolder\u0026#39;, \u0026#39;offline_access\u0026#39; ]; 3. 安全存储令牌 // ✅ 浏览器插件: 使用 chrome.storage.local chrome.storage.local.set({ onedrive_token: encryptedToken // 最好加密存储 }); // ✅ Web 应用: 使用 HttpOnly Cookie res.cookie(\u0026#39;access_token\u0026#39;, token, { httpOnly: true, secure: true, sameSite: \u0026#39;strict\u0026#39; }); 4. 定期检查应用活动 登录 Azure Portal 进入应用注册 → 你的应用 查看 \u0026ldquo;概述\u0026rdquo; 中的使用情况统计 检查异常登录和 API 调用 5. 处理敏感数据 // 上传前加密敏感数据 async function uploadSecureData(data) { const encrypted = await encryptData(data); await onedriveSync.uploadFile(\u0026#39;secure-data.enc\u0026#39;, encrypted); } // 下载后解密 async function downloadSecureData() { const encrypted = await onedriveSync.downloadFile(\u0026#39;secure-data.enc\u0026#39;); return await decryptData(encrypted); } 进阶技巧 1. 实现文件版本管理 OneDrive 自动保留文件版本历史,可以通过 API 访问:\nasync function getFileVersions(fileName) { const token = await onedriveSync.getValidAccessToken(); const response = await fetch( `https://graph.microsoft.com/v1.0/me/drive/special/approot:/${fileName}:/versions`, { headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}` } } ); const data = await response.json(); return data.value; // 返回版本列表 } 2. 实现增量同步 通过 Delta API 获取文件变化:\nasync function syncChanges(deltaLink) { const token = await onedriveSync.getValidAccessToken(); const url = deltaLink || \u0026#39;https://graph.microsoft.com/v1.0/me/drive/special/approot/delta\u0026#39;; const response = await fetch(url, { headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}` } }); const data = await response.json(); // 处理变化的文件 for (const item of data.value) { if (item.deleted) { console.log(\u0026#39;文件已删除:\u0026#39;, item.name); } else { console.log(\u0026#39;文件已更新:\u0026#39;, item.name); } } // 保存 deltaLink 供下次使用 return data[\u0026#39;@odata.deltaLink\u0026#39;]; } 3. 实现冲突解决 async function smartSync(fileName, localData) { try { // 下载远程文件 const remoteData = await onedriveSync.downloadFile(fileName); // 比较时间戳 if (remoteData.lastModified \u0026gt; localData.lastModified) { // 远程更新,下载覆盖本地 return { action: \u0026#39;download\u0026#39;, data: remoteData }; } else if (localData.lastModified \u0026gt; remoteData.lastModified) { // 本地更新,上传覆盖远程 await onedriveSync.uploadFile(fileName, localData); return { action: \u0026#39;upload\u0026#39;, data: localData }; } else { // 智能合并 const merged = mergeData(localData, remoteData); await onedriveSync.uploadFile(fileName, merged); return { action: \u0026#39;merge\u0026#39;, data: merged }; } } catch (error) { // 文件不存在,直接上传 if (error.status === 404) { await onedriveSync.uploadFile(fileName, localData); return { action: \u0026#39;create\u0026#39;, data: localData }; } throw error; } } 4. 批量操作 使用批处理 API 提高性能:\nasync function batchUpload(files) { const token = await onedriveSync.getValidAccessToken(); const requests = files.map((file, index) =\u0026gt; ({ id: index.toString(), method: \u0026#39;PUT\u0026#39;, url: `/me/drive/special/approot:/${file.name}:/content`, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: file.content })); const response = await fetch(\u0026#39;https://graph.microsoft.com/v1.0/$batch\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ requests }) }); return await response.json(); } 相关资源 官方文档 📘 Microsoft Graph API 文档 📘 OneDrive API 参考 📘 Azure AD 应用注册指南 📘 OAuth 2.0 授权流程 开发工具 🛠️ Graph Explorer - 在线测试 API 🛠️ Microsoft Graph SDK - 各语言 SDK 🛠️ Postman Collection - API 调试 示例项目 💻 OneDrive JavaScript SDK 💻 浏览器插件 OAuth 示例 社区资源 💬 Microsoft Graph 开发者论坛 💬 Stack Overflow - microsoft-graph ","permalink":"https://lifeislife.cn/posts/onedrive-api%E7%94%B3%E8%AF%B7%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e在开发应用时,我们经常需要实现数据同步功能。例如我之前开发的表单填写工具(QuickFillForm),如果不保存到网盘,换个浏览器数据就丢失了;但如果接入 OneDrive 同步,用户就能在各个设备上无缝使用。本文将以这个实际案例为例,详细说明如何申请和配置 OneDrive API,帮助开发者快速实现网盘同步功能。\u003c/p\u003e","title":"OneDrive API 申请配置指南 - 实现网盘同步功能"},{"content":"在日常开发中，我们经常需要在本地编写代码，然后将代码同步到远程服务器进行测试或部署。传统的方式是使用 FileZilla、WinSCP 等第三方工具手动上传文件，这种方式不仅繁琐，而且容易出错。VSCode 的 SFTP 插件可以帮助我们实现本地代码与远程服务器的自动同步，大大提高开发效率。\n应用场景 SFTP 插件适用于以下场景：\n本地开发，远程调试：在本地编写代码，保存后自动同步到远程服务器，无需手动上传 快速部署：本地测试通过后，一键同步到生产环境服务器 多服务器管理：同时管理多个远程服务器，快速切换上传目标 团队协作：统一开发环境，确保代码在服务器端运行一致 安装插件 打开 VSCode，按下快捷键 Ctrl + Shift + X 打开扩展商店，搜索 sftp，找到名为 SFTP 的插件（作者：Natizyskunk），这是安装量最高、最受欢迎的 SFTP 插件。点击安装即可。\n\u003c!DOCTYPE html\u003e Responsive Image 安装完成后，VSCode 会在侧边栏显示 SFTP 图标，表示插件已成功安装。\n配置插件 生成配置文件 插件安装完成后，我们需要为当前项目创建配置文件。有两种方式：\n方式一：使用命令面板\n按下快捷键 Ctrl + Shift + P 打开命令面板 输入 SFTP: Config 并回车 VSCode 会在当前工作区的 .vscode 文件夹下自动生成 sftp.json 配置文件 方式二：右键菜单\n在 VSCode 资源管理器中，右键点击项目文件夹 选择 SFTP: Config 同样会生成 sftp.json 配置文件 基础配置示例 打开生成的 sftp.json 文件，你会看到一个默认的配置模板。下面是一个基础配置示例：\n{ \u0026#34;name\u0026#34;: \u0026#34;我的服务器\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;192.168.1.100\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, \u0026#34;port\u0026#34;: 22, \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;your_password\u0026#34;, \u0026#34;remotePath\u0026#34;: \u0026#34;/var/www/project\u0026#34;, \u0026#34;uploadOnSave\u0026#34;: true, \u0026#34;useTempFile\u0026#34;: false, \u0026#34;openSsh\u0026#34;: false } 完整配置示例 下面是一个包含更多选项的完整配置示例：\n{ \u0026#34;name\u0026#34;: \u0026#34;生产环境服务器\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;192.168.1.100\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, \u0026#34;port\u0026#34;: 22, \u0026#34;username\u0026#34;: \u0026#34;deployer\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;your_password\u0026#34;, \u0026#34;remotePath\u0026#34;: \u0026#34;/home/deployer/project\u0026#34;, \u0026#34;context\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;uploadOnSave\u0026#34;: true, \u0026#34;useTempFile\u0026#34;: false, \u0026#34;openSsh\u0026#34;: false, \u0026#34;downloadOnOpen\u0026#34;: false, \u0026#34;ignore\u0026#34;: [ \u0026#34;.vscode\u0026#34;, \u0026#34;.git\u0026#34;, \u0026#34;.DS_Store\u0026#34;, \u0026#34;node_modules\u0026#34;, \u0026#34;*.log\u0026#34;, \u0026#34;*.tmp\u0026#34; ], \u0026#34;watcher\u0026#34;: { \u0026#34;files\u0026#34;: \u0026#34;**/*\u0026#34;, \u0026#34;autoUpload\u0026#34;: true, \u0026#34;autoDelete\u0026#34;: false }, \u0026#34;syncOption\u0026#34;: { \u0026#34;delete\u0026#34;: false, \u0026#34;skipCreate\u0026#34;: false, \u0026#34;ignoreExisting\u0026#34;: false, \u0026#34;update\u0026#34;: true }, \u0026#34;sshConfigPath\u0026#34;: null, \u0026#34;concurrency\u0026#34;: 4 } 配置参数详解 连接配置参数 参数 类型 说明 示例 name String 配置名称，用于区分多个服务器配置 \u0026quot;生产环境\u0026quot; host String 服务器 IP 地址或域名（必填） \u0026quot;192.168.1.100\u0026quot; port Number 端口号，SFTP 默认 22，FTP 默认 21 22 protocol String 传输协议，可选 sftp 或 ftp \u0026quot;sftp\u0026quot; username String 登录用户名（必填） \u0026quot;root\u0026quot; password String 登录密码 \u0026quot;your_password\u0026quot; 认证方式参数 SFTP 插件支持三种认证方式：\n1. 密码认证（最简单） { \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;your_password\u0026#34; } 2. 密钥认证（推荐） { \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;privateKeyPath\u0026#34;: \u0026#34;C:\\\\Users\\\\YourName\\\\.ssh\\\\id_rsa\u0026#34;, \u0026#34;passphrase\u0026#34;: \u0026#34;密钥密码（如果有的话）\u0026#34; } 密钥文件路径说明：\nWindows: C:\\\\Users\\\\YourName\\\\.ssh\\\\id_rsa 或 ~/.ssh/id_rsa Linux/Mac: ~/.ssh/id_rsa 支持 OpenSSH 格式和 PPK 格式的密钥 3. SSH Config 配置（高级） 如果你已经配置了 SSH config 文件，可以直接引用：\n{ \u0026#34;sshConfigPath\u0026#34;: \u0026#34;~/.ssh/config\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;myserver\u0026#34; } 对应的 SSH config 文件内容：\nHost myserver HostName 192.168.1.100 User deployer Port 22 IdentityFile ~/.ssh/id_rsa 路径配置参数 参数 类型 说明 示例 remotePath String 远程服务器的目标路径（必填） \u0026quot;/var/www/project\u0026quot; context String 本地项目的相对路径，默认为 ./ \u0026quot;./src\u0026quot; 路径配置说明：\n假设本地项目结构如下：\nproject/ ├── src/ │ ├── index.js │ └── utils.js ├── tests/ └── .vscode/ └── sftp.json 如果 context 为 \u0026quot;./\u0026quot; 且 remotePath 为 \u0026quot;/var/www/project\u0026quot;，则 src/index.js 会上传到 /var/www/project/src/index.js 如果 context 为 \u0026quot;./src\u0026quot; 且 remotePath 为 \u0026quot;/var/www/project\u0026quot;，则 src/index.js 会上传到 /var/www/project/index.js 自动同步参数 参数 类型 说明 默认值 uploadOnSave Boolean 保存文件时自动上传 false downloadOnOpen Boolean 打开文件时自动下载最新版本 false useTempFile Boolean 上传时使用临时文件（避免覆盖） false 最佳实践建议：\n开发环境：设置 uploadOnSave: true，方便快速同步 生产环境：设置 uploadOnSave: false，避免误操作 忽略文件配置 ignore 参数用于指定哪些文件或文件夹不需要同步，支持 glob 模式：\n{ \u0026#34;ignore\u0026#34;: [ \u0026#34;**/.vscode/**\u0026#34;, \u0026#34;**/.git/**\u0026#34;, \u0026#34;**/.DS_Store\u0026#34;, \u0026#34;**/node_modules/**\u0026#34;, \u0026#34;**/*.log\u0026#34;, \u0026#34;**/*.tmp\u0026#34;, \u0026#34;**/dist/**\u0026#34;, \u0026#34;**/coverage/**\u0026#34; ] } 常用忽略模式：\n**/.git/**：忽略 Git 版本控制文件 **/node_modules/**：忽略 Node.js 依赖包 **/*.log：忽略所有日志文件 **/dist/**：忽略构建输出目录 监听器配置（Watcher） 监听器可以监控文件变化并自动执行同步操作：\n{ \u0026#34;watcher\u0026#34;: { \u0026#34;files\u0026#34;: \u0026#34;**/*\u0026#34;, \u0026#34;autoUpload\u0026#34;: true, \u0026#34;autoDelete\u0026#34;: false } } 参数 类型 说明 默认值 files String 监听的文件模式（glob） false autoUpload Boolean 文件变化时自动上传 false autoDelete Boolean 本地删除文件时自动删除远程文件 false 注意事项：\nautoDelete: true 可能导致误删除，请谨慎使用 监听器会持续运行，可能影响性能，建议按需启用 同步选项（Sync Option） syncOption 用于配置手动同步时的行为：\n{ \u0026#34;syncOption\u0026#34;: { \u0026#34;delete\u0026#34;: false, \u0026#34;skipCreate\u0026#34;: false, \u0026#34;ignoreExisting\u0026#34;: false, \u0026#34;update\u0026#34;: true } } 参数 类型 说明 delete Boolean 删除远程服务器上多余的文件 skipCreate Boolean 跳过创建新文件 ignoreExisting Boolean 忽略已存在的文件 update Boolean 更新已修改的文件 性能优化参数 参数 类型 说明 默认值 concurrency Number 并发上传的文件数量 4 connectTimeout Number 连接超时时间（毫秒） 10000 keepalive Number 保持连接的间隔时间（毫秒） 10000 { \u0026#34;concurrency\u0026#34;: 8, \u0026#34;connectTimeout\u0026#34;: 15000, \u0026#34;keepalive\u0026#34;: 5000 } 性能优化建议：\n网络环境好时，可以增加 concurrency 提高上传速度 网络不稳定时，增加 connectTimeout 避免连接超时 频繁操作时，减小 keepalive 保持连接活跃 插件使用 常用操作 安装并配置好插件后，可以通过以下方式使用：\n1. 上传文件或文件夹 方式一：右键菜单\n在资源管理器中右键点击文件或文件夹 选择 Upload 上传到服务器 方式二：命令面板\n按 Ctrl + Shift + P 打开命令面板 输入 SFTP: Upload 并选择相应的命令 2. 下载文件或文件夹 右键点击文件或文件夹 选择 Download 从服务器下载 3. 同步操作 同步本地到远程：\n命令面板输入 SFTP: Sync Local -\u0026gt; Remote 将本地所有文件同步到服务器 同步远程到本地：\n命令面板输入 SFTP: Sync Remote -\u0026gt; Local 将服务器文件同步到本地 双向同步：\n命令面板输入 SFTP: Sync Both Directions 根据文件修改时间自动判断同步方向 4. 对比文件差异 右键点击文件 选择 Diff with Remote VSCode 会显示本地文件和远程文件的差异 5. 列出远程文件 命令面板输入 SFTP: List 可以浏览远程服务器的文件目录 完整命令列表 按 Ctrl + Shift + P 打开命令面板，输入 SFTP 可以看到所有可用命令：\n命令 说明 SFTP: Config 创建或编辑配置文件 SFTP: Upload 上传当前文件 SFTP: Upload Folder 上传整个文件夹 SFTP: Download 下载当前文件 SFTP: Download Folder 下载整个文件夹 SFTP: Sync Local -\u0026gt; Remote 本地同步到远程 SFTP: Sync Remote -\u0026gt; Local 远程同步到本地 SFTP: Sync Both Directions 双向同步 SFTP: Diff with Remote 对比本地和远程文件 SFTP: List 列出远程目录 SFTP: List All 列出所有配置的服务器 SFTP: Delete 删除远程文件 多服务器配置 在实际开发中，我们可能需要同时管理开发环境、测试环境和生产环境多个服务器。SFTP 插件支持在一个配置文件中配置多个服务器。\n配置多个服务器 在 sftp.json 中使用数组格式配置多个服务器：\n[ { \u0026#34;name\u0026#34;: \u0026#34;开发环境\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;192.168.1.101\u0026#34;, \u0026#34;port\u0026#34;: 22, \u0026#34;username\u0026#34;: \u0026#34;developer\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;dev_password\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, \u0026#34;remotePath\u0026#34;: \u0026#34;/home/developer/project\u0026#34;, \u0026#34;uploadOnSave\u0026#34;: true, \u0026#34;ignore\u0026#34;: [ \u0026#34;.vscode/**\u0026#34;, \u0026#34;.git/**\u0026#34;, \u0026#34;node_modules/**\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;测试环境\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;192.168.1.102\u0026#34;, \u0026#34;port\u0026#34;: 22, \u0026#34;username\u0026#34;: \u0026#34;tester\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;test_password\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, \u0026#34;remotePath\u0026#34;: \u0026#34;/var/www/test\u0026#34;, \u0026#34;uploadOnSave\u0026#34;: false, \u0026#34;ignore\u0026#34;: [ \u0026#34;.vscode/**\u0026#34;, \u0026#34;.git/**\u0026#34;, \u0026#34;node_modules/**\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;生产环境\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;192.168.1.103\u0026#34;, \u0026#34;port\u0026#34;: 22, \u0026#34;username\u0026#34;: \u0026#34;deployer\u0026#34;, \u0026#34;privateKeyPath\u0026#34;: \u0026#34;~/.ssh/production_key\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, \u0026#34;remotePath\u0026#34;: \u0026#34;/var/www/production\u0026#34;, \u0026#34;uploadOnSave\u0026#34;: false, \u0026#34;ignore\u0026#34;: [ \u0026#34;.vscode/**\u0026#34;, \u0026#34;.git/**\u0026#34;, \u0026#34;node_modules/**\u0026#34;, \u0026#34;*.log\u0026#34; ] } ] 切换服务器 配置多个服务器后，每次执行上传、下载等操作时，VSCode 会弹出选择框，让你选择目标服务器。\n也可以通过命令面板 SFTP: List All 查看所有配置的服务器。\n最佳实践 1. 安全配置建议 不要将密码明文写入配置文件：\n方案一：使用环境变量\n{ \u0026#34;username\u0026#34;: \u0026#34;${env.SFTP_USER}\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;${env.SFTP_PASSWORD}\u0026#34; } 方案二：使用密钥认证（推荐）\n{ \u0026#34;username\u0026#34;: \u0026#34;deployer\u0026#34;, \u0026#34;privateKeyPath\u0026#34;: \u0026#34;~/.ssh/id_rsa\u0026#34; } 将配置文件加入 .gitignore：\n.vscode/sftp.json 如果需要团队共享配置，可以创建一个 sftp.json.example 模板文件，将敏感信息替换为占位符：\n{ \u0026#34;name\u0026#34;: \u0026#34;示例配置\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;your_server_ip\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;your_username\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;your_password\u0026#34;, \u0026#34;remotePath\u0026#34;: \u0026#34;/path/to/project\u0026#34; } 2. 工作流建议 开发阶段：\n{ \u0026#34;uploadOnSave\u0026#34;: true, \u0026#34;downloadOnOpen\u0026#34;: false, \u0026#34;watcher\u0026#34;: { \u0026#34;autoUpload\u0026#34;: true } } 部署阶段：\n{ \u0026#34;uploadOnSave\u0026#34;: false, \u0026#34;syncOption\u0026#34;: { \u0026#34;update\u0026#34;: true, \u0026#34;delete\u0026#34;: false } } 3. 团队协作建议 为团队创建统一的配置模板：\n{ \u0026#34;name\u0026#34;: \u0026#34;团队开发服务器\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;${env.DEV_SERVER}\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;${env.DEV_USER}\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;${env.DEV_PASSWORD}\u0026#34;, \u0026#34;remotePath\u0026#34;: \u0026#34;/home/${env.DEV_USER}/project\u0026#34;, \u0026#34;uploadOnSave\u0026#34;: true, \u0026#34;ignore\u0026#34;: [ \u0026#34;.vscode/**\u0026#34;, \u0026#34;.git/**\u0026#34;, \u0026#34;.env\u0026#34;, \u0026#34;node_modules/**\u0026#34;, \u0026#34;*.log\u0026#34; ] } 团队成员在本地创建 .env 文件配置自己的环境变量即可。\n4. 性能优化建议 对于大型项目，建议优化以下配置：\n{ \u0026#34;concurrency\u0026#34;: 8, \u0026#34;ignore\u0026#34;: [ \u0026#34;node_modules/**\u0026#34;, \u0026#34;dist/**\u0026#34;, \u0026#34;build/**\u0026#34;, \u0026#34;.git/**\u0026#34;, \u0026#34;**/*.log\u0026#34; ], \u0026#34;syncOption\u0026#34;: { \u0026#34;update\u0026#34;: true } } 常见问题 1. 连接超时 **问题：**上传文件时提示连接超时。\n解决方案：\n检查服务器 IP 和端口是否正确 检查防火墙是否开放对应端口 增加 connectTimeout 参数： { \u0026#34;connectTimeout\u0026#34;: 30000 } 2. 权限不足 **问题：**上传文件提示 Permission denied。\n解决方案：\n确认登录用户对目标目录有写权限 在服务器上执行：chmod 755 /target/path 或切换到有权限的用户 3. 密钥认证失败 **问题：**使用密钥登录时提示认证失败。\n解决方案：\n确认密钥文件路径正确 确认密钥文件权限：chmod 600 ~/.ssh/id_rsa 如果密钥有密码，需要配置 passphrase Windows 用户注意路径格式：C:\\\\Users\\\\Name\\\\.ssh\\\\id_rsa 4. 文件同步冲突 **问题：**本地和远程文件都被修改，不知道以哪个为准。\n解决方案：\n使用 Diff with Remote 对比差异 手动合并代码后再上传 使用版本控制工具如 Git 管理代码 5. 上传速度慢 **问题：**上传大量文件时速度很慢。\n解决方案：\n增加并发数：\u0026quot;concurrency\u0026quot;: 10 完善 ignore 配置，避免上传不必要的文件 使用 Sync Local -\u0026gt; Remote 而不是 Upload Folder 参考资料 SFTP 插件官方文档 SSH 密钥认证配置 SFTP 协议介绍 ","permalink":"https://lifeislife.cn/posts/vscode-sftp%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%AD%A5/","summary":"\u003cp\u003e在日常开发中，我们经常需要在本地编写代码，然后将代码同步到远程服务器进行测试或部署。传统的方式是使用 FileZilla、WinSCP 等第三方工具手动上传文件，这种方式不仅繁琐，而且容易出错。VSCode 的 SFTP 插件可以帮助我们实现本地代码与远程服务器的自动同步，大大提高开发效率。\u003c/p\u003e","title":"VSCode SFTP插件实现本地代码与远程服务器同步"},{"content":"前言 Meta Quest 3 是一款优秀的 VR 一体机，但在国内激活存在网络限制问题。本文将介绍如何使用 Netch 工具，通过 Windows 电脑配置网络代理，实现 Quest 3 在国内的顺利激活。\n准备工作 在开始之前，你需要准备以下内容：\nWindows 电脑一台 一个路由器 VPN 代理 获取代理服务 首先需要获取一个 VPN 代理服务。可以访问以下任意链接注册，必须支持 UDP 转发，连接 WiFi 时需要对设备进行时间校准，这个校准步骤就同时验证这个 WiFi 是否可以连网，但这个校准是基于 UDP 的，只开启梯子的系统代理只能走 TCP 又不支持 UDP，所以只能上网不能校准时间。绝大部分机场不支持 UDP，你可以咨询机场客服是否支持 UDP 转发，也可以参考这篇文档Quest 网络受限原因 | Meta Quest 中文指南，测试是否支持 UDP。\n如果你没有代理，或者代理不支持 UDP，可以考虑使用以下代理，我已经测试过：\n龙猫云 老猫云 Web3加速器 选最便宜的买就行，后续可能会用其他不支持 UDP 便宜的机场，所以不要买贵的。我之前用的机场就不支持 UDP，但是平时使用完全够用，只有在 Quest3 激活是用到过这一次 UDP。\n机场注册之后注意看一下是否支持导出订阅地址，有一些机场只能使用自己的客户端，那就无法使用 Netch。请一定要注意！！！因为文章可能维护不及时，我也不保证上面的机场是否还支持导出订阅地址。之前使用过万达云的机场，用了一天就因为无法导出订阅地址无法使用了。他家改成只能使用自己的客户端了。\nNetch 配置步骤 下载 Netch 从Netch 开源主页下载最新版本。\n重要提示：使用 Netch 时不能同时开启其他代理软件！如果之前有开启其他代理，请全部关闭后重启电脑。\n安装 Netch 解压下载的压缩包到任意磁盘根目录 运行 Netch.exe 文件 安装 Npcap 前往官网下载 Npcap 并安装Npcap: Windows Packet Capture Library \u0026amp; Driver。\n安装时选择：\nSupport raw 802.11 traffic Install Npcap in WinPcap API-Compatible Mode 添加订阅 点击上方的\u0026quot;订阅\u0026quot; → \u0026ldquo;管理订阅\u0026rdquo; \u003c!DOCTYPE html\u003e Responsive Image 添加订阅链接 \u003c!DOCTYPE html\u003e Responsive Image 更新服务器 点击上方的\u0026quot;订阅\u0026quot; → \u0026ldquo;更新服务器\u0026rdquo; \u003c!DOCTYPE html\u003e Responsive Image 如果更新失败，检查订阅链接是否正确，确保关闭所有其他代理软件 选择节点 点击\u0026quot;服务器\u0026quot;，选择一个节点，优先选择美国节点 如果是自己的代理服务，可以多尝试不同节点 选择模式 点击\u0026quot;模式\u0026quot;，选择 [pcap2socks]Tencent(10.6.0.1)Preset\n\u003c!DOCTYPE html\u003e Responsive Image 配置 DNS 点击\u0026quot;设置\u0026quot; \u003c!DOCTYPE html\u003e Responsive Image 切换到\u0026quot;WinTUN\u0026quot;选项卡 勾选\u0026quot;使用自定义 DNS\u0026quot; 勾选\u0026quot;代理 DNS\u0026quot; 将 DNS 改为 1.1.1.1 点击右下角\u0026quot;保存\u0026quot; \u003c!DOCTYPE html\u003e Responsive Image 启动 Netch 点击右下角的\u0026quot;启动\u0026quot;按钮，等待启动完成。\n判断启动成功：\n\u0026ldquo;启动\u0026quot;按钮变成\u0026quot;停止\u0026rdquo; 下方出现绿色圆形标志 软件右侧出现以下终端窗口：\n\u003c!DOCTYPE html\u003e Responsive Image Quest 3 激活流程 1. 连接 WiFi 启动 Quest 3 在语言选择界面选择\u0026quot;简体中文\u0026quot; 选择\u0026quot;在头戴设备中输入 WIFI 信息\u0026quot; 选择你的路由器 WiFi，不要点击连接，需要后面配置高级选项 2. 配置静态 IP 输入 WiFi 密码后，点击\u0026quot;高级选项\u0026quot;\n将 IP 设置从\u0026quot;DHCP\u0026quot;改为\u0026quot;静态\u0026quot;\n配置静态 IP 地址\nIP 地址：10.6.0.1 网关：10.6.0.2 网络前缀长度：24 DNS1:8.8.8.8 滚动到页面最下方，点击\u0026quot;连接\u0026quot;\n正常情况下点击连接后，Netch 软件旁边的终端窗口会有响应，有一行输出提示某一个 IP 地址设备加入了链接。\n3. 系统更新 连接成功后，Quest 3 会自动进入更新流程。按照我的经验，激活过程中经常断连，所以需要多尝试几次。不要开始更新就把机器扔一边，经常看看。\n常见问题处理 提示\u0026quot;Wrong STUN Server\u0026quot; 进入设置，将 STUN 服务器改为以下任意一个：\nstun.voipstunt.com stun.xten.com stun.ekiga.net 没有绿点或显示 NOUDP/UnsupportedServer \u003c!DOCTYPE html\u003e Responsive Image 可能的解决方案：\n刷新状态：点击 NOUDP 刷新几次，如果变成黄点或红点也可能能用 兼容性问题：进入设置，勾选\u0026quot;TLS AllowInsecure\u0026quot;，保存后重试 \u003c!DOCTYPE html\u003e Responsive Image 修改 STUN 服务器：同上面的解决方案 检查其他软件：确保关闭所有其他代理软件后重启电脑 检查节点：选择其他节点重试 重启设备：重启路由器和 Netch 跳过绿点检查：如果后续 Quest3 能正常更新（进度条会走），可以不用管绿点 提示\u0026quot;找不到 VCRUNTIME140.dll\u0026quot; 搜索下载\u0026quot;Windows 常用运行库\u0026quot;并安装。\n","permalink":"https://lifeislife.cn/posts/quest3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8netch/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003eMeta Quest 3 是一款优秀的 VR 一体机，但在国内激活存在网络限制问题。本文将介绍如何使用 Netch 工具，通过 Windows 电脑配置网络代理，实现 Quest 3 在国内的顺利激活。\u003c/p\u003e\n\u003ch2 id=\"准备工作\"\u003e准备工作\u003c/h2\u003e\n\u003cp\u003e在开始之前，你需要准备以下内容：\u003c/p\u003e","title":"Quest3 激活教程 - 使用 Netch"},{"content":"当终端出现输入卡顿、命令执行后迟迟“回不来”的情况，往往不是单一因素导致。本文记录了我在 Git Bash 上的排查过程：最终发现是 oh-my-zsh 的 z 插件在家目录累积了大量 .z 数据文件，引发了明显的慢响应。同时也整理了一份更系统的优化与排错清单，帮助你快速定位并消除常见的性能瓶颈。\n一、现象与环境 Git Bash 终端卡顿：输入有明显延迟，命令执行后迟迟不返回提示符。 使用的是 zsh（配合 oh-my-zsh），启用了包括 z 在内的多个插件。 家目录出现了很多 .z 相关文件（z 插件的跳转数据库），怀疑数据库过大导致慢响应。 二、我的排查与解决过程 1) 先隔离配置：用干净的 zsh -f 启动 zsh -f 会在不加载 ~/.zshrc 的前提下启动一个“空配置”的 zsh，能快速判断是否是配置或插件导致问题。 如果 zsh -f 下终端恢复顺畅，基本可以确定问题在 ~/.zshrc 或其引入的插件与脚本。 2) 定位“嫌疑插件”：移除 ~/.zshrc 中的 z 插件 打开 ~/.zshrc，从 plugins=(...) 中移除 z，保存退出，重新打开终端。 如果卡顿消失，进一步确认 z 插件就是主要原因。 3) 清理 z 插件数据库：删除家目录下的 .z 数据文件 z 插件默认会在家目录存储路径权重数据库，文件名通常为 ~/.z（可能还有备份，比如 ~/.z.1 等）。\n执行：\nrm -f ~/.z ~/.z.* 注意：只删除 .z 及其备份，勿用宽泛的通配符误删其他以 .z 开头的配置文件（例如 ~/.zshrc、~/.zsh_history 等）。\n4) 验证 再次启动 Git Bash，观察输入响应与命令执行返回。若明显恢复正常，则问题确认并解决。 三、更多可能导致终端卡顿的原因与优化方法 下面按层次列出常见瓶颈与处理策略。建议从“快速隔离”到“逐步优化”依次进行。\nA. zsh 配置与插件层面 用 zsh -f 快速隔离：先确认卡顿是否源自 ~/.zshrc。\n用内置性能分析：\n在交互会话里执行：\nzmodload zsh/zprof source ~/.zshrc zprof 查看哪个函数或插件耗时最多，针对性优化或禁用。\n精简/优化高开销插件：\nzsh-autosuggestions：在超长历史或远程磁盘上可能放大延迟，必要时暂时禁用。 zsh-syntax-highlighting：对超长命令行或复杂高亮也可能造成卡顿，可移到 ~/.zshrc 最末加载或暂时禁用。 git 相关主题/段：提示符中显示仓库状态若每次刷新都做代价高的检测，易导致卡顿（详见下一节）。 清理与限制缓存/历史：\n删除过期的 ~/.zcompdump* 文件，让补全缓存重新生成：\nrm -f ~/.zcompdump* compinit -C 限制历史大小，避免历史过大：\nexport HISTSIZE=5000 export SAVEHIST=5000 必要时压缩或清理 ~/.zsh_history（先备份，再用专门工具或谨慎操作）。\n优化补全与缓存（选做）：\n# 开启补全缓存（需确保缓存目录存在） zstyle \u0026#39;:completion:*\u0026#39; use-cache on zstyle \u0026#39;:completion:*\u0026#39; cache-path $HOME/.zsh/cache 控制 PATH 长度与重复项：超长 PATH 或大量网络路径会增加命令解析成本，去重并移除不必要条目。\n跳转插件替代：如果依赖频繁路径跳转，可以考虑更高性能的 zoxide（Rust 实现，跨平台），或使用 fzf + cd 组合实现快速导航。\nB. Git 状态/提示符层面（对大型仓库尤其重要） 减少提示符的 Git 状态开销：\n如果使用 oh-my-zsh 的 git 主题段，可以只显示分支名，不显示“脏状态”（新增/删除/未跟踪），显著减少每次刷新调用：\nexport DISABLE_UNTRACKED_FILES_DIRTY=\u0026#34;true\u0026#34; 避免在 PROMPT 或 RPROMPT 中触发完整的 git status（尤其是有大量未跟踪文件时）。\n提升 Git 的基础性能（全局设置，温和安全）：\ngit config --global core.preloadIndex true git config --global core.fscache true git config --global gc.writeCommitGraph true git maintenance start 说明：\ncore.preloadIndex 与 core.fscache 常见于 Git for Windows 的加速选项（新版本多为默认开启，显式配置更稳妥）。 写入 commit-graph 与开启维护任务，可以加速多种 Git 操作（包括 status、log 等），对大仓库尤为明显。 仅在确定版本支持的情况下考虑文件监控（fsmonitor）：新版本 Git 在 Windows 上逐步完善内置 FS 监控特性，能减少反复扫描文件系统的成本。建议升级到较新的 Git for Windows 后再查阅对应版本说明开启；旧版或不支持时不要启用。\nC. 终端/系统层面（Windows） 升级工具与组件： 升级到最新的 Git for Windows。 如果使用外部终端（如 Windows Terminal），留意 ConPTY 后端的兼容参数；不同设置在部分环境下会影响交互流畅度。 杀毒/安全软件与索引扫描： 为 C:\\Program Files\\Git\\ 安装目录与主要仓库路径添加实时扫描排除规则，避免每次命令触发大量 I/O 扫描。 避免在网络盘、同步盘（如 OneDrive）或被系统索引服务重度扫描的目录中工作。 字体与渲染： 某些 Nerd Font 或高开销渲染配置在低配环境下也会造成刷新卡顿，可换用常规字体测试。 四、快速排查与操作清单（可直接拿来用） 干净启动，判断是否为配置问题：\nzsh -f 性能画像（找出最慢的函数/插件）：\nzmodload zsh/zprof source ~/.zshrc zprof 移除 z 插件，并清理数据库：\n编辑 ~/.zshrc，从 plugins=(...) 中删除 z；\n删除数据库文件：\nrm -f ~/.z ~/.z.* 限制 Git 状态显示开销（oh-my-zsh）：\nexport DISABLE_UNTRACKED_FILES_DIRTY=\u0026#34;true\u0026#34; 提升 Git 基础性能（全局）：\ngit config --global core.preloadIndex true git config --global core.fscache true git config --global gc.writeCommitGraph true git maintenance start 清理补全缓存并快速初始化：\nrm -f ~/.zcompdump* compinit -C 五、结语 这次卡顿的根因是 z 插件的路径数据库过大，移除插件并清理 .z 数据后问题即刻消失。更通用的经验是：先用 zsh -f 快速隔离，再用 zprof 定位耗时点\n","permalink":"https://lifeislife.cn/posts/git-bash%E7%BB%88%E7%AB%AF%E5%8D%A1%E9%A1%BF%E6%8E%92%E6%9F%A5%E5%AE%9E%E5%BD%95/","summary":"\u003cp\u003e当终端出现输入卡顿、命令执行后迟迟“回不来”的情况，往往不是单一因素导致。本文记录了我在 Git Bash 上的排查过程：最终发现是 oh-my-zsh 的 \u003ccode\u003ez\u003c/code\u003e 插件在家目录累积了大量 \u003ccode\u003e.z\u003c/code\u003e 数据文件，引发了明显的慢响应。同时也整理了一份更系统的优化与排错清单，帮助你快速定位并消除常见的性能瓶颈。\u003c/p\u003e","title":"Git Bash 终端卡顿排查实录：一次 z 插件数据库过大的坑与高效优化清单"},{"content":"创建普通用户，用户名为user\nuseradd -m user 修改默认shell为bash\nsudo usermod -s /bin/bash user 添加用户到sudoers\nsudo usermod -aG sudo user 立即生效配置\nsudo newgrp sudo 修改用户密码\nsudo passwd user 一键安装Docker\ncurl -fsSL https://cdn.jsdelivr.net/gh/muzihuaner/docker-install@master/install.sh -o install-docker.sh sh install-docker.sh 配置镜像仓库\necho \u0026#39;{\u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.1ms.run\u0026#34;]}\u0026#39; | sudo tee /etc/docker/daemon.json \u0026gt; /dev/null systemctl daemon-reload systemctl restart docker 添加当前用户到docker组，避免每次使用docker命令时都需要sudo\nsudo usermod -aG docker $USER 生效配置\nnewgrp docker 常见问题 安卓客户端登录密码错误 password invalid 确保hosts中的域名都能够被正常解析。\n127.0.0.1 us-or-rly101.zwift.com 127.0.0.1 secure.zwift.com 127.0.0.1 cdn.zwift.com 安卓设备可以下载应用Termux，可以使用ping命令检查域名是否能够被正常解析。\nping us-or-rly101.zwift.com ping secure.zwift.com ping cdn.zwift.com 一定到注意每个域名都测试一遍，之前有遇到过只有部分域名能够被正常解析的情况。如果发现部分域名能够被正常解析，而部分域名不能被正常解析，可以尝试使用txt编辑工具，比如txtpad，不要使用WPS，Microsoft Word等工具来编辑，这些工具可能会自动将域名转换为其他格式，导致无法被正常解析。用txtpad编辑后，保存为hosts.txt文件到能找到的位置，然后重新使用ping命令检查域名是否能够被正常解析。\n","permalink":"https://lifeislife.cn/posts/zwift%E5%8D%95%E6%9C%BA%E7%89%88%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA%E6%95%99%E7%A8%8B/","summary":"\u003cp\u003e创建普通用户，用户名为user\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003euseradd -m user\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改默认shell为bash\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo usermod -s /bin/bash user\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e添加用户到sudoers\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo usermod -aG sudo user\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e立即生效配置\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo newgrp sudo\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改用户密码\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo passwd user\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e一键安装Docker\u003c/p\u003e","title":"Zwift单机版多人联机教程"},{"content":"一切要从一个软件开始 某天看到Strava上自己的骑行轨迹，仓鼠的天性开始显露，既然能记录骑行的轨迹，为啥不把开车轨迹，步行轨迹都记录了？虽然早就听说了世界迷雾（Fog of World），但是因为走过的地方并不多，再加上安装过程比较复杂，所以一直没有尝试。现在看到骑行的地方越来越多，世界迷雾（Fog of World）的诱惑越来越大，于是开始折腾。\n使用这个软件就不多说了，反正倒腾Google Pay就捣鼓了好久，又花了20刀乐买了这个软件。\n虽然这个软件本身就是自带轨迹记录功能，但是使用手机导航的都知道，任何需要GPS功能的软件都是耗电大户，让这个软件常驻后台显然不能接受，一次偶然的机会，看到了这个设备，原来可以通过外置GPS记录轨迹，于是开始折腾。\n探险家V900 GPS轨迹记录器 一个快20年前的产品，早已经停产，目前只能找到它的升级版V990以及性能更好的产品，但是价格也贵了不少。即使现在能找到在售的V990，价格也要500块，还是没有舍得。只能在闲鱼上淘一下，140块淘了一个品相还不错的V900。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 因为对GPS硬件一窍不通，也不知道这个规格里的性能如何，只是想当然觉得专用的GPS记录器应该至少比手机强吧，但是东西到手只能感叹一句，技术进步太快了。\n这玩意只能获取GPS信号，但是现在最廉价的手机都能支持多种定位方式，包括GPS，北斗，GLONASS等等信号了，这意味它获取定位的精度和速度都远远不如手机。\n在室内定位了很久都没有定位成功，又专门到楼下空地还是无法定位，最终只能放弃，退回卖家，但是卖家也可能觉得是老古董了，估计很难卖出去，最终答应20块钱卖给我。我心想20块钱买个曾经500块的玩具，也挺划算的，于是就收下了。既然能开机，说明硬件应该没问题，应该还是能用的。\n折腾过程 无法定位 因为设备很久没有开机定位了，所以相当于冷启动，通常获取GPS信号时间就会很久，之前买新的码表时就会遇到这种情况，第一次定位花了很久，以为设备坏了，后来定位成功一次后，后续定位就很快了。于是我又找了一块广场空地开始定位，这次果然定位成功了。\n所以想要解决定位问题，首先不能在室内，室内因为混凝土遮挡信号，几乎无法定位成功，第一次定位时最好找个没有遮挡的空地，3-5分钟基本上能定位成功。\n无法记录轨迹 这个问题包括插入内存卡后，开机后自动关机，定位成功后设备发出急促的哔哔哔声音，这些都是因为内存卡分区格式问题导致的。\n因为这是快20年前的产品，那时候的内存卡大多还是4G以下的内存，文件系统还是FAT格式，现在想要买一个4G以下的内存卡都很难了，所以能见到的大部分内存卡都是无法直接在这个设备上使用，必须格式化成FAT格式。所以最好找一个小容量的卡，如果是4G以下的卡，通常可以在电脑上直接格式化为FAT或者FAT16，如果大于4G的卡，那就需要专门的软件来格式化了，并且格式化之后的容量最大就只有4G，所以最好买一个小容量卡。\n格式化的工具和步骤可以参考这个链接：How to record tracks in V-990/V-900 with a MicroSD card (Capacity above 4G)。虽然是老古董产品，但是这个常见的售后支持做的还是很到位的，这么多年都还保留了所有产品的文档和相关工具。\n最终卡信息如下：\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 产品文档链接：支持和下载\n\u003c!DOCTYPE html\u003e Responsive Image 使用蓝牙连接设备 这个功能当初开发出来应该是为了给一些软件提供第三方的导航功能的，但是现在导航工具已经触手可得，这个功能就没什么用了。如果你想尝试一下这个功能，可以下载一个Bluetooth GPS软件，Bluetooth GPS针对于Android - 从Uptodown上下载APK来连接设备。\n链接过程如下：\n长按开机键开机，自动进入蓝牙模式，蓝牙灯闪烁 打开手机蓝牙，搜索设备，找到设备后点击连接，设备名称为Columbus GPS 输入匹配码0000连接设备 打开软件选择Columbus GPS，点击连接 连接成功后，软件会显示设备信息，包括经纬度，速度，海拔等 \u003c!DOCTYPE html\u003e Responsive Image 轨迹实测 \u003c!DOCTYPE html\u003e Responsive Image 蓝色是佳明Forerunner 255的运动轨迹，红色是V900的轨迹，可以看到V900的性能在今天来说完全不够看了，漂移严重，并且海拔信息几乎不可用，这么点距离海拔爬升200多，在海宁这种大平原上，走一天都爬不了这么高。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E6%8E%A2%E9%99%A9%E5%AE%B6v900-gps%E8%BD%A8%E8%BF%B9%E8%AE%B0%E5%BD%95%E5%99%A8%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"一切要从一个软件开始\"\u003e一切要从一个软件开始\u003c/h1\u003e\n\u003cp\u003e某天看到Strava上自己的骑行轨迹，仓鼠的天性开始显露，既然能记录骑行的轨迹，为啥不把开车轨迹，步行轨迹都记录了？虽然早就听说了世界迷雾（Fog of World），但是因为走过的地方并不多，再加上安装过程比较复杂，所以一直没有尝试。现在看到骑行的地方越来越多，世界迷雾（Fog of World）的诱惑越来越大，于是开始折腾。\u003c/p\u003e","title":"探险家V900 GPS轨迹记录器折腾笔记"},{"content":"Strava Statistics 部署文档 Strava Statistics 是一个自托管工具，利用 Strava 数据生成个人运动统计，支持 Docker 部署，提供丰富的可视化分析。下面介绍如何使用 Docker Compose 部署。\n申请 Strava 的 API 权限 在ZwiftOffline中也需要用到 API 权限，因为不同应用程序也不冲突，懒得再重新申请，所以以下填的信息使用的 ZwiftOffline 的 API 权限。\n登录Strava，申请 API，获取Client ID和Client Secret。\n填写内容可以参考下图：\n\u003c!DOCTYPE html\u003e Responsive Image 其中授权回调域填写：launcher.zwift.com\n申请完成后会得到下面的信息：\n\u003c!DOCTYPE html\u003e Responsive Image 将下面链接中的client_id值换成上图中的客户 ID，然后浏览器中访问这个链接：\nhttp://www.strava.com/oauth/authorize?client_id=xxxxxxx\u0026amp;response_type=code\u0026amp;redirect_uri=http://localhost/exchange_token\u0026amp;approval_prompt=force\u0026amp;scope=activity:read_all 点击授权：\n\u003c!DOCTYPE html\u003e Responsive Image 此时跳转到一个无法访问的网页，将地址栏中的code值记录下来，后面需要用到：\n\u003c!DOCTYPE html\u003e Responsive Image 需要用这个code发起一个 cURL 请求得到refresh_token，具体做法是在命令行终端中执行下面的命令：\ncurl -X POST https://www.strava.com/oauth/token \\ -F client_id=YOURCLIENTID \\ -F client_secret=YOURCLIENTSECRET \\ -F code=AUTHORIZATIONCODE \\ -F grant_type=authorization_code client_id值替换为申请得到的客户ID client_secret值替换为申请得到的客户端密钥 code替换为上一步浏览器中得到的code 执行成功后可以得到下面的返回信息，需要将返回值中的refresh_token和access_token记录下来，后面需要用到：\n{\u0026#34;token_type\u0026#34;:\u0026#34;Bearer\u0026#34;,\u0026#34;expires_at\u0026#34;:1740213400,\u0026#34;expires_in\u0026#34;:21600,\u0026#34;refresh_token\u0026#34;:\u0026#34;123456789123456789\u0026#34;,\u0026#34;access_token\u0026#34;:\u0026#34;123456789123456789\u0026#34;,\u0026#34;athlete\u0026#34;:{\u0026#34;id\u0026#34;:117756825,\u0026#34;username\u0026#34;:\u0026#34;dunky_zhang\u0026#34;,\u0026#34;resource_state\u0026#34;:2,\u0026#34;firstname\u0026#34;:\u0026#34;Dominic\u0026#34;,\u0026#34;lastname\u0026#34;:\u0026#34;Zhang\u0026#34;,\u0026#34;bio\u0026#34;:\u0026#34;骑行小白\u0026#34;,\u0026#34;city\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;country\u0026#34;:null,\u0026#34;sex\u0026#34;:\u0026#34;M\u0026#34;,\u0026#34;premium\u0026#34;:true,\u0026#34;summit\u0026#34;:true,\u0026#34;created_at\u0026#34;:\u0026#34;2023-05-10T13:54:32Z\u0026#34;,\u0026#34;updated_at\u0026#34;:\u0026#34;2025-02-06T05:29:52Z\u0026#34;,\u0026#34;badge_type_id\u0026#34;:1,\u0026#34;weight\u0026#34;:66.0,\u0026#34;profile_medium\u0026#34;:\u0026#34;https://dgalywyr863hv.cloudfront.net/pictures/athletes/117756825/32138099/2/medium.jpg\u0026#34;,\u0026#34;profile\u0026#34;:\u0026#34;https://dgalywyr863hv.cloudfront.net/pictures/athletes/117756825/32138099/2/large.jpg\u0026#34;,\u0026#34;friend\u0026#34;:null,\u0026#34;follower\u0026#34;:null}}# Docker Compose 部署 Strava Statistics 创建目录用于存放 Strava Statistics 的配置文件\nmkdir statistics-for-strava cd statistics-for-strava 创建 docker-compose.yml 文件\ntouch docker-compose.yml 编辑 docker-compose.yml 文件，填入以下内容：\nservices: app: image: robiningelbrecht/strava-statistics:latest volumes: - ./build:/var/www/build - ./storage/database:/var/www/storage/database - ./storage/files:/var/www/storage/files env_file: ./.env ports: - 8080:8080 environment: - PUID=1000 - PGID=1000 - TZ=Asia/Shanghai # 因为 Strava 的 API 需要代理访问，所以下面设置了我的代理地址，请你根据自己的代理地址进行设置 - http_proxy=http://192.168.1.9:7890 - https_proxy=http://192.168.1.9:7890 - all_proxy=socks5://192.168.1.9:7891 创建 .env 文件\ntouch .env 编辑 .env 文件，填入以下内容：\n# 应用程序将托管的URL。此URL将用于清单文件中。 # 这将允许您将Web应用程序作为原生应用程序安装到您的设备上。 MANIFEST_APP_URL=http://localhost:8080/ # 您的Strava应用程序的客户端ID。 STRAVA_CLIENT_ID=xxxxxxx # 您的Strava应用程序的客户端密钥。 STRAVA_CLIENT_SECRET=xxxxxxxxxxxxxx # 您的Strava应用程序的刷新令牌。在上一步获取到的 STRAVA_REFRESH_TOKEN=xxxxxxxxxxxxxx # Strava API有限速限制（https://github.com/robiningelbrecht/strava-statistics/wiki）， # 为了确保我们不会达到限速，我们希望限制每次导入处理的新活动数量。 # 考虑到每天有1000次请求限制，并且导入一个新活动最多可能需要3次API调用，250应该是一个安全的数字。 NUMBER_OF_NEW_ACTIVITIES_TO_PROCESS_PER_IMPORT=250 # 定期运行导入和HTML构建的计划。留空以禁用定期导入。 # 默认计划为每天凌晨04:05运行一次。如果您不知道什么是cron表达式，请勿更改此项。 # 请确保不要过于频繁地运行导入，以避免达到Strava API的限速。每天一次应该足够。 IMPORT_AND_BUILD_SCHEDULE=\u0026#34;5 4 * * *\u0026#34; # 设置用于计划的时区 # 有效的时区可以在此处找到（TZ标识符列）：https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List TZ=Asia/Shanghai # 允许的选项：en_US、fr_FR 或 nl_BE LOCALE=en_US # 允许的选项：metric（公制）或 imperial（英制） UNIT_SYSTEM=metric # 渲染应用程序时使用的时间格式 # 允许的格式：24 或 12（包括AM和PM） TIME_FORMAT=24 # 渲染应用程序时使用的日期格式 # 允许的格式：DAY-MONTH-YEAR（日-月-年）或 MONTH-DAY-YEAR（月-日-年） DATE_FORMAT=DAY-MONTH-YEAR # 要导入的运动类型。留空以导入所有运动类型。 # 通过此列表，您还可以决定运动类型的渲染顺序。 # 完整的允许选项列表可在以下地址找到：https://github.com/robiningelbrecht/strava-statistics/wiki/Supported-sport-types/ SPORT_TYPES_TO_IMPORT=\u0026#39;[]\u0026#39; # 您的生日。需要用于计算心率区间。 ATHLETE_BIRTHDAY=1999-01-01 # 体重历史（单位为千克或磅，取决于UNIT_SYSTEM）。需要用于计算相对功率重量比（w/kg）。 # 查看更多信息：https://github.com/robiningelbrecht/strava-statistics/wiki ATHLETE_WEIGHTS=\u0026#39;{ \u0026#34;1970-01-01\u0026#34;: 68 }\u0026#39; # FTP（功能阈值功率）历史。需要用于计算活动压力水平。 # 查看更多信息：https://github.com/robiningelbrecht/strava-statistics/wiki FTP_VALUES=\u0026#39;{ \u0026#34;2024-12-12\u0026#34;: 235 }\u0026#39; # 包含ntfy主题的完整URL。此主题将用于在新的HTML构建运行时通知您。 # 留空以禁用通知。 NTFY_URL=\u0026#39;\u0026#39; # 在导入期间要跳过的活动ID数组。 # 这允许您在导入时跳过特定活动。 ACTIVITIES_TO_SKIP_DURING_IMPORT=\u0026#39;[]\u0026#39; # 创建/拥有由strava-statistics管理的文件的UID和GID # 可能仅在Linux主机上需要，详见Wiki中的文件权限部分 #PUID= #PGID= 开始导入数据：\n启动容器\ndocker-compose up -d 导入数据\ndocker compose exec App bin/console app:strava:import-data docker compose exec App bin/console app:strava:build-files 导入过程非常非常慢，因为需要挨个数据获取，并且很容易出错，如果出错了，需要先关闭容器，然后重新导入。以下是导入成功的截图： \u003c!DOCTYPE html\u003e Responsive Image 访问 localhost:8080 查看数据\n\u003c!DOCTYPE html\u003e Responsive Image 常见问题 401 Unauthorized \u003c!DOCTYPE html\u003e Responsive Image .env中的STRAVA_REFRESH_TOKEN可能过期，需要重新获取。又或者压根就忘记了获取refresh_token，需要重新获取。\nFailed to connect to nominatim.openstreetmap.org \u003c!DOCTYPE html\u003e Responsive Image 因为需要生成一些地图热点信息，所以需要访问 nominatim.openstreetmap.org，所以需要配置代理。\nTring to calculate the relative power for activity \u003c!DOCTYPE html\u003e Responsive Image 因为需要计算相对功率重量比（w/kg），所以需要配置体重历史。如果发现某个活动的时间点没有配置体重信息就会报这个错。看看.env中的ATHLETE_WEIGHTS是否配置正确。我建议直接修改成我提供的数据，也就是从 1970 年开始都是当前的体重。因为我尝试配置了自己的体重历史，但是一直报错，所以直接改成了这个。\nLooks like you still need to import your strava data \u003c!DOCTYPE html\u003e Responsive Image 如果你只执行了docker-compose up -d，而没有执行导入数据的命令，那么就会出现这个错误。需要执行导入数据的命令。如果你已经导入成功了，如果还报这个错，就需要重启一下容器。\n","permalink":"https://lifeislife.cn/posts/docker-compose%E9%83%A8%E7%BD%B2strava-statistics/","summary":"\u003ch1 id=\"strava-statistics-部署文档\"\u003eStrava Statistics 部署文档\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/robiningelbrecht/strava-statistics\"\u003eStrava Statistics\u003c/a\u003e 是一个自托管工具，利用 Strava 数据生成个人运动统计，支持 Docker 部署，提供丰富的可视化分析。下面介绍如何使用 Docker Compose 部署。\u003c/p\u003e\n\u003ch2 id=\"申请-strava-的-api-权限\"\u003e申请 Strava 的 API 权限\u003c/h2\u003e\n\u003cp\u003e在\u003ca href=\"https://lifeislife.cn/awesome-cycling/docs/training-fitness/zwiftoffline/\"\u003eZwiftOffline\u003c/a\u003e中也需要用到 API 权限，因为不同应用程序也不冲突，懒得再重新申请，所以以下填的信息使用的 ZwiftOffline 的 API 权限。\u003c/p\u003e","title":"Docker Compose 部署 Strava Statistics"},{"content":"前言 ZwiftOffline是一个开源社区自制的 Zwift 的 server 端，可以在没有网络的情况下进行 Zwift 课程或路线训练，多平台支持。\n本教程将详细介绍如何在 Windows 系统上安装和配置 Zwift 单机版，包括基础安装、账号配置、Strava 同步、训练课程上传以及移动端 Companion 配置等完整流程。\n一、准备工作 1.1 下载必要文件 ZwiftOffline 主程序\n从GitHub Release 页面下载最新的 zoffline 发布版（.exe文件） 配置辅助工具\n从GitHub Release下载zoffline-helper.zip配置脚本文件 Zwift 官方客户端\n前往Zwift 官网，拉到页面底部，下载并安装 Zwift 软件 重要：记住安装路径，后续配置需要用到（例如：C:\\Program Files (x86)\\Zwift） 1.2 创建运行目录 创建一个目录用于存放 ZwiftOffline 相关文件，例如新建zwiftoffline目录。\n二、基础安装与配置 2.1 初始化 ZwiftOffline 将下载的zoffline.exe文件保存到zwiftoffline目录 运行zoffline.exe，程序会在同目录下自动创建storage目录（用于保存 Zwift 进度） 看到storage目录生成后，按Ctrl+C关闭 zoffline，稍后进行配置 \u003c!DOCTYPE html\u003e Responsive Image 2.2 安装并更新 Zwift 客户端 运行刚安装的 Zwift 程序，客户端会开始更新游戏本体 ⚠️ 重要提示：必须在配置网络之前完成此步骤，因为后续配置会修改 hosts 文件，导致无法连接到 Zwift 服务器下载游戏本体 \u003c!DOCTYPE html\u003e Responsive Image 2.3 配置网络连接 将下载的zoffline-helper.zip解压到zwiftoffline目录 进入zwiftoffline/zoffline-helper目录 右键点击configure_client.bat，选择以管理员身份运行 脚本会自动配置 zoffline，期间会弹窗让你选择 Zwift 安装目录（即之前记住的路径） \u003c!DOCTYPE html\u003e Responsive Image 配置完成后，会显示如下结果： \u003c!DOCTYPE html\u003e Responsive Image 2.4 启动并验证 进入zwiftoffline目录，双击运行zoffline.exe（文件名可能因版本而异，如zoffline_1.0.140279.exe） \u003c!DOCTYPE html\u003e Responsive Image 启动原版 Zwift 程序，检查登录界面 成功标志：显示 ZwiftOffline 的登录页面（如下图） \u003c!DOCTYPE html\u003e Responsive Image 失败标志：如果显示官方原版登录界面，说明配置失败 \u003c!DOCTYPE html\u003e Responsive Image ⚠️ 重要提示： 如果显示的是原版登录页面，检查是否开启了代理，关闭代理后重试 将输入法切换为微软英文输入法，点击Start Zwift开始游戏 使用搜狗输入法等第三方输入法可能会卡在登录页面 三、高级配置 3.1 同步原有账号信息 如果不配置此项，使用 Zwift offline 时会显示为新账号，而不是你原来的账号信息。\n配置步骤：\n在登录页面点击设置按钮进入设置界面 \u003c!DOCTYPE html\u003e Responsive Image 填写你的 Zwift 邮箱和密码，勾选所有选项，点击 Submit 提交 \u003c!DOCTYPE html\u003e Responsive Image 配置完成后，再次登录 Zwift 时就会显示为原来的账号了 3.2 配置 Strava 自动上传 3.2.1 申请 Strava API 登录Strava API 设置页面 创建新应用，填写以下信息： 应用名称：自定义（如：ZwiftOffline） 类别：其他 授权回调域：launcher.zwift.com 网站：可留空或填写个人网站 \u003c!DOCTYPE html\u003e Responsive Image 申请完成后，记录下Client ID和Client Secret \u003c!DOCTYPE html\u003e Responsive Image 3.2.2 在 ZwiftOffline 中配置 Strava 在登录页面进入设置，填写Client ID和Client Secret \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 点击Submit提交：\n\u003c!DOCTYPE html\u003e Responsive Image 3.2.3 授权 Strava 访问 这一步可以省略，如果通过上面的步骤没法上传，再尝试这个步骤手动配置\n右键以管理员身份运行zoffline-helper/disable_zoffline.bat，清除 hosts 配置\n在命令行中运行以下命令（替换CLIENT_ID和CLIENT_SECRET为你的实际值）：\nzoffline-helper/strava_auth.exe --client-id CLIENT_ID --client-secret CLIENT_SECRET 浏览器会自动打开或手动访问localhost:8000进行授权\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 授权完成后，将生成的strava_token.txt文件移动到storage/1目录下 右键以管理员身份运行zoffline-helper/configure_client.bat，重新配置 hosts 3.3 上传自定义训练课程 如果你习惯在 Intervals ICU 等平台创建训练课程，可以手动上传到 Zwift 单机版。\n上传步骤：\n将你的.zwo训练课程文件保存到以下目录：\nDocuments/Zwift/Workouts/1 \u003c!DOCTYPE html\u003e Responsive Image ⚠️ 注意：不是zwiftoffline\\storage\\1\\customworkouts目录，如果放错位置会导致课程无法上传 \u003c!DOCTYPE html\u003e Responsive Image 3.4 配置 Garmin Connect Garmin Connect 可以同步你的 Zwift 活动数据到 Garmin 设备。\n3.4.1 配置账号 PC 端配置\n在 ZwiftOffline 登录窗口点击\u0026quot;Settings - Garmin\u0026quot;按钮 输入你的 Garmin Connect 账号和密码 安卓端配置\n访问 https://\u0026lt;zoffline_ip\u0026gt;/garmin/zoffline/ 输入你的 Garmin Connect 账号和密码 将\u0026lt;zoffline_ip\u0026gt;替换为运行 zoffline 的电脑 IP 地址 3.4.2 多因素认证（MFA） 如果你的账号启用了多因素认证，需要额外配置：\n使用 Python 脚本（推荐）\n运行garmin_auth.py脚本 脚本会在运行目录下生成garth文件夹 将garth文件夹移动到storage/1目录下 使用 Windows 可执行文件\n如果未安装 Python，可以从zoffline-helper Release 页面下载garmin_auth.exe 运行garmin_auth.exe，同样会生成garth文件夹 将garth文件夹移动到storage/1目录下 3.5 配置 Intervals.icu Intervals.icu 是一个强大的训练分析平台，可以同步 Zwift 活动数据。\n3.5.1 获取 API 凭证 登录 Intervals.icu 设置页面 进入\u0026quot;Developer Settings\u0026quot;（开发者设置）部分 复制以下信息： Athlete ID（运动员 ID） API Key（API 密钥） 3.5.2 配置账号 PC 端配置\n在 ZwiftOffline 登录窗口点击\u0026quot;Settings - Intervals\u0026quot;按钮 输入之前复制的 Athlete ID 和 API Key 安卓端配置\n访问 https://\u0026lt;zoffline_ip\u0026gt;/intervals/zoffline/ 输入 Athlete ID 和 API Key 将\u0026lt;zoffline_ip\u0026gt;替换为运行 zoffline 的电脑 IP 地址 3.6 启用多人游戏 多人游戏功能允许多个用户同时连接到同一个 zoffline 服务器进行骑行。\n3.6.1 基本配置 在storage目录下创建multiplayer.txt文件（文件内容为空） 3.6.2 远程服务器配置 如果 zoffline 运行在与 Zwift 客户端不同的 PC 上：\n在storage目录下创建server-ip.txt文件 文件内容填写运行 zoffline 的 PC 的 IP 地址 端口要求：确保以下端口在运行 zoffline 的 PC 上开放： TCP 端口：80, 443, 3025 UDP 端口：3024 3.6.3 创建账号 启动 Zwift，创建新账号 ⚠️ 注意：此账号仅存在于你的 zoffline 服务器上，与官方 Zwift 账号无关 3.6.4 启用密码重置功能（可选） 在storage目录下创建gmail_credentials.txt文件 文件内容格式： \u0026lt;gmail 账号\u0026gt; \u0026lt;应用密码\u0026gt; \u0026lt;恢复 URL 主机（可选）\u0026gt; 获取应用密码： 访问 https://security.google.com/settings/security/apppasswords 创建应用密码，允许服务器登录 将生成的应用密码填入文件第二行 恢复 URL 主机（可选）： 第三行可以填写恢复 URL 的主机地址 如果不填写，将使用服务器 IP 地址作为默认值 3.7 启用 Ghosts（幽灵） Ghosts 功能可以保存你之前的骑行记录，并在相同路线上显示为\u0026quot;幽灵\u0026quot;与你一起骑行。\n3.7.1 启用功能 PC 端\n在 zoffline 启动器窗口中勾选\u0026quot;Enable ghosts\u0026quot; 安卓端\n访问 https://\u0026lt;zoffline_ip\u0026gt;/user/zoffline/ 勾选\u0026quot;Enable ghosts\u0026quot; 点击\u0026quot;Start Zwift\u0026quot;保存设置 3.7.2 使用说明 保存幽灵：当你保存活动时，幽灵会自动保存在storage/\u0026lt;player_id\u0026gt;/ghosts/\u0026lt;world\u0026gt;/\u0026lt;route\u0026gt;目录下 加载幽灵：下次骑行相同路线时，幽灵会自动加载 重新编组：在聊天中输入.regroup命令可以重新编组幽灵 3.7.3 自定义装备 在storage目录下创建ghost_profile.txt文件 可以使用find_equip.py脚本来自动填充此文件 3.8 启用 Bots（机器人） Bots 功能可以将保存的幽灵转换为持续骑行的机器人，无论你选择什么路线，它们都会继续骑行。\n3.8.1 启用功能 在storage目录下创建enable_bots.txt文件 可选：文件内容可以包含一个倍数（如：2表示双倍机器人数量） ⚠️ 警告：如果机器人数量过多，可能导致性能问题或功能失效 3.8.2 控制命令 在聊天中使用以下命令控制机器人：\n.group：编组机器人 .groupall：编组所有机器人（包括使用倍数时的重复机器人） .autogroup：自动编组（当你改变路线时） .autogroupall：自动编组所有机器人 .stopautogroup：停止自动编组 .disperse：随机化机器人位置 3.8.3 自定义机器人 在storage目录下创建bot.txt文件 可以自定义机器人的名称、国籍和装备 可以使用get_pro_names.py脚本来自动填充此文件 随机机器人：如果需要随机机器人，可以参考zoffline-bots 仓库 3.9 配置 RoboPacers（机器人配速员） RoboPacers 是使用功率模拟器保存的幽灵，可以创建完美的循环配速员。\n3.9.1 获取 RoboPacers 可以从zoffline-bots 仓库下载预制的 RoboPacers 3.9.2 创建要求 要创建可用的 RoboPacer，需要满足以下条件：\n更新频率：必须使用 1 秒的更新频率录制（默认是 3 秒） 循环要求：活动必须从同一位置和速度开始和结束，否则机器人无法平滑循环 配置文件要求： 必须包含唯一的玩家 ID 必须包含路线 ID 这样当你加入机器人时，会在交叉路口走相同的转弯 3.9.3 编辑工具 bot_editor.py 脚本：可以用于修改以下文件： profile.bin：设置名称、玩家 ID 和路线 ID route.bin：裁剪多余的点以创建完美循环 3.9.4 创建动态 RoboPacer 要创建动态 RoboPacer（在上坡时增加功率，下坡时减少功率）：\n使用 standalone_power.py 脚本 硬件要求： 2 个 ANT 适配器 python-ant PowerMeterTx.py 3.10 使用 Bookmarks（书签） 书签功能可以保存你的位置，方便快速跳转到特定地点。\n3.10.1 自动保存书签 当你完成活动时，你的最后位置会自动保存为书签。\n3.10.2 手动保存书签 在聊天中使用以下命令保存书签：\n.bookmark \u0026lt;名称\u0026gt; 例如：.bookmark 起点\n3.10.3 使用书签 从书签开始新活动：\n在主页屏幕选择\u0026quot;Join a Zwifter\u0026quot; 选择你想要的书签 传送到书签：\n使用操作栏上的传送图标 选择目标书签进行传送 3.11 启用历史排行榜 历史排行榜功能可以覆盖 60 分钟的实时结果和 90 天的个人记录，显示所有时间的最佳成绩。\n3.11.1 启用功能 在storage目录下创建all_time_leaderboards.txt文件（文件内容可以为空） 3.11.2 功能说明 排行榜：显示所有时间的最佳成绩，而不仅仅是最近 60 分钟或 90 天的记录 荣誉衫：仍然有效期为 60 分钟，但只有在创造新的历史记录时才会授予 3.12 解锁装备 可以解锁特殊装备或所有装备。\n3.12.1 解锁特殊装备 在storage目录下创建unlock_entitlements.txt文件（文件内容可以为空） 这将解锁需要特殊权限的装备 3.12.2 解锁所有装备 在storage目录下创建unlock_all_equipment.txt文件（文件内容可以为空） 这将解锁所有可用装备 3.13 配置 CDN 代理 CDN 代理功能可以从 Zwift 官方服务器获取地图时间表和更新文件。\n3.13.1 启用 CDN 代理 在storage目录下创建cdn-proxy.txt文件（文件内容可以为空） ⚠️ 限制：此功能只能在 zoffline 运行在与 Zwift 客户端不同的机器上时使用 3.13.2 禁用代理 默认情况下，zoffline 会尝试使用 Google 公共 DNS 来解析 Zwift 主机名，即使 zoffline 与 Zwift 客户端运行在同一台机器上也能工作。\n如果要禁用此代理功能，在storage目录下创建disable_proxy.txt文件 3.13.3 从 zoffline 提供更新文件 运行get_gameassets.py脚本下载游戏文件 这样 zoffline 可以直接提供更新文件，而不需要从 Zwift 服务器获取 四、移动端 Companion 配置 Zwift Companion 是配套的移动端社交软件，可用于与骑友互动、配对设备、点赞、使用道具等功能。使用离线版 Zwift 需要重新打包 Companion 应用。\n4.1 准备工作 官方原版 Companion 会对网络连接和证书做严格验证，需要对其进行\u0026quot;打补丁并重签名\u0026quot;才能连接到本地 zoffline 服务器。\n4.2 替换 APK 证书并重新签名 4.2.1 安装 apk-mitm 安装 Node.js（如果尚未安装） 使用以下命令全局安装 apk-mitm： npm install -g apk-mitm 其他系统可参考apk-mitm 项目 README自行安装 4.2.2 修改 apktool 配置 使用npm root -g查找 apk-mitm 的实际安装路径 打开apk-mitm/dist/tools/apktool.js文件 修改decode方法，添加-resm和dummy参数： decode(inputPath, outputPath) { return this.run([ \u0026#39;decode\u0026#39;, \u0026#39;-resm\u0026#39;, // add this \u0026#39;dummy\u0026#39;, // add this inputPath, \u0026#39;--output\u0026#39;, outputPath, \u0026#39;--frame-path\u0026#39;, this.options.frameworkPath, ], \u0026#39;decoding\u0026#39;); } 4.2.3 生成修改后的 APK 从Zwift Offline 仓库下载以下文件：\nssl/cert-zwift-com.pem（证书文件） zwift-offline-companion.apk（原始 APK 文件） 将这两个文件复制到同一目录（如：C:\\Users\\Administrator\\Desktop\\zwift-offline-companion）\n在该目录下运行以下命令：\napk-mitm --certificate cert-zwift-com.pem zwift-offline-companion.apk 命令执行完成后，会生成zwift-offline-companion-patched.apk文件，将其拷贝到手机安装即可 4.3 配置域名重定向 4.3.1 安装 Virtual Hosts 下载virtual hosts软件 安装到手机中 4.3.2 创建 hosts 文件 创建hosts.txt文件，内容如下（将\u0026lt;zoffline ip\u0026gt;替换为你运行 zoffline 的电脑 IP 地址）： \u0026lt;zoffline ip\u0026gt; us-or-rly101.zwift.com \u0026lt;zoffline ip\u0026gt; secure.zwift.com ⚠️ 重要提示：如果在 PC 上配置过 hosts 文件，可能包含以下映射： 127.0.0.1 cdn.zwift.com 此映射不要添加到手机端的 hosts 文件中！\n将hosts.txt文件复制到手机，放在便于访问的位置 4.3.3 启用域名重定向 打开 Virtual Hosts 软件 选择之前创建的hosts.txt文件 启用域名重定向功能 4.4 使用 Companion 使用离线版的账号登录 Companion，即可正常使用 验证连接：在打开和登录 Companion 时，观察 PC 端运行的 Zwift offline 命令行窗口是否有日志输出 如果有日志输出，说明连接正常 如果没有任何输出，说明请求未成功转发，需要检查 IP 地址配置是否正确 五、安卓设备直接使用 Zwift Offline 除了在 PC 上使用 Zwift Offline，你也可以直接在安卓设备上运行 Zwift 并连接到 zoffline 服务器。这种方式不需要 root 权限，但需要在每次安装或更新 Zwift 后重新打补丁。\n5.1 安装必要应用 5.1.1 下载并安装 ZofflineObb 从GitHub Release 页面下载ZofflineObb.apk 安装到安卓设备上（需要允许安装未知来源应用） 5.1.2 下载并安装 Virtual Hosts 从GitHub Release 页面下载app-Github-release.apk 安装到安卓设备上 5.2 配置域名重定向 5.2.1 创建 hosts.txt 文件 创建hosts.txt文件，可以使用文本编辑器应用或在线工具（如在线文本编辑器）\n文件内容如下（将\u0026lt;zoffline ip\u0026gt;替换为运行 zoffline 的电脑 IP 地址）：\n\u0026lt;zoffline ip\u0026gt; us-or-rly101.zwift.com \u0026lt;zoffline ip\u0026gt; secure.zwift.com \u0026lt;zoffline ip\u0026gt; cdn.zwift.com ⚠️ 注意：与 Companion 配置不同，安卓设备直接使用需要包含cdn.zwift.com的映射\n将hosts.txt文件保存到手机，放在便于访问的位置\n5.2.2 关闭 Private DNS 进入安卓设备的设置 \u0026gt; 网络和互联网 \u0026gt; 高级 \u0026gt; Private DNS 选择关闭或自动 5.2.3 配置 Virtual Hosts 打开 Virtual Hosts 应用 选择之前创建的hosts.txt文件 启用域名重定向功能（确保按钮处于开启状态） 5.2.4 替代方案：使用 DNS 配置 如果你不想使用 Virtual Hosts 应用，也可以使用以下方法：\n在运行 zoffline 的 PC 上，在storage目录下创建fake-dns.txt文件 在手机的 Wi-Fi 设置中，将DNS 1设置为运行 zoffline 的 PC 的 IP 地址 注意：如果你的路由器支持，也可以在路由器层面配置 DNS 记录，这样所有设备都可以自动使用 5.3 安装并打补丁 Zwift 5.3.1 安装 Zwift 从 Google Play 商店安装或更新 Zwift ⚠️ 重要：安装或更新后，不要立即启动 Zwift 如果已经启动过 Zwift，需要先清除数据： 进入设置 \u0026gt; 应用 \u0026gt; Zwift \u0026gt; 存储 \u0026gt; 清除数据 或者卸载后重新安装 5.3.2 运行 ZofflineObb 打补丁 打开ZofflineObb应用 运行补丁程序（允许访问存储权限） 等待补丁过程完成（通常需要 5-10 分钟） 补丁完成后，应用会提示完成 原理说明：ZofflineObb 会修改 Zwift 应用，使其接受 zoffline 服务器的自签名证书，这是连接离线服务器的关键步骤。\n5.4 运行 Zwift 确保 Virtual Hosts 按钮处于开启状态 启动 Zwift 应用 使用任意邮箱和密码登录，或创建新用户（如果启用了多人游戏功能） Zwift 应该能够正常验证下载并运行 5.5 重要提示 每次更新后需要重新打补丁：无论是从 Google Play 更新 Zwift，还是重新安装，都需要重新运行 ZofflineObb 打补丁 保持网络连接：确保安卓设备与运行 zoffline 的 PC 在同一局域网内 防火墙设置：确保 PC 的防火墙允许 zoffline 的端口访问 六、常见问题 6.1 卡在蓝色登录界面 症状： 登录时卡在蓝色界面，无法进入游戏\n\u003c!DOCTYPE html\u003e Responsive Image 解决方法：\n在任务管理器中关闭 Zwift 进程 将输入法切换为微软英文输入法 重新启动 Zwift 并登录 \u003c!DOCTYPE html\u003e Responsive Image 6.2 配置后无法更新 Zwift 原因： configure_client.bat会修改 Hosts 文件，导致无法连接到 Zwift 服务器\n解决方法：\n关闭正在运行的zoffline 进入zwiftoffline/zoffline-helper目录 右键点击disable_zoffline.bat，选择以管理员身份运行，清除网络配置 打开 Zwift 进行更新 更新完成后，重新运行configure_client.bat恢复配置 6.3 无法自动上传活动到 Strava 可能原因及解决方法：\n检查strava_token.txt文件是否已正确放置在storage/1目录下 确认 Strava API 的Client ID和Client Secret配置正确 检查网络连接，确保 zoffline 可以访问 Strava API 查看 zoffline 命令行窗口的错误日志，根据具体错误信息进行排查 检查在申请 API 时填写的授权回调域是否正确 6.4 安卓客户端无法登录 可能原因及解决方法：\n对于 Companion 应用：\n检查 Virtual Hosts 是否已正确启用 确认 hosts 文件中的 IP 地址是否正确（应为运行 zoffline 的电脑 IP，而非 127.0.0.1） 确保手机和电脑在同一局域网内 检查防火墙设置，确保 zoffline 的端口未被阻止 重新安装修改后的 APK 文件 对于直接使用 Zwift 应用：\n确认已关闭 Private DNS 设置 检查 Virtual Hosts 是否已正确启用，按钮必须处于开启状态 确认 hosts.txt 文件包含所有三个域名映射（包括cdn.zwift.com） 检查是否在安装/更新 Zwift 后运行了 ZofflineObb 打补丁 如果已启动过 Zwift，尝试清除应用数据后重新打补丁 确认手机和运行 zoffline 的 PC 在同一局域网内 检查 PC 防火墙设置，确保 zoffline 端口未被阻止 ","permalink":"https://lifeislife.cn/posts/zwift%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/zoffline/zwift-offline?tab=readme-ov-file\"\u003eZwiftOffline\u003c/a\u003e是一个开源社区自制的 Zwift 的 server 端，可以在没有网络的情况下进行 Zwift 课程或路线训练，多平台支持。\u003c/p\u003e\n\u003cp\u003e本教程将详细介绍如何在 Windows 系统上安装和配置 Zwift 单机版，包括基础安装、账号配置、Strava 同步、训练课程上传以及移动端 Companion 配置等完整流程。\u003c/p\u003e","title":"Zwift 单机版安装教程"},{"content":"引入原因 Per-CPU 变量是 Linux 内核中的一个重要概念，主要解决以下问题：\n锁竞争问题\n在 SMP 系统中，如果多个 CPU 同时访问同一个变量，需要使用锁来保证数据一致性 这种锁机制会导致性能下降，特别是在高并发场景下 Per-CPU 变量为每个 CPU 核心分配独立的变量副本，无需加锁即可安全访问 需要注意的一点是，Per-CPU 变量是独立的变量，每个 CPU 分别有一个自己的变量，这些变量不是互相同步的。 缓存效率\n传统共享变量会导致频繁的缓存失效（cache invalidation） Per-CPU 变量位于各自 CPU 的本地缓存中，提高缓存命中率 减少了 CPU 间的缓存同步开销 NUMA 友好\n在 NUMA 架构中，访问远端内存的开销很大 Per-CPU 变量确保数据位于本地节点，减少跨 NUMA 节点访问 这时候你可能会问，为什么不直接定义 16 个变量分别用于不同的 CPU？\n代码冗余\n如果手动为每个 CPU 定义变量，代码会变得冗长且难以维护。\n例如，对于 128 个 CPU 的系统，可能需要定义 128 个变量：\nint var_cpu0, var_cpu1, var_cpu2, ..., var_cpu127; 不能动态支持多 CPU\n在支持 CPU 热插拔的系统中，CPU 的数量可能动态变化。 手动定义变量无法适应这种动态变化。 访问效率低\n访问特定 CPU 的变量时，需要手动计算偏移量或使用条件语句，效率较低。\n例如：\nint *get_var(int cpu) { switch (cpu) { case 0: return \u0026amp;var_cpu0; case 1: return \u0026amp;var_cpu1; // ... default: return NULL; } } 缓存局部性问题\n手动定义的变量可能位于同一缓存行中，导致 缓存行共享（False Sharing），降低性能。 Per-CPU 变量的优势\n代码简洁\nPer-CPU 变量通过内核提供的机制自动为每个 CPU 分配变量，代码更简洁。\n例如：\nDEFINE_PER_CPU(int, my_var); 动态适应 CPU 数量\nPer-CPU 变量支持动态 CPU 数量，能够自动适应 CPU 热插拔。\n例如，动态分配 Per-CPU 变量：\nint __percpu *my_var = alloc_percpu(int); 高效访问\nPer-CPU 变量通过内核提供的宏（如 this_cpu_ptr 和 per_cpu_ptr）高效访问当前或指定 CPU 的变量。\n例如：\nint *ptr = this_cpu_ptr(\u0026amp;my_var); // 访问当前 CPU 的变量 int *ptr = per_cpu_ptr(\u0026amp;my_var, cpu); // 访问指定 CPU 的变量 缓存优化\nPer-CPU 变量会自动对齐到缓存行，避免缓存行共享问题。 例如，内核会确保每个 CPU 的变量位于不同的缓存行中。 静态声明和定义 // 1. 定义 Per-CPU 变量 DEFINE_PER_CPU(type, name); // 定义并初始化为 0 DEFINE_PER_CPU(type, name) = value; // 定义并指定初值 // 2. 声明外部 Per-CPU 变量 DECLARE_PER_CPU(type, name); // 声明在其他地方定义的变量 // 3. 定义 Per-CPU 数组 DEFINE_PER_CPU(type, name[SIZE]); // 定义数组类型 // 4. 定义只读 Per-CPU 变量 DEFINE_PER_CPU_READ_MOSTLY(type, name); // 主要用于只读数据，优化缓存 内部实现机制 #define DEFINE_PER_CPU(type, name) \\ DEFINE_PER_CPU_SECTION(type, name, \u0026#34;\u0026#34;) __attribute__((section(\u0026#34;.data..percpu\u0026#34;))) int per_cpu_n #define DEFINE_PER_CPU_SECTION(type, name, sec) \\ __PCPU_ATTRS(sec) __typeof__(type) name #define __PCPU_ATTRS(sec) \\ __percpu __attribute__((section(PER_CPU_BASE_SECTION sec))) #define PER_CPU_BASE_SECTION \u0026#34;.data..percpu\u0026#34; 比如：\n// 在编译时定义 Per-CPU 变量 DEFINE_PER_CPU(int, my_counter) = 0; // 展开后实际上是 __attribute__((section(\u0026#34;.data..percpu\u0026#34;))) int my_counter = 0; 这里为什么要引入 section 机制？\n对于 kernel 中的普通变量，经过了编译和链接后，会被放置到.data 或者.bss 段，系统在初始化的时候会准备好一切（例如 clear bss），由于 per CPU 变量的特殊性，内核将这些变量放置到了其他的 section，位于 kernel address space 中__per_cpu_start和__per_cpu_end之间，我们称之 Per-CPU 变量的原始变量。 摘自：Linux 内核同步机制之（二）：Per-CPU 变量\nSection 机制允许编译器将特定的数据放在目标文件的特定区域 对于 Per-CPU 变量，Linux 使用 .data..percpu section 将所有 Per-CPU 变量集中存放 这种集中存放便于运行时进行整体复制和管理 Per-CPU 变量如何建立副本的？\n在内核初始化阶段会调用setup_per_cpu_areas函数，为每个 CPU 设置 Per-CPU 变量的偏移地址。\nvoid __init setup_per_cpu_areas(void) { unsigned long delta; unsigned int cpu; ... delta = (unsigned long)pcpu_base_addr - (unsigned long)__per_cpu_start; for_each_possible_cpu(cpu) __per_cpu_offset[cpu] = delta + pcpu_unit_offsets[cpu]; } __per_cpu_offset 是一个全局数组，用于存储每个 CPU 的 Per-CPU 变量的偏移地址。 在初始化时，内核会为每个 CPU 计算其 Per-CPU 变量的基地址，并将其存储在 __per_cpu_offset[cpu] 中。 这个偏移地址是相对于 Per-CPU 变量的起始地址（__per_cpu_start）的。 在 CPU 初始化时，内核会使用调用set_my_cpu_offset函数设置每个 CPU 静态 Per-CPU 变量的偏移地址。\n#define per_cpu_offset(x) (__per_cpu_offset(x)) void notrace cpu_init(void) { #ifndef CONFIG_CPU_V7M unsigned int cpu = smp_processor_id(); struct stack *stk = \u0026amp;stacks[cpu]; if (cpu \u0026gt;= NR_CPUS) { pr_crit(\u0026#34;CPU%u: bad primary CPU number\\n\u0026#34;, cpu); BUG(); } /* * This only works on resume and secondary cores. For booting on the * boot cpu, smp_prepare_boot_cpu is called after percpu area setup. */ set_my_cpu_offset(per_cpu_offset(cpu)); cpu_proc_init(); ... } 在set_my_cpu_offset函数中，根据ARM64_HAS_VIRT_HOST_EXTN的值，选择将偏移地址写入tpidr_el1或者tpidr_el2寄存器。\n/* arch/arm64/include/asm/percpu.h */ static inline void set_my_cpu_offset(unsigned long off) { asm volatile(ALTERNATIVE(\u0026#34;msr tpidr_el1, %0\u0026#34;, \u0026#34;msr tpidr_el2, %0\u0026#34;, ARM64_HAS_VIRT_HOST_EXTN) :: \u0026#34;r\u0026#34; (off) : \u0026#34;memory\u0026#34;); } 在访问时使用this_cpu_ptr宏，展开后可以发现相当于 percpu 变量指针 ptr 加上__my_cpu_offset。__my_cpu_offset宏即是从当前cpu的tpidr_el1、tpidr_el2寄存器中取出此前设置的__per_cpu_offset[cpu]值。\n#define this_cpu_ptr(ptr) raw_cpu_ptr(ptr) #define raw_cpu_ptr(ptr) \\ ({ \\ __verify_pcpu_ptr(ptr); \\ arch_raw_cpu_ptr(ptr); \\ }) #define arch_raw_cpu_ptr(ptr) SHIFT_PERCPU_PTR(ptr, __my_cpu_offset) static inline unsigned long __my_cpu_offset(void) { unsigned long off; /* * We want to allow caching the value, so avoid using volatile and * instead use a fake stack read to hazard against barrier(). */ asm(ALTERNATIVE(\u0026#34;mrs %0, tpidr_el1\u0026#34;, \u0026#34;mrs %0, tpidr_el2\u0026#34;, ARM64_HAS_VIRT_HOST_EXTN) : \u0026#34;=r\u0026#34; (off) : \u0026#34;Q\u0026#34; (*(const unsigned long *)current_stack_pointer)); return off; } 使用方式 Per-CPU 变量的常用操作方式：\n静态定义\n// 定义 Per-CPU 整型变量 DEFINE_PER_CPU(int, my_percpu_var); // 定义 Per-CPU 结构体 DEFINE_PER_CPU(struct my_struct, my_percpu_struct); 访问变量\n// 获取本地 CPU 的变量 int cpu_var = get_cpu_var(my_percpu_var); put_cpu_var(my_percpu_var); // 必须配对使用 // 访问指定 CPU 的变量 int var_cpu0 = per_cpu(my_percpu_var, 0); // 遍历所有 CPU 的变量 int cpu; for_each_possible_cpu(cpu) { int value = per_cpu(my_percpu_var, cpu); // 处理 value } ","permalink":"https://lifeislife.cn/posts/per-cpu-%E5%8F%98%E9%87%8F/","summary":"\u003ch3 id=\"引入原因\"\u003e引入原因\u003c/h3\u003e\n\u003cp\u003ePer-CPU 变量是 Linux 内核中的一个重要概念，主要解决以下问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e锁竞争问题\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在 SMP 系统中，如果多个 CPU 同时访问同一个变量，需要使用锁来保证数据一致性\u003c/li\u003e\n\u003cli\u003e这种锁机制会导致性能下降，特别是在高并发场景下\u003c/li\u003e\n\u003cli\u003ePer-CPU 变量为每个 CPU 核心分配独立的变量副本，无需加锁即可安全访问\u003c/li\u003e\n\u003cli\u003e需要注意的一点是，Per-CPU 变量是独立的变量，每个 CPU 分别有一个自己的变量，这些变量不是互相同步的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e缓存效率\u003c/strong\u003e\u003c/p\u003e","title":"Per-CPU 变量"},{"content":"为什么要升级 人傻钱多（bushi）。平时骑台子能实时看到自己输出功率，判断自己的状态，也能更好的控制自己的训练强度，不至于过度训练。外出路骑没有功率计总觉得不得劲，特别是在蹭风或者团骑时，不知道自己的状态如何，因为路骑人比较兴奋，也许功率已经超过自己的FTP但是可能并不觉得累，但是体能是有限的，不累只是精神上的感觉，也许骑不了多久精神头过了就被拉爆了。所以十分想要一个功率计能够实时看到自己的输出功率，能让路骑尽量维持在自己想要的强度。\n前期准备 先了解和功率计相关的几个零件：\n盘片 SRAM Rival 107BCD 盘片 \u003c!DOCTYPE html\u003e Responsive Image 盘爪 SRAM Red AXS/Force \u003c!DOCTYPE html\u003e Responsive Image 盘钉：固定盘片和盘爪 SRAM RIVAL 107/94 BCD M8X4.75X8.75 盘钉 \u003c!DOCTYPE html\u003e Responsive Image 曲柄 SRAM RIVAL AXS QUARQ DUB \u003c!DOCTYPE html\u003e Responsive Image 曲柄螺丝 SRAM DUB AXS RED或FROCE 曲柄螺丝 \u003c!DOCTYPE html\u003e Responsive Image 中轴 和曲柄连接在一起 \u003c!DOCTYPE html\u003e Responsive Image 功率计的种类有很多，有脚踏功率计，盘爪功率计、曲柄功率计和贴片功率计等等，每种功率计都有自己的优缺点，因为我也不是专家所以就不详细介绍了，想要了解的可以参考视频公路车功率计介绍和选择安装建议_哔哩哔哩_bilibili。\n我在看了一些介绍视频以及根据自己目前使用套件的情况，最终选择了使用人群最广的盘爪式功率计，盘爪功率计就是将上面提到的盘爪这个邻接用功率计替换，功率计本身就是盘爪。下面是我升级选购的一些思路，供和我一样的小白参考。\n当我决定使用盘爪式功率计时，就需要选择具体哪一款，哪一个品牌的功率计，可以直接淘宝搜索“盘爪功率计”，会有很多选择，如：\n迈金 P505 SRAM QUARQ Sigeyi 思各异 XCADEY 接下来就是根据自己的钱包大小来选择了，当然还有一个最重要的参数，就是BCD，这个参数是盘爪功率计的螺丝孔的间距，不同的品牌不同的型号的盘爪功率计BCD是不一样的，这个参数决定了功率计能否安装到牙盘上，我使用的是SRAM Rival eTap AXS套件，这个套件的BCD是107，所以我需要选择BCD为107的盘爪功率计。这时查看各个功率计详情可以看到迈金不支持107BCD，所以可以直接排除这款功率计了。在剩下的几款功率计中，SRAM QUARQ是SRAM自家的产品，我觉得原配最好，所以选择了SRAM QUARQ。\n关于盘片和盘爪规格的介绍可以参考视频【自行车维修手册】第17期 公路车盘片选择与安装_哔哩哔哩_bilibili\n在确定了功率计后，就需要考虑如何安装了，RIVAL套件中，曲柄和盘爪是一体的，这意味着如果要在不更换盘片的情况下加装功率计，就需要更换曲柄。更换曲柄就需要了解曲柄的规格，有不同类型的中轴比如GXP和DU，有不同的曲柄长度，还有不同的安装规格，比如3钉，5钉，8钉等等。因为我们已经选好了盘爪功率计，而盘爪功率计是和曲柄安装在一起的，所以盘爪功率计的规格已经确定了曲柄的安装规格，比如QUARQ的盘爪功率计是8钉，所以我们需要选择8钉的曲柄。接下来就是选择曲柄的长度，曲柄的长度根据自己的身体数据来选择，没有Fitting的话就看原来曲柄的长度，换一个一样长度的即可，曲柄的长度标注在曲柄上，比如我的RIVAL套件是170mm。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 根据这些信息我选择了SRAM FORCE DUB 8 钉曲柄。\n\u003c!DOCTYPE html\u003e Responsive Image 关于曲柄规格的介绍可以参考视频【自行车维修手册】第15期 自行车曲柄牙盘规格区分介绍_哔哩哔哩_bilibili\n至此主要的零件已经选购完毕，接下来就是等待零件到货，然后开始安装。但是安装少不了工具，需要准备的工具有：\n8 mm 内六角扳手，拆卸安装曲柄 空心钢管，用于拆卸安装曲柄，当做加力杆，曲柄的螺丝扭力高达50N.m，普通扳手力臂太小，很难拧下来 6 mm 内六角扳手，拆卸安装脚踏 2 mm 内六角扳手，调整曲柄锁紧环 扭力扳手，安装曲柄螺丝 界面脂 拆卸 曲柄拆卸方式可以参考视频技师手册十四（连载）速联RIVAL牙盘曲柄拆装_哔哩哔哩_bilibili。\n\u003c!DOCTYPE html\u003e Responsive Image 这里有个小技巧，就是在拆卸曲柄时，可以用一个空心钢管套在内六角扳手上，这样可以增加力臂，减小力臂，这样就可以更容易的拧下曲柄螺丝。还有如果你和我一样总记不住拆卸曲柄和脚踏的方向，那么可以这么记。拆卸的旋转方向都是踩踏前进的相反方向。\n安装 安装就是把螺丝拧上，但是有一些细节需要注意：\n曲柄和盘爪连接的螺丝的扭力值为 4 N.m 大牙盘正面有一个金属圆柱，这个圆柱体需要在曲柄正下方 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 小牙盘上有一个凸起的尖尖，这个尖尖需要在曲柄正下方 \u003c!DOCTYPE html\u003e Responsive Image 小牙盘标注齿数和型号的那面正对自己才是正确的方向 牙盘的盘钉扭力值为 10 N.m 每个螺丝都抹上界面脂，因为牙盘上的螺丝都会受到很大的力，所以需要抹上界面脂，这样可以减小螺丝的摩擦力，减小螺丝的磨损，也可以防止异响 中轴的大螺丝抹上黄油，扭力值至少为50 N.m，扭紧时最好用上空心钢管 参考资料 【自行车维修手册】第15期 自行车曲柄牙盘规格区分介绍_哔哩哔哩_bilibili 【自行车维修手册】第17期 公路车盘片选择与安装_哔哩哔哩_bilibili 公路车功率计介绍和选择安装建议_哔哩哔哩_bilibili ","permalink":"https://lifeislife.cn/posts/%E9%80%9F%E8%81%94sram-rival%E5%8D%87%E7%BA%A7%E5%8A%9F%E7%8E%87%E8%AE%A1/","summary":"\u003ch1 id=\"为什么要升级\"\u003e为什么要升级\u003c/h1\u003e\n\u003cp\u003e人傻钱多（bushi）。平时骑台子能实时看到自己输出功率，判断自己的状态，也能更好的控制自己的训练强度，不至于过度训练。外出路骑没有功率计总觉得不得劲，特别是在蹭风或者团骑时，不知道自己的状态如何，因为路骑人比较兴奋，也许功率已经超过自己的FTP但是可能并不觉得累，但是体能是有限的，不累只是精神上的感觉，也许骑不了多久精神头过了就被拉爆了。所以十分想要一个功率计能够实时看到自己的输出功率，能让路骑尽量维持在自己想要的强度。\u003c/p\u003e","title":"速联SRAM RIVAL升级功率计"},{"content":"Follow是一个开源RSS阅读器，可以发布自己的订阅源，比如将自己的博客RSS发布到Follow上，其他用户在Follow上订阅你的博客时，就可以看到这是你发布的源，并且可以为源的发布者进行打赏。当然自己的小博客也不指望其他人能订阅，只是想完成Follow的成就任务，完成认证后可以获得Power值，可以用来打赏其他用户，以及购买其他服务，比如订阅付费的列表等。\nPaperMod已经嵌入了RSS订阅功能，所以认证会很方便，所谓认证就是在自己的网站中加入一段代码，Follow会检测这段代码，如果检测到了，就会认为这个网站是你发布的源，从而完成认证。\n开启PaperMod的RSS订阅功能 首先要在config.yaml中开启RSS订阅功能，如下：\nparams: socialIcons: - name: RSS url: \u0026#34;{网站链接}/index.xml\u0026#34; ShowFullTextinRSS: true socialIcons参数用于添加博客主页的图标，这里添加了一个RSS订阅图标，其中{网站链接}是你的网站链接，比如我的博客是https://lifeislife.cn/，那么这里就填https://lifeislife.cn/index.xml。ShowFullTextinRSS参数是控制RSS订阅的内容是否显示全文，如果为true，则显示全文，否则只显示摘要。如果为false，那么RSS订阅时只会显示摘要，点击后才会跳转到博客查看全文。为了方便用户阅读，建议设置为true。\n前往Follow进行订阅 打开博客主页，点击RSS图标，会跳转到https://lifeislife.cn/index.xml，这是博客的RSS订阅地址，复制这个地址，然后打开Follow，点击右上角的+，选择Add Feed，粘贴刚才复制的地址，点击Add Feed，就完成了订阅。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 点击预览后点击订阅，就完成了订阅。\n获取认证代码 在订阅列表中右击你的博客，选择认证，会弹出一个对话框，里面有一段代码，复制这段代码。\n\u003c!DOCTYPE html\u003e Responsive Image 添加认证代码 需要将上面得到的代码添加到博客的RSS订阅页面的description标签中，这个标签在themes/PaperMod/layouts/_default/rss.xml中。为了便于修改，通常我会将博客主题原目录中的themes/PaperMod/layouts/_default/rss.xml复制到我的博客根目录layouts/_default/rss.xml，然后在layouts/_default/rss.xml中修改description标签。\n\u0026lt;description\u0026gt;feedId:57980998056508425+userId:73222296380546048 Recent content {{ if ne .Title site.Title }}{{ with .Title }}in {{ . }} {{ end }}{{ end }}on {{ site.Title }}\u0026lt;/description\u0026gt; 以上就是添加好的状态，保存修改并提交，然后重新部署博客。\n完成认证 回到Follow，点击认证按钮，如果博客已经被正常部署，那么会显示认证成功。点击头像-\u0026gt;成就，就可以获取60Power的奖励。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/papermod%E6%B7%BB%E5%8A%A0follow-rss%E8%AE%A4%E8%AF%81/","summary":"\u003cp\u003e\u003ca href=\"https://follow.is/\"\u003eFollow\u003c/a\u003e是一个开源RSS阅读器，可以发布自己的订阅源，比如将自己的博客RSS发布到Follow上，其他用户在Follow上订阅你的博客时，就可以看到这是你发布的源，并且可以为源的发布者进行打赏。当然自己的小博客也不指望其他人能订阅，只是想完成Follow的成就任务，完成认证后可以获得Power值，可以用来打赏其他用户，以及购买其他服务，比如订阅付费的列表等。\u003c/p\u003e\n\u003cp\u003ePaperMod已经嵌入了RSS订阅功能，所以认证会很方便，所谓认证就是在自己的网站中加入一段代码，Follow会检测这段代码，如果检测到了，就会认为这个网站是你发布的源，从而完成认证。\u003c/p\u003e","title":"PaperMod添加Follow RSS订阅认证"},{"content":"NAS 的系统磁盘空间告急了，当初用了一张就笔记本闲置的固态硬盘，只有 128G，心想光做系统盘应该足够了，结果还是经不住折腾，需要清理一下磁盘空间。本文记录了一些常用的清理磁盘空间的方法。\n查看磁盘使用情况 df -h 清理软件包 # 清理旧版本缓存 apt-get autoclean # 清理所有缓存 apt-get clean # 移除孤立软件 apt-get autoremove 清理日志 # 查看 journal 日志占用的硬盘空间 journalctl -x --disk-usage # 清理日志到只剩下 10M journalctl --vacuum-size=10M # 清理一天前的日志 journalctl --vacuum-time=1d # 永久限制 journal 日志的大小： [Journal] SystemMaxUse=10M # 硬盘中只保留最近 10M 的日志 RuntimeMaxUse=10M # 内存中只保留最近 10M 的日志 清理 Docker # 清理所有停止的容器 docker container prune # 清理所有未使用的镜像 docker image prune # 清理所有未使用的卷 docker volume prune # 清理所有未使用的网络 docker network prune # 清理所有未使用的镜像、容器、网络、卷，如果你使用docker的话，这一步会释放大量的空间 docker system prune --volumes WARNING! This will remove: - all stopped containers - all networks not used by at least one container - all volumes not used by at least one container - all dangling images - all dangling build cache 清理 pip 缓存 # 清理 pip 缓存 pip cache purge rm -r ~/.cache/pip 大文件查找清理 # 查找大于 100M 的文件 find / -type f -size +100M # 删除大于 100M 的文件 find / -type f -size +100M -delete ","permalink":"https://lifeislife.cn/posts/linux-%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4/","summary":"\u003cp\u003eNAS 的系统磁盘空间告急了，当初用了一张就笔记本闲置的固态硬盘，只有 128G，心想光做系统盘应该足够了，结果还是经不住折腾，需要清理一下磁盘空间。本文记录了一些常用的清理磁盘空间的方法。\u003c/p\u003e","title":"Linux 清理磁盘释放空间"},{"content":"在使用 systemd-journald 进行日志管理时，遇到内核日志输出过快导致日志丢失的情况时，一般是由于 journald 的缓冲区设置过小，无法处理快速输出的内核消息。本文将介绍问题原因，并给出相应的解决方案。\n问题描述 当内核日志输出过快时，systemd-journald 可能会因其内部缓冲区设置过小而无法处理所有日志，导致部分日志信息丢失。表现为系统日志中出现类似以下的错误：\nMissed xxx kernel messages 这种情况通常出现在内核大量输出调试信息、系统初始化阶段日志频繁输出，或系统发生较大故障时。\n原因分析 systemd-journald 是一个处理系统日志的服务，包括内核日志。它通过监听 /dev/kmsg 获取内核日志信息。journald 使用一个内部缓冲区来暂存日志，如果日志流速过快而 journald 无法及时处理，这个缓冲区会被填满，导致消息溢出或丢失。\n默认情况下，journald 的日志缓冲区大小较小，可能无法应对高频率的日志输出。此外，journald 还可能受限于某些系统资源的配置，如最大消息大小、日志文件大小等。\n解决方案 我们可以通过以下几个步骤来缓解或解决内核日志丢失问题：\n1. 增加 systemd-journald 缓存大小 通过调整 systemd-journald 的配置来增大其缓冲区，可以减少日志丢失的情况。\n编辑 journald 的配置文件：\nsudo vim /etc/systemd/journald.conf 找到以下参数并进行调整：\n# RuntimeMaxUse: 设置运行时日志文件的最大使用空间。 # 可以将此值设为较大的值，例如 100M。 RuntimeMaxUse=100M # SystemMaxUse: 设置系统日志文件的最大使用空间。 # 可以将此值设为 500M。 SystemMaxUse=500M # RateLimitInterval: 限制日志接收速率的时间间隔。 # 可以适当延长此时间，例如 10s。 RateLimitInterval=10s # RateLimitBurst: 限制日志接收速率的最大突发数。 # 增加突发限制，比如 10000。 RateLimitBurst=10000 保存并关闭文件，然后重启 journald 服务使配置生效：\nsudo systemctl restart systemd-journald 2. 调整内核日志环形缓冲区的大小 内核日志存储在一个环形缓冲区中，该缓冲区的大小可以通过 dmesg 命令查看和调整。默认的缓冲区可能较小，可以通过 kernel 命令行参数 log_buf_len 来调整。\n编辑 grub 配置文件：\nsudo vim /etc/default/grub 在 GRUB_CMDLINE_LINUX_DEFAULT 行中添加如下参数：\nGRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;log_buf_len=16M\u0026#34; 这将内核日志缓冲区设置为 16M。保存并更新 grub：\nsudo update-grub 然后重启系统以应用更改：\nsudo reboot 3. 禁用日志速率限制 如果日志速率限制不符合当前系统需求，可以考虑禁用速率限制，尤其是在开发和调试环境中：\nsudo vim /etc/systemd/journald.conf 在配置文件中禁用日志速率限制：\nRateLimitInterval=0 RateLimitBurst=0 保存文件并重启 systemd-journald 服务：\nsudo systemctl restart systemd-journald ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3missed--kernel-messages/","summary":"\u003cp\u003e在使用 \u003ccode\u003esystemd-journald\u003c/code\u003e 进行日志管理时，遇到内核日志输出过快导致日志丢失的情况时，一般是由于 \u003ccode\u003ejournald\u003c/code\u003e 的缓冲区设置过小，无法处理快速输出的内核消息。本文将介绍问题原因，并给出相应的解决方案。\u003c/p\u003e","title":"解决systemd-journald查看日志出现Missed  kernel messages"},{"content":" 本文翻译自：PCIe 第 2 部分 - 关于内存：MMIO、DMA、TLP 等！– 灵魂的逆向工程 \u0026mdash; PCIe Part 2 - All About Memory: MMIO, DMA, TLPs, and more! – Reversing Engineering for the Soul\n在这个系列文章的第一部分中，我们讨论了 ECAM 以及软件和硬件数据包网络中的配置空间访问。在讨论中，引入了 TLP（Transaction Layer Packets）的概念，这是所有 PCIe 数据在层次结构中移动的通用数据包结构。我们还讨论了这些数据包如何像以太网一样传输，即路由设备使用一个地址（在这种情况下是 BDF）来发送配置空间数据包穿过网络。\n配置空间读取和写入只是可以直接使用设备执行 I/O 的几种方式之一。通过“configuration”这个名称，我们可以知道很明显它的意图不是为了执行大量数据传输。主要缺点是它的速度，因为配置空间数据包最多只能包含双向读取或写入的 64 位数据（通常只有 32 位）。对于如此少量的可用数据，数据包和其他链路标头的开销非常大，因此浪费了带宽。\n正如第 1 部分所讨论的，理解内存和地址将继续是理解 PCIe 的关键。在这篇文章中，我们将更深入地研究更快的设备 I/O 事务形式，并开始了解软件设备驱动程序如何实际与 PCIe 设备连接以完成有用的工作。\n注意：您无需成为计算机体系结构或 TCP/IP 网络方面的专家即可从这篇文章中获得一些信息。但是，了解 TCP/IP 和虚拟内存的基础知识对于掌握本文的一些核心概念是必要的。这篇文章也以 第 1 部分 中的信息为基础。如果您需要查看这些内容，请立即查看！\nPCIe 中的数据传输方法简介 配置空间是一种在枚举时间内通过其 BDF 与设备通信的一种简单而有效的方式。这是一种简单的传输模式是有原因的 - 它必须是配置和可用的所有其他数据传输方法的基础。枚举设备后，配置空间已设置设备与主机一起执行实际工作所需的所有信息。配置空间仍用于允许主机监控和响应设备及其链接状态的变化，但它不会用于执行设备的实际高速传输或功能。\n配置空间是在枚举时间通过设备的 BDF 进行通信的一种简单有效的方式。它是一种简单的传输模式，是所有数据传输方法的基础。一旦设备被枚举，配置空间就已经设置了设备执行实际工作所需的所有信息，与主机机器一起。配置空间仍用于允许主机计算机监视和响应设备及其链接的变化，但不会用于执行设备的实际高速传输或功能。\n我们现在需要的是数据传输方法，让我们真正开始利用 PCIe 设计的高速传输吞吐量。吞吐量是对给定时间段内传输的字节数的度量。这意味着为了最大限度地提高吞吐量，我们必须最小化每个数据包的开销，以传输每个数据包的最大字节数。如果我们每个数据包只发送几个 DWORD（每个 4 字节），就像在配置空间的情况下一样，PCIe 高速传输能力就浪费了。\n废话不多说，先介绍一下 PCIe 中高速 I/O 的两种主要形式：\n内存映射输入/输出（简称 MMIO）- 与主机 CPU 读取和写入内存到 ECAM 以执行配置空间访问类似，MMIO 可以用来映射设备的地址空间，以执行内存传输。主机机器在其物理地址空间中配置“内存窗口”，使 CPU 拥有一个内存地址窗口，这些内存地址神奇地转换为直接读取和写入设备。内存窗口在 RC 中解码，将 CPU 的读取和写入转换为传输到设备的数据 TLPs。硬件优化使得这种方法可以实现比配置空间访问快得多的吞吐量。然而，其速度仍然远远落后于 DMA 的批量传输速度。 直接内存访问（简称 DMA）- DMA 是迄今为止最常见的数据传输形式，因为它具有原始传输速度和低延迟。每当驱动程序需要在主机和设备之间沿任一方向进行任何重要大小的传输时，它肯定会是 DMA。但与 MMIO 不同的是，DMA 是由设备本身启动的，而不是由主机 CPU 启动的。主机 CPU 将通过 MMIO 告诉设备 DMA 应该去哪里，设备本身负责开始和完成 DMA 传输。这允许设备在没有 CPU 参与的情况下执行 DMA 事务，与设备必须等待主机 CPU 告诉它每次传输做什么相比，这节省了大量的 CPU 周期。由于 DMA 的普遍性和重要性，从硬件实现和软件层面了解 DMA 非常有价值。 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image MMIO 简介 什么是 BAR？ 由于配置空间限制为 4096 字节，因此之后没有太多可用空间用于特定于设备的功能。如果设备想要映射 1GB 的 MMIO 空间来访问其内部 RAM，该怎么办？没有办法将其放入 4096 字节的配置空间。因此，它将需要请求一个被称为 BAR（基地址寄存器）的东西。这是通过配置空间公开的一个寄存器，允许主机机器配置其内存的一个区域，直接映射到设备上。然后主机机器上的软件通过对 BAR 的物理地址的内存读/写指令来访问 BAR，就像我们在 ECAM 的第一部分中看到的 MMIO 一样。对设备内存映射进行读取或写入的操作将直接转换为发送到层次结构上的设备的数据包。当设备需要响应时，它将通过层次结构向主机机器发送一个新的数据包。\n\u003c!DOCTYPE html\u003e Responsive Image 当 CPU 指令读取器件 MMIO 区域的内存时，会生成一个内存读取请求事务层数据包（MemRd TLP），该数据包从主机的 RC 向下传输到器件。这个 TLP 包的目的是通知设备希望读取设备，然后设备需要尽快响应请求地址上的内容。\n在 PCIe 中发送和接收的所有数据传输数据包都将采用 TLP 形式。回想一下第 1 部分，这些数据包是设备之间的所有通信都在 PCIe 中发生的中心抽象。这些数据包在出现数据传输错误（类似于网络中的 TCP）的情况下是可靠的，并且可以根据需要重试/重新发送。这确保了数据传输免受 PCIe 可以达到的极高速度下发生的恶劣电气干扰。我们很快就会仔细研究 TLP 的结构，但现在只需将这些视为您在 TCP 中看到的常规网络数据包。\n\u003c!DOCTYPE html\u003e Responsive Image 当设备收到请求者数据包时，设备会使用 MemRd TLP 响应内存请求。此 TLP 包含从设备内存空间读取的结果，给定原始请求者数据包中的地址和大小。设备将它正在响应的特定请求数据包和发送方标记到响应数据包中，交换层次结构知道如何将响应数据包返回给请求者。然后，请求者将使用数据包中的数据来更新发起请求的 CPU 寄存器。\n同时，当 TLP 正在传输时，CPU 必须等待内存请求完成，并且它不能被中断或执行许多有用的工作。正如你可能看到的，如果需要执行大量这样的请求，CPU 将需要花费大量时间等待设备响应每个请求。虽然在硬件级别进行了优化，使此过程更加简化，但使用 CPU 周期等待数据传输完成仍然不是最佳选择。希望您能看到我们需要第二种类型的传输，即 DMA，来解决 BAR 访问的这些缺点。\n这里的另一个重点是，设备内存并不严格需要用于设备的 RAM。虽然通常会看到具有板载 RAM 的设备通过 BAR 公开其内部 RAM 的映射，但这不是必需的。例如，访问设备的 BAR 可能会访问设备的内部寄存器，也可能导致设备执行某些操作。例如，写入 BAR 是设备开始执行 DMA 的主要方式。一个核心要点是，设备 BAR 非常灵活，可用于控制设备或执行与设备之间的数据传输。\n如何枚举 BAR？ 设备使用其配置空间从软件请求内存区域。在枚举时，由主机确定该区域将放置在物理内存中的位置。每个器件在其配置空间（称为“寄存器”，因此称为基址寄存器）中都有 6 个 32 位值，当枚举器件时，软件将读取和写入这些值。这些寄存器描述了器件希望分配的每个 MMIO 区域的长度和对齐要求，每个可能的 BAR 一个，总共 6 个不同的区域。如果设备希望能够将其 BAR 映射到 4GB 空间（64 位 BAR）以上，它可以将两个 32 位寄存器组合在一起，形成一个 64 位 BAR，最多只留下三个 64 位 BAR。\nPCIe\n\u003c!DOCTYPE html\u003e Responsive Image 术语注释：尽管首字母缩略词 BAR 表示基址寄存器，但你会看到上面的文本也将 MMIO 的内存窗口称为 BAR。不幸的是，这意味着配置空间中的寄存器名称也与给 device 的 MMIO 区域相同（两者都称为 BAR）。你可能需要根据上下文，以确定它们是指内存窗口，还是配置空间本身的实际寄存器。\nBARs 是配置空间中另一个示例，它不是常量寄存器。在第一部分中，我们看了一些常量寄存器，比如 VendorID 和 DeviceID。但是 BARs 不是常量寄存器，它们应该由软件写入和读取。实际上，由软件写入寄存器的值是特殊的，因为将某些类型的值写入寄存器将导致读取时功能不同。如果你没有牢记设备内存并非总是 RAM，读取回来的值可能与写入的不同，那么现在正是时候这么做了。\n设备内存可以是 RAM，但它并不总是 RAM，也不需要像 RAM 那样工作！\n什么是 DMA？引言和理论 到目前为止，我们已经看到了两种形式的 I/O，配置空间访问和通过 BAR 的 MMIO 访问。我们将讨论的最后一种也是最后一种访问形式是直接内存访问（DMA）。DMA 是迄今为止最快的 PCIe 批量传输方法，因为它的传输开销最小。也就是说，通过链路传输最大字节数所需的资源最少。这使得 DMA 对于真正利用 PCIe 提供的高速链路至关重要。\n但是，强大的力量会带来巨大的混乱。对于软件开发人员来说，DMA 是一个非常陌生的概念，因为我们在软件中没有类似的东西可以比较。对于 MMIO，我们可以将内存访问概念化为从设备内存中读取和写入的指令。但 DMA 与此非常不同。这是因为 DMA 是异步的，它不利用 CPU 来执行传输。相反，顾名思义，读取和写入的内存直接来自系统 RAM。一旦 DMA 开始，唯一涉及的各方是系统主内存的内存控制器和设备本身。因此，CPU 不会花费周期等待单个内存访问。相反，它只是启动转移，并让平台在后台自行完成 DMA。然后，平台将在传输完成时通知 CPU，通常是通过中断。\n让我们想一想，为什么异步执行 DMA 如此重要。考虑 CPU 从计算机上的 NVMe SSD 解密大量文件的情况。一旦主机上的 NVMe 驱动程序启动 DMA，设备就会不断以最快的速度将文件数据从 SSD 的内部存储传输到 CPU 可以访问的系统 RAM 中的位置。然后，CPU 可以使用其 100% 的处理能力来执行解密数学运算，以便在从系统内存中读取数据时解密文件块。CPU 不会花时间等待对设备进行单个内存读取，而是简单地连接数据，并允许设备尽可能快地传输，而 CPU 会尽可能快地处理它。在此期间，任何额外的数据都会在系统 RAM 中缓冲，直到 CPU 可以访问它。这样，任何过程的任何部分都不会等待其他事情发生。所有这些都以尽可能快的速度同时发生。\n由于 DMA 的复杂性和涉及的部件数量，我将尝试以最直接的方式解释 DMA，并用大量图表来显示该过程。更令人困惑的是，每个设备都有不同的 DMA 接口。没有用于执行 DMA 的通用软件接口，只有器件的设计人员知道如何告诉该器件执行 DMA。值得庆幸的是，某些设备类别使用普遍认可的接口，例如大多数 SSD 使用的 NVMe 接口或 USB 3.0 的 XHCI 接口。如果没有标准接口，则只有硬件设计人员知道设备如何执行 DMA，因此生产设备的公司或个人需要是编写设备驱动程序的人，而不是依赖与操作系统捆绑的通用驱动程序与设备通信。\n一个简单的 DMA 传输 - Step by Step 我们 DMA 旅程的第一步是查看传输的初始设置。这涉及几个步骤，为即将到来的 DMA 传输准备系统内存、内核和设备。在这种情况下，我们将设置 DMA，以便读取系统 RAM 中存在的 DMA 缓冲区中的内存内容，并将其放入 Target Memory 的器件板载 RAM 中。此时我们已经选择将此内存从 DMA Buffer 读取到器件上地址为 0x8000 中。目标是尽快将此内存从系统内存传输到设备，以便它可以开始处理它。假设在这种情况下，内存量几 M 字节，MMIO 会太慢，但为简单起见，我们将仅显示 32 字节的内存。这种传输将是最简单的 DMA 传输类型：将内存块的已知大小和地址从系统 RAM 复制到设备 RAM。\n\u003c!DOCTYPE html\u003e Responsive Image 第 1 步 - 从操作系统分配 DMA 内存 此过程的第一步是从 OS 分配 DMA 内存。这意味着设备驱动程序必须进行 OS API 调用，以请求 OS 为设备分配一个内存区域以将数据写入。这一点很重要，因为操作系统可能需要执行特殊的内存管理操作才能使数据对设备可用，例如删除保护或重新组织现有分配以促进请求。\n传统上，DMA（直接内存访问）存储器必须是连续的物理存储器，这意味着设备从某个地址和长度的起始处开始，并线性地从缓冲区的起始位置读取/写入数据直到结束。因此，操作系统必须负责组织其物理内存，以创建足够大的连续范围，以满足驱动程序请求的 DMA 缓冲区。有时，对于长时间运行或物理内存有限的系统来说，这可能非常困难。因此，这一领域的增强功能允许更现代的设备使用 Scatter-Gather 和 IOMMU Remapping 等功能传输到非连续的存储器区域。稍后，我们将看一些这些功能。但现在，我们只专注于更简单的连续内存情况。\n一旦请求的分配成功，API 将返回内存地址，并指向系统 RAM 中的缓冲区。这将是设备通过 DMA 访问内存的地址。DMA 意图为 API 返回的地址将被赋予一个特殊的名称; 设备逻辑地址或逻辑地址。对于我们的示例，逻辑地址等同于物理地址。设备看到的是操作系统看到的物理内存的完全相同视图，没有额外的转换。然而，在更高级的传输形式中，情况可能并非总是如此。因此最好意识到，设备给出的地址可能并非总是与其在 RAM 中实际的物理地址相同。\n分配缓冲区后，由于目的是将数据从此缓冲区移动到设备，因此设备驱动程序将提前使用写入设备所需的信息填充缓冲区。在此示例中，由重复 01 02 03 04 模式组成的数据正在传输到设备的 RAM。\n第 2 步 - 将 DMA 地址写入设备并开始传输 传输的下一步是准备设备执行事务所需的信息。这通常是了解器件的特定 DMA 接口最重要的地方。每个设备都以自己的方式进行编程，了解驱动程序应该如何对设备进行编程的唯一方法是参考其通用标准（如 NVMe 规范）或简单地与硬件设计人员合作。\n在这个例子中，我将为一个只有执行传输所需的最基本功能的设备构建一个简化的 DMA 接口。在下面的图表中，我们可以看到这个设备通过向 BAR0 MMIO 区域写入数值来进行编程。这意味着为了为这个设备编程 DMA，驱动程序必须将内存写入由 BAR0 指定的 MMIO 区域。每个寄存器在 BAR0 区域内的位置是由驱动程序编写者提前知道的，并且被集成到设备驱动程序的代码中。\n对于此示例、我在 BAR0 中创建了四个器件寄存器：\nDestination Address（目标地址） - 设备内部 RAM 中用于写入从系统 RAM 读取的数据的地址。这是我们将对已经确定的目标地址 0x8000 进行编程的地方。 Source Address（源地址） - 设备将从中读取数据的系统 RAM 的逻辑地址。这将对我们希望设备读取的 DMA Buffer 的逻辑地址进行编程。 Transfer Size（传输大小） - 我们要传输的大小（以字节为单位）。 Initiate Transfer（启动传输标志位）- 一旦次寄存器写入 1，器件将开始在上面给出的地址之间进行传输。通过这种方式，驱动程序可以判断设备已完成填充缓冲区并准备好开始传输。这通常被称为门铃（Door Bell）寄存器。 \u003c!DOCTYPE html\u003e Responsive Image 在上图中，驱动程序需要使用器件的 BAR0 的映射内存将必要的值写入寄存器（它如何映射此内存取决于 OS）。此图中的值如下所示：\nTarget Memory - 我们要从器件复制的内存将为 0x00008000，它映射到器件板载 RAM 中的内存区域。这将是我们的目标地址。 DMA 缓冲区 - 操作系统在 0x001FF000 分配内存块，因此这将是我们的源地址。 有了这些信息，驱动程序现在可以将值编程到设备中，如下所示：\n\u003c!DOCTYPE html\u003e Responsive Image 现在，驱动程序已经配置了执行传输所需的所有寄存器。最后一步是向启动传输寄存器写入一个值，该寄存器充当开始传输的 Door bell 寄存器。一旦写入此值，设备将驱动 DMA 传输，并独立于驱动程序或 CPU 的参与执行它。驱动程序已完成启动传输的工作，此时 CPU 可在等待设备通知系统 DMA 完成的同时，自由进行其他工作。\n第 3 步 - 设备执行 DMA 事务 现在，驱动程序已写入 Door bell 寄存器，设备现在将接管处理实际传输。在设备本身上，存在一个名为 DMA 引擎的模块，负责处理和维护事务的所有方面。当器件被编程时，对 BAR0 的寄存器写入正在对 DMA 引擎进行编程，其中包含开始在 PCIe 链路上发送必要的 TLP 以执行内存事务所需的信息。\n如上一节所述，PCIe 链路上的所有内存操作都是通过 Memory Write/Read TLP 完成的。在这里，我们将深入研究在交易发生时设备的 DMA 引擎发送和接收的 TLP。请记住，更容易将 TLP 视为在单个可靠连接上发送和接收数据的网络数据包。\n如在前文部分讨论过的，PCIe 链接上的所有内存操作都是通过内存写入/读取 TLPs 来完成的。在这里，我们将深入探讨设备的 DMA 引擎在传输过程中发送和接收的 TLPs。要牢记的是，将 TLPs 视为在一个单一、可靠的连接上发送和接收数据的网络数据包更易于理解。\n插曲：快速了解 TLP 在查看链路上的 TLP 之前，让我们仔细了解一下数据包结构本身的概览。\n以下是内存读取请求和响应的两个 TLP。如前所述，用于内存操作的 TLP 利用请求和响应系统。执行读取的设备将生成特定地址和长度（以 4 字节 DWORD 为单位）的读取请求 TLP，然后坐下来等待完成数据包到达包含响应数据的链路。\n\u003c!DOCTYPE html\u003e Responsive Image 我们可以看到，有与生成请求的设备、Requester 以及唯一的 Tag 值相关的元数据。此 Tag 值用于将请求与其完成匹配。当设备生成请求时，它会使用唯一值标记 TLP 以跟踪待处理的请求。该值由请求的发送者选择，并且由发送者来跟踪其分配的 Tags。\n随着完成的数据通过链路到达，完成的 Tag 让设备能够将接入的数据正确地移至特定传输所需的位置。该系统允许单一设备有多个独特的未完成传输任务，尽管它们接收的数据包相互交错，但仍能保持作为独立传输任务的有序性。\n数据包内部还包含了必要的信息，使得 PCIe 切换层次结构能够确定请求和完成需要去向的位置。例如，内存地址被用来确定正在请求访问的设备是哪一个。在枚举期间，层次结构中的每一个设备都被编程以拥有各自独特的地址范围。切换结构根据数据包中的内存地址，确定数据包需要去向哪里以访问那个地址。\n设备收到并处理请求后，响应数据将以 Completion TLP 的形式发送回去。完成或“响应”数据包可以而且通常会被分段为许多较小的 TLP，这些 TLP 发送整体响应的一部分。这是因为在枚举期间，已确定设备和总线可以处理最大有效载荷大小（MPS）。MPS 可根据平台和设备功能进行配置，从 128 开始，最高可达 4096 的 2 次方大小。通常，此值约为 256 字节，这意味着需要将大型读取请求拆分为许多较小的 TLP。这些数据包中的每一个都有一个字段，该字段指示完成响应的原始请求的偏移量，有效负载中是返回的数据块。\n有一个常见的误解，即内存 TLP 使用 BDF 来寻址数据包需要去往的位置。其实请求仅使用内存地址来指示数据包的目的地，并且设备和目标之间的桥接设备负责将该数据包发送到其正确的位置。。然而，完成数据包确实利用请求者的 BDF 将数据返回给发起请求的设备。\n以下是一个展示内存读取和响应过程的图表，图中展示出请求会使用一个地址来发起请求，而完成的操作会使用请求中 Request 字段的 BDF 来发送相应应答：\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 现在回到实际的传输 让我们看看 DMA 引擎为了执行我们的请求而发送和接收的所有内容。由于我们请求了 32 字节的数据，因此只有一个单一的 Memory Read Request 和一个带有响应的单一 Memory Read Completion 数据包。为了便于您理解，请停止向前阅读，并考虑一下在此事务中哪个设备将发送和接收哪个 TLP。如果您需要再次查看第 2 步的图表，请向上滚动。\n现在，让我们深入研究一下传输的实际数据包。虽然我将继续绘制这个模拟示例，但我认为对于这个练习，当执行真实传输时，实际看到其中一些 TLP 是什么样子可能会很有趣。\n在实验中，我使用真实设备配置了如上文所示的同类通用参数，并启动了 DMA。这个设备会发送真实的 TLPs，将系统 RAM 中的内存读取到设备里。因此，你将有机会罕见地查看在执行这种 DMA 时发送的实际 TLPs 的例子，除非有分析器，否则这些在传输过程中几乎无法看到。\n要查看此实验，请点击此链接至配套文章：Experiment - Packet Dumping PCIe DMA TLPs with a Protocol Analyzer and Pcileech – Reversing Engineering for the Soul\n以下是器件生成的内存读取请求以及请求如何遍历层次结构的框图。\n\u003c!DOCTYPE html\u003e Responsive Image 勘误表：0x32 应该是 32\n此图中概述的步骤如下：\nDMA 引擎创建 TLP - DMA 引擎识别出它必须从 0x001FF000 读取 32 字节。它生成一个包含此请求的 TLP，并通过其本地 PCIe 链路将其发送出去。 TLP 遍历层次结构 - PCIe 的交换层次结构通过桥接设备移动此请求，直到它到达其目的地，即 RC。回想一下，RC 负责处理所有用于访问系统 RAM 的传入数据包。 通知 DRAM 控制器 - RC 在内部与 DRAM 控制器通信，该控制器负责实际访问系统 DRAM 的内存。 从 DRAM 读取内存 - 从地址 0x001FF000 的 DRAM 请求给定长度的 32 字节，并将其返回到值为 01 02 03 04\u0026hellip; 尽量不要被这些信息淹没，因为我确实知道仅针对单个内存请求 TLP 就有很多事情要做。所有这些在高层次上归结为仅从 RAM 中的地址 0x001FF000 读取 32 字节的内存。平台如何通过与 DRAM 控制器通信来实际读取系统 DRAM，仅供您参考。设备本身不知道 Root Complex 实际上是如何读取此内存的，它只是使用 TLP 启动传输。\n注意：此处未显示更复杂的 RAM 缓存过程。在 x86-64 上，来自设备的所有内存访问都是缓存一致的，这意味着平台会自动将 CPU 缓存与设备正在访问的值同步。在其他平台（如 ARM 平台）上，由于其缓存架构，这是一个更复杂的过程。现在，我们只假设缓存一致性正在自动为我们处理，我们对此没有任何特别的担忧。\n当 RC 收到此 TLP 时，它会在内部标记 Requester 和 Tag 的读取内容。当它等待 DRAM 响应该值时，此请求的信息将在 RC 中等待。要概念化这一点，可以将其视为网络套接字中的“open connection”。RC 知道它需要响应什么，因此会等到响应数据可用后，再通过套接字将数据发送回去。\n最后，将 Completion 从 Root Complex 发送回设备。请注意，Destination 与 Requester 相同：\n\u003c!DOCTYPE html\u003e Responsive Image 以下是响应数据包概述的步骤，如上所示：\n从 DRAM 读取内存 - DRAM 控制器从系统 DRAM 中 0x001FF000 的 DMA 缓冲区地址读取 32 字节。 DRAM 控制器响应根复合体 - DRAM 控制器在内部响应从 DRAM 向 RC 请求的内存 RC 生成完成 - RC 跟踪传输并为从 DRAM 读取的值创建完成 TLP。在此 TLP 中，元数据值是根据 RC 对待处理传输的了解来设置的，例如发送的字节数、传输的标记以及从原始请求的 Requester 字段复制的目标 BDF。 DMA 引擎接收 TLP - DMA 引擎通过 PCIe 链路接收 TLP，并查看标签是否与原始请求的相同标签匹配。它还会在内部跟踪此值，并知道有效负载中的内存应写入 Target Memory，该内存在设备内部 RAM 中处于 0x8000。 Target Memory is Written（目标内存已写入） - 设备内存中的值将更新为从数据包的 Payload 中复制的值。 系统中断 - 虽然这是可选的，但大多数 DMA 引擎将配置为在 DMA 完成时中断主机 CPU。这会在设备成功完成 DMA 时向设备驱动程序发出通知。 同样，仅处理这个 complete 数据包就涉及很多步骤。但是，同样，您可以将整个过程简单地视为“从设备的请求中收到 32 字节的响应”。这些步骤的其余部分只是为了向您展示此响应处理的完整端到端是什么样子。\n从这里，设备驱动程序会收到 DMA 已完成的通知，设备驱动程序的代码负责清理 DMA 缓冲区或将其存储起来以供下次使用。\n在我们的艰苦努力后，我们终于完成了一次单一的 DMA 传输事务！想到这就是我能提供的最“简单”的传输方式，真是让人惊讶。有了 IOMMU 重映射和 Scatter-Gather 能力的加入，这些事务甚至可能变得更复杂。但就现在而言，你应该对 DMA 的全部内容以及它如何在真实设备中运作有了深入的理解。\n尾声 - 关于复杂性的小说明 如果您读完这篇文章并觉得自己没有完全掌握所有抛给您的概念，或者对复杂性感到不知所措，您不必担心。这些帖子如此复杂的原因是它不仅涵盖广泛的主题，而且还涵盖广泛的专业。通常，整个系统的每个部分在行业中都有不同的团队，他们只关注他们在这个复杂机器中的“齿轮”。通常，硬件开发人员专注于设备，驱动程序开发人员专注于驱动程序代码，而操作系统开发人员专注于资源管理。这些团队之间很少有太多重叠，除非在他们的边界交接，以便另一支团队可以连接到它。\n这些帖子有点独特，因为它们试图将系统作为一个整体进行记录，以便于概念理解，而不是实现。这意味着，在通常划定团队边界的地方，这些帖子根本不关心。我鼓励觉得这个话题有趣的读者在自己的时间里继续深入研究。也许您可以了解一些 FPGA 并开始制作自己的设备，或者您可以购买一个设备并开始尝试对其进行逆向工程，并通过您自己的定制软件与它进行通信。\n总结 希望您喜欢这篇深入探讨 PCIe 内存传输的文章！虽然我在这篇文章中涵盖了大量信息，但兔子洞总是更深。值得庆幸的是，通过学习配置空间访问、MMIO（BAR）和 DMA，您现在已经涵盖了 PCIe 中可用的各种形式的数据通信！对于连接到 PCIe 总线的每个设备，主机系统和设备之间的通信将通过这三种方法中的一种进行。设备的链接、资源和驱动程序软件的所有设置和配置最终都是为了促进这三种形式的通信。\n这篇文章花了这么长时间才发布的一个重要原因是，为了理解这一切，我必须向读者展示大量信息。很难决定什么值得写，什么太深以至于理解变得模糊。这个决定瘫痪使博客写作过程花费的时间比我预期的要长得多。再加上全职工作，很难找到时间来撰写这些帖子。\n在即将发布的帖子中，我期待着讨论以下一些或所有的话题：\n层次结构的 PCIe 交换/桥接和枚举 更高级的 DMA 主题，例如 DMA 重新映射 电源管理;设备如何“睡眠”和“唤醒” 平台/OS 的中断及其分配和处理 设备的简单驱动程序开发示例 与往常一样，如果你有任何问题或想评论或讨论这个系列的某个方面，你最好在我的 discord 的 #hardware 频道中通过“@gbps”找到我，逆向工程 discord\n请期待未来的帖子！\n","permalink":"https://lifeislife.cn/posts/%E8%AF%91%E6%96%87-pcie-part2/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文翻译自：\u003ca href=\"https://ctf.re/kernel/pcie/tutorial/dma/mmio/tlp/2024/03/26/pcie-part-2/\"\u003ePCIe 第 2 部分 - 关于内存：MMIO、DMA、TLP 等！– 灵魂的逆向工程 \u0026mdash; PCIe Part 2 - All About Memory: MMIO, DMA, TLPs, and more! – Reversing Engineering for the Soul\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在这个系列文章的第一部分中，我们讨论了 ECAM 以及软件和硬件数据包网络中的配置空间访问。在讨论中，引入了 TLP（Transaction Layer Packets）的概念，这是所有 PCIe 数据在层次结构中移动的通用数据包结构。我们还讨论了这些数据包如何像以太网一样传输，即路由设备使用一个地址（在这种情况下是 BDF）来发送配置空间数据包穿过网络。\u003c/p\u003e","title":"PCIe Part 2 - 关于内存的一切 MMIO DMA TLPs !"},{"content":" 本文翻译自：面向 Windows 初学者的 PCIe 实用教程（第 1 部分）– 灵魂的逆向工程 \u0026mdash; A Practical Tutorial on PCIe for Total Beginners on Windows (Part 1) – Reversing Engineering for the Soul\nHello！我最近一直在与一些朋友和同事交谈，他们有兴趣了解更多关于 PCIe 的信息，但对复杂性或缺乏适合初学者的简单资源感到害怕。我最近经常使用 PCIe，觉得可能值得以博客文章的形式分享我的一些经验。\n本文主要供具有计算机系统背景并且喜欢亲身实践的人员使用。它也适用于 PCIe 的初学者，或者是对通用概念有所理解但却无法将它们联系在一起的人。\n第一件事是第一件事：不要被吓倒。有很多首字母缩略词和令人困惑的概念，当你\u0026quot;明白\u0026quot;时，它们就会变得简单。当时要迈出一步，不要害怕提出问题！（如果你想问我问题，可以考虑在 Reverse Engineering Discord 的 #hardware 频道@Gbps ping 我）\n我打算在这个系列中做几件事：\n从软件方面将 PCIe 分解为我认为最重要的内容，以学习和为现代 PC/服务器系统构建一个良好的基线思想模型。 展示使用各种工具（通常是 WinDbg）在 Windows 上调查 PCIe 层次结构和设备的实际示例。 为避免造成混淆，我会有意识地简化或略过一些具体的细节。在这里，可能会有一些术语的使用不准确，甚至信息本身也可能在技术上有所出入。但是，这样做的目的是为了学习整个系统，而不是规范的具体细节。PCIe 是复杂的，当我们处于初学阶段时，陷入过多的细节和特殊情况是没有意义的。 我们希望通过将这项技术与你已经熟悉的概念相联系，来揭开其神秘面纱。PCIe 并未重新发明轮子，通过理解与它类似的技术，你可能已经比你自己意识到的了解得更多。 我不打算用这个系列做以下事情：\n详细了解传统 PCI 或 PCI-X。一般来说，这项技术除了历史价值之外并不重要。 演示如何为 PCIe 设备编写设备驱动程序。这是非常特定于操作系统的，并且比这里要讨论的要高得多。 详细介绍 PCIe 的链路层。该规范的一半以上都花在了这个主题上，并包含了一些世界上最前沿的高速数据传输技术。我不处理这边的事情，但是将来我可能会谈论使用 FPGA 构建 PCIe 设备（我以前做过）。 帮助你使用 PCIe 在视频游戏中作弊。是的，它存在。不，我不会帮忙。 这并不是对技术或协议的全面研究。要获得真正详尽的了解，你应该参考永远难以捉摸的 PCI-SIG PCI Express 基本规范。这是实现所有 PCIe 代码所依据的规范。目前，在撰写本文时，我们使用的是该规范的 6.0 版，但 3.0 及更高版本的版本都与现代 PCIe 完全相关。如何获得这种昂贵的规格对读者来说是一项练习。\n注意：我有时会在“PCI”和“PCIe”之间来回切换，将技术描述为一种习惯的力量。除非另有说明，否则本系列中的所有内容都是关于 PCIe 的。\n什么是 PCIe，我为什么要关注？ PCIe 代表 Peripheral Component Interconnect Express，外围设备组件互联传输。它于 2003 年首次推出，是从早期 PC 时代越来越流行的旧 PCI 和 PCI-X 规范演变而来的（为 Express 添加了“e”以区分它）。\n大多数使用计算机的人都认为它是主板上插入显卡或适配器卡的 PCIe 插槽，但 PCIe 不仅仅是这几个扩展 Port。PCIe 是现代 CPU 与连接到系统的几乎所有设备通信的基础。\n自推出以来，PCIe 的受欢迎程度飙升，成为短距离高速数据传输的近乎通用的标准。几乎所有的 M.2 SSD 都使用 NVMe over PCIe 作为其传输协议。Thunderbolt 3 能够使用外部线将 PCIe 设备直接动态热插拔到系统（支持扩展坞和 eGPU 等技术）。在此基础上，USB4 正在扩展 Thunderbolt 3，以使这种 PCIe 路由技术能够达到开放的 USB 规范。CXL 等新型传输协议，用于数据中心服务器，以 PCIe 为基础规范并在其上扩展他们的特别功能。\n即使与之通信的设备本身不使用 PCIe 作为其物理层协议，系统仍必须使用 PCI 的软件接口进行通信。这是因为系统使用适配器（通常称为主机控制器），这些适配器是 PCI 设备，有助于将来自 CPU 的 PCI 请求转换为主机控制器支持的任何协议或总线。例如，此测试计算机上的所有 USB 3.1 都使用 USB XHCI 协议，该协议是一种通信协议，通过与 USB 主机控制器通信的 PCI 驱动程序将 PCIe 桥接到 USB。\n\u003c!DOCTYPE html\u003e Responsive Image 毋庸置疑，PCI 如今无处不在，并且已被计算机世界的各个部分完全采用。因此，我们必须对这项技术有很好的理解，以更好地理解现代计算。\n研究 PCIe 层次结构 - 一种分组交换网络 从传统的 PCI 转变到 PCIe 最重要的变化是从真正的总线拓扑结构转变为点对点链接。你可以将这看作是以太网集线器向今天的以太网交换机的演变。每个链接都是一个单独的点对点链接，其路由方式就像在一个分组交换的以太网网络上的以太网线一样。这意味着 PCIe 实际上并不是一个“总线协议”，尽管在各种文献和技术规范中让人困惑的频繁使用“总线”这个词。人们必须仔细理解，这个词“总线”并不意味着多个 PCIe 设备在同一个物理链接上进行通信。数据包（也被称为 TLPs）经过每个单独的链接，层次结构中的交换设备使用数据包内的路由信息将数据包传送到正确的 Port。\n在我们进入 PCIe 的技术细节之前，首先我们需要谈谈整个系统的布局。我们研究 PCIe 层次结构的第一种方法是通过 Windows 设备管理器。大多数熟悉 Windows 的人以前都用过它，但没有多少人知道 View \u0026gt; Devices by Connection 中发现的非常方便的功能。\n\u003c!DOCTYPE html\u003e Responsive Image 通过选择此视图，我们可以从根 PNP（Plug-N-Play）节点看到系统的完整拓扑。PNP 根节点是 Windows 上所有设备树的根，无论它们使用什么总线或协议。每个设备（无论是虚拟设备还是物理设备）都被枚举并放置在此 PNP 树上。我们可以利用 Device Manager 的这个视图来查看这个树的布局。\n特别是，我们希望在系统上找到 PCI 设备的布局。这样，我们就可以开始构建 PCI 树在这台机器上的外观的可视化模型。为此，我们需要找到 PCI 树的根：RC。RC（缩写为 RC）是系统上所有 PCIe 的所有者。它物理上位于 CPU 芯片上，负责充当所有 PCIe 设备接收和发送数据包的主机。它可以被认为是软件（在你的机器上执行的指令）和硬件（PCIe 和 RAM 的外部世界）之间的桥梁。\n在这个系统中，它位于这里的 PNP 层次结构中：\n\u003c!DOCTYPE html\u003e Responsive Image 注意：你现在可能会问：“如果 PCI 主导了一切，为什么 PCI 根复合物不在树的顶部？答案是由于 PCIe 总线不是启动期间固件提供的系统初始布局。相反，ACPI（高级配置和电源接口）是描述 PCIe 到操作系统存在的东西。虽然你永远不会在 PC 中看到它，但可以描述一个没有 PCI 总线的系统，所有内容都完全由 ACPI 提供。我们稍后会详细讨论 ACPI，但现在不要太担心这个，只要知道 ACPI 是固件告诉我们RC在哪里的方式，然后帮助操作系统枚举树中的 PCI 设备。\n所以现在我们知道 RC 是 PCIe 树的顶部，现在让我们看一下它下面的所有内容：\n\u003c!DOCTYPE html\u003e Responsive Image 不出所料，此 PCI 总线上有许多设备。在这里，我们可以看到负责音频、集成显卡、USB、串行和 SATA 的各种控制器。此外，我们还看到其中一些设备称为 PCI Express Root Port。Root Port 是RC上的一个 Port，另一个 PCIe 端点（又名物理“设备”）或交换机（又名“路由器”）可以连接到该 Port。出于 PCI 规范的考虑，你将听到 Endpoint 称为 Type 0 设备，而 Switch（或网桥）称为 Type 1 设备，因为一个被配置为用于通信的设备，另一个被配置为用于路由数据包的设备。RC 将具有与其物理支持的一样多的 Root Port。也就是说，可以连接到 CPU 芯片的次数越多。CPU 上的一些 Root Port 可能直接路由到物理 PCIe 插槽，而其他 Root Port 可能路由到其他类型的插槽，如 NVMe 插槽。它也可能被路由到另一个 PCIe 交换设备，该设备可以将数据包路由到多个 Port，从而一次路由到多个端点。\n我会继续提出这个比较，但我觉得这很重要——如果你已经了解以太网交换机，你就已经了解 PCIe 交换机。你可以想象这些 Root Port 就像台式计算机上的以太网 Port。你可以将这些直接连接到其他设备（例如摄像头），也可以将它们连接到像家用路由器/调制解调器这样的交换机，这将交换数据包以公开更多连接，以便与更多设备和机器通信。在这种情况下，以太网线是将一个 PCIe Port 连接到另一个 PCIe Port 的铜线，从而使其成为“点对点”。\n考虑到这一点，让我们开始绘制这个层次结构（部分）图表，以便我们直观地看到它的全部布局：\n\u003c!DOCTYPE html\u003e Responsive Image 在 PCI 中，系统上的所有“总线”都用 0 到 255（含）之间的数字标识。此外，所有设备都使用“设备 ID”和“功能 ID”进行标识。这通常被描述为 Bus/Device/Function，或简称为 BDF。在更正确的规范术语中，这称为 RID（请求者 ID）。为了减少混淆，我将它称为 BDF。BDF 很重要，因为它专门告诉我们设备在 PCIe 层次结构中的位置，以便我们可以与之通信。\n因为这些都位于层级结构的顶层，所以我们将为这个“bus”提供一个数字标识符，即“Bus 0”或 Root Bus。我们可以通过右键单击顶级设备并选择 Properties 并查看 Location 来验证所有这些设备是否都是 Bus 0 设备：\n\u003c!DOCTYPE html\u003e Responsive Image 对于此集成图形设备，它的 BDF 为 0:2.0。它位于总线 0（根总线）上，设备 ID 为 2，功能 ID 为 0。在这种情况下，“设备”表示物理设备，例如显卡。“功能”是物理设备向系统公开的独特功能。无论出于何种意图和目的，都可以将其视为一个单独的实体。公开多个功能的设备被恰当地称为多功能设备（MFD）。这意味着它向系统公开两个或多个 PCI 连接，而实际上只有一个设备。我们很快就会看到一个真正的 MFD 示例。\n敏锐的读者会注意到，我们已经打破了我之前提到的“规则”：与这个独特的总线 0 相连的设备有很多。这是 PCIe 中“点对点”规则的第一个例外，只有在因为总线 0 物理上位于 CPU 的硅片上的情况下才允许这样做。也就是说，这些设备之间没有电气路径，这是一个想象中的连接。所有这些设备都存在于 CPU 封装内，并使用极高速电气互连进行路由。这些处理器互连使用的是特定于 CPU 供应商的内部协议，尽管这些协议并未公开文档，但我们仍然以 PCIe 的“语言”与它进行通信。这些端点（标记为绿色），由于其特殊性质，将被赋予一个特殊的名称：根复合集成端点（RC Integrated Endpoints，简称 RCIE），因为它们直接集成在 RC 上。\n这并不奇怪，你会期望集成 UHD 图形等设备将物理位于 CPU 上（因为它是 CPU 规格的一部分）。但是，我们可以通过观察其他 RCIE 来了解系统的一些更有趣的拓扑结构，例如这里也存在 RAM 控制器（与内存的 DRAM DIMM 通信的硅）和 USB 控制器（与外部 USB 设备通信的硅）。这就是为什么某些 CPU 仅支持某些类型的 RAM 和 USB 规范的原因——因为通信的设备在物理上位于 CPU 上，并且仅支持它们在物理上创建时要支持的规范。\n更新：这种说法是不正确的。一些 IO 控制器仍然可以在称为 PCH（Intel）或也称为芯片组（AMD）的分立芯片上找到，该芯片位于 CPU 附近，并且具有高速链路，使其看起来像是集成到 CPU 芯片中。上面这句话错误地说你可以在物理 CPU 上找到 USB 控制器，而它更有可能在“芯片组”上。但是，为了提高速度，与 RAM 通信的内存控制器位于 CPU 芯片上。\n此图是层次结构第一级的最小化版本，但现在让我们通过在设备管理器中展开其余的 Root Ports 来构建层次结构的其余部分。\n这是填充的图表的样子：\n\u003c!DOCTYPE html\u003e Responsive Image 注意：我已经标记了 UHD Graphics 设备和总线 0 的 BDF。\n这些 Root Port 物理上位于 CPU 上，但连接到它的设备并不在其中。这台机器的外部 PCIe 插槽上连接了 3 个设备：一块 NVIDIA Quadro P400 图形卡和两个 NVMe 驱动器。通过进入设备管理器中每个设备的属性，我们可以获取并更新它们在视觉上的 BDF(总线、设备、功能) 信息。\n\u003c!DOCTYPE html\u003e Responsive Image 在每个 Root Port 下，我们可以看到一个设备已物理连接。但是，我们还可以看到，我们在每个 Bus 下都公开了一个新的 Bus。Root Port 充当了桥，它将我们从总线 0 桥接到新的总线，因此必须为新总线分配一个新的数字 ID，并且该 Port 下的所有设备/功能都将继承该新总线编号。这与 OS/固件在引导期间的总线枚举期间使用的逻辑相同：所有网桥和交换机都公开一条新总线，必须为其分配新的总线 ID 号。\n在这种情况下，我们还可以看到一个多功能设备的好例子。Quadro P400 显卡充当具有两种功能的 MFD。第一个函数是 0（BDF 01:00.0），是显卡设备本身。第二个功能是 1（BDF 01:00.1），它是音频控制器，允许从 HDMI 等 Port 播放音频。这两个功能是不同的——它们用于完全不同的目的，并且具有与之关联的单独驱动程序和配置，但它们仍然由相同的物理设备（即设备 0）实现，并且位于同一总线（即总线 1）上。这与 PCIe 的点对点规则是一致的，一个链路上只能连接一个物理设备，因此总线上只能存在一个物理设备（除了例外，总线 0）。\n从 WinDbg 探索 PCIe 层次结构和设备 到目前为止，我们已经通过使用 Device Manager 的“View by Connection”功能看到了标准的 PCI 总线层次结构。还有另一种更详细的方法来调查 PCIe 层次结构：使用 WinDbg 提供的可靠内核调试扩展。\n注意：我们假设你了解如何在一台机器上设置内核调试器来继续下面的操作。你也可以用 LiveKD 来完成大部分练习。如果你并不了解如何设置，可以参考微软提供的指南：设置 KDNET。\n我已经连接到了一台与上述使用的机器不同的新测试机。我们将通过调试器的输出，来演练如何绘制这台机器的层次结构图。我们也将学习如何通过其配置内存来查找设备的信息。\n放入调试器后，我们将使用！pcitree 命令开始。这将转储系统上列举的 PCI 设备的文本树形图。\n8: kd\u0026gt; !pcitree Bus 0x0 (FDO Ext ffffdc89b9f75920) (d=0, f=0) 80866f00 devext 0xffffdc89b0759270 devstack 0xffffdc89b0759120 0600 Bridge/HOST to PCI (d=1, f=0) 80866f02 devext 0xffffdc89ba0c74c0 devstack 0xffffdc89ba0c7370 0604 Bridge/PCI to PCI Bus 0x1 (FDO Ext ffffdc89ba0aa190) No devices have been enumerated on this bus. (d=2, f=0) 80866f04 devext 0xffffdc89ba0c94c0 devstack 0xffffdc89ba0c9370 0604 Bridge/PCI to PCI Bus 0x2 (FDO Ext ffffdc89ba0a8190) (d=0, f=0) 10de13bb devext 0xffffdc89ba04f270 devstack 0xffffdc89ba04f120 0300 Display Controller/VGA (d=0, f=1) 10de0fbc devext 0xffffdc89ba051270 devstack 0xffffdc89ba051120 0403 Multimedia Device/Unknown Sub Class (d=3, f=0) 80866f08 devext 0xffffdc89ba0cb4c0 devstack 0xffffdc89ba0cb370 0604 Bridge/PCI to PCI Bus 0x3 (FDO Ext ffffdc89ba08f190) No devices have been enumerated on this bus. (d=5, f=0) 80866f28 devext 0xffffdc89ba0cd4c0 devstack 0xffffdc89ba0cd370 0880 Base System Device/\u0026#39;Other\u0026#39; base system device (d=5, f=1) 80866f29 devext 0xffffdc89ba0cf4c0 devstack 0xffffdc89ba0cf370 0880 Base System Device/\u0026#39;Other\u0026#39; base system device (d=5, f=2) 80866f2a devext 0xffffdc89ba0d14c0 devstack 0xffffdc89ba0d1370 0880 Base System Device/\u0026#39;Other\u0026#39; base system device (d=5, f=4) 80866f2c devext 0xffffdc89ba0d34c0 devstack 0xffffdc89ba0d3370 0800 Base System Device/Interrupt Controller (d=11, f=0) 80868d7c devext 0xffffdc89ba0d84c0 devstack 0xffffdc89ba0d8370 ff00 (Explicitly) Undefined/Unknown Sub Class (d=11, f=4) 80868d62 devext 0xffffdc89ba0da4c0 devstack 0xffffdc89ba0da370 0106 Mass Storage Controller/Unknown Sub Class (d=14, f=0) 80868d31 devext 0xffffdc89ba0dc4c0 devstack 0xffffdc89ba0dc370 0c03 Serial Bus Controller/USB (d=16, f=0) 80868d3a devext 0xffffdc89ba0de4c0 devstack 0xffffdc89ba0de370 0780 Simple Serial Communications Controller/\u0026#39;Other\u0026#39; (d=16, f=3) 80868d3d devext 0xffffdc89ba0e04c0 devstack 0xffffdc89ba0e0370 0700 Simple Serial Communications Controller/Serial Port (d=19, f=0) 808615a0 devext 0xffffdc89ba0e24c0 devstack 0xffffdc89ba0e2370 0200 Network Controller/Ethernet (d=1a, f=0) 80868d2d devext 0xffffdc89ba0e44c0 devstack 0xffffdc89ba0e4370 0c03 Serial Bus Controller/USB (d=1b, f=0) 80868d20 devext 0xffffdc89ba0254c0 devstack 0xffffdc89ba025370 0403 Multimedia Device/Unknown Sub Class (d=1c, f=0) 80868d10 devext 0xffffdc89ba0274c0 devstack 0xffffdc89ba027370 0604 Bridge/PCI to PCI Bus 0x4 (FDO Ext ffffdc89ba0a9190) No devices have been enumerated on this bus. (d=1c, f=1) 80868d12 devext 0xffffdc89ba02c4c0 devstack 0xffffdc89ba02c370 0604 Bridge/PCI to PCI Bus 0x5 (FDO Ext ffffdc89b9fe6190) No devices have been enumerated on this bus. (d=1c, f=3) 80868d16 devext 0xffffdc89ba02e4c0 devstack 0xffffdc89ba02e370 0604 Bridge/PCI to PCI Bus 0x6 (FDO Ext ffffdc89ba0a7190) (d=0, f=0) 12838893 devext 0xffffdc89ba062270 devstack 0xffffdc89ba062120 0604 Bridge/PCI to PCI Bus 0x7 (FDO Ext ffffdc89ba064250) No devices have been enumerated on this bus. (d=1c, f=4) 80868d18 devext 0xffffdc89ba0304c0 devstack 0xffffdc89ba030370 0604 Bridge/PCI to PCI Bus 0x8 (FDO Ext ffffdc89ba0b2190) No devices have been enumerated on this bus. (d=1d, f=0) 80868d26 devext 0xffffdc89ba0364c0 devstack 0xffffdc89ba036370 0c03 Serial Bus Controller/USB (d=1f, f=0) 80868d44 devext 0xffffdc89ba0384c0 devstack 0xffffdc89ba038370 0601 Bridge/PCI to ISA (d=1f, f=2) 80868d02 devext 0xffffdc89ba03a4c0 devstack 0xffffdc89ba03a370 0106 Mass Storage Controller/Unknown Sub Class (d=1f, f=3) 80868d22 devext 0xffffdc89ba03c4c0 devstack 0xffffdc89ba03c370 0c05 Serial Bus Controller/Unknown Sub Class 注意：如果你遇到“无法获取 PciFdoExtensionListHead 地址”的错误，确保你的符号设置正确，并执行.reload pci.sys 操作来重新加载 PCI 的符号。\n当显示此输出时，由于空格的格式设置方式，可能很难直观地看到“tree”。解释此输出的方法是查看 Bus 0x 文本的缩进。任何比 Bus 0x 行进一步缩进一组空格的东西都是该总线上的设备。我们可以看到，在器件的正下方还有其他 Bus 0x 线路。这意味着 Bus 0x 线上方的器件正在向我们公开一条新总线，并且总线编号在那里给出。\n让我们看一下此输出的特定部分：\nBus 0x0 (FDO Ext ffffdc89b9f75920) (d=0, f=0) 80866f00 devext 0xffffdc89b0759270 devstack 0xffffdc89b0759120 0600 Bridge/HOST to PCI (d=1, f=0) 80866f02 devext 0xffffdc89ba0c74c0 devstack 0xffffdc89ba0c7370 0604 Bridge/PCI to PCI Bus 0x1 (FDO Ext ffffdc89ba0aa190) No devices have been enumerated on this bus. (d=2, f=0) 80866f04 devext 0xffffdc89ba0c94c0 devstack 0xffffdc89ba0c9370 0604 Bridge/PCI to PCI Bus 0x2 (FDO Ext ffffdc89ba0a8190) (d=0, f=0) 10de13bb devext 0xffffdc89ba04f270 devstack 0xffffdc89ba04f120 0300 Display Controller/VGA (d=0, f=1) 10de0fbc devext 0xffffdc89ba051270 devstack 0xffffdc89ba051120 0403 Multimedia Device/Unknown Sub Class (d=3, f=0) 80866f08 devext 0xffffdc89ba0cb4c0 devstack 0xffffdc89ba0cb370 0604 Bridge/PCI to PCI Bus 0x3 (FDO Ext ffffdc89ba08f190) No devices have been enumerated on this bus. 在此输出中，我们可以看到每个设备显示的 BDF。我们还可以看到总线 0 上存在的一组 Root Port，这些 Port 下面没有列举任何设备，这意味着插槽尚未连接到任何设备。\n在这里看到树结构应该更容易，但无论如何，让我们把它画出来：\n\u003c!DOCTYPE html\u003e Responsive Image 注意：这只是一个巧合，即公交号恰好与桥梁/PCI 的设备编号匹配到 PCI 端口。\n如你现在所知，标记为 Bridge/PCI to PCI 的设备实际上是 Root Port，而总线 2 上的设备实际上是一个多功能设备。与设备管理器不同，我们看不到！pcitree 中的设备真实名称。相反，我们只得到了一个通用的 PCI 名称，用于设备“类型”将自己宣传为什么。这是因为设备管理器 从驱动程序读取设备名称，而不是直接从 PCI 读取设备名称。\n要了解更多关于这个显示控制器设备的信息，我们可以使用命令 ！devext [pointer]，其中 [pointer] 是布局中单词 devext 后面的值。在本例中，它是：\n(d=0, f=0) 10de13bb devext 0xffffdc89ba04f270 devstack 0xffffdc89ba04f120 0300 Display Controller/VGA !devext 0xffffdc89ba04f270 从这里，我们将从 Windows 中的 PCI 总线驱动程序获得此 PCI 设备的摘要的打印输出，pci.sys：\n8: kd\u0026gt; !devext 0xffffdc89ba04f270 PDO Extension, Bus 0x2, Device 0, Function 0. DevObj 0xffffdc89ba04f120 Parent FDO DevExt 0xffffdc89ba0a8190 Device State = PciStarted Vendor ID 10de (NVIDIA CORPORATION) Device ID 13BB Subsystem Vendor ID 103c (HEWLETT-PACKARD COMPANY) Subsystem ID 1098 Header Type 0, Class Base/Sub 03/00 (Display Controller/VGA) Programming Interface: 00, Revision: a2, IntPin: 01, RawLine 00 Possible Decodes ((cmd \u0026amp; 7) = 7): BMI Capabilities: Ptr=60, power msi express Express capabilities: (BIOS controlled) Logical Device Power State: D0 Device Wake Level: Unspecified WaitWakeIrp: \u0026lt;none\u0026gt; Requirements: Alignment Length Minimum Maximum BAR0 Mem: 01000000 01000000 0000000000000000 00000000ffffffff BAR1 Mem: 10000000 10000000 0000000000000000 ffffffffffffffff BAR3 Mem: 02000000 02000000 0000000000000000 ffffffffffffffff BAR5 Io: 00000080 00000080 0000000000000000 00000000ffffffff ROM BAR: 00080000 00080000 0000000000000000 00000000ffffffff VF BAR0 Mem: 00080000 00080000 0000000000000000 00000000ffffffff Resources: Start Length BAR0 Mem: 00000000f2000000 01000000 BAR1 Mem: 00000000e0000000 10000000 BAR3 Mem: 00000000f0000000 02000000 BAR5 Io: 0000000000001000 00000080 Interrupt Requirement: Line Based - Min Vector = 0x0, Max Vector = 0xffffffff Message Based: Type - Msi, 0x1 messages requested Interrupt Resource: Type - MSI, 0x1 Messages Granted 这里有很多内核知道的关于这个设备的信息。此信息是通过 配置空间（缩写为“config space”）检索的，配置空间 是系统上的内存部分，允许内核以标准化的方式枚举、查询信息和设置 PCI 设备。软件从设备读取内存以查询供应商 ID 等信息，设备（如果已打开电源）使用该信息进行响应。在下一节中，我将更多地讨论这实际上是如何发生的，但要知道这里查询的信息是从配置空间生成的。\n因此，让我们分解一些重要的东西：\nDevObj：指向 nt！_DEVICE_OBJECT 结构的指针，该结构表示内核中的物理设备。 Vendor ID：注册给特定设备制造商的 16 位 ID 号。此值是标准化的，PCI-SIG 必须为新供应商分配一个唯一 ID，以便它们不会重叠。在本例中，我们看到这是 NVIDIA 显卡。 Device ID：执行 PCIe 的特定芯片的 16 位 ID 号。类似的想法是，公司必须为其芯片请求一个唯一的 ID，这样它就不会与任何其他芯片冲突。 Subsystem Vendor ID：芯片所在电路板的供应商 ID。在这种情况下，“HP”是显卡的生产商，而“NVIDIA”设计了图形芯片。 Subsystem Device ID：芯片所在电路板的设备 ID。 Logical Device Power State：此设备的电源状态。PCI 中有两种主要的电源状态，D0 = 设备已通电，D3 = 设备处于低功耗状态或完全关闭。 Requirements：设备要求 OS 为其分配的内存要求。稍后会详细介绍。 Resources：操作系统分配给此设备的内存资源。此设备已打开电源并启动，因此已为其分配了资源。 Interrupt Requirement/Resource：与上述相同，但是对于中断则不同。 要实际获取有关此设备的完整信息，我们可以使用 PCI Lookup 中的出色工具来查询有关在 PCI-SIG 中注册的 PCI 设备的公共信息。让我们将有关设备和 Vendor ID 的信息放入框中：\n\u003c!DOCTYPE html\u003e Responsive Image 当我们搜索时，我们得到这个：\n\u003c!DOCTYPE html\u003e Responsive Image 这告诉我们该设备是 NVIDIA 创建的 Quadro K620 显卡。子系统 ID 告诉我们，这个特定的卡 PCB 是由 HP 生产的，该公司已获得 NVIDIA 的许可。\n我们在 ！devext 中看到的很好地概述了 pci.sys 在摘要中特别关心向我们展示的内容，但它只触及了配置空间中所有信息的皮毛。要将所有信息转储到配置空间中，我们可以使用扩展名 ！pci 100 B D F，其中 BDF 是我们相关设备的 BDF。100 是一组标志，指定我们要转储有关设备的所有信息。显示的信息将按照它在设备的 config space 中存在的顺序进行布局。每个部分的前缀是一个偏移量，例如 02 表示 Device ID。这指定了从中读取此值的 config 空间的偏移量。这些偏移量在 PCI 规范中进行了详细说明，并且不会出于向后兼容性目的在 PCI 版本之间更改。\n8: kd\u0026gt; !pci 100 2 0 0 PCI Configuration Space (Segment:0000 Bus:02 Device:00 Function:00) Common Header: 00: VendorID 10de Nvidia Corporation 02: DeviceID 13bb 04: Command 0507 IOSpaceEn MemSpaceEn BusInitiate SERREn InterruptDis 06: Status 0010 CapList 08: RevisionID a2 09: ProgIF 00 VGA 0a: SubClass 00 VGA Compatible Controller 0b: BaseClass 03 Display Controller 0c: CacheLineSize 0000 0d: LatencyTimer 00 0e: HeaderType 80 0f: BIST 00 10: BAR0 f2000000 14: BAR1 e000000c 18: BAR2 00000000 1c: BAR3 f000000c 20: BAR4 00000000 24: BAR5 00001001 28: CBCISPtr 00000000 2c: SubSysVenID 103c 2e: SubSysID 1098 30: ROMBAR 00000000 34: CapPtr 60 3c: IntLine 00 3d: IntPin 01 3e: MinGnt 00 3f: MaxLat 00 Device Private: 40: 1098103c 00000000 00000000 00000000 50: 00000000 00000001 0023d6ce 00000000 60: 00036801 00000008 00817805 fee001f8 70: 00000000 00000000 00120010 012c8de1 80: 00003930 00453d02 11010140 00000000 90: 00000000 00000000 00000000 00040013 a0: 00000000 00000006 00000002 00000000 b0: 00000000 01140009 00000000 00000000 c0: 00000000 00000000 00000000 00000000 d0: 00000000 00000000 00000000 00000000 e0: 00000000 00000000 00000000 00000000 f0: 00000000 00000000 00000000 00000000 Capabilities: 60: CapID 01 PwrMgmt Capability 61: NextPtr 68 62: PwrMgmtCap 0003 Version=3 64: PwrMgmtCtrl 0008 DataScale:0 DataSel:0 D0 68: CapID 05 MSI Capability 69: NextPtr 78 6a: MsgCtrl 64BitCapable MSIEnable MultipleMsgEnable:0 (0x1) MultipleMsgCapable:0 (0x1) 6c: MsgAddrLow fee001f8 70: MsgAddrHi 0 74: MsgData 0 78: CapID 10 PCI Express Capability 79: NextPtr 00 7a: Express Caps 0012 (ver. 2) Type:LegacyEP 7c: Device Caps 012c8de1 80: Device Control 3930 bcre/flr MRR:1K NS ap pf ET MP:256 RO ur fe nf ce 82: Device Status 0000 tp ap ur fe nf ce 84: Link Caps 00453d02 88: Link Control 0140 es CC rl ld RCB:64 ASPM:None 8a: Link Status 1101 SCC lt lte NLW:x16 LS:2.5 9c: DeviceCaps2 00040013 CTR:3 CTDIS arifwd aor aoc32 aoc64 cas128 noro ltr TPH:0 OBFF:1 extfmt eetlp EETLPMax:0 a0: DeviceControl2 0000 CTVal:0 ctdis arifwd aor aoeb idoreq idocom ltr OBFF:0 eetlp Enhanced Capabilities: 100: CapID 0002 Virtual Channel Capability Version 1 NextPtr 258 0104: Port VC Capability 1 00000000 0108: Port VC Capability 2 00000000 010c: Port VC Control 0000 010e: Port VC Status 0000 0110: VC Resource[0] Cap 00000000 0114: VC Resource[0] Control 800000ff 011a: VC Resource[0] Status 0000 258: CapID 001e L1 PM SS Capability Version 1 NextPtr 128 25c: Capabilities 0028ff1f PTPOV:5 PTPOS:0 PCMRT:255 L1PMS ASPML11 ASPML12 PCIPML11 PCIPML12 260: Control1 00000000 LTRL12TS:0 LTRL12TV:0 CMRT:0 aspml11 aspml12 pcipml11 pcipml12 264: Control2 00000028 TPOV:5 TPOS:0 128: CapID 0004 Power Budgeting Capability Version 1 NextPtr 600 600: CapID 000b Vendor Specific Capability Version 1 NextPtr 000 Vendor Specific ID 0001 - Ver. 1 Length: 024 这个视图的好处是，我们可以看到有关配置空间的 Capabilities 部分的详细信息。Capabilities 是 config 空间中的一组结构，它准确描述了 device 能够实现的功能。Capabilities 包括链接速度和设备支持的中断类型等信息。PCI 规范中添加的任何新功能都将通过这些结构进行公布，这些结构在配置空间中形成了一个功能链表，可以迭代以发现设备的所有功能。并非所有这些功能都与操作系统相关，有些功能仅与本文未涵盖的硬件方面相关。现在，我不会详细介绍该设备的功能。\nPCIe：一切都与内存相关 现在我们已经研究了几个设备和 PCI 总线的层次结构，让我们谈谈与软件和 PCI 设备的通信实际上是如何运作的。当我第一次学习 PCI 时，我很难理解当软件与 PCI 设备连接时到底发生了什么。因为整个事务对作为软件开发人员的你来说是抽象出来的，所以很难仅通过从调试工具中探入 PCI 内存来构建所发生的事情的心智模型。希望这篇文章能提供比我刚开始时所能得到的更好的概述。\n首先，我要做一个大胆的声明：所有现代 PCIe 通信都是通过内存读写完成的。如果你了解 PCIe 中的内存如何工作，你就会了解 PCIe 软件通信的工作原理。（是的，在某些平台上还有其他传统的通信方式，但我们不会讨论这些方式，因为它们已被弃用）。\n现在，让我们谈谈现代平台上不同类型的内存。在启动的早期，操作系统的 CPU 将使用虚拟内存。也就是说，CPU 看到的内存地址是映射到物理内存世界的内存视图。\n就我们的目的而言，系统上有两种类型的物理内存：\nRAM - 读取或写入时从计算机上的 DRAM DIMM 存储和检索的地址。这就是大多数人在想到“内存”时所想到的。 Device Memory（设备内存） - 在读取或写入时与系统上的设备“对话”的地址。这里的关键词是“对话”。它不会在设备上存储内存，也不会检索设备上的内存（尽管设备可能同时能够同时检索两者）。你可能正在与之通信的地址甚至可能根本不是内存，而是一个更抽象的“device register” ，用于配置设备的内部工作。这种访问会发生什么取决于设备。你所做的只是与设备通信。你通常会看到这称为 MMIO，它全称是 Memory-Mapped I/O。 注意：每当设备不响应设备内存区域中访问的地址时，PCI 的设备内存将始终读取“全 1”或“所有 FF”。这是了解设备何时实际响应的便捷方法。如果你看到所有 FF，则表示你正在读取无效的设备地址。\n初学者认为所有物理内存都是 RAM，这是错误的。当软件与 PCI 区域中的 PCI 设备通信时，它不会从 RAM 读取和写入数据。相反，该设备从 RC 接收一个数据包（TLP，传输层数据包），当 PCI 区域内的地址被读/写时，你的 CPU 会立即自动生成该数据包。你无需在软件中创建这些数据包，所有这些数据包都是在访问此内存后立即完全在后台生成的。在软件中，你甚至无法查看或捕获这些数据包，而需要一个特殊的硬件测试设备来拦截和查看正在发送的数据包。稍后会详细介绍。\n如果有帮助，请将物理内存视为设备的映射。RAM 是为你映射到物理内存中的设备。PCI 还会自动为你映射区域。尽管它们截然不同且行为也非常不同，但它们在软件中看起来是相同的。\n在下图中，我们可以看到典型系统如何将虚拟内存映射到物理内存。请注意，有两个 RAM 区域和两个 PCI 内存区域。这是因为某些较旧的 PCI 设备只能寻址 32 位内存。因此，如果你的 RAM 不适合 4GB 以下的地址窗口，则一些 RAM 会上移到 4GB 以上。由于你的处理器支持 64 位地址，因此这不是问题。此外，在 4GB 行上方为支持 64 位地址的 PCI 设备创建第二个窗口。由于 4GB 区域可能非常有限，因此设备最好在 4GB 以上移动尽可能多的内存，以免弄乱下面的空间。\n\u003c!DOCTYPE html\u003e Responsive Image 首先，让我们来谈谈我们已经见过存储器：配置空间（Configuration Space）。\n配置空间位于一个名为 ECAM（Extended Configuration Access Management，扩展配置访问管理）的内存部分。因为它是一种设备内存，所以要从内核（使用虚拟内存）访问这段内存，内核必须请求内存管理器将这部分物理内存映射到一个虚拟地址上。然后，软件指令可以使用映射的虚拟地址来从物理地址读取和写入。在 Windows 上，定位和映射这段内存的工作部分由pci.sys处理，部分由acpi.sys处理，还有部分由内核（具体来说是 HAL）处理。\n注意：通常，在 Windows 中映射设备内存的方式是通过 MmMapIoSpaceEx，这是驱动程序可用于映射物理设备内存的 API。但是，为了进行配置空间访问，软件必须使用 HalGetBusDataByOffset 和 HalSetBusDataByOffset 来确保 pci.sys 的内部状态与你正在执行的配置空间读/写保持同步。如果你尝试自己映射和更改配置空间，则可能会使 pci.sys 状态不同步并导致蓝屏死机。\n注意：ECAM/PCI 区域在物理内存中的位置取决于平台。引导时的固件将分配系统物理内存的所有特殊区域。然后，固件会在引导期间向操作系统公布这些区域的位置。在 x86-64 系统上，ECAM 区域将使用称为 MCFG 的表（结构）通过 ACPI 从固件进行通信。现在知道使用什么特定协议来检索此信息不是很重要吗，只需了解操作系统从固件中检索这些区域的地址，固件决定了将它们放在哪里。\n因此，为了进行配置空间访问，内核必须将配置空间（ECAM）映射到虚拟内存。这是这样的事情会是什么样子：\n\u003c!DOCTYPE html\u003e Responsive Image 在此之后，内核现在可以使用虚拟映射与设备的配置空间进行通信。但是这个配置空间是什么样的呢？嗯，它只是我们上面讨论的一堆配置空间结构块。设备可能具有的每个可能的 BDF 都在 ECAM 中提供了空间来对其进行配置。它的布局方式是，设备的 BDF 会告诉你其配置空间在 ECAM 中的确切位置。也就是说，给定一个 BDF，我们可以计算要添加到 ECAM 区域基数的偏移量，以便与设备通信，因为每个功能的所有 ECAM 区域的大小都相同。\n\u003c!DOCTYPE html\u003e Responsive Image 从这张图中，我们可以开始看到 PCIe 的枚举实际上是如何发生的。当我们读回有效的配置空间数据时，我们知道该 BDF 上存在设备。如果我们改为读回 FF，我们知道设备不在该插槽或功能中。当然，我们不会为了枚举所有设备而暴力破解每个地址，因为由于 MMIO 的开销，代价比较大。但是，这种蛮力的高级版本是我们如何快速枚举所有已通电并在配置空间上响应我们的设备。\n把它们放在一起 - 软件配置空间访问 现在我们了解了如何访问配置空间，我们可以将两端（层次结构和 MMIO）放在一起，以查看从内核模式读取配置空间的指令的完整路径。\n\u003c!DOCTYPE html\u003e Responsive Image 让我们逐步完成此处采用的整个路径（从左到右）：\n在内核模式下运行的某些代码从 ECAM 虚拟映射中读取偏移量。 虚拟映射由 CPU 的页表转换为 ECAM 中的物理地址。 读取物理地址，导致内部 CPU 互连中发生操作，以通知RC访问。 RC将请求的数据包化版本生成为 TLP，该 TLP 显示“读取设备 02:00.0 的偏移量 0x0 处的值”，并通过层次结构发送该请求。 TLP 由总线 2 上的此显示控制器接收，并看到它是一个配置空间 TLP。现在，它知道使用包含偏移量 0x0 处的值内容的配置空间响应 TLP 进行响应。 现在让我们看看响应：\n\u003c!DOCTYPE html\u003e Responsive Image 响应路径没那么有趣了。设备以含有偏移 0 处的值（我们知道这是供应商 ID）的特殊 TLP 进行响应。这个数据包找到回到请求者（即RC），然后互连通知 CPU 更新 rax 的值为 0x10DE，这是 NVIDIA 显卡的供应商 ID。然后，CPU 开始执行下一条指令。\n如你所想那样，通过这种方式进行访问可能比通过全部的 TLP 生成的 RAM 慢很多。这确实是事实，并且这也是存在比这种 MMIO 方法更多的方式去与设备通信的主要原因之一。在接下来的文章中，我将详细介绍另一种方法，即 DMA，以及它对于确保软件能够尽可能快地在 CPU 和设备之间传输内存的至关重要性。\n练习：通过 WinDbg 手动访问 ECAM 我们看了一下 config space access 理论上是如何发生的，但让我们自己用 debugger 做同样的事情。为此，我们希望：\n找到 ECAM 在系统上的位置。 计算到 ECAM 的偏移量以读取设备的供应商 ID。为此，我选择了 NVIDIA 显卡上的Multimedia Device @ 02:00.1 在该地址执行物理内存读取以检索值。 第一步是找到 ECAM。鉴于 ECAM 的位置来自 ACPI，特别是 ACPI 中的 MCFG 表，这部分有点棘手。这是 firmware 用来告诉操作系统 ECAM 在系统的物理内存映射中的位置的表。关于 ACPI 以及如何将其与 PCI 结合使用，有很多内容要讨论，但现在，我将快速跳到相关部分以实现我们的目标。\n在我们的调试器中，我们可以通过使用!acpicache来转储所有 ACPI 表的缓存副本。要转储 MCFG，请点击链接 MCFG 来转储其内容，或手动键入!acpitable MCFG：\n8: kd\u0026gt; !acpicache Dumping cached ACPI tables... XSDT @(fffff7b6c0004018) Rev: 0x1 Len: 0x0000bc TableID: SLIC-WKS MCFG @(fffff7b6c0005018) Rev: 0x1 Len: 0x00003c TableID: SLIC-WKS FACP @(fffff7b6c0007018) Rev: 0x4 Len: 0x0000f4 TableID: SLIC-WKS APIC @(fffff7b6c0008018) Rev: 0x2 Len: 0x000afc TableID: SLIC-WKS DMAR @(fffff7b6c000a018) Rev: 0x1 Len: 0x0000c0 TableID: SLIC-WKS HPET @(fffff7b6c015a018) Rev: 0x1 Len: 0x000038 TableID: SLIC-WKS TCPA @(ffffdc89b07209f8) Rev: 0x2 Len: 0x000064 TableID: EDK2 SSDT @(ffffdc89b0720a88) Rev: 0x2 Len: 0x0003b3 TableID: Tpm2Tabl TPM2 @(ffffdc89b0720e68) Rev: 0x3 Len: 0x000034 TableID: EDK2 SSDT @(ffffdc89b07fc018) Rev: 0x1 Len: 0x0013a1 TableID: Plat_Wmi UEFI @(ffffdc89b07fd3e8) Rev: 0x1 Len: 0x000042 TableID: BDAT @(ffffdc89b07fd458) Rev: 0x1 Len: 0x000030 TableID: SLIC-WKS MSDM @(ffffdc89b07fd4b8) Rev: 0x3 Len: 0x000055 TableID: SLIC-WKS SLIC @(ffffdc89b07fd538) Rev: 0x1 Len: 0x000176 TableID: SLIC-WKS WSMT @(ffffdc89b07fd6d8) Rev: 0x1 Len: 0x000028 TableID: SLIC-WKS WDDT @(ffffdc89b0721a68) Rev: 0x1 Len: 0x000040 TableID: SLIC-WKS SSDT @(ffffdc89b2580018) Rev: 0x2 Len: 0x086372 TableID: SSDT PM NITR @(ffffdc89b26063b8) Rev: 0x2 Len: 0x000071 TableID: SLIC-WKS ASF! @(ffffdc89b2606548) Rev: 0x20 Len: 0x000074 TableID: HCG BGRT @(ffffdc89b26065e8) Rev: 0x1 Len: 0x000038 TableID: TIANO DSDT @(ffffdc89b0e94018) Rev: 0x2 Len: 0x021c89 TableID: SLIC-WKS 8: kd\u0026gt; !acpitable MCFG HEADER - fffff7b6c0005018 Signature: MCFG Length: 0x0000003c Revision: 0x01 Checksum: 0x3c OEMID: HPQOEM OEMTableID: SLIC-WKS OEMRevision: 0x00000001 CreatorID: INTL CreatorRev: 0x20091013 BODY - fffff7b6c000503c fffff7b6`c000503c 00 00 00 00 00 00 00 00-00 00 00 d0 00 00 00 00 ................ fffff7b6`c000504c 00 00 00 ff 00 00 00 00 ........ 要了解如何阅读此表，遗憾的是，我们需要查看 ACPI 规范。与其让你这样做，不如省去你的痛苦，把相关部分拉到这里：\n\u003c!DOCTYPE html\u003e Responsive Image 由于 ！acpitable 命令已经解析并显示此表中 Creator Revision 之前的所有内容，因此 BODY 的前 8 个字节将是偏移量 36 处的 8 个字节的 Reserved 内存。因此，我们跳过这 8 个字节并找到以下结构：\n\u003c!DOCTYPE html\u003e Responsive Image 此字节的前 8 个字节是 Reserved 后面的区域的 ECAM 区域的地址。这意味着 ECAM 基址的偏移量为偏移量 8。\nBODY - fffff7b6c000503c fffff7b6`c000503c 00 00 00 00 00 00 00 00-00 00 00 d0 00 00 00 00 ................ fffff7b6`c000504c 00 00 00 ff 00 00 00 00 ........ 对于这个系统，ECAM 位于地址：0xD0000000。（请别忘了以小端序来读取这个地址）\n为了验证我们得到了正确的地址，让我们读取00:00.0的供应商 ID，这也是 ECAM 的前两个字节。我们将使用!dw命令来完成这个操作，该命令代表的dump physical word（感叹号代表物理）。这个命令要求你指定一个缓存类型，在我们的情况下，总是使用[uc]或者说未缓存。它还提供了一个长度，这是由 L1 指定要读取的 word 的数量。\n注意：请务必始终将目标设备内存的大小与我们从软件中读取的大小相匹配。这意味着，如果我们要读取的值是 16 位值（如供应商 ID），则必须执行 16 位读取。执行 32 位读取可能会更改设备响应的结果。对于配置空间，我们可以读取供应商 ID 的更大大小，但并非在所有情况下都是如此。最好养成将读取大小与目标大小匹配的习惯，以避免任何意外结果。请记住：设备内存不是 RAM。\n综上所述，我们读取 00：00.0 的 VendorID，如下所示：\n8: kd\u0026gt; !dw [uc] D0000000 L1 #d0000000 8086 我们读取的结果值为 0x8086，它恰好是 Intel 的供应商 ID。为了验证这是正确的，让我们使用 ！pci 转储相同的内容。\n8: kd\u0026gt; !pci 100 0 0 0 PCI Configuration Space (Segment:0000 Bus:00 Device:00 Function:00) Common Header: 00: VendorID 8086 Intel Corporation 从特定函数读取 VendorID 现在要计算我们希望与之通信的另一个函数（02：00.1 的 NVIDIA 卡）的 ECAM 地址，我们需要通过使用目标函数的 BDF 和一些位数学计算到 ECAM 的偏移量来手动执行“数组访问”。\n计算方法存在于 PCIe 规范中，该规范为总线、器件和函数分配了一定数量的 ECAM 位来计算偏移量：\n| 27 - 20 | 19 - 15 | 14 - 12 | 11 - 0 | | Bus Nr | Dev Nr | Function Nr | Register | 通过填写 BDF 并根据每个元素的位位置对结果进行移位和 OR 运算，我们可以计算出要添加到 ECAM 的偏移量。\n我将使用 python，但你可以使用任何你想要的计算器：\n\u0026gt;\u0026gt;\u0026gt; hex(0xD0000000 + ((2 \u0026lt;\u0026lt; 20) | (0 \u0026lt;\u0026lt; 15) | (1 \u0026lt;\u0026lt; 12))) \u0026#39;0xd0201000\u0026#39; 这意味着 02：00.1 的 ECAM 区域位于 0xD0201000。\n现在，要从函数中读取 VendorID 的值：\n8: kd\u0026gt; !dw [uc] D0201000 L1 #d0201000 10de 结果是 0x10de，我们从上面知道它是 NVIDIA Corporation！这意味着我们成功地从 ECAM 中读取了此函数的第一个值。\n总结 这篇帖子最终比我预期的要长得多！我不会继续这篇文章，而是将其拆分并随着时间的推移充实该系列。关于 PCIe，我想介绍的主题太多了，但空闲时间却很少，但在下一篇文章中，我将更详细地介绍设备 BAR（一种特定于设备的 MMIO 形式）和 DMA（直接内存访问）。本系列将继续使用与以前相同的租户，更侧重于理解而不是具体细节。\n希望你喜欢这个对 PCIe 世界的小小了解！期待更多精彩。\n单击此处查看第 2 部分！\n","permalink":"https://lifeislife.cn/posts/%E8%AF%91%E6%96%87-pcie-part1/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文翻译自：\u003ca href=\"https://ctf.re/windows/kernel/pcie/tutorial/2023/02/14/pcie-part-1/\"\u003e面向 Windows 初学者的 PCIe 实用教程（第 1 部分）– 灵魂的逆向工程 \u0026mdash; A Practical Tutorial on PCIe for Total Beginners on Windows (Part 1) – Reversing Engineering for the Soul\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eHello！我最近一直在与一些朋友和同事交谈，他们有兴趣了解更多关于 PCIe 的信息，但对复杂性或缺乏适合初学者的简单资源感到害怕。我最近经常使用 PCIe，觉得可能值得以博客文章的形式分享我的一些经验。\u003c/p\u003e","title":"PCIe Part 1 - 面向 Windows 初学者的 PCIe 实用教程"},{"content":"同步 Strava 数据 GearAutomator 是一个可以生成 Strava 运动热图和天气卡片的工具，访问 GearAutomator，点击的Connect with Strava按钮，然后输入 Strava 的用户名和密码登录。\n根据运动数据量不同，生成时间会有所不同，请勿关闭页面，等待生成完成。Strava的API限制很严格，同步数据很慢，连接上Strava之后，建议干其他事情，等待数据同步完成，不用频繁刷新页面。我第一次同步数据不知道花了多久一直没有显示热图，以为这个工具失效了，后来某一天再次访问，发现热图已经生成了。\n查看热图 Zwift虚拟骑行也会使用真实的GPX数据，所以在热力地图中也能看到有轨迹，虚拟骑行会用紫色轨迹表示，真实骑行会用绿色轨迹表示。图中紫色轨迹就是巴黎香街冲刺。绿色轨迹是一次路骑。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 配置天气卡片 Strava 订阅用户可以生成每次运动的天气卡片，可以在运动简介中看到这次运动时的天气情况，如图所示：\n没有订阅的用户也可以通过这个工具来生成，在天气配置页面，开启即可：\n\u003c!DOCTYPE html\u003e Responsive Image 当下次有新的数据同步到Strava时，会自动在标题下面生成天气信息，如图所示：\n\u003c!DOCTYPE html\u003e Responsive Image 如果你想自定义天气卡片的样式，可以在天气卡片配置页面进行设置，比如将英文转换为中文：\n\u003c!DOCTYPE html\u003e Responsive Image 你可以直接复制下面的文本，替换即可：\n温度: ${temperature} 体感温度: ${apparentTemperature} 天气状况: ${skyCon} 湿度: ${humidity} 气压: ${pressure} 云量: ${cloudRate} 风速: ${windSpeed} 能见度: ${visibility} 空气质量: 空气质量指数(AQI): ${aqi} 细颗粒物(PM2.5): ${pm25} 可吸入颗粒物(PM10): ${pm10} 臭氧(O3): ${o3} 二氧化硫(SO2): ${so2} 二氧化氮(NO2): ${no2} 一氧化碳(CO): ${co} 紫外线强度(UV): ${uv} 地面接收的太阳辐射(DSWRF): ${dswrf} 温度: ${startTemperature} - ${endTemperature} 体感温度: ${startApparentTemperature} - ${endApparentTemperature} 天气状况: ${startSkyCon} - ${endSkyCon} 湿度: ${startHumidity} - ${endHumidity} 气压: ${startPressure} - ${endPressure} 云量: ${startCloudRate} - ${endCloudRate} 风速: ${startWindSpeed} - ${endWindSpeed} 能见度: ${startVisibility} - ${endVisibility} 空气质量: 空气质量指数(AQI): ${startAqi} - ${endAqi} 细颗粒物(PM2.5): ${startPM25} - ${endPM25} 可吸入颗粒物(PM10): ${startPM10} - ${endPM10} 臭氧(O3): ${startO3} - ${endO3} 二氧化硫(SO2): ${startSO2} - ${endSO2} 二氧化氮(NO2): ${startNO2} - ${endNO2} 一氧化碳(CO): ${startCO} - ${endCO} 紫外线强度(UV): ${startUV} - ${endUV} 地面接收的太阳辐射(DSWRF): ${startDswrf} - ${endDswrf} ","permalink":"https://lifeislife.cn/posts/gearautomator%E7%94%9F%E6%88%90strava%E8%BF%90%E5%8A%A8%E7%83%AD%E5%9B%BE%E5%92%8C%E5%A4%A9%E6%B0%94%E5%8D%A1%E7%89%87/","summary":"\u003ch1 id=\"同步-strava-数据\"\u003e同步 Strava 数据\u003c/h1\u003e\n\u003cp\u003eGearAutomator 是一个可以生成 Strava 运动热图和天气卡片的工具，访问 \u003ca href=\"https://www.gearaut.com\"\u003eGearAutomator\u003c/a\u003e，点击的\u003ccode\u003eConnect with Strava\u003c/code\u003e按钮，然后输入 Strava 的用户名和密码登录。\u003c/p\u003e\n\u003cp\u003e根据运动数据量不同，生成时间会有所不同，请勿关闭页面，等待生成完成。Strava的API限制很严格，同步数据很慢，连接上Strava之后，建议干其他事情，等待数据同步完成，不用频繁刷新页面。我第一次同步数据不知道花了多久一直没有显示热图，以为这个工具失效了，后来某一天再次访问，发现热图已经生成了。\u003c/p\u003e","title":"GearAutomator生成Strava运动热图和天气卡片"},{"content":"想了解如何提供 API，我们先看看 CMN 模块是如何使用 API 的，在文件module/cmn700/src/mod_cmn700.c我们可以看到如下代码：\n// module/cmn700/src/mod_cmn700.c static struct mod_system_info_get_info_api *system_info_api; int cmn700_start(fwk_id_t id) { ... status = system_info_api-\u0026gt;get_system_info(\u0026amp;system_info); if (status == FWK_SUCCESS) { chip_id = system_info-\u0026gt;chip_id; multi_chip_mode = system_info-\u0026gt;multi_chip_mode; } ... } 他调用了system_info_api-\u0026gt;get_system_info这个函数，实际这就是 mod_system_info 暴露给 mod_cmn700 的一个 API。用于获取系统信息。\n为何这个静态变量system_info_api就能调用到mod_system_info的函数呢？我们继续搜索代码，可以看到如下代码：\n// module/cmn700/src/mod_cmn700.c static int cmn700_bind(fwk_id_t id, unsigned int round) { ... if (fwk_id_is_type(id, FWK_ID_TYPE_MODULE)) { /* Bind to system info module to obtain multi-chip info */ status = fwk_module_bind( FWK_ID_MODULE(FWK_MODULE_IDX_SYSTEM_INFO), FWK_ID_API(FWK_MODULE_IDX_SYSTEM_INFO, MOD_SYSTEM_INFO_GET_API_IDX), \u0026amp;system_info_api); return status; } ... } 在cmn700_bind函数中，调用了fwk_module_bind函数，这个函数的作用是绑定一个模块的 API，这样就可以通过这个 API 调用模块的函数。fwk_module_bind函数的第一个参数是提供 API 的模块的 ID，比如当前是模块system_info的 ID，如果是要用 USB 的 API，那么就是 USB 模块的 ID。第二个参数是 API 的 ID，这个 ID 是在模块的头文件中定义的，比如mod_system_info.h中定义了MOD_SYSTEM_INFO_GET_API_IDX，这个宏定义的值就是 API 的 ID。第三个参数是 API 的指针，这个指针就是开头提到的静态变量的地址，它是定义在使用 API 的模块中的。这样就可以通过 API 的指针调用模块的函数。对于 USB 模块，我们就需要在使用到 USB 的模块中定义一个静态变量。\nfwk_module_bind做了什么呢？进入该函数，可以看到它回调了mod_system_info的process_bind_request函数，也就是system_info_process_bind_request函数。\n// framework/src/fwk_module.c int fwk_module_bind(fwk_id_t target_id, fwk_id_t api_id, const void *api) { ... status = fwk_mod_ctx-\u0026gt;desc-\u0026gt;process_bind_request( fwk_module_ctx.bind_id, target_id, api_id, (const void **)api); ... } system_info_process_bind_request函数的作用是根据 API 的 ID 返回 API 的指针。它把get_system_info_api的地址赋值给了api。这就实现了 API 的暴露。经过这个函数，system_info_api就指向了get_system_info_api。实际就是我们在cmn700_bind函数中使用system_info_api就是在调用get_system_info_api。\n// module/system_info/src/mod_system_info.c static int system_info_process_bind_request(fwk_id_t requester_id, fwk_id_t targer_id, fwk_id_t api_id, const void **api) { switch (fwk_id_get_api_idx(api_id)) { case MOD_SYSTEM_INFO_GET_API_IDX: *api = \u0026amp;get_system_info_api; break; default: return FWK_E_PARAM; } return FWK_SUCCESS; } 解释完这个 bind 函数，它是在哪被调用的？它在框架初始化时就会被调用，分析fwk_arch_init函数，可以看到在fwk_module_start函数中会对每一个模块调用bind函数。函数调用流程参考图片文件。在此就不再赘述了。\n经过以上分析，提供 API 的模块需要做的事情就是：\n在模块的头文件中定义 API 的 ID，它有一定的格式，具体可以参考 MSCP 文档doc/framework.md的APIs章节。\nenum mod_modulename_api { MOD_MODULENAME_API_A, MOD_MODULENAME_API_B, }; 在模块的源文件中定义 API 结构体，用于在其他模块中使用。\nstruct mod_system_info_get_info_api { int (*get_system_info)(const struct mod_system_info **sys_info); }; 在模块原文件中提供process_bind_request函数，用于根据 API 的 ID 返回 API 的指针。\nstatic int system_info_process_bind_request(fwk_id_t requester_id, fwk_id_t targer_id, fwk_id_t api_id, const void **api) { switch (fwk_id_get_api_idx(api_id)) { case MOD_SYSTEM_INFO_GET_API_IDX: *api = \u0026amp;get_system_info_api; break; default: return FWK_E_PARAM; } return FWK_SUCCESS; } 在模块的源文件中定义 API 的指针，用于提供 API 的地址。\nstatic struct mod_system_info_get_info_api get_system_info_api = { .get_system_info = system_info_get_system_info, }; 实现需要提供的 API 函数。\nstatic int system_info_get_system_info(const struct mod_system_info **sys_info) { *sys_info = \u0026amp;system_info; return FWK_SUCCESS; } 以上就是大致的移植流程了。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/scp-firmware%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-module%E9%97%B4api%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/","summary":"\u003cp\u003e想了解如何提供 API，我们先看看 CMN 模块是如何使用 API 的，在文件\u003ccode\u003emodule/cmn700/src/mod_cmn700.c\u003c/code\u003e我们可以看到如下代码：\u003c/p\u003e","title":"SCP-firmware 源码分析-module 间 api 调用分析"},{"content":"推荐一个开源工具，Elevate for Strava，可以为 Strava 提供丰富的数据分析功能，帮助骑行爱好者和运动员更好地了解自己的运动表现。目前有Web插件、Windows APP和MacOS APP。开发者表示未来主要是提供应用软件，插件开发可能投入会减少，如果想要更快更全面体验软件功能，推荐使用Windows APP或MacOS APP。因为Web插件使用更加方便，所以我就以Web插件为例进行介绍。\n安装工具 以下是简单的安装步骤，App版本可以前往Elevate for Strava的github主页Release页面下载。\n安装扩展程序\n用户可以通过 Chrome 或 Firefox 浏览器的扩展商店搜索“Elevate for Strava”，然后点击“安装”按钮。如果你是Chrome用户，可以点击此链接直达。其他浏览器可以访问官网查看。 同步 Strava 数据\n安装完成后，用户需要登录他们的 Strava 账户，并授权 Elevate 访问其运动数据。之后，Elevate 将自动同步 Strava 数据，并开始生成各种分析报告。 \u003c!DOCTYPE html\u003e Responsive Image 配置和使用\n用户可以根据自己的需求调整 Elevate 的设置，包括单位、分析参数等选项。 使用介绍 第一次导入成功后先别着急查看数据，先配置一下个人信息，参考下图。切记基本信息和Strava保持一致，不然重新导入真的很费时间，因为Strava接口请求有限制，你可以在Strava申请导出所有数据为文件，这样会快很多，后面再详细介绍。\n\u003c!DOCTYPE html\u003e Responsive Image 查看活动汇总\n\u003c!DOCTYPE html\u003e Responsive Image 设置年度目标，计算目标进度\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 你是不是也想知道自己关注的大佬功率是多少？嘿嘿，Elevate会根据大佬公开的数据，预估一个功率和工体比。以下就是范二特的一次骑行数据。\n\u003c!DOCTYPE html\u003e Responsive Image More Data！点击橙色的按钮，可以显示更多的数据信息，当然这些信息对于普通骑行者作用不大。对于业余车手可以通过这些数据来学习一下职业车手的骑行习惯。比如功率分配，踏频分配等等。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/elevate-for-strava%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E6%9B%B4%E5%85%A8%E9%9D%A2%E7%9A%84%E9%AA%91%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","summary":"\u003cp\u003e推荐一个开源工具，\u003ca href=\"https://github.com/thomaschampagne/elevate\"\u003eElevate for Strava\u003c/a\u003e，可以为 Strava 提供丰富的数据分析功能，帮助骑行爱好者和运动员更好地了解自己的运动表现。目前有Web插件、Windows APP和MacOS APP。开发者表示未来主要是提供应用软件，插件开发可能投入会减少，如果想要更快更全面体验软件功能，推荐使用Windows APP或MacOS APP。因为Web插件使用更加方便，所以我就以Web插件为例进行介绍。\u003c/p\u003e","title":"Elevate for Strava浏览器插件更全面的骑行数据分析"},{"content":"QEMU 在 decode 指令的时候，需要调用各平台所定义的 instruction decoders 来解析指令。如在 ARM 平台下，就定义了：disas_arm_insn()、disas_thumb_insn() 及 disas_thumb2_insn() 等来分别负责 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。\n而 Decodetree 则是由 Bastian Koppelmann 于 2017 年在 移植 RISC-V QEMU 的时候所提出来的机制 (详见：讨论邮件1、讨论邮件2)。提出该机制主要是因为过往的 instruction decoders (如：ARM) 都是采用一堆 switch-case 来做判断。不仅难阅读，也难以维护。\n因此 Bastian Koppelmann 就提出了 Decodetree 的机制，开发者只需要通过 Decodetree 的语法定义各个指令的格式，便可交由 Decodetree 来动态生成对应包含 switch-case 的 instruction decoder .c 文档。\nDecodetree 特别适合像 RISC-V 这种具有固定指令格式的 ISA。\n因为各字段都在固定的位置，(如 RISC-V 的 opcode 都是固定在 bits[6..0] 的位置)。 \u003c!DOCTYPE html\u003e Responsive Image Decodetree 其实是由 Python script (./scripts/decodetree.py) 所生成的。使用文档可以参考：./docs/devel/decodetree.rst，里面有详细定义了其语法的格式。QEMU 在编译时，会调用 Decodetree，根据各平台所定义的 decode 文档，动态生成对应的 decoder。\n如 RISC-V 的 instruction decoders 就是被定义在：./target/riscv/*.decode 中。其 Makefile.obj 就有如下的声明：\n... DECODETREE = $(SRC_PATH)/scripts/decodetree.py decode32-y = $(SRC_PATH)/target/riscv/insn32.decode decode32-$(TARGET_RISCV64) += $(SRC_PATH)/target/riscv/insn32-64.decode ... target/riscv/decode_insn32.inc.c: $(decode32-y) $(DECODETREE) $(call quiet-command, \\ $(PYTHON) $(DECODETREE) -o $@ --static-decode decode_insn32 \\ $(decode32-y), \u0026#34;GEN\u0026#34;, $(TARGET_DIR)$@) Decodetree 的语法共分为：Fields、Argument Sets、Formats、Patterns 五部分。本文将介绍如何通过 Decodetree 的语法，来动态生成一个指令的 decoder。\nField Field 定义如何取出一指令中，各字段 (eg: rd, rs1, rs2, imm) 的值。\nfield_def := \u0026#39;%\u0026#39; identifier ( unnamed_field )* ( !function=identifier )? unnamed_field := number \u0026#39;:\u0026#39; ( \u0026#39;s\u0026#39; ) number 其语法由 % 开头，随后紧接着一个 identifier 及零个或多个 unamed_field，并可再加上可选的 !function。\nidentifier 可由开发者自定，如：rd、imm… 等。 unamed_field 定义了该字段的所在比特。第一个数字定义了该字段的 least-significant bit position，第二个数字则定义了该字段的比特长度。另外可加上可选的 s 字符来标明在取出该字段后，是否需要做 符号扩展。 Eg：%rd 7:5 代表 rd 占了指令中 bits 7 ~ bits 11 的位置 (insn[11:7])，共 5 bits。 !function 定义在截取出该字段的值后，所会再调用的 function。 Field (32-bits 指令) 最后会生成对应的 extract32() 及 sextract32() 代码，以用来取得指令中各字段的值：\nField 示例 Input Generated code %disp 0:s16 sextract(i, 0, 16) %imm9 16:6 10:3 extract(i, 16, 6) \u0026laquo; 3 %disp12 0:s1 1:1 2:10 sextract(i, 0, 1) \u0026laquo; 11 %shimm8 5:s8 13:1 !function=expand_shimm8 expand_shimm8(sextract(i, 5, 8)) \u0026laquo; 1 以 RISC-V 的 U-type 指令为例：\n\u003c!DOCTYPE html\u003e Responsive Image 其中，imm 占 insn[31:12]，共20位，rd 占 insn[11:7]，且 imm 需要做 符号扩展 后 左移 12 位 (20-bit immediate is shifted left by 12 bits to form U immediates)。因此，如果我们要定义 RISC-V 的 U-type 指令，则可以声明成：\n%rd 7:5 %imm_u 12:s20 !function=ex_shift_12 20 表示占 20 bits\n最后会生成如下的代码：\nstatic void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn) { a-\u0026gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u0026gt;rd = extract32(insn, 7, 5); } static void decode_insn32_extract_u() 是由下文 Format 定义所生成的，而 arg_u *a 则是由 Argument Set 定义所生成的，将会在后面的部分再做说明。\n可以看到：\na-\u0026gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u0026gt;rd = extract32(insn, 7, 5); a-\u0026gt;imm 是由 insn[31:12] 所取得并做符号扩展，且会再调用 ex_shift_12() 来 左移 12 个 bits。\nP.S. RISC-V 的 ex_shift_12() 是通过定义在./target/riscv/translate.c 中 EX_SH 这个 macro 所展开的：\n#define EX_SH(amount) \\ static int ex_shift_##amount(DisasContext *ctx, int imm) \\ { \\ return imm \u0026lt;\u0026lt; amount; \\ } EX_SH(1) EX_SH(2) EX_SH(3) EX_SH(4) EX_SH(12) a-\u0026gt;rd 是由 insn[11:7] 所取得。\n此外，在 Decodetree 的 spec 中也有提到，我们可以通过只定义 !function 来直接调用该 function。在这种情况下，只有 DisasContext 会被传入该 function。\n如 ARM Thumb ./target/arm/t16.decode 就有定义：\n# Set S if the instruction is outside of an IT block. %s !function=t16_setflags static void disas_t16_extract_addsub_2i(DisasContext *ctx, arg_s_rri_rot *a, uint16_t insn) { a-\u0026gt;imm = extract32(insn, 6, 3); a-\u0026gt;rn = extract32(insn, 3, 3); a-\u0026gt;rd = extract32(insn, 0, 3); a-\u0026gt;s = t16_setflags(ctx); a-\u0026gt;rot = 0; } 请注意，未包含任何 unnamed_fields 或 !function 的 Field 会被视为错误。\nArgument Set Argument Set 定义用来保存从指令中所截取出来各字段的值。\nargs_def := \u0026#39;\u0026amp;\u0026#39; identifier ( args_elt )+ ( !extern )? args_elt := identifier 其语法由 \u0026amp; 开头，随后紧接着一个或多个的 identifier ，并可再加上可选的 !extern 。\nidentifier 可由开发者自订，如：regs、loadstore… 等。 !extern 则表示是否在其他地方已经由其他的 decoder 定义过。如果有该字段，就不会再次生成对应的 argument set struct。 Argument Set 示例 例1：\n\u0026amp;ampreg3 ra rb rc 会生成以下的 argument set struct：\ntypedef struct { int ra; int rb; int rc; } arg_reg3; 例2：\n\u0026amp;loadstore reg base offset 则会生成以下的 argument set struct：\ntypedef struct { int base; int offset; int reg; } arg_loadstore; 因此，以刚刚的 RISC-V U-type 指令为例，我们需要从指令中截取 imm 及 rd 字段的值，可以声明其 argument set 如下：\n\u0026amp;u imm rd 最后会生成以下的 argument set struct：\ntypedef struct { int imm; int rd; } arg_u; 此 argument set struct 会被传入由 Format 定义所生成的 extract function：\nstatic void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn) { a-\u0026gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u0026gt;rd = extract32(insn, 7, 5); } 所传入的arg_u 会保存从指令中截取出的 imm 及 rd 字段的值，待后续使用。\nFormat Format 定义了指令的格式 (如 RISC-V 中的 R、I、S、B、U、J-type)，并会生成对应的 decode function。\nfmt_def := \u0026#39;@\u0026#39; identifier ( fmt_elt )+ fmt_elt := fixedbit_elt | field_elt | field_ref | args_ref fixedbit_elt := [01.-]+ field_elt := identifier \u0026#39;:\u0026#39; \u0026#39;s\u0026#39;? number field_ref := \u0026#39;%\u0026#39; identifier | identifier \u0026#39;=\u0026#39; \u0026#39;%\u0026#39; identifier args_ref := \u0026#39;\u0026amp;\u0026#39; identifier 其语法由 @ 开头，随后紧接着一个 identifier 及一个以上的 fmt_elt。\nidentifier 可由开发者自订，如：opr、opi… 等。\nfmt_elt 则可以采用以下不同的语法：\nfixedbit_elt 包含一个或多个 0、1、.、-，每一个代表指令中的 1 个 bit。\n. 代表该 bit 可以用 0 或是 1 来表示。 - 代表该 bit 完全被忽略。 field_elt 可以用 Field 的语法来声明。\nEg：ra:5、rb:5、lit:8 field_ref 有下列两种格式 (以下范例参考上文所定义之 Field)：\n'%' identifier：直接参考一个被定义过的 Field。\n如：%rd，会生成：\na-\u0026gt;rd = extract32(insn, 7, 5); identifier '=' '%' identifier：直接参考一个被定义过的 Field，但通过第一个 identifier 来重命名其所对应的 argument 名称。此方式可以用来指定不同的 argument 名称来参考至同一个 Field。\n如：my_rd=%rd，会生成：\na-\u0026gt;my_rd = extract32(insn, 7, 5); args_ref 指定所传入 decode function 的 Argument Set。若没有指定 args_ref 的话，Decodetree 会根据 field_elt 或 field_ref 自动生成一个 Argument Set。此外，一个 Format 最多只能包含一个 args_ref。\n当 fixedbit_elt 或 field_ref 被定义时，该 Foramt 的所有的 bits 都必须被定义 (可通过 fixedbit_elt 或 . 来定义各个 bits，空格会被忽略)。\nFormat 示例 @opi ...... ra:5 lit:8 1 ....... rc:5 定义了 op1 这个 Format，其中：\ninsn[31:26] 可为 0 或 1。 insn[25:21] 为 ra。 insn[20:13] 为 lit。 insn[12] 固定为 1。 insn[11:5] 可为 0 或 1。 insn[4:0] 为 rc。 此 Format 会生成以下的 decode function：\ntypedef struct { int lit; int ra; int rc; } arg_decode_insn320; static void decode_insn32_extract_opi(DisasContext *ctx, arg_decode_insn320 *a, uint32_t insn) { a-\u0026gt;ra = extract32(insn, 21, 5); a-\u0026gt;lit = extract32(insn, 13, 8); a-\u0026gt;rc = extract32(insn, 0, 5); } 由于我们没有指定 args_ref，因此 Decodetree 根据了 field_elt 的定义，自动生成了 arg_decode_insn320 这个 Argument Set。\n以 RISC-V I-type 指令为例：\n# Fields: %rs1 15:5 %rd 7:5 # immediates: %imm_i 20:s12 # Argment sets: \u0026amp;i imm rs1 rd @i ........ ........ ........ ........ \u0026amp;i imm=%imm_i %rs1 %rd 定义了 i 这个 Format，其中：\ninsn[31:20] 为 imm，且为 符号扩展。 insn[19:5] 为 rs1。 insn[11:7] 为 rd。 此外，我们可以看到：\n此 Format 指定了 Argument Set：\u0026amp;i。 \u0026amp;i 中必须包含所有有用到的 arguments (也就是：imm、rs1 及 rd) imm 是通过重命名的方式来参考 %imm_i 这个 Field。 此范例会生成以下的 decode function：\ntypedef struct { int imm; int rd; int rs1; } arg_i; static void decode_insn32extract_i(DisasContext *ctx, arg_i *a, uint32_t insn) { a-\u0026gt;imm = sextract32(insn, 20, 12); a-\u0026gt;rs1 = extract32(insn, 15, 5); a-\u0026gt;rd = extract32(insn, 7, 5); } 相比于第一个范例，由于这次我们有指定 args_ref：\u0026amp;i，因此对应的 arg_i 会被传入 decode function。\n回到先前的 RISC-V U-type 指令，我们可以如同 I-type 指令定义其格式：\n# Fields: %rd 7:5 # immediates: %imm_u 12:s20 !function=ex_shift_12 # Argument sets: \u0026amp;u imm rd @u .................... ..... ....... \u0026amp;u imm=%imm_u %rd 定义了 u 这个 Format，其中：\ninsn[31:12] 为 imm，且为 符号扩展。 insn[11:7] 为 rd。 会生成以下的 decode function：\ntypedef struct { int imm; int rd; } arg_u; static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn) { a-\u0026gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u0026gt;rd = extract32(insn, 7, 5); } 我们可以看到：\n此 Format 指定了 Argument Set：\u0026amp;u。 \u0026amp;u 中必须包含所有有用到的 arguments (也就是：imm、rd) imm 是通过重命名的方式来参考 %imm_u 这个 Field。 Pattern Pattern 实际定义了一个指令的 decode 方式。Decodetree 会根据 Patterns 的定义，来动态产生出对应的 switch-case decode 判断分支。\npat_def := identifier ( pat_elt )+ pat_elt := fixedbit_elt | field_elt | field_ref | args_ref | fmt_ref | const_elt fmt_ref := \u0026#39;@\u0026#39; identifier const_elt := identifier \u0026#39;=\u0026#39; number 其语法由用户所定义的 identifier，随后紧接着一个以上的 pat_elt。\nidentifier 可由开发者自订，如：addl_r、addli … 等。\npat_elt 则可以采用以下不同的语法：\nfixedbit_elt 与在 Format 中 fixedbit_elt 的定义相同。 field_elt 与在 Format 中 field_elt 的定义相同。 field_ref 与在 Format 中 field_ref 的定义相同。 args_ref 与在 Format 中 args_ref 的定义相同。 fmt_ref 直接参考一个被定义过的Format。 const_elt 可以直接指定某一个 argument 的值。 由于 Pattern 实际定义了一个指令的 decode 方式，因此所有的 bits 及 arguments (如果有参考 args_ref 的话) 都必须明确的被定义，如果在搭配了所有的 pat_elt 后还有未定义的 bits 或是 arguments 的话，Decodetree 便会报错。\n此外，Pattern 所产生出来的 decoder，最后还会调用对应的 translator function。translator function 需开发者自行定义。\nPattern 示例 addl_i 010000 ..... ..... .... 0000000 ..... @opi 定义了 addl_i 这个指令的 Pattern，其中：\ninsn[31:26] 为 010000。 insn[11:5] 为 0000000。 参考了 Format 示例中 定义的 @opi Format。 由于 Pattern 的所有 bits 都必须明确的被定义，因此 @opi 必须包含其余 insn[25:12] 及 insn[4:0] 的格式定义，否则 Decodetree 便会报错。 最后 addl_i 的 decoder 还会调用 trans_addl_i() 这个 translator function。\n搭配之前介绍的 Fields、Argument Sets 及 Formats，让我们再看几个完整的例子应该会更清楚 Decodetree 是怎产生一个指令的 decoder 的。\n首先是 RISC-V 的 lui 及 auipc 指令：\n\u003c!DOCTYPE html\u003e Responsive Image # Fields: %rd 7:5 # immediates: %imm_u 12:s20 !function=ex_shift_12 # Argument sets: \u0026amp;u imm rd # Formats: @u .................... ..... ....... \u0026amp;u imm=%imm_u %rd # Patterns lui .................... ..... 0110111 @u auipc .................... ..... 0010111 @u 会产生以下 lui 及 auipc 的 decoder：\ntypedef struct { int imm; int rd; } arg_u; static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn) { a-\u0026gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u0026gt;rd = extract32(insn, 7, 5); } static bool decode_insn32(DisasContext *ctx, uint32_t insn) { union { arg_u f_u; } u; decode_insn32_extract_u(ctx, \u0026amp;u.f_u, insn); switch (insn \u0026amp; 0x0000007f) { case 0x00000017: if (trans_auipc(ctx, \u0026amp;u.f_u)) return true; return false; case 0x00000037: if (trans_lui(ctx, \u0026amp;u.f_u)) return true; return false; } return false; } 回顾到目前为止所介绍的：\nArgument Sets：\u0026amp;u 这个 argument set 包含了 imm 及 rd 这两个 arguments。\ntypedef struct { int imm; int rd; } arg_u; Fields： imm 及 rd 分别位在 insn[31:12] 及 insn[11:7]，且 imm 为 符号扩展。最后在截取出 imm 的值后，还会调用 ex_shift_12()。\na-\u0026gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u0026gt;rd = extract32(insn, 7, 5); Formats：@u 定义了 RISC-V U-type 指令的格式\n参考了 \u0026amp;u 这个 Argument Set，因此 decode function 会传入 arg_u 作为参数。 insn[31:12] 参考了 imm_u 这个 Field (并重命名为 imm) insn[11:7] 参考了 rd 这个 Field。 static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn) { a-\u0026gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u0026gt;rd = extract32(insn, 7, 5); } Patterns：\nlui 的 opcode (insn[6:0]) 为 0010111，也就是 0x17，在产生出来的 switch-case 中可以看到其对应的 case。 lui 的 decoder 最后调用了 trans_lui()，并传入 DisasContext 及经由 decode_insn32_extract_u() 所解析出来的 arg_u。 auipc 的 opcode (insn[6:0]) 为 0110111，也就是 0x37，在产生出来的 switch-case 中可以看到其对应的 case。 auipc 的 decoder 最后调用了 trans_auipc()，并传入 DisasContext 及经由 decode_insn32_extract_u() 所解析出来的 arg_u。 P.S. 这边由于 Decodetree 发现 lui 及 auipc 可以共用 decode_insn32_extract_u()，因此将其提到了 switch-case 之外。 static bool decode_insn32(DisasContext *ctx, uint32_t insn) { union { arg_u f_u; } u; decode_insn32_extract_u(ctx, \u0026amp;u.f_u, insn); switch (insn \u0026amp; 0x0000007f) { case 0x00000017: if (trans_auipc(ctx, \u0026amp;u.f_u)) return true; return false; case 0x00000037: if (trans_lui(ctx, \u0026amp;u.f_u)) return true; return false; } return false; } 我们另外可以发现，Pattern + Format 把所有的 32-bits 都给了明确的定义：\nPattern 定义了 opcode (insn[6:0])。 Format 参考了 imm (insn[31:12]) 及 rd (insn[11:7])。 如果有任何未明确定义的 bits 的话，Decodetree 便会报错，例如如果我们将 lui 的 opcode 最高 2 个 bits (insn[6:5]) 由 01 改成 ..：\nlui .................... ..... ..10111 @u Decodetree 在解析时，便会报错：\n./insn32.decode:17: error: (‘bits left unspecified (0x00000060)’,)\nDecodetree 提醒我们，insn[6:5] (0x00000060) 尚未给出明确定义，并会显示出其错误的行数。\ntrans_lui() 和 trans_auipc() 被定义在 target/riscv/insn_trans/trans_rvi.inc.c：\nstatic bool trans_lui(DisasContext *ctx, arg_lui *a) { if (a-\u0026gt;rd != 0) { tcg_gen_movi_tl(cpu_gpr[a-\u0026gt;rd], a-\u0026gt;imm); } return true; } static bool trans_auipc(DisasContext *ctx, arg_auipc *a) { if (a-\u0026gt;rd != 0) { tcg_gen_movi_tl(cpu_gpr[a-\u0026gt;rd], a-\u0026gt;imm + ctx-\u0026gt;base.pc_next); } return true; } 可以看到 trans_*() 负责实际指令的业务逻辑及产生对应的 TCG codes。\n如同先前所介绍，Patterns 的 pat_elt 也可以采用 field_elt 语法，如 RISC-V 的 fence 指令：\nfence ---- pred:4 succ:4 ----- 000 ----- 0001111 insn[27:24] 为 pred。 insn[23:20] 为 succ。 insn[14:12] 固定为 000。 insn[6:0] 为 opcode (0001111)。 没有参考任何的 Format。 剩下的 insn[31:28]、insn[19:15]、insn[11:7] 被声明为 -，因此就算没有被明确定义也没有关系。 所生成 fence 的 decoder 如下：\ntypedef struct { int pred; int succ; } arg_decode_insn320; static void decode_insn32_extract_decode_insn32_Fmt_0(DisasContext *ctx, arg_decode_insn320 *a, uint32_t insn) { a-\u0026gt;pred = extract32(insn, 24, 4); a-\u0026gt;succ = extract32(insn, 20, 4); } static bool decode_insn32(DisasContext *ctx, uint32_t insn) { union { arg_decode_insn320 f_decode_insn320; } u; decode_insn32_extract_decode_insn32_Fmt_0(ctx, \u0026amp;u.f_decode_insn320, insn); switch (insn \u0026amp; 0x0000707f) { case 0x0000000f: if (trans_fence(ctx, \u0026amp;u.f_decode_insn320)) return true; return false; } return false; } 值得注意的是，虽然这次我们没有参考任何的 Argument Set，但 Decodetree 还是替我们生成了一个包含 pred 和 succ 的 arg_decode_insn320 。\ntrans_fence() 同样是被定义在 ./target/riscv/insn_trans/trans_rvi.inc.c：\nstatic bool trans_fence(DisasContext *ctx, arg_fence *a) { tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC); return true; } Pattern Groups Pattern Groups 由一个以上的 Patterns 所组成，其主要差别是不同 Patterns 之间的 bits 可以 overlap。当同组中有多个 Patterns 时，会依据该组中各 Pattern 的声明顺序依序判断目前的指令是否符合其定义。除此之外，当符合的 Pattern 其 trans_*() 回传值为 false 时，也会被视为不相符，而继续判断该组中的下一个 Pattern。因此 Pattern Groups 非常适合将多个相似格式的指令给组成同一个 Pattern Group。\ngroup := \u0026#39;{\u0026#39; ( pat_def | group )+ \u0026#39;}\u0026#39; 各 Pattern Group 以 { 开头，并以 } 结尾，且允许 nested pattern groups 的存在，其他语法皆与 Pattern 相同。\nPattern Group 示例 { { nop 000010 ----- ----- 0000 001001 0 00000 copy 000010 00000 r1:5 0000 001001 0 rt:5 } or 000010 rt2:5 r1:5 cf:4 001001 0 rt:5 } 会产生以下的 decoder：\nswitch (insn \u0026amp; 0xfc000fe0) { case 0x08000240: if ((insn \u0026amp; 0x0000f000) == 0x00000000) { if ((insn \u0026amp; 0x0000001f) == 0x00000000) { extract_decode_Fmt_0(\u0026amp;u.f_decode0, insn); if (trans_nop(ctx, \u0026amp;u.f_decode0)) return true; } if ((insn \u0026amp; 0x03e00000) == 0x00000000) { extract_decode_Fmt_1(\u0026amp;u.f_decode1, insn); if (trans_copy(ctx, \u0026amp;u.f_decode1)) return true; } } extract_decode_Fmt_2(\u0026amp;u.f_decode2, insn); if (trans_or(ctx, \u0026amp;u.f_decode2)) return true; return false; } 当指令的值符合 nop 及 copy 这个内层 Pattern Group 时，会先判断该指令是否符合 nop 指令的定义，且 trans_nop() 的回传值为 true。否则的话，就会继续判断是否符合同组中的 copy 指令。若都不符，就会再判断是否符合外层 Pattern Group 的 or 指令。若仍不符，才会回传 false 表示 decode 失败。\n与单纯使用 Pattern 最大不同的是，当一 Pattern 的 trans_*() 回传值为 false 时，不会直接回传 false (代表 decode 失败)，而是会接续着判断后续的 Patterns 是否相符。\nRISC-V Compressed-Extension 中的 c.ebreak、c.jalr、及 c.add 指令，由于这三个指令的格式非常相似，因此非常适合使用 Pattern Group 来定义：\nRISC-V spec. 中定义：\n\u003c!DOCTYPE html\u003e Responsive Image C.EBREAK指令与C.ADD指令共享相同的opcode，但是rd和rs2都为zero，因此也可以使用CR格式。 C.JALR指令只有在rs1≠x0时才有效；当rs1=x0时，对应的代码点是C.EBREAK指令。 C.ADD指令只有在rs2≠x0时才有效；当rs2=x0时，对应的代码点是C.JALR和C.EBREAK指令。具有rs2̸=x0和rd=x0的代码点是HINTs。 c.ebreak、c.jalr、c.add 三个指令：\ninsn[15:13]、insn[12]、insn[1:0] 的值皆相同。 当 insn[11:7] 且 insn[6:2] 的值皆为 0 (rs1=0 且 rs2=0) 时为 c.ebreak 指令。 当只有 insn[11:7] 的值为 0 (rs1=0 且 rs2≠0) 时为 c.jalr 指令。 否则为 c.add 指令 (rs1≠x0 且 rs2≠0)。 # Fields %rd 7:5 %rs2_5 2:5 # Argument Sets \u0026amp;r rd rs1 rs2 !extern \u0026amp;i imm rs1 rd !extern # Formats @cr .... ..... ..... .. \u0026amp;r rs2=%rs2_5 rs1=%rd %rd @c_jalr ... . ..... ..... .. \u0026amp;i imm=0 rs1=%rd # Pattern Groups { ebreak 100 1 00000 00000 10 jalr 100 1 ..... 00000 10 @c_jalr rd=1 # C.JALR add 100 1 ..... ..... 10 @cr } 所生成的 decoder 如下：\nstatic void decode_insn16_extract_c_jalr(DisasContext *ctx, arg_i *a, uint16_t insn) { a-\u0026gt;imm = 0; a-\u0026gt;rs1 = extract32(insn, 7, 5); } static void decode_insn16_extract_cr(DisasContext *ctx, arg_r *a, uint16_t insn) { a-\u0026gt;rs2 = extract32(insn, 2, 5); a-\u0026gt;rs1 = extract32(insn, 7, 5); a-\u0026gt;rd = extract32(insn, 7, 5); } static void decode_insn16_extract_decode_insn16_Fmt_2(DisasContext *ctx, arg_decode_insn162 *a, uint16_t insn) {} static bool decode_insn16(DisasContext *ctx, uint16_t insn) { union { arg_decode_insn162 f_decode_insn162; arg_i f_i; arg_r f_r; } u; switch (insn \u0026amp; 0x0000f003) { case 0x00009002: if ((insn \u0026amp; 0x00000ffc) == 0x00000000) { decode_insn16_extract_decode_insn16_Fmt_2(ctx, \u0026amp;u.f_decode_insn162, insn); if (trans_ebreak(ctx, \u0026amp;u.f_decode_insn162)) return true; } if ((insn \u0026amp; 0x0000007c) == 0x00000000) { decode_insn16_extract_c_jalr(ctx, \u0026amp;u.f_i, insn); u.f_i.rd = 1; if (trans_jalr(ctx, \u0026amp;u.f_i)) return true; } decode_insn16_extract_cr(ctx, \u0026amp;u.f_r, insn); if (trans_add(ctx, \u0026amp;u.f_r)) return true; return false; } return false; } 当指令格式符合 c.ebreak、c.jalr、c.add 的 Pattern Group 时，会依序判断该指令是否符合 c.ebreak、c.jalr、c.add 的定义以及其对应的 trans_*()。\n另外值得一提的是，在 c_jalr Format 和 jalr Pattern 中有分别指定其 imm 及 rd 的值为 0，所生成的 codes 也会分别在对应的地方将该值设为 0 (见 codes 注解说明)。\n总结 以上就是 Decodetree 的语法说明。通过 Decodetree，我们不用再像以前以样写一大包的 switch-case 来 decode 指令。将不同类型的指令写至不同的 decode 档，不仅方便维护，阅读起来也更为容易。\n--translate：translator function 的 prefix，默认为 trans。一旦指定后，translator function 的 scope 就不会再是 static。 --decode：decode function 的 prefix，默认为 decode，且 scope 为 static。一旦指定后，decode function 的 scope 就不会再是 static。 --static-decode：如同 --decode，不过 decode function 的 scope 仍维持为 static。 -o / --output：指定生成的 decoder .c 档路径。 -w / --insnwidth：指令长度，eg：32 or 16，默认为 32。 --varinsnwidth：指令为不定长度。 最后一个参数为输入的 decode 档路径。 运行范例：\n./decodetree.py -o target/riscv/decode_insn16.inc.c --static-decode decode_insn16 \\ -w 16 ./insn16.decode static inline int32_t sextract32(uint32_t value, int start, int length){ assert(start \u0026gt;= 0 \u0026amp;\u0026amp; length \u0026gt; 0 \u0026amp;\u0026amp; length \u0026lt;= 32 - start); return ((int32_t)(value \u0026lt;\u0026lt; (32 - length - start))) \u0026gt;\u0026gt; (32 - length);} ","permalink":"https://lifeislife.cn/posts/qemu-decodetree%E8%AF%A6%E8%A7%A3/","summary":"\u003cp\u003eQEMU 在 decode 指令的时候，需要调用各平台所定义的 instruction decoders 来解析指令。如在 ARM 平台下，就定义了：\u003ccode\u003edisas_arm_insn()\u003c/code\u003e、\u003ccode\u003edisas_thumb_insn()\u003c/code\u003e 及 \u003ccode\u003edisas_thumb2_insn()\u003c/code\u003e 等来分别负责 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。\u003c/p\u003e","title":"QEMU Decodetree详解"},{"content":"为了避免qBittorrnet在下载文件时对机械硬盘频繁读写，可以将固态硬盘作为临时下载盘，在下载完成后再将文件移动到机械硬盘。qBittorrentk可以通过简单的设置就能实现这一目的。\n首先需要将固态硬盘映射到qBittorrent的容器中。我是使用docker-compose部署的qBittorrent，所以需要在docker-compose.yml中添加一个volume：\nservices: qbittorrent: image: linuxserver/qbittorrent:latest container_name: qbittorrent restart: always ports: - 8080:8080 environment: - TZ=Asia/Shanghai volumes: - /root/sharedfolder/appdata/qbittorrent:/config - /root/sharedfolder/downloads/qbittorrent:/downloads - /srv/download-disk/downloads/qbittorrent:/download-disk 其中/root/sharedfolder/downloads/qbittorrent:/downloads是原来机械硬盘的目录，我们不需要动他。/srv/download-disk/downloads/qbittorrent:/download-disk是新的固态硬盘的目录，我在download-disk目录下新建了和之前一样的目录结构。将它映射到容器的/download-disk目录下。\n进入qBittorrent的web页面，先全选所有的任务，将任务暂停。\n点击工具-\u0026gt;选项-\u0026gt;下载，设置保存未完成的文件到固态硬盘。路径就是我们在docker-compose.yml中设置的/download-disk目录下的qbincomplete目录。\n\u003c!DOCTYPE html\u003e Responsive Image 重启qBittorrent容器，这样就设置好了。\n再次登录qBittorrent的web页面，qBittorrent会自动将之前暂停的任务都移动到固态硬盘/download-disk中。你在宿主机的/srv/download-disk/downloads/qbittorrent/qbincomplete目录下就能看到这些任务。你可以重新启动所有任务，当他们移动完成后就会继续下载。下载完成后就会自动移动到机械硬盘中。也就是你设置的默认下载位置，比如我的下载位置为/root/sharedfolder/downloads/qbittorrent/qbcomplete。\n","permalink":"https://lifeislife.cn/posts/qbittorrent%E8%AE%BE%E7%BD%AE%E5%8D%95%E7%8B%AC%E7%9A%84%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E4%BD%9C%E4%B8%BA%E4%B8%B4%E6%97%B6%E4%B8%8B%E8%BD%BD%E7%9B%98/","summary":"\u003cp\u003e为了避免qBittorrnet在下载文件时对机械硬盘频繁读写，可以将固态硬盘作为临时下载盘，在下载完成后再将文件移动到机械硬盘。qBittorrentk可以通过简单的设置就能实现这一目的。\u003c/p\u003e","title":"qBittorrent 设置单独的固态硬盘作为临时下载盘"},{"content":"用qBittorrent下载文件有些资源上传率很低，下载很慢，就会对机械硬盘频繁读写，这样会导致硬盘寿命缩短。虽然组了RAID5，但是还是希望硬盘能活得久一点吧。所以买了一块新固态专门用来下载文件，作为临时存放，等文件下载完了再整块拷贝到RAID5里。OMV本来挂载新硬盘很简单的，UI页面点点就可以了，不知道是不是因为我这块硬盘是通过PCIe转接卡接在主板上的，挂载一直报错。\nOMV\\ExecException: Failed to execute command \u0026#39;export PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin; export LANG=C.UTF-8; omv-salt deploy run --no-color fstab 2\u0026gt;\u0026amp;1\u0026#39; with exit code \u0026#39;1\u0026#39;: /usr/lib/python3/dist-packages/requests/__init__.py:91: RequestsDependencyWarning: urllib3 (1.26.18) or chardet (3.0.4) doesn\u0026#39;t match a supported version! RequestsDependencyWarning) 网上找了一圈也没找到解决办法，只好自己手动挂载了。\n首先查看新硬盘的设备名：\nlsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT nvme0n1 259:0 0 931.5G 0 disk 使用fdisk命令对硬盘进行分区：\nfdisk /dev/nvme0n1 Welcome to fdisk (util-linux 2.39.1). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. # 输入n表示新建分区 Command (m for help): n Partition type p primary (2 primary, 0 extended, 2 free) e extended (container for logical partitions) # 输入p表示主分区 Select (default p): p # 分区号直接回车使用默认的，新硬盘应该为1 Partition number (2-128, default 2): # 输入两次回车使用默认的，从第一个扇区开始，到最后一个扇区结束，即整个硬盘 # 我因为已经分区完了，所以找了以前的笔记，所以扇区号和实际的大小，你们只需要两次回车就行了 First sector (1001472-452984798, default 1001472): Last sector, +/-sectors or +/-size{K,M,G,T,P} (1001472-452984798, default 452982783): # 输入w保存退出 Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. # 分区完成了 格式化分区：\nmkfs.ext4 /dev/nvme0n1p1 mke2fs 1.44.5 (15-Dec-2018) Creating filesystem with 244189696 4k blocks and 61054976 inodes Filesystem UUID: 1b1b1b1b-1b1b-1b1b-1b1b-1b1b1b1b1b1b Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, 102400000, 214990848 创建挂载点：\n# 在NAS上创建一个目录，用来挂载新硬盘，我的硬盘都挂载在了srv目录下，所以这里也挂载在srv下 mkdir /srv/download-disk 挂载硬盘：\nmount /dev/nvme0n1p1 /srv/download-disk 查看挂载情况：\n$ df -h Filesystem Size Used Avail Use% Mounted on udev 7.6G 0 7.6G 0% /dev tmpfs 1.6G 13M 1.5G 1% /run /dev/sda1 116G 97G 14G 88% / tmpfs 7.6G 0 7.6G 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 7.6G 0 7.6G 0% /sys/fs/cgroup /dev/nvme0n1p1 916G 28K 870G 1% /srv/download-disk 为文件系统打上标签，为了能在NAS中能方便区分硬盘，我就用了硬盘的品牌和容量：\ne2label /dev/nvme0n1p1 Kingston1tb 查看标签：\n$ blkid 设置自动挂载，编辑/etc/fstab文件，每次重启后都会自动挂载：\necho \u0026#34;/dev/nvme0n1p1 /srv/download-disk ext4 defaults 0 0\u0026#34; \u0026gt;\u0026gt; /etc/fstab ","permalink":"https://lifeislife.cn/posts/linux%E6%8C%82%E8%BD%BD%E6%96%B0%E7%A1%AC%E7%9B%98/","summary":"\u003cp\u003e用qBittorrent下载文件有些资源上传率很低，下载很慢，就会对机械硬盘频繁读写，这样会导致硬盘寿命缩短。虽然组了RAID5，但是还是希望硬盘能活得久一点吧。所以买了一块新固态专门用来下载文件，作为临时存放，等文件下载完了再整块拷贝到RAID5里。OMV本来挂载新硬盘很简单的，UI页面点点就可以了，不知道是不是因为我这块硬盘是通过PCIe转接卡接在主板上的，挂载一直报错。\u003c/p\u003e","title":"Linux挂载新硬盘"},{"content":"编译源码 下载配置工具链 访问ARM 官网下载工具链下载自己系统的版本的工具链。如果你也是 x86_64 的 Linux 系统，直接点击该链接下载 arm-gnu-toolchain-13.3\n解压工具链：\nxz -d arm-gnu-toolchain-13.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz tar -xvf arm-gnu-toolchain-13.3.rel1-x86_64-aarch64-none-linux-gnu.tar 将工具链路径添加到环境变量中。\n编译源码 源码使用 CMake 进行编译，CMake 版本需要 3.18.4 以上。如果你是 Ubuntu 20.04，直接安装即可。\nsudo apt install cmake 如果你是 Ubuntu 18.04，需要升级 CMAKE。可以通过下面的方式下载源码编译安装 CMAKE。\nwget https://github.com/Kitware/CMake/releases/download/v3.22.0/cmake-3.22.0-linux-x86_64.tar.gz tar -zxvf cmake-3.22.0-linux-x86_64.tar.gz mv cmake-3.22.0-linux-x86_64 /usr/local/cmake export PATH=/usr/local/cmake/bin:$PATH 源码编译：\nmake -f Makefile.cmake PRODUCT=totalcompute/tc2 MODE=debug firmware-scp_ramfw 源码编译成功后，会在build/tc2/GNU/debug/firmware-scp_ramfw/bin目录下生成二进制文件。具体编译参数，可以参考源码根目录下的user_guide文档。\n初始化流程分析 \u003c!DOCTYPE html\u003e Responsive Image fwk_module_init 初始时，module_config_table 是在什么时候被初始化的？ module_config_table 无法在源码中直接搜索到，因为它是在编译过程中生成的，当你编译一次后，就会在 output/build/mpw/GNU/debug/firmware-scp_romfw/framework/src/fwk_module_list.c 找到这个变量。具体它是如何生成的，注意通过 framework/CMakeLists.txt 文件中的这段代码完成，我们逐行分析这段代码。\nlist(LENGTH SCP_MODULES SCP_MODULE_IDX_MAX) 获取模块列表的长度，保存在 SCP_MODULE_IDX_MAX 变量中。在每个 Firmware.cmake 文件中，都会有一个 SCP_MODULES 变量，这个变量保存了该产品所包含的模块。\n# product/juno/scp_romfw/Firmware.cmake list(APPEND SCP_MODULES \u0026#34;test\u0026#34;) list(APPEND SCP_MODULES \u0026#34;uart\u0026#34;) 当前我们加入了两个模块，所以 SCP_MODULE_IDX_MAX 的值为 2。\nforeach(idx RANGE ${SCP_MODULE_IDX_MAX}) if(idx EQUAL SCP_MODULE_IDX_MAX) string(APPEND SCP_MODULE_IDX_GEN \u0026#34; FWK_MODULE_IDX_COUNT = ${idx},\\n\u0026#34;) break() endif() 遍历模块列表，生成模块索引的定义，如下：\nenum fwk_module_idx { FWK_MODULE_IDX_COUNT = 0, }; list(GET SCP_MODULES ${idx} SCP_MODULE) 将 SCP_MODULES 列表中索引为 idx 的元素赋值给变量 SCP_MODULE，以便在后续的代码中使用。当前 idx 为 0，所以 SCP_MODULE 为 test。\nstring(MAKE_C_IDENTIFIER ${SCP_MODULE} SCP_MODULE) string(TOUPPER ${SCP_MODULE} SCP_MODULE_UPPER) 将 SCP_MODULE 转换为 C 标识符。将 SCP_MODULE 转为大写并保存在 SCP_MODULE_UPPER 中，即 SCP_MODULE_UPPER=\u0026quot;TEST\u0026quot;\nstring(APPEND SCP_MODULE_IDX_GEN \u0026#34; FWK_MODULE_IDX_${SCP_MODULE_UPPER} = ${idx},\\n\u0026#34;) string(APPEND SCP_MODULE_ID_INIT_GEN \u0026#34;#define FWK_MODULE_ID_${SCP_MODULE_UPPER}_INIT FWK_ID_MODULE_INIT(FWK_MODULE_IDX_${SCP_MODULE_UPPER})\\n\u0026#34;) string(APPEND SCP_MODULE_ID_GEN \u0026#34;#define FWK_MODULE_ID_${SCP_MODULE_UPPER} FWK_ID_MODULE(FWK_MODULE_IDX_${SCP_MODULE_UPPER})\\n\u0026#34;) string(APPEND SCP_MODULE_ID_CONST_GEN \u0026#34;static const fwk_id_t fwk_module_id_${SCP_MODULE} = FWK_MODULE_ID_${SCP_MODULE_UPPER}_INIT;\\n\u0026#34;) string(APPEND SCP_MODULE_EXTERN_GEN \u0026#34;extern const struct fwk_module module_${SCP_MODULE};\\n\u0026#34;) string(APPEND SCP_MODULE_EXTERN_CONFIG_GEN \u0026#34;extern const struct fwk_module_config config_${SCP_MODULE};\\n\u0026#34;) string(APPEND SCP_MODULE_GEN \u0026#34; \u0026amp;module_${SCP_MODULE},\\n\u0026#34;) string(APPEND SCP_MODULE_CONFIG_GEN \u0026#34; \u0026amp;config_${SCP_MODULE},\\n\u0026#34;) 进行一些宏替换，替换后的结果如下：\nSCP_MODULE_IDX_GEN: \u0026#34; FWK_MODULE_IDX_TEST = 0,\u0026#34; SCP_MODULE_ID_INIT_GEN: \u0026#34;#define FWK_MODULE_ID_TEST_INIT FWK_ID_MODULE_INIT(FWK_MODULE_IDX_TEST)\u0026#34; SCP_MODULE_ID_GEN: \u0026#34;#define FWK_MODULE_ID_TEST FWK_ID_MODULE(FWK_MODULE_IDX_TEST)\u0026#34; SCP_MODULE_ID_CONST_GEN: \u0026#34;static const fwk_id_t fwk_module_id_test = FWK_MODULE_ID_TEST_INIT;\u0026#34; SCP_MODULE_EXTERN_GEN: \u0026#34;extern const struct fwk_module module_test;\u0026#34; SCP_MODULE_EXTERN_CONFIG_GEN: \u0026#34;extern const struct fwk_module_config config_test;\u0026#34; SCP_MODULE_GEN: \u0026#34;\u0026amp;module_test,\u0026#34; SCP_MODULE_CONFIG_GEN: \u0026#34;\u0026amp;config_test,\u0026#34; target_compile_definitions(framework PUBLIC \u0026#34;BUILD_HAS_MOD_${SCP_MODULE_UPPER}=1\u0026#34;) 将 BUILD_HAS_MOD_TEST 定义为 1，以便在后续的代码中使用。\n在源码文件中有两个模板文件，分别为 fwk_module_list.c.in 和 fwk_module_idx.h.in，这两个文件中包含了一些宏定义，这些宏定义在编译过程中会被替换为上面生成的宏定义。\n#include \u0026lt;stddef.h\u0026gt; @SCP_MODULE_EXTERN_GEN@ const struct fwk_module *module_table[FWK_MODULE_IDX_COUNT] = { @SCP_MODULE_GEN@ }; @SCP_MODULE_EXTERN_CONFIG_GEN@ const struct fwk_module_config *module_config_table[FWK_MODULE_IDX_COUNT] = { @SCP_MODULE_CONFIG_GEN@ }; #include \u0026lt;fwk_id.h\u0026gt; @SCP_MODULE_ID_INIT_GEN@ @SCP_MODULE_ID_GEN@ enum fwk_module_idx { @SCP_MODULE_IDX_GEN@ }; @SCP_MODULE_ID_CONST_GEN@ 在编译过程中就会生成下面两个文件，当使用module_config_table时，就会引用这两个文件，找到对应的配置。\n// build/mpw/GNU/debug/firmware-scp_romfw/framework/include/fwk_module_idx.h #define FWK_MODULE_ID_TEST_INIT FWK_ID_MODULE_INIT(FWK_MODULE_IDX_TEST) #define FWK_MODULE_ID_UART_INIT FWK_ID_MODULE_INIT(FWK_MODULE_IDX_UART) #define FWK_MODULE_ID_TEST FWK_ID_MODULE(FWK_MODULE_IDX_TEST) #define FWK_MODULE_ID_UART FWK_ID_MODULE(FWK_MODULE_IDX_UART) enum fwk_module_idx { FWK_MODULE_IDX_TEST = 0, FWK_MODULE_IDX_UART = 1, FWK_MODULE_IDX_COUNT = 2, }; static const fwk_id_t fwk_module_id_test = FWK_MODULE_ID_TEST_INIT; static const fwk_id_t fwk_module_id_uart = FWK_MODULE_ID_UART_INIT; // build/mpw/GNU/debug/firmware-scp_romfw/framework/src/fwk_module_list.c extern const struct fwk_module module_test; extern const struct fwk_module module_uart; const struct fwk_module *module_table[FWK_MODULE_IDX_COUNT] = { \u0026amp;module_test, \u0026amp;module_uart, }; extern const struct fwk_module_config config_test; extern const struct fwk_module_config config_uart; const struct fwk_module_config *module_config_table[FWK_MODULE_IDX_COUNT] = { \u0026amp;config_test, \u0026amp;config_uart, }; 如何确定各个模块在初始化过程中的执行顺序？ 在每个产品目录 mscp/product/juno/scp_romfw/Firmware.cmake 中，都会有一个 Firmware.cmake 文件，这个文件中会包含该产品所包含的模块：\nlist(APPEND SCP_MODULES \u0026#34;juno-ppu\u0026#34;) list(APPEND SCP_MODULES \u0026#34;juno-rom\u0026#34;) list(APPEND SCP_MODULES \u0026#34;gtimer\u0026#34;) list(APPEND SCP_MODULES \u0026#34;sds\u0026#34;) list(APPEND SCP_MODULES \u0026#34;bootloader\u0026#34;) list(APPEND SCP_MODULES \u0026#34;juno-soc-clock\u0026#34;) 编译后会在 output 文件夹中生成fwk_module_idx.h文件，这个文件中会包含所有模块的索引，如下：\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/scp-firmware%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/","summary":"\u003ch2 id=\"编译源码\"\u003e编译源码\u003c/h2\u003e\n\u003ch3 id=\"下载配置工具链\"\u003e下载配置工具链\u003c/h3\u003e\n\u003cp\u003e访问\u003ca href=\"https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads\"\u003eARM 官网下载工具链\u003c/a\u003e下载自己系统的版本的工具链。如果你也是 x86_64 的 Linux 系统，直接点击\u003ca href=\"https://developer.arm.com/-/media/Files/downloads/gnu/13.3.rel1/binrel/arm-gnu-toolchain-13.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\"\u003e该链接下载 arm-gnu-toolchain-13.3\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e解压工具链：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exz -d arm-gnu-toolchain-13.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar -xvf arm-gnu-toolchain-13.3.rel1-x86_64-aarch64-none-linux-gnu.tar\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e将工具链路径添加到环境变量中。\u003c/p\u003e\n\u003ch3 id=\"编译源码-1\"\u003e编译源码\u003c/h3\u003e\n\u003cp\u003e源码使用 CMake 进行编译，CMake 版本需要 3.18.4 以上。如果你是 Ubuntu 20.04，直接安装即可。\u003c/p\u003e","title":"SCP-firmware 源码分析 - 源码编译以及模块初始化流程"},{"content":"配置页面的菜单 在config.yaml中配置menu字段，如下：\nmenu: main: - identifier: \u0026#34;archives\u0026#34; name: \u0026#34;归档\u0026#34; url: \u0026#34;/archives/\u0026#34; weight: 2 - identifier: \u0026#34;tags\u0026#34; name: \u0026#34;标签\u0026#34; url: \u0026#34;/tags/\u0026#34; weight: 3 - identifier: \u0026#34;categories\u0026#34; name: \u0026#34;分类\u0026#34; url: \u0026#34;/categories/\u0026#34; weight: 4 其中weight字段表示菜单的排序，数字越小越靠前。此时页面应该会显示这三个菜单，但是归档页面是 404，还需要在创建一个content/archives.md文件，内容如下：\n--- title: \u0026#34;Archive\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives\u0026#34; summary: \u0026#34;archives\u0026#34; --- 其中最关键的就是layout字段，指定了这个页面使用的模板，这里使用的是themes\\PaperMod\\layouts\\_default\\archives.html模板，所以我们在content/archives.md中只需要制定这个模板就行，不需要再添加其他内容，这样就能够让归档页面正常显示了。\n\u003c!DOCTYPE html\u003e Responsive Image 修改 layout 模板 我们可以直接修改主题中的文件，但是这样会导致主题更新时丢失我们的修改，所以我们可以将主题中的文件复制到layouts目录下，然后再进行修改，这样就不会丢失我们的修改了。hugo 会优先使用layouts目录下的文件。\n文章添加标签和分类 在文章的头部添加tags和categories字段，如下：\ntags: [ELF, C] categories: [C 语言入门] 文章添加封面图 在static目录下创建一个img目录，然后将图片a.jpg放到这个目录下，然后在文章的头部添加cover字段，如下：\ncover: image: img/a.jpg # 设置图片的小标题 alt: \u0026#34;图片\u0026#34; caption: \u0026#34;图片\u0026#34; \u003c!DOCTYPE html\u003e Responsive Image 点击图片显示原图 在config.yaml中添加如下配置：\nparams: cover: linkFullImages: true 设置面包屑导航 在config.yaml中添加如下配置：\nparams: showBreadCrumbs: true \u003c!DOCTYPE html\u003e Responsive Image 设置主页欢迎信息 在config.yaml中添加如下配置：\nparams: homeInfoParams: title: \u0026#34;欢迎来到我的博客\u0026#34; content: \u0026#34;这里是我的个人博客，欢迎访问。\u0026#34; \u003c!DOCTYPE html\u003e Responsive Image 主页添加社交网站信息 params: # 主页添加社交网站图标 socialIcons: - name: GitHub url: \u0026#34;https://github.com/Dunky-Z\u0026#34; \u003c!DOCTYPE html\u003e Responsive Image 添加搜索功能 添加以下配置到 config.yml 文件（上述配置文件已有，此处不用重复添加）\noutputs: home: - HTML - RSS - JSON # is necessary 在 content 文件夹中创建 search.md 并添加以下配置：\n--- title: \u0026#34;🔍 搜索\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary # url: \u0026#34;/archive\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; placeholder: \u0026#34;搜索框内的默认显示\u0026#34; --- 要使得某些特定的不被搜素到，可以在博客开头添加：\n--- searchHidden: true 更改字体 打开谷歌字体，选择自己喜欢的字体，点击 Get Font-\u0026gt;Get embed code，复制 html 和 css 两部分备用。\n\u003c!DOCTYPE html\u003e Responsive Image 将主题中的themes\\PaperMod\\layouts\\partials\\extend_head.html文件复制到博客主目录下的layout\\partials\\extend_head.html目录下，一定要保持目录结构一致，没有的目录自己创建一个。将 Html 代码粘贴到extend_head.html文件中。\n将主题中的themes\\PaperMod\\assets\\css\\extended\\blank.css文件复制到博客主目录下的assets\\css\\extended\\blank.css目录下，同样需要保持目录结构一致，将 css 代码粘贴到blank.css文件中。注意 Google Font 提供的是个 CSS 模板，有些具体的参数需要修改一下，比如尖括号里的内容是需要自己填写的。我的修改如下：\nbody{ font-family: \u0026#34;Noto Sans SC\u0026#34;, sans-serif; font-optical-sizing: auto; font-size: 1rem; line-height: 1.5; margin: 0; } 修改代码字体过程一样，需要注意的是，Google Font 可以选择多个字体，比如我选择了两种字体，一种JetBrains+Mono用于代码，一种Noto+Sans+SC用于中文，在选择第二个字体时，点击 Get embed font 默认会把html代码何必在了一起，也就是下面这样：\n\u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800\u0026amp;family=Noto+Sans+SC:wght@100..900\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; 加入 Disqus 评论 前往Disqus 官网注册账号，创建一个站点，\n\u003c!DOCTYPE html\u003e Responsive Image 然后将站点的shortname复制下来，\n\u003c!DOCTYPE html\u003e Responsive Image 然后在config.yaml中添加如下配置：\nparams: env: production comments: true services: disqus: shortname: lifeislife-1 回到 Disqus 官网，点击Create a new site，等几分钟创建完成。安装时拉到下面选择手动安装：\n\u003c!DOCTYPE html\u003e Responsive Image 把代码块复制下来：\n\u003c!DOCTYPE html\u003e Responsive Image 复制主题中的themes\\PaperMod\\layouts\\partials\\comments.html文件到博客主目录下的layouts\\partials\\comments.html目录下，然后将 Disqus 提供的代码粘贴到comments.html文件中。\n\u0026lt;div id=\u0026#34;disqus_thread\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page\u0026#39;s canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page\u0026#39;s unique identifier variable }; */ (function() { // DON\u0026#39;T EDIT BELOW THIS LINE var d = document, s = d.createElement(\u0026#39;script\u0026#39;); s.src = \u0026#39;https://lifeislife-1.disqus.com/embed.js\u0026#39;; s.setAttribute(\u0026#39;data-timestamp\u0026#39;, +new Date()); (d.head || d.body).appendChild(s); })(); \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt;Please enable JavaScript to view the \u0026lt;a href=\u0026#34;https://disqus.com/?ref_noscript\u0026#34;\u0026gt;comments powered by Disqus.\u0026lt;/a\u0026gt;\u0026lt;/noscript\u0026gt; 配置完成，刷新页面可以在博客底部看到评论框。\n\u003c!DOCTYPE html\u003e Responsive Image 配置网站的 favicon Favicon 就是网站的小图标，比如标签栏中的图标。\n\u003c!DOCTYPE html\u003e Responsive Image 准备一个喜欢的 Logo，最好为 png 格式，尺寸为 1:1，但是图片内容为圆形，圆形外面为透明的，这样才不会影响显示。\n\u003c!DOCTYPE html\u003e Responsive Image 打开Favicon Generator，选择自己的图标，点击 Generate Favicon，下载生成的文件。\n把解压的文件都放到博客主目录下的static/assets目录下。比如/static/assets/favicon.ico。\n修改配置文件config.yaml，添加如下配置：\nparams: assets: disableHLJS: true favicon: \u0026#34;/assets/favicon.ico\u0026#34; # favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; # favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; # favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; # apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; # safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; 路径中不需要加上static。\n刷新页面，可以看到网站图标已经修改。\n\u003c!DOCTYPE html\u003e Responsive Image 点击图片查看原图 博客中有一些图片比较大，无法查看原图就看不到细节，可以通过点击图片查看原图。\n修改网站根目录下的 config.yaml 文件，添加如下配置：\nparams: fancybox: true 主题目录下创建以下路径和文件/layouts/_default/_markup/render-image.html，并添加内容：\n{{if .Page.Site.Params.fancybox }} \u0026lt;div class=\u0026#34;post-img-view\u0026#34;\u0026gt; \u0026lt;a data-fancybox=\u0026#34;gallery\u0026#34; href=\u0026#34;{{ .Destination | safeURL }}\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ .Destination | safeURL }}\u0026#34; alt=\u0026#34;{{ .Text }}\u0026#34; {{ with .Title}} title=\u0026#34;{{ . }}\u0026#34;{{ end }} /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 主题 layouts/partials 目录下的 head.html 或者 footer.html 中添加以下代码：\n{{if .Page.Site.Params.fancybox }} \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} 图片居中，设置显示大小 修改之前/layouts/_default/_markup/render-image.html中的代码，在img标签上添加style=\u0026quot;display: block; margin: 0 auto; width: 60%;\u0026quot;。\ndisplay: block - 使图片变为块级元素，这样 margin: 0 auto 才会生效。 margin: 0 auto - 将图片水平居中。 width: 60% - 将图片宽度设置为原图的 60%。避免原图太大占用页面空间。 {{ if .Page.Site.Params.fancybox }} \u0026lt;div class=\u0026#34;post-img-view\u0026#34;\u0026gt; \u0026lt;a data-fancybox=\u0026#34;gallery\u0026#34; href=\u0026#34;{{ .Destination | safeURL }}\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ .Destination | safeURL }}\u0026#34; alt=\u0026#34;{{ .Text }}\u0026#34; {{ with .Title}} title=\u0026#34;{{ . }}\u0026#34;{{ end }} style=\u0026#34;display: block; margin: 0 auto; width: 60%;\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 根据屏幕大小自适应图片高度 修改之前/layouts/_default/_markup/render-image.html中的代码，加入JS脚本，根据屏幕大小自适应图片高度。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Responsive Image\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .post-img-view { text-align: center; } .responsive-image { display: block; margin: 0 auto; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{ if .Page.Site.Params.fancybox }} \u0026lt;div class=\u0026#34;post-img-view\u0026#34;\u0026gt; \u0026lt;a data-fancybox=\u0026#34;gallery\u0026#34; href=\u0026#34;{{ .Destination | safeURL }}\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;responsive-image\u0026#34; src=\u0026#34;{{ .Destination | safeURL }}\u0026#34; alt=\u0026#34;{{ .Text }}\u0026#34; {{ with .Title}} title=\u0026#34;{{ . }}\u0026#34;{{ end }} style=\u0026#34;margin: 0 auto;\u0026#34;/\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { var images = document.querySelectorAll(\u0026#34;.responsive-image\u0026#34;); var maxHeight = window.innerHeight / 3; images.forEach(function(image) { image.style.maxHeight = maxHeight + \u0026#34;px\u0026#34;; }); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下，不用担心一张图片铺满整个屏幕了。\n\u003c!DOCTYPE html\u003e Responsive Image 加入哔哩哔哩视频 {{ \u0026lt; douban src=\u0026#34;https://book.douban.com/subject/30838038/\u0026#34; \u0026gt; }} # 使用的时候把去掉尖括弧外侧空格，此处是为了防止被识别生效 ","permalink":"https://lifeislife.cn/posts/hugo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","summary":"\u003ch2 id=\"配置页面的菜单\"\u003e配置页面的菜单\u003c/h2\u003e\n\u003cp\u003e在\u003ccode\u003econfig.yaml\u003c/code\u003e中配置\u003ccode\u003emenu\u003c/code\u003e字段，如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003emenu\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e- \u003cspan class=\"nt\"\u003eidentifier\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;archives\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;归档\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003eurl\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;/archives/\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003eweight\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"m\"\u003e2\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e- \u003cspan class=\"nt\"\u003eidentifier\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;tags\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;标签\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003eurl\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;/tags/\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003eweight\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"m\"\u003e3\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e- \u003cspan class=\"nt\"\u003eidentifier\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;categories\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;分类\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003eurl\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;/categories/\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003eweight\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"m\"\u003e4\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其中\u003ccode\u003eweight\u003c/code\u003e字段表示菜单的排序，数字越小越靠前。此时页面应该会显示这三个菜单，但是归档页面是 404，还需要在创建一个\u003ccode\u003econtent/archives.md\u003c/code\u003e文件，内容如下：\u003c/p\u003e","title":"Hugo 主题配置"},{"content":"VSCode 插件发布简易流程 注册微软开发者账号 如果已经有微软账号，直接登录即可，如果没有，需要注册一个微软账号。登录：https://login.live.com/。\n登录https://aka.ms/SignupAzureDevOps，注册微软开发者账号。设置保存默认即可，自己设置也行，不太重要。\n右上角创建Personal Access Token，用于登录vsce。\n\u003c!DOCTYPE html\u003e Responsive Image 创建的Token名随意，但是Organization和Scopes需要选择正确的，否则会报错。\nOrganization：All accessible organizations Scopes：Full access \u003c!DOCTYPE html\u003e Responsive Image 创建成功后，会生成一个Token，需要保存好，后续会用到。Token只会显示一次，如果忘记了，需要重新创建。\n注册VSCode Publisher 登录：https://aka.ms/vscode-create-publisher，填写姓名即可如“Dominic Zhang”，会自动生成一个唯一的ID，ID只能是数字字母下划线，所以会生成“DominicZhang”。需要记住这个ID，后续会用到。\nvsce登录并发布插件 输入在注册微软开发者账号时生成的Token，登录vsce。\nvsce login DominicZhang WARNING Failed to open credential store. Falling back to storing secrets clear-text in: /home/nic/.vsce https://marketplace.visualstudio.com/manage/publishers/ Personal Access Token for publisher \u0026#39;DominicZhang\u0026#39;: **************************************************** The Personal Access Token verification succeeded for the publisher \u0026#39;DominicZhang\u0026#39;. 打包插件：\nvsce package 发布插件：\nvsce publish ","permalink":"https://lifeislife.cn/posts/vscode-%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E7%AE%80%E6%98%93%E6%B5%81%E7%A8%8B/","summary":"\u003ch1 id=\"vscode-插件发布简易流程\"\u003eVSCode 插件发布简易流程\u003c/h1\u003e\n\u003ch2 id=\"注册微软开发者账号\"\u003e注册微软开发者账号\u003c/h2\u003e\n\u003cp\u003e如果已经有微软账号，直接登录即可，如果没有，需要注册一个微软账号。登录：https://login.live.com/。\u003c/p\u003e\n\u003cp\u003e登录https://aka.ms/SignupAzureDevOps，注册微软开发者账号。设置保存默认即可，自己设置也行，不太重要。\u003c/p\u003e","title":"VSCode 插件发布简易流程"},{"content":"配置Windows与开发板网络通信 配置Windows侧网卡 将Windows与开发板通过USB网卡连接，开发板的网卡插口选择eth0，也就是靠近拨码开关的网口。开发板开机，Windows的设备管理器中出现以下网卡表示网卡功能正常。\n\u003c!DOCTYPE html\u003e Responsive Image 打开网络和共享中心，选择更改适配器设置，找到USB网卡，右键属性，选择Internet协议版本4（TCP/IPv4），点击属性，选择使用以下IP地址，设置IP地址为以下内容：\nIP地址：192.168.1.111 子网掩码：255.255.225.0 默认网关：192.168.1.1 网卡的IP要和你Window主机自己的IP在一个网段，不能盲目设置为手册里的192.168.5.10，这样会导致Windows主机无法访问开发板。可以通过在Windows命令行输入ipconfig查看Windows主机的IP地址。一般来说，如果没有设置过路由器，默认都是在192.168.1.x网段。那么网关通常就是这个网段的第一个地址，也就是192.168.1.1，这也是路由器的地址。\n如果你配置完网卡以及开发板的IP后能正常相互ping通，那么说明网络配置成功。如果你很不巧和我一样，USB网卡一直无法通过DHCP自动获取IP地址，并且配置完静态IP后只能单侧ping通，那么也可以和我一样将USB网卡和主机的WIFI网卡桥接，这样就可以实现双向通信。这里有个前提条件就是你的主机原先就有两张网卡，一张用于连接路由器，一张是WIFI网卡。不能直接将USB网卡和连接路由器的网卡桥接。\n万万没想到一张整年闲置的WIFI网卡竟然派上了用场。\n选择WIFI网卡和USB网卡，右键桥接，这样就创建一个网桥，网桥会自动获取IP地址。\n\u003c!DOCTYPE html\u003e Responsive Image 开发板侧配置网卡 配置网卡IP，这个IP也是需要和Windows主机在一个网段的。因为路由器分配IP时会从小到大分配，为了避免和已有的设备IP冲突，我们就可以设置一个比较大的IP，比如112。\n# 配置网卡ip为192.169.1.112，子网掩码为255.255.255.0 ifconfig eth0 192.168.1.112 设置默认网关：\nip route add default via 192.168.1.1 注意：更换网口需要重启开发板\n[Match] Name=eth0 [Network] Address=192.168.1.112/24 Gateway=192.168.1.1 挂载NSF共享目录 Windows侧配置 安装haneWIN NFS 服务器（https://pan.baidu.com/s/1y2R2aJyEExnCJ7FRqdaNdA 提取码：esdw）\n安装路径一般为：C:\\Program Files (x86)\\nfsd。使用VScode打开该目录下的exports文件，修改内容如下，保存时需要用管理员身份保存： d:\\nfs -public 192.168.1.112 d:\\nfs：共享目录为D盘的nfs，可以根据自己的实际情况修改。 -public：表示共享目录为公共目录，即所有用户都可以访问。 IP：为开发板的IP地址，表示要与这个IP进行共享。 关闭防火墙或者开启必要的通信端口\n如果为了省事，可以直接关闭Windows防火墙 如果不想关防火墙需要开启以下端口的通信： TCP 111 UDP 111 TCP 2049 UDP 2049 TCP 1058 UDP 1058 开启端口的方法为：控制面板 -\u0026gt; 系统和安全 -\u0026gt; Windows Defender 防火墙 -\u0026gt; 高级设置 -\u0026gt; 入站规则 -\u0026gt; 新建规则 -\u0026gt; 端口 -\u0026gt; 下一步 -\u0026gt; TCP -\u0026gt; 特定本地端口 -\u0026gt; 2049 -\u0026gt; 下一步 -\u0026gt; 允许连接 -\u0026gt; 下一步 -\u0026gt; 下一步 -\u0026gt; 规则名称 -\u0026gt; 完成。 需要注意在出站规则和入站规则都需要添加。 重启Windows NFS Server服务\n右键Windows徽标键，打开计算机管理，找到服务和应用程序，点击服务，找到NFS Server，右键重启。 \u003c!DOCTYPE html\u003e Responsive Image 点击软件的输出选项卡，点击重启服务器，如果出现如图配置表示正确启动服务： \u003c!DOCTYPE html\u003e Responsive Image 开发板侧配置 新建一个目录，用于挂载共享目录\nmkdir /nfs 挂载共享目录\nmount -vvv -t nfs -o nolock -o vers=3,port=2049 192.168.1.7:/d/nfs /nfs -vvv：表示挂载时输出详细信息，可省略 -t nfs：表示挂载的文件系统类型为nfs -o nolock：表示不使用锁定机制 -o vers=3：表示使用NFSv3版本 -o port=2049：表示NFS服务端口号 192.168.1.7:/d/nfs：表示NFS服务器的IP地址和共享目录 /nfs: 表示开发板上的共享目录 常见错误 挂载时报错：portmap query failed: RPC: Timed out 点击NFS服务的端口映射页面，可以查看RPC使用的所有端口，需要将这些端口都开放，或者直接关闭防火墙。\n\u003c!DOCTYPE html\u003e Responsive Image 一些可能用到的命令：\nip route add default via 192.168.1.1 ip route del 0.0.0.0/0 via 192.168.1.1 dev eth0 ip route del 192.168.1.0/24 dev eth0 vi /etc/systemd/network/50-static.network systemctl enable systemd-networkd 如何在Windows上搭建NFS服务器实现开发板与Windows之间的文件共享_opencv_Jack_小明-GitCode 开源社区\n","permalink":"https://lifeislife.cn/posts/windows%E6%8C%82%E8%BD%BDnfs%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BC%80%E5%8F%91%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/","summary":"\u003ch2 id=\"配置windows与开发板网络通信\"\u003e配置Windows与开发板网络通信\u003c/h2\u003e\n\u003ch3 id=\"配置windows侧网卡\"\u003e配置Windows侧网卡\u003c/h3\u003e\n\u003cp\u003e将Windows与开发板通过USB网卡连接，开发板的网卡插口选择eth0，也就是靠近拨码开关的网口。开发板开机，Windows的设备管理器中出现以下网卡表示网卡功能正常。\u003c/p\u003e","title":"Windows挂载NFS网络文件系统实现与开发文件传输"},{"content":"QEMU 是一个开源的虚拟化软件，它能够模拟不同的硬件平台，让用户在不同的操作系统之间进行切换和测试。以下是 QEMU 常用命令的总结文档，包含每个命令的功能说明。\nQEMU 安装 源码下载 压缩包方式 版本可以修改\ncd qemu-build \u0026amp;\u0026amp; wget \u0026#34;https://download.qemu.org/qemu-8.0.2.tar.xz\u0026#34; tar -xf qemu-8.0.2.tar.xz --strip-components=1 Clone 方式 git clone https://gitlab.com/qemu-project/qemu.git cd qemu git submodule init git submodule update --recursive 配置编译选项 ./configure --target-list=riscv32-softmmu,riscv32-linux-user,riscv64-linux-user,riscv64-softmmu \\ --enable-kvm \\ --enable-debug \\ --enable-sdl \\ --prefix=/home/user/program/riscv64-qemu \\ --python=/usr/bin/python3 # --python=python路径，如果提示默认python版本低，可以加这个参数 # --prefix 选项设置qemu的安装位置绝对路径，之后若要卸载删除qemu只要删除该文件夹即可，--enable-kvm开启kvm # config完，可以在指定的qemu安装文件夹下面找到config-host.mak文件， # 该文件记录着qemu配置的选项，可以和自己设置的进行对比，确保配置和自己已知 一些常用的编译选项 \u0026ndash;enable-debug：编译调试版本，调试版本的运行速度非常慢 \u0026ndash;disable-werror：忽略警告，否则任何编译警告都被视为编译错误 \u0026ndash;enable-plugins：开启TCG Plugin支持 \u0026ndash;disable-stack-protector：关闭QEMU自身的栈保护 \u0026ndash;extra-cflags=\u0026quot;-O3\u0026quot;：能让你的QEMU提速5~10%，如果编译时报错，请加上--disable-werror \u0026ndash;prefix=\u0026lt;路径\u0026gt;：指定安装目录的路径 \u0026ndash;target-list=\u0026lt;架构\u0026gt;：指定要编译的目标架构列表，例如 x86_64-softmmu,arm-softmmu。 \u0026ndash;enable-\u0026lt;功能\u0026gt;：启用指定的功能。例如，--enable-kvm 启用 KVM 支持，--enable-gtk 启用 GTK 图形界面等。 \u0026ndash;disable-\u0026lt;功能\u0026gt;：禁用指定的功能。 \u0026ndash;enable-debug：启用调试模式，包括调试符号和调试输出。 \u0026ndash;enable-virtfs：启用 virtio 文件系统支持。 \u0026ndash;enable-modules：启用模块支持。 \u0026ndash;disable-guest-agent：禁用客户机代理支持。 \u0026ndash;enable-trace-backend=\u0026lt;后端\u0026gt;：指定跟踪后端，例如 simple、log 或 dtrace。 \u0026ndash;disable-vhost-net：禁用 vhost-net 支持。 编译时输出.i 文件用于查看宏定义展开 $ ./configure --extra-cflags=\u0026#34;-save-temps\u0026#34; --target-list=riscv64-linux-user,riscv64-softmmu --disable-werror --python=/usr/bin/python3 启动虚拟机 以下命令用于启动虚拟机：\nqemu-system-x86_64 -boot d -cdrom /path/to/iso -m 1024 -hda /path/to/hda.img -boot d：从 CD/DVD 启动 -cdrom /path/to/iso：指定 ISO 文件的路径 -m 1024：设置虚拟机的内存大小为 1024MB -hda /path/to/hda.img：指定虚拟硬盘的路径 安装系统至磁盘 qemu-system-x86_64 \\ -cdrom ~/Downloads/ubuntu.iso \\ -drive file=ubuntu.qcow2 \\ -enable-kvm \\ -cpu host \\ -smp cores=2,threads=2 \\ -m 2G \\ -vga virtio \\ -display sdl,gl=on 网络配置 以下命令用于配置虚拟机的网络：\nqemu-system-x86_64 -net nic -net user,hostfwd=tcp::2222-:22 -net nic：启用虚拟网卡 -net user：使用用户模式网络堆栈 hostfwd=tcp::2222-:22：将主机的 2222 端口转发到虚拟机的 22 端口 调试相关命令 启动调试模式 qemu-system-x86_64 -s -S -s：启用 GDB 调试 -S：在启动时暂停虚拟机，等待调试器连接 输出调试日志 /home/user/develop/qemu/build/qemu-riscv64 -d in_asm,exec,cpu,strace -D ./log hello QEMU 的 -d 参数说明\n日志选项（用逗号分隔）：\nout_asm：显示每个已编译基本块生成的宿主汇编代码 in_asm：显示每个已编译基本块的目标汇编代码 op：显示每个已编译基本块的微操作 op_opt：显示优化后的微操作 op_ind：显示间接降低前的微操作 int：以简短格式显示中断/异常 exec：在每次执行基本块前显示跟踪（大量日志） cpu：在进入基本块前显示 CPU 寄存器（大量日志） fpu：在“cpu”日志中包含 FPU 寄存器 mmu：记录与 MMU 相关的活动 pcall：仅限 x86：显示保护模式下的远程调用/返回/异常 cpu_reset：在 CPU 重置前显示 CPU 状态 unimp：记录未实现的功能 guest_errors：当来宾操作系统执行无效操作（例如访问不存在的寄存器）时记录日志 page：在用户模式仿真开始时转储页面 nochain：不链式编译基本块，以便“exec”和“cpu”显示完整的跟踪 plugin：输出来自 TCG 插件的信息 strace：记录每个用户模式系统调用、其输入和结果 trace:PATTERN：启用跟踪事件 使用 \u0026quot;-d trace:help\u0026quot; 来获取跟踪事件列表。\nqemu-system-xxx 常用相关参数 -M：指定 machine，-help 可以列出所有所支持的 machine -cpu：指定模拟的 CPU 型号，例如 cortex-a57、cortex-a53 等。 -smp：CPU 核数 -m：RAM 容量 -kernel：Linux kernel 文件 -append：Linux Kernel 的 bootargs。这个命令的参数很复杂，具体可以参考 kernel 文档。 -console：设备名必须和 machine 的串口一致，否则会看不到 kernel log。而不同的平台 console 名称都是不一样的，这是 Kernel 很不友好的一点。 -ignore_loglevel：可以让你看到尽可能多的 kernel log，当然也会减慢 kernel 的启动速度 -init：必须保证 initrd 里有/linuxrc 这个文件，否则会无法启动 shell -initrd：指定 initrd 文件 快照管理 # 拍快照 qemu-img snapshot -c oe-rv-snapshot1 openEuler-22.09-riscv64-qemu.qcow2 # 列举快照 qemu-img snapshot-l openEuler-22.09-riscv64-qemu.qcow2 # 恢复快照 qemu-img snapshot -a my_snapshot mydisk.qcow2 查看虚拟硬盘信息 qemu-img info /path/to/image 将虚拟硬盘转换为 QCOW2 格式 qemu-img convert -O qcow2 /path/to/image /path/to/new/image 调整磁盘大小 qemu-img resize ubuntu.qcow2 +5G 显示器选项 qemu-system-x86_64 -vga std qemu-system-x86_64 -display sdl qemu-system-x86_64 -display gtk -vga std：使用标准 VGA 显示器 -display sdl：使用 SDL 显示器 -display gtk：使用 GTK 显示器 输入选项 qemu-system-x86_64 -k en-us qemu-system-x86_64 -usb qemu-system-x86_64 -device usb-mouse -k en-us：使用英文键盘布局 -usb：启用 USB 支持 -device usb-mouse：使用 USB 鼠标设备 声音选项 以下命令用于配置虚拟机的声音：\nqemu-system-x86_64 -soundhw all qemu-system-x86_64 -soundhw sb16 qemu-system-x86_64 -audiodev pa,id=pa1,out.mixing-engine=off -soundhw all：启用所有声卡 -soundhw sb16：启用 SoundBlaster 16 声卡 -audiodev pa,id=pa1,out.mixing-engine=off：使用 PulseAudio 声音设备 USB 设备管理 以下命令用于管理虚拟机的 USB 设备：\nqemu-system-x86_64 -usbdevice host:1234:5678 qemu-system-x86_64 -usbdevice tablet qemu-system-x86_64 -usbdevice keyboard -usbdevice host🔢5678：将主机的 USB 设备 1234:5678 分配给虚拟机 -usbdevice tablet：使用 USB 触摸板 -usbdevice keyboard：使用 USB 键盘 ","permalink":"https://lifeislife.cn/posts/qemu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"\u003cp\u003eQEMU 是一个开源的虚拟化软件，它能够模拟不同的硬件平台，让用户在不同的操作系统之间进行切换和测试。以下是 QEMU 常用命令的总结文档，包含每个命令的功能说明。\u003c/p\u003e","title":"QEMU 常用命令"},{"content":"常见术语 黄衫（Yellow jersey/Maillot Jaune） 黄衫是总成绩领先者的象征，穿上黄衫的车手就是比赛的领头羊。 绿衫（Green jersey/Maillot Vert） 绿衫代表冲刺积分的领先者，通常由擅长平地冲刺的车手穿着。 圆点衫（Polka dot jersey/Maillot à Pois Rouges） 圆点衫授予爬坡积分最高的车手，爬坡能力强的车手更有机会获得。 白衫（White jersey/Maillot Blanc） 白衫是最佳年轻车手（25岁以下）的象征，表现优异的年轻车手会穿上白衫。 突围/兔子（Breakaway） 指比赛中一小部分车手从主集团（Peloton）中突围出来，尝试抢占领先位置。 主集团（Peloton） 主集团是比赛中最大的车手队伍，大部分车手都会待在主集团里，节省体力。 冲刺（Sprint） 冲刺是比赛最后几百米的激烈竞争，冲刺手（Sprinter）们会在这时全力以赴，争夺赛段冠军。 掉队（Dropped） 被其他选手甩在后面，也被称为off the back或者out the back。 计时赛（Time Trial） 计时赛是车手单独出发，按时间计成绩的比赛形式，包括个人计时赛（ITT）和团队计时赛（TTT）。 总成绩（General Classification, GC） 总成绩是根据车手每个赛段的时间累加计算的，最终总时间最少的车手将获得黄衫。 皇后赛段（Queen Stage） 指的是能够决定多日赛最终排名的关键性山地赛段，通常有数座难度很大的山峰。 火车（Paceline） 指的是队友在前面做苦力，保护主将，为主将节省体力的战术。（对应的有冲刺火车或是山地火车） 跟风/蹭风/吸尾流（Draft） 在高速骑行过程中，车手的大部分体力是消耗在对抗空气阻力（风阻）上。因此会有车手骑在其他人或车子后方，来降低风阻，节省体力。 粘瓶（Sticky Bpttle） 选手在拿补给车的水壶时，会短暂获得补给车所带来的助力，以节省体力，通常三五秒之内都是被允许的，如果时间太长被裁判发现将会被罚款甚至取消成绩。 关门时间（Time limit） 在每天的比赛中，车手们必须在不超过当日赛段冠军用时的一定比例时间内完赛，否则将被取消比赛资格，不被获准在第二天的比赛时发车；确切的比例取决于赛段的类型、地形和速度；速度快时，在平地赛段中，比例会低至5%，而速度慢时，在山地赛段中，比例会达到16、17%。在某些情况下，赛事组织者有权酌情赦免一些车手，比如当有过大一部分车手无法在关门时间内完赛时。历史上也有过特例，一些大牌冲刺手被关门，然后组委会以扣冲刺积分的形式来放他们一马。 爬坡点等级（Mountain Climb Classification） 比赛中设置的爬坡抢分点，难度与级数由低至高为4、3、2、1、HC（顶级）；越高的级数代表爬坡长度越长、坡度越陡。 补给区 Feed Zone 比赛中设置一个区域，让车队提供车手饮食补给袋的地方。通常，车手不会在这个区域发动攻击。 垃圾丢弃区（Collection Zone） UCI规定只能在固定的垃圾丢弃区扔垃圾，否则会被罚款。 自行车战术 油管上有个台湾博主叫做《喂我阿维》做了一个自行车战术的系列视频，这个系列的视频选择了一些实战的战况并结合了三维动画来解释各种战术，非常直观易懂，推荐大家观看。\n环法观赛中小白常问的问题 为何约纳斯温格高（Jonas Vingegaard Rasmussen）外号鲨鱼佬？ 温格高在进入职业比赛之前曾在鱼类加工厂干过一年左右的兼职，所以粉丝给他起了外号sha鱼佬。因为鲨鱼和sha鱼发音相同，所以就有了这个外号。其实也是为了规避社交平台的敏感词。 为何提到波加查就会提到芬达？叫他芬达超人？ 因为其他车手结束比赛大多会喝纯净水或者一些电解质饮料，或者一些我们不认识的功能饮料。而波加查喜欢比赛后喝芬达。不过今年很少看到他喝芬达了，不知道是不是没要到赞助费（狗头保命）。 每次比赛都有四五个小时，车手怎么上厕所？ 当然是站着解决了，哈哈。比赛开始时车速较慢，还可以停车在路边解决。比赛中段车速会很快，一旦停车将很难追上，通常这时车手会边骑边放水，如果你在直播中看到有在边上骑车并且骑行姿势奇怪的车手，那么他可能在放水。 环法中有中国的车队吗？ 很可惜，没有。目前也只有一位中国车手完成过环法，是在2014年来自捷安特·禧玛诺车队中国车手计成，以第164名，也是最后一名完成比赛。 有的赛段在终点前许多车手为什么向路边扔水壶？ 为了减轻负重，提高冲刺速度。 卡文迪什（Mark CAVENDISH）外号由来？ 盘爷：取自名字（CAVENDISH）的最后四个字母（Dish）。 曼岛飞弹：因为卡文迪什是土生土长的曼岛人，并且速度飞快（曼岛以摩托赛曼岛TT著称）。 卡胖：卡文迪什不擅爬坡，以及每逢佳节胖三斤的体质，为他招来了这个“雅号”。 为何不想争赛段的车队也会在前面带风？为何要把主将带到最后三公里？ 首先在集团前方相对来说较为安全，因为集团后方只能看到前面车手的屁股，对突发情况难以预判。其次因为在最后三公里发生摔车或者机械故障，成绩按照大集团的过线成绩计算，不会丢时间。 更新：UCI 已决定允许组织者和其他利益相关者试行要求修改所谓的“三公里”（或“冲刺区”）规则（《UCI 规则》第 2.6. 027 条），该规则适用于以下情况：比赛进入最后冲刺区，根据该规则，如果在公路赛段的最后三公里（不包括山顶终点）发生适当注意到的事件（例如跌倒、机械问题或爆胎），受影响的骑手的时间记入事件发生时与他一起骑车的骑手的时间。如果有正当理由，提出请求的组织者（或其他利益相关者）可以延长上述规则所考虑的距离，最多可以增加到五公里。任何变更都必须在比赛开始前获得同意。 环法是不是只有一条线路？环绕法国国界吗？ 不是，环法多个赛段，并且环法每年的线路都不一样，今年2024年就有21个赛段，并且也不是环绕法国边境线，有时候会经过法国以外的国家，比如今年2024年，就是从意大利的佛罗伦萨发车。 比赛中的兔子是什么意思？为何有风不蹭要自己顶风骑？ 之前回复哔站的一位的提问。兔子就是突围的车手，就是冲在最前面远离大集团的车手。每个车队在每场比赛中的战术不同这个目的就太多了，最简单的就是一个车手觉得自己今天状态特别好，那他就可以冲出去为了争夺赛段冠军，如果跟着大集团的话最后的冲刺会很难取胜。也有的车队想要拉赞助获得更高的曝光，那就会安排车手突围，这样可以获得更多的镜头增加曝光量。还有就是比赛一般都有荣誉衫，荣誉衫不仅仅只有成绩第一才有，也有冲刺得分最多的，爬坡得分最多的，那么就会有突围车手冲出去抢夺这些积分获得荣誉衫。再有就是只是为了打乱竞争对手的节奏，因为你突围的话，竞争对手就需要消耗大量体力追赶，很容易乱了节奏。当然你也肯定听过空中加油这个战术，在使用这个战术时就需要兔子这个角色，一般是实力较强的副将突围，在爬坡之前等自己的主将（在等待过程中就会降速恢复体力），然后在爬坡时为他破风，因为这时候竞争对手在追兔子的时候已经消耗了体力，而兔子已经稍有恢复，这时候就能将主将发射出去。 车手把立位置是显示屏吗？还是一张贴纸？ 是贴纸，标注了简单的赛段信息，最重要的是补给时间，比如图2就是第四赛段波加查车上贴的贴纸，标注了海拔图，还有在哪些位置进行补给。码表一般放在把立前方，突出的部分，有个架子。 什么是十公里党？ 就是只看比赛最后10公里的观众，因为平路赛段通常比较无聊，不会有什么进攻，只有最后几公里才有一些动作。 个人计时赛（ITT）如何进行的？ 所有未退赛的选手，都会参加。发车顺序是当前总成绩的倒序。发车间隔不确定（可能UCI有规定如果有知道具体计算方式的欢迎评论区告知），2024年环法第7赛段发车间隔为1分钟。和其他赛段不同，个人计时赛没有队友和其他人破风，完全需要比拼个人实力，用时最短者获胜。此外还有团队计时赛（TTT），是以车队为单位间隔发车，比拼车队整体实力，2024年环法没有团队计时赛。 直播中屏幕上方的时间差是什么意思？ 上方标志可以查看集团信息，黄色高亮框表示当然画面是哪个集团，比如现在就是表示画面是大集团。集团标题可能为荣誉衫的法语名称（比如Maillot Jaune是黄衫，Gr.是Group的缩写），领头羊（Tête de la Course，表示这个集团从开始就突围并一直保持领先未被追上过），明星车手的名字（比如图中的Carapaz和Johannessen），大集团（Peloton），追击集团（Chase）等等。显示的时间表示与突围集团的差距，所有的时间都是相对于突围集团的，不是相对于它的前一个集团。比如当前大集团比突围集团慢了约三分钟三十四秒，卡拉帕兹比突围集团慢了约十七秒。 破风手在比赛前就定好了吗。每场比赛会轮流吗？ 不是定好的，但是每个车队都会赛前定战术，赛场上变化很多，赛中车手也会听无线电里车队主管的安排。有一点是定的，主将几乎不会参与破风。 最佳车队奖是如何评比的？ 每个赛段结束后，根据每个车队的前三名最好成绩，计算车队的总成绩。时间最少的车队获得最佳车队奖。 赞助商赞助的资源是否包含你提到的这些角色，是肯定包含的。但是具体赞助了什么，赞助多少，如何分配，也算是商业机密吧，我就不得而知了。我也分享一些我了解的信息。赞助商投入最大的还是在自行车上。每辆自行车至少都在一万美元以上。每个赛季都要投入一两百辆的车，这些装备肯定都是分配给车手的，此外赞助商通常还会赞助各个车队全球征战的差旅费，这就肯定包含所有后勤保障人员了。这里插一个有意思的，车队赞助商的投入不仅可以从车手装备看出差异，后勤保障车上也能管中窥豹。去年的冠军车队visma车队大巴堪比移动堡垒，移动之家，而现在只是职业车队乐透车队(Visma车队是世界级车队，比职业车队高一级)的大巴就略显“寒酸”了。感兴趣的话可以油管搜索关键词Inside Team bus。看看各个车队大巴的内部豪华设施，还是蛮有意思的。 关于赞助商的内容，我也是外行人，我给你发了一个链接，可以了解更多关于赞助的内容。也感谢你的提问，让我也学到了很多。\n第二个问题是关于如何获得比赛奖金以及奖金如何分配的。如何获得奖金，感兴趣的话可以直接站内搜索应该有朋友做总结，我就简单概括一下吧，奖金除了和比赛排名相关，和荣誉衫也是息息相关的。1. 最后总成绩的前三名肯定是有奖金的（第一名可以获得50万欧元的奖金），其实每个完赛的选手都有奖金。2. 每个赛段也会根据排名发放奖金，但是通常就只有前20名会有奖金。3. 每个荣誉衫每穿一天都会获得一次奖金，比如爬坡王圆点衫，每穿一天就能获得300欧元。4. 赛段中如果有标注等级的爬坡，那么率先通过这个爬坡的车手也会获得奖金。5. 组委会会为每个赛段中突围，进攻最积极的选手颁发敢斗奖，并在下个赛段用红色号码牌标记。拿敢斗奖也会获得2000欧元的奖金。6. 除了个人奖金，还有最佳车队奖，每一赛段结束后，根据每个车队的前三名最好成绩，计算车队的总成绩。时间最少的车队获得最佳车队奖（2800欧元）。7. 此外需要提醒的是，奖金只会发给真正获得荣誉衫的人，如果是顺延代穿荣誉衫，是不会获得奖金的。\n再说说奖金的分配，奖金从面子上讲，他是归属获得者个人的（最佳团队奖除外），但是里子上通常会根据内部规定进行分配。具体如何分配我也不够专业，就不误导你了。但是有一点你说的肯定没错，获奖一般离不开其他队友的帮助，肯定会按出力程度来分配。至于环法组委会如何发放奖金，发放到哪里，我也不太清楚，如果你有找到相关资料，欢迎分享给我。\n观赛工具 环法官网 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image Tour Tracker 网页版：https://live.thetourtracker.com/\nAPP版本：Google Play Store 和 Apple App Store 搜索 Tour Tracker。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 奥运会公路车概况 男子个人计时赛没有中国选手参加，但是男子公路赛有吕先景一位中国选手参加。吕先景目前效力于中国华兴-铭普洲际车队。2018年雅加达亚运会上，他获得男子山地自行车银牌，2019年环中国自行车赛，获得第二赛段冠军。期待吕先景在奥运会上取得好成绩。（PS：不用惊讶哦，是有环中国比赛的，只是2019年之后因为疫情就停办了，并且也没有复办的消息） 女子个人计时赛有中国选手唐欣参加，同时她还会参加女子公路赛。她是中国第一位参加巴黎鲁贝女子自行车上并完赛的车手，也是中国第一位参加环西班牙女子自行车赛并完赛的车手，期待她在奥运会上取得好成绩。 比赛规则简述 男女个人计时赛\n一场定胜负的比赛，运动员在规定的时间内完成比赛，成绩最好的运动员获得金牌； 运动员按照规定的间隔时间单独出发，以运动员到达终点的成绩优劣排名； 发车时由同一名裁判员扶车； 间隔1-2分钟发车，具体发车时间可在Tour Tracker，奥林匹克官网，ProCyclingStats等网站查看； 即使追上了前面发车的车手，也不能相互领骑； 在超车以及被超越过程中，运动员不得进入对手左右2米，前后25米的空间； 队车不得在运动员前方行驶，只能在运动员后方25米外行驶； 男女公路赛\n一场定胜负的比赛，运动员在规定的时间内完成比赛，成绩最好的运动员获得金牌； 发车位置按照签到顺序确定； 比赛中可以跟风，可以互相帮助，交换食物和水以及工具等，但是不能相互推行； 在赛程的前50公里和进入最后20公里后，不得进行补给，赛道上会有标识补给开始区域和补给结束区域； 队车不得超越运动员，只有裁判同意才可以； ","permalink":"https://lifeislife.cn/posts/%E5%B0%8F%E7%99%BD%E7%8E%AF%E6%B3%95%E8%A7%82%E8%B5%9B%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"常见术语\"\u003e常见术语\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e黄衫（Yellow jersey/Maillot Jaune）\n黄衫是总成绩领先者的象征，穿上黄衫的车手就是比赛的领头羊。\u003c/li\u003e\n\u003cli\u003e绿衫（Green jersey/Maillot Vert）\n绿衫代表冲刺积分的领先者，通常由擅长平地冲刺的车手穿着。\u003c/li\u003e\n\u003cli\u003e圆点衫（Polka dot jersey/Maillot à Pois Rouges）\n圆点衫授予爬坡积分最高的车手，爬坡能力强的车手更有机会获得。\u003c/li\u003e\n\u003cli\u003e白衫（White jersey/Maillot Blanc）\n白衫是最佳年轻车手（25岁以下）的象征，表现优异的年轻车手会穿上白衫。\u003c/li\u003e\n\u003cli\u003e突围/兔子（Breakaway）\n指比赛中一小部分车手从主集团（Peloton）中突围出来，尝试抢占领先位置。\u003c/li\u003e\n\u003cli\u003e主集团（Peloton）\n主集团是比赛中最大的车手队伍，大部分车手都会待在主集团里，节省体力。\u003c/li\u003e\n\u003cli\u003e冲刺（Sprint）\n冲刺是比赛最后几百米的激烈竞争，冲刺手（Sprinter）们会在这时全力以赴，争夺赛段冠军。\u003c/li\u003e\n\u003cli\u003e掉队（Dropped）\n被其他选手甩在后面，也被称为off the back或者out the back。\u003c/li\u003e\n\u003cli\u003e计时赛（Time Trial）\n计时赛是车手单独出发，按时间计成绩的比赛形式，包括个人计时赛（ITT）和团队计时赛（TTT）。\u003c/li\u003e\n\u003cli\u003e总成绩（General Classification, GC）\n总成绩是根据车手每个赛段的时间累加计算的，最终总时间最少的车手将获得黄衫。\u003c/li\u003e\n\u003cli\u003e皇后赛段（Queen Stage）\n指的是能够决定多日赛最终排名的关键性山地赛段，通常有数座难度很大的山峰。\u003c/li\u003e\n\u003cli\u003e火车（Paceline）\n指的是队友在前面做苦力，保护主将，为主将节省体力的战术。（对应的有冲刺火车或是山地火车）\u003c/li\u003e\n\u003cli\u003e跟风/蹭风/吸尾流（Draft）\n在高速骑行过程中，车手的大部分体力是消耗在对抗空气阻力（风阻）上。因此会有车手骑在其他人或车子后方，来降低风阻，节省体力。\u003c/li\u003e\n\u003cli\u003e粘瓶（Sticky Bpttle）\n选手在拿补给车的水壶时，会短暂获得补给车所带来的助力，以节省体力，通常三五秒之内都是被允许的，如果时间太长被裁判发现将会被罚款甚至取消成绩。\u003c/li\u003e\n\u003cli\u003e关门时间（Time limit）\n在每天的比赛中，车手们必须在不超过当日赛段冠军用时的一定比例时间内完赛，否则将被取消比赛资格，不被获准在第二天的比赛时发车；确切的比例取决于赛段的类型、地形和速度；速度快时，在平地赛段中，比例会低至5%，而速度慢时，在山地赛段中，比例会达到16、17%。在某些情况下，赛事组织者有权酌情赦免一些车手，比如当有过大一部分车手无法在关门时间内完赛时。历史上也有过特例，一些大牌冲刺手被关门，然后组委会以扣冲刺积分的形式来放他们一马。\u003c/li\u003e\n\u003cli\u003e爬坡点等级（Mountain Climb Classification）\n比赛中设置的爬坡抢分点，难度与级数由低至高为4、3、2、1、HC（顶级）；越高的级数代表爬坡长度越长、坡度越陡。\u003c/li\u003e\n\u003cli\u003e补给区 Feed Zone\n比赛中设置一个区域，让车队提供车手饮食补给袋的地方。通常，车手不会在这个区域发动攻击。\u003c/li\u003e\n\u003cli\u003e垃圾丢弃区（Collection Zone）\nUCI规定只能在固定的垃圾丢弃区扔垃圾，否则会被罚款。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"自行车战术\"\u003e自行车战术\u003c/h2\u003e\n\u003cp\u003e油管上有个台湾博主叫做\u003ca href=\"https://www.youtube.com/watch?v=f1ncgvjB_z4\u0026amp;list=PLa5LB6K0vQT3CzQNp7traSqvvp4Sn_uaQ\"\u003e《喂我阿维》做了一个自行车战术的系列视频\u003c/a\u003e，这个系列的视频选择了一些实战的战况并结合了三维动画来解释各种战术，非常直观易懂，推荐大家观看。\u003c/p\u003e","title":"小白环法观赛指南"},{"content":"准备工作 一直在QEMU上做RISC-V开发，最近入手了Milk-V Duo S开发板，准备尝试在硬件上玩玩RISC-V。99块钱的开发板，性价比还是很高的。以下内容就是参考官方文档从 microSD 卡启动 Duo | Milk-V，复现一遍。先熟悉一下硬件。\nMilk-V Duo S开发板一块 大于 1GB 的 microSD 卡，我买的是 SD 卡版本，如果买的自带eMMC的就不需要了。 Type-C 数据线 准备镜像并烧录 下载官方镜像，我使用的是milkv-duos-sd-v1.1.1-2024-0528.img.zip。解压后就可以得到镜像文件。我习惯使用Rufus烧录镜像。\nMilk-V Duo S 启动！ 将SD卡插入开发板，然后使用Type-C线连接Duo S开发板和电脑。稍等片刻开发板上的蓝色LED灯将闪烁，红色LED保持常量亮。说明开发板已经启动成功。接下来就可以通过SSH连接开发板了。\n在使用SSH之前需要开启Windows RNDIS。开启过程参考官方文档设置工作环境 | Milk-V，我就不再重复了，图片有点多，看官方文档更直观。\n","permalink":"https://lifeislife.cn/posts/milk-v-duo-s-%E5%90%AF%E5%8A%A8/","summary":"\u003ch2 id=\"准备工作\"\u003e准备工作\u003c/h2\u003e\n\u003cp\u003e一直在QEMU上做RISC-V开发，最近入手了Milk-V Duo S开发板，准备尝试在硬件上玩玩RISC-V。99块钱的开发板，性价比还是很高的。以下内容就是参考官方文档\u003ca href=\"https://milkv.io/zh/docs/duo/getting-started/boot\"\u003e从 microSD 卡启动 Duo | Milk-V\u003c/a\u003e，复现一遍。先熟悉一下硬件。\u003c/p\u003e","title":"Milk-V Duo S 启动"},{"content":"根文件系统 文件系统与根文件系统 文件系统（File System）是操作系统用于管理和存储数据的一种方式。它定义了如何在存储设备（如硬盘、SSD、USB 驱动器等）上组织文件和目录，以及如何进行数据的读写操作。\n常见的文件系统类型有：\next4：Linux 最常用的文件系统，支持大文件和大分区。 NTFS：Windows 操作系统常用的文件系统，支持文件加密和权限控制。 FAT32：一种兼容性广泛的文件系统，常用于 USB 驱动器和内存卡。 XFS：适用于高性能和高容量存储需求的文件系统。 btrfs：一种现代 Linux 文件系统，支持快照、压缩和多设备管理。 根文件系统（Root File System，通常简称为 rootfs）是文件系统层次结构中的顶级文件系统。它包含了操作系统启动和运行所需的所有基本文件和目录。根文件系统是整个文件系统层次的起点，在 Linux 中由单个斜杠（/）表示。根文件系统首先是内核启动时所 mount 的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。\n根文件系统是建立在文件系统之上的。根文件系统使用某种具体的文件系统类型（如 ext4）来管理和存储其内容。\n基于内存的文件系统 ramdisk 是一种基于内存的文件系统，它将内存的一部分用作硬盘驱动器，这样就可以在内存中创建一个文件系统。ramdisk 是一个虚拟磁盘，它的大小和硬盘驱动器的大小一样。ramdisk 的优点是速度快，缺点是断电后数据丢失。\n根文件系统中各种配置文件的作用以及配置文件的格式介绍 /etc/inittab /etc/inittab 是 Linux 系统中的一个配置文件，它是 init 程序的配置文件，用于配置系统的运行级别和 init 程序的行为。在 Linux 系统中，init 程序是系统的第一个进程，它负责启动系统中的所有其他进程。/etc/inittab 文件中的每一行都是一个配置项，每个配置项由四个字段组成，字段之间用空格或制表符分隔。/etc/inittab 文件的格式如下：\nid:runlevels:action:process 每个字段用冒号分隔，可以缺省。各字段的含义如下：\nid：配置项的标识符，用于标识配置项。 runlevels：配置项所对应的运行级别，可以是一个或多个运行级别的组合。 action：配置项的动作，可以是以下几种动作之一： sysinit：系统初始化时运行。 respawn：如果进程终止，立即重新启动。 askfirst：在运行 process 之前询问用户。并在控制台上显示 Please press Enter to active this console。 wait：等待进程终止，然后继续执行下一个配置项。 once：只运行一次，进程终止后不会重新启动。 boot：在系统引导时运行。 bootwait：在系统引导时运行，等待进程终止后继续引导。 initdefault：设置默认运行级别。 shutdown：在系统关机时运行。 process：要执行的进程或脚本的路径。 示例：\n# /etc/inittab #系统开机或重新启动，执行rcS文件 ::sysinit:/etc/init.d/rcS #系统启动后，运行登录程序 ::askfirst:-/bin/login #按下组合键“ctrl+alt+del”，重启Linux系统 ::ctrlaltdel:-/sbin/reboot #系统关机时，卸载所有文件系统 ::shutdown:/bin/umount -a -r #重启init进程 ::restart:/sbin/init /etc/fstab /etc/fstab 是 Linux 系统中的一个配置文件，用于配置文件系统的挂载信息。在 Linux 系统中，文件系统是通过挂载的方式来访问的，/etc/fstab 文件中记录了系统中所有文件系统的挂载信息。/etc/fstab 文件的格式如下：\ndevice mount_point fs_type options dump pass 各字段的含义如下：\ndevice：设备文件或 UUID。 mount_point：挂载点。 fs_type：文件系统类型。 options：挂载选项。 dump：备份标志，用于备份工具。 pass：文件系统检查顺序。 示例：\n# /etc/fstab # \u0026lt;文件系统\u0026gt; \u0026lt;挂载点\u0026gt; \u0026lt;类型\u0026gt; \u0026lt;选项\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;fsck\u0026gt; # 根文件系统 /dev/sda1 / ext4 defaults 1 1 # 根分区，使用 ext4 文件系统，默认挂载选项 # /boot 分区，用于存放引导加载程序和内核镜像 /dev/sda2 /boot ext4 defaults 1 2 # /boot 分区，使用 ext4 文件系统，默认挂载选项 # 交换分区，用作虚拟内存 /dev/sda3 none swap sw 0 0 # 交换分区，不需要挂载点，使用 swap 类型 # /home 分区，用于存放用户的个人数据 /dev/sda4 /home ext4 defaults 1 2 # /home 分区，使用 ext4 文件系统，默认挂载选项 # /tmp 分区，用于存放临时文件 /dev/sda5 /tmp ext4 defaults 1 2 # /tmp 分区，使用 ext4 文件系统，默认挂载选项 # /var 分区，用于存放可变数据文件，如日志、邮件、缓存等 /dev/sda6 /var ext4 defaults 1 2 # /var 分区，使用 ext4 文件系统，默认挂载选项 # /mnt/data 分区，用于存放额外的数据文件 /dev/sda7 /mnt/data ext4 defaults 1 2 # /mnt/data 分区，使用 ext4 文件系统，默认挂载选项 # 挂载 proc 文件系统，用于访问进程和系统信息 proc /proc proc defaults 0 0 # proc 虚拟文件系统，默认挂载选项 # 挂载 sysfs 文件系统，用于访问设备和内核信息 sysfs /sys sysfs defaults 0 0 # sysfs 虚拟文件系统，默认挂载选项 # 挂载 tmpfs 文件系统，用于临时文件存储 tmpfs /dev/shm tmpfs defaults 0 0 # tmpfs 虚拟文件系统，默认挂载选项 # 挂载 devpts 文件系统，用于伪终端设备 devpts /dev/pts devpts gid=5,mode=620 0 0 # devpts 虚拟文件系统，默认挂载选项 /etc/init.d/rcS /etc/init.d/rcS 是 Linux 系统中的一个初始化脚本，用于系统初始化时运行。在 Linux 系统中，/etc/init.d/rcS 脚本是系统初始化时运行的第一个脚本，它负责初始化系统中的各种服务和配置。/etc/init.d/rcS 脚本通常包含了一些初始化命令，如加载模块、挂载文件系统、启动服务等。/etc/init.d/rcS 脚本的格式如下：\n#!/bin/sh # 这行是 shebang，用于指定这个脚本将由 /bin/sh 解释执行 # 挂载 proc 文件系统到 /proc 目录 mount -t proc none /proc # proc 文件系统是一个虚拟文件系统，用于提供内核和进程的信息 # 挂载 sysfs 文件系统到 /sys 目录 mount -t sysfs none /sys # sysfs 文件系统是一个虚拟文件系统，用于提供设备和内核信息 # 挂载 devtmpfs 文件系统到 /dev 目录 mount -t devtmpfs none /dev # devtmpfs 是一个用于设备节点的临时文件系统 # 运行 mdev 以创建设备节点 /sbin/mdev -s # mdev 是一个轻量级的设备管理工具，用于创建和管理 /dev 目录中的设备节点 # 设置主机名 echo \u0026#34;myhostname\u0026#34; \u0026gt; /proc/sys/kernel/hostname # 将主机名设置为 \u0026#34;myhostname\u0026#34;，这个名字可以根据需要更改 # 启动网络接口配置脚本 ifconfig lo up # 启动回环接口 lo，这是一个特殊的网络接口，用于网络软件本地通信 # 运行所有位于 /etc/init.d/ 目录中的初始化脚本 for script in /etc/init.d/S*; do if [ -x \u0026#34;$script\u0026#34; ]; then \u0026#34;$script\u0026#34; start fi done # 遍历 /etc/init.d/ 目录中的所有以 S 开头的脚本，并执行它们以启动相应的服务 # -x 选项用于检查文件是否可执行 # 挂载用户文件系统（可选，根据实际需要） mount -a # 挂载 /etc/fstab 文件中列出的所有文件系统 # 打印启动完成信息 echo \u0026#34;System initialization complete.\u0026#34; # 输出系统初始化完成信息 /etc/profile /etc/profile 是 Linux 系统中的一个全局配置文件，用于配置系统的环境变量和用户的 shell 环境。在 Linux 系统中，/etc/profile 文件是系统启动时加载的第一个配置文件，它包含了系统的全局环境变量和用户的 shell 环境配置。/etc/profile 文件的格式如下：\n# /etc/profile #!/bin/sh # 这行是 shebang，用于指定这个脚本将由 /bin/sh 解释执行 # 设置 PATH 环境变量，定义系统命令的搜索路径 PATH=\u0026#34;/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\u0026#34; export PATH # /usr/local/sbin:/usr/local/bin 是系统管理员和用户安装的程序路径 # /sbin:/bin:/usr/sbin:/usr/bin 是系统默认的命令路径 # 设置用户 umask，定义新文件和目录的默认权限掩码 umask 022 # umask 022 表示新文件的默认权限是 755，新目录的默认权限是 644 # 设置系统语言和区域 LANG=\u0026#34;en_US.UTF-8\u0026#34; export LANG # LANG 变量定义了系统的语言环境，这里设置为美国英语 UTF-8 编码 # 设置历史记录文件和大小 HISTSIZE=1000 HISTFILESIZE=2000 export HISTSIZE HISTFILESIZE # HISTSIZE 定义了 shell 会话历史记录的条目数，HISTFILESIZE 定义了历史记录文件的最大条目数 # 系统启动信息 echo \u0026#34;Welcome to your Linux system!\u0026#34; # 在用户登录时显示欢迎信息 # 读取并执行 /etc/bashrc（如果存在） if [ -f /etc/bashrc ]; then . /etc/bashrc fi # /etc/bashrc 是另一个全局配置文件，通常包含 bash shell 的配置 # 使用 . /etc/bashrc 命令将其内容导入当前 shell 环境 # 配置别名（示例） alias ll=\u0026#39;ls -l\u0026#39; alias la=\u0026#39;ls -A\u0026#39; alias l=\u0026#39;ls -CF\u0026#39; # 定义一些常用命令的别名 # ll 代表 ls -l，显示详细列表 # la 代表 ls -A，显示所有文件包括隐藏文件（但不包括 . 和 ..） # l 代表 ls -CF，以分类格式显示文件 # 读取用户特定的配置文件（如果存在） if [ -f \u0026#34;$HOME/.profile\u0026#34; ]; then . \u0026#34;$HOME/.profile\u0026#34; fi # .profile 是用户的个人配置文件 # 使用 . $HOME/.profile 命令将其内容导入当前 shell 环境 # 设置编辑器 EDITOR=vim export EDITOR # 定义默认的文本编辑器为 vim # 设置主机名显示，也就是终端最前面提示符的样式 PS1=\u0026#39;\\u@\\h:\\w\\$ \u0026#39; export PS1 # PS1 定义了 shell 提示符的样式 # \\u 代表用户名 # \\h 代表主机名 # \\w 代表当前工作目录 Busybox 简介以及如何制作 Busybox 文件系统 准备 QEMU cd \u0026amp;\u0026amp; mkdir -p /home/user/program/riscv64-qemu cd workspace git clone https://github.com/qemu/qemu.git cd qemu cd qemu \u0026amp;\u0026amp; ./configure --target-list=riscv32-softmmu,riscv32-linux-user,riscv64-linux-user,riscv64-softmmu \\ --enable-kvm --enable-sdl \\ --prefix=/home/user/program/riscv64-qemu make install -j $(nproc) 准备 OpenSBI cd workspace git clone https://github.com/riscv-software-src/opensbi.git cd opensbi make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- PLATFORM=generic 准备 Linux 内核 cd workspace git clone https://github.com/torvalds/linux.git make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- defconfig make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- -j $(nproc) 准备 Busybox 进入下载软件包，https://busybox.net/downloads/\nwget https://busybox.net/downloads/busybox-1.36.1.tar.bz2 tar -xvf busybox-1.36.1.tar.bz2 mv busybox-1.36.1 busybox cd busybox 配置编译选项\nmake CROSS_COMPILE=riscv64-unknown-linux-gnu- menuconfig 选择静态库模式，设置路径：Settings -\u0026gt; Build static binary (no shared libs)\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 编译 Busybox\nmake CROSS_COMPILE=riscv64-unknown-linux-gnu- -j $(nproc) 如果需要频繁编译，也可以在 Menuconfig 中设置交叉编译器路径，这样就不需要每次都指定了。设置路径为：Settings -\u0026gt; Build Options -\u0026gt; Cross Compiler prefix。将其设置为 riscv64-unknown-linux-gnu-。\n安装 Busybox：\nmake CROSS_COMPILE=riscv64-unknown-linux-gnu- install Busybox 默认安装在当前目录的_install 目录下，也可以在 Menuconfig 中设置安装目录，路径为：Settings -\u0026gt; Build Options -\u0026gt; Destination path for \u0026lsquo;make install\u0026rsquo;。\n查看安装目录\nls _install bin linuxrc sbin usr 制作根文件系统\nqemu-img create -f raw rootfs.img 256M mkfs.ext4 rootfs.img mkdir rootfs sudo mount -o loop rootfs.img rootfs sudo cp -r _install/* rootfs cd rootfs sudo mkdir proc sys dev etc etc/init.d cd etc cd init.d sudo touch rcS sudo chmod +x rcS sudo vim rcS 写入以下内容：\n#!/bin/sh mount -t proc none /proc mount -t sysfs none /sys /sbin/mdev -s sudo umount rootfs qemu 启动内核：\n#!/usr/bin/env bash RESTORE=$(echo -en \u0026#39;\\001\\033[0m\\002\u0026#39;) YELLOW=$(echo -en \u0026#39;\\001\\033[00;33m\\002\u0026#39;) ## Configuration vcpu=8 memory=16 drive=\u0026#34;/home/user/workspace/rootfs.img\u0026#34; kernel=\u0026#34; /home/user/workspace/linux-stable/arch/riscv/boot/Image\u0026#34; fw=\u0026#34;/home/user/workspace/opensbi/build/platform/generic/firmware/fw_jump.bin\u0026#34; ssh_port=12070 cmd=\u0026#34;/home/user/program/riscv64-qemu/bin/qemu-system-riscv64 \\ -nographic -machine virt \\ -smp \u0026#34;$vcpu\u0026#34; -m \u0026#34;$memory\u0026#34;G \\ -cpu rv64\\ -bios \u0026#34;$fw\u0026#34; \\ -kernel \u0026#34;$kernel\u0026#34; \\ -drive file=$drive,format=raw,id=hd0 \\ -device virtio-blk-device,drive=hd0 \\ -append \u0026#34;root=/dev/vda console=ttyS0\u0026#34; \u0026#34; echo ${YELLOW}:: Starting VM...${RESTORE} echo ${YELLOW}:: Using following configuration${RESTORE} echo \u0026#34;\u0026#34; echo ${YELLOW}vCPU Cores: \u0026#34;$vcpu\u0026#34;${RESTORE} echo ${YELLOW}Memory: \u0026#34;$memory\u0026#34;G${RESTORE} echo ${YELLOW}Disk: \u0026#34;$drive\u0026#34;${RESTORE} echo ${YELLOW}SSH Port: \u0026#34;$ssh_port\u0026#34;${RESTORE} echo \u0026#34;\u0026#34; echo ${YELLOW}:: NOTE: Make sure ONLY ONE .qcow2 file is${RESTORE} echo ${YELLOW}in the current directory${RESTORE} echo \u0026#34;\u0026#34; echo ${YELLOW}:: Tip: Try setting DNS manually if QEMU user network doesn\\\u0026#39;t work well. ${RESTORE} echo ${YELLOW}:: HOWTO -\\\u0026gt; https://serverfault.com/a/810639 ${RESTORE} echo \u0026#34;\u0026#34; echo \u0026#34;\u0026#34; sleep 2 eval $cmd \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/busybox-%E6%9E%84%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8-risc-v-linux-%E5%86%85%E6%A0%B8/","summary":"\u003ch1 id=\"根文件系统\"\u003e根文件系统\u003c/h1\u003e\n\u003ch2 id=\"文件系统与根文件系统\"\u003e文件系统与根文件系统\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e文件系统\u003c/strong\u003e（File System）是操作系统用于管理和存储数据的一种方式。它定义了如何在存储设备（如硬盘、SSD、USB 驱动器等）上组织文件和目录，以及如何进行数据的读写操作。\u003c/p\u003e","title":"BusyBox 构建并启动 RISC-V Linux 内核"},{"content":"Google Play 改区 第一步登录 Google Pay，点击右上角的设置按钮。\n\u003c!DOCTYPE html\u003e Responsive Image 第二步点击付款方式，删除已有的付款方式。然后点击添加付款方式。\n\u003c!DOCTYPE html\u003e Responsive Image 第三步添加信用卡或者借记卡，填写卡号、有效期、CVV、姓名、地址等信息。所有信息可以使用美国地址生成。美国地址只是网站的名称，根据实际情况可以选择其他国家的地址。\n需要注意的是：\n你要改哪个国家就选择哪个国家，并且生成对应国家的地址。 地址第一行和地址第二行可以随便填。 市/区、州/省、邮编、必须使用生成的地址。 \u003c!DOCTYPE html\u003e Responsive Image 填写示例如下：\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 第四步添加完成后点击保存，此时底部会有弹窗提示，如图所示。这是正常现象，点击继续。关闭窗口到Google Pay查看地区已经完成更改。\n\u003c!DOCTYPE html\u003e Responsive Image 如果不巧，你也跟我一样没能修改成功，可以尝试在手机端登录Google Play，在手机端添加付款方式。添加方式和电脑端一样，只是在手机端添加更容易成功。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/google-play-%E6%94%B9%E5%8C%BA/","summary":"\u003ch1 id=\"google-play-改区\"\u003eGoogle Play 改区\u003c/h1\u003e\n\u003cp\u003e第一步登录 \u003ca href=\"https://pay.google.com/\"\u003eGoogle Pay\u003c/a\u003e，点击右上角的设置按钮。\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2024/06/14/9a6c2e3777731d27ef47d33cb95c8a0c.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2024/06/14/9a6c2e3777731d27ef47d33cb95c8a0c.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e第二步点击付款方式，删除已有的付款方式。然后点击添加付款方式。\u003c/p\u003e","title":"Google Play 改区"},{"content":"VSCode滚动条左侧有较宽的滚动条，这玩意叫小地图Minimap，作用和游戏里的小地图类似，就是为了看一下整个代码结构，便于快速定位，但是我习惯用搜索，觉得这玩意太占地方了，可以在设置里搜索Minimap进行关闭，或者设置为自动隐藏。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/vscode%E5%85%B3%E9%97%AD%E6%BB%9A%E5%8A%A8%E6%9D%A1%E9%A2%84%E8%A7%88/","summary":"\u003cp\u003eVSCode滚动条左侧有较宽的滚动条，这玩意叫小地图Minimap，作用和游戏里的小地图类似，就是为了看一下整个代码结构，便于快速定位，但是我习惯用搜索，觉得这玩意太占地方了，可以在设置里搜索Minimap进行关闭，或者设置为自动隐藏。\u003c/p\u003e","title":"VSCode关闭滚动条预览"},{"content":"懒得自己搭建了，还要准备一台公网服务器，直接找第三方服务商。签到免费送流量，不过流量不多，不过用来穿透个小服务还是够的。\nhttps://chickfrp.com?affcode=2649EJBPNQ https://console.openfrp.net/ 创建隧道，下载配置文件如下：\n[common] protocol=tcp server_addr=ali-shanghai-a.chickfrp.com server_port=7000 user=xxxxxxxxx token=xxxxxxxx tcp_mux=true [ openai ] type= tcp remote_port= 10006 local_ip= 192.168.1.9 local_port= 3322 use_compression=false use_encryption=false 配置客户端，下面以 Linux 为例，因为需要配置 Docker 服务，所以做个简单记录。\n# 下载 frp 应用，解压后 frpc 是客户端，frps 是服务端，今天我们只用到 frpc wget https://github.com/fatedier/frp/releases/download/v0.56.0/frp_0.56.0_linux_amd64.tar.gz tar zxvf frp_0.56.0_linux_amd64.tar.gz 将服务商提供的配置文件复制到frpc.toml中。服务商提供的可能是旧版本的 frp 配置，是ini格式，需要转换成toml格式。有能力可以自己稍微改一下格式就行，不会的话，可以用在线转换工具，比如：https://toml.info/zh/ini-to-toml。\n简单启动：\n./frpc -c ./frpc.toml 2024-04-01 21:04:29.326 [I] [client/control.go:170] [19341bf77b5454753237] [SDSDasdaderf.openai] start proxy success 配置 Docker-compose 一键启动，将配置文件frpc.toml映射到容器中。\nversion: \u0026#34;3.7\u0026#34; services: frp: image: stilleshan/frpc:latest container_name: frp volumes: - /path/to/frpc.toml:/frp/frpc.toml restart: always docker-compose up -d启动容器。docker logs frp查看日志。出现start proxy success表示成功。\n","permalink":"https://lifeislife.cn/posts/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","summary":"\u003cp\u003e懒得自己搭建了，还要准备一台公网服务器，直接找第三方服务商。签到免费送流量，不过流量不多，不过用来穿透个小服务还是够的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://chickfrp.com?affcode=2649EJBPNQ\"\u003ehttps://chickfrp.com?affcode=2649EJBPNQ\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://console.openfrp.net/\"\u003ehttps://console.openfrp.net/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e创建隧道，下载配置文件如下：\u003c/p\u003e","title":"FRP 内网穿透"},{"content":"问题背景 一款 SoC 芯片，会支持多种方式启动，比如从 NAND Flash、SPI Flash、eMMC、USB、UART 启动。对于 SPI Flash 启动，BootROM 需要知道 SPI Flash 的型号、容量、页大小、擦除大小等信息，以便正确读取、写入、擦除 SPI Flash。但是，不同厂家的 SPI Flash，这些参数可能不同，而 ROM 中的代码是无法修改的，并且容量有限，如何以最小的代码量，适配不同厂家的 SPI Flash 呢？\nSPI 开发流程 SPI 控制器初始\nSPI 控制器有自己的寄存器，可以配置 SPI 的页，块的擦除时间，是否需要 DMA，是否开启中断，单次读写的大小等等。 使用 SPI 对 Flash 进行配置\nBootROM 的 SPI 支持三种模式：Single、Dual、Quad，这不仅要配置 SPI 本身的寄存器，也需要配置 Flash 的寄存器。配置 Flash 的寄存器就需要使用 SPI 来完成。 BootROM 中配置 SPI 控制器的 SPIC_CSR_01 寄存器的spi_bus_mode 位可以配置 SPI 的模式； 查阅 Flash 手册，找到配置总线模式的寄存器以及操作它的命令，如 WINBOND-W25Q128JW 这款 Flash 的配置寄存器为 Status Register-2，Flash 的寄存器是无法直接读写的，所以需要在 Flash 手册中找到操作这个寄存器的命令，在手册的 Instructions 章节可以找到这款 Flash 的配置命令为 Write Status Register-2，命令码为 0x31，只要我们向 Flash 发送 0x31，就可以配置 Flash 的总线模式了。 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 如何向 Flash 发送指令？需要将真正要发送的指令写入 SPI 的寄存器SPIC_CSR_06，该寄存器的各个 Bit 可以配置命令码，命令类型，命令是否有效等信息。我们将之前的命令码0x31写入到SPIC_CSR_06的command_code位，然后将SPIC_CSR_06的command_type位设置为write status register，SPI 就会自动将这些信息发送给 Flash。Flash 接收到命令后，会根据命令码执行配置寄存器的操作。 SPI 读写 Flash\n和配置 Flash 总线模式一样，读写 Flash 也需要配置 SPI 控制器的寄存器，以及配置 Flash 的寄存器。SPI 控制器的寄存器配置和配置 Flash 总线模式一样，只是命令码和命令类型不同。稍有不同的是需要先配置好 SPI 寄存器，配置读写的大小以及读写的地址，然后再配置SPIC_CSR_06。Flash接收到命令后，会根据命令码执行读写操作。主设备只需要读写 Flash 的指定地址即可读写到数据。 SPI 驱动如何适配不同的 Flash 在开发流程中我们并未考虑不同厂家的 Flash 如何操作，只是关心了 WINBOND-W25Q128JW 这款 Flash 的操作。在操作过程中我们可以发现，不同厂家的 Flash 的操作基本一致，只是命令码、页大小、擦除大小等参数不同。我们只要针对不同的 Flash，配置不同的参数即可。但是，如何知道当前 Flash 的参数呢？这就需要用到 SFDP 了。\nSFDP 是 JEDEC 发布的 JESD216 的一个新标准，目前的版本号是 V1.0。简而言之，SFDP（Serial Flash Discoverable Parameters）就相当于一张存储了 FLASH 部分属性的表，此表是不占用 FLASH 本身的存储空间的。SFDP 中的信息自出厂就被固定，只供读取，开发人员可通过发送操作指令 0x5A 来读取当前 FLASH 的 SFDP 相关内容，这有利于开发人员了解 FLASH 之间的差异，提高开发效率，缩短整个开发周期。\n也就是只要 Flash 研发时遵循了 JESD216 这个标准，我们都可以通过发送 0x5A 这个命令码，去获取Flash相关参数。最为关键的就是其中会保存 Flash 厂商的 ID，当我们获取到 Flash 厂商的 ID 时，我们就可以根据 ID 执行不同的配置操作。\n对于 WINBOND-W25Q128JW 这款 Flash，在数据手册的Feature里就可以看到它是支持 SFDP 的： \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/bootrom%E4%B8%ADspi%E5%A6%82%E4%BD%95%E9%80%82%E9%85%8D%E4%B8%8D%E5%90%8C%E5%8E%82%E5%AE%B6%E7%9A%84flash%E8%8A%AF%E7%89%87/","summary":"\u003ch1 id=\"问题背景\"\u003e问题背景\u003c/h1\u003e\n\u003cp\u003e一款 SoC 芯片，会支持多种方式启动，比如从 NAND Flash、SPI Flash、eMMC、USB、UART 启动。对于 SPI Flash 启动，BootROM 需要知道 SPI Flash 的型号、容量、页大小、擦除大小等信息，以便正确读取、写入、擦除 SPI Flash。但是，不同厂家的 SPI Flash，这些参数可能不同，而 ROM 中的代码是无法修改的，并且容量有限，如何以最小的代码量，适配不同厂家的 SPI Flash 呢？\u003c/p\u003e","title":"BootROM 中 SPI 如何适配不同厂家的 Flash 芯片"},{"content":"GitHub Copilot CLI 是一个命令行工具，它允许你在终端中使用 GitHub Copilot。你可以使用它来获取代码建议，这些建议是由 OpenAI 的 GPT-4 模型生成的。这个工具可以在任何支持命令行的环境中使用，包括 Visual Studio Code 的集成终端。\n参考官方文档：Using GitHub Copilot in the CLI - GitHub Docs\n安装 前提：\n需要订阅Github Copilot，每月$10。\n需要安装GH CLI\n订阅自行解决，接下来安装GH CLI：\nsudo mkdir -p -m 755 /etc/apt/keyrings \u0026amp;\u0026amp; wget -qO- https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg \u0026gt; /dev/null \\ \u0026amp;\u0026amp; sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \\ \u0026amp;\u0026amp; echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\u0026#34; | sudo tee /etc/apt/sources.list.d/github-cli.list \u0026gt; /dev/null \\ \u0026amp;\u0026amp; sudo apt update \\ \u0026amp;\u0026amp; sudo apt install gh -y 如果没法安装，可以下载deb文件手动安装。Release GitHub CLI 2.46.0 · cli/cli\n安装完GH CLI后，安装Copilot CLI：\n$ gh auth login # 选择登录账号类型为Github.com ? What account do you want to log into? [Use arrows to move, type to filter] \u0026gt; GitHub.com GitHub Enterprise Server # 选择传输协议为SSH ? What is your preferred protocol for Git operations on this host? [Use arrows to move, type to filter] HTTPS \u0026gt; SSH # 选择一个本地的公钥，并命名SSH key的名称 ? Title for your SSH key: (GitHub CLI) wsl2 # 选择验证方式为使用浏览器验证 ? How would you like to authenticate GitHub CLI? [Use arrows to move, type to filter] \u0026gt; Login with a web browser Paste an authentication token ! First copy your one-time code: 7AAA-SA47 # 回车后会弹出浏览器，输入验证码即可 Press Enter to open github.com in your browser... ! Failed opening a web browser at https://github.com/login/device fork/exec /usr/bin/winchrome: exec format error Please try entering the URL in your browser manually WSL2 环境下可能会出现无法打开浏览器的情况，可以手动打开浏览器输入地址验证https://github.com/login/device。\n使用 支持两个命令：\n# 解释代码 gh copilot explain # 获取命令行建议 gh copilot suggest 示例：\n$ gh copilot explain \u0026#34;sudo apt-get\u0026#34; Welcome to GitHub Copilot in the CLI! version 1.0.1 (2024-03-22) I\u0026#39;m powered by AI, so surprises and mistakes are possible. Make sure to verify any generated code or suggestions, and share feedback so that we can learn and improve. For more information, see https://gh.io/gh-copilot-transparency Explanation: • sudo is used to run a command with elevated rights, typically as a superuser. • apt-get is the Ubuntu package manager. • It is used to manage packages on the system, including installing, updating, and removing software packages. • It requires administrative privileges to perform these operations. • Additional sub-commands can be used with apt-get to perform specific tasks, such as install, remove, update, etc. $ gh copilot suggest \u0026#34;Install git\u0026#34; Welcome to GitHub Copilot in the CLI! version 1.0.1 (2024-03-22) I\u0026#39;m powered by AI, so surprises and mistakes are possible. Make sure to verify any generated code or suggestions, and share feedback so that we can learn and improve. For more information, see https://gh.io/gh-copilot-transparency ? What kind of command can I help you with? [Use arrows to move, type to filter] \u0026gt; generic shell command gh command git command Suggestion: sudo apt-get install git ? Select an option [Use arrows to move, type to filter] \u0026gt; Copy command to clipboard Explain command Execute command Revise command Rate response Exit gh copilot 默认提供了这两个命令的别名，无需输入完整命令，可以直接使用：\n# ghce 为 gh copilot explain 的别名 ghce \u0026#34;sudo apt-get\u0026#34; # ghcs 为 gh copilot suggest 的别名 ghcs \u0026#34;install git\u0026#34; 为了便于在每个终端中使用 gh copilot cli，将以下配置放到配置文件中：\necho \u0026#39;eval \u0026#34;$(gh copilot alias -- zsh)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc ","permalink":"https://lifeislife.cn/posts/github-copilot-cli%E5%91%BD%E4%BB%A4%E8%A1%8Cai%E5%B7%A5%E5%85%B7/","summary":"\u003cp\u003eGitHub Copilot CLI 是一个命令行工具，它允许你在终端中使用 GitHub Copilot。你可以使用它来获取代码建议，这些建议是由 OpenAI 的 GPT-4 模型生成的。这个工具可以在任何支持命令行的环境中使用，包括 Visual Studio Code 的集成终端。\u003c/p\u003e","title":"GitHub Copilot CLI命令行AI工具"},{"content":"Windows上通过WSL2进行Linux开发，但是有时候需要开发带GUI的引用，这样就需要将图像转发。\n配置Windows 下载安装XMing，启动Xlaunch。\n选择MultiWindow 设置Display number为10（可以自行设置，主要是需要和后面在WSL2中设置的变量保持一致） 选择Start no client（Windows的XMing是被动等待接收图像数据，所以选择该项） 一直下一页，其余保持默认，点击完成即可。 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 配置VSCode 安装RemoteX11插件，直接在插件中心搜索安装即可。\n打开设置页面，搜索Remote x11，找到如下配置项，将Display Number配置为10\n\u003c!DOCTYPE html\u003e Responsive Image 配置WSL2 安装xclock用于测试\nsudo apt-get install xclock 设置环境变量\nexport DISPLAY=localhost:10.0 # 或者 export DISPLAY=:0 运行xclock查看结果\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/remotex11-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%B8%A6gui%E5%BA%94%E7%94%A8/","summary":"\u003cp\u003eWindows上通过WSL2进行Linux开发，但是有时候需要开发带GUI的引用，这样就需要将图像转发。\u003c/p\u003e\n\u003ch2 id=\"配置windows\"\u003e配置Windows\u003c/h2\u003e\n\u003cp\u003e下载安装XMing，启动Xlaunch。\u003c/p\u003e","title":"RemoteX11 远程调试带GUI应用"},{"content":"以前对软件包的构建不太了解，喜欢随意修改软件源列表，软件源和当前系统的版本不一致就会出现安装了一个依赖较多的软件包后会出现连锁反应，修改了所有依赖的软件包版本，导致系统故障。最常出现的就是修改了GCC版本，导致GLIBCXX版本不一致，导致系统软件无法运行。\n如果你的系统还能正常安装软件，那么修改软件源和当前系统版本保存一致，然后更新软件，并重新安装GCC即可解决问题。具体步骤如下：\n# 修改软件源 sudo vim /etc/apt/sources.list # 检查当前系统版本 lsb_release -a # 将软件源修改为当前系统版本的软件源，Ubuntu系统版本号对应的软件源列表可以在https://wiki.ubuntu.com/Releases查看 # 更新软件 sudo apt update # 安装GCC，build-essential包含了GCC sudo apt install build-essential 如果你和我一样倒霉，连 apt 都无法使用，那么可以使用 dpkg 命令手动安装 GCC。\n因为误操作在 Ubuntu 20.04 上安装了 Ubuntu 18.04 的 GCC，导致系统软件无法运行，apt 也无法使用，所以只能手动安装 GCC。\napt: libx86_64-linux-gnu-libstdc++.so.6: version `GLIBCXX_3.4.29\u0026#39; not found (required by libx86_64-linux-gnulibapt-private.so.0.0) 既然libstdc++版本不一致，我们就去下载对应版本的GCC，访问https://packages.ubuntu.com/，在下方的搜索框中输入libstdc++6，选择对应的系统版本，然后下载对应的GCC。\n\u003c!DOCTYPE html\u003e Responsive Image 点击搜索结果，点击系统的架构，一般为amd64，\n\u003c!DOCTYPE html\u003e Responsive Image 具体下载地址比较隐蔽，直接点击红框的链接没有反应，你可以右键另存为到本地，我习惯复制链接后用wget下载。\n\u003c!DOCTYPE html\u003e Responsive Image 下载完成后，使用dpkg命令安装GCC。\nsudo dpkg -i libstdc++6_12.3.0-1ubuntu1\\~22.04_amd64.deb 之后可以检查一下缺失的GLIBCXX版本已经安装。\n$ strings /lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX GLIBCXX_3.4 GLIBCXX_3.4.1 GLIBCXX_3.4.2 GLIBCXX_3.4.3 GLIBCXX_3.4.4 GLIBCXX_3.4.5 GLIBCXX_3.4.6 GLIBCXX_3.4.7 GLIBCXX_3.4.8 GLIBCXX_3.4.9 GLIBCXX_3.4.10 GLIBCXX_3.4.11 GLIBCXX_3.4.12 GLIBCXX_3.4.13 GLIBCXX_3.4.14 GLIBCXX_3.4.15 GLIBCXX_3.4.16 GLIBCXX_3.4.17 GLIBCXX_3.4.18 GLIBCXX_3.4.19 GLIBCXX_3.4.20 GLIBCXX_3.4.21 GLIBCXX_3.4.22 GLIBCXX_3.4.23 GLIBCXX_3.4.24 GLIBCXX_3.4.25 GLIBCXX_3.4.26 GLIBCXX_3.4.27 GLIBCXX_3.4.28 GLIBCXX_3.4.29 GLIBCXX_3.4.30 GLIBCXX_DEBUG_MESSAGE_LENGTH 此时apt 应该就可以正常使用了，我们只需要修复一下所有软件包，让它回到正确的版本即可恢复系统。\nsudo apt --fix-broken install ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3%E7%B3%BB%E7%BB%9F%E4%BE%9D%E8%B5%96%E9%94%99%E8%AF%AFglibcxx-3-4-29-not-found/","summary":"\u003cp\u003e以前对软件包的构建不太了解，喜欢随意修改软件源列表，软件源和当前系统的版本不一致就会出现安装了一个依赖较多的软件包后会出现连锁反应，修改了所有依赖的软件包版本，导致系统故障。最常出现的就是修改了GCC版本，导致GLIBCXX版本不一致，导致系统软件无法运行。\u003c/p\u003e","title":"解决系统依赖错误GLIBCXX_3.4.29 not found"},{"content":"repo 源配置解析 openEuler 的软件源配置文件位于/etc/yum.repos.d/目录下，以.repo 为后缀名，文件名可以任意取，但是必须以.repo 结尾。\n#generic-repos is licensed under the Mulan PSL v2. #You can use this software according to the terms and conditions of the Mulan PSL v2. #You may obtain a copy of Mulan PSL v2 at: # http://license.coscl.org.cn/MulanPSL2 #THIS SOFTWARE IS PROVIDED ON AN \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR #IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR #PURPOSE. #See the Mulan PSL v2 for more details. [OS] name=OS baseurl=http://repo.openeuler.org/openEuler-23.09/OS/$basearch/ metalink=https://mirrors.openeuler.org/metalink?repo=$releasever/OS\u0026amp;arch=$basearch metadata_expire=1h enabled=1 gpgcheck=1 gpgkey=http://repo.openeuler.org/openEuler-23.09/OS/$basearch/RPM-GPG-KEY-openEuler [source] name=source baseurl=http://repo.openeuler.org/openEuler-23.09/source/ metalink=https://mirrors.openeuler.org/metalink?repo=$releasever\u0026amp;arch=source metadata_expire=1h enabled=1 gpgcheck=1 gpgkey=http://repo.openeuler.org/openEuler-23.09/source/RPM-GPG-KEY-openEuler 其中各个配置项的含义如下：\n[repoid]中的 repoid 为软件仓库（repository）的 ID 号，所有.repo 配置文件中的各 repoid 不能重复，必须唯一。示例中 repoid 为 OS 和 source。 name 为软件仓库描述的字符串，可以任意取，但是建议取一个有意义的名称，方便用户理解。示例中 name 为 OS 和 source。 baseurl 为软件仓库的地址，可以是 http、https、ftp 等协议，也可以是本地目录。 enabled 为是否启用该软件源仓库，可选值为 1 和 0。默认值为 1，表示启用该软件源仓库。示例中 enabled 为 1。 metalink 为动态的镜像地址，用于镜像加速。 metadata_expire 为元数据过期时间，单位为秒。默认值为 90 分钟，即 5400 秒。示例中 metadata_expire 为 1h，即 1 小时。 gpgcheck 可设置为 1 或 0，1 表示进行 gpg（GNU Private Guard）校验，0 表示不进行 gpg 校验，gpgcheck 可以确定 rpm 包的来源是有效和安全的。 gpgkey 为验证签名用的公钥地址，如果 gpgcheck 为 1，则必须设置 gpgkey。 gpgcheck 详解 RPM-GPG-KEY 是一个公共密钥，用于验证由该密钥签名的RPM包的真实性和完整性。在使用 yum 或 dnf 这样的包管理工具时，这些工具会使用 GPG 密钥来验证软件包的签名，以确保软件包来自于可信的源，且未被篡改。\n命名约定： RPM-GPG-KEY 是一个命名约定，通常与其所属的仓库或发行版相关。例如，如果你在使用某个特定发行版的官方仓库，它可能会提供一个 RPM-GPG-KEY 文件来进行软件包签名验证。如openEuler官方仓库提供的 RPM-GPG-KEY 文件名为 RPM-GPG-KEY-openEuler。\n密钥生成： 这个密钥是通过 GPG（GNU Privacy Guard）工具生成的。GPG 是一个用于进行加密和签名的开源工具。RPM-GPG-KEY 文件包含了一个公钥，该公钥由仓库所有者使用私钥签署软件包，而用户使用公钥验证软件包。\n验证软件包： 当用户使用 yum 或 dnf 安装软件包时，这些工具会检查软件包的签名，并使用相应的 RPM-GPG-KEY 文件中的公钥来验证签名。如果验证通过，工具会认为软件包是可信的，否则将会发出警告或拒绝安装。\n导入密钥： 为了使用 RPM-GPG-KEY 文件，用户通常需要将密钥导入到本地系统中。这通常可以通过运行类似于以下命令的导入密钥的操作来完成：\nrpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-openEuler 上述命令中的 /etc/pki/rpm-gpg/RPM-GPG-KEY-openEuler 路径可能会因发行版和配置而有所不同。\nRPM包签名 对于发布的 RPM 包进行 GPG 签名是一种重要的安全措施，可以确保接收者能够验证软件包的真实性和完整性。以下是一般的步骤：\n生成 GPG 密钥： 如果你还没有 GPG 密钥对，你需要使用 GPG 工具生成一对密钥，包括私钥和公钥。你可以运行以下命令来生成密钥：\ngpg --gen-key 当你运行 gpg --gen-key 命令时，它会启动 GPG（GNU Privacy Guard）的密钥生成过程。这个过程将引导你提供一些必要的信息以生成密钥对，包括私钥和公钥。以下是这个命令的详细步骤：\n选择密钥类型： 你将被要求选择密钥的类型。通常，默认的 RSA 和 DSA 都是可接受的选择，你可以通过键入数字来选择。\n选择密钥大小： 你将被要求选择密钥的大小。通常，默认值（通常是2048位）是足够的，但你也可以选择更大的值。\n选择密钥的有效期： 你将被要求选择密钥的有效期。你可以选择密钥永久有效，或者在一段特定的时间内有效。如果你选择了特定的时间，你需要输入一个表示有效期的值，例如1y表示一年，1m表示一个月。\n提供用户标识信息： 你将被要求提供与密钥相关联的用户标识信息。这包括你的真实姓名、电子邮件地址和一个可选的注释。\n确认提供的信息： GPG 将显示你提供的信息并询问你是否确认。如果确认无误，你可以输入 O 或直接按回车键。\n输入保护密语（passphrase）： 你将被要求输入保护密语，用于保护你的私钥。请确保选择一个强密码。\n等待密钥生成： GPG 将使用提供的信息生成密钥对。这可能需要一些时间，具体取决于你选择的密钥大小。\n生成完成： 一旦生成完成，你将看到一条消息表明密钥生成成功。\n在整个过程中，你将看到类似以下的一些提示：\ngpg: key ABCDEFGH marked as ultimately trusted gpg: revocation certificate stored as \u0026#39;/home/your_user/.gnupg/openpgp-revocs.d/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.rev\u0026#39; public and secret key created and signed. gpg: checking the trustdb gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model gpg: depth: 0 valid: 2 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 2u pub 2048R/XXXXXXXX 2024-01-01 [expires: 2024-01-01] Key fingerprint = XXXX YYYY ZZZZ AAAA BBBB CCCC DDDD EEEE FFFF 1111 uid Your Name \u0026lt;your.email@example.com\u0026gt; sub 2048R/YYYYYYYY 2024-01-01 [expires: 2024-01-01] 在这个例子中，XXXXXXXX 是你的密钥 ID，YYYYYYYY 是子密钥的 ID。你可以使用这些 ID 来引用你的密钥。\n导出公钥： 生成密钥后，你需要将公钥导出。运行以下命令：\ngpg --output RPM-GPG-KEY-your-repo --armor --export your@email.com 这将生成一个 ASCII 格式的公钥文件 RPM-GPG-KEY-your-repo，你可以与软件包一起发布。\n为 RPM 包签名： 在构建 RPM 包时，使用 rpmbuild 命令时，可以通过添加 --sign 选项来指示 rpmbuild 对 RPM 包进行签名。例如：\nrpmbuild -ba your-package.spec --sign 当你执行 rpmbuild -ba your-package.spec --sign 命令时，rpmbuild 会使用默认的 GPG 密钥进行签名。这通常是你在系统上配置为默认 GPG 密钥的密钥。\n你可以通过检查 rpmbuild 使用的 GPG 密钥来确认它是哪个密钥：\nrpm -q gpg-pubkey --qf \u0026#39;%{name}-%{version}-%{release} --\u0026gt; %{summary}\\n\u0026#39; 这个命令将显示系统上安装的 GPG 公钥，其中默认的密钥可能是 \u0026ldquo;gpg-pubkey-xxxxxxxx-yyyyyyyy\u0026rdquo;。你可以根据密钥的 \u0026ldquo;xxxxxxxx-yyyyyyyy\u0026rdquo; 部分来确定默认使用的 GPG 密钥。\n如果你想使用不同的 GPG 密钥进行签名，可以在 rpmbuild 命令中使用 --signwith 选项，例如：\nrpmbuild -ba your-package.spec --signwith \u0026lt;key-id\u0026gt; 其中 \u0026lt;key-id\u0026gt; 是你想要使用的 GPG 密钥的 ID。这会覆盖默认的密钥。确保你在构建和签名 RPM 包时使用的是正确的 GPG 密钥。\n导入密钥： 为了验证你的软件包，用户需要导入你的公钥。他们可以运行以下命令：\nrpm --import RPM-GPG-KEY-your-repo 发布： 将签名的 RPM 包和公钥一起发布。确保用户知道他们可以使用导入的公钥来验证软件包的签名。\n","permalink":"https://lifeislife.cn/posts/repo%E6%BA%90%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/","summary":"\u003ch1 id=\"repo-源配置解析\"\u003erepo 源配置解析\u003c/h1\u003e\n\u003cp\u003eopenEuler 的软件源配置文件位于/etc/yum.repos.d/目录下，以.repo 为后缀名，文件名可以任意取，但是必须以.repo 结尾。\u003c/p\u003e","title":"repo源配置解析"},{"content":"初学 Linux 内核或者第一次编译使用内核模块时经常会遇到类似这样的错误：\ninsmod: ERROR: could not insert module kvm.ko: Invalid module format 这个报错通常由于当前插入kvm.ko的version magic版本信息与正在运行的 kernel 的version magic版本不一致导致的。\n内核校验模块的流程 我们从问题出发，看看内核是如何校验模块的。搜索了内核源码，找到了在函数check_version中抛出了disagrees about version of symbol错误信息，我们根据源码来回溯一下整个过程。\n// kernel/module.c static int check_version(const struct load_info *info, const char *symname, struct module *mod, const s32 *crc) { Elf_Shdr *sechdrs = info-\u0026gt;sechdrs; unsigned int versindex = info-\u0026gt;index.vers; unsigned int i, num_versions; struct modversion_info *versions; /* Exporting module didn\u0026#39;t supply crcs? OK, we\u0026#39;re already tainted. */ if (!crc) return 1; /* No versions at all? modprobe --force does this. */ if (versindex == 0) return try_to_force_load(mod, symname) == 0; versions = (void *) sechdrs[versindex].sh_addr; num_versions = sechdrs[versindex].sh_size / sizeof(struct modversion_info); for (i = 0; i \u0026lt; num_versions; i++) { u32 crcval; if (strcmp(versions[i].name, symname) != 0) continue; if (IS_ENABLED(CONFIG_MODULE_REL_CRCS)) crcval = resolve_rel_crc(crc); else crcval = *crc; if (versions[i].crc == crcval) return 1; pr_debug(\u0026#34;Found checksum %X vs module %lX\\n\u0026#34;, crcval, versions[i].crc); goto bad_version; } /* Broken toolchain. Warn once, then let it go.. */ pr_warn_once(\u0026#34;%s: no symbol version for %s\\n\u0026#34;, info-\u0026gt;name, symname); return 1; bad_version: pr_warn(\u0026#34;%s: disagrees about version of symbol %s\\n\u0026#34;, info-\u0026gt;name, symname); return 0; } 参数说明：\ninfo: 包含正在加载信息的结构体。 symname: 需要查找对比的符号的名称。 mod: 表示模块的结构体。 crc: 当前正在运行的内核的模块符号的 CRC（Cyclic Redundancy Check）值 如果 CRC 为空，不检查直接 PASS 如果模块中没有_versions 小节，表示模块没有开启 CRC 如果开启了 CONFIG_MODULE_FORCE_LOAD，则强制加载，内核标记为 tainted，直接 PASS 如果没有开启 CONFIG_MODULE_FORCE_LOAD，则报错 如果模块中有_versions 小节，没有找到 module_layout 符号，报 warning，直接 PASS 如果模块中有_versions 小节，找到 module_layout 符号 对比_versions 小节中的 CRC 和参数中的 CRC，如果一致，PASS 如果不一致，报错 插播一句，CRC是什么？在 Linux 内核中，模块符号 CRC（Cyclic Redundancy Check）是一种校验值，用于确保模块中的符号（函数、变量等）在加载时与内核中的符号一致。当模块被构建时，针对每个符号都会计算一个 CRC 值，然后将这些 CRC 值保存在模块的符号版本表中。简单理解就是如果要保持CRC不变，需要满足两个条件：\n语法保持不变 遵守这个条件，说明如果模块在新内核下重新编译，那应该没有任何语法问题。 即导出符号的类型名没有变化，如果是函数，则要求参数和返回值类型没有任何变化；如果这些类型是结构体的话，结构体的成员名也没有有任何变化。 语义保持不变 这要求符号的类型不能有变化，如果类型本身是结构体(struct)，则它成员的类型不能有变化，成员在结构体内的位置不能有变化，以及成员本身不能增删。 如果想要深入了解如何计算CRC可以参考这篇博客：Linux内核模块符号CRC检查机制-CSDN博客 分析代码我们可以知道，内核会通过遍历正在加载的模块的版本信息的数组versions，从中查找与给定符号名称匹配的版本信息。如果找到匹配的版本信息，则计算 CRC 值，与参数中的 CRC 值进行比较。（通过后续分析我们知道参数的 CRC 就是正在运行的内核的 module_layout 符号的 CRC）如果匹配，表示版本一致，返回 1。如果不匹配，打印调试信息，并跳转到 bad_version，输出警告信息。\n这里有两个疑问，\nversions 内容是怎么链接到模块的 elf 文件中的？ 我们找到模块的mod.c文件，打开可以发现以下内容：\nMODULE_INFO(vermagic, VERMAGIC_STRING); MODULE_INFO(name, KBUILD_MODNAME); __visible struct module __this_module __section(.gnu.linkonce.this_module) = { .name = KBUILD_MODNAME, .init = init_module, #ifdef CONFIG_MODULE_UNLOAD .exit = cleanup_module, #endif .arch = MODULE_ARCH_INIT, }; #ifdef CONFIG_RETPOLINE MODULE_INFO(retpoline, \u0026#34;Y\u0026#34;); #endif static const struct modversion_info ____versions[] __used __section(__versions) = { { 0x3e549f1d, \u0026#34;module_layout\u0026#34; }, { 0x5138e6ba, \u0026#34;param_ops_int\u0026#34; }, { 0x183b57f9, \u0026#34;phy_ethtool_nway_reset\u0026#34; }, { 0x6e5363eb, \u0026#34;eth_validate_addr\u0026#34; }, { 0x4df55e5b, \u0026#34;usb_deregister\u0026#34; }, { 0x8e48f69b, \u0026#34;usb_register_driver\u0026#34; }, } 这个文件是在编译过程中调用了scripts/modpost脚本生成的，它的功能是在里面增加了 2 个__section，.gnu.linkonce.this_module和__versions。__versions 小节的内容就是一些字符串和值组成的数组，check_version就是解析这个小节去做验证。\nCRC 值哪来的？ 我们继续向上跟踪，找到函数check_modstruct_version，其中find_symbol会在内核符号表中查找给定符号名称的符号信息，接着调用check_version函数，传入符号名称、模块结构体和 CRC 值，进行版本匹配。\n// kernel/module.c static inline int check_modstruct_version(const struct load_info *info, struct module *mod) { const s32 *crc; /* * Since this should be found in kernel (which can\u0026#39;t be removed), no * locking is necessary -- use preempt_disable() to placate lockdep. */ preempt_disable(); if (!find_symbol(\u0026#34;module_layout\u0026#34;, NULL, \u0026amp;crc, true, false)) { preempt_enable(); BUG(); } preempt_enable(); return check_version(info, \u0026#34;module_layout\u0026#34;, mod, crc); } // 获取当前运行内核 module_layout 函数的 crc 值 find_symbol(\u0026#34;module_layout\u0026#34;, NULL, \u0026amp;crc, true, false) each_symbol_section(find_exported_symbol_in_section, \u0026amp;fsa) // 遍历内核三个导出符号表段__start___ksymtab，__start___ksymtab_gpl 和__start___ksymtab_gpl_future，为每段调用 find_symbol_in_section each_symbol_in_section(arr, ARRAY_SIZE(arr), NULL, fn, data) // 遍历内核每个已加载模块的三个导出符号表段 mod-\u0026gt;syms,mod-\u0026gt;gpl_syms,mod-\u0026gt;gpl_future_syms，为每段调用 find_symbol_in_section each_symbol_in_section(arr, ARRAY_SIZE(arr), mod, fn, data) // 对导出符号表进行二分查找，按照字符串排序，符号表的地址按照地址排序 find_exported_symbol_in_section(const struct symsearch *syms,struct module *owner,void *data) Linux 对可装载模块采取了两层验证：除了上述的模块 CRC 值校验外还有 vermagic 的检查。模块 vermagic（即 Version Magic String）保存了模块编译时的内核版本以及 SMP 等配置信息，当模块 vermagic 与主机信息不相符时也无法加载模块。\n在内核中load_module函数调用check_modstruct_version函数完成 CRC 校验后，就会继续调用layout_and_allocate --\u0026gt; check_modinfo 完成 vermagic 校验。\n// kernel/module.c static int check_modinfo(struct module *mod, struct load_info *info, int flags) { const char *modmagic = get_modinfo(info, \u0026#34;vermagic\u0026#34;); int err; if (flags \u0026amp; MODULE_INIT_IGNORE_VERMAGIC) modmagic = NULL; /* This is allowed: modprobe --force will invalidate it. */ if (!modmagic) { err = try_to_force_load(mod, \u0026#34;bad vermagic\u0026#34;); if (err) return err; } else if (!same_magic(modmagic, vermagic, info-\u0026gt;index.vers)) { pr_err(\u0026#34;%s: version magic \u0026#39;%s\u0026#39; should be \u0026#39;%s\u0026#39;\\n\u0026#34;, info-\u0026gt;name, modmagic, vermagic); return -ENOEXEC; } ... return 0; } get_modinfo 会获取内核中的 vermagic 信息，模块 vermagic 信息则被保存在了 ELF 的 .modinfo 小节中。这里我们说的 vermagic 就是下文提到的拓展版本信息，它就是系统配置信息组成的一个字符串。\n如何解决模块校验错误 Linux 对可装载模块采取了两层验证，我们需要分别从 CRC 和 vermagic 两个方面来解决模块校验错误。首先从简单的 vermagic 校验开始。我们需要保证运行的内核版本与模块编译时的内核版本一致，这样才能保证 vermagic 校验通过。首先了解如何查看内核版本以及模块版本信息，然后修改内核模块版本信息。\n解决 vermagic 校验错误 如何查看内核版本以及模块版本信息 uname参数功能：\n-s, 输出 kernel 名称； -n, 输出主机名； -r, 输出 kernel 发行版本号； -v, 输出操作系统版本； -m, 输出主机的硬件架构名称； -p, 输出处理器类型； -i, 输出硬件平台； -o, 输出操作系统名称 -a, 输出所有信息 # 输出kernel发行版本号 uname -r 6.4.0-10.1.0.20.oe2309.riscv64 # 输出所有信息 uname -a Linux openeuler 6.4.0-10.1.0.20.oe2309.riscv64 #1 SMP Sat Oct 7 06:19:28 UTC 2023 riscv64 riscv64 riscv64 GNU/Linux modinfo 可以查看模块信息，包括模块vermagic信息。\nmodinfo kvm.ko filename: /root/build-kernel/kernel/./arch/riscv/kvm/kvm.ko license: GPL author: Qumranet srcversion: 5DA13DC0E55100B5FE1D56A depends: intree: Y name: kvm vermagic: 6.4.0 SMP mod_unload modversions riscv parm: halt_poll_ns:uint parm: halt_poll_ns_grow:uint parm: halt_poll_ns_grow_start:uint parm: halt_poll_ns_shrink:uint 其中vermagic就是version magic版本信息，可以看到当前kvm.ko的version magic版本信息为6.4.0。与前文的uname -r输出的 kernel 发行版本号6.4.0-10.1.0.20.oe2309.riscv64不一致。所以会报错。\n修改内核模块版本信息 修改基础版本信息 打开内核源代码根目录下的 Makefile 文件。你会找到一个包含内核版本信息的地方，类似于：\n# SPDX-License-Identifier: GPL-2.0 VERSION = 6 PATCHLEVEL = 4 SUBLEVEL = 0 EXTRAVERSION = 表示内核版基础本号为6.4.0。\n修改拓展版本信息 kernel 引入了一些配置来增强版本信息，在内核源码的\u0026quot;include/linux/vermagic.h\u0026quot;下我们可以看到模块的健全版本信息，如下默认配置的有：\n/* Simply sanity version stamp for modules. */ #ifdef CONFIG_SMP #define MODULE_VERMAGIC_SMP \u0026#34;SMP \u0026#34; #else #define MODULE_VERMAGIC_SMP \u0026#34;\u0026#34; #endif #ifdef CONFIG_PREEMPT_BUILD #define MODULE_VERMAGIC_PREEMPT \u0026#34;preempt \u0026#34; #elif defined(CONFIG_PREEMPT_RT) #define MODULE_VERMAGIC_PREEMPT \u0026#34;preempt_rt \u0026#34; #else #define MODULE_VERMAGIC_PREEMPT \u0026#34;\u0026#34; #endif #ifdef CONFIG_MODULE_UNLOAD #define MODULE_VERMAGIC_MODULE_UNLOAD \u0026#34;mod_unload \u0026#34; #else #define MODULE_VERMAGIC_MODULE_UNLOAD \u0026#34;\u0026#34; #endif #ifdef CONFIG_MODVERSIONS #define MODULE_VERMAGIC_MODVERSIONS \u0026#34;modversions \u0026#34; #else #define MODULE_VERMAGIC_MODVERSIONS \u0026#34;\u0026#34; #endif #ifdef RANDSTRUCT #include \u0026lt;generated/randstruct_hash.h\u0026gt; #define MODULE_RANDSTRUCT \u0026#34;RANDSTRUCT_\u0026#34; RANDSTRUCT_HASHED_SEED #else #define MODULE_RANDSTRUCT #endif #define VERMAGIC_STRING \\ UTS_RELEASE \u0026#34; \u0026#34; \\ MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT \\ MODULE_VERMAGIC_MODULE_UNLOAD MODULE_VERMAGIC_MODVERSIONS \\ MODULE_ARCH_VERMAGIC \\ MODULE_RANDSTRUCT 其中，\u0026quot;UTS_RELEASE\u0026quot;的配置在内核源码的\u0026quot;include/generated/utsrelease.h\u0026quot;下可以看到，utsrelease.h的内容是由Makefile和``.config的内容来生成的，当成功编译kernel以后，utsrelease.h`得到更新，\n#defineUTS_RELEASE \u0026#34;6.4.0\u0026#34; 那么前文\u0026quot;6.4.0-d46299ae\u0026quot;中的\u0026quot;-d46299ae\u0026quot;是如何得来的呢？其实这个是开发者使用了 Git 来管理代码。当你修改或者提交代码以后，每次编译内核后，在\u0026quot;UTS_RELEASE\u0026quot;后面就会看到一串哈希值，例如\u0026quot;6.4.0-d46299ae\u0026quot;，其中\u0026quot;-d46299ae\u0026quot;这个就是 Git 版本控制而产生的哈希值。发行版本号只是各个厂商用于区别自己发布的不同时期的 kernel 版本或者产品版本而产生的编号，完全由各厂商自己定义。\n解决 CRC 校验错误 我们可以通过一些手段修改新模块的 module_layout 的 CRC 与内核CRC相同，再插入。/boot目录下通常有个在symvers-\u0026lt;kernel_version\u0026gt;.gz 文件通常包含了内核模块的符号版本信息。这个文件是由 Linux 内核构建时生成的，用于记录在该内核版本下构建的模块的符号信息，包括函数和变量的名称、版本号等。里面就保存了内核的 module_layout 的 CRC 值。我们可以使用gzip -d命令解压这个文件，找到 module_layout 的 CRC 值，记录下来。\n方法一：使用 16 进制编辑器修改模块文件，将 module_layout 的值修改为相同的值，再插入。 在 Linux 中，可以使用 hexdump 和 xxd 等工具查看二进制文件的内容，并尝试编辑。下面是一种使用 xxd 查看和修改二进制文件的方法：\n使用 xxd 将二进制文件转换为十六进制文本：\nxxd /usr/src/linux-6.4.0-10.1.0.20.oe2309.riscv64/arch/riscv/kvm/kvm.ko \u0026gt; kvm_hex.txt 这将创建一个名为 kvm_hex.txt 的文本文件，其中包含 kvm.ko 的十六进制表示。\n使用文本编辑器（如 nano 或 vim）打开 kvm_hex.txt，找到并编辑 module_layout 的值。请确保你了解所做更改的含义，并且只修改你确信的内容。\n保存并关闭文本编辑器。\n使用 xxd 将修改后的十六进制文本转换回二进制文件：\nxxd -r kvm_hex.txt \u0026gt; /usr/src/linux-6.4.0-10.1.0.20.oe2309.riscv64/arch/riscv/kvm/kvm.ko 这将覆盖原始的 kvm.ko 文件。\n方法二：修改 Module.symvers\n# 清理编译结果。不要使用 make distclean，这会删除.config 文件以及 Module.symvers 文件 make clean # 修改 Module.symvers 文件 sed -i \u0026#39;/module_layout/ s/0x[0-9a-f][0-9a-f]*/0xdf88831e/\u0026#39; Module.symvers # 重新编译模块 make M=./arch/riscv/kvm/ -j33 # 检查模块的 module_layout modprobe --dump-modversions /usr/src/linux-6.4.0-10.1.0.20.oe2309.riscv64/arch/riscv/kvm/kvm.ko | grep module_layout 0xdf88831e 如何生成 .mod.c 文件 如果是自己写的模块，可以根据下面的命令编译模块，就可以得到.mod.c文件，它是源文件到.mod.o文件的一个中间文件。\nmake -C /root/build-kernel/kernel M=/driver_study/ modules -j22 如果是用内核自己的模块，执行make modules命令，也可以得到.mod.c文件。但是一般执行make -j22命令就不会生成这些文件，我们可以找一个启用的内核模块，例如kvm.ko，执行下面的命令，就可以得到.mod.c文件。不能随便找个模块，必须在 config 中开启的模块，否则会报错undefined!。\nmake M=./arch/riscv/kvm modules -j22 ","permalink":"https://lifeislife.cn/posts/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/","summary":"\u003cp\u003e初学 Linux 内核或者第一次编译使用内核模块时经常会遇到类似这样的错误：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003einsmod: ERROR: could not insert module kvm.ko: Invalid module format \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个报错通常由于当前插入\u003ccode\u003ekvm.ko\u003c/code\u003e的\u003ccode\u003eversion magic\u003c/code\u003e版本信息与正在运行的 kernel 的\u003ccode\u003eversion magic\u003c/code\u003e版本不一致导致的。\u003c/p\u003e","title":"Linux内核模块校验机制"},{"content":"binfmt_misc 简介 binfmt_misc 是 Linux 内核提供的一个机制，它允许用户空间定义新的二进制格式，并将它们与相应的解释器关联起来。这个机制使得在 Linux 上能够动态地注册并运行不同架构的二进制可执行文件，从而支持交叉编译和多架构环境。\n具体来说，binfmt_misc 的功能可以通过 /proc/sys/fs/binfmt_misc/ 目录下的文件系统接口实现。这个目录下的文件用于注册和管理二进制格式和相应解释器之间的关联关系。\n下面是一些与 binfmt_misc 相关的重要概念和文件：\n注册表文件： 在 /proc/sys/fs/binfmt_misc/ 目录下，每个注册的二进制格式都有一个对应的注册表文件。这些文件的命名通常遵循格式 \u0026lt;格式名称\u0026gt;，例如 qemu-riscv64。 注册和注销： 用户空间可以通过在注册表目录下创建文件来注册新的二进制格式。这可以通过写入注册表文件的方式完成。相反，通过删除这些文件，可以注销二进制格式的支持。 解释器： 对于每种注册的二进制格式，需要指定相应的解释器，即用于执行这种格式的程序。在注册表文件中，通过 interpreter 字段指定解释器的路径。 参数： 除了解释器，还可以为每个注册的格式指定一些参数。这些参数可以影响如何运行二进制文件。 内核如何通过 binfmt_misc 机制添加新架构的支持？ 可以通过向 /proc/sys/fs/binfmt_misc/register 文件写入注册信息来注册新的二进制格式。告诉内核某一格式的文件用什么解释器来执行。写入的格式如下：\n:name:type:offset:magic:mask:interpreter:flags 各个字段以冒号分隔，部分字段可以缺省，但是冒号需要保留。\n字段含义如下：\nname：二进制格式的名称，比如qemu-riscv64。\ntype：类型为 E 或 M。\n如果是 E，可执行文件格式由其文件扩展名标识：magic 是要与二进制格式相关联的文件扩展名；offset 和 mask 将被忽略。 如果是 M，格式由文件中绝对偏移（默认为 0）处的魔数标识，并且 mask 是一个位掩码（默认为全 0xFF），表示数字中哪些位是有效的。 interpreter：是要作为匹配文件的参数运行的解释器，使用解释器的绝对路径，比如/usr/bin/qemu-riscv64-static。\nflags：可选字段，控制 interpreter 打开文件的行为。共支持 POCF 四种 flag。\nP 表示 preserve-argv[0]，保留原始的 argv[0] 参数。 O 表示 open-binary，binfmt-misc 默认会传递文件的路径，而启用这个参数时，binfmt-misc 会打开文件，传递文件描述符。 C 表示 credentials，即会传递文件的 setuid 等权限，这个选项也隐含了 O。 F 表示 fix binary，binfmt-misc 默认的行为在 spwan 进程时会延迟，这种方式可能会受到 mount 命名空间和 chroot 的影响，设置 F 时会立刻打开二进制文件。 举个例子，如果要在 x86_64 架构的系统上运行 RISC-V 架构的二进制文件，可以通过以下方式注册 RISC-V 二进制格式：\n首先需要添加解释器，通常使用 QEMU 的静态二进制文件作为解释器，在 Ubuntu 系统中我们可以使用以下命令安装：\nsudo apt install qemu-user-static 注册二进制格式：\necho \u0026#39;:qemu-riscv64:M:0:7f454c460201010000000000000000000200f300::/usr/libexec/qemu-binfmt/riscv64-binfmt-P:POCF\u0026#39; \u0026gt; /proc/sys/fs/binfmt_misc/register 表示将 RISC-V 二进制格式注册到 /proc/sys/fs/binfmt_misc/qemu-riscv64 文件中，使用 /usr/libexec/qemu-binfmt/riscv64-binfmt-P 作为解释器，同时传递 POCF 参数。执行了以上命令，内核会自动创建一个 /proc/sys/fs/binfmt_misc/qemu-riscv64 文件，内容如下：\n$ sudo cat /proc/sys/fs/binfmt_misc/qemu-riscv64 enabled interpreter /usr/libexec/qemu-binfmt/riscv64-binfmt-P flags: POCF offset 0 magic 7f454c460201010000000000000000000200f300 mask ffffffffffffff00fffffffffffffffffeffffff 这就完成了 RISC-V 二进制格式的注册。此时，你就可以在 x86_64 架构的系统上运行 RISC-V 架构的二进制文件了。\n使用 Docker 运行 RISC-V 的容器：\n$ docker run --rm -it devops/openeuler-builder:23.09-riscv64 uname -m riscv64 使用封装好的程序简化注册过程 以上的写入 register 文件的方式比较繁琐，可以使用封装好的程序来简化注册过程。\n方式一：\nsudo apt install qemu-user-binfmt 可以安装所有 QEMU 支持的架构。\n方式二：\n# 安装解释器 sudo apt install qemu-user-static # 安装binfmt操作支持 sudo apt install binfmt-support # 开启异构支持 sudo update-binfmts --package=qemu-user-static --enable 同上。\n注销 echo -1 \u0026gt;/proc/sys/fs/binfmt_misc/status # 注销所有注册的条目 echo -1 \u0026gt;/proc/sys/fs/binfmt_misc/qemu-riscv64 # 注销单个条目 或者通过命令行工具完成：\n# 安装binfmt操作支持 sudo apt install binfmt-support # 禁用qemu-riscv64，再次查看/proc/sys/fs/binfmt_misc/发现qemu-riscv64已被删除 sudo update-binfmts --disable qemu-riscv64 Gitea 如何实现多架构应用构建？ Gitea 不会自己运行 Job，而是将 Job 委托给 Runner。Gitea Actions 的 Runner 被称为 act runner，它是一个独立的程序。在接收到 Job 后，act runner 会根据 Job 的内容，启用不同的 Container 来运行 Job。\n为了避免消耗过多资源并影响 Gitea 实例，Gitea 和 Runner 一般运行在不同的机器上。但是同一个 Runner 启动的容器一定在同一台机器上。我这里演示的统一都在同一台 x86 架构的机器上。\n因为都运行在 x86 架构的机器上，所有执行任务的 Container 也一定是 x86 架构的。但是我们了解了上面的 binfmt_misc 机制后，就可以在容器内部通过注册不同架构的二进制格式，从而在 x86 架构的机器上运行不同架构的二进制文件。就可以实现多架构应用构建。\n\u003c!DOCTYPE html\u003e Responsive Image 打开 Gitea 的 tea 的项目源码找到它的 release workflow 文件，可以看到它使用了docker/setup-qemu-action@v3这个 action 来实现多架构构建。\n- name: Set up QEMU uses: docker/setup-qemu-action@v3 查阅action 的源码，可以发现底层实现是通过binfmt_misc来实现的。\nfunc init() { // 定义了一些全局变量 flag.StringVar(\u0026amp;mount, \u0026#34;mount\u0026#34;, \u0026#34;/proc/sys/fs/binfmt_misc\u0026#34;, \u0026#34;binfmt_misc mount point\u0026#34;) flag.StringVar(\u0026amp;toInstall, \u0026#34;install\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;architectures to install\u0026#34;) flag.StringVar(\u0026amp;toUninstall, \u0026#34;uninstall\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;architectures to uninstall\u0026#34;) flag.BoolVar(\u0026amp;flVersion, \u0026#34;version\u0026#34;, false, \u0026#34;display version\u0026#34;) } func install(arch string) error { cfg, ok := configs[arch] // 拼接路径为/proc/sys/fs/binfmt_misc/register，打开这个文件检查是否能够打开成功 register := filepath.Join(mount, \u0026#34;register\u0026#34;) file, err := os.OpenFile(register, os.O_WRONLY, 0) binaryBasename, binaryFullpath, err := getBinaryNames(cfg) if err != nil { return err } // 向/proc/sys/fs/binfmt_misc/register 写入 line，注册二进制格式 line := fmt.Sprintf(\u0026#34;:%s:M:0:%s:%s:%s:%s\u0026#34;, binaryBasename, cfg.magic, cfg.mask, binaryFullpath, flags) _, err = file.Write([]byte(line)) if err != nil { e, ok := err.(*os.PathError) if ok \u0026amp;\u0026amp; e.Err == syscall.EEXIST { return errors.Errorf(\u0026#34;%s already registered\u0026#34;, binaryBasename) } return errors.Errorf(\u0026#34;cannot register %q to %s: %s\u0026#34;, binaryFullpath, register, err) } return nil } Q \u0026amp; A 为何/proc/sys/fs/binfmt_misc/register 文件是只读的？ /proc/sys/fs/binfmt_misc/register 文件是只写的，这是因为在 Linux 中，/proc 文件系统下的很多文件都是通过对文件进行写入来进行配置和控制的。这些文件通常代表内核参数或控制接口，提供了一种方便的方式来与内核进行交互。\n对于 /proc/sys/fs/binfmt_misc/register 文件来说，通过写入注册信息，用户可以向内核注册新的二进制格式，告知内核如何执行特定的二进制文件。这种只写的设计是为了保持简单性和安全性。允许用户在运行时动态地注册新的格式，而不是从文件中读取注册信息，可以提供更大的灵活性。\n虽然 /proc/sys/fs/binfmt_misc/register 文件是只写的，但是通过向文件中写入正确格式的注册信息，用户仍然能够有效地配置新的二进制格式。这种设计符合 Linux 中的文件系统和权限模型。\n参考资料 Kernel Support for miscellaneous Binary Formats (binfmt_misc)\n","permalink":"https://lifeislife.cn/posts/x86%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8gitea-actions%E6%9E%84%E5%BB%BA%E5%A4%9A%E6%9E%B6%E6%9E%84%E5%BA%94%E7%94%A8/","summary":"\u003ch1 id=\"binfmt_misc-简介\"\u003ebinfmt_misc 简介\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003ebinfmt_misc\u003c/code\u003e 是 Linux 内核提供的一个机制，它允许用户空间定义新的二进制格式，并将它们与相应的解释器关联起来。这个机制使得在 Linux 上能够动态地注册并运行不同架构的二进制可执行文件，从而支持交叉编译和多架构环境。\u003c/p\u003e","title":"x86 平台使用 Gitea Actions 构建多架构应用 (binfmt_misc)"},{"content":"卡在55%的基本上驱动已经下载完成，但是还没有安装。这时我们找到下载的文件手动安装即可。一般保存的路径为C:\\Users\\Administrator\\AppData\\Local\\Packages\\B9ECED6F.ArmouryCrate_qmba6cd70vzyy\\LocalState\\SupportTemp，找到需要安装的驱动文件夹，双击setup.exe即可。\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3armoury-crate-%E5%8D%8E%E7%A1%95%E5%A5%A5%E5%88%9B%E4%B8%AD%E5%BF%83%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8%E5%8D%A1%E5%9C%A855/","summary":"\u003cp\u003e卡在55%的基本上驱动已经下载完成，但是还没有安装。这时我们找到下载的文件手动安装即可。一般保存的路径为\u003ccode\u003eC:\\Users\\Administrator\\AppData\\Local\\Packages\\B9ECED6F.ArmouryCrate_qmba6cd70vzyy\\LocalState\\SupportTemp\u003c/code\u003e，找到需要安装的驱动文件夹，双击\u003ccode\u003esetup.exe\u003c/code\u003e即可。\u003c/p\u003e","title":"解决Armoury Crate(华硕奥创中心）安装驱动卡在55%"},{"content":"迁移过程 # 关闭WSL2 wsl --shutdown # 查看WSL2的状态 wsl -l -v NAME STATE VERSION Stopped 2 Ubuntu Stopped 2 # 导出WSL2 wsl --export Ubuntu D:\\wsl2\\ubuntu.tar 正在导出，这可能需要几分钟时间。 操作成功完成。 # 删除WSL2 wsl --unregister Ubuntu 正在注销。 操作成功完成。 # 导入WSL2 wsl --import Ubuntu D:\\wsl2 D:\\wsl2\\ubuntu.tar --version 2 正在导入，这可能需要几分钟时间。 操作成功完成。 # 设置默认用户，如果不设置将会使用root用户，因为之前我一直使用自己创建的用户，所以需要设置，否则zsh配置文件会找不到 ubuntu.exe config --default-user nic # 启动WSL2 wsl 可能有人和我一样安装了Docker，启用WSL后，docker运行数据都在WSL发行版中，文件位置都只能由WSL管理！\n安装docker后，docker会自动创建2个发行版：\nwsl -l -v NAME STATE VERSION Stopped 2 docker-desktop Stopped 2 docker-desktop-data Stopped 2 和上面一样需要到导出，删除，导入。\n# 关闭docker 将Docker程序退出即可 # 导出docker-desktop wsl --export docker-desktop D:\\wsl2\\docker-desktop\\docker-desktop.tar # 删除docker-desktop wsl --unregister docker-desktop # 导入docker-desktop wsl --import docker-desktop D:\\wsl2\\docker-desktop D:\\wsl2\\docker-desktop\\docker-desktop.tar --version 2 # 导出docker-desktop-data wsl --export docker-desktop-data D:\\wsl2\\docker-desktop-data.tar # 删除docker-desktop-data wsl --unregister docker-desktop-data # 导入docker-desktop-data wsl --import docker-desktop-data D:\\wsl2\\docker-desktop-data D:\\wsl2\\docker-desktop-data\\docker-desktop-data.tar --version 2 ","permalink":"https://lifeislife.cn/posts/%E8%BF%81%E7%A7%BBwsl2%E5%88%B0%E9%9D%9E%E7%B3%BB%E7%BB%9F%E7%9B%98/","summary":"\u003ch1 id=\"迁移过程\"\u003e迁移过程\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 关闭WSL2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewsl --shutdown\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看WSL2的状态\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewsl -l -v\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eNAME                   STATE           VERSION\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eStopped         \u003cspan class=\"m\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Ubuntu         Stopped         \u003cspan class=\"m\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 导出WSL2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewsl --export Ubuntu D:\u003cspan class=\"se\"\u003e\\w\u003c/span\u003esl2\u003cspan class=\"se\"\u003e\\u\u003c/span\u003ebuntu.tar\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e正在导出，这可能需要几分钟时间。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e操作成功完成。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 删除WSL2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewsl --unregister Ubuntu\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e正在注销。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e操作成功完成。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 导入WSL2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewsl --import Ubuntu D:\u003cspan class=\"se\"\u003e\\w\u003c/span\u003esl2 D:\u003cspan class=\"se\"\u003e\\w\u003c/span\u003esl2\u003cspan class=\"se\"\u003e\\u\u003c/span\u003ebuntu.tar --version \u003cspan class=\"m\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e正在导入，这可能需要几分钟时间。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e操作成功完成。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 设置默认用户，如果不设置将会使用root用户，因为之前我一直使用自己创建的用户，所以需要设置，否则zsh配置文件会找不到\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eubuntu.exe config --default-user nic\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 启动WSL2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewsl\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可能有人和我一样安装了Docker，启用WSL后，docker运行数据都在WSL发行版中，文件位置都只能由WSL管理！\u003c/p\u003e","title":"迁移WSL2到非系统盘"},{"content":"半月前给用了三年的小米 10 换了一块二手电池，手机又可以再战三年了。想着自己还有两个耳机，也没有严重故障，只是电池亏点用不了半小时，于是也想着换个电池，看看能不能复活。本来以为耳机太小，太精密，怕自己修不了，但是想想如果不换电池，这个耳机也还是死路一条，不如自己尝试尝试，也能积攒一点经验。实操下来，发现并没有想象中那么难，只要有耐心，还是能修好的。甚至比换手机电池还要容易些，没有那么多螺丝需要拆，也没有那么多胶需要撬。\n小米 FlipBuds Pro 配件和工具准备 配件\nCR1154 3V 锂电池（可以直接淘宝搜索 FlipBuds Pro 电池，也可以直接搜这个型号，最好买带线的，不带线焊接会比较麻烦） 工具\n热风枪（吹风机即可） 电烙铁（小米的这个耳机是需要焊接电池线的） 镊子（清理耳机里面的胶水） 拆机 用吹风机对准耳机吹一两分钟，沿着合模线徒手就能掰开。打开腔体时需要慢一点，有地方有胶水粘粘，不是一打开就是图中的样子，需要把胶水清理干净。\n\u003c!DOCTYPE html\u003e Responsive Image 分离后可以从边缘将电池撬出来。\n\u003c!DOCTYPE html\u003e Responsive Image 电池正极上用的双面胶将导线粘到了正极，用吹风机对准图中位置稍微加热一分钟作用，然后将电池正极上的贴片取下来。\n\u003c!DOCTYPE html\u003e Responsive Image 除了上面一个连接点，还有两个焊接的连接点，用电烙铁加热取下即可将电池脱离。\n\u003c!DOCTYPE html\u003e Responsive Image 没有微距镜头，用了我爱音频网的图片\n装机 将电池红线连接到正极，黑线连接到负极，然后将电池放回原位，合模即可。如果不知道正负极，可以在耳机线路板上有标识。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 还有个需要注意的地方就是吸附磁铁的安装，可能在拆电池时候磁铁会掉落，可以根据图片中磁铁的位置进行安装。先放磁铁再安电池。\n\u003c!DOCTYPE html\u003e Responsive Image 在装机过程中就可以连接手机，并播放音乐测试耳机是否能正常工作。因为合模时需要大力压合，播放音乐还能保证压合过程中线路没有断开。\n测试 \u003c!DOCTYPE html\u003e Responsive Image 用了一天，耳机电池能用四小时左右，基本上和全新的一样。\n索尼 WF-1000XM3、 配件和工具准备 配件\nCR1254 3.7V 锂电池，原装的是 VARTA 品牌的，我买的是 ZeniPower，只要型号一样，品牌自己选。甚至可以选 3.85V，75mAh 的续航更好。 工具\n热风枪（吹风机即可） 镊子（清理耳机里面的胶水） 螺丝刀 拆机 用吹风机对着耳机的触摸原盘吹一两分钟胶水只在这块区域，边缘是卡扣不需要加热，指甲长的话直接用指甲掰开即可。打开后的样子如下图所示。\n\u003c!DOCTYPE html\u003e Responsive Image 有两个小螺丝，拧下后就可以将盖板翻过来，电池就在下方。电池下方有双面胶，直接抠不容易抠出来，用吹风机对着盖板吹一两分钟就可以将胶水软化，然后用镊子将胶水取下。\n\u003c!DOCTYPE html\u003e Responsive Image 安装 将电池放回原位，盖板合上，拧上螺丝即可。在安装回耳机盖时需要注意耳机盖是分左右的，如果左右颠倒了是合不上的。参考图中的位置。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E8%80%B3%E6%9C%BA%E6%8D%A2%E7%94%B5%E6%B1%A0%E5%A4%8D%E6%B4%BB%E8%80%B3%E6%9C%BA%E5%B0%8F%E8%AE%B0/","summary":"\u003cp\u003e半月前给用了三年的小米 10 换了一块二手电池，手机又可以再战三年了。想着自己还有两个耳机，也没有严重故障，只是电池亏点用不了半小时，于是也想着换个电池，看看能不能复活。本来以为耳机太小，太精密，怕自己修不了，但是想想如果不换电池，这个耳机也还是死路一条，不如自己尝试尝试，也能积攒一点经验。实操下来，发现并没有想象中那么难，只要有耐心，还是能修好的。甚至比换手机电池还要容易些，没有那么多螺丝需要拆，也没有那么多胶需要撬。\u003c/p\u003e","title":"耳机换电池复活耳机小记"},{"content":"问题背景 不知什么原因，一直正常使用的Adobe Photoshop 2021突然开始弹窗提示升级，还是日文的（应该是代理到到日本了），可能根据地区不同，弹窗的内容也不同，但是都是提示升级，倒计时10天，不知道十天之后啥情况。\n\u003c!DOCTYPE html\u003e Responsive Image 解决方法 Adobe的其他软件同理，比如我在用的Lightroom也是这样，解决方法也是一样的。以下方式基于Windows 11，其他版本的Windows也是类似的。\n如果没有用代理，可以直接将Photoshop程序禁止联网。可以通过配置Windows的防火墙来实现，具体方法如下：\n打开设置搜索“防火墙”，打开Windows防火墙，选择“高级设置”。\n\u003c!DOCTYPE html\u003e Responsive Image 选择“出站规则”，点击“新建规则”，选择规则类型为“程序”，程序选择为Photoshop的安装目录下的Photoshop.exe，然后选择“阻止连接”，一路下一步，最后命名规则为“禁止Photoshop联网”。 \u003c!DOCTYPE html\u003e Responsive Image 如果使用了代理，防火墙可能会被绕过，Photoshop可能仍然会通过代理访问更新服务器。需要通过配置代理将Photoshop禁止代理。如果不配置，可以在每次打开Adobe相关软件前关闭代理，如果配置，这里以Clash for Windows为例，可以通过配置Clash的规则来实现，不用关闭代理。具体方法如下：\n点击“Profiles”，选择自己的订阅，右击选择“Edit”，将以下这些规则添加到配置文件中保存即可，把配置放到最前面，这样优先级最高。\n# Final - MATCH,Proxy - PROCESS-NAME,Lightroom.exe,REJECT - PROCESS-NAME,lightroom.exe,REJECT - PROCESS-NAME,Photoshop.exe,REJECT - PROCESS-NAME,photoshop.exe,REJECT - PROCESS-NAME,Adobe Lightroom CEF Helper.exe,REJECT - PROCESS-NAME,AdobeIPCBroker.exe,REJECT - PROCESS-NAME,dynamiclinkmanager.exe,REJECT - PROCESS-NAME,dynamiclinkmediaserver.exe,REJECT - DOMAIN-SUFFIX,adobe.com,REJECT - DOMAIN-SUFFIX,adobelogin.com,REJECT - DOMAIN-SUFFIX,adobesc.com,REJECT - DOMAIN-SUFFIX,adobe.io,REJECT - DOMAIN-SUFFIX,adobecc.com,REJECT - DOMAIN-SUFFIX,adobemarketingcloud.com,REJECT - DOMAIN-SUFFIX,adobe.net,REJECT - DOMAIN-SUFFIX,adobeexchange.com,REJECT - DOMAIN-SUFFIX,photoshop.com,REJECT - DOMAIN-SUFFIX,photoshop.adobe.com,REJECT - DOMAIN-KEYWORD,photoshop,REJECT 其他程序你可以自己添加，格式为PROCESS-NAME,程序名,REJECT。表示拒绝这些程序访问网络。\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3adobe-photoshop%E6%AD%A3%E7%89%88%E5%8D%87%E7%BA%A7%E5%BC%B9%E7%AA%97/","summary":"\u003ch2 id=\"问题背景\"\u003e问题背景\u003c/h2\u003e\n\u003cp\u003e不知什么原因，一直正常使用的Adobe Photoshop 2021突然开始弹窗提示升级，还是日文的（应该是代理到到日本了），可能根据地区不同，弹窗的内容也不同，但是都是提示升级，倒计时10天，不知道十天之后啥情况。\u003c/p\u003e","title":"解决Adobe Photoshop正版升级弹窗"},{"content":"安装与配置 登录 Zwift 官网下载安装包，安装完成后打开，输入邮箱和密码登录。但是我的电脑离骑行台较远，蓝牙很不稳定，Zwift 还有一个配套的手机 App，叫 Companion，可以在谷歌商店安装。安装后打开登录。Zwift PC 客户端登录后在配对装置页面左上角选择“透过手机进行配对”，正常情况下手机端会自动弹出配对页面。记得打开手机的蓝牙开关。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 道具功能介绍 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 常见问题 启动后闪退 将输入法切换为英文模式再重新启动。\n没有其他玩家，只有自己 挂全局代理重新启动。\n","permalink":"https://lifeislife.cn/posts/zwift%E4%BD%BF%E7%94%A8tips/","summary":"\u003ch1 id=\"安装与配置\"\u003e安装与配置\u003c/h1\u003e\n\u003cp\u003e登录 Zwift 官网下载安装包，安装完成后打开，输入邮箱和密码登录。但是我的电脑离骑行台较远，蓝牙很不稳定，Zwift 还有一个配套的手机 App，叫 Companion，可以在谷歌商店安装。安装后打开登录。Zwift PC 客户端登录后在配对装置页面左上角选择“透过手机进行配对”，正常情况下手机端会自动弹出配对页面。记得打开手机的蓝牙开关。\u003c/p\u003e","title":"ZWIFT 使用 Tips"},{"content":"Docker-Compose version: \u0026#34;3.8\u0026#34; services: nexus: image: sonatype/nexus3 container_name: nexus restart: always ports: - 8081:8081 volumes: - /srv/nexus/data:/nexus-data 修改/srv/nexus目录的所有者为当前用户：\nsudo chown -R username:username /srv/nexus 修改data目录有最高权限，否则无法启动成功：\nsudo chmod -R 777 /srv/nexus/data 代理Docker Hub 登录WEB页面 登录WEB页面，地址为：http://192.168.1.9:8081。 用户名为：admin，密码通过命令获取：\ndocker exec nexus3 cat /nexus-data/admin.password 创建Blob 在 Nexus Repository Manager 中，Blob Store（二进制大对象存储）是一个用于存储仓库数据的核心组件。Blob Store 主要用于存储各种二进制文件，例如软件包、依赖库、构建产物等，这些文件通常被称为“blob”。\nBlob Store 的作用包括：\n存储二进制文件： Blob Store 被设计用来安全、可靠地存储二进制文件。这些文件可以是各种形式的构建产物、软件包、依赖库等。Blob Store 是 Nexus 仓库管理系统的核心，它为这些文件提供了一个中央存储位置。\n支持不同类型的存储后端： Nexus 支持不同类型的 Blob Store，例如本地文件系统、云存储（如Amazon S3、Google Cloud Storage）等。这使得用户可以根据需求选择不同的存储后端，并根据实际情况进行扩展或迁移。\n提供存储策略： Blob Store 允许你定义存储策略，以确定何时以及如何清理或删除不再需要的文件。这对于管理仓库的存储空间非常重要，可以根据策略自动清理不再需要的快照或旧版本。\n支持代理和缓存： 在 Maven Repository 的场景下，Blob Store 还可以用于代理远程 Maven 仓库，并缓存远程仓库中的文件。这有助于提高构建性能，减少对远程仓库的依赖。\n我们缓存的镜像需要存储为blob，所以需要创建一个Blob store。点击左侧菜单栏的Blob Stores，然后点击Create blob store，选择Type为File，Name填写为dockerhub。\n创建Repository 在 Nexus Repository Manager 中，有三种主要的仓库类型：Hosted Repository、Proxy Repository、和 Group Repository。每种类型都有不同的作用和用途：\nHosted Repository（托管仓库）:\n作用： 用于存储和管理本地创建的部署（deploy）的二进制文件。这包括你自己或你的团队创建的库，例如 Maven 构件、npm 包、Docker 镜像等。 使用场景： 当你需要在内部存储和分享自己创建的构建产物时，你可以使用 Hosted Repository。 Proxy Repository（代理仓库）:\n作用： 用于代理和缓存远程仓库的二进制文件。当你从远程仓库获取构建依赖时，Proxy Repository 会将这些文件缓存在本地，从而提高构建性能并减少对远程仓库的依赖。 使用场景： 在构建过程中，你通常会依赖于一些公共的远程仓库，例如 Maven Central、npm registry、Docker Hub等。使用 Proxy Repository 可以有效地管理这些依赖并减少对远程仓库的直接访问。 Group Repository（组合仓库）:\n作用： 允许你将多个仓库组合成一个逻辑单元。当你需要在构建中同时使用多个仓库的内容时，Group Repository 可以将这些仓库组合在一起，使它们在应用程序中看起来像一个单一的仓库。 使用场景： 当你有多个 Proxy Repository 或 Hosted Repository 时，你可以使用 Group Repository 将它们组合在一起。这对于简化构建配置、统一依赖管理等非常有用。 我们一般创建三个仓库，proxy代理公共镜像，hosted保存自己的镜像，group将proxy和hosted组合在一起。我们分别创建三个仓库。\nproxy 点击左侧菜单栏的Repositories，然后点击Create repository，选择Docker (proxy)，按照下图填写：\n\u003c!DOCTYPE html\u003e Responsive Image Remote storage 图中填写为https://registry-1.docker.io，这是dockerhub的地址。但是实测会很慢，所以我们使用加速地址https://dockerproxy.com。需要注意修改一下。\n还有一些国内镜像源可选，可以参考这个项目。Test Registry · docker-practice/docker-registry-cn-mirror-test@83a4dd4\n\u003c!DOCTYPE html\u003e Responsive Image Blob store选择为刚刚创建的dockerhub。\n\u003c!DOCTYPE html\u003e Responsive Image hosted hosted比较简单，只需要填个名称就行了，这里填写为docker-hosted。\ngroup group 需要注意以下：\nHTTP需要单独设置端口号。我们设置与WEB页面不同的端口号，8082即可。 需要将proxy和hosted都添加到group中，这样才能将两个仓库组合在一起。 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 启用Realms 这里要在 Security-Realms 里面启用 Docker Bearer Token Realm。\n\u003c!DOCTYPE html\u003e Responsive Image 拉取镜像 如果直接使用docker pull拉取镜像，会报错：\n$ docker pull 192.168.1.9:8082/redis Using default tag: latest Error response from daemon: Get \u0026#34;https://192.168.1.9:8082/v2/\u0026#34;: http: server gave HTTP response to HTTPS client 编辑/etc/docker/daemon.json文件，添加以下内容：\n{ \u0026#34;insecure-registries\u0026#34;: [ \u0026#34;192.168.1.9:8082\u0026#34; ], \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;http://192.168.1.9:8082\u0026#34; ] } 注意：registry-mirrors中只保留一个Nexus的地址，这样默认就会从Nexus拉取镜像。如果有多个地址，就可能会从其他地址拉取镜像。因为我们在Nexus中配置的URL就是docker-proxy的地址，他就是一个国内代理地址，所以这里我们只保留一个Nexus的地址就行。 注意： insecure-registries 拼写，不要写成 insecure-registry。最好直接复制，json格式很严格。\n重启Docker服务：\nsudo systemctl restart docker 登录Docker Registry：\n需要注意的shi，这里的用户名和密码是Nexus的用户名和密码，不是Docker Hub的用户名和密码。\ndocker login 192.168.1.9:8082 -u admin -p admin123 拉取镜像：\n$ docker pull redis Using default tag: latest latest: Pulling from redis 1f7ce2fa46ab: Already exists 4827e9d1e197: Pull complete 5845062cfda9: Pull complete 44d659adcf8b: Pull complete b6962d83313d: Pull complete 5d29cf86ecab: Pull complete 4f4fb700ef54: Pull complete 3a2d9f90268c: Pull complete Digest: sha256:249e1bfb9448ae9e76807748f8cb3c5cc73e55441b7b36364c61a7428c9e814c Status: Downloaded newer image for 192.168.1.9:8082/redis:latest 192.168.1.9:8082/redis:latest 可以在首页的Browse Docker中看到镜像已经被缓存了。\n\u003c!DOCTYPE html\u003e Responsive Image 推送镜像 如果你需要上传自己修改的镜像，那么就需要修改之前的docker-hosted，其中HTTP中该为8083，和docker-proxy的端口号区分。这样我们就可以从8082下载镜像，从8083推送镜像。\n\u003c!DOCTYPE html\u003e Responsive Image 首先我们需要重命名镜像，格式如下\ndocker tag \u0026lt;imageId or imageName\u0026gt; \u0026lt;nexus-hostname\u0026gt;:\u0026lt;repository-port\u0026gt;/\u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; docker tag af340544ed62 192.168.1.9:8083/hello-world:mytag docker push 192.168.1.9:8083/hello-world:mytag 拉取这个镜像：\ndocker pull 192.168.1.9:8083/hello-world:mytag 代理 YUM 源 代理 APT 源 和 YUM 源代理稍有不同的是，APT 源代理时没有 Group 仓库，但是使用APT源的系统如Ubuntu也是有多个版本的，我们只需要在 Distribution 参数里填写需要代理的版本即可，每隔版本用逗号分隔。\n\u003c!DOCTYPE html\u003e Responsive Image 常用的版本以及代号如下：\nUbuntu 16.04 Xenial Xerus Ubuntu 18.04 Bionic Beaver Ubuntu 20.04 Focal Fossa Ubuntu 21.04 Hirsute Hippo Ubuntu 21.10 Impish Indri Ubuntu 22.04 Jammy Jellyfish Ubuntu 22.10 Kinetic Kudu Ubuntu 23.04 Lunar Lobster Ubuntu 23.10 Mantic Minotau 代理地址为：http://192.168.1.9:8081/repository/apt-proxy/，我们可以在Ubuntu中使用这个地址来代理APT源。修改/etc/apt/sources.list文件，将原来的源地址替换为Nexus的地址即可。\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb http://192.168.1.9:8081/repository/apt-proxy/ jammy main restricted universe multiverse # deb-src http://192.168.1.9:8081/repository/apt-proxy/ jammy main restricted universe multiverse deb http://192.168.1.9:8081/repository/apt-proxy/ jammy-updates main restricted universe multiverse # deb-src http://192.168.1.9:8081/repository/apt-proxy/ jammy-updates main restricted universe multiverse deb http://192.168.1.9:8081/repository/apt-proxy/ jammy-backports main restricted universe multiverse # deb-src http://192.168.1.9:8081/repository/apt-proxy/ jammy-backports main restricted universe multiverse deb http://192.168.1.9:8081/repository/apt-proxy/ jammy-security main restricted universe multiverse # deb-src http://192.168.1.9:8081/repository/apt-proxy/ jammy-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb http://192.168.1.9:8081/repository/apt-proxy/ jammy-proposed main restricted universe multiverse # # deb-src http://192.168.1.9:8081/repository/apt-proxy/ jammy-proposed main restricted universe multiverse 代理 pip 源 使用阿里云作为代理，我们需要在Nexus中创建一个PyPI代理仓库。点击左侧菜单栏的Repositories，然后点击Create repository，选择PyPI (proxy)，按照下图填写：\n\u003c!DOCTYPE html\u003e Responsive Image 再创建一个PyPI Group仓库，将刚刚创建的PyPI代理仓库和PyPI Hosted仓库添加到Group仓库中。\n编辑/etc/pip.conf文件，添加以下内容：\n或者在用户目录下的~/.pip/pip.conf文件中添加\n[global] index = http://192.168.1.9:8081/repository/pypi/ index-url = http://192.168.1.9:8081/repository/pypi/simple trusted-host = 192.168.1.9 在 WSL2 中使用 Nexus 代理 因为 WSL2 使用的是宿主机Windows的Docker desktop作为Docker引擎，所以我们需要在Windows中配置Docker的代理。打开Docker Desktop，点击Settings，然后选择Docker Engine，添加以下内容：\n\u003c!DOCTYPE html\u003e Responsive Image { \u0026#34;builder\u0026#34;: { \u0026#34;gc\u0026#34;: { \u0026#34;defaultKeepStorage\u0026#34;: \u0026#34;20GB\u0026#34;, \u0026#34;enabled\u0026#34;: true } }, \u0026#34;experimental\u0026#34;: false, \u0026#34;insecure-registries\u0026#34;: [ \u0026#34;http://192.168.1.9:8082\u0026#34; ], \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;http://192.168.1.9:8082\u0026#34; ] } 重启Docker Desktop。然后在WSL2中使用 docker info 查看是否配置成功。\n\u003c!DOCTYPE html\u003e Responsive Image 常见错误 docker login nexus unauthorized authentication required 确认登录密码是否正确，密码为Nexus登录密码 却是否启用Realms docker login nexus connection refused docker login 192.168.1.9:8082 -u admin -p admin123 确认Docker compose配置文件中已经将端口8082暴露，如果新增需要重启Nexus\n确认防火墙关闭或者已经打开端口\nsudo ufw allow 8082 sudo ufw allow 8082/tcp 确认已经将私有仓库添加到了/etc/docker/daemon.json，并且及时重启了docker服务\nsudo systemctl restart docker.service 确认已经开启了Http connector\n如图： \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/nexus-%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86/","summary":"\u003ch1 id=\"docker-compose\"\u003eDocker-Compose\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yml\" data-lang=\"yml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eversion\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;3.8\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nt\"\u003eservices\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003enexus\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eimage\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003esonatype/nexus3\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003econtainer_name\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003enexus\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003erestart\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003ealways\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eports\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"m\"\u003e8081\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"m\"\u003e8081\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003evolumes\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/srv/nexus/data:/nexus-data\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改/srv/nexus目录的所有者为当前用户：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo chown -R username:username /srv/nexus\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改data目录有最高权限，否则无法启动成功：\u003c/p\u003e","title":"Nexus搭建内部镜像"},{"content":"Tunasync 项目简介 Tunasync 是一个开源的镜像站点镜像工具，可以帮助你快速搭建一个镜像站点，也可以帮助你快速的同步镜像站点的镜像。我们所熟知的清华大学镜像站就是使用 Tunasync 来同步镜像的。\n准备 workspace 创建目录用于存放 Tunasync 的程序、配置文件和数据库文件：\nmkdir /home/username/tunasync mkdir /home/username/tunasync/conf mkdir /home/username/tunasync/db 创建目录用于存放镜像文件：\nsudo mkdir /srv/mirrors srv 目录需要 root 权限，将 mirrors 目录的所有者改为当前用户：\nsudo chown -R username:username /srv/mirrors 下载 Tunasync 可以从 Tunasync 项目的 Github releases 编译好的程序直接使用。\ncd /home/username/tunasync wget https://github.com/tuna/tunasync/releases/download/v0.8.0/tunasync-linux-amd64-bin.tar.gz tar -zxvf tunasync-linux-amd64-bin.tar.gz 配置 Tunasync Manager 配置 创建配置文件/home/username/tunasync/conf/manager.conf，并添加以下内容：\ndebug = false [server] addr = \u0026#34;127.0.0.1\u0026#34; port = 12345 ssl_cert = \u0026#34;\u0026#34; ssl_key = \u0026#34;\u0026#34; [files] db_type = \u0026#34;bolt\u0026#34; db_file = \u0026#34;/home/username/tunasync/db/manager.db\u0026#34; ca_cert = \u0026#34;\u0026#34; Worker 配置 创建配置文件/home/username/tunasync/conf/worker-openeuler.conf，并添加以下内容：\n[global] name = \u0026#34;openeuler_worker\u0026#34; log_dir = \u0026#34;/srv/mirrors/log/tunasync/{{.Name}}\u0026#34; mirror_dir = \u0026#34;/srv/mirrors\u0026#34; concurrent = 10 interval = 1440 [manager] api_base = \u0026#34;http://localhost:12345\u0026#34; token = \u0026#34;some_token\u0026#34; ca_cert = \u0026#34;\u0026#34; [cgroup] enable = false base_path = \u0026#34;/sys/fs/cgroup\u0026#34; group = \u0026#34;tunasync\u0026#34; [server] hostname = \u0026#34;localhost\u0026#34; listen_addr = \u0026#34;127.0.0.1\u0026#34; listen_port = 16010 ssl_cert = \u0026#34;\u0026#34; ssl_key = \u0026#34;\u0026#34; [[mirrors]] name = \u0026#34;centos\u0026#34; provider = \u0026#34;rsync\u0026#34; upstream = \u0026#34;rsync://mirrors.tuna.tsinghua.edu.cn/openeuler/\u0026#34; use_ipv6 = false 启动 Tunasync 启动 Manager cd /home/username/tunasync ./tunasync manager -c conf/manager.conf \u0026gt;\u0026gt; /srv/mirrors/log/plog/manager.log \u0026amp; 启动 Worker cd /home/username/tunasync ./tunasync worker -c conf/worker-openeuler.conf \u0026gt;\u0026gt; /srv/mirrors/log/plog/worker-openeuler.log \u0026amp; 通常可能同步不止一个镜像站点，可以创建多个 Worker 配置文件，然后启动多个 Worker。\n创建 web 服务 安装 Apache2：\nsudo apt update sudo apt install apache2 修改配置文件：\nUbuntu 中的 Apache2 主要配置文件是 /etc/apache2/apache2.conf。可以在此文件中进行全局配置，也可以使用专门的配置文件，例如 /etc/apache2/sites-available/your-site.conf。\nsudo nano /etc/apache2/apache2.conf 在 apache2.conf 文件中，添加以下行，设置 DocumentRoot 和目录访问权限：\nDocumentRoot /mirrors \u0026lt;Directory \u0026#34;/mirrors\u0026#34;\u0026gt; Options Indexes FollowSymLinks AllowOverride None Require all granted \u0026lt;/Directory\u0026gt; 请确保将 \u0026lt;Directory\u0026gt; 部分添加到正确的位置。可以在文件中找到 \u0026lt;Directory /var/www/\u0026gt; 部分，然后在该部分下添加配置。\n重新启动 Apache2 服务：\n在进行配置更改后，需要重新启动 Apache2 服务以使更改生效：\nsudo systemctl restart apache2 补充文件：\n将 index.html 文件和其他需要的文件添加到 /srv/mirrors 目录中。\n测试：\n打开 Web 浏览器，访问 http://your-server-ip 或 http://localhost，应该能够看到 /srv/mirrors 目录中的文件。\n如打不开，需要开启防火墙\nsudo ufw allow http sudo ufw allow https 修改 Web 服务端口\n编辑 Apache2 配置文件：\nsudo nano /etc/apache2/ports.conf **在文件中找到 ​Listen​ ** 行，修改端口：\nListen 2081 编辑虚拟主机配置（如果有）：\n如果你有虚拟主机配置文件（通常在 /etc/apache2/sites-available/ 中），确保其中的 \u0026lt;VirtualHost\u0026gt; 部分中的端口也被修改为 2081。\n保存并退出配置文件。\n重启 Apache 服务：\nsudo systemctl restart apache2 打开防火墙端口 1. **打开 2081 端口：** ```bash sudo ufw allow 2081 ``` 2. **检查配置：** ```bash sudo ufw status ``` 确保 2081 端口已经正确添加。 3. **重启防火墙（可选）：** ```bash sudo ufw reload ``` 或者 ```bash sudo systemctl restart ufw ``` 这样，你就将 Apache2 Web 服务的端口修改为 2081，并且只开放了 2081 端口。确保修改了防火墙规则后，仍能够通过新的端口访问你的网站。 ","permalink":"https://lifeislife.cn/posts/tunasync%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E7%AB%99/","summary":"\u003ch1 id=\"tunasync-项目简介\"\u003eTunasync 项目简介\u003c/h1\u003e\n\u003cp\u003eTunasync 是一个开源的镜像站点镜像工具，可以帮助你快速搭建一个镜像站点，也可以帮助你快速的同步镜像站点的镜像。我们所熟知的清华大学镜像站就是使用 Tunasync 来同步镜像的。\u003c/p\u003e","title":"Tunasync 搭建私有镜像站"},{"content":"安装Clangd插件 在VSCode中，你可以通过以下步骤安装Clangd插件：\n打开VSCode； 点击左侧的插件图标（Ctrl+Shift+X）； 搜索“Clangd”插件； 点击“安装”按钮。 生成compile_commands.json 对于make项目来说，常规来讲，可以使用Bear来对源码生成compile_commands.json。首先安装Bear：\nsudo apt install bear 然后在项目根目录下执行：\nbear make -j32 编译完成后，会在项目根目录下生成compile_commands.json文件。\n对于CMAKE项目来说，可以在CMakeLists.txt中添加以下语句，然后重新编译项目即可生成compile_commands.json文件： set(CMAKE_EXPORT_COMPILE_COMMANDS True)\n配置Clangd插件 进入到项目目录下，下载配置文件：\ngit clone --depth 1 https://github.com/Dunky-Z/dot-vscode.git .vscode 主要修改--compile-commands-dir参数，将其修改为自己的路径。\n随便打开内核源码文件，clangd将会自动生成索引，并将索引文件.idx保存在项目根目录下的.cache目录中。\nLinux-5.4 ├── .cache │ └── clangd ├── .config ├── .git 如果生成了索引文件，那么说明配置成功，可以打开源码文件看看是否能够正常跳转。\n","permalink":"https://lifeislife.cn/posts/vscode-linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/","summary":"\u003ch2 id=\"安装clangd插件\"\u003e安装Clangd插件\u003c/h2\u003e\n\u003cp\u003e在VSCode中，你可以通过以下步骤安装Clangd插件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e打开VSCode；\u003c/li\u003e\n\u003cli\u003e点击左侧的插件图标（Ctrl+Shift+X）；\u003c/li\u003e\n\u003cli\u003e搜索“Clangd”插件；\u003c/li\u003e\n\u003cli\u003e点击“安装”按钮。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"生成compile_commandsjson\"\u003e生成compile_commands.json\u003c/h2\u003e\n\u003cp\u003e对于make项目来说，常规来讲，可以使用Bear来对源码生成compile_commands.json。首先安装Bear：\u003c/p\u003e","title":"VSCode Linux内核源码阅读环境"},{"content":"通过文档资料百度网盘下载配套资料，学习手册目录中有嵌入式Linux应用开发完全手册V5.1_STM32MP157_Pro开发板.pdf，里面有详细的开发环境搭建步骤，但是在搭建过程中还是遇到了一些问题，记录如下：\nModuleNotFoundError: No module named \u0026lsquo;requests\u0026rsquo; ../repo/repo init -u https://gitee.com/weidongshan/manifests.git -b linux-sdk -m stm32mp1/100ask_stm32mp157_pro_release-v2.0.xml --no-repo-verify Traceback (most recent call last): File \u0026#34;/home/nic/develop/repo/main.py\u0026#34;, line 56, in \u0026lt;module\u0026gt; from subcmds.version import Version File \u0026#34;/home/nic/develop/repo/subcmds/__init__.py\u0026#34;, line 35, in \u0026lt;module\u0026gt; mod = __import__(__name__, File \u0026#34;/home/nic/develop/repo/subcmds/selfupdate.py\u0026#34;, line 22, in \u0026lt;module\u0026gt; from subcmds.sync import _PostRepoUpgrade File \u0026#34;/home/nic/develop/repo/subcmds/sync.py\u0026#34;, line 74, in \u0026lt;module\u0026gt; from project import Project File \u0026#34;/home/nic/develop/repo/project.py\u0026#34;, line 33, in \u0026lt;module\u0026gt; import requests ModuleNotFoundError: No module named \u0026#39;requests\u0026#39; 解决方法：\npython -m pip install requests ModuleNotFoundError: No module named \u0026lsquo;formatter\u0026rsquo; formatter已经在python3.4标记成废弃接口，在python3.10已经正式删除，并且其依赖的cStringIO也已经删除。所以不能简单的安装formatter模块，可以通过两种方式解决：\n方法一：降低python版本到3.9以下 添加 ppa 源，此源可安装多个 python 版本 sudo add-apt-repository ppa:deadsnakes/ppa 安装 python3.9 sudo apt install python3.9 建立 python 的组,并添加 Python3.9 的可选项，优先级为 1 sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.9 1 验证当前 python 是否是 3.9 版本 python --version 如果不是，用以下命令手动配置一下 sudo update-alternatives --config python 方法二：修改repo源码 将repo/repo/subcmds/help.py文件替换为如下内容：\n也可以参考Google修复后的代码，根据diff修改文件。\n# -*- coding:utf-8 -*- # # Copyright (C) 2008 The Android Open Source Project # # Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from __future__ import print_function import re import sys import textwrap from subcmds import all_commands from color import Coloring from command import PagedCommand, MirrorSafeCommand, GitcAvailableCommand, GitcClientCommand import gitc_utils class Help(PagedCommand, MirrorSafeCommand): common = False helpSummary = \u0026#34;Display detailed help on a command\u0026#34; helpUsage = \u0026#34;\u0026#34;\u0026#34; %prog [--all|command] \u0026#34;\u0026#34;\u0026#34; helpDescription = \u0026#34;\u0026#34;\u0026#34; Displays detailed usage information about a command. \u0026#34;\u0026#34;\u0026#34; def _PrintCommands(self, commandNames): \u0026#34;\u0026#34;\u0026#34;Helper to display |commandNames| summaries.\u0026#34;\u0026#34;\u0026#34; maxlen = 0 for name in commandNames: maxlen = max(maxlen, len(name)) fmt = \u0026#39; %%-%ds %%s\u0026#39; % maxlen for name in commandNames: command = all_commands[name]() try: summary = command.helpSummary.strip() except AttributeError: summary = \u0026#39;\u0026#39; print(fmt % (name, summary)) def _PrintAllCommands(self): print(\u0026#39;usage: repo COMMAND [ARGS]\u0026#39;) print(\u0026#39;The complete list of recognized repo commands are:\u0026#39;) commandNames = list(sorted(all_commands)) self._PrintCommands(commandNames) print(\u0026#34;See \u0026#39;repo help \u0026lt;command\u0026gt;\u0026#39; for more information on a \u0026#34; \u0026#39;specific command.\u0026#39;) def _PrintCommonCommands(self): print(\u0026#39;usage: repo COMMAND [ARGS]\u0026#39;) print(\u0026#39;The most commonly used repo commands are:\u0026#39;) def gitc_supported(cmd): if not isinstance(cmd, GitcAvailableCommand) and not isinstance(cmd, GitcClientCommand): return True if self.manifest.isGitcClient: return True if isinstance(cmd, GitcClientCommand): return False if gitc_utils.get_gitc_manifest_dir(): return True return False commandNames = list(sorted([name for name, command in all_commands.items() if command.common and gitc_supported(command)])) self._PrintCommands(commandNames) print( \u0026#34;See \u0026#39;repo help \u0026lt;command\u0026gt;\u0026#39; for more information on a specific command.\\n\u0026#34; \u0026#34;See \u0026#39;repo help --all\u0026#39; for a complete list of recognized commands.\u0026#34;) def _PrintCommandHelp(self, cmd, header_prefix=\u0026#39;\u0026#39;): class _Out(Coloring): def __init__(self, gc): Coloring.__init__(self, gc, \u0026#39;help\u0026#39;) self.heading = self.printer(\u0026#39;heading\u0026#39;, attr=\u0026#39;bold\u0026#39;) self._first = True def _PrintSection(self, heading, bodyAttr): try: body = getattr(cmd, bodyAttr) except AttributeError: return if body == \u0026#39;\u0026#39; or body is None: return if not self._first: self.nl() self._first = False self.heading(\u0026#39;%s%s\u0026#39;, header_prefix, heading) self.nl() self.nl() me = \u0026#39;repo %s\u0026#39; % cmd.NAME body = body.strip() body = body.replace(\u0026#39;%prog\u0026#39;, me) # Extract the title, but skip any trailing {#anchors}. asciidoc_hdr = re.compile(r\u0026#39;^\\n?#+ ([^{]+)(\\{#.+\\})?$\u0026#39;) for para in body.split(\u0026#34;\\n\\n\u0026#34;): if para.startswith(\u0026#39; \u0026#39;): self.write(\u0026#39;%s\u0026#39;, para) self.nl() self.nl() continue m = asciidoc_hdr.match(para) if m: self.heading(\u0026#39;%s%s\u0026#39;, header_prefix, m.group(1)) self.nl() self.nl() continue lines = textwrap.wrap(para.replace(\u0026#39; \u0026#39;, \u0026#39; \u0026#39;), width=80, break_long_words=False, break_on_hyphens=False) for line in lines: self.write(\u0026#39;%s\u0026#39;, line) self.nl() self.nl() out = _Out(self.manifest.globalConfig) out._PrintSection(\u0026#39;Summary\u0026#39;, \u0026#39;helpSummary\u0026#39;) cmd.OptionParser.print_help() out._PrintSection(\u0026#39;Description\u0026#39;, \u0026#39;helpDescription\u0026#39;) def _PrintAllCommandHelp(self): for name in sorted(all_commands): cmd = all_commands[name]() cmd.manifest = self.manifest self._PrintCommandHelp(cmd, header_prefix=\u0026#39;[%s] \u0026#39; % (name,)) def _Options(self, p): p.add_option(\u0026#39;-a\u0026#39;, \u0026#39;--all\u0026#39;, dest=\u0026#39;show_all\u0026#39;, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;show the complete list of commands\u0026#39;) p.add_option(\u0026#39;--help-all\u0026#39;, dest=\u0026#39;show_all_help\u0026#39;, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;show the --help of all commands\u0026#39;) def Execute(self, opt, args): if len(args) == 0: if opt.show_all_help: self._PrintAllCommandHelp() elif opt.show_all: self._PrintAllCommands() else: self._PrintCommonCommands() elif len(args) == 1: name = args[0] try: cmd = all_commands[name]() except KeyError: print(\u0026#34;repo: \u0026#39;%s\u0026#39; is not a repo command.\u0026#34; % name, file=sys.stderr) sys.exit(1) cmd.manifest = self.manifest self._PrintCommandHelp(cmd) else: self._PrintCommandHelp(self) ","permalink":"https://lifeislife.cn/posts/%E5%B5%8C%E5%85%A5%E5%BC%8Flinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91/","summary":"\u003cp\u003e通过\u003ca href=\"https://pan.baidu.com/s/1Gnh9G8a05LSgHYlohyl93Q?pwd=root#list/path=%2F\"\u003e文档资料百度网盘\u003c/a\u003e下载配套资料，学习手册目录中有嵌入式Linux应用开发完全手册V5.1_STM32MP157_Pro开发板.pdf，里面有详细的开发环境搭建步骤，但是在搭建过程中还是遇到了一些问题，记录如下：\u003c/p\u003e\n\u003ch2 id=\"modulenotfounderror-no-module-named-requests\"\u003eModuleNotFoundError: No module named \u0026lsquo;requests\u0026rsquo;\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e../repo/repo init -u https://gitee.com/weidongshan/manifests.git -b linux-sdk -m stm32mp1/100ask_stm32mp157_pro_release-v2.0.xml --no-repo-verify\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eTraceback \u003cspan class=\"o\"\u003e(\u003c/span\u003emost recent call last\u003cspan class=\"o\"\u003e)\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  File \u003cspan class=\"s2\"\u003e\u0026#34;/home/nic/develop/repo/main.py\u0026#34;\u003c/span\u003e, line 56, in \u0026lt;module\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    from subcmds.version import Version\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  File \u003cspan class=\"s2\"\u003e\u0026#34;/home/nic/develop/repo/subcmds/__init__.py\u0026#34;\u003c/span\u003e, line 35, in \u0026lt;module\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nv\"\u003emod\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e __import__\u003cspan class=\"o\"\u003e(\u003c/span\u003e__name__,\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  File \u003cspan class=\"s2\"\u003e\u0026#34;/home/nic/develop/repo/subcmds/selfupdate.py\u0026#34;\u003c/span\u003e, line 22, in \u0026lt;module\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    from subcmds.sync import _PostRepoUpgrade\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  File \u003cspan class=\"s2\"\u003e\u0026#34;/home/nic/develop/repo/subcmds/sync.py\u0026#34;\u003c/span\u003e, line 74, in \u0026lt;module\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    from project import Project\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  File \u003cspan class=\"s2\"\u003e\u0026#34;/home/nic/develop/repo/project.py\u0026#34;\u003c/span\u003e, line 33, in \u0026lt;module\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    import requests\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eModuleNotFoundError: No module named \u003cspan class=\"s1\"\u003e\u0026#39;requests\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e解决方法：\u003c/p\u003e","title":"嵌入式Linux驱动开发环境搭建踩坑"},{"content":"sudo apt update 在更新源时报错 Clearsigned file isn\u0026rsquo;t valid, got \u0026lsquo;NOSPLIT\u0026rsquo; (does the network require authentication?)。\n换中科大的源解决，其余源无法解决。\n如要用于其他版本，把 jammy 换成其他版本代号即可: 22.04：jammy；20.04：focal；18.04：bionic；16.04：xenial；14.04：trusty。\n# 默认注释了源码仓库，如有需要可自行取消注释 deb https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3ubuntu%E6%9B%B4%E6%96%B0%E6%BA%90%E6%8A%A5%E9%94%99clearsigned-file-isn-t-valid-got-nosplit/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在更新源时报错 Clearsigned file isn\u0026rsquo;t valid, got \u0026lsquo;NOSPLIT\u0026rsquo; (does the network require authentication?)。\u003c/p\u003e\n\u003cp\u003e换中科大的源解决，其余源无法解决。\u003c/p\u003e\n\u003cp\u003e如要用于其他版本，把 jammy 换成其他版本代号即可: 22.04：jammy；20.04：focal；18.04：bionic；16.04：xenial；14.04：trusty。\u003c/p\u003e","title":"解决Ubuntu更新源报错Clearsigned file isnt valid, got NOSPLIT"},{"content":"docker-compose 部署 version: \u0026#34;3.7\u0026#34; services: postgres: image: postgres:latest container_name: postgres ports: - 5432:5432 networks: - br-net-gitea environment: POSTGRES_USER: user POSTGRES_PASSWORD: 123456 POSTGRES_DB: gitea volumes: - ./postgresql:/var/lib/postgresql - ./data:/var/lib/postgresql/data gitea: image: gitea/gitea:1.20.5 container_name: gitea environment: - USER_UID=1000 - USER_GID=1000 - GITEA__database__DB_TYPE=postgres - GITEA__database__HOST=192.168.1.9:5432 - GITEA__database__NAME=gitea - GITEA__database__USER=user - GITEA__database__PASSWD=123456 restart: always networks: - br-net-gitea volumes: - ./data:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro - /home/git/.ssh/:/data/git/.ssh ports: - 3000:3000 - \u0026#34;127.0.0.1:2222:22\u0026#34; depends_on: - postgres act_runner: image: gitea/act_runner:latest environment: - GITEA_INSTANCE_URL=http://192.168.1.9:3000 - GITEA_RUNNER_REGISTRATION_TOKEN=Qw5Qf4A1bTENfIOQlc1NSNyFYMLp7TAtSujb5ihF - GITEA_RUNNER_NAME=docker_runner volumes: - /var/run/docker.sock:/var/run/docker.sock - ./act_runner/act_data:/data - ./act_runner/act_cache:/root/.cache 常见问题 首次登录web时没有创建管理员账号，如何登录 打开Gitea网页注册的第一个账号就是管理员账号。无需特殊设置。也无需找回密码。\n从Github导入仓库时报错：从不允许的主机导入 打开配置文件gitea/conf/app.ini，修改以下配置：\n[migrations] ALLOW_LOCALNETWORKS = true ALLOWED_DOMAINS = 127.0.0.1,192.168.31.100,github.com,*.github.com IMPORT_LOCAL_PATHS = true ;; 导入本地仓库开关，false：设置为false，防止所有用户（包括admin）导入服务器上的本地路径。 docker-compose restart gitea重启容器。\n以下修改配置文件后，需要重启容器才能生效，不再赘述。\n如何开启软件包 [packages] ENABLED = true 开启action [actions] ENABLED=true error response from daemon server gave http response to https client docker login 报错\n配置/etc/docker/daemon.json\n\u0026#34;insecure-registries\u0026#34;: [ \u0026#34;192.168.1.9:2010\u0026#34; ] 如何上传docker镜像到gitea制品库 # 登录你的镜像仓库，也就是你的 Gitea 服务器地址 docker login 192.168.1.9:2010 # 从官方仓库拉取一个 nginx:latest 镜像，并改名 docker pull nginx:latest docker tag nginx:latest 192.168.1.9:2010/zhangsan/nginx:latest # 推送镜像到 Gitea 服务器 docker push 192.168.1.9:2010/zhangsan/nginx:latest ","permalink":"https://lifeislife.cn/posts/%E4%BD%BF%E7%94%A8gitea%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/","summary":"\u003ch1 id=\"docker-compose-部署\"\u003edocker-compose 部署\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yml\" data-lang=\"yml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eversion\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;3.7\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nt\"\u003eservices\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003epostgres\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eimage\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003epostgres:latest\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003econtainer_name\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003epostgres\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eports\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"m\"\u003e5432\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"m\"\u003e5432\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003enetworks\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003ebr-net-gitea\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eenvironment\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ePOSTGRES_USER\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003euser\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ePOSTGRES_PASSWORD\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"m\"\u003e123456\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ePOSTGRES_DB\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003egitea\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003evolumes\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e./postgresql:/var/lib/postgresql\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e./data:/var/lib/postgresql/data\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003egitea\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eimage\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003egitea/gitea:1.20.5\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003econtainer_name\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003egitea\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eenvironment\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eUSER_UID=1000\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eUSER_GID=1000\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eGITEA__database__DB_TYPE=postgres\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eGITEA__database__HOST=192.168.1.9:5432\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eGITEA__database__NAME=gitea\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eGITEA__database__USER=user\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eGITEA__database__PASSWD=123456\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003erestart\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003ealways\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003enetworks\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003ebr-net-gitea\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003evolumes\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e./data:/data\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/etc/timezone:/etc/timezone:ro\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/etc/localtime:/etc/localtime:ro\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/home/git/.ssh/:/data/git/.ssh\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eports\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"m\"\u003e3000\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"m\"\u003e3000\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;127.0.0.1:2222:22\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003edepends_on\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003epostgres\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003eact_runner\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eimage\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003egitea/act_runner:latest\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eenvironment\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eGITEA_INSTANCE_URL=http://192.168.1.9:3000\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eGITEA_RUNNER_REGISTRATION_TOKEN=Qw5Qf4A1bTENfIOQlc1NSNyFYMLp7TAtSujb5ihF\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eGITEA_RUNNER_NAME=docker_runner\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003evolumes\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/var/run/docker.sock:/var/run/docker.sock\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e./act_runner/act_data:/data\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e./act_runner/act_cache:/root/.cache\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"常见问题\"\u003e常见问题\u003c/h1\u003e\n\u003ch2 id=\"首次登录web时没有创建管理员账号如何登录\"\u003e首次登录web时没有创建管理员账号，如何登录\u003c/h2\u003e\n\u003cp\u003e打开Gitea网页注册的第一个账号就是管理员账号。无需特殊设置。也无需找回密码。\u003c/p\u003e","title":"使用Gitea部署个人代码仓库"},{"content":"买的一些课程配套资料都是 PDF 格式的，为了防止盗版都事先用的图片转成的 PDF，这样 PDF 里的内容既没法复制也没法搜索，在查找资料里的关键词的时候就很不方便，所以就想着把这些 PDF 转成可搜索的 PDF。找到了一款工具叫做 ocrmypdf，可以把 PDF 转成可搜索的 PDF，而且还支持中文，这里记录一下使用方法。详细使用文档可以参考官方文档 OCRmyPDF documentation。\n安装 sudo apt install ocrmypdf 使用 指定 OCR 的语言 安装语言包\nsudo apt install tesseract-ocr-chi-sim 查看是否安装成功\n$ tesseract --list-langs List of available languages (3): chi_sim eng osd 注意参数 -l 后面的语言包名称是下划线，而不是短横线。\nocrmypdf -l chi_sim input.pdf output.pdf $ ocrmypdf -l chi_sim --redo-ocr input.pdf output.pdf Scanning contents: 100%|██████████████████████████████████████████████████████████████████████████████████████████████████████| 752/752 [00:14\u0026lt;00:00, 51.36page/s] Start processing 24 pages concurrently 33 redoing OCR 26 [tesseract] lots of diacritics - possibly poor OCR 54 [tesseract] lots of diacritics - possibly poor OCR 88 [tesseract] lots of diacritics - possibly poor OCR 119 [tesseract] lots of diacritics - possibly poor OCR 203 [tesseract] lots of diacritics - possibly poor OCR 256 [tesseract] lots of diacritics - possibly poor OCR 265 [tesseract] lots of diacritics - possibly poor OCR 347 [tesseract] lots of diacritics - possibly poor OCR 376 [tesseract] lots of diacritics - possibly poor OCR 383 [tesseract] lots of diacritics - possibly poor OCR 386 [tesseract] lots of diacritics - possibly poor OCR 402 [tesseract] lots of diacritics - possibly poor OCR 404 [tesseract] lots of diacritics - possibly poor OCR 403 [tesseract] lots of diacritics - possibly poor OCR 412 [tesseract] lots of diacritics - possibly poor OCR 415 [tesseract] lots of diacritics - possibly poor OCR 410 [tesseract] lots of diacritics - possibly poor OCR 439 [tesseract] lots of diacritics - possibly poor OCR 519 [tesseract] lots of diacritics - possibly poor OCR 526 [tesseract] lots of diacritics - possibly poor OCR 587 [tesseract] lots of diacritics - possibly poor OCR 591 [tesseract] lots of diacritics - possibly poor OCR 595 [tesseract] lots of diacritics - possibly poor OCR 607 [tesseract] lots of diacritics - possibly poor OCR 644 [tesseract] lots of diacritics - possibly poor OCR 661 [tesseract] lots of diacritics - possibly poor OCR 682 [tesseract] lots of diacritics - possibly poor OCR 720 [tesseract] lots of diacritics - possibly poor OCR 742 [tesseract] lots of diacritics - possibly poor OCR OCR: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 752.0/752.0 [03:41\u0026lt;00:00, 3.40page/s] Postprocessing... Some input metadata could not be copied because it is not permitted in PDF/A. You may wish to examine the output PDF\u0026#39;s XMP metadata. PDF/A conversion: 100%|███████████████████████████████████████████████████████████████████████████████████████████████████████| 752/752 [01:09\u0026lt;00:00, 10.80page/s] Recompressing JPEGs: 0image [00:00, ?image/s] Deflating JPEGs: 100%|██████████████████████████████████████████████████████████████████████████████████████████████████████| 756/756 [00:00\u0026lt;00:00, 920.21image/s] JBIG2: 0item [00:00, ?item/s] Optimize ratio: 1.20 savings: 17.0% Output file is okay but is not PDF/A (seems to be No PDF/A metadata in XMP) 转换的结果还不错，页面排版不会改变，保持原样，但是搜索文字时可能需要用空格分开。\n","permalink":"https://lifeislife.cn/posts/ocrmypdf-%E8%AE%A9pdf%E5%8F%AF%E6%90%9C%E7%B4%A2/","summary":"\u003cp\u003e买的一些课程配套资料都是 PDF 格式的，为了防止盗版都事先用的图片转成的 PDF，这样 PDF 里的内容既没法复制也没法搜索，在查找资料里的关键词的时候就很不方便，所以就想着把这些 PDF 转成可搜索的 PDF。找到了一款工具叫做 ocrmypdf，可以把 PDF 转成可搜索的 PDF，而且还支持中文，这里记录一下使用方法。详细使用文档可以参考官方文档\u003ca href=\"https://ocrmypdf.readthedocs.io/en/latest/installation.html\"\u003e OCRmyPDF documentation\u003c/a\u003e。\u003c/p\u003e","title":"ocrmypdf 让 PDF 可搜索"},{"content":" 本次实验是清华大学操作系统课程的课程实验，实验内容是基于 RISC-V 架构的 uCore 操作系统。本次实验的目的是搭建实验环境，为后续实验做准备。指导书参考uCore-Tutorial-Guide-2023S 文档。本系列文章内容主要是指导书的补充以及我在实验过程的一些理解。\n本章没有什么需要特别说明的，指导手册十分详细，按照指导手册的步骤一步步来就可以了。因为平时也在用 WSL2 开发，所以配置十分顺利，没有遇到什么问题。这篇文章就当占坑了，如果后续有什么需要补充的再来更新。\n","permalink":"https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC0%E7%AB%A0-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本次实验是清华大学操作系统课程的课程实验，实验内容是基于 RISC-V 架构的 uCore 操作系统。本次实验的目的是搭建实验环境，为后续实验做准备。指导书参考\u003ca href=\"https://learningos.github.io/uCore-Tutorial-Guide-2023S/index.html\"\u003euCore-Tutorial-Guide-2023S 文档\u003c/a\u003e。本系列文章内容主要是指导书的补充以及我在实验过程的一些理解。\u003c/p\u003e","title":"uCore-实验第 0 章 - 实验环境搭建"},{"content":"了解系统调用 操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送请求，来执行一些必须由操作系统来完成的任务，例如读取文件、创建进程、分配内存等。\n通俗地说，可以把操作系统看作一个巨大的服务员，而应用程序就像是顾客。应用程序不能直接访问硬件或执行特权操作，因为这样可能会导致系统不稳定或不安全。所以，应用程序需要通过系统调用来与操作系统进行交互，请求操作系统代表它完成某些任务。\n当应用程序需要操作系统执行特定的功能时，它会调用适当的系统调用函数，并传递参数给它。然后操作系统会接收到这个请求，并根据请求的类型和参数来执行相应的操作。完成后，操作系统会将执行结果返回给应用程序。\n在 RISC-V 架构中，系统调用是通过使用特定的指令来实现的。具体来说，RISC-V 架构提供了一个称为 ecall（environment call）的指令来触发系统调用。\n要使用 syscall，在 RISC-V 汇编代码中可以通过以下步骤来完成：\n将系统调用编号（syscall number）放入寄存器 a7 中，该编号对应于所需的系统调用功能。 将系统调用所需的参数放入其他相应的寄存器中。例如，参数传递给文件读取系统调用可能需要将文件描述符放入 a0 寄存器，缓冲区地址放入 a1 寄存器，以及读取的字节数放入 a2 寄存器。 执行 ecall 指令。这会触发操作系统处理当前运行的程序的系统调用请求。 操作系统接收到系统调用请求后，根据寄存器 a7 中的系统调用编号和其他寄存器中的参数来执行相应的操作。 当操作系统完成系统调用请求时，它将结果放入适当的寄存器中，通常是 a0 寄存器。 程序继续执行，可以检查结果并进行后续的处理。 需要注意的是，具体的系统调用编号以及参数的传递方式会根据操作系统的实现而有所不同。所以在编写 RISC-V 汇编代码时，需要参考操作系统的相关文档来了解具体的系统调用接口和参数传递方式。\nmakr run 之后发生了什么？ 当执行make run命令后，以下是运行流程的概述：\n内核代码编译：执行make run会触发 Makefile 中的相应规则，从而编译生成内核（kernel）二进制文件。\n加载 kernel 并启动 QEMU：根据 QEMUOPTS 变量指定的参数，QEMU 加载生成的 kernel 二进制文件，并启动模拟器。\n引导代码执行：在模拟器启动后，CPU 的通用寄存器被清零，程序计数器（PC）指向 0x1000 的位置，这里有硬件固化的一小段引导代码。该引导代码会迅速跳转到 0x80000000 处的 RustSBI（Rust Supervisor Binary Interface）。\nRustSBI 完成硬件初始化：RustSBI 是一个用于与操作系统进行交互的接口层。在跳转到 RustSBI 之后，它会完成必要的硬件初始化工作。\n执行操作系统第一条指令：RustSBI 在完成硬件初始化后，会跳转到 kernel 二进制文件所在内存位置 0x80200000 处，并开始执行我们操作系统的第一条指令。\n综上所述，执行make run命令会完成内核的编译和加载，启动 QEMU 虚拟机，并经过引导代码和 RustSBI 的处理，最终开始执行操作系统的第一条指令。\n了解链接脚本 # kernel.ld BASE_ADDRESS = 0x80200000; SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) # 第一行代码 *(.text .text.*) } ... } kernel.ld 中的 BASE_ADDRESS = 0x80200000 指定了内核的加载地址，这个地址哪来的？ 以下内容摘自参考rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档：\n在 Qemu 模拟的 virt 硬件平台上，物理内存的起始物理地址为 0x80000000，物理内存的默认大小为 128MiB，它可以通过 -m 选项进行配置。如果使用默认配置的 128MiB 物理内存则对应的物理地址区间为 [0x80000000,0x88000000) 。如果使用上面给出的命令启动 Qemu，那么在 Qemu 开始执行任何指令之前，首先把两个文件加载到 Qemu 的物理内存中：即作把作为 bootloader 的 rustsbi-qemu.bin 加载到物理内存以物理地址 0x80000000 开头的区域上，同时把内核镜像 os.bin 加载到以物理地址 0x80200000 开头的区域上。\n为什么加载到这两个位置呢？这与 Qemu 模拟计算机加电启动后的运行流程有关。一般来说，计算机加电之后的启动流程可以分成若干个阶段，每个阶段均由一层软件或 固件 负责，每一层软件或固件的功能是进行它应当承担的初始化工作，并在此之后跳转到下一层软件或固件的入口地址，也就是将计算机的控制权移交给了下一层软件或固件。Qemu 模拟的启动流程则可以分为三个阶段：第一个阶段由固化在 Qemu 内的一小段汇编程序负责；第二个阶段由 bootloader 负责；第三个阶段则由内核镜像负责。\n第一阶段：将必要的文件载入到 Qemu 物理内存之后，Qemu CPU 的程序计数器（PC, Program Counter）会被初始化为 0x1000，因此 Qemu 实际执行的第一条指令位于物理地址 0x1000，接下来它将执行寥寥数条指令并跳转到物理地址 0x80000000 对应的指令处并进入第二阶段。从后面的调试过程可以看出，该地址 0x80000000 被固化在 Qemu 中，作为 Qemu 的使用者，我们在不触及 Qemu 源代码的情况下无法进行更改。\n第二阶段：由于 Qemu 的第一阶段固定跳转到 0x80000000，我们需要将负责第二阶段的 bootloader rustsbi-qemu.bin 放在以物理地址 0x80000000 开头的物理内存中，这样就能保证 0x80000000 处正好保存 bootloader 的第一条指令。在这一阶段，bootloader 负责对计算机进行一些初始化工作，并跳转到下一阶段软件的入口，在 Qemu 上即可实现将计算机控制权移交给我们的内核镜像 os.bin。这里需要注意的是，对于不同的 bootloader 而言，下一阶段软件的入口不一定相同，而且获取这一信息的方式和时间点也不同：入口地址可能是一个预先约定好的固定的值，也有可能是在 bootloader 运行期间才动态获取到的值。我们选用的 RustSBI 则是将下一阶段的入口地址预先约定为固定的 0x80200000，在 RustSBI 的初始化工作完成之后，它会跳转到该地址并将计算机控制权移交给下一阶段的软件——也即我们的内核镜像。\n第三阶段：为了正确地和上一阶段的 RustSBI 对接，我们需要保证内核的第一条指令位于物理地址 0x80200000 处。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 0x80200000 开头的区域上。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核，也就达到了本节的目标。\n以上过程是 QEMU 中的启动流程，真实计算机的加电启动流程大致如下： 第一阶段：加电后 CPU 的 PC 寄存器被设置为计算机内部只读存储器（ROM，Read-only Memory）的物理地址，随后 CPU 开始运行 ROM 内的软件。我们一般将该软件称为固件（Firmware），它的功能是对 CPU 进行一些初始化操作，将后续阶段的 bootloader 的代码、数据从硬盘载入到物理内存，最后跳转到适当的地址将计算机控制权转移给 bootloader。它大致对应于 Qemu 启动的第一阶段，即在物理地址 0x1000 处放置的若干条指令。可以看到 Qemu 上的固件非常简单，因为它并不需要负责将 bootloader 从硬盘加载到物理内存中，这个任务此前已经由 Qemu 自身完成了。 第二阶段：bootloader 同样完成一些 CPU 的初始化工作，将操作系统镜像从硬盘加载到物理内存中，最后跳转到适当地址将控制权转移给操作系统。可以看到一般情况下 bootloader 需要完成一些数据加载工作，这也就是它名字中 loader 的来源。它对应于 Qemu 启动的第二阶段。在 Qemu 中，我们使用的 RustSBI 功能较弱，它并没有能力完成加载的工作，内核镜像实际上是和 bootloader 一起在 Qemu 启动之前加载到物理内存中的。 第三阶段：控制权被转移给操作系统。由于篇幅所限后面我们就不再赘述了。 值得一提的是，为了让计算机的启动更加灵活，bootloader 目前可能非常复杂：它可能也分为多个阶段，并且能管理一些硬件资源，从复杂性上它已接近一个传统意义上的操作系统。\n终端是如何控制颜色的？ enum LOG_COLOR { RED = 31, GREEN = 32, BLUE = 34, GRAY = 90, YELLOW = 93, }; #if defined(USE_LOG_ERROR) #define errorf(fmt, ...) \\ do { \\ int tid = threadid(); \\ printf(\u0026#34;\\x1b[%dm[%s %d]\u0026#34; fmt \u0026#34;\\x1b[0m\\n\u0026#34;, RED, \u0026#34;ERROR\u0026#34;, tid, \\ ##__VA_ARGS__); \\ } while (0) #else ANSI 转义码是一种用于控制终端输出的特殊字符序列。它们由\\x1b（或\\033）开头，后面跟着一系列数字和分号组成。\nANSI 转义码中的数字部分用于指定不同的控制操作，如设置文本颜色、背景颜色、光标位置等等。其中，用于设置颜色的转义码包括三个主要的部分：\\x1b[颜色代码m。\n具体来说，\\x1b[表示开始使用控制序列，接下来的数字代表不同的颜色代码，最后的m表示结束控制序列。例如，\\x1b[31m表示将文本颜色设置为红色，而\\x1b[0m用于重置所有属性为默认值。\n当终端遇到这样的转义序列时，它会解析并执行相应的控制操作，从而实现对文本颜色、背景颜色和其他属性的控制。\n需要注意的是，不同的终端可能支持不同的 ANSI 转义码，并且不同操作系统也可能有不同的实现。因此，在编写使用 ANSI 转义码的代码时，建议先测试并确保其在目标终端上正常工作。\n更多详细解释可以参考文章：终端颜色控制 - 简书。\n应用程序输出字符会调用 SBI 服务，SBI 中发生了什么？ 因为对 Rust 语言不熟悉，所以这里的分析是基于 C 语言的 OpenSBI 来分析的，他们的逻辑是一样的。如果有熟悉 Rust 的可以查看 RustSBI 源码\n根据指导书中的解释以及阅读代码，我们知道调用了 printf 最终实际上是调用了 sbi_call。那么 sbi_call 是如何实现的呢？因为我是做驱动开发以及固件开发的，也经常需要使用 OpenSBI，所想多问一句，OpenSBI 是如何实现的呢？OpenSBI 是如何提供服务的呢？它是如何打印出字符的呢？\n内核中的 SBI 调用 我们先看一下内核中的 sbi_call 都做了写啥。\n// uCore-Tutorial-Code-2023S/os/sbi.c const uint64 SBI_CONSOLE_PUTCHAR = 1; void console_putchar(int c) { sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } // uCore-Tutorial-Code-2023S/os/sbi.c int inline sbi_call(uint64 which, uint64 arg0, uint64 arg1, uint64 arg2) { // 使用寄存器变量来保存参数值和系统调用编号 register uint64 a0 asm(\u0026#34;a0\u0026#34;) = arg0; // 将 \u0026#39;arg0\u0026#39; 的值保存在寄存器 \u0026#39;a0\u0026#39; 中 register uint64 a1 asm(\u0026#34;a1\u0026#34;) = arg1; // 将 \u0026#39;arg1\u0026#39; 的值保存在寄存器 \u0026#39;a1\u0026#39; 中 register uint64 a2 asm(\u0026#34;a2\u0026#34;) = arg2; // 将 \u0026#39;arg2\u0026#39; 的值保存在寄存器 \u0026#39;a2\u0026#39; 中 register uint64 a7 asm(\u0026#34;a7\u0026#34;) = which; // 将 \u0026#39;which\u0026#39; 的值保存在寄存器 \u0026#39;a7\u0026#39; 中 // 内联汇编代码使用 ecall 指令进行系统调用 asm volatile( \u0026#34;ecall\u0026#34; // 使用 ecall 指令进行系统调用 // 在这段代码中，指令 \u0026#34;ecall\u0026#34; 的输入参数是寄存器 a0 a1 a2 和 a7，输出参数是寄存器 a0 : \u0026#34;=r\u0026#34;(a0) // 输出操作数：将返回值存储在变量 \u0026#39;a0\u0026#39; 中 : \u0026#34;r\u0026#34;(a0), \u0026#34;r\u0026#34;(a1), \u0026#34;r\u0026#34;(a2), \u0026#34;r\u0026#34;(a7) // 输入操作数：传递参数和系统调用编号 : \u0026#34;memory\u0026#34; // \u0026#34;memory\u0026#34; 标志告诉编译器，这条指令可能会修改内存中的数据，需要进行内存屏障操作来保证数据的正确性。 ); return a0; // 返回存储在变量 \u0026#39;a0\u0026#39; 中的值 } 那么 OpenSBI 如何提供服务？在include/sbi/sbi_ecall.h这种定义了每个ecall服务全局变量。\n//include/sbi/sbi_ecall.h extern struct sbi_ecall_extension ecall_base; extern struct sbi_ecall_extension ecall_legacy; extern struct sbi_ecall_extension ecall_time; extern struct sbi_ecall_extension ecall_rfence; extern struct sbi_ecall_extension ecall_ipi; extern struct sbi_ecall_extension ecall_vendor; extern struct sbi_ecall_extension ecall_hsm; extern struct sbi_ecall_extension ecall_srst; 在lib/sbi/sbi_ecall.c中注册了所有的ecall服务，并将其加到链表ecall_exts_list中。\nint sbi_ecall_init(void) { int ret; struct sbi_ecall_extension *ext; unsigned long i; for (i = 0; i \u0026lt; sbi_ecall_exts_size; i++) { ext = sbi_ecall_exts[i]; ret = sbi_ecall_register_extension(ext); if (ret) return ret; } return 0; } int sbi_ecall_register_extension(struct sbi_ecall_extension *ext) { struct sbi_ecall_extension *t; if (!ext || (ext-\u0026gt;extid_end \u0026lt; ext-\u0026gt;extid_start) || !ext-\u0026gt;handle) return SBI_EINVAL; sbi_list_for_each_entry(t, \u0026amp;ecall_exts_list, head) { unsigned long start = t-\u0026gt;extid_start; unsigned long end = t-\u0026gt;extid_end; if (end \u0026lt; ext-\u0026gt;extid_start || ext-\u0026gt;extid_end \u0026lt; start) /* no overlap */; else return SBI_EINVAL; } SBI_INIT_LIST_HEAD(\u0026amp;ext-\u0026gt;head); sbi_list_add_tail(\u0026amp;ext-\u0026gt;head, \u0026amp;ecall_exts_list); return 0; } /** * Iterate over list of given type * @param pos the type * to use as a loop cursor. * @param head the head for your list. * @param member the name of the list_struct within the struct. */ #define sbi_list_for_each_entry(pos, head, member) \\ for (pos = sbi_list_entry((head)-\u0026gt;next, typeof(*pos), member);\t\\ \u0026amp;pos-\u0026gt;member != (head); \\ pos = sbi_list_entry(pos-\u0026gt;member.next, typeof(*pos), member)) 那么服务 id 如何和相对应的服务绑定的呢？以ecall_time为例，查看其结构体原型struct sbi_ecall_extension ：\n// include/sbi/sbi_ecall.h: 23 struct sbi_ecall_extension { struct sbi_dlist head; unsigned long extid_start; unsigned long extid_end; int (* probe)(unsigned long extid, unsigned long *out_val); int (* handle)(unsigned long extid, unsigned long funcid, const struct sbi_trap_regs *regs, unsigned long *out_val, struct sbi_trap_info *out_trap); }; 可以看到有 extid_start、extid_end 和 handle。\n目前 OpenSBI 逐步将每个服务的实现都放在了lib/sbi单独文件中，以ecall_time为例，其实现在lib/sbi/sbi_ecall_time.c中。单独为其绑定回调处理函数sbi_ecall_time_handler。但是还有很多服务的实现还是放在了lib/sbi/sbi_ecall_legacy.c中，后续应该会逐步迁移。我们上文使用的SBI_CONSOLE_PUTCHAR服务就是在这里实现的。\n// lib/sbi/sbi_ecall_legacy.c struct sbi_ecall_extension ecall_legacy = { .extid_start = SBI_EXT_0_1_SET_TIMER, .extid_end = SBI_EXT_0_1_SHUTDOWN, .handle = sbi_ecall_legacy_handler, }; static int sbi_ecall_legacy_handler(unsigned long extid, unsigned long funcid, const struct sbi_trap_regs *regs, unsigned long *out_val, struct sbi_trap_info *out_trap) { int ret = 0; struct sbi_tlb_info tlb_info; u32 source_hart = current_hartid(); ulong hmask = 0; switch (extid) { case SBI_EXT_0_1_SET_TIMER: sbi_timer_event_start((u64)regs-\u0026gt;a0); break; case SBI_EXT_0_1_CONSOLE_PUTCHAR: sbi_putc(regs-\u0026gt;a0); break; case SBI_EXT_0_1_CONSOLE_GETCHAR: ret = sbi_getc(); break; // ... }; return ret; } 这就把 id 与相应的服务函数绑定。一个extid对应一个handler。\n我们可以在找到SBI_EXT_0_1_CONSOLE_PUTCHAR的值，是与 Linux 内核里定义的值是一致的。\n// include/sbi/sbi_ecall_interface.h /* SBI Extension IDs */ #define SBI_EXT_0_1_CONSOLE_PUTCHAR\t0x1 ecall 服务调用流程 在 firmware/fw_base.S 中注册了 Machine Mode 的 trap handler，即 sbi_trap_handler；\n_start_warm: /* Setup trap handler */ la\ta4, _trap_handler csrw\tCSR_MTVEC, a4 /* CSR_MTVEC = _trap_handler */ _trap_handler: TRAP_SAVE_AND_SETUP_SP_T0 TRAP_SAVE_MEPC_MSTATUS 0 TRAP_SAVE_GENERAL_REGS_EXCEPT_SP_T0 TRAP_CALL_C_ROUTINE TRAP_RESTORE_GENERAL_REGS_EXCEPT_SP_T0 TRAP_RESTORE_MEPC_MSTATUS 0 TRAP_RESTORE_SP_T0 mret .macro\tTRAP_CALL_C_ROUTINE /* Call C routine */ add\ta0, sp, zero call\tsbi_trap_handler .endm 在 lib/sbi/sbi_trap.c 中定义了 sbi_trap_handler，处理各种 mcause，比如 Illegal Instructions，Misaligned Load \u0026amp; Store, Supervisor \u0026amp; Machine Ecall 等。\n// lib/sbi/sbi_trap.c void sbi_trap_handler(struct sbi_trap_regs *regs) { ... switch (mcause) { case CAUSE_ILLEGAL_INSTRUCTION: rc = sbi_illegal_insn_handler(mtval, regs); break; case CAUSE_MISALIGNED_LOAD: rc = sbi_misaligned_load_handler(mtval, mtval2, mtinst, regs); break; case CAUSE_MISALIGNED_STORE: rc = sbi_misaligned_store_handler(mtval, mtval2, mtinst, regs); break; case CAUSE_SUPERVISOR_ECALL: case CAUSE_MACHINE_ECALL: rc = sbi_ecall_handler(regs); break; default: /* If the trap came from S or U mode, redirect it there */ trap.epc = regs-\u0026gt;mepc; trap.cause = mcause; trap.tval = mtval; trap.tval2 = mtval2; trap.tinst = mtinst; rc = sbi_trap_redirect(regs, \u0026amp;trap); break; }; ... 在 lib/sbi/sbi_ecall.c 中定义了处理 ecall mcause 的 sbi_ecall_handler，它遍历上面 ecall_exts_list 中注册的各种 ecall 服务。\nsbi_ecall_handler 根据 Linux 内核传递的 ext (extension id) 找到链表中对应的 ecall 服务，执行其中的 handle 函数，该函数根据 fid 执行具体的服务内容。\n// lib/sbi/sbi_ecall.c int sbi_ecall_handler(struct sbi_trap_regs *regs) { // ... unsigned long extension_id = regs-\u0026gt;a7; unsigned long func_id = regs-\u0026gt;a6; struct sbi_trap_info trap = {0}; unsigned long out_val = 0; // 遍历所有 ecall 服务 ext = sbi_ecall_find_extension(extension_id); if (ext \u0026amp;\u0026amp; ext-\u0026gt;handle) { // 如果找到了就执行 ret = ext-\u0026gt;handle(extension_id, func_id, regs, \u0026amp;out_val, \u0026amp;trap); if (extension_id \u0026gt;= SBI_EXT_0_1_SET_TIMER \u0026amp;\u0026amp; extension_id \u0026lt;= SBI_EXT_0_1_SHUTDOWN) is_0_1_spec = 1; } else { ret = SBI_ENOTSUPP; } ... } 我们可以发现 extension_id 就是 a7 寄存器，他和我们在 uCore OS 中定义的 SBI_EXT_0_1_CONSOLE_PUTCHAR 是一致的。\n程序的内存布局与编译流程 程序的内存布局 uCore 的编译系统 .PHONY: clean build user # 设置伪目标clean、build和user，可以通过命令make来执行这些目标 all: build_kernel # 默认目标为build_kernel，即执行build_kernel目标下的指令 LOG ?= error # 定义一个变量LOG，默认值是error K = os TOOLPREFIX = riscv64-unknown-elf- CC = $(TOOLPREFIX)gcc AS = $(TOOLPREFIX)gcc LD = $(TOOLPREFIX)ld OBJCOPY = $(TOOLPREFIX)objcopy OBJDUMP = $(TOOLPREFIX)objdump PY = python3 GDB = $(TOOLPREFIX)gdb CP = cp MKDIR_P = mkdir -p BUILDDIR = build C_SRCS = $(wildcard $K/*.c) # 定义一个变量C_SRCS，使用wildcard函数匹配所有以.c为后缀的文件，并存储在$K目录下 AS_SRCS = $(wildcard $K/*.S) # 定义一个变量AS_SRCS，使用wildcard函数匹配所有以.S为后缀的文件，并存储在$K目录下 C_OBJS = $(addprefix $(BUILDDIR)/, $(addsuffix .o, $(basename $(C_SRCS)))) # 定义一个变量C_OBJS，通过addprefix和addsuffix函数将$(C_SRCS)中的路径替换为$(BUILDDIR)，并将后缀修改为.o AS_OBJS = $(addprefix $(BUILDDIR)/, $(addsuffix .o, $(basename $(AS_SRCS)))) # 定义一个变量AS_OBJS，通过addprefix和addsuffix函数将$(AS_SRCS)中的路径替换为$(BUILDDIR)，并将后缀修改为.o OBJS = $(C_OBJS) $(AS_OBJS) # 定义一个变量OBJS，其值为$(C_OBJS)和$(AS_OBJS)的组合 HEADER_DEP = $(addsuffix .d, $(basename $(C_OBJS))) # 定义一个变量HEADER_DEP，通过addsuffix函数将$(C_OBJS)中的后缀修改为.d -include $(HEADER_DEP) # 包含$(HEADER_DEP)中的.d文件 CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb # 定义一个变量CFLAGS，并赋值为-Wall -Werror -O -fno-omit-frame-pointer -ggdb CFLAGS += -MD # 将-MD选项追加到CFLAGS变量中，用于自动生成依赖关系文件 CFLAGS += -mcmodel=medany # 将-mcmodel=medany选项追加到CFLAGS变量中，用于指定内存模型 CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax # 将-ffreestanding -fno-common -nostdlib -mno-relax选项追加到CFLAGS变量中，用于编译无操作系统环境下的程序 CFLAGS += -I$K # 将-I$K选项追加到CFLAGS变量中，用于指定头文件搜索路径为$K目录下 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; echo -fno-stack-protector) # 将$(CC) -fno-stack-protector -E -x c /dev/null \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; echo -fno-stack-protector命令执行结果追加到CFLAGS变量中，用于禁用栈保护机制 ifeq ($(LOG), error) CFLAGS += -D LOG_LEVEL_ERROR else ifeq ($(LOG), warn) CFLAGS += -D LOG_LEVEL_WARN else ifeq ($(LOG), info) CFLAGS += -D LOG_LEVEL_INFO else ifeq ($(LOG), debug) CFLAGS += -D LOG_LEVEL_DEBUG else ifeq ($(LOG), trace) CFLAGS += -D LOG_LEVEL_TRACE endif # 根据$(LOG)变量的值，向CFLAGS变量追加相应的预处理器选项，相当于添加了一个宏定义，log.h中的LOG_LEVEL_ERROR等宏定义会根据这个宏定义来决定是否生效 # Disable PIE when possible (for Ubuntu 16.10 toolchain) ifneq ($(shell $(CC) -dumpspecs 2\u0026gt;/dev/null | grep -e \u0026#39;[^f]no-pie\u0026#39;),) CFLAGS += -fno-pie -no-pie endif ifneq ($(shell $(CC) -dumpspecs 2\u0026gt;/dev/null | grep -e \u0026#39;[^f]nopie\u0026#39;),) CFLAGS += -fno-pie -nopie endif # 根据系统环境判断是否支持PIE（位置无关执行）选项，并根据情况向CFLAGS变量追加相应的选项 LDFLAGS = -z max-page-size=4096 # 定义一个变量LDFLAGS，并赋值为-z max-page-size=4096 $(AS_OBJS): $(BUILDDIR)/$K/%.o : $K/%.S @mkdir -p $(@D) $(CC) $(CFLAGS) -c $\u0026lt; -o $@ # 规则：生成$(AS_OBJS)目标所需的依赖文件$(BUILDDIR)/$K/%.o，依赖于$K/%.S，并通过$(CC)命令编译生成目标文件 $(C_OBJS): $(BUILDDIR)/$K/%.o : $K/%.c $(BUILDDIR)/$K/%.d @mkdir -p $(@D) $(CC) $(CFLAGS) -c $\u0026lt; -o $@ # 规则：生成$(C_OBJS)目标所需的依赖文件$(BUILDDIR)/$K/%.o，依赖于$K/%.c和$(BUILDDIR)/$K/%.d，并通过$(CC)命令编译生成目标文件 $(HEADER_DEP): $(BUILDDIR)/$K/%.d : $K/%.c @mkdir -p $(@D) @set -e; rm -f $@; $(CC) -MM $\u0026lt; $(INCLUDEFLAGS) \u0026gt; $@.$$$$; \\ sed \u0026#39;s,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g\u0026#39; \u0026lt; $@.$$$$ \u0026gt; $@; \\ rm -f $@.$$$$ # 规则：生成$(HEADER_DEP)目标所需的依赖文件$(BUILDDIR)/$K/%.d，依赖于$K/%.c，并通过$(CC)命令生成依赖关系文件 build: build/kernel # 定义一个目标build，其依赖于build/kernel build/kernel: $(OBJS) $(LD) $(LDFLAGS) -T os/kernel.ld -o $(BUILDDIR)/kernel $(OBJS) $(OBJDUMP) -S $(BUILDDIR)/kernel \u0026gt; $(BUILDDIR)/kernel.asm $(OBJDUMP) -t $(BUILDDIR)/kernel | sed \u0026#39;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d\u0026#39; \u0026gt; $(BUILDDIR)/kernel.sym @echo \u0026#39;Build kernel done\u0026#39; # 规则：生成build/kernel目标，依赖于$(OBJS)，通过$(LD)命令连接生成kernel，并通过$(OBJDUMP)命令生成汇编文件和符号表 clean: rm -rf $(BUILDDIR) # BOARD BOARD\t?= qemu SBI\t?= rustsbi BOOTLOADER\t:= ./bootloader/rustsbi-qemu.bin QEMU = qemu-system-riscv64 QEMUOPTS = \\ -nographic \\ -machine virt \\ -bios $(BOOTLOADER) \\ -kernel build/kernel\t\\ run: build/kernel $(QEMU) $(QEMUOPTS) # QEMU\u0026#39;s gdb stub command line changed in 0.11 QEMUGDB = $(shell if $(QEMU) -help | grep -q \u0026#39;^-gdb\u0026#39;; \\ then echo \u0026#34;-gdb tcp::15234\u0026#34;; \\ else echo \u0026#34;-s -p 15234\u0026#34;; fi) # 启动QEMU并通过GDB调试，此时QEMu会进入后台运行，并暂停执行，等待GDB连接 # 连接的GDB端口为15234 debug: build/kernel .gdbinit $(QEMU) $(QEMUOPTS) -S $(QEMUGDB) \u0026amp; sleep 1 $(GDB) 编译、运行 uCore 的一些常用命令有如下一些，涉及了后续章节中引入的测试用例中的命令：\nmake run make debug make clean # 编译测试用例的前四章 make user CHAPTER=4 LOG=trace # 编译测试用例的第四章 make user CHAPTER=4_only LOG=trace # 只运行测试用例的第四章 make test CHAPTER=4_only 附录 makefile 和 qemu\nAS = $(TOOLPREFIX)gas \u0026gt; AS = $(TOOLPREFIX)as\n参考资料 终端颜色控制 - 简书 ","permalink":"https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC1%E7%AB%A0-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/","summary":"\u003ch1 id=\"了解系统调用\"\u003e了解系统调用\u003c/h1\u003e\n\u003cp\u003e操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送请求，来执行一些必须由操作系统来完成的任务，例如读取文件、创建进程、分配内存等。\u003c/p\u003e","title":"uCore-实验第 1 章 - 应用程序与基本执行环境"},{"content":"首先，.section .data 表示定义了一个数据段，在这个段中定义了一系列的全局变量。其中，_app_num 是一个标签，表示一个 64 位的整数，初始值为 23。接下来是一系列的标签，分别代表了应用程序的起始地址，每个标签都是 64 位的整数。\n接着，.section .data 后面又出现了一个标签 _app_names，它是一个字符串数组，包含了一组字符串，分别命名为 \u0026ldquo;ch2b_exit\u0026rdquo;、\u0026ldquo;ch2b_hello_world\u0026rdquo;、\u0026ldquo;ch2b_power\u0026rdquo; 等等。这些字符串名字对应了前面定义的应用程序的起始地址。\n再往下，出现了一个标签 INIT_PROC，它是一个字符串，表示初始化进程的名称，值为 \u0026ldquo;usershell\u0026rdquo;。\n之后，每个应用程序都有自己的标签和段名，比如 app_0_start、app_1_start 等等。每个标签都包含一个指令 .incbin，它用于将一个二进制文件（以字符串形式指定文件路径）插入到当前段中。\n进程初始化分析 scheduler() fetch_task() // 获取下一个要执行的进程 swtch(\u0026amp;curenv-\u0026gt;context, nextenv-\u0026gt;context) // 切换到下一个进程上下文 // Per-process state struct proc { enum procstate state; // 进程状态 int pid; // 进程 ID uint64 ustack; // 进程用户栈虚拟地址 (用户页表) uint64 kstack; // 进程内核栈虚拟地址 (内核页表) struct trapframe *trapframe; // 进程中断帧 struct context context; // 用于保存进程内核态的寄存器信息，进程切换时使用 pagetable_t pagetable; // User page table uint64 max_page; uint64 program_brk; uint64 heap_bottom; struct proc * parent; // Parent process uint64 exit_code; struct file * files[FD_BUFFER_SIZE]; uint32 syscall_times[MAX_SYSCALL_NUM]; // 系统调用次数统计 uint64 start_time; // 进程开始运行时间 struct vma vmas[NVMA]; // 虚拟内存区域 }; wait 系统调用的功能 wait 系统调用是用于处理子进程终止状态的系统调用。其主要功能是等待子进程的终止，并获取子进程的退出状态信息。在操作系统中，当一个父进程创建了一个子进程后，通常会使用 wait 来等待子进程的终止，以便进行后续的处理，如回收子进程的资源或获取其运行结果。\n以下是 wait 系统调用的主要功能：\n等待子进程终止：父进程调用 wait 系统调用后，会进入阻塞状态，等待子进程终止。如果子进程已经终止，那么 wait 立即返回，否则父进程会一直等待直到子进程终止。\n获取子进程的退出状态：wait 系统调用会获取子进程的退出状态信息，包括子进程的退出码（通常是一个整数）。这个退出码可以告诉父进程子进程的终止情况，例如是否成功执行等。\n回收子进程资源：一旦子进程终止，其占用的系统资源（如内存、文件描述符等）通常需要由父进程来回收，以避免资源泄漏。wait 系统调用在等待子进程终止后，会自动回收这些资源。\n处理僵尸进程：在某些情况下，子进程可能会在终止后成为僵尸进程，即已经终止但其进程描述符仍然存在。父进程可以使用 wait 来回收这些僵尸进程，释放相关资源。\nexec、fork 和 spawn 是操作系统中常见的进程管理系统调用，各自具有不同的功能和用途：\nexec 系统调用：\n功能：exec 系统调用用于在当前进程的上下文中加载并执行一个新的程序。 用途：通常在一个进程需要替换自身的执行映像时使用。它会加载一个新的可执行文件，覆盖当前进程的地址空间和代码段，然后开始执行新的程序。这个新程序可以是完全不同的程序，从而允许进程动态切换到不同的应用程序，而不需要创建新的进程。 fork 系统调用：\n功能：fork 系统调用用于创建一个与当前进程几乎完全相同的新进程，包括代码、数据和上下文等。 用途：通常用于创建新的进程，新进程称为子进程，它从父进程继承了大部分状态，然后可以在独立的地址空间中执行不同的操作。fork 创建的子进程是父进程的副本，可以并行执行不同的任务。 spawn 系统调用：\n功能：spawn 系统调用通常用于创建新的进程并执行指定的程序。 用途：类似于 fork，它也创建了一个新的进程，但不像 fork 那样完全复制父进程。相反，spawn 允许你指定一个新程序的路径和参数，而不是完全复制当前进程的状态。这使得它更适合用于启动新程序，而不是简单地创建一个进程副本。 总结：\nexec 用于替换当前进程的执行映像，允许加载和执行新程序。 fork 用于创建一个几乎与父进程相同的新进程，新进程成为父进程的副本。 spawn 通常用于创建一个新进程并执行指定的程序，允许指定不同的程序路径和参数。 附录 本章任务： 在次 -\u0026gt; 在此\n","permalink":"https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC5%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","summary":"\u003cp\u003e首先，\u003ccode\u003e.section .data\u003c/code\u003e 表示定义了一个数据段，在这个段中定义了一系列的全局变量。其中，\u003ccode\u003e_app_num\u003c/code\u003e 是一个标签，表示一个 64 位的整数，初始值为 23。接下来是一系列的标签，分别代表了应用程序的起始地址，每个标签都是 64 位的整数。\u003c/p\u003e","title":"uCore 实验第 5 章 - 进程及进程管理"},{"content":" 为何指定 TRAMPOLINE 和 TRAPFRAME 在 va 的最高位？ TRAMPOLINE 和 TRAPFRAME 被定义在最高的虚拟内存地址上，是因为它们在操作系统的内存布局中起着重要作用。 TRAMPOLINE 被用作从用户模式切换到内核模式的跳转目标。当发生异常或中断时，处理器将从用户模式切换到内核模式，并将控制权转移到内核中预定义的位置，也就是陷阱处理程序。TRAMPOLINE 页面被映射到最高虚拟地址，以便处理器能够在这个转换过程中方便地引用它。通过将其放置在最高地址，确保了无论系统的具体内存布局如何，它始终是可访问的。 另一方面，TRAPFRAME 用于在发生异常或中断时存储机器状态。它包含寄存器、标志和其他操作系统处理异常所需的信息。TRAPFRAME 也被放置在最高的虚拟地址上，以确保它易于访问，并且陷阱处理程序可以高效地访问它。 通过将 TRAMPOLINE 和 TRAPFRAME 定义在最高的虚拟内存地址上，内核可以方便而可靠地处理异常和中断，而无需关心它们在内存中的特定位置。\n如何确定分页方案 - satp 在 MMU 没有使能的情况下，虚拟地址和物理地址是相同的。在 MMU 使能的情况下，虚拟地址会被转换成物理地址。这个转换过程是由操作系统来管理的，操作系统需要维护一个数据结构来记录虚拟地址和物理地址的映射关系。这个数据结构就是页表。\n转换的过程需要分页机制，分页机制有多种。RISC-V 的分页方案以 SvX 的模式命名，其中 X 是以位为单位的虚拟地址的长度。在 RV64 架构下，RISC-V 支持多种分页方案，包括 Sv39，Sv48，Sv57 以及 Sv64。Sv39 最大支持 39 位的虚拟地址，这意味着它可以支持 512 GB 的虚拟地址空间。Sv48 最大支持 48 位的虚拟地址，这意味着它可以支持 256 TB 的虚拟地址空间。我们将在本章中实现 Sv39 分页方案。\n如何开启分页机制呢？RISC-V 的分页机制是通过 satp（Supervisor address translation and protection）寄存器来开启的。satp 寄存器字段分布如下：\n\u003c!DOCTYPE html\u003e Responsive Image Mode 字段可以决定是否开启分页以及分页级数。Mode=0 时，不开启分页；Mode=8 时，开启 Sv39 分页机制。 ASID（Address Space Identifier，地址空间标识符）域是可选的，它可以用来降低上下文切换的开销。目前我们暂不考虑这个字段的作用。 PPN（Physical Page Number，物理页号），保存了根页表的物理地址。 SV39 多级页表机制 页表项描述 \u003c!DOCTYPE html\u003e Responsive Image Sv39 页表项（page-table entry，PTE）的布局，从左到右分别包含如下所述的域：\nV 位决定了该页表项的其余部分是否有效 (V=1 时有效)。若 V=0，则任何遍历到此页表项的虚址转换操作都会导致页错误。 R、W 和 X 位分别表示此页是否可以读取、写入和执行。如果这三个位都是 0，那么这个页表项是指向下一级页表的指针，否则它是页表树的一个叶节点。 U 位表示该页是否是用户页面。若 U=0，则 U 模式不能访问此页面，但 S 模式可以。若 U=1，则 U 模式下能访问这个页面，而 S 模式不能。 G 位表示这个映射是否对所有虚址空间有效，硬件可以用这个信息来提高地址转换的性能。这一位通常只用于属于操作系统的页面。 A 位表示自从上次 A 位被清除以来，该页面是否被访问过。 D 位表示自从上次清除 D 位以来页面是否被弄脏（例如被写入）。 RSW 域留给操作系统使用，它会被硬件忽略。 PPN 域包含物理页号，这是物理地址的一部分。若这个页表项是一个叶节点，那么 PPN 是转换后物理地址的一部分。否则 PPN 给出下一节页表的地址。 虚拟地址转换物理地址过程 \u003c!DOCTYPE html\u003e Responsive Image 当 satp 寄存器中开启分页时，S 模式和 U 模式中访存的地址都会被视为虚拟地址，需要将其转换为物理地址。虚拟地址转换物理地址的过程如下：\n从 satp 寄存器中读取 PPN，得到根页表的物理地址，为了表述方便，我们将其记做三级页表基地址 satp.PPN； 从虚拟地址中取出三级虚拟页号 L2 处理器会读取地址位于 satp.PPN * 4096 + L2 * 4 的页表项，得到下一级页表的基地址 L1.PPN； 从虚拟地址中取出二级虚拟页号 L1 处理器会读取地址位于 L1.PPN * 4096 + L1 * 4 的页表项，得到下一级页表的基地址 L0.PPN； 从虚拟地址中取出一级虚拟页号 L0 处理器会读取地址位于 L0.PPN * 4096 + L0 * 4 的页表项，得到物理页号 PPN； 将 PPN 和虚拟地址的低 12 位也就是 Offset 拼接起来，得到物理地址。 我们看代码中是如何实现的：\n#define PTE2PA(pte) (((pte) \u0026gt;\u0026gt; 10) \u0026lt;\u0026lt; 12) // 从虚拟地址中提取三个 9 位的页表索引 #define PXMASK 0x1FF // 9 // PGSHIFT = 12，这段宏定义用于定位 VPNx 的位置 #define PXSHIFT(level) (PGSHIFT + (9 * (level))) // 从虚拟地址 VA 中提取出第 level 级页表的索引 #define PX(level, va) ((((uint64)(va)) \u0026gt;\u0026gt; PXSHIFT(level)) \u0026amp; PXMASK) 上面这三个工具宏可以用来提取虚拟页号 VPN。\n// 返回页表 pagetable 中与虚拟地址 va 对应的 PTE 的地址。 // 如果 alloc != 0，则创建所需的页表页。 // // RISC-V Sv39 方案有三级页表页。一个页表页包含 512 个 64 位的 PTEs。 // 一个 64 位的虚拟地址被分为五个字段： // 39..63 -- 必须为零。 // 30..38 -- 2 级索引的 9 位。 // 21..29 -- 1 级索引的 9 位。 // 12..20 -- 0 级索引的 9 位。 // 0..11 -- 页面内的 12 位字节偏移量。 // pagetable 页表 // va 虚拟地址 // alloc 页表项不存在时是否分配 pte_t *walk(pagetable_t pagetable, uint64 va, int alloc) { if (va \u0026gt;= MAXVA) panic(\u0026#34;walk\u0026#34;); for (int level = 2; level \u0026gt; 0; level--) { pte_t *pte = \u0026amp;pagetable[PX(level, va)]; // 通过 PTE 的标志位判断每一级的 pte 是否是有效的（V 位） if (*pte \u0026amp; PTE_V) { pagetable = (pagetable_t)PTE2PA(*pte); } else { // 如果该项无效且 alloc 标志被设置，则分配一个新的页表 // 如果 alloc 参数=0 或者已经没有空闲的内存了，那么遇到中途 V=0 的 pte 整个 walk 过程就会直接退出 if (!alloc || (pagetable = (pde_t *)kalloc()) == 0) { return 0; } // 清空分配的页表 memset(pagetable, 0, PGSIZE); // 更新页表项，将其指向新分配的页表，并设置有效位 PTE_V *pte = PA2PTE(pagetable) | PTE_V; } } // 返回最低级和虚拟地址的页表项，不是返回物理地址 return \u0026amp;pagetable[PX(0, va)]; } 每次从虚拟地址 va 中提取出一个虚拟页号，然后根据这个虚拟页号从页表中取出下一级页表的基地址。如果这个页表项无效，那么根据 alloc 参数决定是否分配一个新的页表。如果 alloc 参数为 0 或者已经没有空闲的内存了，那么遇到中途 V=0 的 pte 整个 walk 过程就会直接退出。如果 alloc 参数为 1，那么就会分配一个新的页表，然后将这个页表项指向新分配的页表，并设置有效位 PTE_V。\n我们可以发现 walk 返回的结果不是物理地址，而是页表项的地址。这是因为 walk 函数的作用是将虚拟地址转换为物理地址，而页表项中的 PPN 只是物理地址的一部分，还需要加上虚拟地址的低 12 位偏移量才能得到物理地址。\n如何建立页表 前面的过程实际上是以用户的角度来考虑的，也就是给你一个虚拟地址按照分页的规则将其转化成物理地址就能访问了。但是作为一个操作系统，我们还需要多考虑一下，页表是哪来的？我们知道从虚拟地址中去获取页表地址，但是页表的内容是哪来的呢？页表是如何建立起来的呢？这些是需要操作系统来完成的。\n建立页表也就是建立虚拟地址到物理地址的映射关系。也就是给你一个虚拟地址，你需要告诉我如何查到物理地址，实际上这个过程就是建立页表的过程。这个过程也是通过 walk 函数来完成的，从上文我们知道如果页表都建好的情况下 walk 就是不断查页表的过程，那么在没有页表的情况下，walk 还可以建立一个个页表。稍有不同的是，walk 返回的是最后一级页表项的地址，我们需要将物理地址写入这个页表项中。\n在 uCore 中使用 mappages 函数封装了 walk 函数，具体如下：\n#define PA2PTE(pa) ((((uint64)pa) \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 10) /** * 为从虚拟地址 va 开始的页面创建指向物理地址 pa 开始的页表项（PTE） * 注意：va 和 size 可能不是页面对齐的 * 如果无法分配所需的页表，则返回 0，否则返回 -1 * * @param pagetable 根页表地址 * @param va 虚拟地址 * @param size 映射的字节数 * @param pa 物理地址 * @param perm 权限位 * @return 成功返回 0，否则返回 -1 */ int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) { uint64 virtualAddress, lastVirtualAddress; pte_t *pte; // 地址必须是页面对齐的 virtualAddress = PGROUNDDOWN(va); lastVirtualAddress = PGROUNDDOWN(va + size - 1); for (;;) { // 返回最低级的虚拟地址的页表项，如果不存在会创建一个新的页表项 // 页表项可能会因为内存不足创建失败，如果创建失败，则返回 -1 if ((pte = walk(pagetable, virtualAddress, 1)) == 0) { return -1; } // 如果 PTE 已经有效，则输出错误信息并返回 -1 if (*pte \u0026amp; PTE_V) { errorf(\u0026#34;remap\u0026#34;); return -1; } // 将物理地址 pa 转换为页表项，并设置权限位 perm 和 有效位 PTE_V *pte = PA2PTE(pa) | perm | PTE_V; // 如果当前是最后一个地址，则结束循环 if (virtualAddress == lastVirtualAddress) { break; } virtualAddress += PGSIZE; pa += PGSIZE; } return 0; } 问答作业 请列举 SV39 页表页表项的组成，结合课堂内容，描述其中的标志位有何作用／潜在作用？ Sv39 页表页表项的组成如下：\n有效位 (V)：这是页表项的最高位，用于指示页表项是否有效。如果有效位设置为 1，表示页表项有效，可以使用；如果设置为 0，表示页表项无效，禁止使用。这是虚拟内存中页表项的基本有效性标志。 写入位 (W)：这个标志位用于指示是否可以对此页进行写入操作。如果设置为 1，表示允许写入；如果设置为 0，表示禁止写入。它是页表项的访问权限控制标志之一。 用户位 (U)：用户位用于指示是否允许用户态程序访问此页。如果设置为 1，表示允许用户态访问；如果设置为 0，表示只允许内核态访问。它是页表项的访问权限控制标志之一。 执行位 (X)：执行位用于指示是否允许执行此页上的指令。如果设置为 1，表示允许执行；如果设置为 0，表示禁止执行。它也是页表项的访问权限控制标志之一。 全局位 (G)：全局位用于指示此页是否是全局的，即无需 TLB 缓存，通常用于内核页。如果设置为 1，表示是全局的；如果设置为 0，表示不是全局的。 已访问位 (A)：已访问位表示是否已经访问过此页，通常由硬件设置。操作系统可以用它来实现页面置换算法，如 LRU。 已修改位 (D)：已修改位表示是否已经对此页进行了写入操作。与已访问位类似，操作系统可以用它来实现页面置换算法。 物理页框地址 (PPN)：这是页表项中存储的物理页框的地址。它指示了虚拟页到物理页的映射关系。 Sv39 页表的页表项标志位允许操作系统和硬件实现对虚拟内存的细粒度控制和保护。不同的标志位组合可以实现不同级别的内存保护和权限控制，从而提高系统的安全性和可用性。例如，有效位、写入位、用户位和执行位的不同组合可以实现不同级别的内存保护，使操作系统可以将不同的内存区域分配给用户态和内核态，并设置不同的权限。已访问位和已修改位则用于实现页面置换算法，帮助操作系统决定哪些页面应该被置换出去，以优化内存利用率。全局位可以用于标识全局共享的页，从而节省 TLB 缓存空间。物理页框地址是页表项的核心，它建立了虚拟地址到物理地址的映射关系，使虚拟内存管理成为可能。\n缺页相关问题 请问哪些异常可能是缺页导致的？ 缺页异常是由于进程访问的页面不在页表中或者在页表中无效而引发的异常。以下这些异常可能是因为缺页导致的：\nLoad Page Fault（Load 异常）：当进程试图读取一个不在页表中或者无效的页面时，会引发 Load Page Fault 异常。在 RISC-V 中，这个异常对应的异常代码是 5。\nStore Page Fault（Store 异常）：当进程试图写入一个不在页表中或者无效的页面时，会引发 Store Page Fault 异常。在 RISC-V 中，这个异常对应的异常代码是 7。\nInstruction Page Fault（指令页异常）：当进程试图执行一个不在页表中或者无效的页面上的指令时，会引发 Instruction Page Fault 异常。在 RISC-V 中，这个异常对应的异常代码是 12。\n发生缺页时，描述相关的重要寄存器的值（lab2 中描述过的可以简单点）。 sepc（Exception Program Counter）：trap 发生时会将当前指令的下一条指令地址写入其中，用于 trap 处理完成后返回。 stval（Machine Trap Value）：mtval 寄存器包含导致异常的原因，即导致异常的指令的具体信息。例如，如果是缺页异常，那么 mtval 寄存器包含导致缺页异常的虚拟地址。 scause: 中断/异常发生时， CSR 寄存器 scause 中会记录其信息， Interrupt 位记录是中断还是异常， Exception Code 记录中断/异常的种类。 sstatus: 记录处理器当前状态，其中 SPP 段记录当前特权等级。 stvec: 记录处理 trap 的入口地址，现有两种模式 Direct 和 Vectored 。 sscratch: 其中的值是指向hart相关的S态上下文的指针，比如内核栈的指针。 以下行为的好处？ 缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做，而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。\nLazy Loading 策略有以下好处：\n减少初始化开销：Lazy Loading 允许操作系统在程序启动时只加载必需的页面，而不是一次性加载整个程序。这可以减少启动时间和初始化开销，因为不需要将整个程序加载到内存中。 节省内存：Lazy Loading 策略避免了不必要的内存占用。如果程序的某些部分从不被访问，那么它们就不会被加载到内存中，从而节省了内存资源。 提高响应速度：通过仅在需要时加载页面，Lazy Loading 可以提高系统的响应速度。只有当程序访问某个页面时，操作系统才会执行磁盘加载操作，而不会在程序启动时浪费时间加载可能永远不会被访问的内容。 更好的磁盘利用率：Lazy Loading 允许操作系统将程序的不同部分分散在磁盘上，根据需要加载。这可以提高磁盘利用率，因为不需要在磁盘上为整个程序分配连续的空间。 请问处理 10G 连续的内存页面，需要操作的页表实际大致占用多少内存 (给出数量级即可)？ 此外 COW(Copy On Write) 也是常见的容易导致缺页的 Lazy 策略，这个之后再说。其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间，然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。\n处理 10GB 连续的内存页面所需的页表实际上占用的内存量取决于操作系统的页表结构和管理策略。在 RISC-V 的页表结构中，一个页表项（Page Table Entry，PTE）通常占据 8 字节（64 位系统），其中包括物理页框号和一些标志位。让我们假设一个 PTE 占用 8 字节。\n为了估算 10GB 连续内存页面所需的页表实际占用内存量，我们可以按照以下步骤进行计算：\n首先，将 10GB 转换为字节数。1GB 等于 1,073,741,824 字节，所以 10GB 等于 10 * 1,073,741,824 = 10,737,418,240 字节。\n然后，计算每个页面表项覆盖的内存范围。假设每个页面表项管理 4KB（4 * 1024 字节）的内存页面。\n计算需要多少个页面表项来管理 10GB 的内存。这可以通过将 10GB 除以每个页面表项管理的内存范围来实现。\n最后，将所需的页面表项数量乘以每个 PTE 的大小来估算所需的总内存量。\n让我们进行具体计算：\n内存大小：10,737,418,240 字节 每个页面表项管理的内存范围：4KB = 4 * 1024 字节 需要的页面表项数量：10,737,418,240 字节 / 4KB = 2,621,440 个页表项 假设每个页表项占用 8 字节，则需要的总内存量为：\n2,621,440 个页表项 * 8 字节/页表项 = 20,971,520 字节\n所以，处理 10GB 连续的内存页面所需的页表实际占用内存量约为 20,971,520 字节，或者大约 20MB。这只是一个估算，实际内存占用可能会因操作系统的管理策略和对齐等因素而有所不同。\n请简单思考如何才能在现有框架基础上实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。 要在现有框架基础上实现 Lazy 策略，可以采取以下简单思路：\n延迟加载（Lazy Loading）：在用户进程请求内存映射时，不立即将整个内存区域加载到物理内存中。而是仅创建虚拟内存映射和页表项，记录对应的磁盘位置等信息。\n缺页处理（Page Fault Handling）：当用户进程访问虚拟内存中的某个尚未加载的内存页面时，会触发缺页异常。在缺页异常处理程序中，操作系统会根据页表中的磁盘位置信息，将相应的磁盘数据加载到物理内存中，并更新页表项，使其指向新加载的物理页面。\n惰性加载（Demand Paging）：为了提高性能，可以采用惰性加载策略，即只加载实际被访问的内存页面，而不是一次性加载整个区域。这可以通过在缺页处理程序中进行懒加载操作来实现。\n内存回收（Memory Reclamation）：当系统内存不足时，操作系统可以选择回收一些不常访问的内存页面，将其写回磁盘，并更新页表项为无效。这需要根据页面访问模式和策略来确定哪些页面可以被回收。\n性能优化：为了提高性能，可以采用预读取（Prefetching）策略，即在缺页处理时，不仅加载当前访问的页面，还预先加载相邻的页面，以减少未来可能的缺页次数。\n此时页面失效如何表现在页表项 (PTE) 上？ 缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。\nDirty bit (D 位)：当页面被修改并且尚未写回到主存时，该位会被设置为 1。如果页面已经被换出到磁盘上，D 位将保持为 1，以指示页面数据已过期。\nValid bit (V 位)：当页面在主存中有效时，V 位被设置为 1。如果页面被换出到磁盘上，V 位将被清除为 0，表示该页无效。\n通过检查页表项的 D 位和 V 位，操作系统可以确定页面是否需要从磁盘重新加载到内存中。如果 D 位为 1，说明页面需要写回到主存，在将其置为有效之前，必须将页数据从磁盘读取到内存中。如果 V 位为 0，说明页面当前无效，需要将其从磁盘加载到内存中，并将 V 位设置为 1，表示页面有效。\n双页表与单页表 为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说，用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。请结合课堂知识回答如下问题：(备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )\n单页表情况下，如何更换页表？ 在单页表情况下，页表的更换通常是由操作系统的上下文切换来触发的。当从用户态切换到内核态或从一个进程切换到另一个进程时，操作系统会根据相应的上下文信息加载不同的页表，实现页表的更换。\n单页表情况下，如何控制用户态无法访问内核页面？（tips:看看第一题最后一问） 设置页面权限：内核页面通常会被设置为只能在内核态下访问（例如，设置 PTE_U 位为 0），这样用户态无法访问内核页面。 操作系统权限：操作系统内核态拥有较高的权限，可以通过特权级别或访问控制机制来确保用户态无法直接访问内核页面。用户程序只能通过系统调用进入内核态，并在内核态下由操作系统执行，从而实现对内核页面的访问控制。 单页表有何优势？（回答合理即可） 单页表的主要优势在于简化了地址转换过程，减少了内存访问的开销。由于用户线程和内核线程共享同一张页表，不需要在上下文切换时频繁切换页表，这可以提高地址转换的效率。此外，单页表还可以节省内存，因为不需要为每个用户线程分配独立的页表。\n双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？ 在双页表实现下，页表的更换通常在发生上下文切换时需要。当从用户态切换到内核态或从一个进程切换到另一个进程时，需要加载相应的页表，以确保正确的地址转换。如果操作系统采用了每个进程独立的页表，那么在进程切换时需要更换页表。\n如果我写一个单页表操作系统，我会选择在发生进程切换时更换页表，因为这是最频繁的上下文切换情况之一。在其他情况下，如从用户态切换到内核态，可能不需要更换整张页表，而只需修改页表项的权限位来实现访问控制。这样可以减少页表更换的开销，提高性能。\n附录 修改user项目中的makefile，删除ch4_\n","permalink":"https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC4%E7%AB%A0-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/","summary":"\u003cblockquote\u003e\n\u003cp\u003e为何指定 TRAMPOLINE 和 TRAPFRAME 在 va 的最高位？\nTRAMPOLINE 和 TRAPFRAME 被定义在最高的虚拟内存地址上，是因为它们在操作系统的内存布局中起着重要作用。\nTRAMPOLINE 被用作从用户模式切换到内核模式的跳转目标。当发生异常或中断时，处理器将从用户模式切换到内核模式，并将控制权转移到内核中预定义的位置，也就是陷阱处理程序。TRAMPOLINE 页面被映射到最高虚拟地址，以便处理器能够在这个转换过程中方便地引用它。通过将其放置在最高地址，确保了无论系统的具体内存布局如何，它始终是可访问的。\n另一方面，TRAPFRAME 用于在发生异常或中断时存储机器状态。它包含寄存器、标志和其他操作系统处理异常所需的信息。TRAPFRAME 也被放置在最高的虚拟地址上，以确保它易于访问，并且陷阱处理程序可以高效地访问它。\n通过将 TRAMPOLINE 和 TRAPFRAME 定义在最高的虚拟内存地址上，内核可以方便而可靠地处理异常和中断，而无需关心它们在内存中的特定位置。\u003c/p\u003e","title":"uCore 实验第 4 章 - 地址空间"},{"content":"// 启动时初始化进程表 void proc_init(void) { struct proc *p; for (p = pool; p \u0026lt; \u0026amp;pool[NPROC]; p++) { p-\u0026gt;state = UNUSED; // p - pool 是 p 指向的 proc 在 pool 中的下标，因此 p - pool 变化情况是 0, 1, 2, ..., NPROC - 1 p-\u0026gt;kstack = (uint64)kstack[p - pool]; p-\u0026gt;ustack = (uint64)ustack[p - pool]; p-\u0026gt;trapframe = (struct trapframe *)trapframe[p - pool]; /* * LAB1: you may need to initialize your new fields of proc here */ } idle.kstack = (uint64)boot_stack_top; idle.pid = 0; current_proc = \u0026amp;idle; } p - pool 表示什么？ 假设我们有一个名为 pool 的数组，其中包含了多个类型为 struct proc 的元素，并且有一个指针 p 指向其中的某个元素。 当 p 指向 pool 数组的第一个元素时，p - pool 的结果将是 0，因为指针相对于数组首地址的偏移量为 0。 当 p 指向 pool 数组的第二个元素时，p - pool 的结果将是 1，因为指针相对于数组首地址的偏移量为 1。 以此类推，当 p 指向 pool 数组的第 N 个元素时，p - pool 的结果将是 N-1，因为指针相对于数组首地址的偏移量为 N-1。 总结来说，如果 p 是指向 pool 数组中第 N 个元素的指针，那么 p - pool 的结果将是 N-1。\n原调度函数每次都会从 pool 数组的第一个元素开始遍历，这样会导致每次都是从第一个进程开始运行，而不是从上次运行的进程开始运行。需要修改为如下：\n// 调度程序永不返回。它循环执行以下操作： // - 选择要运行的进程。 // - 切换以启动运行该进程。 // - 最终，该进程通过切换将控制权 // 传递回调度程序。 void scheduler(void) { struct proc *p; struct proc *last_checked_proc = pool; // 初始化指针为 pool for (;;) { for (p = last_checked_proc; p \u0026lt; \u0026amp;pool[NPROC]; p++) { // 将 p 初始化为 last_checked_proc if (p-\u0026gt;state == RUNNABLE) { /* * LAB1：你可能需要在这里初始化进程的起始时间 */ p-\u0026gt;state = RUNNING; current_proc = p; swtch(\u0026amp;idle.context, \u0026amp;p-\u0026gt;context); } } last_checked_proc = pool + 1; // 更新 last_checked_proc 的值为下一个位置 } } LAB1 --- os/loader.c | 5 +- os/proc.c | 15 +- os/proc.h | 23 +- os/syscall.c | 55 ++++- os/syscall_ids.h | 5 +- os/timer.h | 2 + 9 files changed, 374 insertions(+), 291 deletions(-) diff --git a/os/loader.c b/os/loader.c index b45e85d..b21b0a4 100644 --- a/os/loader.c +++ b/os/loader.c @@ -1,6 +1,7 @@ #include \u0026#34;loader.h\u0026#34; #include \u0026#34;defs.h\u0026#34; #include \u0026#34;trap.h\u0026#34; +#include \u0026lt;string.h\u0026gt; static uint64 app_num; static uint64 *app_info_ptr; @@ -49,8 +50,10 @@ int run_all_app() trapframe-\u0026gt;sp = (uint64)p-\u0026gt;ustack + USER_STACK_SIZE; p-\u0026gt;state = RUNNABLE; /* -\t* LAB1: you may need to initialize your new fields of proc here +\t* LAB1: 初始化系统调用数以及进程开始时间 */ + memset(p-\u0026gt;syscall_times, 0, MAX_SYSCALL_NUM * sizeof(uint32)); + p-\u0026gt;start_time = 0; } return 0; } \\ No newline at end of file diff --git a/os/proc.c b/os/proc.c index fee3886..0c69ae5 100644 --- a/os/proc.c +++ b/os/proc.c @@ -2,6 +2,7 @@ #include \u0026#34;defs.h\u0026#34; #include \u0026#34;loader.h\u0026#34; #include \u0026#34;trap.h\u0026#34; +#include \u0026#34;timer.h\u0026#34; struct proc pool[NPROC]; char kstack[NPROC][PAGE_SIZE]; @@ -33,9 +34,8 @@ void proc_init(void) p-\u0026gt;kstack = (uint64)kstack[p - pool]; p-\u0026gt;ustack = (uint64)ustack[p - pool]; p-\u0026gt;trapframe = (struct trapframe *)trapframe[p - pool]; - /* -\t* LAB1: you may need to initialize your new fields of proc here -\t*/ + memset(p-\u0026gt;syscall_times, 0, MAX_SYSCALL_NUM * sizeof(uint32)); + p-\u0026gt;start_time = 0; } idle.kstack = (uint64)boot_stack_top; idle.pid = 0; @@ -47,6 +47,7 @@ int allocpid() static int PID = 1; return PID++; } + // 在进程表中寻找一个未使用的进程。 // 如果找到，则初始化在内核中运行所需的状态。 // 如果没有空闲的进程，或者内存分配失败，则返回 0。 @@ -80,14 +81,18 @@ void scheduler(void) { struct proc *p; struct proc *last_checked_proc = pool; // 初始化指针为 pool - for (;;) { for (p = last_checked_proc; p \u0026lt; \u0026amp;pool[NPROC]; p++) { // 将 p 初始化为 last_checked_proc if (p-\u0026gt;state == RUNNABLE) { /* - * LAB1：你可能需要在这里初始化进程的起始时间 + * LAB1：在这里初始化进程的开始时间 */ + if (p-\u0026gt;start_time == 0) { + uint64 cycle = get_cycle(); + p-\u0026gt;start_time = + (cycle % CPU_FREQ) * MILLISECONDS_PER_SECOND / CPU_FREQ; + } p-\u0026gt;state = RUNNING; current_proc = p; swtch(\u0026amp;idle.context, \u0026amp;p-\u0026gt;context); diff --git a/os/proc.h b/os/proc.h index d208c5d..53576bf 100644 --- a/os/proc.h +++ b/os/proc.h @@ -3,7 +3,8 @@ #include \u0026#34;types.h\u0026#34; -#define NPROC (16) +#define NPROC (16) // 最大进程数 +#define MAX_SYSCALL_NUM (500) // 最大系统调用数 // Saved registers for kernel context switches. struct context { @@ -42,14 +43,28 @@ struct proc { uint64 kstack; // 进程内核栈虚拟地址 (内核页表) struct trapframe *trapframe; // 进程中断帧 struct context context; // 用于保存进程内核态的寄存器信息，进程切换时使用 - /* -\t* LAB1: you may need to add some new fields here + /* +\t* LAB1: 添加一些新的成员用于新的 sys_task_info 系统调用 */ + uint32 syscall_times[MAX_SYSCALL_NUM]; // 系统调用次数统计 TODO: 后续改为指针 + uint64 start_time; // 进程开始运行时间 }; /* -* LAB1: you may need to define struct for TaskInfo here +* LAB1: 定义 TaskInfo 结构体 */ +typedef enum { + UnInit, + Ready, + Running, + Exited, +} TaskStatus; + +typedef struct { + TaskStatus status; + uint32 syscall_times[MAX_SYSCALL_NUM]; + int time; // 进程运行时间统计 +} TaskInfo; struct proc *curr_proc(); void exit(int); diff --git a/os/syscall.c b/os/syscall.c index 1cc5aeb..f54ed86 100644 --- a/os/syscall.c +++ b/os/syscall.c @@ -4,6 +4,7 @@ #include \u0026#34;syscall_ids.h\u0026#34; #include \u0026#34;timer.h\u0026#34; #include \u0026#34;trap.h\u0026#34; +#include \u0026#34;proc.h\u0026#34; uint64 sys_write(int fd, char *str, uint len) { @@ -31,14 +32,46 @@ uint64 sys_sched_yield() uint64 sys_gettimeofday(TimeVal *val, int _tz) { uint64 cycle = get_cycle(); - val-\u0026gt;sec = cycle / CPU_FREQ; - val-\u0026gt;usec = (cycle % CPU_FREQ) * MICROSECONDS_PER_SECOND / CPU_FREQ; + tracef(\u0026#34;sys_gettimeofday cycle = %d\u0026#34;, cycle); + val-\u0026gt;sec = cycle / CPU_FREQ; + val-\u0026gt;msec = (cycle % CPU_FREQ) * MILLISECONDS_PER_SECOND / CPU_FREQ; + val-\u0026gt;usec = (cycle % CPU_FREQ) * MICROSECONDS_PER_SECOND / CPU_FREQ; return 0; } -/* -* LAB1: you may need to define sys_task_info here -*/ +/** + * LAB1：此处定义 sys_task_info 函数 + * 查询当前正在执行的任务信息，任务信息包括任务控制块相关信息（任务状态）、任务使用的系统调用次数、任务总运行时长。 + */ +int sys_task_info(TaskInfo *ti) +{ + struct proc *proc = curr_proc(); + // TODO: proc 检查为空 + for (int i = 0; i \u0026lt; MAX_SYSCALL_NUM; i++) { + ti-\u0026gt;syscall_times[i] = proc-\u0026gt;syscall_times[i]; + } + uint64 cycle = get_cycle(); + uint64 current_time = + (cycle % CPU_FREQ) * MILLISECONDS_PER_SECOND / CPU_FREQ; + infof(\u0026#34;sys_task_info current_time = %d\u0026#34;, current_time); + infof(\u0026#34;proc-\u0026gt;start_time = %d\u0026#34;, proc-\u0026gt;start_time); + infof(\u0026#34;ti-\u0026gt;time = %d\u0026#34;, current_time - proc-\u0026gt;start_time); + + if (proc-\u0026gt;state == RUNNING) { + ti-\u0026gt;status = Running; + } else if (proc-\u0026gt;state == RUNNABLE) { + ti-\u0026gt;status = Ready; + } else if (proc-\u0026gt;state == SLEEPING) { + ti-\u0026gt;status = Ready; + } else if (proc-\u0026gt;state == ZOMBIE) { + ti-\u0026gt;status = Exited; + } else if (proc-\u0026gt;state == UNUSED) { + ti-\u0026gt;status = UnInit; + } + + ti-\u0026gt;time = current_time - proc-\u0026gt;start_time; + return 0; +} extern char trap_page[]; @@ -51,8 +84,9 @@ void syscall() tracef(\u0026#34;syscall %d args = [%x, %x, %x, %x, %x, %x]\u0026#34;, id, args[0], args[1], args[2], args[3], args[4], args[5]); /* -\t* LAB1: you may need to update syscall counter for task info here +\t* LAB1: 更新系统调用次数 */ + curr_proc()-\u0026gt;syscall_times[id]++; switch (id) { case SYS_write: ret = sys_write(args[0], (char *)args[1], args[2]); @@ -67,8 +101,15 @@ void syscall() ret = sys_gettimeofday((TimeVal *)args[0], args[1]); break; /* -\t* LAB1: you may need to add SYS_taskinfo case here +\t* LAB1: 在此处添加 SYS_task_info 的系统调用处理情况 */ + case SYS_task_info: + ret = sys_task_info((TaskInfo *)args[0]); + break; + case SYS_getpid: + infof(\u0026#34;SYS_getpid %d\u0026#34;, SYS_getpid); + ret = curr_proc()-\u0026gt;pid; + break; default: ret = -1; errorf(\u0026#34;unknown syscall %d\u0026#34;, id); diff --git a/os/syscall_ids.h b/os/syscall_ids.h index 05a6cb9..3c1a5a9 100644 --- a/os/syscall_ids.h +++ b/os/syscall_ids.h @@ -277,9 +277,8 @@ #define SYS_io_pgetevents 292 #define SYS_rseq 293 #define SYS_kexec_file_load 294 -/* -* LAB1: you may need to define SYS_task_info here -*/ +// LAB1：添加 SYS_task_info 的系统调用号 +#define SYS_task_info 410 #define SYS_pidfd_send_signal 424 #define SYS_io_uring_setup 425 #define SYS_io_uring_enter 426 diff --git a/os/timer.h b/os/timer.h index c6ebd14..63ab45c 100644 --- a/os/timer.h +++ b/os/timer.h @@ -6,6 +6,7 @@ #define TICKS_PER_SEC (100) // QEMU #define CPU_FREQ (12500000) +#define MILLISECONDS_PER_SECOND (1000) #define MICROSECONDS_PER_SECOND (1000000) uint64 get_cycle(); @@ -14,6 +15,7 @@ void set_next_timer(); typedef struct { uint64 sec; // 自 Unix 纪元起的秒数 + uint64 msec; // 毫秒数 uint64 usec; // 微秒数 } TimeVal; -- 2.34.1 问答作业 问题一 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。请同学们可以自行测试这些内容（参考 前三个测例，描述程序出错行为，同时注意注明你使用的 sbi 及其版本。\n测试前三个测试用例指的是uCore-Tutorial-Code-2023S/user/src/ 目录下的三个bad测试用例，查看user项目的 Makefile 可以发现在编译时修改CHAPTER参数值为2_bad即可编译运行这些测试用例。\n[rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0 .______ __ __ _______.___________. _______..______ __ | _ \\ | | | | / | | / || _ \\ | | | |_) | | | | | | (----`---| |----`| (----`| |_) || | | / | | | | \\ \\ | | \\ \\ | _ \u0026lt; | | | |\\ \\----.| `--\u0026#39; |.----) | | | .----) | | |_) || | | _| `._____| \\______/ |_______/ |__| |_______/ |______/ |__| [rustsbi] Implementation : RustSBI-QEMU Version 0.2.0-alpha.2 [rustsbi] Platform Name : riscv-virtio,qemu [rustsbi] Platform SMP : 1 [rustsbi] Platform Memory : 0x80000000..0x88000000 [rustsbi] Boot HART : 0 [rustsbi] Device Tree Region : 0x87000000..0x87000ef2 [rustsbi] Firmware Address : 0x80000000 [rustsbi] Supervisor Address : 0x80200000 [rustsbi] pmp01: 0x00000000..0x80000000 (-wr) [rustsbi] pmp02: 0x80000000..0x80200000 (---) [rustsbi] pmp03: 0x80200000..0x88000000 (xwr) [rustsbi] pmp04: 0x88000000..0x00000000 (-wr) [TRACE 0]load app 0 at 0x0000000080400000 [TRACE 0]load app 1 at 0x0000000080420000 [TRACE 0]load app 2 at 0x0000000080440000 [INFO 0]start scheduler! [ERROR 1]unknown trap: 0x0000000000000007, stval = 0x0000000000000000 [INFO 1]进程 1 以代码 -1 退出 IllegalInstruction in application, core dumped. [INFO 2]进程 2 以代码 -3 退出 IllegalInstruction in application, core dumped. [INFO 3]进程 3 以代码 -3 退出 [PANIC 3] os/loader.c:15: all apps over 第一个进程测试用例如下：\nint main() { int *p = (int *)0; *p = 0; return 0; } 在您提供的代码中，将空指针分配给指针变量*p 后，试图对其进行解引用并将值 0 赋给该指针。由于用户模式下禁止直接访问物理内存，操作系统会检测到这个非法操作并触发异常。因此，该程序 IllegalInstruction in application, core dumped.\n在 RISC-V 架构中，U 模式是最低的用户模式，用户程序无法直接访问物理内存或其他特权级别资源。这种限制是为了确保操作系统的安全性和稳定性。\n第二个进程测试用例如下：\nint main() { asm volatile(\u0026#34;sret\u0026#34;); return 0; } 试图使用汇编语言执行 sret 指令，该指令用于从中断或异常处理程序返回。由于用户模式下禁止直接访问特权级别寄存器，操作系统会检测到这个非法操作并触发异常。因此，该程序 IllegalInstruction in application, core dumped。\n第三个进程测试用例如下：\nint main() { uint64 x; asm volatile(\u0026#34;csrr %0, sstatus\u0026#34; : \u0026#34;=r\u0026#34;(x)); return 0; } 原因同上，试图使用汇编语言执行 csrr 指令，该指令用于从特权级别寄存器中读取值。由于用户模式下禁止直接访问特权级别寄存器，操作系统会检测到这个非法操作并触发异常。因此，该程序 IllegalInstruction in application, core dumped。\n在操作系统代码中，触发异常后会进入void usertrap() 函数，该函数会根据 scause 寄存器的值判断异常类型，用例中的结果进入了case IllegalInstruction，其中 IllegalInstruction = 2。我们查阅手册 riscv-privileged.pdf ，可以查到 IllegalInstruction 的值为 2，与预期相符。\n问题二 请结合用例理解 trampoline.S 中两个函数 userret 和 uservec 的作用，并回答如下几个问题：\nL79: 刚进入 userret 时，a0、a1 分别代表了什么值。 在进入userret函数时，a0和a1分别代表以下值：\na0: TRAPFRAME 的地址，指向当前进程的陷阱帧（trapframe）结构体。 a1: 用户页表的地址，即进程的页表（pagetable）。这个地址会被写入到satp寄存器中，用于切换到用户模式的页表。 L87-L88: sfence 指令有何作用？为什么要执行该指令，当前章节中，删掉该指令会导致错误吗？ csrw satp, a1 sfence.vma zero, zero sfence指令（Store Fence）的作用是确保之前的存储操作完成，并且对其他处理器上的核心可见。\n执行sfence指令的主要目的是为了保证内存访问的顺序性和一致性。在多核处理器系统中，不同的核心可能会有自己的缓存，当一个核心修改了共享内存中的数据时，为了保证其他核心能够看到这个修改，需要使用sfence指令来刷新缓存并将修改写回共享内存。\n在代码中，sfence指令被用于确保对用户页表的修改对其他处理器上的核心可见。因为目前我只使用了单核处理器，所以不会出现多核处理器的情况，因此sfence指令的作用是确保对用户页表的修改对当前核心可见。\n因此，当前章节中，删掉该指令不会导致错误。\nL96-L125: 为何注释中说要除去 a0？哪一个地址代表 a0？现在 a0 的值存在何处？ # restore all but a0 from TRAPFRAME ld ra, 40(a0) ld sp, 48(a0) ld t5, 272(a0) ld t6, 280(a0) a0 是保存在 sscratch 寄存器中的，首先，该代码通过 ld 指令从 TRAPFRAME 中加载各个寄存器的值。然后，这些值被存储在相应的寄存器中，以便在恢复用户上下文时使用。\n接下来，代码使用 csrrw 指令将 sscratch 寄存器的值与 a0（即 TRAPFRAME）进行交换。这样做是为了将用户的 a0（TRAPFRAME）保存在 sscratch 寄存器中，以便后续步骤可以正确地恢复用户上下文。\n最后，通过 sret 指令返回到用户模式，并将控制权交给用户代码。在执行 sret 指令后，处理器将根据用户上下文中的 sepc 寄存器的值跳转到用户代码的指令地址。返回的同时，处理器还会自动恢复 sstatus 寄存器的值，以确保正确的特权级别和中断状态。\nuserret：中发生状态切换在哪一条指令？为何执行之后会进入用户态？ 在userret函数中，发生状态切换的指令是sret指令。\nsret指令用于从内核模式切换到用户模式，并将控制权交给用户代码。执行sret指令后，处理器会根据用户上下文中的sepc寄存器的值跳转到用户代码的指令地址。\n执行sret指令之后进入用户态的原因是，该指令会自动恢复sstatus寄存器的值，以确保正确的特权级别和中断状态。当sret指令执行后，处理器将从内核态切换回用户态，程序将继续执行用户代码。这意味着userret函数成功完成了从内核切换到用户模式的过程。\nL29：执行之后，a0 和 sscratch 中各是什么值，为什么？ csrrw a0, sscratch, a0 在执行指令后，a0和sscratch中的值发生了互换。\n假设原始a0寄存器中的值为 X，而sscratch寄存器中的值为 Y。执行csrrw a0, sscratch, a0指令后，a0寄存器中的值变为 Y，而sscratch寄存器中的值变为 X。\n这是因为csrrw指令是一个特权指令，用于将某个 CSR（Control and Status Register）的值读取到目标寄存器，然后将目标寄存器的值写回到该 CSR 中。在这里，csrrw a0, sscratch, a0指令将sscratch寄存器的值读取到a0寄存器中，同时将a0寄存器中的值写回到sscratch寄存器中，从而实现了两者之间的数据交换。\nL32-L61: 从 trapframe 第几项开始保存？为什么？是否从该项开始保存了所有的值，如果不是，为什么？ sd ra, 40(a0) sd sp, 48(a0) ... sd t5, 272(a0) sd t6, 280(a0) 进入 S 态是哪一条指令发生的？ L75-L76: ld t0, 16(a0) 执行之后，t0中的值是什么，解释该值的由来？ ld t0, 16(a0) jr t0 ld t0, 16(a0)就是从 trapframe 中恢复 t0寄存器值，t0保存了kernel_trap的入口地址。使用 jr t0，就跳转到了我们早先设定在 trapframe-\u0026gt;kernel_trap 中的地址，也就是 trap.c 之中的 usertrap 函数。这个函数在 main 的初始化之中已经调用了。\n","permalink":"https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC3%E7%AB%A0-%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 启动时初始化进程表\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eproc_init\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eproc\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epool\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003epool\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eNPROC\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003estate\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eUNUSED\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// p - pool 是 p 指向的 proc 在 pool 中的下标，因此 p - pool 变化情况是 0, 1, 2, ..., NPROC - 1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ekstack\u003c/span\u003e    \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003euint64\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003ekstack\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003epool\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eustack\u003c/span\u003e    \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003euint64\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eustack\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003epool\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003etrapframe\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003etrapframe\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003etrapframe\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003epool\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\t\t* LAB1: you may need to initialize your new fields of proc here\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\t\t*/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eidle\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekstack\u003c/span\u003e  \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003euint64\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eboot_stack_top\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eidle\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e     \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ecurrent_proc\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eidle\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003ep - pool 表示什么？\n假设我们有一个名为 pool 的数组，其中包含了多个类型为 struct proc 的元素，并且有一个指针 p 指向其中的某个元素。\n当 p 指向 pool 数组的第一个元素时，p - pool 的结果将是 0，因为指针相对于数组首地址的偏移量为 0。\n当 p 指向 pool 数组的第二个元素时，p - pool 的结果将是 1，因为指针相对于数组首地址的偏移量为 1。\n以此类推，当 p 指向 pool 数组的第 N 个元素时，p - pool 的结果将是 N-1，因为指针相对于数组首地址的偏移量为 N-1。\n总结来说，如果 p 是指向 pool 数组中第 N 个元素的指针，那么 p - pool 的结果将是 N-1。\u003c/p\u003e","title":"uCore 实验第 3 章 - 多道程序与分时多任务"},{"content":"背景 配置 yaml 文件时会遇到需要将配置的内容按照键值排序的情况，比如下面这样riscv_fork_list.yaml：\npackages: - name: accumulo - name: abseil-cpp - name: acpica-tools - name: acpid - name: activemq - name: afflib - name: adcli - name: adwaita-icon-theme - name: aide - name: alsa-lib - name: amtk - name: anaconda - name: apache-sshd - name: annobin - name: antlr3 - name: apache-commons-csv - name: aom - name: apache-commons-beanutils - name: apache-commons-daemon - name: apache-commons-el - name: apache-commons-exec - name: apache-commons-jexl - name: apache-poi - name: apache-rat 我想按照 name 的字母顺序排序，可以使用 yq 工具来实现。\n安装 yq wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq \u0026amp;\u0026amp;\\ chmod +x /usr/bin/yq 使用 yq yq -i \u0026#39;.packages |= sort_by(.name)\u0026#39; riscv_fork_list.yaml packages: - name: abseil-cpp - name: accumulo - name: acpica-tools - name: acpid - name: activemq - name: adcli - name: adwaita-icon-theme - name: afflib - name: aide - name: alsa-lib - name: amtk - name: anaconda - name: annobin - name: antlr3 - name: aom - name: apache-commons-beanutils - name: apache-commons-csv - name: apache-commons-daemon - name: apache-commons-el - name: apache-commons-exec - name: apache-commons-jexl - name: apache-poi - name: apache-rat - name: apache-sshd ","permalink":"https://lifeislife.cn/posts/yq%E4%B8%BAyaml%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%8E%92%E5%BA%8F/","summary":"\u003ch1 id=\"背景\"\u003e背景\u003c/h1\u003e\n\u003cp\u003e配置 \u003ccode\u003eyaml\u003c/code\u003e 文件时会遇到需要将配置的内容按照键值排序的情况，比如下面这样\u003ccode\u003eriscv_fork_list.yaml\u003c/code\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003epackages\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eaccumulo\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eabseil-cpp\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eacpica-tools\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eacpid\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eactivemq\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eafflib\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eadcli\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eadwaita-icon-theme\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eaide\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003ealsa-lib\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eamtk\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eanaconda\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eapache-sshd\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eannobin\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eantlr3\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eapache-commons-csv\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eaom\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eapache-commons-beanutils\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eapache-commons-daemon\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eapache-commons-el\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eapache-commons-exec\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eapache-commons-jexl\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eapache-poi\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eapache-rat\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我想按照 \u003ccode\u003ename\u003c/code\u003e 的字母顺序排序，可以使用 \u003ccode\u003eyq\u003c/code\u003e 工具来实现。\u003c/p\u003e","title":"yq 为 yaml 文件内容排序"},{"content":"问题描述 在 VSCode 中编辑 Markdown 文本，复制到思源笔记后，思源笔记无法转义为 Markdown 格式。会变成一个代码块，但是代码块内的内容并不是复制的内容。\n比如上面这段话复制到思源笔记成了下图这样：\n\u003c!DOCTYPE html\u003e Responsive Image 但是我需要的是能够转义为 Markdown 的阅读模式。\n解决方法 问题的原因在于 VSCode 复制的文本是带格式的，而思源笔记默认的粘贴模式是纯文本模式，所以会出现上面的问题。\n解决方法就是从 VSCode 复制的内容为纯文本，一种可以把文本复制到 txt 文件中，再复制，但是比较麻烦。\n第二种方法是使用 VSCode 的插件 Copy Plain Text，搜索下载后，默认快捷键为 Ctrl+Alt+C，可以复制为纯文本。\n再次粘贴到思源笔记中，就可以转义为 Markdown 格式了。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3%E5%A4%8D%E5%88%B6markdown%E6%96%87%E6%9C%AC%E5%88%B0%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E6%97%A0%E6%B3%95%E8%BD%AC%E4%B9%89%E4%B8%BAmarkdown%E6%A0%BC%E5%BC%8F/","summary":"\u003ch2 id=\"问题描述\"\u003e问题描述\u003c/h2\u003e\n\u003cp\u003e在 VSCode 中编辑 Markdown 文本，复制到思源笔记后，思源笔记无法转义为 Markdown 格式。会变成一个代码块，但是代码块内的内容并不是复制的内容。\u003c/p\u003e\n\u003cp\u003e比如上面这段话复制到思源笔记成了下图这样：\u003c/p\u003e","title":"解决复制 Markdown 文本到思源笔记无法转义为 Markdown 格式"},{"content":"flowchart TB subgraph entry.S _entry[_entry] end subgraph link_app.S _app_num[_app_num] end subgraph main.c main[main] end subgraph loader.c loader_init[loader_init] run_next_app[run_next_app] load_app[load_app] end _entry --\u0026gt; main main --\u0026gt; loader_init main --\u0026gt; run_next_app run_next_app --\u0026gt; load_app loader_init --\u0026gt; _app_num ","permalink":"https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC2%E7%AB%A0-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-gdscript3\" data-lang=\"gdscript3\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eflowchart\u003c/span\u003e \u003cspan class=\"n\"\u003eTB\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003esubgraph\u003c/span\u003e \u003cspan class=\"n\"\u003eentry\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003e_entry\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e_entry\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003esubgraph\u003c/span\u003e \u003cspan class=\"n\"\u003elink_app\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003e_app_num\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e_app_num\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003esubgraph\u003c/span\u003e \u003cspan class=\"n\"\u003emain\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003esubgraph\u003c/span\u003e \u003cspan class=\"n\"\u003eloader\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eloader_init\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eloader_init\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003erun_next_app\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003erun_next_app\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eload_app\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eload_app\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003e_entry\u003c/span\u003e \u003cspan class=\"o\"\u003e--\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003emain\u003c/span\u003e \u003cspan class=\"o\"\u003e--\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eloader_init\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003emain\u003c/span\u003e \u003cspan class=\"o\"\u003e--\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003erun_next_app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003erun_next_app\u003c/span\u003e \u003cspan class=\"o\"\u003e--\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eload_app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eloader_init\u003c/span\u003e \u003cspan class=\"o\"\u003e--\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_app_num\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"uCore 实验第 2 章 - 批处理系统"},{"content":"背景简介 在使用 VSCode 的过程中，我们经常会安装一些插件来提高开发效率。但是，由于某些原因，我们可能无法直接访问 VSCode 的插件市场，这时候我们就需要离线安装插件了。\n这里存在两种情况，一种是为本地的 VSCode 安装插件，另一种是为远程的 VSCode 安装插件。本文将分别介绍这两种情况下的离线安装方法。\n远程 VSCode 也就是 VSCode 的Remote Development功能，可以通过 SSH、Docker、WSL 等方式远程连接到远程主机上的 VSCode。\n方法一：使用已安装的插件目录 从已经安装插件的电脑上拷贝所有插件，路径一般为 C:\\用户\\用户名\\.vscode\\extensions 拷贝到离线安装的电脑上的 .vscode/extensions 文件夹下即可，重启 VScode 即可安装成功。 对于远程 VSCode 我们需要知道，插件不区分操作系统，所以我们可以在本地的 Windows 上的 VSCode 上安装插件，然后将插件目录压缩后整个拷贝到远程主机上即可。\n远程主机上的插件目录一般在 ~/.vscode-server/extensions 下。将压缩的文件解药到这个目录下，重启 VSCode 即可。\n方法二：下载离线安装包 vslx 安装 到 VScode 插件中心 搜索需要使用的插件名称\n下载对应的拓展程序文件，下载的文件的后缀是.vslx \u003c!DOCTYPE html\u003e Responsive Image VSCode 中安装 \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E5%A6%82%E4%BD%95%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85vscode%E6%8F%92%E4%BB%B6/","summary":"\u003ch1 id=\"背景简介\"\u003e背景简介\u003c/h1\u003e\n\u003cp\u003e在使用 VSCode 的过程中，我们经常会安装一些插件来提高开发效率。但是，由于某些原因，我们可能无法直接访问 VSCode 的插件市场，这时候我们就需要离线安装插件了。\u003c/p\u003e","title":"如何离线安装 VSCode 插件"},{"content":"命令行 在 Windows 中，可以使用 netsh 命令来添加、查看和删除端口转发规则。\n要添加一个端口转发规则，可以使用以下命令：\nnetsh interface portproxy add v4tov4 listenaddress=\u0026lt;local_address\u0026gt; listenport=\u0026lt;local_port\u0026gt; connectaddress=\u0026lt;remote_address\u0026gt; connectport=\u0026lt;remote_port\u0026gt; 其中：\n\u0026lt;local_address\u0026gt;是本地监听的地址（可以是 IP 地址或 0.0.0.0 表示所有地址）。 \u0026lt;local_port\u0026gt;是本地监听的端口。 \u0026lt;remote_address\u0026gt;是转发连接到的远程地址。 \u0026lt;remote_port\u0026gt;是转发连接到的远程端口。 例如，要将本地的 8080 端口转发到远程服务器上的 80 端口，可以使用以下命令：\nnetsh interface portproxy add v4tov4 listenaddress=127.0.0.1 listenport=8080 connectaddress=192.168.0.100 connectport=80 要查看当前的端口转发规则，可以使用以下命令：\nnetsh interface portproxy show v4tov4 要删除特定的端口转发规则，可以使用以下命令：\nnetsh interface portproxy delete v4tov4 listenaddress=\u0026lt;local_address\u0026gt; listenport=\u0026lt;local_port\u0026gt; 其中的\u0026lt;local_address\u0026gt;和\u0026lt;local_port\u0026gt;应该与你想删除的规则匹配。\n请注意，执行这些操作通常需要管理员权限。\nGUI 使用开源工具PortProxyGUI可以在 UI 界面快速增删改查端口映射。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/windows%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/","summary":"\u003ch1 id=\"命令行\"\u003e命令行\u003c/h1\u003e\n\u003cp\u003e在 Windows 中，可以使用 netsh 命令来添加、查看和删除端口转发规则。\u003c/p\u003e\n\u003cp\u003e要\u003cstrong\u003e添加一个端口转发规则\u003c/strong\u003e，可以使用以下命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enetsh interface portproxy add v4tov4 \u003cspan class=\"nv\"\u003elistenaddress\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u0026lt;local_address\u0026gt; \u003cspan class=\"nv\"\u003elistenport\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u0026lt;local_port\u0026gt; \u003cspan class=\"nv\"\u003econnectaddress\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u0026lt;remote_address\u0026gt; \u003cspan class=\"nv\"\u003econnectport\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u0026lt;remote_port\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;local_address\u0026gt;\u003c/code\u003e是本地监听的地址（可以是 IP 地址或 0.0.0.0 表示所有地址）。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;local_port\u0026gt;\u003c/code\u003e是本地监听的端口。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;remote_address\u0026gt;\u003c/code\u003e是转发连接到的远程地址。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;remote_port\u0026gt;\u003c/code\u003e是转发连接到的远程端口。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e例如，要将本地的 8080 端口转发到远程服务器上的 80 端口，可以使用以下命令：\u003c/p\u003e","title":"Windows 端口映射"},{"content":"背景简介 WSL2 是 Windows 的子系统，可以在 Windows 上运行 Linux，但是 WSL2 是运行在虚拟机中的，所以无法直接访问 WSL2 中的服务，比如 SSH 服务。本文介绍如何使用内网穿透工具花生壳来实现远程访问 WSL2 中的服务。\n实现这一需求需要完成两个功能。\nWSL2 中的服务是运行在虚拟机中的，如何将公网的访问转发到 WSL2 中。 Windows 没有公网 IP，如何通过公网来访问。 WSL2 端口转发 获取 WSL2 的 IP 地址：\nhostname -I | awk \u0026#39;{print $1}\u0026#39; 172.26.13.98 Windows 自带的netsh interface portproxy可以实现端口转发。管理员身份打开 cmd，执行以下命令：\nnetsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=2222 connectaddress=172.26.13.98 connectport=22 listenport：公网访问的端口（改一个不冲突的就行） connectaddress：WSL2 的 IP 地址 connectport：WSL2 中 SSH 服务的端口 (默认为 22，不需要更改) 开启 Windows 防火墙入站规则，管理员身份打开 cmd，执行以下命令：\nnetsh advfirewall firewall add rule name=WSL2 dir=in action=allow protocol=TCP localport=2222 这个命令是用于在 Windows 高级防火墙中添加一条规则。下面是对每个参数的解释：\nname=WSL2：将规则命名为 \u0026ldquo;WSL2\u0026rdquo;。 dir=in：指定规则适用于传入的网络流量。 action=allow：允许通过该规则的流量通过防火墙。 protocol=TCP：指定规则适用于 TCP 协议的流量。 localport=2222：指定本地端口号为 2222。 验证端口转发是否成功：\nssh -p 2222 user@localhost user 修改成 WSL2 的用户名 如果配置成功，则会成功登录 WSL2。\n安装配置花生壳 进入官网下载花生壳客户端，安装后打开，注册账号，登录。需要实名认证\n免费账户可以绑定2 个映射，对我来说暂时够用了，免费流量 1G/月。实测阅读代码不编译的话大概每天 50M左右。\n打开客户端，添加映射，配置如下：\n\u003c!DOCTYPE html\u003e Responsive Image 保存即可。\n\u003c!DOCTYPE html\u003e Responsive Image 验证是否配置成功，找一台不在同一个局域网的电脑，使用 SSH 连接 WSL2：\n如果复制出来的访问地址为abcdjsj.goho.co:33445，那么 SSH 命令修改为如下：\nssh -p 33445 user@abcdjsj.goho.co user 修改成 WSL2 的用户名 如果配置成功，则会成功登录 WSL2。\n题外话 WSL2 的 IP 会经常变化，如果连不上了，可以重新获取一下 IP，然后修改一下各个配置。或者想办法将 WSL2 的 IP 固定下来。 带宽有限，登录时比较慢，耐心等待。后续准备使用 frp 自建一个穿透服务。 PC 耗电伤不起啊，一百多瓦赶上三四台 NAS 了。这玩意只能应急，长时间挂机电费都够买个云服务器了。 常见问题 \u0026ldquo;System is booting up. Unprivileged users are not permitted to log in yet\u0026rdquo; 登录服务端，也就是 WSL2，执行以下命令\nsudo rm /run/nologin ","permalink":"https://lifeislife.cn/posts/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%AE%B6%E9%87%8C%E7%9A%84wsl2/","summary":"\u003ch1 id=\"背景简介\"\u003e背景简介\u003c/h1\u003e\n\u003cp\u003eWSL2 是 Windows 的子系统，可以在 Windows 上运行 Linux，但是 WSL2 是运行在虚拟机中的，所以无法直接访问 WSL2 中的服务，比如 SSH 服务。本文介绍如何使用内网穿透工具\u003cstrong\u003e花生壳\u003c/strong\u003e来实现远程访问 WSL2 中的服务。\u003c/p\u003e","title":"内网穿透远程访问家里的 WSL2"},{"content":"Docker-compose 启动 下载官方的 docker-compose.yml 文件，然后修改一下端口和挂载路径，然后启动即可。\nwget https://dl.photoprism.app/docker/docker-compose.yml 如果无法下载下载地址可以前往 Docker Compose - PhotoPrism 查看最新。\n根据自己需要修改以下参数：\nversion: \u0026#39;3.5\u0026#39; services: photoprism: ## Use photoprism/photoprism:preview for testing preview builds: image: dockerproxy.com/photoprism/photoprism:latest # 配置了镜像加速 ports: - \u0026#34;2342:2342\u0026#34; # HTTP port (host:container) environment: PHOTOPRISM_ADMIN_USER: \u0026#34;admin\u0026#34; # 管理员用户名 PHOTOPRISM_ADMIN_PASSWORD: \u0026#34;12345678\u0026#34; # 管理员密码 PHOTOPRISM_DETECT_NSFW: \u0026#34;true\u0026#34; # 自动检测 NSFW 图片并标记隐私图片 PHOTOPRISM_UPLOAD_NSFW: \u0026#34;true\u0026#34; # 运行上传 NSFW 图片 ## Share hardware devices with FFmpeg and TensorFlow (optional): devices: - \u0026#34;/dev/dri:/dev/dri\u0026#34; # 如果有核显或者独显可以配置硬件加速 volumes: - \u0026#34;/root/sharedfolder/syncthing/Photo_Album:/photoprism/originals/Photo_Album\u0026#34; # 照片存放路径 - \u0026#34;/root/sharedfolder/syncthing/daily:/photoprism/originals/daily\u0026#34; # 照片存放路径 - \u0026#34;/root/sharedfolder/syncthing/baby:/photoprism/originals/baby\u0026#34; # 照片存放路径 - \u0026#34;./storage:/photoprism/storage\u0026#34; # 不要删除 (DO NOT REMOVE) 然后启动即可：\ndocker-compose up -d 初始化需要时间，等待一分钟左右，然后访问 http://{hostip}:2342 即可看到登录界面。\n配置 配置中文界面 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 索引照片 这个过程会调用 TensorFlow 进行照片的 AI 识别，然后自动进行分类，照片如果很多会很慢。如果只想索引某一个目录就点击图片中的区域选择指定目录，选择目录的过程会加载比较慢，需要等待。\n\u003c!DOCTYPE html\u003e Responsive Image 使用相册 索引完成就可以点击搜索进行查看所有照片了：\n\u003c!DOCTYPE html\u003e Responsive Image 索引过程会根据照片的 Exif 信息自动分类，包括时间与地点。后悔从相机导出照片时把地点抹去了。\n照片还是得及时整理呀，这成千上万张照片挨个标记还是很麻烦的，就这样吧，做个图片墙也不错。\n常见问题 在docker-compose.yml中删除已经索引的volume，为何图片库中还存在缓存 缓存保存在storage中，如果图片内容不多，可以将该目录删除，重启容器。也可以通过以下命令将缓存删除：\n# 进入容器 docker exec -it photo-prism bash # 删除索引 photoprism purge # 删除文件 photoprism cleanup 全选图片，选择多个图片 可以选择一张图片后按住Shift到最后一张，批量选择图片\n定时索引照片 可以使用 crontab 定时执行 photoprism index 命令，例如每天凌晨 3 点执行一次：\n# 编辑定时任务 crontab -e # 添加以下内容 0 3 * * * docker exec -i photo-prism photoprism index ","permalink":"https://lifeislife.cn/posts/photoprism%E9%83%A8%E7%BD%B2%E7%A7%81%E4%BA%BA%E7%9B%B8%E5%86%8C/","summary":"\u003ch1 id=\"docker-compose-启动\"\u003eDocker-compose 启动\u003c/h1\u003e\n\u003cp\u003e下载官方的 \u003ccode\u003edocker-compose.yml\u003c/code\u003e 文件，然后修改一下端口和挂载路径，然后启动即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget https://dl.photoprism.app/docker/docker-compose.yml\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e如果无法下载下载地址可以前往 \u003ca href=\"https://docs.photoprism.app/getting-started/docker-compose/\"\u003eDocker Compose - PhotoPrism\u003c/a\u003e 查看最新。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e根据自己需要修改以下参数：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yml\" data-lang=\"yml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eversion\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;3.5\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nt\"\u003eservices\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003ephotoprism\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c\"\u003e## Use photoprism/photoprism:preview for testing preview builds:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eimage\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003edockerproxy.com/photoprism/photoprism:latest\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# 配置了镜像加速\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eports\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;2342:2342\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# HTTP port (host:container)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eenvironment\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ePHOTOPRISM_ADMIN_USER\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;admin\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e                 \u003c/span\u003e\u003cspan class=\"c\"\u003e# 管理员用户名\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ePHOTOPRISM_ADMIN_PASSWORD\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;12345678\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e          \u003c/span\u003e\u003cspan class=\"c\"\u003e# 管理员密码\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ePHOTOPRISM_DETECT_NSFW\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;true\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e                 \u003c/span\u003e\u003cspan class=\"c\"\u003e# 自动检测 NSFW 图片并标记隐私图片\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ePHOTOPRISM_UPLOAD_NSFW\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;true\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e                 \u003c/span\u003e\u003cspan class=\"c\"\u003e# 运行上传 NSFW 图片   \u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c\"\u003e## Share hardware devices with FFmpeg and TensorFlow (optional):\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003edevices\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;/dev/dri:/dev/dri\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e                           \u003c/span\u003e\u003cspan class=\"c\"\u003e# 如果有核显或者独显可以配置硬件加速\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003evolumes\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;/root/sharedfolder/syncthing/Photo_Album:/photoprism/originals/Photo_Album\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e               \u003c/span\u003e\u003cspan class=\"c\"\u003e# 照片存放路径\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;/root/sharedfolder/syncthing/daily:/photoprism/originals/daily\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e               \u003c/span\u003e\u003cspan class=\"c\"\u003e# 照片存放路径\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;/root/sharedfolder/syncthing/baby:/photoprism/originals/baby\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e               \u003c/span\u003e\u003cspan class=\"c\"\u003e# 照片存放路径\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;./storage:/photoprism/storage\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e                  \u003c/span\u003e\u003cspan class=\"c\"\u003e# 不要删除 (DO NOT REMOVE)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后启动即可：\u003c/p\u003e","title":"PhotoPrism 部署私人相册"},{"content":"docker-compose.yml version: \u0026#34;3.7\u0026#34; services: radarr: container_name: radarr image: dockerproxy.com/linuxserver/radarr:latest ports: - \u0026#34;7878:7878\u0026#34; environment: - PUID=1000 - PGID=1000 - UMASK=002 - TZ=Asia/Shanghai volumes: - /root/sharedfolder/appdata/radarr:/config - /root/sharedfolder/media:/movies - /root/sharedfolder/downloads/qbittorrent:/downloads 配置中文界面：\n\u003c!DOCTYPE html\u003e Responsive Image 导入视频：\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/docker%E9%83%A8%E7%BD%B2radarr%E5%88%AE%E5%89%8A%E7%94%B5%E5%BD%B1/","summary":"\u003ch1 id=\"docker-composeyml\"\u003edocker-compose.yml\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-YAML\" data-lang=\"YAML\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eversion\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;3.7\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nt\"\u003eservices\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003eradarr\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003econtainer_name\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eradarr\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eimage\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003edockerproxy.com/linuxserver/radarr:latest\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eports\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;7878:7878\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eenvironment\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003ePUID=1000\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003ePGID=1000\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eUMASK=002\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eTZ=Asia/Shanghai\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003evolumes\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/root/sharedfolder/appdata/radarr:/config\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/root/sharedfolder/media:/movies\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/root/sharedfolder/downloads/qbittorrent:/downloads\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e配置中文界面：\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/17/9dbfcaa5f918bccfa99ce64cc97a7e16.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/08/17/9dbfcaa5f918bccfa99ce64cc97a7e16.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"Docker 部署 Radarr 刮削电影"},{"content":"生成密钥对 宿主机任意下目录执行：\n$ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/user/.ssh/id_rsa): host2servera_id_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in host2servera_id_rsa. Your public key has been saved in host2servera_id_rsa.pub. The key fingerprint is: SHA256:OkWcw+R3x6Z2mzeYQuG033H3N9qIeym3TZKzz6YD8tQ user@ubuntu18 The key\u0026#39;s randomart image is: +---[RSA 2048]----+ | . | | = . . | | B .o. + | | . oo.o+ | | S ++ ..o| | o ..+.A=o=| | o +..B+=+| | . oo=@o+| | o=ss= | +----[SHA256]-----+ 一直回车确定，生成公私钥，保存在~/.ssh目录下。\n我在宿主机上生成的公私钥名称为，分别是host2servera_id_rsa,host2servera_id_rsa.pub方便我记忆。如果一直回车，那么生成的公私钥名称为id_rsa，id_rsa.pub。\n发送公钥 将公钥复制到服务器 ServerA 上，以 IP：10.12.193.53 为例。\n$ ssh-copy-id 10.12.193.53 # 输入密码 /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys user@10.12.193.53\u0026#39;s password: Number of key(s) added: 1 Now try logging into the machine, with: \u0026#34;ssh \u0026#39;10.12.193.53\u0026#39;\u0026#34; and check to make sure that only the key(s) you wanted were added. 默认是把 ServerA 的用户当做 user 进行登录。如果有确定的用户如userA，就使用ssh-copy-id userA@10.12.193.53\n然后就可以直接免密码登录了：\nssh user@10.12.193.53 # 或者 ssh userA@10.12.193.53 如果还是需要输入密码，可能ssh-agent没有启动，执行eval $(ssh-agent)启动ssh-agent，然后再次登录即可。然后将私钥添加到ssh-agent中，执行ssh-add ~/.ssh/host2servera_id_rsa，然后再次登录即可。\n配置快捷登录 即使免密登录，输入一长串 IP 也太麻烦了，能不能配置更简单的登录方式，比如给服务器起个名字如ServerA直接使用ssh ServerA就登录服务器，能。\n打开~/.ssh/config配置如下内容：\nHost ServerA HostName 10.12.193.53 Port 22 User userA IdentityFile ~/.ssh/host2servera_id_rsa 然后就可以直接使用ssh ServerA登录了。\n","permalink":"https://lifeislife.cn/posts/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/","summary":"\u003ch1 id=\"生成密钥对\"\u003e生成密钥对\u003c/h1\u003e\n\u003cp\u003e宿主机任意下目录执行：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ ssh-keygen -t rsa\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eGenerating public/private rsa key pair.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eEnter file in which to save the key \u003cspan class=\"o\"\u003e(\u003c/span\u003e/home/user/.ssh/id_rsa\u003cspan class=\"o\"\u003e)\u003c/span\u003e: host2servera_id_rsa\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eEnter passphrase \u003cspan class=\"o\"\u003e(\u003c/span\u003eempty \u003cspan class=\"k\"\u003efor\u003c/span\u003e no passphrase\u003cspan class=\"o\"\u003e)\u003c/span\u003e: \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eEnter same passphrase again: \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eYour identification has been saved in host2servera_id_rsa.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eYour public key has been saved in host2servera_id_rsa.pub.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eThe key fingerprint is:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eSHA256:OkWcw+R3x6Z2mzeYQuG033H3N9qIeym3TZKzz6YD8tQ user@ubuntu18\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eThe key\u003cspan class=\"err\"\u003e\u0026#39;\u003c/span\u003es randomart image is:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+---\u003cspan class=\"o\"\u003e[\u003c/span\u003eRSA 2048\u003cspan class=\"o\"\u003e]\u003c/span\u003e----+\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e        .        \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e       \u003cspan class=\"o\"\u003e=\u003c/span\u003e .   .   \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e        B .o. +  \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e       . oo.o+   \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e        S  ++ ..o\u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e       o ..+.A\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003eo\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e      o   +..B+\u003cspan class=\"o\"\u003e=\u003c/span\u003e+\u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e       .   \u003cspan class=\"nv\"\u003eoo\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e@o+\u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e           \u003cspan class=\"nv\"\u003eo\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003ess\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+----\u003cspan class=\"o\"\u003e[\u003c/span\u003eSHA256\u003cspan class=\"o\"\u003e]\u003c/span\u003e-----+\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e一直回车确定，生成公私钥，保存在\u003ccode\u003e~/.ssh\u003c/code\u003e目录下。\u003c/p\u003e","title":"SSH 免密登录"},{"content":"配置网桥 brctl # 创建一个名为 br0 的网桥 sudo brctl addbr br0 # 删除网桥 br0 sudo brctl delbr br0 # 列出所有的网桥及其接口信息 sudo brctl show # 将网络接口 `eth0` 添加到网桥 `br0` 中 sudo brctl addif br0 eth0 # 从网桥 `br0` 中删除网络接口 `eth0` sudo brctl delif br0 eth0 ### 显示网桥 `br0` 的 Spanning Tree Protocol (STP)配置 sudo brctl showstp br0 # 禁用 Linux 内核中桥接器对数据包进行处理时调用 iptables 的功能。这种配置通常用于提高桥接速度，减少桥接过程中的 CPU 开销。 sudo sysctl net.bridge.bridge-nf-call-iptables=0 sudo sysctl net.bridge.bridge-nf-call-iptables=0 # 为虚拟网卡设置IP并启动 sudo ifconfig tap0 192.168.2.1 up 虚拟网络设备 tunctl # 创建一个名为tun0的虚拟网络设备 sudo tunctl -t tun0 # 将虚拟网卡设置为任何人都有权限使用： sudo chmod 0666 /dev/net/tun # 删除名为tun0的虚拟网络设备 sudo tunctl -d tun0 # 创建名为tun0的虚拟网络设备并指定其拥有者和组 sudo tunctl -u user -g group -t tun0 # 列出所有活跃的虚拟网络设备及其接口信息 sudo tunctl -s # 指定虚拟网络设备的MAC地址 sudo tunctl -m [mac_address] -t tun0 # 列出具有给定设备名称前缀的所有已分配的虚拟网络设备 sudo tunctl -g [device_name_prefix] # 分配虚拟网络设备的文件描述符，将结果输出到标准输出 sudo tunctl -p -t tun0 # 将虚拟网络设备关联到现有的桥接设备 sudo tunctl -b -t tun0 -g br0 # 从现有虚拟网络设备解除关联 sudo tunctl -B -t tun0 # 指定虚拟网络设备的最大传输单元(MTU) sudo ip link set tun0 mtu [value] # 启用虚拟网络设备 sudo ip link set tun0 up # 禁用虚拟网络设备 sudo ip link set tun0 down # 显示由Linux内核管理的虚拟网络设备的状态信息 sudo ip link show tun0 # 修改虚拟网络设备的MAC地址 sudo ip link set dev tun0 address [mac_address] # 为虚拟网络设备分配一个IPv4地址 sudo ip addr add [ip_address/cidr] dev tun0 # 从虚拟网络设备中删除一个IPv4地址 sudo ip addr del [ip_address/cidr] dev tun0 # 检查虚拟网络设备是否已分配IPv4地址 ip addr show tun0 | grep inet # 使用DLADDR命令获取虚拟网络设备的MAC地址 sudo ethtool -P tun0 # 列出当前所有活动的网络接口 ip a # 检查虚拟网络设备是否已分配IPv6地址 ip addr show tun0 | grep inet6 网络接口管理（ifconfig） # 显示所有网络接口信息 ifconfig -a # 激活指定接口(如 eth0) ifconfig eth0 up # 关闭指定接口(如 eth0) ifconfig eth0 down # 添加 IP 地址，例如添加 IP 地址为 192.168.2.100 的网卡 eth0 ifconfig eth0 192.168.2.100 netmask 255.255.255.0 up # 删除 IP 地址，例如删除网卡 eth0 上的 IP 地址 ifconfig eth0 0.0.0.0 # 启用或禁用广播地址 ifconfig eth0 broadcast 192.168.2.255 up ifconfig eth0 -broadcast # 设置网卡 mtu 大小为 9000 ifconfig eth0 mtu 9000 # 增加一个虚拟网络接口 eth0:1，并配置 IP 地址为 192.168.2.100 ifconfig eth0:1 192.168.2.100 netmask 255.255.255.0 up 路由管理（route） # 显示当前路由表 route -n # 添加默认路由 route add default gw 192.168.2.1 # 删除默认路由 route del default # 增加一个到目标网络的静态路由 route add -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.2.1 # 删除静态路由 route del -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.2.1 # 清除所有路由缓存项 route flush cache # 查看 IP 地址对应网卡接口的 MAC 地址 arping -I eth0 192.168.2.1 DNS 解析（nslookup 和 dig） # 使用域名服务器解析域名 nslookup www.example.com # 指定域名服务器，并解析域名 nslookup www.example.com 8.8.8.8 # 查询DNS地址 dig example.com +nssearch # 查询所有的 NS 记录 dig example.com NS # 查询某个域名的 MX 记录 dig example.com MX 网络诊断工具（ping 和 traceroute） # 测试与目标主机之间的连通性，查看网络是否可达 ping 192.168.2.1 # ping 命令的高级选项，控制发送的数据包数量、大小和时间间隔等参数 ping -c 5 -s 100 -i 1 192.168.2.1 # 显示数据包在网络上的传输路径，检测网络故障 traceroute www.google.com # 显示每一跳所经过的路由器名称和 IP 地址 traceroute -n www.google.com 网络流量分析工具（tcpdump 和 wireshark） # 监听指定的网络接口上的数据包，显示每个数据包的详细信息 tcpdump -i eth0 # 监听指定端口上的数据包 tcpdump port 80 # 显示从指定源地址到目标地址的所有网络流量 tcpdump src 192.168.2.100 and dst 192.168.2.200 # 显示所有 IP 流量，并将结果保存到文件 tcp.pcap 中，以便使用 Wireshark 分析 tcpdump -i eth0 -w tcp.pcap ip # 图形化的网络协议分析工具，用于分析网络流量 wireshark 其他命令 # 显示网络连接状态和统计信息 netstat -an # 显示 TCP/IP 配置参数 sysctl net.ipv4.tcp_* # 设置 TCP/IP 参数，例如设置 SYN 攻击保护 sysctl -w net.ipv4.tcp_syncookies=1 # 重新加载 /etc/resolv.conf 文件 systemd-resolve --flush-caches # 显示当前 DNS 服务器 systemd-resolve --status | grep \u0026#39;DNS Servers\u0026#39; # 重启网络 systemctl restart NetworkManager ","permalink":"https://lifeislife.cn/posts/linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"\u003ch1 id=\"配置网桥-brctl\"\u003e配置网桥 brctl\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 创建一个名为 br0 的网桥\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo brctl addbr br0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 删除网桥 br0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo brctl delbr br0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 列出所有的网桥及其接口信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo brctl show\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 将网络接口 `eth0` 添加到网桥 `br0` 中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo brctl addif br0 eth0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 从网桥 `br0` 中删除网络接口 `eth0`\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo brctl delif br0 eth0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e### 显示网桥 `br0` 的 Spanning Tree Protocol (STP)配置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo brctl showstp br0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 禁用 Linux 内核中桥接器对数据包进行处理时调用 iptables 的功能。这种配置通常用于提高桥接速度，减少桥接过程中的 CPU 开销。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo sysctl net.bridge.bridge-nf-call-iptables\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"m\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo sysctl net.bridge.bridge-nf-call-iptables\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"m\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 为虚拟网卡设置IP并启动\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ifconfig tap0 192.168.2.1 up\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"虚拟网络设备-tunctl\"\u003e虚拟网络设备 tunctl\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 创建一个名为tun0的虚拟网络设备\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo tunctl -t tun0 \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 将虚拟网卡设置为任何人都有权限使用：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo chmod \u003cspan class=\"m\"\u003e0666\u003c/span\u003e /dev/net/tun\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 删除名为tun0的虚拟网络设备\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo tunctl -d tun0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 创建名为tun0的虚拟网络设备并指定其拥有者和组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo tunctl -u user -g group -t tun0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 列出所有活跃的虚拟网络设备及其接口信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo tunctl -s \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 指定虚拟网络设备的MAC地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo tunctl -m \u003cspan class=\"o\"\u003e[\u003c/span\u003emac_address\u003cspan class=\"o\"\u003e]\u003c/span\u003e -t tun0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 列出具有给定设备名称前缀的所有已分配的虚拟网络设备\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo tunctl -g \u003cspan class=\"o\"\u003e[\u003c/span\u003edevice_name_prefix\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 分配虚拟网络设备的文件描述符，将结果输出到标准输出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo tunctl -p -t tun0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 将虚拟网络设备关联到现有的桥接设备\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo tunctl -b -t tun0 -g br0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 从现有虚拟网络设备解除关联\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo tunctl -B -t tun0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 指定虚拟网络设备的最大传输单元(MTU)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ip link \u003cspan class=\"nb\"\u003eset\u003c/span\u003e tun0 mtu \u003cspan class=\"o\"\u003e[\u003c/span\u003evalue\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 启用虚拟网络设备\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ip link \u003cspan class=\"nb\"\u003eset\u003c/span\u003e tun0 up\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 禁用虚拟网络设备\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ip link \u003cspan class=\"nb\"\u003eset\u003c/span\u003e tun0 down\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示由Linux内核管理的虚拟网络设备的状态信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ip link show tun0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 修改虚拟网络设备的MAC地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ip link \u003cspan class=\"nb\"\u003eset\u003c/span\u003e dev tun0 address \u003cspan class=\"o\"\u003e[\u003c/span\u003emac_address\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 为虚拟网络设备分配一个IPv4地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ip addr add \u003cspan class=\"o\"\u003e[\u003c/span\u003eip_address/cidr\u003cspan class=\"o\"\u003e]\u003c/span\u003e dev tun0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 从虚拟网络设备中删除一个IPv4地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ip addr del \u003cspan class=\"o\"\u003e[\u003c/span\u003eip_address/cidr\u003cspan class=\"o\"\u003e]\u003c/span\u003e dev tun0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 检查虚拟网络设备是否已分配IPv4地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eip addr show tun0 \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep inet\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 使用DLADDR命令获取虚拟网络设备的MAC地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ethtool -P tun0 \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 列出当前所有活动的网络接口\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eip a \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 检查虚拟网络设备是否已分配IPv6地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eip addr show tun0 \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep inet6 \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"网络接口管理ifconfig\"\u003e网络接口管理（ifconfig）\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示所有网络接口信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig -a\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 激活指定接口(如 eth0)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig eth0 up\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 关闭指定接口(如 eth0)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig eth0 down\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 添加 IP 地址，例如添加 IP 地址为 192.168.2.100 的网卡 eth0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig eth0 192.168.2.100 netmask 255.255.255.0 up\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 删除 IP 地址，例如删除网卡 eth0 上的 IP 地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig eth0 0.0.0.0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 启用或禁用广播地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig eth0 broadcast 192.168.2.255 up\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig eth0 -broadcast\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 设置网卡 mtu 大小为 9000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig eth0 mtu \u003cspan class=\"m\"\u003e9000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 增加一个虚拟网络接口 eth0:1，并配置 IP 地址为 192.168.2.100\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig eth0:1 192.168.2.100 netmask 255.255.255.0 up\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"路由管理route\"\u003e路由管理（route）\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示当前路由表\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eroute -n\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 添加默认路由\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eroute add default gw 192.168.2.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 删除默认路由\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eroute del default\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 增加一个到目标网络的静态路由\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eroute add -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.2.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 删除静态路由\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eroute del -net 192.168.100.0 netmask 255.255.255.0 gw 192.168.2.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 清除所有路由缓存项\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eroute flush cache\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看 IP 地址对应网卡接口的 MAC 地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003earping -I eth0 192.168.2.1\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"dns-解析nslookup-和-dig\"\u003eDNS 解析（nslookup 和 dig）\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 使用域名服务器解析域名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enslookup www.example.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 指定域名服务器，并解析域名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enslookup www.example.com 8.8.8.8\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查询DNS地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edig example.com +nssearch\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查询所有的 NS 记录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edig example.com NS\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查询某个域名的 MX 记录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edig example.com MX\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"网络诊断工具ping-和-traceroute\"\u003e网络诊断工具（ping 和 traceroute）\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 测试与目标主机之间的连通性，查看网络是否可达\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eping 192.168.2.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# ping 命令的高级选项，控制发送的数据包数量、大小和时间间隔等参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eping -c \u003cspan class=\"m\"\u003e5\u003c/span\u003e -s \u003cspan class=\"m\"\u003e100\u003c/span\u003e -i \u003cspan class=\"m\"\u003e1\u003c/span\u003e 192.168.2.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示数据包在网络上的传输路径，检测网络故障\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etraceroute www.google.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示每一跳所经过的路由器名称和 IP 地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etraceroute -n www.google.com\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"网络流量分析工具tcpdump-和-wireshark\"\u003e网络流量分析工具（tcpdump 和 wireshark）\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 监听指定的网络接口上的数据包，显示每个数据包的详细信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etcpdump -i eth0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 监听指定端口上的数据包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etcpdump port \u003cspan class=\"m\"\u003e80\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示从指定源地址到目标地址的所有网络流量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etcpdump src 192.168.2.100 and dst 192.168.2.200\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示所有 IP 流量，并将结果保存到文件 tcp.pcap 中，以便使用 Wireshark 分析\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etcpdump -i eth0 -w tcp.pcap ip\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 图形化的网络协议分析工具，用于分析网络流量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewireshark\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"其他命令\"\u003e其他命令\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示网络连接状态和统计信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enetstat -an\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示 TCP/IP 配置参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esysctl net.ipv4.tcp_*\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 设置 TCP/IP 参数，例如设置 SYN 攻击保护\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esysctl -w net.ipv4.tcp_syncookies\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 重新加载 /etc/resolv.conf 文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemd-resolve --flush-caches\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示当前 DNS 服务器\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemd-resolve --status \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep \u003cspan class=\"s1\"\u003e\u0026#39;DNS Servers\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 重启网络\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemctl restart NetworkManager\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Linux 网络配置常用命令"},{"content":"Quick Setup 安装工具 安装两个网络管理工具用于建立网桥以及虚拟网卡：\n# 安装虚拟网桥工具 sudo apt install bridge-utils -y # UML（User-mode linux）工具 sudo apt install uml-utilities -y 配置脚本 qemu-ifup 将下面的脚本保存为文件 qemu-ifup，并赋予可执行权限：\n为了方便复制脚本，在 confluence 页面提供了脚本内容，可以直接复制。\nmkdir -p /etc/qemu mv qemu-ifup /etc/qemu \u0026amp;\u0026amp; mv qemu-ifdown /etc/qemu sudo chmod +x qemu-ifup sudo chmod +x qemu-ifdown 因为网卡信息不容易定位，可能一台机器有多个网卡，所以不方便用脚本获取，需要手动设置一下。将下面的NIC值修改为宿主机可以上网的网卡名称。可以通过ifconfig命令查看。\n#!/bin/bash # 设置默认网卡信息 NIC=enp2s0 # 设置用户名 USER_NAME=user # 设置网桥名称 BRIDGE=br0 # 设置网络信息 NIC_IP=$(ifconfig $NIC | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $2}\u0026#39;) NIC_NETMAST=$(ifconfig $NIC | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) NIC_BROADCAST=$(ifconfig $NIC | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $6}\u0026#39;) NETMASK=255.255.240.0 # 设置默认网关地址 GATEWAY=10.12.192.1 # 获取宿主机网卡MAC地址，因为创建的网桥MAC地址是随机的， # 无法接入公司，需要从开发机网卡将其MAC地址赋值给网桥 MAC=$(ifconfig $NIC | grep \u0026#34;ether\\b\u0026#34; | awk \u0026#39;{print $2}\u0026#39;) # 检查网桥是否已创建，已创建就忽略 function check_bridge() { echO \u0026#34;Check bridge...\u0026#34; if brctl show | grep \u0026#34;^$BRIDGE\u0026#34; \u0026amp;\u0026gt; /dev/null; then return 1 else return 0 fi } # 创建网桥 function create_bridge() { echo \u0026#34;Start Create bridge...\u0026#34; brctl addbr \u0026#34;$BRIDGE\u0026#34; brctl addif \u0026#34;$BRIDGE\u0026#34; \u0026#34;$NIC\u0026#34; ifconfig br0 0.0.0.0 promisc up dhclient $BRIDGE } # ifconfig \u0026#34;$BRIDGE\u0026#34; \u0026#34;$NIC_IP\u0026#34; netmask \u0026#34;$NIC_NETMAST\u0026#34; broadcast \u0026#34;$NIC_BROADCAST\u0026#34; hw ether \u0026#34;$MAC\u0026#34; promisc up # 启用IP转发 function enable_ip_forward() { echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward } # 设置网桥 function setup_bridge() { check_bridge \u0026#34;$BRIDGE\u0026#34; if [ $? -eq 0 ]; then create_bridge fi enable_ip_forward } if [ -n \u0026#34;$1\u0026#34; ]; then setup_bridge echo \u0026#34;Creating $1...\u0026#34; tunctl -t \u0026#34;$1\u0026#34; -u \u0026#34;$USER_NAME\u0026#34; ifconfig \u0026#34;$1\u0026#34; 0.0.0.0 up echo \u0026#34;Adding $1 to $BRIDGE...\u0026#34; brctl addif \u0026#34;$BRIDGE\u0026#34; \u0026#34;$1\u0026#34; sleep 5 ifconfig \u0026#34;$BRIDGE\u0026#34; hw ether \u0026#34;$MAC\u0026#34; promisc up exit 0 else echo \u0026#34;Error: no interface specified.\u0026#34; exit 1 fi qemu-ifdown 以下是qemu-ifdown脚本，用于在关闭 QEMU 时关闭虚拟网卡，将其从网桥中移除，删除虚拟网卡。\n#!/bin/bash # 设置网桥名称 BRIDGE=br0 if [ -n \u0026#34;$1\u0026#34; ]; then # 将tap设备从网桥中移除 brctl delif ${BRIDGE} $1 # 关闭tap设备 ip link link $1 down # 删除tap设备 ip link del \u0026#34;$1\u0026#34; tunctl -d \u0026#34;$1\u0026#34; exit 0 else echo \u0026#34;Error: no interface specified\u0026#34; exit 1 fi 将系统镜像复制一份并修改文件名，QEMU 不能同时使用一个镜像启动两个虚拟机。\ncp openEuler-22.09-riscv64-qemu.qcow2 openEuler-22.09-riscv64-qemu-vm1.qcow2 需要修改启动脚本中的镜像文件名，以及启动参数，将drive以及cmd变量的内容覆盖为下面的内容，修改mac为分配给自己的虚拟机的 MAC 地址，script为上面的脚本qemu-ifup的路径。\n# 该脚本用于启动VM0 drive=\u0026#34;openEuler-22.09-riscv64-qemu.qcow2\u0026#34; .... cmd=\u0026#34;qemu-system-riscv64 \\ -nographic -machine virt \\ -smp \u0026#34;$vcpu\u0026#34; -m \u0026#34;$memory\u0026#34;G \\ -bios \u0026#34;$fw\u0026#34; \\ -drive file=\u0026#34;$drive\u0026#34;,format=qcow2,id=hd0 \\ -object rng-random,filename=/dev/urandom,id=rng0 \\ -device virtio-vga \\ -device virtio-rng-device,rng=rng0 \\ -device virtio-blk-device,drive=hd0 \\ -device virtio-net-device,netdev=tapnet,mac=e0:be:03:88:54:e8 \\ -netdev tap,id=tapnet,script=/etc/qemu/qemu-ifup,downscript=/etc/qemu/qemu-ifdown \\ -device qemu-xhci -usb -device usb-kbd -device usb-tablet\u0026#34; 以sudo权限启动脚本：\nsudo ./preview_start_vm0.sh 以下为配置 VM1 过程，VM1 的启动脚本与 VM0 的启动脚本类似，只需要修改drive以及MAC，必须保证MAC与 VM0 的MAC不同。\n# 该脚本用于启动VM1 drive=\u0026#34;openEuler-22.09-riscv64-qemu.qcow2\u0026#34; .... cmd=\u0026#34;qemu-system-riscv64 \\ -nographic -machine virt \\ -smp \u0026#34;$vcpu\u0026#34; -m \u0026#34;$memory\u0026#34;G \\ -bios \u0026#34;$fw\u0026#34; \\ -drive file=\u0026#34;$drive\u0026#34;,format=qcow2,id=hd0 \\ -object rng-random,filename=/dev/urandom,id=rng0 \\ -device virtio-vga \\ -device virtio-rng-device,rng=rng0 \\ -device virtio-blk-device,drive=hd0 \\ -device virtio-net-device,netdev=tapnet,mac=80:d4:09:62:cd:3c \\ -netdev tap,id=tapnet,script=/etc/qemu/qemu-ifup,downscript=/etc/qemu/qemu-ifdown \\ -device qemu-xhci -usb -device usb-kbd -device usb-tablet\u0026#34; 网络通信测试 当前网络状态如下：\nHOST:10.12.192.177 VM0:10.12.193.53 VM1:10.12.193.101 HOST \u0026ndash;\u0026gt; VM0 # user @ ubuntu18 in ~/openeuler/openEuler2209 [18:41:54] $ ping -c 3 10.12.193.101 PING 10.12.193.101 (10.12.193.101) 56(84) bytes of data. 64 bytes from 10.12.193.101: icmp_seq=1 ttl=64 time=1.37 ms 64 bytes from 10.12.193.101: icmp_seq=2 ttl=64 time=0.897 ms 64 bytes from 10.12.193.101: icmp_seq=3 ttl=64 time=0.890 ms --- 10.12.193.101 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2002ms rtt min/avg/max/mdev = 0.890/1.055/1.378/0.228 ms Host \u0026ndash;\u0026gt; VM1 的测试结果与 Host \u0026ndash;\u0026gt; VM0 的测试结果相同。\nVM0 \u0026ndash;\u0026gt; HOST [root@openEuler-riscv64 ~]# ping -c 3 10.12.193.53 PING 10.12.193.53 (10.12.193.53) 56(84) bytes of data. 64 bytes from 10.12.193.53: icmp_seq=1 ttl=64 time=0.716 ms 64 bytes from 10.12.193.53: icmp_seq=2 ttl=64 time=1.74 ms 64 bytes from 10.12.193.53: icmp_seq=3 ttl=64 time=1.81 ms --- 10.12.193.53 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2009ms rtt min/avg/max/mdev = 0.716/1.424/1.812/0.501 ms VM1 \u0026ndash;\u0026gt; Host 的测试结果与 Host \u0026ndash;\u0026gt; VM0 的测试结果相同。\nVM1 \u0026ndash;\u0026gt; VM0 [root@openEuler-riscv64 ~]# ping -c 3 10.12.193.53 PING 10.12.193.53 (10.12.193.53) 56(84) bytes of data. 64 bytes from 10.12.193.53: icmp_seq=1 ttl=64 time=0.716 ms 64 bytes from 10.12.193.53: icmp_seq=2 ttl=64 time=1.74 ms 64 bytes from 10.12.193.53: icmp_seq=3 ttl=64 time=1.81 ms --- 10.12.193.53 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2009ms rtt min/avg/max/mdev = 0.716/1.424/1.812/0.501 ms VM0 \u0026ndash;\u0026gt; VM1 与 VM1 \u0026ndash;\u0026gt; VM0 的测试结果相同。\nVM0 \u0026ndash;\u0026gt; github [root@openEuler-riscv64 ~]# ping -c 4 github.com PING github.com (192.30.255.113) 56(84) bytes of data. 64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=1 ttl=46 time=221 ms 64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=2 ttl=46 time=277 ms 64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=3 ttl=46 time=216 ms 64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=4 ttl=46 time=218 ms --- github.com ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3014ms rtt min/avg/max/mdev = 215.984/232.733/276.593/25.374 ms HOST \u0026ndash;\u0026gt; github # user @ ubuntu18 in ~/openeuler/openEuler2209 [17:59:40] $ ping -c 3 github.com PING github.com (192.30.255.113) 56(84) bytes of data. 64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=1 ttl=46 time=218 ms 64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=2 ttl=46 time=216 ms 64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=3 ttl=46 time=216 ms --- github.com ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2002ms rtt min/avg/max/mdev = 216.252/217.087/218.409/0.945 ms 原理探究 (Ongoing) Step by Step 解析 查看一下网络接口信息：\nifconfig enp3s0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.12.192.173 netmask 255.255.240.0 broadcast 10.12.207.255 inet6 fe80::a00:27ff:fe32:e709 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 08:00:27:32:e7:09 txqueuelen 1000 (Ethernet) RX packets 6017 bytes 5412928 (5.4 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1979 bytes 179467 (179.4 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 125 bytes 10142 (10.1 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 125 bytes 10142 (10.1 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 创建一个名为br0的网桥\nsudo brctl addbr br0 将网桥与宿主机的网卡绑定\nsudo brctl addif br0 enp3s0 启用 br0 接口，并从 DHCP 服务器获得 IP 地址\nsudo ifconfig br0 0.0.0.0 promisc up sudo dhclient br0 查看虚拟网桥列表\nsudo brctl show br0 bridge name\tbridge id\tSTP enabled interfaces br0\t8000.e0be0388eec9 no enp3s0 查看 br0 的各接口信息\nsudo brctl showstp br0 br0 bridge id\t8000.e0be0388eec9 designated root\t8000.e0be0388eec9 root port\t0\tpath cost 0 max age\t20.00s forward delay\t15.00s hello time\t2.00s ageing time\t300.00s hello timer\t0.00s\t\u0026lt;tbd\u0026gt; forward timer\t0.00s\t\u0026lt;tbd\u0026gt; ageing timer\t0.00s\t\u0026lt;tbd\u0026gt; enp3s0 (1) port id\t8001\tlocal state forwarding designated root\t8000.08002732e709 path cost\t100 designated bridge\t8000.08002732e709 designated port\t8001 forward delay\t15.00s hello time\t2.00s max age\t20.00s ageing time\t300.00s priority\t128 当前网络拓扑：\n+-----------------------------------+ | Internet | +-----------------------------------+ | | v +---------------------------------------------------------+ | enp3s0 (Host Interface) | | IP: 10.12.192.173 | +---------------------------------------------------------+ | v +---------------------------------------------------------+ | br0 (Bridge) | | IP: 10.12.192.173 | +---------------------------------------------------------+ 创建一个 tap0 接口用于VM0使用，允许 user 用户访问\nsudo tunctl -t tap0 -u user 在虚拟网桥中增加 tap0 接口\nsudo brctl addif br0 tap0 启用 tap0 接口，混杂模式\nsudo ifconfig tap0 0.0.0.0 promisc up 将网桥的 MAC 地址修改为宿主机的 MAC 地址，这样就可以接入公司网络了。否则因为内网的 MAC 地址过滤，无法接入公司网络。\nifconfig br0 hw ether 08:00:27:32:e7:09 promisc up 查看虚拟网桥列表\n$ sudo brctl show br0 bridge name\tbridge id\tSTP enabled interfaces br0\t8000.08002732e709 no enp3s0 tap0 查看当前的网桥状态：\n$ sudo brctl showstp br0 br0 bridge id\t8000.08002732e709 designated root\t8000.08002732e709 root port\t0\tpath cost\t0 max age\t20.00\tbridge max age\t20.00 hello time\t2.00\tbridge hello time\t2.00 forward delay\t15.00\tbridge forward delay\t15.00 ageing time\t300.00 hello timer\t0.00\ttcn timer\t0.00 topology change timer\t0.00\tgc timer\t7.75 flags\tenp2s0 (1) port id\t8001\tstate\tforwarding designated root\t8000.08002732e709\tpath cost\t4 designated bridge\t8000.08002732e709\tmessage age timer\t0.00 designated port\t8001\tforward delay timer\t0.00 designated cost\t0\thold timer\t0.00 flags\ttap0 (2) port id\t8002\tstate\tdisabled designated root\t8000.08002732e709\tpath cost\t100 designated bridge\t8000.08002732e709\tmessage age timer\t0.00 designated port\t8002\tforward delay timer\t0.00 designated cost\t0\thold timer\t0.00 flags\ttap0可能处于disabled状态，因为还没有虚拟机使用它。启动虚拟机之后会自动切换到forwarding状态。\n当前网络拓扑：\n+-----------------------------------+ | Internet | +-----------------------------------+ | | v +---------------------------------------------------------+ | enp3s0 (Host Interface) | | IP: 10.12.192.173 | +---------------------------------------------------------+ | v +---------------------------------------------------------+ | br0 (Bridge) | | IP: 10.12.192.173 | | +---------------------+ | | | tap0 | | | | IP: 0.0.0.0 | | +---------------------------------------------------------+ 启动 QEMU\ncmd=\u0026#34;qemu-system-riscv64 \\ -nographic -machine virt \\ -smp \u0026#34;$vcpu\u0026#34; -m \u0026#34;$memory\u0026#34;G \\ -bios \u0026#34;$fw\u0026#34; \\ -drive file=\u0026#34;$drive\u0026#34;,format=qcow2,id=hd0 \\ -object rng-random,filename=/dev/urandom,id=rng0 \\ -device virtio-vga \\ -device virtio-rng-device,rng=rng0 \\ -device virtio-blk-device,drive=hd0 \\ -device virtio-net-device,netdev=tapnet,mac=e0:be:03:88:54:e8 \\ -netdev tap,id=tapnet,ifname=tap0,script=no,downscript=no \\ -device qemu-xhci -usb -device usb-kbd -device usb-tablet\u0026#34; 关注这段脚本的网络配置部分：\n-device virtio-net-device,netdev=tapnet,mac=e0:be:03:88:54:e8 \\ -netdev tap,id=tapnet,ifname=tap0,script=no,downscript=no \\ 详细解释可以查看“QEMU 网络虚拟化章节”，第一个参数 -device virtio-net-device 定义了名为 virtio-net-device 的网络设备，并将其连接到一个名为 tapnet 的网络设备上，指定它的 MAC 地址为 e0:be:03:88:54:e8。第二个参数 -netdev tap 用于指定后端实现，使用tap方式，并且指定唯一 ID 为tapnet由-device参数中的子参数netdev使用，指定ifname=tap0，表示使用tap0接口作为虚拟化的后端。script=no和downscript=no表示不使用脚本来启动和关闭tap0接口。\n查看当前的网络接口信息ifconfig：\nbr0: flags=4419\u0026lt;UP,BROADCAST,RUNNING,PROMISC,MULTICAST\u0026gt; mtu 1500 inet 10.12.192.173 netmask 255.255.240.0 broadcast 10.12.207.255 inet6 fe80::e2be:3ff:fe88:eec9 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 08:00:27:32:e7:09 txqueuelen 1000 (Ethernet) RX packets 861148 bytes 310707296 (310.7 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 17556062 bytes 1516515693 (1.5 GB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 enp2s0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.12.192.173 netmask 255.255.240.0 broadcast 10.12.207.255 inet6 fe80::4964:61f8:420d:6781 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 08:00:27:32:e7:09 txqueuelen 1000 (Ethernet) RX packets 894523 bytes 325547917 (325.5 MB) RX errors 0 dropped 1926 overruns 0 frame 0 TX packets 17563568 bytes 1516947572 (1.5 GB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 1654925876 bytes 134933568498 (134.9 GB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1654925876 bytes 134933568498 (134.9 GB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tap0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet6 fe80::f8ae:85ff:fed7:f9cd prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether fa:ae:85:d7:f9:cd txqueuelen 1000 (Ethernet) RX packets 557 bytes 44913 (44.9 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 7165 bytes 832171 (832.1 KB) TX errors 0 dropped 55942 overruns 0 carrier 0 collisions 0 当前网络拓扑：\n+-----------------------------------+ | Internet | +-----------------------------------+ | | v +---------------------------------------------------------+ | enp3s0 (Host Interface) | | IP: 10.12.192.173 | +---------------------------------------------------------+ | v +---------------------------------------------------------+ | br0 (Bridge) | | IP: 10.12.192.173 | | +---------------------+ | | | tap0 | | | | IP: 0.0.0.0 | | +---------------------------|-----------------------------+ | v +---------------------------|-----------------------------+ | | eth0 | | | | IP:10.12.193.53 | | | +---------------------+ | | VM0 (QEMU) | +---------------------------------------------------------+ 查看当前的网桥状态，可以看到 tap0 已经处于 forwarding 状态：\n$ sudo brctl showstp br0 br0 bridge id\t8000.08002732e709 designated root\t8000.08002732e709 enp2s0 (1) port id\t8001\tstate\tforwarding designated root\t8000.08002732e709\tpath cost\t4 designated bridge\t8000.08002732e709\tmessage age tap0 (2) port id\t8002\tstate\tforwarding designated root\t8000.08002732e709\tpath cost\t100 designated bridge\t8000.08002732e709\tmessage age 添加 VM1 过程就忽略了，添加后的网络拓扑如下：\n+-----------------------------------+ | Internet | +-----------------------------------+ | | v +---------------------------------------------------------+ | enp3s0 (Host Interface) | | IP: 10.12.192.173 | +---------------------------------------------------------+ | v +---------------------------------------------------------+ | br0 (Bridge) | | IP: 10.12.192.173 | | +---------------------+ +-------------------+ | | | tap0 | | tap1 | | | | IP: 0.0.0.0 | | IP: 0.0.0.0 | | +---------------|-------------------------|---------------+ | | v v +---------------|----------+ +-----------|---------------+ | | eth0 | | | | eth0 | | | | IP:10.12.193.53 | | | | IP:10.12.193.101 | | | +---------------------+| | +-------------------+ | | VM0 (QEMU) | | VM1 (QEMU) | +--------------------------+ +---------------------------+ QEMU 网络虚拟化 QEMU 对于网络的虚拟化需要两个参数来指定：\n其中一个用于指定网络的前端驱动，也就是 Guest 中的实现 另一个用于指定网络的后端实现，也就是在 Host 中的实现。 QEMU 支持两种方式来实现网络虚拟化，一种是旧版本上使用的参数为 -net 配合 -net ，另一种是在新版本上支持的 -device 配合 -netdev 。QEMU 的发展趋势是倾向于用 -device 一种命令格式来虚拟出不同的设备，其中包括网卡设备。\n-net \u0026amp; -net (legacy) 虽然仍然支持，但是逐步被废弃，不推荐使用。\n我们以以下命令为例，来说明 -net 和 -net 的使用方法：\nvcpu=8 memory=8 drive=\u0026#34;openEuler-22.09-V1-riscv64-qemu.qcow2\u0026#34; fw=\u0026#34;fw_payload_oe_qemuvirt.elf\u0026#34; cmd=\u0026#34;qemu-system-riscv64 \\ -nographic -machine virt \\ -smp \u0026#34;$vcpu\u0026#34; -m \u0026#34;$memory\u0026#34;G \\ -kernel \u0026#34;$fw\u0026#34; \\ -bios none \\ -drive file=\u0026#34;$drive\u0026#34;,format=qcow2,id=hd0 \\ -object rng-random,filename=/dev/urandom,id=rng0 \\ -device virtio-vga \\ -device virtio-rng-device,rng=rng0 \\ -device virtio-blk-device,drive=hd0 \\ -net nic,mac=52:54:00:12:34:56 \\ -net tap,ifname=tap0,script=no,downscript=no \\ -device qemu-xhci -usb -device usb-kbd -device usb-tablet \\ -append \u0026#39;root=/dev/vda1 rw console=ttyS0 swiotlb=1 loglevel=3 systemd.default_timeout_start_sec=600 selinux=0 highres=off mem=\u0026#34;$memory_append\u0026#34;M earlycon\u0026#39; \u0026#34; 其中这两个参数即实现了虚拟化网络：\n-net nic,mac=52:54:00:12:34:56 \\ -net tap,ifname=tap0,script=no,downscript=no \\ 第一个参数 -net nic 用于指定上述所说的前端驱动，也就是 Guest 中的实现，这里使用的是 默认的驱动，这个驱动是 QEMU 中的一个虚拟网卡设备，指定它的 MAC 地址为 52:54:00:12:34:56。\n第二个参数 -net tap 用于指定后端实现，也就是 Host 中的实现，这里使用的是 tap 驱动，它的网卡名称为 tap0，并且不执行任何脚本。这两个参数的组合就实现了虚拟化网络。\n更多示例：\n-net nic,model=virtio \\ -net tap,ifname=tap3,script=/ect/qemu/qemu-ifup,downscript=no \\ 第一个参数 -net nic 用于指定上述所说的前端驱动，也就是 Guest 中的实现，这里使用的是 virtio 驱动，这个驱动是 QEMU 中的一个虚拟网卡设备。第二个参数 -net tap 用于指定后端实现，也就是 Host 中的实现，这里使用的是 tap 驱动，它的网卡名称为 tap3，并且执行脚本 /ect/qemu/qemu-ifup。\n解释/ect/qemu/qemu-ifup 该脚本用于创建网桥，将网桥与宿主机的网卡绑定，然后将虚拟网卡绑定到网桥上，这样虚拟机就可以通过网桥与宿主机通信，宿主机也可以通过网桥与虚拟机通信。\n-device \u0026amp; -netdev （Recommended） 这是新版本的 QEMU 支持的命令格式，也是 QEMU 未来的发展趋势，我们以以下命令为例，来说明 -device 和 -netdev 的使用方法：\nqemu-system-riscv64 \\ -nographic -machine virt \\ -smp \u0026#34;$vcpu\u0026#34; -m \u0026#34;$memory\u0026#34;G \\ -bios \u0026#34;$fw\u0026#34; \\ -drive file=\u0026#34;$drive\u0026#34;,format=qcow2,id=hd0 \\ -object rng-random,filename=/dev/urandom,id=rng0 \\ -device virtio-vga \\ -device virtio-rng-device,rng=rng0 \\ -device virtio-blk-device,drive=hd0 \\ -device virtio-net-device,netdev=tapnet,mac=e0:be:03:88:54:e8 \\ -netdev tap,id=tapnet,ifname=tap0,script=~/qemu-script/qemu-ifup,downscript=no \\ -device qemu-xhci -usb -device usb-kbd -device usb-tablet 其中这两个参数即实现了虚拟化网络：\n-device virtio-net-device,netdev=tapnet,mac=e0:be:03:88:54:e8 \\ -netdev tap,id=tapnet,ifname=tap0,script=~/qemu-script/qemu-ifup,downscript=no \\ 第一个参数 -device virtio-net-device 用于指定上述所说的前端驱动，也就是 Guest 中的实现，定义了名为 virtio-net-device 的网络设备，并将其连接到一个名为 tapnet 的网络设备上，指定它的 MAC 地址为 e0:be:03:88:54:e8。\n第二个参数 -netdev tap 用于指定后端实现，使用tap方式，并且指定唯一 ID 为tapnet由-device参数中的子参数netdev使用。网卡名称为tap0并且执行脚本 ~/qemu-script/qemu-ifup。\n-netdev 参数中 id 的使用 -netdev 参数中的 id 用于指定唯一的 ID，这个 ID 会被 -device 参数中的子参数 netdev 使用，这样 -device 参数就知道要将前端驱动连接到哪个后端实现上了。id 可以自定义任意唯一字符串如-netdev tap,id=test对应-device virtio-net-device,netdev=test\n更多示例：\n-device virtio-net-pci,netdev=tapnet,mac=e0:be:03:88:54:e8 \\ -netdev tap,id=tapnet,script=no,downscript=no \\ 第一个参数 -device virtio-net-pci 定义了名为 virtio-net-pci 的网络设备，并将其连接到一个名为 tapnet 的网络设备上，指定它的 MAC 地址为 e0:be:03:88:54:e8。\n第二个参数，仔细观察会发现，我们没有定义链接到后端网卡的名称ifname，这是因为以tap模式启动 QEMU 时会自动创建tap设备，具体网卡名称根据当前宿主机的网卡情况而定，默认会创建一个名为tap0的网卡，如果启动了两个虚拟机，那么第二个虚拟机的网卡名称就是tap1，以此类推。\n区分 tap 模式与 bridge 模式 我们有时候会用以下的命令进行 QEMU 虚拟机桥接网络的配置：\n-device virtio-net-device,netdev=bridgenet,mac=52:54:00:12:34:57 \\ -netdev bridge,ifname=br0,id=bridgenet 这也能为我们创建一个桥接网络，这是因为它和 -netdev tap 的工作方式是一样的，只是 -netdev bridge 的简化写法，qemu-bridge-helper 在背后替我们做了 tap 设备创建以及将 tap 设备加入桥接口的所有事情。\n添加多张网卡 如果了解上述内容，添加多张网卡就十分容易实现了，我们只需要再添加一对 -device 和 -netdev 参数即可，如下所示：\nqemu-system-riscv64 \\ -nographic -machine virt \\ -smp \u0026#34;$vcpu\u0026#34; -m \u0026#34;$memory\u0026#34;G \\ -bios \u0026#34;$fw\u0026#34; \\ -drive file=\u0026#34;$drive\u0026#34;,format=qcow2,id=hd0 \\ -object rng-random,filename=/dev/urandom,id=rng0 \\ -device virtio-vga \\ -device virtio-rng-device,rng=rng0 \\ -device virtio-blk-device,drive=hd0 \\ -device virtio-net-device,netdev=tapnet0,mac=e0:be:03:88:54:e8 \\ -netdev tap,id=tapnet0,script=/etc/qemu/qemu-ifup,downscript=/etc/qemu/qemu-ifdown \\ -device virtio-net-device,netdev=tapnet1,mac=e0:be:03:88:54:e8 \\ -netdev tap,id=tapnet1,script=/etc/qemu/qemu-ifup,downscript=/etc/qemu/qemu-ifdown \\ -device qemu-xhci -usb -device usb-kbd -device usb-tablet 需要注意的是，我们需要为每个 -device 参数指定一个唯一的 ID，这个 ID 会被 -netdev 参数中的子参数 netdev 使用，这样 -device 参数就知道要将前端驱动连接到哪个后端实现上了。并且每个 tap 设备只能被一个虚拟机使用，所以每个虚拟机的 tap 设备名称不能相同。\n登录虚拟机查看网卡信息：\n[root@openEuler-riscv64 ~]# ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.12.193.53 netmask 255.255.240.0 broadcast 10.12.207.255 inet6 fe80::9e6:287b:30a2:574d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether e0:be:03:88:54:e8 txqueuelen 1000 (Ethernet) RX packets 81 bytes 9871 (9.6 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 19 bytes 1735 (1.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 eth1: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.12.193.101 netmask 255.255.240.0 broadcast 10.12.207.255 inet6 fe80::4fe0:9e1e:4681:52b7 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 80:d4:09:62:cd:3c txqueuelen 1000 (Ethernet) RX packets 76 bytes 9471 (9.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 15 bytes 1708 (1.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 不同网络策略工作方式 NAT 网络模式 NAT 网络以路由器的 NAT 功能为原理，允许虚拟机通过共享主机的 IP 地址访问互联网，但虚拟机之间不能直接通信。通过端口转发可以实现虚拟机之间的连接。 桥接网络模式 桥接网络模式通过虚拟交换机连接虚拟机和主机，使得虚拟机可以通过局域网访问互联网，并允许虚拟机之间直接通信。 内部网络模式 内部网络模式使得虚拟机可以创建一个完全隔离的网络，虚拟机之间可以直接通信，但无法访问互联网或外部网络。 仅主机网络模式 仅主机网络模式允许虚拟机之间可以通信，并且与主机之间也可以通信，但无法访问互联网或外部网络。 VM \u0026lt;\u0026gt; VM VM → HOST HOST → VM VM → Internet Internet → VM 网络地址转换 NAT × √ × √ × NAT 网络 √ √ × √ × Bridged Adapter 桥接网卡 √ √ √ √ √ TUN/TAP 网络设备 TAP 属于 Linux 内核支持的一种虚拟化网络设备，还有 TUN 也属于这种设备，它们完全由软件模拟实现，TUN/TAP 负责在内核协议栈和用户进程之间传送协议数据单元。TUN 工作在网络层，而 TAP 工作在数据链路层，TUN 负责与应用程序交换 IP 数据包，而 TAP 与应用程序交换以太网帧。所以 TUN 经常涉及路由，而 TAP 常用于网络桥接。\nSSH 远程登录虚拟机 宿主机任意下目录执行：\n$ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/user/.ssh/id_rsa): host2vm0_id_irsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in host2vm0_id_irsa. Your public key has been saved in host2vm0_id_irsa.pub. The key fingerprint is: SHA256:OkWcw+R3x6Z2mzeYQuG033H3N9qIeym3TZKzz6YD8tQ user@ubuntu18 The key\u0026#39;s randomart image is: +---[RSA 2048]----+ | . | | = . . | | B .o. + | | . oo.o+ | | S ++ ..o| | o ..+.E=o=| | o +..B+=+| | . oo=@o+| | o=**= | +----[SHA256]-----+ 一直回车确定，生成公私钥，保存在~/.ssh目录下。\n我在宿主机上生成的公私钥名称为，分别是host2vm0_id_rsa,host2vm0_id_rsa.pub方便我记忆。如果一直回车，那么生成的公私钥名称为id_rsa，id_rsa.pub。\n将公钥复制到虚拟机 VM0 上，以当前虚拟机 VM0 的 IP：10.12.193.53 为例。\n$ ssh-copy-id 10.12.193.53 # 输入密码 /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys user@10.12.193.53\u0026#39;s password: Number of key(s) added: 1 Now try logging into the machine, with: \u0026#34;ssh \u0026#39;10.12.193.53\u0026#39;\u0026#34; and check to make sure that only the key(s) you wanted were added. 然后就可以直接免密码登录了：\nssh user@10.12.193.53 Fixed Problems (Ongoing) cannot ioctl tunsetiff tap0 device or resource busy (errno=16) failed to initialize tap device: Operation not permitted 同类型错误：failed to create TAP device: Operation not permitted。因为创建虚拟设备 tap 需要 root 权限，所以需要使用 sudo 命令。执行 QEMU 启动是需要添加 sudo。\nQEMU 虚拟机启动后网卡处于 DOWN 状态，无法获取 IP 查看是否是 MAC 地址配置错误，使用下面命令检查：\nsudo ifconfig eth0 up SIOCSIFFLAGS: Cannot assign requested address 如果报错，参考下面章节SIOCSIFFLAGS: Cannot assign requested address解决方法进行解决。\n虚拟机可以 ping 通外网，宿主机无法 ping 外网 这种情况说明基本网络没有问题，只是 DNS 解析有问题，可以通过修改/etc/resolv.conf文件解决。\n海宁 DNS 服务器地址：10.12.2.21 和 10.12.2.22，我的情况是只能 ping 10.12.2.21，可以选择自己能 ping 通的 DNS 服务器地址。如果无法 ping 通，说明问题不在这，需要自行解决。\n# 修改 DNS 服务器地址 sudo vim /etc/resolv.conf # 添加以下内容 nameserver 10.12.2.21 nameserver 10.12.2.22 网络配置错误，如何恢复配置之前的状态 最简单的方式 - 重启，因为所有操作都是命令行配置，都是临时配置，可以直接重启解决。\n既然有这一小节，说明肯定有时候不方便直接重启，那么就需要手动恢复配置之前的状态。但是能够恢复的前提是需要记得之前的网卡 IP 地址、子网掩码、网关、广播地址等信息。这些信息在局域网里，可能只有 IP 不同，其他信息如果没记住可以查看其他同事的网卡配置即可。\n# 将网桥绑定的网卡从网桥上移除 sudo brctl delif br0 enp2s0 sudo brctl delif br0 tap0 # 配置宿主机网卡信息，必须一字不差，保持和之前一模一样才能恢复 sudo ip addr add 10.12.192.173/20 broadcast 10.12.207.255 dev enp2s0 # 必须设置网关 sudo ip route add default via 10.12.192.1 dev enp2s0 # 重启网络管理器 systemctl restart NetworkManager -netdev tap,id=tapnet,script=/qemu-script/qemu-ifup,:network script /qemu-script/qemu-ifup failed with status 256 可能原因 1: qemu-ifup 脚本没有执行权限，需要添加执行权限。\nchmod +x qemu-ifup 可能原因 2: qemu-ifup 路径不对，必须放到/etc/qemu/目录下。\nmkdir -p /etc/qemu mv qemu-ifup /etc/qemu \u0026amp;\u0026amp; mv qemu-ifdown /etc/qemu sudo chmod +x qemu-ifup sudo chmod +x qemu-ifdown SIOCSIFFLAGS: Cannot assign requested address sudo ifconfig eth0 up SIOCSIFFLAGS: Cannot assign requested address 一般由于 MAC 地址配置错误导致，可以通过修改 MAC 地址为多播地址解决。\nsudo ifconfig enp2s0 hw ether 00:11:22:33:44:55 重启网卡\nsudo ifconfig enp2s0 down sudo ifconfig enp2s0 up MAC 地址的第一个字节中的最后一位（即第 7 位）用于标识该地址是单播，多播还是广播地址。如果这个位设置为 0，则表示这是一个单播地址；如果设置为 1，则表示这是一个多播或广播地址。\n使用这种方法，我们可以确定上述每个 MAC 地址是否是单播地址：\ncd:c2:05:84:c8:2c - 单播地址 13:7b:49:fc:a6:aa - 单播地址 8f:aa:42:29:e8:68 - 单播地址 00:11:22:33:44:55 是多播地址。\nqemu -device drive with 0 bus=0 unit=0 exists 这个错误通常意味着您尝试在 QEMU VM 中添加一个重复的设备。\n如果您已经在 VM 中添加了驱动器，则可能会出现此问题。您可以检查是否存在两个具有相同 bus 和 unit 的设备（在此情况下，都是 0）。解决此问题的方法是删除重复设备或更改其配置以包括唯一的 bus 和 unit。\n如果您没有意图添加重复的设备，在运行 QEMU 之前，您可能需要检查您的命令行，以确保正确设置了 -drive 选项。请注意，当使用 -device 添加设备时，您还应该避免使用 -drive 选项，因为它们可能引起冲突。\n如果您需要进一步帮助，建议提供完整的 QEMU 命令和参数列表，以便更好地理解问题并提供更详细的建议。\n参考资料 QEMU 网络配置 // 围城 理解 Linux 虚拟网卡设备 tun/tap 的一切 | 骏马金龙 QEMU 网络配置一把梭 | CataLpa\u0026rsquo;s Site qemu 虚拟机与外部网络的通信 li_Jiejun 的博客-CSDN 博客 安装 qemu-kvm 以及配置桥接网络 QEMU 中的网络虚拟化配置_程序猿 Ricky 的日常干货的博客-CSDN 博客 Nginx Directory QEMU 网络配置 - 浙林龙哥 - 博客园 【qemu】qemu 网络配置 - 知乎 QEMU 网络配置 // 围城 安装 qemu-kvm 以及配置桥接网络 在 qemu 中使用桥接网络 - T^3 Blog 为 QEMU 配置网桥上网 | Yanick\u0026rsquo;s Wiki 理解 Linux 虚拟网卡设备 tun/tap 的一切 | 骏马金龙 QEMU 网络配置一把梭 | CataLpa\u0026rsquo;s Site 附录 ","permalink":"https://lifeislife.cn/posts/qemu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","summary":"\u003ch1 id=\"quick-setup\"\u003eQuick Setup\u003c/h1\u003e\n\u003ch2 id=\"安装工具\"\u003e安装工具\u003c/h2\u003e\n\u003cp\u003e安装两个网络管理工具用于建立网桥以及虚拟网卡：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 安装虚拟网桥工具\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install bridge-utils -y\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# UML（User-mode linux）工具        \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install uml-utilities  -y   \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"配置脚本\"\u003e配置脚本\u003c/h2\u003e\n\u003ch3 id=\"qemu-ifup\"\u003eqemu-ifup\u003c/h3\u003e\n\u003cp\u003e将下面的脚本保存为文件 \u003ccode\u003eqemu-ifup\u003c/code\u003e，并赋予可执行权限：\u003c/p\u003e","title":"QEMU 虚拟机网络配置"},{"content":"Dotfiles 就是我们在使用软件的时候，软件为了存储我们个人偏好设置而建立的一个以 . 开头的文件。例如，vim 的配置文件就是 .vimrc，zsh 的配置文件就是 .zshrc。这些文件通常存储在用户的 home 目录中。但是，在不同的电脑上工作时，如果需要使用相同的配置，我们可以考虑使用版本控制工具来管理这些文件。或者在一台新电脑上想快速配置好环境，也可以使用版本控制工具来管理这些文件。Yadm 就可以帮助我们完成这些需求。\n安装 yadm 安装 安装 yadm 非常简单，只需在终端输入以下命令：\nsudo apt-get install yadm 初始化 yadm 仓库 创建一个新的 yadm 仓库很容易，只需在 home 目录中运行以下命令：\nyadm init 现在，yadm 已经创建了一个空白的 git 仓库。\n存储库位置/home/nic/.local/share/yadm/\n添加 dotfile 文件 要将现有的 dotfile 添加到 yadm 仓库中，请使用以下命令：\nyadm add ~/.zshrc 一旦您完成了对要添加的文件的更改并将它们添加到 yadm 仓库中，您需要提交它们。可以使用以下命令：\nyadm commit -m \u0026#34;Add .zshrc file to yadm repository\u0026#34; 建立远程仓库 使用 yadm 还可以将 dotfile 文件同步到 GitHub 等 Git 托管服务中。\n登录 Github，创建一个新的仓库。例如，您可以创建一个名为 dotfile 的仓库。现在，您需要将本地仓库与远程仓库连接起来。要将本地仓库连接到远程仓库，请使用以下命令：\nyadm remote add origin https://github.com/[用户名]/dotfile.git 现在 yadm 已经连接到您在 Github 上创建的仓库。要将本地代码上传到远程仓库，请使用以下命令：\nyadm push 使用多台电脑时如何同步配置 假设需要在多个计算机之间共享 dotfile 文件。只需按照以下步骤即可：\n在另一台计算机上安装 yadm 并初始化 yadm 仓库。 将远程仓库克隆到该计算机的 yadm 仓库中： yadm clone https://github.com/[用户名]/dotfile.git 此时，您的 dotfile 文件应在计算机上自动更新。 执行完 clone 命令后实际上就是 yadm 会把远程仓库的文件都拷贝到本地。\n如果本地有修改和远程有冲突怎么办 如果本地有修改，远程也有修改，那么就会产生冲突。这时候需要先解决冲突，然后再提交。\n每台电脑的配置不一样怎么办 比如我们会在.zshrc中配置一些环境变量，但是每台电脑的环境变量可能不一样。这时候我们可以在.zshrc中添加一些判断，比如我们可以简单的判断一下主机名，然后根据主机名来加载不同的配置。\nif [ $HOSTNAME = \u0026#34;xxx\u0026#34; ]; then # xxx的配置 elif [ $HOSTNAME = \u0026#34;yyy\u0026#34; ]; then # yyy的配置 fi 但有一些配置文件可能不支持这样的添加语句，比如.gitconfig，这时候我们可以使用 yadm 的 Alternate Files 功能解决。\nAlternate Files 是一个用于管理同一文件不同版本的功能，有时在不同的主机、操作系统和用户需要不同的文件。Alternate Files 允许使用同一个文件名字，在文件名后添加一个带有条件的后缀，例如##os.Linux,hostname.host1，class.work，yadm 会根据当前系统的特定条件自动选择适当的版本，并创建符号链接。如果没有符合条件的版本，它将选择默认版本。\n就以.gitconfig配置文件为例，我们通常在公司的电脑和家里的电脑配置不太一样，比如公司使用下面的配置：\n[user] email = 公司邮箱 name = 公司用户名 在家里使用下面的配置：\n[user] email = 日常使用邮箱 name = 日常使用用户名 配置文件不支持条件语句，所以无法通过直接在同一个配置文件里完成不同环境的配置。这就用到了 Alternate Files 功能，我们可以复制两个.gitconfig文件后面添加一个条件后缀，比如.gitconfig##class.work，然后在.gitconfig##class.work文件中添加公司的配置，.gitconfig文件中添加家里的配置。这样 yadm 就会根据当前的主机名自动选择合适的配置文件。并把这三个文件都加入到 yadm 仓库中。\nyadm add ~/.gitconfig yadm add ~/.gitconfig##class.work yadm add ~/.gitconfig##class.home 那么 yadm 是如何实现不同环境的切换呢？我们还需要进一步配置，有注意到我们的配置文件名中的class属性吗，这是 yadm 支持的条件属性之一。我们可以通过yadm config命令来配置当前电脑的属性。比如我们配置公司电脑的class属性为work，家里的电脑的class属性为home。\nyadm config local.class work 我们执行完此命令后，yadm 会自动为.gitconfig文件添加一个软链接，链接到.gitconfig##class.work文件。这样我们就可以在公司电脑上使用公司的配置了。如果我们在家里的电脑上执行yadm config local.class home，那么 yadm 会自动为.gitconfig文件添加一个软链接，链接到.gitconfig##class.home文件。这样我们就可以在家里的电脑上使用家里的配置了。\nyadm 支持以下这些条件：\n属性 意义 arch, a 如果值匹配架构则有效。通过运行 uname -m 计算架构。 class, c 如果值匹配 local.class 配置，则有效。必须使用“yadm config local.class ”手动设置 Class。 default 当没有其他备选项有效时有效。 distro, d 如果值与发行版匹配，则有效。通过运行 lsb_release -si或检查/etc/os-release来计算分布。 distro_family, f 如果值匹配发行版系列，则有效。通过检查/etc/os-release 中的 ID_LIKE 行计算发行版系列。 extension, e 一种特殊的“条件”，不影响选择过程。它的目的是允许备选文件以特定扩展名结尾，例如使编辑器正确突出显示内容。 hostname, h 如果值匹配短主机名，则有效。通过运行 uname -n，并去除任何域来计算主机名。 os，o 如果值与操作系统匹配，则有效。通过运行 uname -s 计算 OS。* template, t 当值与支持的模板处理器匹配时有效。有关更多详细信息，请参见模板部分。 user, u 如果值匹配当前用户，则有效。通过运行 id -u -n 计算当前用户。 再举个例子，上面用的 class 条件是必须通过yadm config local.class \u0026lt;class\u0026gt;手动设置的。但是有一些条件不需要手动设置 yadm 可以自动识别。比如 os 属性。我们将.zshrc文件复制两份份，命名为.zshrc##os.Linux和.zshrc##os.Darwin，然后在.zshrc##os.Linux文件中添加一些 Linux 系统的配置，.zshrc##os.Darwin文件中添加一些 Mac 系统的配置。并把这三个文件都加入到 yadm 仓库中。这样 yadm 就会根据当前的系统自动选择合适的配置文件。\n","permalink":"https://lifeislife.cn/posts/%E4%BD%BF%E7%94%A8yadm%E7%AE%A1%E7%90%86%E5%B9%B6%E5%90%8C%E6%AD%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6dotfile/","summary":"\u003cp\u003eDotfiles 就是我们在使用软件的时候，软件为了存储我们个人偏好设置而建立的一个以 \u003ccode\u003e.\u003c/code\u003e 开头的文件。例如，vim 的配置文件就是 \u003ccode\u003e.vimrc\u003c/code\u003e，zsh 的配置文件就是 \u003ccode\u003e.zshrc\u003c/code\u003e。这些文件通常存储在用户的 home 目录中。但是，在不同的电脑上工作时，如果需要使用相同的配置，我们可以考虑使用版本控制工具来管理这些文件。或者在一台新电脑上想快速配置好环境，也可以使用版本控制工具来管理这些文件。Yadm 就可以帮助我们完成这些需求。\u003c/p\u003e","title":"使用 Yadm 管理并同步配置文件 Dotfile"},{"content":" 基于Ubuntu 18.04，QEMU 8.0.2，OpenEuler 22.09\n安装QEMU 安装基础编译工具 sudo apt install build-essential autoconf automake autotools-dev pkg-config bc curl \\ gawk git bison flex texinfo gperf libtool patchutils mingw-w64 libmpc-dev \\ libmpfr-dev libgmp-dev libexpat-dev libfdt-dev zlib1g-dev libglib2.0-dev \\ libpixman-1-dev libncurses5-dev libncursesw5-dev meson libvirglrenderer-dev libsdl2-dev -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt install python3.8 python3-pip -y sudo apt install -f pip3 install meson 下载QEMU 建立文件夹用于编译：\ncd \u0026amp;\u0026amp; mkdir -p qemu-build 建立文件夹用于安装：\ncd \u0026amp;\u0026amp; mkdir -p /home/user/program/riscv64-qemu 可登录官网将版本号换成最新版本即可：\ncd qemu-build \u0026amp;\u0026amp; wget \u0026#34;https://download.qemu.org/qemu-8.0.2.tar.xz\u0026#34; tar -xf qemu-8.0.2.tar.xz --strip-components=1 安装QEMU cd qemu-build \u0026amp;\u0026amp; ./configure --target-list=riscv32-softmmu,riscv32-linux-user,riscv64-linux-user,riscv64-softmmu \\ --enable-kvm --enable-sdl \\ --prefix=/home/user/program/riscv64-qemu make install -j $(nproc) 配置环境变量\necho \u0026#39;export QEMU_HOME=/home/user/program/riscv64-qemu\u0026#39; \u0026gt;\u0026gt; ~/.bashrc \u0026amp;\u0026amp; echo \u0026#39;export PATH=$QEMU_HOME/bin:$PATH\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 下载 OpenEuler RISC-V 系统镜像 建立目录：\ncd \u0026amp;\u0026amp; mkdir -p /home/user/openeuler 根据自己的用户名修改user\n下载OpenEuler 22.09版本，下载目录下所有文件/home/user/openeuler。如需下载其他版本请进入其他目录选择下载即可。\n也可以根据自己的情况进入镜像站列表选择下载速度更快的镜像站下载\n最新的23.03版本需要在中科院镜像站下载\n文件说明：\nfw_payload_oe_qemuvirt.elf: 利用 openSBI 将 kernel-5.10 的 image 作为 payload 所制作的 QEMU 启动所需文件 openEuler-22.09-qemu-xfce.qcow2.tar.zst: openEuler RISC-V QEMU GUI 镜像压缩包 preview_start_vm_xfce.sh: GUI 虚拟机启动脚本 openeuler-22.09-qemu.qcow2.tar.zst: openEuler RISC-V QEMU headless 镜像压缩包 preview_start_vm.sh: headless 虚拟机启动脚本 解压：\nsudo apt-get install zstd tar -I \u0026#39;zstdmt\u0026#39; -xvf openEuler-22.09-riscv64-qemu.qcow2.tar.zst 执行启动脚本\nchmod +x preview_start_vm.sh bash preview_start_vm.sh 登录系统 用户名: root 默认密码: openEuler12#$ openEuler 22.09 Kernel 5.10.0 on an riscv64 4penEuler-riscv6 login: openEuler 22.09 Kernel 5.10.0 on an riscv64 openEuler-riscv64 login: root Password: Welcome to 5.10.0 System information as of time: Mon Jul 3 07:52:19 PM CST 2023 System load: 0.17 Processes: 117 Memory used: .6% Swap used: 0.0% Usage On: 6% Users online: 1 [root@openEuler-riscv64 ~]# ls [root@openEuler-riscv64 ~]# pwd 远程登录系统 ssh -p 12055 root@localhost 配置系统 以下操作均在root用户下执行，如果切换了用户会有提示。因为系统初始状态没有普通用户，也没有sudo，所以需要使用root完成一些基础配置。\n修改root密码 原密码太复杂，修改简单密码\npasswd root # 输入两次密码 添加普通用户 # 添加用户 user useradd -s /bin/bash -d /home/user -m user passwd user # 输入两次密码 # 添加管理员权限 usermod -aG wheel user 修改时间 echo \u0026#34;NTP=ntp.aliyun.com\u0026#34; \u0026gt;\u0026gt; /etc/systemd/timesyncd.conf systemctl restart systemd-timesyncd.service 查看timesyncd运行状态：\nsystemctl status systemd-timesyncd.service date命令可查看当前系统时间。验证是否配置成功。\n时间务必正确设置，错误的时间会影响诸如https的TLS认证等过程。\n配置DNS vim /etc/resolv.conf nameserver 119.29.29.29 配置软件包源 配置文件为 /etc/yum.repos.d/openEuler.repo 下\nmv /etc/yum.repos.d/openEuler.repo /etc/yum.repos.d/openEuler.repo.bk \u0026amp;\u0026amp; sudo bash -c \u0026#34;cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/yum.repos.d/openEuler.repo # just for test [mainline] name=mainline baseurl=https://mirror.iscas.ac.cn/openeuler-sig-riscv/openEuler-RISC-V/preview/openEuler-22.09-V1-riscv64/repo/22.09/ enabled=1 gpgcheck=0 # just for test [epol] name=epol baseurl=https://mirror.iscas.ac.cn/openeuler-sig-riscv/openEuler-RISC-V/preview/openEuler-22.09-V1-riscv64/repo/22.09/ enabled=1 gpgcheck=0 [extra] name=extra baseurl=https://mirror.iscas.ac.cn/openeuler-sig-riscv/openEuler-RISC-V/preview/openEuler-22.09-V1-riscv64/repo/extra/ enabled=1 gpgcheck=0 EOF\u0026#34; 需要注意的是，因为OpenEuler还在快速发展中，镜像地址可能会发生变化，所以需确认地址是否能够正常访问，如无法访问会导致404错误\n[repoid]中的repoid为软件仓库（repository）的ID号，所有.repo配置文件中的各repoid不能重复，必须唯一。示例中repoid设置为base。 name为软件仓库描述的字符串。 baseurl为软件仓库的地址。 enabled为是否启用该软件源仓库，可选值为1和0。默认值为1，表示启用该软件源仓库。 gpgcheck可设置为1或0，1表示进行gpg（GNU Private Guard）校验，0表示不进行gpg校验，gpgcheck可以确定rpm包的来源是有效和安全的。 gpgkey为验证签名用的公钥。\n磁盘扩容 在宿主机上安装 qemu-img 工具: apt install qemu-utils 在 openEuler RISC-V 虚拟机上安装 growpart 工具: dnf install cloud-utils-growpart 关闭QEMU虚拟机 把 qcow2 文件的容量加200GB： $ qemu-img resize *.qcow2 +200G Image resized. $ qemu-img info *.qcow2 image: openEuler-preview.riscv64.qcow2 file format: qcow2 virtual size: 220 GiB disk size: 9.58 GiB cluster_size: 65536 Format specific information: compat: 1.1 compression type: zlib lazy refcounts: false refcount bits: 16 corrupt: false extended l2: false QEMU 启动 openEuler RISC-V。 启动以后，我们先看看分区情况：可以看到根目录对应的分区只使用了 10G。\n[root@openEuler-RISCV-rare ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 254:0 0 220G 0 disk └─vda1 254:1 0 10G 0 part / 扩展分区 vda1，执行 growpart /dev/vda1 执行 lsblk 可以看到 / 所在的 vda1 分区已经扩展到了预期大小\n[root@openEuler-RISCV-rare ~]# growpart /dev/vda 1 CHANGED: partition=1 start=2048 old: size=20969472 end=20971520 new: size=419428319 end=419430367 [root@openEuler-RISCV-rare ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 254:0 0 220G 0 disk └─vda1 254:1 0 220G 0 part / 扩展文件系统： resize2fs /dev/vda1 BUG network backend ‘user‘ is not compiled into this binary git clone https://gitlab.freedesktop.org/slirp/libslirp.git\nhttp://security.ubuntu.com/ubuntu/pool/main/libs/libslirp/libslirp-dev_4.1.0-2ubuntu2.2_amd64.deb\nsudo apt-get install libslirp-dev 重新编译QEMU：\ncd qemu-build \u0026amp;\u0026amp; rm -rf build cd qemu-build \u0026amp;\u0026amp; ./configure --target-list=riscv32-softmmu,riscv32-linux-user,riscv64-linux-user,riscv64-softmmu \\ --enable-kvm --enable-sdl --enable-slirp\\ --prefix=/home/user/program/riscv64-qemu make install -j $(nproc) 参考文档 RISC-V/doc/tutorials/vm-qemu-oErv.md at master · openeuler-mirror/RISC-V · GitHub\nopenEuler 22.09技术白皮书\n","permalink":"https://lifeislife.cn/posts/qemu%E5%90%AF%E5%8A%A8risc-v%E6%9E%B6%E6%9E%84openeuler%E5%B9%B6%E9%85%8D%E7%BD%AEosc%E7%8E%AF%E5%A2%83/","summary":"\u003cblockquote\u003e\n\u003cp\u003e基于Ubuntu 18.04，QEMU 8.0.2，OpenEuler 22.09\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"安装qemu\"\u003e安装QEMU\u003c/h1\u003e\n\u003ch2 id=\"安装基础编译工具\"\u003e安装基础编译工具\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install build-essential autoconf automake autotools-dev pkg-config bc curl \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e                 gawk git bison flex texinfo gperf libtool patchutils mingw-w64 libmpc-dev \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e                 libmpfr-dev libgmp-dev libexpat-dev libfdt-dev zlib1g-dev libglib2.0-dev \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e                 libpixman-1-dev libncurses5-dev libncursesw5-dev meson libvirglrenderer-dev libsdl2-dev  -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo add-apt-repository ppa:deadsnakes/ppa\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install python3.8 python3-pip  -y\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install -f\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epip3 install meson\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"下载qemu\"\u003e下载QEMU\u003c/h2\u003e\n\u003cp\u003e建立文件夹用于编译：\u003c/p\u003e","title":"QEMU启动RISC-V架构OpenEuler并配置OSC环境"},{"content":"基础配置 添加安全组规则，允许 Ping 和 SSH 访问虚拟机：\nopenstack security group rule create --proto icmp default root@allone:~# openstack security group rule create --proto icmp default +-------------------+---------------------------+ | Field | Value | +-------------------+-------------------------+ | created_at | 2023-06-28T06:26:10Z | | description | | | direction | ingress | | ether_type | IPv4 | | id | fe9adfc3-dc42-4680-8ecd-ed5a667e1215 | | location | cloud=\u0026#39;\u0026#39;, project.domain_id=, project.domain_name=\u0026#39;Default\u0026#39;, project.id=\u0026#39;6396365541a74b6b8ea8812d1af05e70\u0026#39;, project.name=\u0026#39;admin\u0026#39;, region_name=\u0026#39;\u0026#39;, zone= | | name | None | | port_range_max | None | | port_range_min | None | | project_id | 6396365541a74b6b8ea8812d1af05e70 | | protocol | icmp | | remote_group_id | None | | remote_ip_prefix | 0.0.0.0/0 | | revision_number | 0 | | security_group_id | f10a3927-5e76-47b4-8691-4169348845ae | | tags | [] | | updated_at | 2023-06-28T06:26:10Z | +-------------------+--------------------------------+ openstack security group rule create --proto tcp --dst-port 22 default root@allone:~# openstack security group rule create --proto tcp --dst-port 22 default +-------------------+--------------------------------------+ | Field | Value | +-------------------+--------------------------------------------+ | created_at | 2023-06-28T06:26:15Z | | description | | | direction | ingress | | ether_type | IPv4 | | id | af699cf9-5fc0-45e2-a009-0bb7828e2d1a | | location | cloud=\u0026#39;\u0026#39;, project.domain_id=, project.domain_name=\u0026#39;Default\u0026#39;, project.id=\u0026#39;6396365541a74b6b8ea8812d1af05e70\u0026#39;, project.name=\u0026#39;admin\u0026#39;, region_name=\u0026#39;\u0026#39;, zone= | | name | None | | port_range_max | 22 | | port_range_min | 22 | | project_id | 6396365541a74b6b8ea8812d1af05e70 | | protocol | tcp | | remote_group_id | None | | remote_ip_prefix | 0.0.0.0/0 | | revision_number | 0 | | security_group_id | f10a3927-5e76-47b4-8691-4169348845ae | | tags | [] | | updated_at | 2023-06-28T06:26:15Z | +-------------------+-----------------+ 命令行方式 生成秘钥 ssh-keygen -q -N “” -q 选项表示静默模式，即在生成密钥对的过程中不会输出任何提示信息或警告。 -N 选项后面可以跟一个密码作为参数。该密码将用于保护生成的私钥文件。如果不指定 -N 参数，则私钥文件将不受密码保护。 该命令会在~/.ssh/目录中自动生成一对公私钥。默认私钥名称：id_rsa，默认公钥名称：id_rsa.pub\nopenstack keypair create --public-key ~/.ssh/id_rsa.pub mykey 向 OpenStack 添加公钥，用于创建实例时选择：\nroot@allone:~# openstack keypair create --public-key ~/.ssh/id_rsa.pub mykey +-------------+-------------------------------------------------+ | Field | Value | +-------------+-------------------------------------------------+ | fingerprint | 11:36:75:e0:c3:98:4c:97:90:30:f5:69:e1:17:a9:4b | | name | mykey | | user_id | 9027da91a2134825a421d78db11011d0 | +-------------+-------------------------------------------------+ openstack keypair list root@allone:~# openstack keypair list +---------------------+-------------------------------------------------+ | Name | Fingerprint | +---------------------+-------------------------------------------------+ | mykey | 11:36:75:e0:c3:98:4c:97:90:30:f5:69:e1:17:a9:4b | | ubuntu cloud server | 67:b4:8a:64:83:4e:47:d0:7c:87:46:34:3b:03:e6:17 | +---------------------+-------------------------------------------------+ ssh ubuntu@10.0.2.111 其中，ubuntun是实例的用户名，10.0.2.111是实例的 IP 地址。\nWEB 界面方式 创建密钥对 Project-Key Pairs-Create Keypairs\n\u003c!DOCTYPE html\u003e Responsive Image 为密钥对起个名字：sshkey，并选择一个类型：SSH Key\n\u003c!DOCTYPE html\u003e Responsive Image 点击创建后会弹出下载私钥的窗口，这时候需要将私钥下载到本地。并将他移动到 ssh 目录下方便管理。\n# 切换root用户，因为我们一直都是用root用户操作的OpenStack sudo su mv sshkey.pem ~/.ssh \u003c!DOCTYPE html\u003e Responsive Image 使用公钥创建实例 Project-Instances-Launch Instance\n\u003c!DOCTYPE html\u003e Responsive Image 在 Key Pair 中选择刚刚创建的 sshkey。这里实际就是将创建的密钥对中的公钥放到了我们的实例中，这样我们就可以拿着本地的私钥去访问实例。\n\u003c!DOCTYPE html\u003e Responsive Image 登录实例 ssh -i ~/.ssh/sshkey.pem ubuntun@10.0.2.111 其中~/.ssh/sshkey.pem是我们下载的私钥文件，ubuntun是实例的用户名，10.0.2.111是实例的 IP 地址。\n","permalink":"https://lifeislife.cn/posts/ssh-%E7%99%BB%E5%BD%95-openstack-%E5%AE%9E%E4%BE%8B/","summary":"\u003ch1 id=\"基础配置\"\u003e基础配置\u003c/h1\u003e\n\u003cp\u003e添加安全组规则，允许 Ping 和 SSH 访问虚拟机：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eopenstack security group rule create --proto icmp default\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eroot@allone:~# openstack security group rule create --proto icmp default\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-------------------+---------------------------+\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e Field             \u003cspan class=\"p\"\u003e|\u003c/span\u003e Value                                                                                                                                                   \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-------------------+-------------------------+\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e created_at        \u003cspan class=\"p\"\u003e|\u003c/span\u003e 2023-06-28T06:26:10Z                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e description       \u003cspan class=\"p\"\u003e|\u003c/span\u003e                                                                                                                                                         \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e direction         \u003cspan class=\"p\"\u003e|\u003c/span\u003e ingress                                                                                                                                                 \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e ether_type        \u003cspan class=\"p\"\u003e|\u003c/span\u003e IPv4                                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e id                \u003cspan class=\"p\"\u003e|\u003c/span\u003e fe9adfc3-dc42-4680-8ecd-ed5a667e1215                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e location          \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"nv\"\u003ecloud\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e, project.domain_id\u003cspan class=\"o\"\u003e=\u003c/span\u003e, project.domain_name\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;Default\u0026#39;\u003c/span\u003e, project.id\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;6396365541a74b6b8ea8812d1af05e70\u0026#39;\u003c/span\u003e, project.name\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;admin\u0026#39;\u003c/span\u003e, \u003cspan class=\"nv\"\u003eregion_name\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e, \u003cspan class=\"nv\"\u003ezone\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e name              \u003cspan class=\"p\"\u003e|\u003c/span\u003e None                                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e port_range_max    \u003cspan class=\"p\"\u003e|\u003c/span\u003e None                                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e port_range_min    \u003cspan class=\"p\"\u003e|\u003c/span\u003e None                                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e project_id        \u003cspan class=\"p\"\u003e|\u003c/span\u003e 6396365541a74b6b8ea8812d1af05e70                                                                                                                        \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e protocol          \u003cspan class=\"p\"\u003e|\u003c/span\u003e icmp                                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e remote_group_id   \u003cspan class=\"p\"\u003e|\u003c/span\u003e None                                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e remote_ip_prefix  \u003cspan class=\"p\"\u003e|\u003c/span\u003e 0.0.0.0/0                                                                                                                                               \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e revision_number   \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"m\"\u003e0\u003c/span\u003e                                                                                                                                                       \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e security_group_id \u003cspan class=\"p\"\u003e|\u003c/span\u003e f10a3927-5e76-47b4-8691-4169348845ae                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e tags              \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"o\"\u003e[]\u003c/span\u003e                                                                                                                                                      \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e updated_at        \u003cspan class=\"p\"\u003e|\u003c/span\u003e 2023-06-28T06:26:10Z                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-------------------+--------------------------------+\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eopenstack security group rule create --proto tcp --dst-port \u003cspan class=\"m\"\u003e22\u003c/span\u003e default\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eroot@allone:~# openstack security group rule  create --proto tcp --dst-port \u003cspan class=\"m\"\u003e22\u003c/span\u003e default\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-------------------+--------------------------------------+\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e Field             \u003cspan class=\"p\"\u003e|\u003c/span\u003e Value                                                                                                                                                   \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-------------------+--------------------------------------------+\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e created_at        \u003cspan class=\"p\"\u003e|\u003c/span\u003e 2023-06-28T06:26:15Z                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e description       \u003cspan class=\"p\"\u003e|\u003c/span\u003e                                                                                                                                                         \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e direction         \u003cspan class=\"p\"\u003e|\u003c/span\u003e ingress                                                                                                                                                 \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e ether_type        \u003cspan class=\"p\"\u003e|\u003c/span\u003e IPv4                                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e id                \u003cspan class=\"p\"\u003e|\u003c/span\u003e af699cf9-5fc0-45e2-a009-0bb7828e2d1a                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e location          \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"nv\"\u003ecloud\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e, project.domain_id\u003cspan class=\"o\"\u003e=\u003c/span\u003e, project.domain_name\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;Default\u0026#39;\u003c/span\u003e, project.id\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;6396365541a74b6b8ea8812d1af05e70\u0026#39;\u003c/span\u003e, project.name\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;admin\u0026#39;\u003c/span\u003e, \u003cspan class=\"nv\"\u003eregion_name\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e, \u003cspan class=\"nv\"\u003ezone\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e name              \u003cspan class=\"p\"\u003e|\u003c/span\u003e None                                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e port_range_max    \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"m\"\u003e22\u003c/span\u003e                                                                                                                                                      \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e port_range_min    \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"m\"\u003e22\u003c/span\u003e                                                                                                                                                      \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e project_id        \u003cspan class=\"p\"\u003e|\u003c/span\u003e 6396365541a74b6b8ea8812d1af05e70                                                                                                                        \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e protocol          \u003cspan class=\"p\"\u003e|\u003c/span\u003e tcp                                                                                                                                                     \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e remote_group_id   \u003cspan class=\"p\"\u003e|\u003c/span\u003e None                                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e remote_ip_prefix  \u003cspan class=\"p\"\u003e|\u003c/span\u003e 0.0.0.0/0                                                                                                                                               \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e revision_number   \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"m\"\u003e0\u003c/span\u003e                                                                                                                                                       \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e security_group_id \u003cspan class=\"p\"\u003e|\u003c/span\u003e f10a3927-5e76-47b4-8691-4169348845ae                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e tags              \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"o\"\u003e[]\u003c/span\u003e                                                                                                                                                      \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e updated_at        \u003cspan class=\"p\"\u003e|\u003c/span\u003e 2023-06-28T06:26:15Z                                                                                                                                    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+-------------------+-----------------+\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"命令行方式\"\u003e命令行方式\u003c/h1\u003e\n\u003ch2 id=\"生成秘钥\"\u003e生成秘钥\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-keygen -q -N “”\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-q\u003c/code\u003e 选项表示静默模式，即在生成密钥对的过程中不会输出任何提示信息或警告。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-N\u003c/code\u003e 选项后面可以跟一个密码作为参数。该密码将用于保护生成的私钥文件。如果不指定 \u003ccode\u003e-N\u003c/code\u003e 参数，则私钥文件将不受密码保护。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e该命令会在\u003ccode\u003e~/.ssh/\u003c/code\u003e目录中自动生成一对公私钥。默认私钥名称：id_rsa，默认公钥名称：id_rsa.pub\u003c/p\u003e","title":"SSH 登录 OpenStack 实例"},{"content":"解决方案 VirtualBox Ubuntu 无法联网，重启后可以联网但是几分钟后断开网络。笔者的情况是因为 NetworkManager 自动修改了网络配置导致无法联网，具体现象是开机后网卡信息如下：\nuser@allone:~$ ifconfig brq64ff9b38-fa: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 ether ce:29:de:12:35:06 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 enp0s3: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.2.15 netmask 255.255.255.0 broadcast 10.0.2.255 inet6 fe80::2e8f:2be6:3752:dec4 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 08:00:27:18:31:21 txqueuelen 1000 (Ethernet) RX packets 947 bytes 584483 (584.4 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 800 bytes 116611 (116.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 此时网络可以正常使用，经过一两分钟后网络信息如下：\nuser@allone:~$ ifconfig brq64ff9b38-fa: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.2.15 netmask 255.255.255.0 broadcast 10.0.2.255 ether ce:29:de:12:35:06 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 enp0s3: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet6 fe80::2e8f:2be6:3752:dec4 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 08:00:27:18:31:21 txqueuelen 1000 (Ethernet) RX packets 947 bytes 584483 (584.4 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 800 bytes 116611 (116.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 也就是默认虚拟网卡的 IP 地址丢失，而不知名网卡 brq64ff9b38-fa 却拥有了 IP，此时网络不可用。如果有类似情况，可以使用以下方式尝试解决，如果是其他问题。请酌情参考。\n关闭 NetworkManager sudo systemctl stop NetworkManager sudo systemctl disable NetworkManager sudo systemctl mask NetworkManager 开启 systemd-networkd sudo systemctl unmask systemd-networkd.service sudo systemctl enable systemd-networkd.service sudo systemctl start systemd-networkd.service 配置 Netplan 编辑/etc/netplan/01-network-manager-all.yaml\nnetwork: version: 2 renderer: networkd ethernets: enp0s3: dhcp4: yes dhcp6: yes addresses: [10.0.2.15/23] nameservers: addresses: [8.8.8.8, 8.8.4.4] optional: true 其中 enp0s3 为网卡名称，addresses 为网卡对应的 IP，均可以通过 ifconfig 查询。\n以下是一些背景知识，以及问题回溯有兴趣可以继续阅读。\n背景知识 NetworkManager 与 systemd-networked NetworkManager 是一项后端服务，用于控制 Ubuntu 操作系统上的网络接口。NetworkManager 的替代方法是 systemd-networked，这两者只能使用一个。在 Ubuntu 桌面上，NetworkManager 是通过图形用户界面管理网络界面的默认服务。因此，如果要通过 GUI 配置 IP 地址，则应启用 NetworkManager。如果用的是无桌面的 Server 版，就可以使用 systemd-networked 来管理网络。\n这两种方式都可以通过配置 netplan，即/etc/netplan/01-network-manager-all.yaml 来管理网络，但是在 renderer 属性中配置有所不同，使用 NetworkManager 时配置如下：\nnetwork: version: 2 renderer: NetworkManager 而使用 systemd-networked 时，配置如下：\nnetwork: version: 2 renderer: networkd 有时无法联网可能是因为配置与实际使用的网络管理方式不匹配导致的。\n","permalink":"https://lifeislife.cn/posts/virtualbox-ubuntu%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/","summary":"\u003ch1 id=\"解决方案\"\u003e解决方案\u003c/h1\u003e\n\u003cp\u003eVirtualBox Ubuntu 无法联网，重启后可以联网但是几分钟后断开网络。笔者的情况是因为 NetworkManager 自动修改了网络配置导致无法联网，具体现象是开机后网卡信息如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003euser@allone:~$ ifconfig\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ebrq64ff9b38-fa: \u003cspan class=\"nv\"\u003eflags\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt;  mtu \u003cspan class=\"m\"\u003e1500\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        ether ce:29:de:12:35:06  txqueuelen \u003cspan class=\"m\"\u003e1000\u003c/span\u003e  \u003cspan class=\"o\"\u003e(\u003c/span\u003eEthernet\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        RX packets \u003cspan class=\"m\"\u003e0\u003c/span\u003e  bytes \u003cspan class=\"m\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e0.0 B\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        RX errors \u003cspan class=\"m\"\u003e0\u003c/span\u003e  dropped \u003cspan class=\"m\"\u003e0\u003c/span\u003e  overruns \u003cspan class=\"m\"\u003e0\u003c/span\u003e  frame \u003cspan class=\"m\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        TX packets \u003cspan class=\"m\"\u003e0\u003c/span\u003e  bytes \u003cspan class=\"m\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e0.0 B\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        TX errors \u003cspan class=\"m\"\u003e0\u003c/span\u003e  dropped \u003cspan class=\"m\"\u003e0\u003c/span\u003e overruns \u003cspan class=\"m\"\u003e0\u003c/span\u003e  carrier \u003cspan class=\"m\"\u003e0\u003c/span\u003e  collisions \u003cspan class=\"m\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eenp0s3: \u003cspan class=\"nv\"\u003eflags\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt;  mtu \u003cspan class=\"m\"\u003e1500\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        inet6 fe80::2e8f:2be6:3752:dec4  prefixlen \u003cspan class=\"m\"\u003e64\u003c/span\u003e  scopeid 0x20\u0026lt;link\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        ether 08:00:27:18:31:21  txqueuelen \u003cspan class=\"m\"\u003e1000\u003c/span\u003e  \u003cspan class=\"o\"\u003e(\u003c/span\u003eEthernet\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        RX packets \u003cspan class=\"m\"\u003e947\u003c/span\u003e  bytes \u003cspan class=\"m\"\u003e584483\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e584.4 KB\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        RX errors \u003cspan class=\"m\"\u003e0\u003c/span\u003e  dropped \u003cspan class=\"m\"\u003e0\u003c/span\u003e  overruns \u003cspan class=\"m\"\u003e0\u003c/span\u003e  frame \u003cspan class=\"m\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        TX packets \u003cspan class=\"m\"\u003e800\u003c/span\u003e  bytes \u003cspan class=\"m\"\u003e116611\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e116.6 KB\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        TX errors \u003cspan class=\"m\"\u003e0\u003c/span\u003e  dropped \u003cspan class=\"m\"\u003e0\u003c/span\u003e overruns \u003cspan class=\"m\"\u003e0\u003c/span\u003e  carrier \u003cspan class=\"m\"\u003e0\u003c/span\u003e  collisions \u003cspan class=\"m\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e此时网络可以正常使用，经过一两分钟后网络信息如下：\u003c/p\u003e","title":"VirtualBox Ubuntu 无法联网"},{"content":" 💻 NAT 网络模式 NAT 网络以路由器的 NAT 功能为原理，允许虚拟机通过共享主机的 IP 地址访问互联网，但虚拟机之间不能直接通信。通过端口转发可以实现虚拟机之间的连接。 🔗 桥接网络模式 桥接网络模式通过虚拟交换机连接虚拟机和主机，使得虚拟机可以通过局域网访问互联网，并允许虚拟机之间直接通信。 🔒 内部网络模式 内部网络模式使得虚拟机可以创建一个完全隔离的网络，虚拟机之间可以直接通信，但无法访问互联网或外部网络。 🏠 仅主机网络模式 仅主机网络模式允许虚拟机之间可以通信，并且与主机之间也可以通信，但无法访问互联网或外部网络。 虚拟机 ↔ 虚拟机 虚拟机 → 宿主机 宿主机 → 虚拟机 虚拟机 → 互联网 互联网 → 虚拟机 网络地址转换 NAT × √ × √ × NAT 网络 √ √ × √ × Bridged Adapter 桥接网卡 √ √ √ √ √ ","permalink":"https://lifeislife.cn/posts/virtual-box%E7%9A%84%E4%B8%8D%E5%90%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/","summary":"\u003cul\u003e\n\u003cli\u003e💻 NAT 网络模式\n\u003cul\u003e\n\u003cli\u003eNAT 网络以路由器的 NAT 功能为原理，允许虚拟机通过共享主机的 IP 地址访问互联网，但虚拟机之间不能直接通信。通过端口转发可以实现虚拟机之间的连接。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e🔗 桥接网络模式\n\u003cul\u003e\n\u003cli\u003e桥接网络模式通过虚拟交换机连接虚拟机和主机，使得虚拟机可以通过局域网访问互联网，并允许虚拟机之间直接通信。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e🔒 内部网络模式\n\u003cul\u003e\n\u003cli\u003e内部网络模式使得虚拟机可以创建一个完全隔离的网络，虚拟机之间可以直接通信，但无法访问互联网或外部网络。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e🏠 仅主机网络模式\n\u003cul\u003e\n\u003cli\u003e仅主机网络模式允许虚拟机之间可以通信，并且与主机之间也可以通信，但无法访问互联网或外部网络。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c/th\u003e\n          \u003cth\u003e虚拟机 ↔ 虚拟机\u003c/th\u003e\n          \u003cth\u003e虚拟机 → 宿主机\u003c/th\u003e\n          \u003cth\u003e宿主机 → 虚拟机\u003c/th\u003e\n          \u003cth\u003e虚拟机 → 互联网\u003c/th\u003e\n          \u003cth\u003e互联网 → 虚拟机\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e网络地址转换 NAT\u003c/td\u003e\n          \u003ctd\u003e×\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e×\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e×\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eNAT 网络\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e×\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e×\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eBridged Adapter 桥接网卡\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"Virtual Box 的不同虚拟机网络模式"},{"content":"数据链路层 基本概念 结点：主机，路由器 链路：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。 数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。 帧：链路层的协议数据单元，封装网络层数据报。\n数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。\n数据链路层的功能 功能概述 数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连 接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。\n为网络层提供服务 无确认无连接服务 有确认无连接服务 有确认面向连接服务 链路管理 连接的建立，维持，释放 组帧 差错控制 封装成帧 封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记(帧定界符)，从收到的比特流中识别帧的开始和结束。\n首部和尾部包含许多的控制信息，他们的一个重要作用：帧定界（确定帧的界限）。\n帧同步：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。\n\u003c!DOCTYPE html\u003e Responsive Image 透明传输\n差错控制 传输中的差错都是由噪声引起的。\n全局性，由于线路本身电气特性所产生的随机噪声 局部性，由于外界短暂的原因造成的冲击噪声 差错又分为位错和帧错\n位错，比特位出错，1 变 0,0 变 1 帧错，包括丢失，重复，失序 发现差错的帧后就将错误值丢弃，如果没有差错控制，将会浪费大量资源，因为传输过程中一直传输了错误的信息。\n差错控制\n检错编码 奇偶校验码 循环冗余 CRC 纠错编码 海明码 这里提到的编码和物理层的编码与调制不同，物理层的编码针对单个比特，解决传输同步问题。这里的编码针对的是一组比特，通过冗余码的技术检测传输中是否出错。\n奇偶校验码 奇校验码：在信息元前加上 1 位后使得 1 的个数为奇数个 偶检验码：在信息元前加上 1 位后使得 1 的个数为偶数个\n该检测方式只能检测出奇数个的位错，检错能力为 50%\n如果一个字符S的ASCI编码从低到高依次为1100101，采用奇校验，在下述收到的传输后字符中，哪种错误不能检测？ A.11000011B.11001010 C.11001100 D.11010011 答：因为采用奇校验，所以在首位加上一个1使得所有1个数为奇数变成11100101，ABC选项中1的个数都是偶数个，明显发生了变化，所以能检测出错误，但是D选项的1也是奇数个，将无法判断是否出现差错。 CRC 循环冗余码 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 链路层的两种信道 局域网、广域网 数据链路层的设备 流量控制与可靠传输 单帧滑动窗口与停止等待协议 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image SR 选择重传协议 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 滑动窗口最大值 \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","summary":"\u003ch2 id=\"数据链路层\"\u003e数据链路层\u003c/h2\u003e\n\u003ch5 id=\"基本概念\"\u003e基本概念\u003c/h5\u003e\n\u003cp\u003e\u003cstrong\u003e结点\u003c/strong\u003e：主机，路由器\n\u003cstrong\u003e链路\u003c/strong\u003e：网络中两个结点之间的\u003ccode\u003e物理通道\u003c/code\u003e，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。\n\u003cstrong\u003e数据链路\u003c/strong\u003e：网络中两个结点之间的\u003ccode\u003e逻辑通道\u003c/code\u003e，把实现控制数据传输\u003ccode\u003e协议\u003c/code\u003e的硬件和软件加到链路上就构成数据链路。\n\u003cstrong\u003e帧\u003c/strong\u003e：链路层的协议数据单元，封装网络层数据报。\u003c/p\u003e","title":"计算机网络 - 数据链路层"},{"content":"确认网卡信息 lsusb 得到 USB 设备信息\nBus 001 Device 013: ID 0bda:a192 Realtek Semiconductor Corp. Disk 安装网卡驱动 根据设备 ID，用关键词网上搜素一下相关驱动，得到有这个驱动可用：\nsudo apt update sudo apt install build-essential git dkms git clone https://gitee.com/BrightXu/rtl8192fu.git cd rtl8192fu make -j$(nproc) sudo make install sudo modprobe 8192fu 查看是否安装成功\nusb-devices 如果有 Driver=rtl8192fu 字段说明安装成功。如果桌面右上角无线连接图标可用，说明可以使用无线网络了。如果不可用继续往下看。\n修改设备模式 如果使用lsusb命令查看设备，发现设备末尾依然是 Disk 模式，说明这个设备是磁盘设备，还不能当做网络适配器使用，需要修改其模式。\nsudo apt-get install -y usb-modeswitch sudo vim /lib/udev/rules.d/40-usb_modeswitch.rules 在最后 LABEL 之前加上\n# Realtek 8192F Wifi AC USB ATTR{idVendor}==\u0026#34;0bda\u0026#34;, ATTR{idProduct}==\u0026#34;a192\u0026#34;, RUN+=\u0026#34;/usr/sbin/usb_modeswitch -K -v 0bda -p a192\u0026#34; LABEL=\u0026#34;modeswitch_rules_end\u0026#34; sudo usb_modeswitch -KW -v 0bda -p a192 关闭安全启动 安全启动模式下无法使用第三方的驱动，所以需要在开机时进入 BIOS 将安全启动关闭，每个主板不一样，自行搜索。\n参考 linux 系统下 usb 网卡的驱动安装_linux usb 网卡-CSDN 博客\n为 ubuntu 22.04 系统安装水星 realtek 5g wifi 驱动 - 郭华伟的博客\nubuntu 18.04 usb 无线网卡无法使用\u0026ndash;ID 0bda:a192 Realtek Semiconductor Corp._放羊 Wa 的博客-CSDN 博客\n","permalink":"https://lifeislife.cn/posts/ubuntu-22-04-%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%B0%B4%E6%98%9F-wifi-%E9%A9%B1%E5%8A%A8mercury-mw310uh/","summary":"\u003ch1 id=\"确认网卡信息\"\u003e确认网卡信息\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003elsusb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e得到 USB 设备信息\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e Bus \u003cspan class=\"m\"\u003e001\u003c/span\u003e Device 013: ID 0bda:a192 Realtek Semiconductor Corp. Disk\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"安装网卡驱动\"\u003e安装网卡驱动\u003c/h1\u003e\n\u003cp\u003e根据设备 ID，用关键词网上搜素一下相关驱动，得到有这个驱动可用：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install build-essential git dkms\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit clone https://gitee.com/BrightXu/rtl8192fu.git\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e rtl8192fu\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emake -j\u003cspan class=\"k\"\u003e$(\u003c/span\u003enproc\u003cspan class=\"k\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo make install\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo modprobe 8192fu\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e查看是否安装成功\u003c/p\u003e","title":"Ubuntu 22.04 系统安装水星 wifi 驱动 Mercury MW310UH"},{"content":"云计算服务类型 传统架构=\u0026gt;Iaas=\u0026gt;Paas=\u0026gt;Saas\n自己烧饭=\u0026gt; 叮咚买菜=\u0026gt; 美团外卖=\u0026gt; 餐厅吃饭\n\u003c!DOCTYPE html\u003e Responsive Image 云计算部署形式以及应用 类型 描述 优点 缺点 私有云 利用已有设备自我构建，云端资源只给内部人员使用。 安全性高 维护成本高 社区云、行业云 为特定行业构建共享基础设施的云。 有一套用户体系 维护成本高 公有云 构建大型基础设施云出租给公众。 用户来说成本低，服务多 安全性低 混合云 两种或者两种以上的云组成的云服务 敏捷，灵活，降低成本 兼容性问题 应用 存储云、医疗云、教育云、企业云、金融云、游戏云、桌面云\n关键技术 虚拟化 \u003c!DOCTYPE html\u003e Responsive Image 分布式存储 将数据存储在不同的物理设备中。这种模式不仅摆脱了硬件设备的限制，同时扩展性更好，能够快速响应用户需求的变化（整合存储资源提供动态可伸缩资源池的分布式存储技术)\n数据中心联网 虚拟机之间需要实时同步大量的数据，产生大量东西流量。\n\u003c!DOCTYPE html\u003e Responsive Image 并行编程 在并行编程模式下，并发处理、容错、数据分布、负载均衡等细节都被抽象到一个函数库中，通过统一接口，用户大尺度的计算任务被自动并发和分布执行，即将一个任务自动分成多个子任务，并行地处理海量数据。\n\u003c!DOCTYPE html\u003e Responsive Image 体系结构 云计算平台体系结构由用户界面、服务目录、管理系统、部署工具、监控和服务器集群组成。\n自动化部署 对云资源进行自动化部署指的是基于脚本调节的基础上实现不同厂商对于设备工具的自动配置，用以减少人机交互比例、提高应变效率，避免超负荷人工操作等现象的发生，最终推进智能部署进程。\n\u003c!DOCTYPE html\u003e Responsive Image 云服务提供商 亚马逊云、腾讯云、阿里云、百度云、华为云\n技术架构：开源（Xen,KVM），Vmware，微软 hyper-v，阿里飞天 Apsara\n开源云管理平台：OpenStack\n虚拟化简介 虚拟化：一种计算机资源管理技术，将各种 T 实体资源抽象、转换成另一种形式的技术都是虚拟化。 作用：通过该技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。\n从行业数据互相关联的角度来说，云计算是极度依赖虚拟化的。但虚拟化并非云计算，云计算也并非虚拟化。虚拟化只是云计算的核心技术，但并非云计算的核心关注点。\n云计算是一种服务。虚拟化是云计算的技术基础。\n虚拟化相关的几个概念 Guest OS:运行在虚拟机之上的 OS Guest Machine:虚拟出来的虚拟机 VMM:虚拟机监控器，即虚拟化层 (Virtual Machine Monitor,VMM) Host OS:运行在物理机之上的 OS Host Machine:物理机\n\u003c!DOCTYPE html\u003e Responsive Image 虚拟化类型 虚拟化类型 描述 特点 案例 寄居虚拟化（Type2） 在主机（宿主）操作系统上安装和运行虚拟化程序 - 简单、易于实现。\n- 安装和运行应用程序依赖于主机操作系统对设备的支持。\n- 有两层 OS，管理开销较大，性能损耗大。\n- 虚拟机对各种物理设备 (cpu、内存、硬盘等) 的调用，都通过虚拟化层和宿主机的 OS 一起协调才能完成。 - Vmware\n- VirturalBox\n裸金属虚拟化 (Type1) 直接将 VMM 安装在硬件设备上，VMM 在这种模式下又叫做 Hypervisor，虚拟机有指令要执行时，Hypervisors 会接管该指令，模拟相应的操作。 - 不依赖于操作系统。\n- 支持多种操作系统，多种应用。\n- 依赖虚拟层内核和服务器控制台进行管理。\n- 需要对虚拟层的内核进行开发（难度大）。 - VMware ESX\n- Xen\n- 华为 FusionSphere\n混合虚拟化 在一个现有的正常操作系统下安装一个内核模块，内核拥有虚拟化能力。(相当于寄居与裸金属的混合) - 相对于寄居虚拟化架构，性能高。\n- 相对于裸金属虚拟化架构，不需要开发内核。\n- 可支持多种操作系统。\n- 需底层硬件支持虚拟化扩展功能。 - KVM 寄居虚拟化（Type2）\n\u003c!DOCTYPE html\u003e Responsive Image 裸金属虚拟化 (Type1)\n\u003c!DOCTYPE html\u003e Responsive Image 混合虚拟化\n\u003c!DOCTYPE html\u003e Responsive Image 虚拟化层架构 架构 描述 特点 典型 全虚拟化 即所抽象的 VM 具有完全的物理特性，虚拟化层负责捕获 CPU 指令，为指令访问硬件充当媒介。 - OS 无需修改。\n- 速度和功能都非常不错，使用非常简单。\n- 移植性好。 - VMware\n- KVM\n- Virtualbox\n- Virtual PC\n半虚拟化 起初是为了解决全虚拟化效率不高的困难，它需要修改 OS，工作效率相对全虚拟化要高很多。Hypervisor 直接安装在物理机上，多个虚拟机在 Hypervisor 上运行。Hypervisor 实现方式一般是一个特殊定制的 Linux 系统。 - 架构更精简。\n- 在整体速度上有一定的优势。\n- 需要对 OS 进行修改，在用户体验方面比较麻烦。 - Xen\n- VMWare ESXi\n- 微软 Hyper-V\n硬件辅助虚拟化 硬件辅助虚拟化是随着虚拟化技术的应用越来越广泛 lntl、AMD 等硬件厂商通过对硬件的改造来支持虚拟化技术。\n常用于优化全虚拟化和半虚拟化产品，像 VMware Workstation，它虽然属于全虚拟化，但它在 6.0 版本中引入了硬件辅助虚拟化技术，比如 Intel 的 VT-x 和 AMD 的 AMD-V。主流全虚拟化和半虚拟化产品都支持硬件辅助虚拟化。(VirtualBox,KVM,Xen 等)\n辅助产品 - VT-x\n- AMD-V\n全虚拟化\n\u003c!DOCTYPE html\u003e Responsive Image 半虚拟化\n\u003c!DOCTYPE html\u003e Responsive Image 全虚拟化代表 KVM 和半虚拟化代表 Xen 架构对比 架构 描述 对比 示意图 全虚拟化：KVM KVM(Kernel\u0026ndash;Based Virtual Machines) 是一个基于 Linux 内核的虚拟化技术，可以直接将 Linux 内核转换为 Hypervisor。.从而使得 Linuxp 内核能够直接管理虚拟机，直接调用 Linux 内核中的内存管理、进程管理子系统来管理虚拟机。 - 支持全虚拟化\n- 内置在内核中\n- 便于版本安装、升级、维护，性能高\n总结：KVM 平台架构侧重性能 \u003c!DOCTYPE html\u003e Responsive Image 半虚拟化：Xen Xen:直接把操作系统内核改了，把 OS 改成一个轻量级 Hypervisor1 在里面运行了一个管理所有资源作资源调度的 Domain0。\n组成：由 Xen Hypervisor(虚拟化层)、Domin0(管理主机)、Domin U(用户虚\n拟机)\n- 支持全虚拟化、半虚拟化\n- 需要对内核修改\n- 更新版本，Xen 需要重新编译整个内核隔离性好\n总结：Xen 平台架构侧重安全性 \u003c!DOCTYPE html\u003e Responsive Image 容器 容器：包装或装载物品的贮存器，利用一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任一 Liux 或 Windows 机器上，也可以实现虚拟化。相互之间不会有任何接口，实现 App 与操作系统的解耦。\n\u003c!DOCTYPE html\u003e Responsive Image 主流容器技术 定义：Docker) 属于 Liux 容器的一种封装，提供简单易用的容器使用接口，他是目前最流行的 Linux 容器解决方案。 作用：将应用程序与该程序的依赖，打包在一个文件里。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。\n组成：客户端 (Docker Client)、守护进程 (Docker Daemon)、镜像（Docker Image)、容器 (DockerContainer)、仓库（Docker Registry)\n\u003c!DOCTYPE html\u003e Responsive Image 容器和虚拟化的区别 虚拟化 容器 隔离性强，有独立的 GUEST OS 共享内核和 OS，隔离性弱 虚拟化性能差 (\u0026gt;15%) 计算/存储无损耗，无 Guest0S 内存开销（200M) 虚拟机镜像庞大（十几 G 几十 G),且实例化时不能共享 Docker 容器镜象 200300M，且公共基础镜象实例化时\n可以共享 虚拟机镜象缺乏统一标准 Docker 提供了容器应用镜象事实标准，OCI 推动进一步标\n准化 虚拟机创建慢 (\u0026gt;2 分钟) 秒级创建 (\u0026lt;10s)\n相当于建立索引 虚拟机启动慢 (\u0026gt;30s) 读文件逐个加载 秒级 (\u0026lt;1s，不含应用本身启动) 资源虚拟化粒度低，单机 10~100 虚拟机 单机支持 1000+ 容器\n密度很高，适合大规模的部署 计算虚拟化 从服务器组建角度来看，计算虚拟化可分为：\nCPU 虚拟化：保障 CPU 资源的合理调度以及 VM 上的指令能够正常高效的执行。 内存虚拟化：保障内存空间的合理分配、管理，隔离，以及高效可靠地使用。 I/O 虚拟化：保障 VM 的 1O 隔离与正常高效的执行。 常见的计算服务架构有：\nOpenStack Nova 阿里云 ECS 腾讯云 CVM Nova OpenStack 是开源的云平台，通过不同的组件提供计算、存储、网络、数据库等多种云服务。其中计算服务由 Nova 组件提供，通过 nova-API 与其他组件通信，通过 nova-computex 对接不同的虚拟层提供计算虚拟化服务。\n\u003c!DOCTYPE html\u003e Responsive Image 创建实例流程：创建实例请求 nova-api，会唤醒 nova-database，请求刷新数据库。将请求给队列组件，nova-scheduler 从队列中取出请求，请求运行相对应的虚拟机。要运行不同的虚拟机，需要不同的平台支持（KVM，Xen,VMware）。虚拟机不能直接与数据库直接交互，需要通过 nova-conductor 转发。\nECS 云服务器 ECS(Elastic Compute Service) 是阿里云提供的基于 KVM 虚拟化的弹性计算服务，建立在阿里云飞天 (Apsara) 分布式操作系统上。 请求的主要调用流程为：OpenAPI、.业务层、控制系统、宿主机服务。\n\u003c!DOCTYPE html\u003e Responsive Image CVM 云服务器 CVM(Cloud Virtual Machine)) 是腾讯提供的基于 KVM 虚拟化的弹性计算服务，建立在腾讯云分布式资源管理调度系统 VStation.上。 请求的主要调用流程为：API Server、.VStation、服务器集群。\n\u003c!DOCTYPE html\u003e Responsive Image CPU 虚拟化 在物理机（宿主机）中通过线程或进程这种纯软件方式模拟出假的 CPU，通过 CPU 虚拟化就可以将一个物理 CPU 发给不同的虚拟机使用。\n虚拟出来的每颗 CPU 实际上就是一个线程或者进程，因此物理 CPU 核数要大于虚拟 CPU 总核数。\nCPU QoS(Quality of Service) 服务质量 QoS 用来控制虚拟机使用 CPU 资源量的大小。 CPU 资源限额：控制虚拟机占用物理资源使用的上限。 CPU 资源份额：定义了多台虚拟机在竞争物理 CPU 资源时，需按比例分配计算资源。 CPU 预留资源：定义了多台虚拟机在竞争物理 CPU 时，每台虚拟机最低分配的计算资源。\nNUMA NUMA(Non Uniform Memory Access Architecture) 非统一内存访问体系结构，提高物理服务器性能的一种技术。\n将物理服务器的 CPU 和内存资源分到多个 node 上，node 内的内存访问效率最高。\nNUMA 保证了一个 VM 上的 VCPU 尽量分配到同一个 node 中的物理 CPU 上，如果一台 VM 的 VCPU 跨 node 访问内存的话，访问的延时肯定增加。\n内存虚拟化 \u003c!DOCTYPE html\u003e Responsive Image 虚拟化类型 全虚拟化 半虚拟化 硬件辅助虚拟化 为每个 VM 维护一个影子页表记录虚拟化内存与物理内存的映射关系，VMM 将影子页表提交给 CPU 的内存管理单元 MMU 进行地址转换，VM 的页表无需改动。 采用页表写入法，为每个 VM 创建\n一个页表并向虚拟化层注册。VM\n运行过程中 VMM 不断管理和维护\n该页表，确保 VM 能直接访问到合\n适的地址。 EPT/NPT 是内存管理单元 MMU 的\n扩展，CPU 硬件一个特性，通过\n硬件方式实现 GuestOS 物理内存地\n址到主机物理内存地址的转换，系\n统开销更低，性能更高。 内存复用技术 内存复用是指在服务器物理内存一定的情况下，通过综合运用内存复用技术对内存进行分时复用。 内存复用技术有：\n内存气泡：虚拟化层将较空闲 VM 内存，分配给内存使用较高的虚拟机。内存的回收和分配由虚拟化层实现，虚拟机上的应用无感知，提高物理内存利用率。（虚拟机分配的内存不超过物理机总内存） 内存交换：将外部存储虚拟成内存给 VM 使用，将 VM 上长时间未访问的数据存放到外部存储上，建立映射关系。VM 再次访问这些数据是通过映射在与内存上的数据进行交换。 内存共享：VM 只对共用的内存（共享数据内容为零的内存页）做只读操作，有写操作时运用写时复制 (VM 有写操作时，开辟另一空间，并修改映射) IO 虚拟化 全虚拟化 半虚拟化 Pass-Thorugh（直通） 硬件辅助虚拟化 通过软件模拟的形式模拟 O 设备，不需要硬件支持，对虚拟机的操作系统也不需要修改（因为模拟的都是一个常见的硬件网卡，如 IntelE1000，主流操作系统一般都自带这些驱动，因此默认情下虚拟机不需要再安装驱动。缺点就是性能差。 由 Hypervisor 提供资源调用接口。VM 通过特定的调用接口与 Hypervisor 通信，完成获取完整/O 资源控制操作。(需修改内核及驱动程序，存在移植性和适用性问题，导致其使用受限。) Hypervisor] 直接把硬件 PCI 设备分配给虚拟独占使用，性能挡当然好啦。但是浪遗硬件设备，且配置复杂，首先需要在 hypervisor 指定通过 PClid 方式分配给指定的虚拟机，然后虚拟机再识别到设备再安装驱动来使用。 通过硬件的辅助可以让虚拟机直接访问物理设备，而不需要通过 VMM。最常用的就是 SR-lOV(Single Root I/OVirtualizmion)单根 I/O 虚拟化标准，该技术可以直接虚拟出 128-512 网卡，可以让虚拟机都拿到一块独立的网卡，直接使用/O 资源。 常见集群策略 集群简介 集群是一种计算机系统，通过一组计算机或服务器的软硬件连接起来高度紧密地协作完成计算工作。在客户端看来为其提供服务的只有一台设备，实际上它是一群设备的集合，只不过这些设备提供的服务一样。\n集群系统中单个计算机通常称为节点，通过局域网连接，利用多个计算机进行并行计算获得很高计算速度，也可以用多个计算机做备份提高可靠性。（并行计算技术）\nHA 策略 HA(High Availability) 高可用性，一种让服务中断尽可能少的技术。将多台主机组建成一个故障转移集群，运行在集群上的服务（或 VM) 不会因为单台主机的故障而停止。\n提升故障恢复速度，降低业务中断时间、保障业务连续性、实现一定的系统自维护。\nDRS 策略 DRS(Dynamic resource scheduling) 动态资源调度，根据对资源池资源负载的动态监控，合理触发均匀分配规侧，实现资源池中的物理服务器之间重新分配资源，达到负载均衡、消峰填谷。\n当物理服务器上负载过大时，通过 DRS 将虚拟机迁移到其他负载较轻的物理服务器上。当虚拟机遇到负载增大时，DRS 将为资源池中的物理服务器重新分配虚拟机可使用资源，在多个虚拟机之间智能地分配可用资源。\nDPM 策略 DPM（Distributed power management) 分布式电源管理，用于业务较轻时，把虚拟机动态“集中”到集群中的少部分主机上，将其他主机待机，节省电力消耗，等业务量较大时，再重新唤醒之前待机的主机。\n执行 DPM 策略的前提是开启 DRS 策略，即集群必须先设置好 DRS 策略，才能设置 DPM 策略。\n存储虚拟化 存储类型 常用的存储类型有：\n本地磁盘 DAS 简介 云计算虚拟化场景下的本地磁盘是指使用服务器本地的磁盘资源，经过 RAD(磁盘阵列) 化后提供给虚拟化平台进行使用。 DAS(Direct-Attached Storage) 直连式存储：一个存储设备与使用存储空间的服务器\n直接相连的架构。DAS 为服务器提供块级的存储服务。 优点 - 使用方便\n- 无共享框架\n- 多个磁盘合并成一个逻辑磁盘，满足海量存储的需求\n- 可实现应用数据和操作系统的分离\n- 能提高存取性能\n- 实施简单\n缺点 - 对跨服务器来说没有备份、冗余机制 - 服务器发生故障，数据不可访问\n- 传输距离短 NAS SAN 简介 NAS(Network Attached Storage) 网络附加存储：将分布、独立的数据进行整合，集\n中化管理，以便对不同主机和应用服务器进行访问的技术。\nNAS 将存储设备连接到现有的网络上来提供数据和文件服务。 SAN(Storage Area Networks) 存储区域网络：是一种高速的、专门用于存储操作的网\n络，通常独立于计算机局域网。\n提供在主机和存储系统之间数据传输，网络内部数据传输的速率快。\n常见架构有 FC SAN、IP SAN。 优点 - 支持快照等高级特性\n- 集中存储\n- 提供安全集成环境（用户认证和授权)\n- 存储容量利用率高\n- 兼容性高\n- 传输距离远\n- 高带宽\n- 主机、存储设备可以独立扩展\n缺点 - 传输速率低\n- 前期安装和设备成本高 - 成本高、复杂 云存储基本概念 存储资源：表示实际的物理存储设备，例如 DAS(直连存储)、NAS(网络附加存储)、SA(存储区域网络) 等。\n存储设备：表示存储资源中的管理单元，例如本地磁盘、LUN(逻辑单元号)、Storage 存储池、NAS 共享目录等。\n数据存储：表示虚拟化平台中可管理的存储逻辑单元，承载了虚拟机业务，创建磁盘。\n\u003c!DOCTYPE html\u003e Responsive Image 创建虚拟存储的流程 在主机软件界面添加存储资源 (SAN、DAS 等)，对主机的启动进行配置。 主机关联存储资源后，进行扫描存储设备（本地磁盘、LUN 等），将具体的设备扫描到主机上。 主机在选择存储设备，进行数据存储的添加，并进行虚拟化。 最后对虚拟化好的数据存储进行创建卷等操作。 \u003c!DOCTYPE html\u003e Responsive Image 存储模式 非虚拟化存储 虚拟化存储 裸设备映射 传统的存储模式，就是把磁盘进行分区，分割成不同的逻辑卷，每一个逻辑卷可以给到虚拟机进行使用。 将不同的存储设备、磁盘进行格式化，格式化的目的是屏蔽底层存储设备的能力、接口\n协议等差异性，将各种存储资源转化为统一管理的数据存储资源。 将磁盘直接给到虚拟机使用，让虚拟机直接处理调用存储的命令（直接访问磁盘）中间虚拟化层不再对其进行任何干预（卷都不需要创建） 特点 - 性能好 (不再有中间的虚拟化层，VM 读写直接在磁盘上)、速度快、效率高。\n- 支持的存储功能少（不支持快照、精简配置等）\n- 支持多种存储功能（快照、精简磁盘、磁盘扩容、存储热迁移等)。\n- 性能不高（没有非虚拟化存储好）\n速度快（三种模式中最快）、性能好。\n支持的存储功能少（不支持快照、精简配置等），仅支持部分操作系统的虚拟机使用、数据存储只能整块当做裸设备映射的磁盘使用，不可分割。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 存储虚拟化方法 基于主机的存储虚拟化 若仅是单个主机服务器（或单个集群）访问多个磁盘阵列，可采用基于主机的存储虚拟化：虚拟化的工作通过特定的软件在主机服务器上完成，经过虚拟化的存储空间可以跨越多个异构的磁盘阵列。\n特点：\n优点是稳定性，以及对异构存储系统的开放性。 软件运行于主机上。 从与主机连接的存储上创建虚拟卷。 \u003c!DOCTYPE html\u003e Responsive Image 基于存储设备的虚拟化 若多个主机服务器需要访问同一个磁盘阵列时，可采用基于存储设备虚拟化。虚拟化的工作在阵列控制器上完成，将一个阵列上的存储容量划分多个存储空间 (LUN),供不同的主机系统访问。主要用在同一存储设备内部，进行数据保护和数据迁移。\n优点是与主机无关，不占用主机资源，数据管理功能丰富。 软件运行于存储设备中专门的嵌入式系统上。 从与 SAN 连接的存储上创建虚拟卷。 \u003c!DOCTYPE html\u003e Responsive Image 基于网络的存储虚拟化 通过在存储区域网 (SAN) 中添加虚似化引擎实现的，主要用于异构存储系统的整合和统数据管理。\n特点：\n优点是与主机无关，不占用主机资源； 支持异构主机、异构存储设备； 能使不同存储设备的数据管理功能统一，统一管理平台，可扩展性好。 \u003c!DOCTYPE html\u003e Responsive Image 存储虚拟化的功能 存储虚拟化可以提高硬件资源的使用效率，简化系统管理的复杂度，增强云存储平台的可靠性。可以通过以下几种技术实现：\n精简磁盘和空间回收 精简磁盘和空间回收用于提高存储资源的使用效率、减小虚拟机未使用空间在主机上占用率过大的问题。\n用户用多少分配多少空间（自动分配）\n空间回收可以将用户删除的数据空间释放到数据存储。\n\u003c!DOCTYPE html\u003e Responsive Image 快照 指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点) 的映像。 快照可以是其所表示的数据的一个副本，可以是数据的一个复制品。 快照的作用主要是能够进行在线数据备份恢复。 为用户提供了数据访问通道 特点\n记录了虚拟机在某一时间点的内容和状。 恢复虚拟机快照可以使虚拟机多次快速恢复到某一时间点。 快照包含磁盘内容、虚拟机配置信息、内存数据。 多次快照之间保存差量数据，节约存储空间。 快照方式介绍 创建快照时会生成一个新的差分卷，虚拟机会挂载这个差分卷作为磁盘文件。\nROW 写时重定向 COW 写时拷贝 \u003c!DOCTYPE html\u003e Responsive Image 快照链介绍 对虚拟机进行多次的快照操作，这些多次的快照操作形成快照链。\n虚拟机卷始终挂载在快照链的最末端。\n\u003c!DOCTYPE html\u003e Responsive Image 链接克隆 将源卷和差分卷组合映射为一个链接克隆卷，给虚拟机使用。一个链接克隆需要和原始虚拟机共享同一虚拟磁盘文件。 采用共享磁盘文件缩短了创建克隆虚拟机的时间，还节省了物理磁盘空间。 通过链接克隆，可以轻松的为不同的任务创建一个独立的虚拟机。 \u003c!DOCTYPE html\u003e Responsive Image 虚拟磁盘文件迁移 功能：\n将虚拟机的磁盘从一个数据存储迁移到另一个数据存储。可以将虚拟机的所有磁盘整体迁移，也可以单个磁盘分别迁移。 虚拟机的快照可以一起迁移，虚拟机开启或者关闭时都可以迁移。 特点：\n\u003c!DOCTYPE html\u003e Responsive Image 网络虚拟化 虚拟化是对所有 T 资源的虚拟化，提高物理硬件的灵活性及利用效率。云计算中的计算和存储资源分别由计算虚拟化和存储虚拟化提供，而网络作为 T 的重要资源也有相应的虚拟化技术，网络资源由网络虚拟化提供。\n网络是由各种设备组成，有传统的物理网络，还有运行在服务器上看不到的虚拟网络。如何呈现和管理它们将是网络虚拟化的首要目标。\n将物理网络虚拟出多个相互隔离的虚拟网络（逻辑网络），从而使得不同用户之间使用独立的网络资源，从而提高网络资源利用率，实现弹性的网络。\nVLAN 就是一种网络虚拟化，在原有网络基础上通过 VLAN Tag:划分出多个广播域。\n网络虚拟化保障我们创建出来的虚拟机可以正常 通信、访问网络。\n节省物理主机的网卡设备资源，并且可以提供应用的虚拟网络所需的 L2 一 L7 层网络服务。\n网络虚拟化软件提供逻辑上的交换机和路由器 (L2-L3),逻辑负载均衡器，逻辑防火墙 (L4-L7) 等，且可以以任何形式进行组装，从而为虚拟机提供一个完整的 L2-L7 层的虚拟网络拓扑。\n物理网络包含的设备 路由器：工作在网络层，连接两个不同的网络。\n二层交换机：工作在数据链路层，转发数据。\n三层交换机：工作在网络层，结合了部分路由和交换机的功能。\n服务器网卡：提供通信服务。\n虚拟化中的网络架构 网卡虚拟化方法有：\n软件网卡虚拟化\n主要通过软件控制各个虚拟机共享同一块物理网卡实现。软件虚拟出来的网卡可以有单独的 MAC 地址、IP 地址。 所有虚拟机的虚拟网卡通过虚拟交换机以及物理网卡连接至物理交换机。虚拟交换机负责将虚拟机上的数据报文从物理网口转发出去。 \u003c!DOCTYPE html\u003e Responsive Image 硬件网卡虚拟化\n主要用到的技术是单根 I/O 虚拟化 (Single Root/O Virtulization,SR-lOV),就是 I/O 直通技术，通过硬件的辅助可以让虚拟机直接访问物理设备，而不需要通过 VMM。该技术可以直接虚拟出 128-512 网卡，可以让虚拟机都拿到一块独立的网卡，直接使用/O 资源。SR-OV 能够让网络传输绕过软件模拟层，直接分配到虚拟机，这样就降低了软件模拟层中的/○ 开销。 交换机虚拟化：\nOVS(Open vSwitch) 开放虚拟化软件交换机，是一款基于软件实现的开源虚拟以太网交换机，使用开源 Apache2.0 许可协议，主要用于虚拟机 VM 环境。与众多开源的虚拟化平台相整合（支持 Xen、KVM 及 VirtualBox 多种虚拟化技术），主要有两个作用：传递虚拟机之间的流量，实现虚拟机和外界网络的通信。 \u003c!DOCTYPE html\u003e Responsive Image 虚拟化中数据的转发路径 相同端口组不同服务器内的虚拟机通讯需要经过物理网络。（黑线） 相同端口组相同服务器内的虚拟机通讯不需要经过物理网络。（红线） 不同端口组相同服务器的虚拟机通讯需要经过物理网络。（黄色） \u003c!DOCTYPE html\u003e Responsive Image 链路虚拟化 VPC(Virtual Port Channel) 虚链路聚合，是最常见的二层虚拟化技术。\n链路聚合将多个物理端口捆绑在一起，虚拟成为一个逻辑端口。但传统链路聚合不能跨设备，VPC 很好解决了这个问题，既可以跨设备，又可以增加链路带宽、实现链路层的高可用性。\n隧道协议 (Tunneling Protocol)：指通过隧道协议使多个不同协议的网络实现互联。使用隧道传递的数据可以是不同协议的数据帧或包。隧道可以将数据流强制送到特定的地址，并隐藏中间节点的网络地址，还可根据需要，提供对数据加密的功能。\nGRE(Generic Routing Encapsulation) 通用路由封装。 IPsec(Internet Protocol Security)Internett 协议安全。 \u003c!DOCTYPE html\u003e Responsive Image 虚拟网络 虚拟网络 (Virtual Network):是由虚拟链路组成的网络。\n虚拟网络节点之间的连接并不使用物理线缆连接，而是依靠特定的虚拟化链路相连。\n典型的虚拟网络包括：\n层叠网络（虚拟二层延伸网络）\n层叠网络 (Overlay Network)：在现有网络的基础上搭建另外一种网络\n层叠网络允许对没有引 P 地址标识的目的主机路由信息。\n层叠网络可以充分利用现有资源，在不增加成本的前提下，提供更多的服务。（比如 ADSL Internet 接入线路就是基于已经存在的 PSTN 网络实现)\n\u003c!DOCTYPE html\u003e Responsive Image 典型技术：\nVXLAN(Virtual eXtensible Local Area Network) 虚拟扩展局域网：很好地解决了现有 VLAN 技术无法满足大二层网络需求的问题。 VXLAN 技术是一种大二层的虚拟网络技术。 原理是引入一个 UDP 格式的外层隧道作为数据链路层，而原有数据报文内容作为隧道净荷加以传输。 VPN 网络\nVPN(Virtual Private Network) 虚拟专用网：是一种常用于连接中、大型企业或团体与团体间的私人网络的通信方法。\n通过公用的网络架构（比如互联网）来传送内联网的信息。 利用已加密的隧道协议来达到保密、终端认证、信息准确性等安全效果。这种技术可以 在不安全的网络上传送可靠的、安全的信息。 \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB/","summary":"\u003ch1 id=\"云计算服务类型\"\u003e云计算服务类型\u003c/h1\u003e\n\u003cp\u003e传统架构=\u0026gt;Iaas=\u0026gt;Paas=\u0026gt;Saas\u003c/p\u003e\n\u003cp\u003e自己烧饭=\u0026gt; 叮咚买菜=\u0026gt; 美团外卖=\u0026gt; 餐厅吃饭\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/09-36-45-b25eafa700db3dce390dab2aeb3af4f9-20230531093640-f17dbe.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/09-36-45-b25eafa700db3dce390dab2aeb3af4f9-20230531093640-f17dbe.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"云计算基础技术汇总"},{"content":"Devstack 部署 OpenStack 试验发现在 Host 为 Ubuntu20.04 和 22.04 上无法顺利安装 VirtualBox，请在 Ubuntu18.04 上安装 VirtualBox。虚拟机镜像版本为 Ubuntu20.04，以下步骤可以稳定复现，OpenStack master（c424a7a299e37004d318107648bb18e157344985）版本。\n总而言之，在 18.04 版本上安装 VirtualBox，在 20.04 版本上安装 OpenStack。\n因为安装 OpenStack 容易破话系统包依赖，如果为了学习建议在虚拟机中安装。\n安装过程中需要下载镜像，请确认机器可以访问外网。\n安装 VirtualBox sudo apt update sudo apt install virtualbox virtualbox-ext-pack 确认 VirtualBox 配置 请确认 VirtualBox 配置如下，VirtualBox 默认配置硬盘为 10G，远远不够用，为了避免后续的麻烦，请确认如下配置：\n磁盘大于 100G\n内存大于 16G\nCPU 大于 4 个\n下载镜像并安装 镜像可以去清华大学开源软件镜像站 | Tsinghua Open Source Mirror下载。\n更新源 sudo mv /etc/apt/sources.list /etc/apt/sources.list.bk \u0026amp;\u0026amp; sudo bash -c \u0026#34;cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/apt/sources.list deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restrcdicted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restrcd \u0026amp;\u0026amp; mkdir .pip \u0026amp;\u0026amp; cd .pipicted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse EOF\u0026#34; 备用源 (以备不时之需) sudo mv /etc/apt/sources.list /etc/apt/sources.list.bk \u0026amp;\u0026amp; sudo bash -c \u0026#34;cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/apt/sources.list deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restrcdicted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restrcd \u0026amp;\u0026amp; mkdir .pip \u0026amp;\u0026amp; cd .pipicted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse EOF\u0026#34; sudo mv /etc/apt/sources.list /etc/apt/sources.list.bk \u0026amp;\u0026amp; sudo bash -c \u0026#34;cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/apt/sources.list deb https://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse EOF\u0026#34; sudo mv /etc/apt/sources.list /etc/apt/sources.list.bk \u0026amp;\u0026amp; sudo bash -c \u0026#34;cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/apt/sources.list deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse EOF\u0026#34; 安装基础包 sudo apt update sudo apt install git sudo apt install aptitude aptitude 用于解决包依赖冲突。\n添加用户 添加 stack 用户\nsudo useradd -s /bin/bash -d /opt/stack -m stack 授予 sudo 权限\necho \u0026#34;stack ALL=(ALL) NOPASSWD: ALL\u0026#34; | sudo tee /etc/sudoers.d/stack 切换到 stack 用户\nsudo su - stack PIP 配置 cd \u0026amp;\u0026amp; mkdir -p .pip \u0026amp;\u0026amp; cd .pip \u0026amp;\u0026amp; bash -c \u0026#34;cat \u0026lt;\u0026lt; EOF \u0026gt; ~/.pip/pip.conf [global] timeout = 6000 index-url = http://mirrors.aliyun.com/pypi/simple/ trusted-host = mirrors.aliyun.com EOF\u0026#34; 仓库下载 git clone https://github.com/openstack/devstack --depth 1 配置 local.conf 只需要修改 HOST_IP，其他的可以不用修改，HOST_IP 为本机 IP 地址，可以使用 ifconfig 查看。如果是虚拟机就是虚拟机的 IP，virtualbox 创建的虚拟机默认为 10.0.2.15。\ncd devstack \u0026amp;\u0026amp; touch local.conf \u0026amp;\u0026amp; bash -c \u0026#34;cat \u0026lt;\u0026lt; EOF \u0026gt; /opt/stack/devstack/local.conf [[local|localrc]] HOST_IP=10.0.2.15 GIT_BASE=http://git.trystack.cn ADMIN_PASSWORD=user DATABASE_PASSWORD=$ADMIN_PASSWORD RABBIT_PASSWORD=$ADMIN_PASSWORD SERVICE_PASSWORD=$ADMIN_PASSWORD EOF\u0026#34; 安装 FORCE=yes ./stack.sh BUG 解决 systemd 包依赖冲突 sudo aptitude install systemd 选择N 再选择Y ModuleNotFoundError: No module named \u0026lsquo;distutils.cmd\u0026rsquo; sudo apt-get install python3.10-distutils # 根据自己的 Python 版本决定，可以 python3.7-distutils python3.8-distutils ....都试一遍 apparmor invalid capability bpf sudo apt install apparmor No tenant network is available for allocation vim /etc/neutron/plugins/ml2/ml2_conf.ini [ml2] type_drivers = flat,vlan,vxlan tenant_network_types = vxlan [ml2_type_vxlan] vni_ranges = 1:1000 unix:/var/run/openvswitch/db.sock: database connection failed (Connection refused) cd /opt/stack/devstack/lib/neutron_plugin vi ovn_agent 116G 跳转到116行 OVS_RUNDIR=$OVS_PREFIX/var/run/openvswitch 修改为OVS_RUNDIR=$OVS_PREFIX/var/run/ovn sudo rm -rf /var/run/ovn VirtualBox 启动报错 : Failed to send host log message Ctrl+F2进入另一个终端 输入：startx进入桌面 AttributeError: module ‘collections‘ has no attribute ‘MutableMapping‘ collections.MutableMapping collections.abc.MutableMapping ModuleNotFoundError: No module named \u0026lsquo;distutils.core\u0026rsquo; sudo apt install python3-pip ERROR: Cannot uninstall \u0026lsquo;simplejson\u0026rsquo;. It is a distutils installed project and thus we cannot sudo pip install --ignore-installed wrapt enum34 simplejson netaddr server certificate verification failed. CAfile: none CRLfile: none git config --global http.sslverify false git config --global https.sslverify false Ubuntu:登录页面验证出错 sudo loginctl unlock-sessions Ubuntu:重装桌面 sudo apt install ubuntu-desktop Ubuntu 登录界面 Authentication Error sudo loginctl unlock-sessions sudo echo \u0026#34;fs.inotify.max_user_watches=524288\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf Ubuntu 无法进入桌面系统，但是可以 SSH 链接 sudo rm -rf /var/lib/apt/lists/* sudo apt-get clean sudo apt-get update sudo apt-get install --reinstall appstream gsettings-desktop-schemas : 破坏：mutter (＜ 3.31.4) 但是 3.28.4-0ubuntu18.04.2 正要被安装解决方案 sudo apt install gsettings-desktop-schemas sudo apt-get install build-essential ","permalink":"https://lifeislife.cn/posts/devstack%E9%83%A8%E7%BD%B2openstack/","summary":"\u003ch1 id=\"devstack-部署-openstack\"\u003eDevstack 部署 OpenStack\u003c/h1\u003e\n\u003cp\u003e试验发现在 Host 为 Ubuntu20.04 和 22.04 上无法顺利安装 VirtualBox，请在 Ubuntu18.04 上安装 VirtualBox。虚拟机镜像版本为 Ubuntu20.04，以下步骤可以稳定复现，OpenStack master（c424a7a299e37004d318107648bb18e157344985）版本。\u003c/p\u003e","title":"Devstack 部署 OpenStack"},{"content":"物理层 基本概念 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层主要任务：确定与传输媒体接口有关的一些特性\n机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。 电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。 功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。 规程特性（过程特性）：定义各条物理线路的工作规程和时序关系 数据通信基础概念 典型的数据通信模型 \u003c!DOCTYPE html\u003e Responsive Image 通信的目的是传送消息。 数据：传送信息的实体，通常是有意义的符号序列。 信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式。\n数字信号：代表消息的参数取值是离散的。 - 模拟信号：代表消息的参数取值是连续的。 信源：产生和发送数据的源头。 信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。\n通信方式 从通信双方信息的交互方式看，可以有三种基本方式：\n单工通信只有一个方向的通信而没有反方向的交互，仅需要一一条信道。 半双工通信通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道。 全双工通信通信双方可以同时发送和接受信息，也需要两条信道。 传输方式 串行传输 速度慢，费用低，适合远距离 并行传输 速度快，费用高，适合近距离 \u003c!DOCTYPE html\u003e Responsive Image 码元 码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有 M 个时（M 大于 2），此时码元为 M 进制码元。 1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表 0 状态，另 - 一种代表 1 状态。在四进制码元中，一个码元就由 2 比特组成。\n\u003c!DOCTYPE html\u003e Responsive Image 速率，波特，带宽 速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示。 传输速率是主机上发出的速率，而传播速率是在信道上的传播速率。两者是不同的概念\n码元传输速率1s传输多少个码元：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数），单位是波特（Baud）。1 波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。 信息传输速率1s传输多少个比特：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特/秒（b/s）。 关系：若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M * n bit/s。\n带宽 (是个理想值)：表示在单位时间内从网络中的某一点到另一 点所能通过的“最高数据率”，常用来表示网络的通信线路所能传输数据的能力。单位是 b/s。\n\u003c!DOCTYPE html\u003e Responsive Image 4 进制表示码元有 4 种波形，只需要 2 位就可以表示 4 种波形，同理 16 进制需要 4 位表示。\n奈氏准则 失真 \u003c!DOCTYPE html\u003e Responsive Image 影响失真程度的因素：\n码元传输速率 信号传输距离 噪声干扰 传输媒体质量 码间串扰 \u003c!DOCTYPE html\u003e Responsive Image 频率太低，会容易受到传输距离，噪声的干扰，从而更容易失真，所以不允许通过 频率太高，不容易区分码元之间的区别\n码间串扰：接收端收到的信号波形失去了码元之间清晰界限的现象。\n奈氏准则 奈氏准则：在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W 是信道带宽，单位是Hz。(只有在奈氏准则和香农定理中的带宽采用Hz)\n理想低通信道下的极限数据传输率 =$2Wlog_2V$(b/s) W:带宽，V：码元的离散电平数目（几种码元）\n1.在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。 2.信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。 3.奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。 4.由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。\n练习：在无噪声的情况下，若某通信链路的带宽为3kHz，采用4个相位，每个相位具有4种振幅的QAM调制技术，则该通信链路的最大数据传输率是多少？ 答：信号有4 x 4=16种变化 最大数据传输率=2 x 3k x4=24kb/s 香农定理 噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，信噪比就很重要。\n信噪比 = 信号的平均功率 / 噪声的平均功率，常记为 S/N，并用分贝（dB）作为度量单位，即： $$dB = 10log_{10}(S/N)$$\n香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。 信道的极限传输速率 = $Wlog_2(1+S/N)$(b/s)\n1.信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 2.对一定的传输带宽和一 - 定的信噪比，信息传输速率的上限就确定了。 3.只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。 4.香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。 5.从香农定理可以看出，若信道带宽 W 或信噪比 S/N 没有上限（不可能），那么信道的极限信息传输速率也就没有上限。\n练习：电话系统的典型参数是信道带宽为3000Hz，信噪比为30dB，则该系统最大数据传输速率是多少？ 答：30dB=10log1o（S/N）则S/N=1000 信道的极限数据传输速率=Wlog2（1+S/N）=3000 x log2（1+1000）\u0026gt;30kb/s 当题目中既给出了码元信息，又给了信噪比信息，就需要用两个公式都算一下，取最小值\n题目：二进制信号在信噪比为127：1的4kHz信道上传输，最大的数据速率可达到多少？ 答： Nice：2 X 4000X log2=8000b/s 香浓：4000 log2（1+127）=28000b/s 编码与调制 基带信号与宽带信号 信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。\n信道上传输的信号\n基带信号 将数字信号 1 和 0 直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。 宽带信号 将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）。 把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道） 在传输距离较近时，计算机网络采用基带传输方式（近距离衰减小，从而信号内容不易发生变化） 在传输距离较远时，计算机网络采用宽带传输方式（远距离衰减大，即使信号变化大也能最后过滤出来基带信号）\n编码与调制 编码：数字数据-》数字信号（数字发送器） 调制：数字数据-》模拟信号（调制器）\n编码：模拟数据-》数字信号（PCM 编码器） 调制：模拟数据-》模拟信号（放大器调制器）\n数字数据-》数字信号 非归零编码（NRZ）（高1低0） 编码容易实现，但没有检错功能，且无法判断一-个码元的开始和结束，以至于收发双方难以保持同步。一个码元内电平不会跳变。 归零编码（RZ） 信号电平在一一个码元之内都要恢复到零的这种编码成编码方式。 反向不归零编码（NRZI） 信号电平翻转表示 0，信号电平不。变表示 1。一个码元内电平不会跳变。 曼彻斯特编码（前高后低1，前低后高为0） 将一个码元分成两个相等的间隔，前一个间隔为低电平后 - 一个间隔为高电平表示码元 1；码元 0 则正好相反。也可以采用相反的规定。该编码的特点是在每\u0026ndash;个码元的中间出现电平跳变，位中间的跳变既作时钟信号（可用于同步），又作数据信号，但它所占的频带宽度是原始的基带宽度的两倍。每一个码元都被调成两个电平，所以数据传输速率只有调制速率的1/2。 差分曼彻斯特编码（同1异0） 常用于局域网传输，其规则是：若码元为 1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为 0，则相反。该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。 4B/5B编码 比特流中插入额外的比特以打破连串的 0 或 1，就是用 5 个比特来编码 4 个比特的数据，之后再传给接收方，因此称为 4B/5B。编码效率为 80%。 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 数字数据-》模拟信号 数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。\n\u003c!DOCTYPE html\u003e Responsive Image 例：某通信链路的波特率是1200Baud，采用4个相位，每个相位有4种振幅的QAM调制技术，则该链路的信息传输速率是多少？ 答：4个相位4种振幅也就是说有16个码元。16个码元也就是16个状态，需要4位来表示。也就是1码元对应4bit。题目中波特率是1200，也就说明1200*4=4800bit/s。 模拟数据-》数字信号 计算机内部处理的是二进制数据，处理的都是数字音频，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现音频数字化）。 最典型的例子就是对音频信号进行编码的脉码调制（PCM），在计算机应用中，能够达到最高保真水平的就是 PCM 编码，被广泛用于素材保存及音乐欣赏，CD、DVD 以及我们常见的WAV文件中均有应用。它主要包括三步：抽样、量化、编码。\n抽样 对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理采样：采样频率 \u0026gt;= 2*信号最高频率 量化 把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。 编码 把量化的结果转换为与之对应的二进制编码。 模拟数据-》模拟信号 为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的。\n传输介质及分类 传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路。传输媒体并不是物理层。 传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为 0 层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。\n传输介质\n导向性：电磁波被导向沿着固体媒介传播 非导向性：空气，海水等 双绞线 双绞线是古老、又最常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。绞合可以减少对相邻导线的电磁干扰。\n\u003c!DOCTYPE html\u003e Responsive Image 双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。距离太远时，对于模拟传输，要用放大器放大衰减的信号；对于数字传输，要用中继器将失真的信号整形。\n同轴电缆 同轴电缆由导体铜质芯线、绝缘层、网状编织屏蔽层和塑料外层构成。按特性阻抗数值的不同，通常将同轴电缆分为两类：50$\\Omega$同轴 电缆和 75$\\Omega$同轴电缆。其中，50$\\Omega$同轴电缆主要用于传送基带数字信号，又称为基带同轴电缆，它在局域网中得到广泛应用；75$\\Omega$同轴电缆主要用于传送宽带信号，又称为宽带同轴电缆，它主要用于有线电视系统。\n由于外导体屏蔽层的作用，同轴电缆抗干扰特性比双绞线好，被厂泛用于传输较高速率的数据，其传输距离更远，但价格较双绞线贵\n\u003c!DOCTYPE html\u003e Responsive Image 光纤 光纤通信就是利用光导纤维（简称光纤）传递光脉冲来进行通信。有光脉冲表示 1，无光脉冲表示 0。而可见光的频率大约是 108MHz，因此光纤通信系统的带宽远远大于目前其他各种传输媒体的带宽。\n光纤主要由纤芯（实心的！）和包层构成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。\n\u003c!DOCTYPE html\u003e Responsive Image 光纤特点：\n传输损耗小，中继距离长，对远距离传输特别经济。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好，也不易被窃听或截取数据。 无线电波 信号所有方向都能传播\n较强穿透能力，可传远距离，广泛用于通信领域（如手机通信）。\n微波 信号固定方向传播\n微波通信频率较高、频段范围宽，因此数据率很高\n优点：\n通信容量大 距离远 覆盖广 广播通信和多址通信 缺点：\n传播时延长（250-270ms） 受气候影响大（eg：强风太阳黑子爆发、日凌）X 信 误码率较高 成本高 红外线，激光 信号固定方向传播\n要把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再在空间中传播。\n物理层设备 中继器 \u003c!DOCTYPE html\u003e Responsive Image 诞生原因：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到\u0026ndash;定程度时将造成信号失真，因此会导致接收错误。 中继器的功能(再生数字信号)：对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。 中继器两端：适用于完全相同的两类网络的互连，速率要相同，只做转发不做检测，可以连接不同设备，两端是同一个协议 5-4-3规则：网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。 5个网段-4个中继器-3个设备\n\u003c!DOCTYPE html\u003e Responsive Image 集线器（多口中继器） \u003c!DOCTYPE html\u003e Responsive Image 功能：再生与放大信号 不能分割冲突域，连接在集线器上的工作主机平分带宽\n","permalink":"https://lifeislife.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/","summary":"\u003ch2 id=\"物理层\"\u003e物理层\u003c/h2\u003e\n\u003ch3 id=\"基本概念\"\u003e基本概念\u003c/h3\u003e\n\u003cp\u003e物理层解决如何在连接各种计算机的传输媒体上\u003ccode\u003e传输数据比特流\u003c/code\u003e，而不是指具体的传输媒体。\n物理层主要任务：确定与传输媒体\u003ccode\u003e接口\u003c/code\u003e有关的一些特性\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、\u003ccode\u003e引脚数量\u003c/code\u003e和排列情况。\u003c/li\u003e\n\u003cli\u003e电气特性：规定传输二进制位时，线路上信号的\u003ccode\u003e电压范围\u003c/code\u003e、阻抗匹配、传输\u003ccode\u003e速率\u003c/code\u003e和\u003ccode\u003e距离\u003c/code\u003e限制等。\u003c/li\u003e\n\u003cli\u003e功能特性：指明某条线上出现的某一\u003ccode\u003e电平表示何种意义\u003c/code\u003e，接口部件的信号线的用途。\u003c/li\u003e\n\u003cli\u003e规程特性（过程特性）：定义各条物理线路的工作\u003ccode\u003e规程和时序\u003c/code\u003e关系\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"数据通信基础概念\"\u003e数据通信基础概念\u003c/h3\u003e\n\u003ch4 id=\"典型的数据通信模型\"\u003e典型的数据通信模型\u003c/h4\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/06/10/dcfc2ba8a7d5d1e222e8be2ea6e6b78b.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/06/10/dcfc2ba8a7d5d1e222e8be2ea6e6b78b.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"计算机网络 - 物理层"},{"content":"REST Client 是 VSCode 中一款非常好用的插件，能够帮助开发人员快速、方便地发送 HTTP 请求并查看响应。在本文中，我们将会详细介绍 REST Client 的使用方法。\n安装 REST Client 插件 在 VSCode 中，你可以通过以下步骤安装 REST Client 插件：\n打开 VSCode； 点击左侧的插件图标（Ctrl+Shift+X）； 搜索“REST Client”插件； 点击“安装”按钮。 发送 HTTP 请求 使用 REST Client 插件发送 HTTP 请求非常简单。你只需要创建一个新的.rest文本文件，将请求信息放入其中，然后使用快捷键Ctrl + Alt + R 或者右键菜单的 Send Request 选项发送请求。\n下面是一个简单的 GET 请求的例子：\nGET https://jsonplaceholder.typicode.com/posts/1 HTTP/1.1 这个请求会获取 JSONPlaceholder API 中的一篇博客文章。\n如果你想添加请求头或请求体，可以使用以下语法：\nGET https://jsonplaceholder.typicode.com/posts/1 HTTP/1.1 Content-Type: application/json { \u0026#34;title\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;userId\u0026#34;: 1 } 这个请求会在请求头中添加 Content-Type 头，请求体中包含 JSON 数据。\n查看响应 发送请求后，你可以在编辑器底部看到响应信息。如果你想查看响应头、响应体或状态码等详细信息，可以使用以下语法：\n### HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 ... { \u0026#34;userId\u0026#34;: 1, \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;sunt aut facere repellat provident occaecati excepturi optio reprehenderit\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;quia et suscipit\\nsuscipit...\u0026#34; } 在这个例子中，###用来分隔请求和响应，这样你就可以很方便地查看请求和响应的详细信息了。\n变量 REST Client 插件还支持变量的使用。你可以使用${variable}语法来定义变量，然后在请求中使用它们。例如：\n@host = https://jsonplaceholder.typicode.com GET ${host}/posts/1 HTTP/1.1 在这个例子中，我们定义了一个名为 host 的变量，并在请求中使用它来指定 API 的基础 URL。\n循环 如果你需要发送多个请求，REST Client 插件支持循环语法。例如：\n@host = https://jsonplaceholder.typicode.com @for(i,1,10){ GET ${host}/posts/${i} HTTP/1.1 } 在这个例子中，我们使用@for 语法来发送 10 个 GET 请求，每个请求 URL 中的 i 变量从 1 到 10 依次递增。\n条件语句 如果你需要根据条件发送请求，REST Client 插件也支持条件语句。例如：\n@host = https://jsonplaceholder.typicode.com @if(isDebug){ GET ${host}/posts/1 HTTP/1.1 }else{ GET ${host}/posts/2 HTTP/1.1 } 在这个例子中，我们使用@if 语法来判断是否为调试模式，如果是就发送一个请求，否则发送另一个请求。\n导入环境变量 REST Client 插件支持从外部文件中导入环境变量。例如，你可以在.env 文件中定义变量：\nhost=https://jsonplaceholder.typicode.com isDebug=true 然后在请求文件中使用@environment 语法来导入这些变量：\n@environment .env @if(isDebug){ GET ${host}/posts/1 HTTP/1.1 }else{ GET ${host}/posts/2 HTTP/1.1 } 在这个例子中，我们使用@environment 语法从.env 文件中导入环境变量，然后在请求文件中使用这些变量。\n结论 REST Client 插件是一个非常好用的工具，能够帮助开发人员快速、方便地发送 HTTP 请求并查看响应。在本文中，我们介绍了 REST Client 的基本使用方法，包括发送请求、查看响应、使用变量、循环、条件语句和导入环境变量等。希望这篇文章能够帮助你更好地使用 REST Client 插件。\n","permalink":"https://lifeislife.cn/posts/vscode-%E6%8F%92%E4%BB%B6-rest-client%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/","summary":"\u003cp\u003eREST Client 是 VSCode 中一款非常好用的插件，能够帮助开发人员快速、方便地发送 HTTP 请求并查看响应。在本文中，我们将会详细介绍 REST Client 的使用方法。\u003c/p\u003e\n\u003ch2 id=\"安装-rest-client-插件\"\u003e安装 REST Client 插件\u003c/h2\u003e\n\u003cp\u003e在 VSCode 中，你可以通过以下步骤安装 REST Client 插件：\u003c/p\u003e","title":"VSCode 插件 REST Client 使用文档"},{"content":"在 WSL2 中，你可能会遇到与 Docker 服务相关的问题，因为 WSL2 与传统 Linux 系统在某些方面有所不同。在这种情况下，你可以尝试以下步骤来解决问题：\n首先，确保你已经安装了 WSL2 的最新版本。你可以通过运行以下命令来更新 WSL2： wsl --update 确保 Docker Desktop for Windows 已安装并启用 WSL2 集成。你可以在 Docker Desktop 设置中找到这个选项。确保你的 WSL2 发行版已被添加到 Docker Desktop 的 WSL 集成列表中。点击链接下载安装在 Windows 上安装 Docker 桌面。 在 WSL2 中，尝试手动停止 Docker 服务： sudo /etc/init.d/docker stop 如果这个命令无法停止 Docker 服务，请尝试以下命令： sudo killall dockerd 卸载 Docker： sudo apt-get purge docker-ce 删除 Docker 相关的文件和目录： sudo rm -rf /var/lib/docker 重新启动 WSL2： wsl --shutdown 然后重新打开 WSL2。 在 WSL2 中，不要直接安装 Docker CE。而是使用 Docker Desktop for Windows 提供的 Docker 服务。这意味着你不需要在 WSL2 中安装 Docker CE，因为 Docker Desktop 已经提供了 Docker 服务。 确保你的 WSL2 发行版可以访问 Docker Desktop 提供的 Docker 服务。你可以通过运行以下命令来检查： docker --version docker info ","permalink":"https://lifeislife.cn/posts/wsl2%E5%AE%89%E8%A3%85docker/","summary":"\u003cp\u003e在 WSL2 中，你可能会遇到与 Docker 服务相关的问题，因为 WSL2 与传统 Linux 系统在某些方面有所不同。在这种情况下，你可以尝试以下步骤来解决问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e首先，确保你已经安装了 WSL2 的最新版本。你可以通过运行以下命令来更新 WSL2：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewsl --update\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e确保 Docker Desktop for Windows 已安装并启用 WSL2 集成。你可以在 Docker Desktop 设置中找到这个选项。确保你的 WSL2 发行版已被添加到 Docker Desktop 的 WSL 集成列表中。点击链接下载安装\u003ca href=\"https://dockerdocs.cn/docker-for-windows/install/\"\u003e在 Windows 上安装 Docker 桌面\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003e在 WSL2 中，尝试手动停止 Docker 服务：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo /etc/init.d/docker stop\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode\u003e如果这个命令无法停止 Docker 服务，请尝试以下命令：\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo killall dockerd\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"4\"\u003e\n\u003cli\u003e卸载 Docker：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get purge docker-ce\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"5\"\u003e\n\u003cli\u003e删除 Docker 相关的文件和目录：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo rm -rf /var/lib/docker\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"6\"\u003e\n\u003cli\u003e重新启动 WSL2：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewsl --shutdown\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"7\"\u003e\n\u003cli\u003e然后重新打开 WSL2。\u003c/li\u003e\n\u003cli\u003e在 WSL2 中，不要直接安装 Docker CE。而是使用 Docker Desktop for Windows 提供的 Docker 服务。这意味着你不需要在 WSL2 中安装 Docker CE，因为 Docker Desktop 已经提供了 Docker 服务。\u003c/li\u003e\n\u003cli\u003e确保你的 WSL2 发行版可以访问 Docker Desktop 提供的 Docker 服务。你可以通过运行以下命令来检查：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker --version\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker info\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"WSL2 安装 Docker"},{"content":"一生一芯概述 “一生一芯”概述 _哔哩哔哩_bilibili\n程序的执行和模拟器 freestanding 运行时环境 程序如何结束运行 在正常的环境中，写了一段代码return之后，实际上调用了一个系统调用exit。但是在 freestanding 环境中，没有操作系统支持，根据 C99 手册规定，在 freestanding 环境中结束运行是由用户实现决定的。\n5.1.2.1 Freestanding environment 2 The effect of program termination in a freestanding environment is implementation-defined. 在 qemu-system-riscv64 中的 virt 机器模型中，往一个特殊的地址写入一个特殊的“暗号”即可结束 QEMU\n#include \u0026lt;stdint.h\u0026gt; void _start() { volatile uint8_t *p = (uint8_t *)(uintptr_t)0x10000000; *p = \u0026#39;A\u0026#39;; volatile uint32_t *exit = (uint32_t *)(uintptr_t)0x100000; *exit = 0x5555; // magic number _start(); // 递归调用，如果正常退出将不会再次打印A } 在自制 freestanding 运行时环境上运行 Hello 程序 QEMU 虽然是个开源项目，但还挺复杂，不利于我们理解细节。让我们来设计一个面向 RISC-V 程序的简单 freestanding 运行时环境，我做以下约定。\n程序从地址 0 开始执行 只支持两条指令 addi 指令 ebreak 指令 寄存器 a0=0 时，输出寄存器 a1 低 8 位的字符 寄存器 a0=1 时，结束运行 ABI Mnemonic（RISC-V 官方为每个寄存器起个名字） static void ebreak(long arg0, long arg1) { asm volatile(\u0026#34;addi a0, x0, %0;\u0026#34; \u0026#34;addi a1, x0, %1;\u0026#34; \u0026#34;ebreak\u0026#34; : : \u0026#34;i\u0026#34;(arg0), \u0026#34;i\u0026#34;(arg1)); } static void putch(char ch) { ebreak(0, ch); } static void halt(int code) { ebreak(1, code); while (1); } void _start() { putch(\u0026#39;A\u0026#39;); halt(0); } /** * 这段代码定义了三个函数：ebreak、putch 和 halt。 * ebreak 函数是一个内联汇编函数，它执行 ebreak 指令。 * 该指令是 RISC-V 架构中的一条调试指令，可以在调试器的控制下执行。 * 该函数接受两个参数 arg0 和 arg1，它们将被存储在寄存器 a0 和 a1 中。 * putch 函数调用了 ebreak 函数，并将第一个参数设为 0， * 第二个参数设为函数参数 ch。这样做的目的可能是为了在调试器的控制下输出一个字符。 * halt 函数调用了 ebreak 函数，并将第一个参数设为 1， * 第二个参数设为函数参数 code。这样做的目的可能是为了通知调试器程序已经结束， * 并使用 code 作为结束状态。然后，halt 函数进入一个死循环，等待调试器的操作。 * 最后，_start 函数调用了 putch 函数输出字符 \u0026#39;A\u0026#39;，然后调用 halt 函数结束程序 */ riscv64-linux-gnu-gcc -march=rv64g -ffreestanding -nostdlib -static -Wl,-Ttext=0 \\ -O2 -o prog a.c riscv64-linux-gnu-gcc: 这是 GCC 的可执行文件的名称，表示使用的是 GCC 编译器。riscv64-linux-gnu 是编译器的目标平台，表示生成的代码是针对 RISC-V 架构，运行在 Linux 系统上的二进制文件。\n-march=rv64g: 这个参数指定了编译器使用的指令集。rv64g 表示使用 RISC-V 架构的 64 位指令集。\n-ffreestanding: 这个参数指示编译器生成的代码将在 freestanding 运行环境中运行。在 freestanding 运行环境中，程序不会自动链接标准 C 库，也不会自动调用 main 函数。\n-nostdlib: 这个参数表示编译器不需要链接标准 C 库。\n-static: 这个参数表示生成的代码是静态链接的。\n-Wl,-Ttext=0: 这个参数是传递给链接器的，表示设置代码段的起始地址为 0。\n-O2: 这个参数指示编译器使用优化级别为 2 的优化选项。\n-o prog: 这个参数指定生成的可执行文件的名称为 prog。\na.c: 这是要编译的 C 源文件的名称。\nllvm-objdump -d prog 反汇编结果如下：\nprog: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 \u0026lt;_start\u0026gt;: 0: 13 05 00 00 li a0, 0 4: 93 05 10 04 li a1, 65 8: 73 00 10 00 ebreak c: 13 05 10 00 li a0, 1 10: 93 05 00 00 li a1, 0 14: 73 00 10 00 ebreak 18: 6f 00 00 00 j 0x18 \u0026lt;_start+0x18\u0026gt; 我们约定中没有li指令，但是汇编中却出现了，这是因为li是一条伪指令，它的实际实现依然是addi。如果不使用伪指令可以使用以下命令反汇编：\nllvm-objdump -M no-aliases -d prog 结果如下，没有伪指令，只有我们约定的几条指令。\nprog: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 \u0026lt;_start\u0026gt;: 0: 13 05 00 00 addi a0, zero, 0 4: 93 05 10 04 addi a1, zero, 65 8: 73 00 10 00 ebreak c: 13 05 10 00 addi a0, zero, 1 10: 93 05 00 00 addi a1, zero, 0 14: 73 00 10 00 ebreak 18: 6f 00 00 00 jal zero, 0x18 \u0026lt;_start+0x18\u0026gt; YEMU 指令如何执行 ISA 手册定义了一个状态机。\n状态集合 S = {\u0026lt;R, M\u0026gt;}\nR = {PC, x0, x1, x2, \u0026hellip;} RISC-V 手册 -\u0026gt; 2.1 Programmers’Model for Base Integer ISA PC = 程序计数器 = 当前执行的指令位置 M = 内存 RISC-V 手册 -\u0026gt; 1.4 Memory 激励事件：执行 PC 指向的指令 状态转移规则：指令的语义 (semantics) 初始状态 S0 = \u0026lt;R0, M0\u0026gt;\n我们只要把这个状态机实现出来，就可以用它来执行指令了！\n用变量实现内存 #include \u0026lt;stdint.h\u0026gt; uint64_t R[32], PC; // according to the RISC-V manual uint8_t M[64]; // 64-Byte memory Q: 为什么不使用 int64_t 和 int8_t?\nA: C语言标准规定, 有符号数溢出是undefined behavior, 但无符号数不会溢出\n6.5 Expressions 5 If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or not in the range of representable values for its type), the behavior is undefined. 6.2.5 Types 9 A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type.\n用语句实现指令的语义 指令周期 (instruction cycle): 执行一条指令的步骤\n取指 (fetch): 从 PC 所指示的内存位置读取一条指令 译码 (decode): 按照手册解析指令的操作码 (opcode) 和操作数 (operand) 执行 (execute): 按解析出的操作码，对操作数进行处理 更新 PC: 让 PC 指向下一条指令 状态机不断执行指令，直到结束运行：\n#include \u0026lt;stdbool.h\u0026gt; bool halt = false; while (!halt) { inst_cycle(); } 31 20 19 15 14 12 11 7 6 0 +---------------+-----+-----+-----+---------+ | imm[11:0] | rs1 | 000 | rd | 0010011 | ADDI +---------------+-----+-----+-----+---------+ +---------------+-----+-----+-----+---------+ | 000000000001 |00000| 000 |00000| 1110011 | EBREAK +---------------+-----+-----+-----+---------+ 一个简单的实现：\nvoid inst_cycle() { uint32_t inst = *(uint32_t *)\u0026amp;M[PC]; if (((inst \u0026amp; 0x7f) == 0x13) \u0026amp;\u0026amp; ((inst \u0026gt;\u0026gt; 12) \u0026amp; 0x7) == 0) { // addi if (((inst \u0026gt;\u0026gt; 7) \u0026amp; 0x1f) != 0) { R[(inst \u0026gt;\u0026gt; 7) \u0026amp; 0x1f] = R[(inst \u0026gt;\u0026gt; 15) \u0026amp; 0x1f] + (((inst \u0026gt;\u0026gt; 20) \u0026amp; 0x7ff) - ((inst \u0026amp; 0x80000000) ? 4096 : 0)); } } else if (inst == 0x00100073) { // ebreak if (R[10] == 0) { putchar(R[11] \u0026amp; 0xff); } else if (R[10] == 1) { halt = true; } else { printf(\u0026#34;Unsupported ebreak command\\n\u0026#34;); } } else { printf(\u0026#34;Unsupported instuction\\n\u0026#34;); } PC += 4; } NEMU 代码导读 make 项目构 # 显示make踪迹 strace make # 显示构建过程 make -d # 显示更详细的构建构过程 make --debug=v Reading makefiles... Reading makefile `Makefile\u0026#39;... Updating goal targets.... File `all\u0026#39; does not exist. File `all\u0026#39; does not exist. Looking for an implicit rule for `all\u0026#39;. Trying pattern rule with stem `all\u0026#39;. Trying implicit prerequisite `all.c\u0026#39;. Trying pattern rule with stem `all\u0026#39;. Trying implicit prerequisite `all.cc\u0026#39;. Trying pattern rule with stem `all\u0026#39;. Trying implicit prerequisite `all.C\u0026#39;. Trying pattern rule with stem `all\u0026#39;. Trying implicit prerequisite `all.cpp\u0026#39;. Trying pattern rule with stem `all\u0026#39;. Trying implicit prerequisite `all.CPP\u0026#39;. Trying pattern rule with stem `all\u0026#39;. Trying implicit prerequisite `all.cxx\u0026#39;. Trying pattern rule with stem `all\u0026#39;. Trying implicit prerequisite `all.CXX\u0026#39;. Trying pattern rule with stem `all\u0026#39;. Trying implicit prerequisite `all.c++\u0026#39;. Trying pattern rule with stem `all\u0026#39;. Trying implicit prerequisite `all.C++\u0026#39;. No implicit rule found for `all\u0026#39;. Finished prerequisites of target file `all\u0026#39;. Must remake target `all\u0026#39;. gcc -o all all.o Finished prerequisites of target file `all\u0026#39;. Must remake target `all\u0026#39;. gcc -o all all.o Successfully remade target file `all\u0026#39;. # 只打印命令不执行 make -n # 输出目标被构建的原因和执行的命令 make --trace 例如，如果您有一个 makefile，其目标 all 依赖于目标 foo 和 bar，并且您运行 make --trace all，您可能会看到如下输出：\nmake[1]: Entering directory \u0026#39;/path/to/project\u0026#39; gcc -o foo foo.c make[1]: Leaving directory \u0026#39;/path/to/project\u0026#39; make[1]: Entering directory \u0026#39;/path/to/project\u0026#39; gcc -o bar bar.c make[1]: Leaving directory \u0026#39;/path/to/project\u0026#39; make[1]: Entering directory \u0026#39;/path/to/project\u0026#39; gcc -o all foo.o bar.o make[1]: Leaving directory \u0026#39;/path/to/project\u0026#39; make -nB # -B 可以强制 make 构建所有目标，即使它们已经是最新的 make -nB | vim - 在 vim 编辑器中进行二次处理，过滤不需要的信息。\n# 只保留 gcc 或 g++开头的行 :%!grep \u0026#34;^\\(gcc\\|g++\\)\u0026#34; # 将环境变量$NEMU_HOME 所指示字符串替换为$NEMU_HOME :%!sed -e \u0026#34;s+$NEMU_HOME+\\$NEMU_HOME+g\u0026#34; # 将$NEMU_HOME/build/obj-riscv64-nemu-interpreter 替换为$OBJ_DIR :%s+\\$NEMU_HOME/build/obj-riscv64-nemu-interpreter+$OBJ_DIR+g # 将-c 之前的内容替换为$CFLAGS :%s/-O2.*=riscv64/$CFLAGS/g # 将最后一行的空格替换成换行并缩进两格 :$s/ */\\r /g 调试技巧选将 断言 在 C 程序中使用断言（assert）不会增加额外的内存空间，也不会增加数据段空间。断言是一种在运行时检查程序假设是否为真的方法，当断言失败时，程序会终止执行并显示错误信息。\n在 C 语言中，断言通常使用宏来实现。它在编译时被解释为一个简单的条件语句，因此它不会增加程序的内存空间或数据段空间。断言宏的定义通常类似于以下代码：\n#include \u0026lt;assert.h\u0026gt; #define assert(expression) ((void)0) 这里的 expression 是要检查的条件。如果 expression 为假，则 assert() 函数会发出错误消息并终止程序的执行。如果 expression 为真，则 assert() 函数不会产生任何操作，并且被解释为 ((void)0)。这个语句不会增加任何内存或数据段空间。\n需要注意的是，当一个程序使用大量的断言时，它可能会对程序的性能产生一些影响，因为每个断言都需要在运行时进行检查。因此，在生产环境中，应该尽可能减少使用断言，并在测试和调试阶段使用它们来确保代码的正 确性。\n// nemu/src/isa/riscv64/local-include/reg.h static inline int check_reg_idx(int idx) { IFDEF(CONFIG_RT_CHECK, assert(idx \u0026gt;= 0 \u0026amp;\u0026amp; idx \u0026lt; 32)); return idx; } 编译器工具 sanitizer 让编译器自动插入 assert, 拦截常见的非预期行为\nAddressSanitizer - 检查指针越界，use-after-free ThreadSanitizer - 检查多线程数据竞争 LeakSanitizer - 检查内存泄漏 UndefinedBehaviorSanitizer - 检查 UB 还能检查指针的比较和相减 打开后程序运行效率有所下降\n但调试的时候非常值得，躺着就能让工具帮你找 bug man gcc 查看具体用法 使用方法 GCC 提供了多种 Sanitizer 工具，可以帮助开发者在编译时检测和修复常见的编程错误，例如内存泄漏、缓冲区溢出、使用未初始化的变量等。以下是几个 Sanitizer 工具的示例用法：\nAddress Sanitizer（ASAN）：检测内存错误，例如使用已经释放的内存、堆栈和全局缓冲区的溢出和下溢等。\ngcc -fsanitize=address -g \u0026lt;source files\u0026gt; -o \u0026lt;output file\u0026gt; Undefined Behavior Sanitizer（UBSAN）：检测未定义行为，例如除以零、使用未初始化的变量、指针溢出等。\ngcc -fsanitize=undefined -g \u0026lt;source files\u0026gt; -o \u0026lt;output file\u0026gt; Thread Sanitizer（TSAN）：检测并发问题，例如竞争条件、死锁等。\ngcc -fsanitize=thread -g \u0026lt;source files\u0026gt; -o \u0026lt;output file\u0026gt; Memory Sanitizer（MSAN）：检测使用未初始化的内存，例如读取未初始化的内存、使用已释放的内存等。\ngcc -fsanitize=memory -g \u0026lt;source files\u0026gt; -o \u0026lt;output file\u0026gt; 需要注意的是，Sanitizer 工具可能会增加程序的执行时间和内存消耗，并且可能会产生误报，因此在生产环境中应该禁用 Sanitizer 工具。通常情况下，开发者可以在开发和测试阶段启用 Sanitizer 工具，以帮助他们发现和修复代码中的问题。\n自顶向下理解程序行为 ftrace - 函数调用层次，理解程序的大体行为 itrace - 指令执行层次，理解指令级别的行为 mtrace - 访存的踪迹 dtrace - 设备访问的踪迹 sdb - 灵活细致地检查客户程序的状态 si - 细粒度的状态转移 info r/x - 检查R/M 监视点 - 捕捉某状态发生变化的时刻 sdb 与 gdb 结合使用\n先用 sdb 定位到出错点附近 再用 gdb 观察 NEMU 的细节行为 程序的运行时间都花在了哪里 Linux 的性能分析工具 perf 是一款功能强大的性能分析工具，它可以通过硬件计数器（Hardware counter）或者性能事件（Performance event）来对 Linux 系统的性能进行分析。以下是 perf 工具的安装和使用方法。\n安装 perf 工具 在大部分 Linux 发行版中，perf 工具已经预先安装，如果没有预先安装，可以通过以下命令进行安装。\nDebian/Ubuntu 系统：sudo apt-get install linux-tools-common linux-tools-generic Fedora 系统：sudo dnf install perf CentOS/RHEL 系统：sudo yum install perf 安装完毕之后，可以通过 perf version 命令来检查 perf 版本信息。\n编写一个简单的 C 代码 这里我们编写一个简单的 C 代码，用于测试 perf 工具的使用。代码如下：\n#include \u0026lt;stdio.h\u0026gt; int main() { int i, sum = 0; for (i = 1; i \u0026lt;= 1000000; i++) sum += i; printf(\u0026#34;sum = %d\\n\u0026#34;, sum); return 0; } 代码的作用是计算 1 到 1000000 的和。\n使用 perf 工具 下面我们使用 perf 工具来对上述代码进行性能分析。假设代码保存在文件 test.c 中。\n统计 CPU 周期数 以下命令用于统计程序的 CPU 周期数：\nperf stat ./test 输出结果类似于：\nPerformance counter stats for \u0026#39;./test\u0026#39;: 19,23 msec task-clock:u # 0.988 CPUs utilized 0 context-switches:u # 0.000 K/sec 0 cpu-migrations:u # 0.000 K/sec 575 page-faults:u # 0.030 M/sec 64,013,620,231 cycles:u # 3.324 GHz (49.80%) 40,010,335,480 instructions:u # 0.62 insn per cycle (62.34%) 9,998,469,566 branches:u # 518.693 M/sec (62.27%) 763,176 branch-misses:u # 0.01% of all branches (62.32%) 0.019438122 seconds time elapsed 0.019411000 seconds user 0.000007000 seconds sys 输出结果中的 cycles 表示 CPU 周期数，instructions 表示指令数，branches 表示分支指令数。其中，cycles 和 instructions 的比例代表了 CPU 的效率，即 IPC（Instructions Per Cycle）。\n统计函数调用次数 以下命令用于统计程序中函数的调用次数：\nperf record -e cycles -g ./test 这个命令将启动 perf 工具，并使用 -g 选项记录调用关系图。我们还需要使用 sudo 权限运行该命令，以便 perf 工具可以访问系统的硬件计数器。\n成为专业码农 要熟悉项目了 -\u0026gt; STFW/RTFM/RTFSC, 尝试理解一切细节 要写代码了 仔细 RTFM, 正确理解需求 编写可读，可维护，易验证的代码 (不言自明，不言自证) 用 lint 工具检查代码 进行充分的测试 添加充分的断言 要调试了 默念“机器永远是对的/未测试代码永远是错的” sanitizer, trace, printf, gdb, … 平时 -\u0026gt; 用正确的工具/方法做事情 感到不爽了 -\u0026gt; 找正确的工具/搭基础设施 总线选讲 定义 广义上讲总线就是一个通信系统，以下这些都属于广义的总线概念:TCP/IP, 以太网，网线，RTL 信号，系统调用。\n主动发起通信的叫 master，响应通信的叫 slave。\n","permalink":"https://lifeislife.cn/posts/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"一生一芯概述\"\u003e一生一芯概述\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.bilibili.com/video/BV12e4y1Y76i/?spm_id_from=333.788\u0026amp;vd_source=7ff88341de4b5111bdf3db48b4e9ca44\"\u003e“一生一芯”概述 _哔哩哔哩_bilibili\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"程序的执行和模拟器\"\u003e程序的执行和模拟器\u003c/h1\u003e\n\u003ch2 id=\"freestanding-运行时环境\"\u003efreestanding 运行时环境\u003c/h2\u003e\n\u003ch3 id=\"程序如何结束运行\"\u003e程序如何结束运行\u003c/h3\u003e\n\u003cp\u003e在正常的环境中，写了一段代码\u003ccode\u003ereturn\u003c/code\u003e之后，实际上调用了一个系统调用\u003ccode\u003eexit\u003c/code\u003e。但是在 freestanding 环境中，没有操作系统支持，根据 C99 手册规定，在 freestanding 环境中结束运行是由用户实现决定的。\u003c/p\u003e","title":"一生一芯笔记"},{"content":"基础设施 本章记录一些配置笔记，不是 step by step 教程\n安装 JAVA # 免登陆下载java https://xiandan.io/posts/jdk-download.html # 高速镜像 https://github.com/LilithBristol/javajdkforwinx64 Linux 环境变量 PATH\n%JAVA_HOME%\\bin %JAVA_HOME%\\jre\\bin Windows 环境变量\n# JAVA_HOME C:\\Program Files\\Java\\jdk1.8.0_212 # CLASSPATH .;%JAVA_HOME%\\bin;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar VSCode 开发环境 基础插件 安装 Extension Pack for Java 即可，会把用到的开发插件都安装。不需要安装 Java Language Support 会和 Extension Pack for Java 中的 Language Support for Java by Red Hat 冲突。目前使用过程中也没有遇到必须使用 Java Language Support 的情况。\n基本使用 使用 CTRL+SHIFT+P 输入 Java: create Project，输入项目名，在 src 文件夹中，选择 Run 运行 Java 代码。\n常用快捷键 # 导包 shift + alt + o IDEA 开发环境 下载安装 IDEA Java 集成开发环境 IntelliJ IDEA 2022.3 Ultimate 永久激活版 - 风软资源站\n配置 MAVEN,IDEA 中下载速度慢 # IDEA中编辑区右键--maven--create xml \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;uk\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Human Readable Name for this Mirror.\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://uk.maven.org/maven2/\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;CN\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;OSChina Central\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.oschina.net/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;nexus\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;internal nexus repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://repo.maven.apache.org/maven2\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; 安装 MYSQL sudo apt install mysql sudo mysql -u root -p source /home/user/oa_system/VBlog/blogserver/src/main/resources/vueblog.sql 常用命令 # 创建数据库 CREATE DATABASE ryvue; # 切换当前数据库 use ryvue; set character set utf8; # 执行sql脚本 source /home/user/oa_system/RuoYi-Vue/sql/ry_20220822.sql source /home/user/oa_system/RuoYi-Vue/sql/quartz.sql # 删除数据库 drop database 数据库名; # 显示所有数据库 show databases; # 创建数据库 create database 数据库名; # 显示数据库编码格式 SHOW VARIABLES LIKE \u0026#39;character_set_%\u0026#39;; # 删除 mysql 密码 SET PASSWORD FOR root@localhost=PASSWORD(\u0026#39;\u0026#39;); # 重建数据库 drop database ryvue; create database ryvue; use ryvue; 安装数据库可视化工具 mysql-workbench echo \u0026#34;deb http://security.ubuntu.com/ubuntu focal-security main\u0026#34; | sudo tee /etc/apt/sources.list.d/focal-security.list sudo apt-get update sudo apt-get install libssl1.1 wget https://downloads.mysql.com/archives/get/p/8/file/mysql-workbench-community_8.0.12-1ubuntu18.04_amd64.deb sudo dpkg -i mysql*.deb sudo apt-get install -f sudo dpkg -i mysql*.deb VSCode 插件-MySQL by weijan Chen vscode-database-client 官方文档\n\u003c!DOCTYPE html\u003e Responsive Image 安装 NPM sudo apt install npm -y npm set progress=false npm config set registry http://registry.npmjs.org/ npm install --legacy-peer-deps reify:abbrev: sill audit bulk request 删除 package-lock.json 文件 安装 nvm 打开终端并输入以下命令以在 Ubuntu 上下载 nvm：\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash 该命令将从 nvm GitHub 存储库下载安装脚本，并使用 bash 在您的 Ubuntu 系统上运行它。运行此命令后，nvm 将被安装在您的家目录中。\n安装完成后，在终端中运行以下命令，以使 nvm 生效：\nsource ~/.bashrc 确认 nvm 是否正确安装：\nnvm --version 如果一切顺利，您将看到 nvm 的版本号。\n安装 node.js 和 npm 使用 nvm 安装特定版本的 Node.js：\nnvm install \u0026lt;node-version\u0026gt; 例如：\nnvm install 14.17.6 这将安装 Node.js 版本 14.17.6。\n安装完成后，使用以下命令将已安装的 Node.js 版本设置为默认版本：\nnvm alias default \u0026lt;node-version\u0026gt; 例如：\nnvm alias default 14.17.6 这将设置 Node.js 版本 14.17.6 为默认版本。\n确认 Node.js 和 npm 是否正确安装：\nnode -v npm -v 如果一切顺利，您将看到 Node.js 和 npm 的版本号。\n使用 nvm 切换 Node.js 版本：\n使用以下命令查看可用的 Node.js 版本：\nnvm ls-remote 该命令将显示可用的 Node.js 版本列表。\n使用以下命令安装特定版本的 Node.js：\nnvm install \u0026lt;node-version\u0026gt; 例如：\nnvm install 12.22.6 这将安装 Node.js 版本 12.22.6。\n使用以下命令切换到特定版本的 Node.js：\nnvm use \u0026lt;node-version\u0026gt; 例如：\nnvm use 12.22.6 这将切换到 Node.js 版本 12.22.6。\n确认当前使用的 Node.js 版本：\nnode -v 如果一切顺利，您将看到当前使用的 Node.js 版本号。\nERROR 合集 Java Error: Could not find or load main class org.apache.maven.wrapper.MavenWrapperMain maven 相关依赖还没下载完 JSON parse error: Cannot construct instance of 确认请求方式是 get 还是 post，如果是 post 是不是前端发了一个空串。空串要用{}包裹\nError: JAVA_HOME is not defined correctly # 缺少.mavenrc 配置文件 vim ~/.mavenrc # 将 JAVA 配置放进去 export JAVA_HOME=/usr/lib/jvm/jdk1dot8 配置数据表中不存在的字段 @TableField(exist = false) Error creating bean with name \u0026lsquo;minioController\u0026rsquo; endpoint must not be null 检查配置文件是否配置了 endpoint\n解决 MyBatis 报错 org.apache.ibatis.binding.BindingException: Invalid bound statement (not found) 1、检查 xml 文件的 namespace 是否对应接口，要是全路径。\n2、xml 中的函数 id 和接口中的函数名是否对得上，参数类型、返回值类型是否对得上\n3、去看输出目录中有没有 xml 映射文件，maven 项目默认把资源文件放在 src/main/resources 下，默认只识别 src/main/resources 下的资源文件。\nUnable to obtain LocalDateTime from TemporalAccessor You can\u0026rsquo;t parse a date string into LocalDateTime without a time.\nLocalDateTime.parse(\u0026ldquo;2019-10-25\u0026rdquo;, DateTimeFormatter.ofPattern(\u0026ldquo;yyyy-MM-dd\u0026rdquo;))\nYou should parse the string into LocalDate and call LocalDate.atStartOfDay() to return LocalDateTime with time 00:00:00.\nLocalDate.parse(\u0026ldquo;2019-10-25\u0026rdquo;, DateTimeFormatter.ofPattern(\u0026ldquo;yyyy-MM-dd\u0026rdquo;)).atStartOfDay()\n// 传入的时间格式要和解析的时间格式保持一致，如以下解析方式，传入参数 2023-03-08 11:11:11 LocalDateTime startDateTime = LocalDateTime.parse(startTime, DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)); LocalDateTime endDateTime = LocalDateTime.parse(endTime, DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)); DateTimeFormatter localDateFmt = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#34;); DateTimeFormatter localDateFmt = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#34;); if (!\u0026#34;\u0026#34;.equals(startTime) \u0026amp;\u0026amp; !\u0026#34;\u0026#34;.equals(endTime)) { LocalDate startDate = LocalDate.parse(startTime, localDateFmt); LocalDate endDate = LocalDate.parse(endTime, localDateFmt); LocalDateTime startDateTime = LocalDateTime.of(startDate, LocalTime.MIN); LocalDateTime endDateTime = LocalDateTime.of(endDate, LocalTime.MAX); log.debug(\u0026#34;startDateTime: \u0026#34; + startDateTime); log.debug(\u0026#34;endDateTime: \u0026#34; + endDateTime); queryWrapper.between(\u0026#34;create_time\u0026#34;, startDateTime, endDateTime); } mybatisplus 提交数据后无法立即被查询到 提升事务隔离级别 @Transactional(isolation = Isolation.READ_UNCOMMITTED) One record is expected, but the query result is multiple records 解决方案：如果想取一条并不想报错时使用 getOne(queryWrapper,false) 注意 mybatisplus 的 sql 返回值 java.lang.NumberFormatException: null 检查使用 Integer.parseInt 转换时，是否转换的数可能为 null\nUnexpected error occurred in scheduled taskjava.lang.NullPointerException: null 服务类没有正确注入，每一个需要注入类都需要添加 Autowire 注解\nUnhandled exception type 原因：被强制异常处理的代码块，必须进行异常处理，否则编译器会提示“Unhandled exception type Exception”错误警告。\n需要将代码写到 try catch 里！\nMySQL 数据库乱码，前端乱码 sudo vim /etc/mysql/my.cnf # 填写如下配置 [client] default-character-set=utf8mb4 [mysqld] character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci init_connect=\u0026#39;SET NAMES utf8mb4\u0026#39; skip-character-set-client-handshake = true [mysql] default-character-set = utf8mb4 nested exception is java.lang.NullPointerException] with root cause \u003c!DOCTYPE html\u003e Responsive Image Error attempting to get column \u0026lsquo;motion_id\u0026rsquo; from result set 数据库字段类型与后端类型不一致\n前端 digital envelope routines::unsupported export NODE_OPTIONS=--openssl-legacy-provider 禁止跨域策略 (CORS policy) node: \u0026ndash;openssl-legacy-provider is not allowed in NODE_OPTIONS unset NODE_OPTIONS Unexpected character (\u0026rsquo;}\u0026rsquo; 请求的时候最后一个字段后面不要加逗号\nThe value of the \u0026lsquo;Access-Control-Allow-Origin\u0026rsquo; header in the response must not be the wildcard \u0026lsquo;*\u0026rsquo; when the request\u0026rsquo;s credentials mode is \u0026lsquo;include\u0026rsquo;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute 这个错误通常是因为在使用 XMLHttpRequest 对象进行跨域请求时，服务器返回的响应头中的 Access-Control-Allow-Origin 的值为*，但请求的 withCredentials 属性被设置为 true，这两者之间是相互冲突的。\nXMLHttpRequest 对象具有 withCredentials 属性，如果设置为 true，它将在请求中包括来自其他域的 cookie 等凭据信息。但是，如果服务器在响应头中将 Access-Control-Allow-Origin 设置为*，浏览器会禁止访问这些凭据信息。这是一项安全保护措施，防止敏感信息泄露。\n解决这个问题的方法是，在服务器端，将 Access-Control-Allow-Origin 设置为请求来源的域名，而不是使用通配符*。这可以让浏览器安全地发送凭据信息。\n在前端，需要将 withCredentials 属性设置为 true，以便在请求中包含凭据信息。同时，需要确保请求的来源域名与服务器端设置的 Access-Control-Allow-Origin 一致。\n如果你无法更改服务器端的设置，可以考虑使用代理或者 JSONP 等跨域解决方案。\n\u003c!DOCTYPE html\u003e Responsive Image VUE 项目端口不固定 Application run failed org.springframework.beans.factory.BeanCreationException: Error creating bean with name \u0026lsquo;communityInfoController\u0026rsquo; 检查target/classes/mapper/DepartmentMapper.xml中的格式是否正确，检查引号是否多了，少了\n\u0026lt;select id=\u0026#34;findIdByOrgId\u0026#34; resultType=\u0026#34;resultType=\u0026#34;java.lang.Integer\u0026#34;\u0026gt; SELECT CAST(id AS UNSIGNED) AS id FROM department WHERE organization_id = #{orgId} \u0026lt;/select\u0026gt; 错误码 400-前后端参数对不上 {POST/GET} there is already xx bean method \u003c!DOCTYPE html\u003e Responsive Image NPM 启动:digital envelope routines::unsupported export NODE_OPTIONS=--openssl-legacy-provider npm run serve The field file exceeds its maximum permitted size of 1048576 bytes spring boot 上传文件时接口报错 The field file exceeds its maximum permitted size of 1048576 bytes.经排查官方设置每个文件的配置最大为 1Mb，单次请求的文件的总数不能大于 10Mb，上传大于 1Mb 的文件需要修改配置文件（application.properties） 1.Spring Boot 1.3.x 或者之前\nmultipart.maxFileSize=100Mb multipart.maxRequestSize=1000Mb 2.Spring Boot 1.4.x 以后\nspring.http.multipart.maxFileSize=100Mb spring.http.multipart.maxRequestSize=1000Mb 3.Spring Boot 2.0 之后\nspring.servlet.multipart.max-file-size=100MB spring.servlet.multipart.max-request-size=1000MB 字段不存在 请求的时候字段名字和 java 中命名保持一直，而不是和数据库名字保持一样\n数据库 communications link failure 配置请求超时时间 src/utils/request.js\n\u003c!DOCTYPE html\u003e Responsive Image Request method GET not supported 前端请求事件没有设置请求方式 post 还是 get\n\u003c!DOCTYPE html\u003e Responsive Image Invalid cros request 跨域\n处理未来数据 https://www.bilibili.com/video/BV1U44y1W77D?t=1655.5\u0026amp;p=23\nTIPS 前端保存代码需要等待一段时间生效 获取用户 IP String userIp = request.getRemoteAddr(); 解决方案：Java 实体类字段 不返回给前端 @JsonIgnore @ApiModelProperty(value = \u0026#34;不重要\u0026#34;) @TableField(exist = false) private String unimportant; Dateutil 包 import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; 获取请求参数 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //获取请求参数 String queryString = request.getQueryString(); log.info(\u0026#34;请求参数:{}\u0026#34;, queryString); } 后端设置 header 前端获取不到 # 必须要加这条字段控制能够获取的 header response.addHeader(\u0026#34;Access-Control-Expose-Headers\u0026#34;,\u0026#34;test\u0026#34;); response.addHeader(\u0026#34;test\u0026#34;, \u0026#34;sdfdsfdsf\u0026#34;); axios 请求 axios.get(\u0026#39;http://opm.eswincomputing.com:9090/user/page\u0026#39;) .then(function (response) { console.log(response.headers); }) .catch(function (error) { console.log(error.headers); }); 查询端口占用 lsof -i lsof -i:8080：查看 8080 端口占用 打印输出 # Application.yml logging: level: com.eswincomputing.springboot: debug # 使用 @Slf4j @RestController @RequestMapping(\u0026#34;/patch-record\u0026#34;) public class PatchRecordController { @Resource private IPatchRecordService patchRecordServic log.info(version); } 校验字符串是否为空 StrUtil.isBlank() 查询主键 SELECT id FROM department WHERE organization_id = #{orgId} 字符整型互转 Integer.parseInt(user.getDelFlag()) 解析 json 字符串 \u0026lt;!-- json 解析 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.21\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; JSONObject object = JSONObject.parseObject(patchRecord.getAttachmentList()); String fileUID = object.getString(\u0026#34;file_uid\u0026#34;); String fileName = object.getString(\u0026#34;file_name\u0026#34;); 逗号分割字符串 String string = \u0026#34;张三，李四，王五，马六，小气\u0026#34;; String substring = string.substring(0, string.length() - 1); System.out.println(substring); String[] split = substring.split(\u0026#34;,\u0026#34;);//以逗号分割 for (String string2 : split) { System.out.println(\u0026#34;数据--\u0026gt;\u0026gt;\u0026gt;\u0026#34; + string2); } ","permalink":"https://lifeislife.cn/posts/java%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"基础设施\"\u003e基础设施\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本章记录一些配置笔记，不是 step by step 教程\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"安装-java\"\u003e安装 JAVA\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 免登陆下载java\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehttps://xiandan.io/posts/jdk-download.html\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 高速镜像\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehttps://github.com/LilithBristol/javajdkforwinx64\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLinux 环境变量 PATH\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e%JAVA_HOME%\u003cspan class=\"se\"\u003e\\b\u003c/span\u003ein\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e%JAVA_HOME%\u003cspan class=\"se\"\u003e\\j\u003c/span\u003ere\u003cspan class=\"se\"\u003e\\b\u003c/span\u003ein\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWindows 环境变量\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# JAVA_HOME\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eC:\u003cspan class=\"se\"\u003e\\P\u003c/span\u003erogram Files\u003cspan class=\"se\"\u003e\\J\u003c/span\u003eava\u003cspan class=\"se\"\u003e\\j\u003c/span\u003edk1.8.0_212\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# CLASSPATH\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e.\u003cspan class=\"p\"\u003e;\u003c/span\u003e%JAVA_HOME%\u003cspan class=\"se\"\u003e\\b\u003c/span\u003ein\u003cspan class=\"p\"\u003e;\u003c/span\u003e%JAVA_HOME%\u003cspan class=\"se\"\u003e\\l\u003c/span\u003eib\u003cspan class=\"se\"\u003e\\d\u003c/span\u003et.jar\u003cspan class=\"p\"\u003e;\u003c/span\u003e%JAVA_HOME%\u003cspan class=\"se\"\u003e\\l\u003c/span\u003eib\u003cspan class=\"se\"\u003e\\t\u003c/span\u003eools.jar\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"vscode-开发环境\"\u003eVSCode 开发环境\u003c/h2\u003e\n\u003ch3 id=\"基础插件\"\u003e基础插件\u003c/h3\u003e\n\u003cp\u003e安装 \u003ccode\u003eExtension Pack for Java\u003c/code\u003e 即可，会把用到的开发插件都安装。不需要安装 Java Language Support 会和 Extension Pack for Java 中的 Language Support for Java by Red Hat 冲突。目前使用过程中也没有遇到必须使用 Java Language Support 的情况。\u003c/p\u003e","title":"JAVA 小白笔记"},{"content":"GitLab CI/CD 是一个强大的工具，可以帮助开发团队实现自动化构建、测试和部署。本文将介绍如何使用 GitLab CI/CD 的 Pipeline 功能，以实现将 Markdown 文件自动编译为 PDF 并上传至 GitLab Release 界面的功能。\n准备工作 在开始使用 GitLab CI/CD 的 Pipeline 功能之前，需要进行一些准备工作。具体步骤如下：\n创建 GitLab 项目：在 GitLab 上创建一个新项目，并将 Markdown 文件上传至项目的某个目录下。例如，我们将 Markdown 文件上传至项目的根目录下，并命名为 example.md。 安装 Pandoc：Pandoc 是一个用于文档转换的工具，我们将使用它将 Markdown 文件转换为 PDF。在安装 Pandoc 之前，需要先安装 LaTeX，因为 Pandoc 使用 LaTeX 进行 PDF 渲染。具体安装步骤请参考 Pandoc 和 LaTeX 的官方文档。\n创建 Release：在 GitLab 上创建一个 Release，用于存储编译好的 PDF 文件。具体操作方法请参考 GitLab 的官方文档。\n创建 CI/CD 配置文件：在项目根目录下创建一个.gitlab-ci.yml 文件，并在其中定义 Pipeline 的流程。\n编写 CI/CD 配置文件 下面是一个样例的.gitlab-ci.yml 文件，用于实现将 Markdown 文件编译为 PDF 并上传至 GitLab Release 界面的功能。\nimage: pandoc/core:latest stages: - build pdf: stage: build script: - pandoc example.md -o example.pdf - curl --header \u0026#34;PRIVATE-TOKEN: ${CI_PRIVATE_TOKEN}\u0026#34; --upload-file example.pdf \u0026#34;${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/uploads\u0026#34; artifacts: paths: - example.pdf 上述配置文件中，我们使用了 pandoc/core:latest 作为 Docker 镜像，该镜像已经预安装了 Pandoc 工具。\n该文件中包含了一个 build 阶段，其中包含了一个 pdf 任务。在 pdf 任务中，我们使用 Pandoc 工具将 Markdown 文件转换为 PDF 文件，并使用 cURL 工具将编译好的 PDF 文件上传至 GitLab Release 界面。注意，我们使用了环境变量${CI_PRIVATE_TOKEN}和${CI_API_V4_URL}，这些变量是 GitLab 自动注入的，用于进行身份验证和上传文件。\n最后，我们将编译好的 PDF 文件定义为 Pipeline 的 artifacts，这样可以确保文件能够被保留并可用于后续的部署。\n运行 Pipeline 完成 CI/CD 配置文件的编写后，我们可以在 GitLab 上启动 Pipeline，将 Markdown 文件自动编译为 PDF 并上传至 GitLab Release 界面。具体步骤如下：\n提交代码：将.gitlab-ci.yml 文件提交到 GitLab\n启动 Pipeline：在 GitLab 上打开项目，并点击“CI/CD”-\u0026gt;“Pipelines”选项卡。点击“Run Pipeline”按钮，启动 Pipeline 流程。\n等待 Pipeline 完成：在 Pipeline 启动后，GitLab 会自动创建一个 Runner 并分配任务。Pipeline 的状态会在页面上实时更新，直到 Pipeline 执行完成。\n查看 Release：Pipeline 执行完成后，我们可以在 GitLab Release 界面中找到编译好的 PDF 文件。点击 PDF 文件链接，即可下载并查看编译好的 PDF 文件。\n","permalink":"https://lifeislife.cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gitlab-ci-pipeline/","summary":"\u003cp\u003eGitLab CI/CD 是一个强大的工具，可以帮助开发团队实现自动化构建、测试和部署。本文将介绍如何使用 GitLab CI/CD 的 Pipeline 功能，以实现将 Markdown 文件自动编译为 PDF 并上传至 GitLab Release 界面的功能。\u003c/p\u003e","title":"如何使用 Gitlab CI Pipeline"},{"content":"Markdown 是支持嵌入 HTML 的，大部分阅读器也都支持解析。Draw.io 可以导出为 HTML 格式。\n文件—导出为 HTML—导出—新窗口打开—复制 HTML 代码—只保留\u0026lt;body\u0026gt;标签之间的内容，不包含\u0026lt;body\u0026gt;和\u0026lt;/body\u0026gt;。\n","permalink":"https://lifeislife.cn/posts/markdown%E5%B5%8C%E5%85%A5draw-io/","summary":"\u003cp\u003eMarkdown 是支持嵌入 HTML 的，大部分阅读器也都支持解析。Draw.io 可以导出为 HTML 格式。\u003c/p\u003e\n\u003cp\u003e文件—导出为 HTML—导出—新窗口打开—复制 HTML 代码—只保留\u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e标签之间的内容，不包含\u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e和\u003ccode\u003e\u0026lt;/body\u0026gt;\u003c/code\u003e。\u003c/p\u003e","title":"Markdown 嵌入 Draw.io"},{"content":"从 APT 安装 Install the GPG Key for https://apt.llvm.org/\nwget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - Add the repo for Clang 11 stable-old for Ubuntu 18.04 Bionic\necho \u0026#34;deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-11 main\u0026#34; | sudo tee -a /etc/apt/sources.list sudo apt-get update Install practically everything (except python-clang-11 which for some reason doesn\u0026rsquo;t work)\nsudo apt-get install libllvm-11-ocaml-dev libllvm11 llvm-11 llvm-11-dev llvm-11-doc llvm-11-examples llvm-11-runtime \\ clang-11 clang-tools-11 clang-11-doc libclang-common-11-dev libclang-11-dev libclang1-11 clang-format-11 clangd-11 \\ libfuzzer-11-dev lldb-11 lld-11 libc++-11-dev libc++abi-11-dev libomp-11-dev -y Make Clang 11 and everything related to it defaults\nsudo update-alternatives \\ --install /usr/lib/llvm llvm /usr/lib/llvm-11 50 \\ --slave /usr/bin/llvm-config llvm-config /usr/bin/llvm-config-11 \\ --slave /usr/bin/llvm-ar llvm-ar /usr/bin/llvm-ar-11 \\ --slave /usr/bin/llvm-as llvm-as /usr/bin/llvm-as-11 \\ --slave /usr/bin/llvm-bcanalyzer llvm-bcanalyzer /usr/bin/llvm-bcanalyzer-11 \\ --slave /usr/bin/llvm-cov llvm-cov /usr/bin/llvm-cov-11 \\ --slave /usr/bin/llvm-diff llvm-diff /usr/bin/llvm-diff-11 \\ --slave /usr/bin/llvm-dis llvm-dis /usr/bin/llvm-dis-11 \\ --slave /usr/bin/llvm-dwarfdump llvm-dwarfdump /usr/bin/llvm-dwarfdump-11 \\ --slave /usr/bin/llvm-extract llvm-extract /usr/bin/llvm-extract-11 \\ --slave /usr/bin/llvm-link llvm-link /usr/bin/llvm-link-11 \\ --slave /usr/bin/llvm-mc llvm-mc /usr/bin/llvm-mc-11 \\ --slave /usr/bin/llvm-mcmarkup llvm-mcmarkup /usr/bin/llvm-mcmarkup-11 \\ --slave /usr/bin/llvm-nm llvm-nm /usr/bin/llvm-nm-11 \\ --slave /usr/bin/llvm-objdump llvm-objdump /usr/bin/llvm-objdump-11 \\ --slave /usr/bin/llvm-ranlib llvm-ranlib /usr/bin/llvm-ranlib-11 \\ --slave /usr/bin/llvm-readobj llvm-readobj /usr/bin/llvm-readobj-11 \\ --slave /usr/bin/llvm-rtdyld llvm-rtdyld /usr/bin/llvm-rtdyld-11 \\ --slave /usr/bin/llvm-size llvm-size /usr/bin/llvm-size-11 \\ --slave /usr/bin/llvm-stress llvm-stress /usr/bin/llvm-stress-11 \\ --slave /usr/bin/llvm-symbolizer llvm-symbolizer /usr/bin/llvm-symbolizer-11 \\ --slave /usr/bin/llvm-tblgen llvm-tblgen /usr/bin/llvm-tblgen-11 sudo update-alternatives \\ --install /usr/bin/clang clang /usr/bin/clang-11 50 \\ --slave /usr/bin/clang++ clang++ /usr/bin/clang++-11 \\ --slave /usr/bin/lld lld /usr/bin/lld-11 \\ --slave /usr/bin/clang-format clang-format /usr/bin/clang-format-11 \\ --slave /usr/bin/clang-tidy clang-tidy /usr/bin/clang-tidy-11 \\ --slave /usr/bin/clang-tidy-diff.py clang-tidy-diff.py /usr/bin/clang-tidy-diff-11.py \\ --slave /usr/bin/clang-include-fixer clang-include-fixer /usr/bin/clang-include-fixer-11 \\ --slave /usr/bin/clang-offload-bundler clang-offload-bundler /usr/bin/clang-offload-bundler-11 \\ --slave /usr/bin/clangd clangd /usr/bin/clangd-11 \\ --slave /usr/bin/clang-check clang-check /usr/bin/clang-check-11 \\ --slave /usr/bin/scan-view scan-view /usr/bin/scan-view-11 \\ --slave /usr/bin/clang-apply-replacements clang-apply-replacements /usr/bin/clang-apply-replacements-11 \\ --slave /usr/bin/clang-query clang-query /usr/bin/clang-query-11 \\ --slave /usr/bin/modularize modularize /usr/bin/modularize-11 \\ --slave /usr/bin/sancov sancov /usr/bin/sancov-11 \\ --slave /usr/bin/c-index-test c-index-test /usr/bin/c-index-test-11 \\ --slave /usr/bin/clang-reorder-fields clang-reorder-fields /usr/bin/clang-reorder-fields-11 \\ --slave /usr/bin/clang-change-namespace clang-change-namespace /usr/bin/clang-change-namespace-11 \\ --slave /usr/bin/clang-import-test clang-import-test /usr/bin/clang-import-test-11 \\ --slave /usr/bin/scan-build scan-build /usr/bin/scan-build-11 \\ --slave /usr/bin/scan-build-py scan-build-py /usr/bin/scan-build-py-11 \\ --slave /usr/bin/clang-cl clang-cl /usr/bin/clang-cl-11 \\ --slave /usr/bin/clang-rename clang-rename /usr/bin/clang-rename-11 \\ --slave /usr/bin/find-all-symbols find-all-symbols /usr/bin/find-all-symbols-11 \\ --slave /usr/bin/lldb lldb /usr/bin/lldb-11 \\ --slave /usr/bin/lldb-server lldb-server /usr/bin/lldb-server-11 Installing CMake Install Kitware\u0026rsquo;s GPG Key\nwget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2\u0026gt;/dev/null | gpg --dearmor - | sudo tee /etc/apt/trusted.gpg.d/kitware.gpg \u0026gt;/dev/null Add repository\necho \u0026#34;deb https://apt.kitware.com/ubuntu/ bionic main\u0026#34; | sudo tee -a /etc/apt/sources.list sudo apt-get update Install this optional package so you don\u0026rsquo;t have to mess with GPG keys anymore\nsudo apt-get install kitware-archive-keyring sudo rm /etc/apt/trusted.gpg.d/kitware.gpg Now upgrade cmake if you already have it installed with sudo apt-get upgrade -y or just install it using sudo apt-get install cmake -y\n使用源码安装 # 更新软件包列表 sudo apt update # 安装必要的依赖包 sudo apt install build-essential cmake python3-dev # 下载 Clang/LLVM 11 的源代码 wget https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/llvm-11.0.0.src.tar.xz # 解压源代码文件 tar xvf llvm-11.0.0.src.tar.xz # 进入解压后的目录 cd llvm-11.0.0.src # 创建一个新的目录，用于存放 Clang/LLVM 编译的结果 mkdir build cd build # 使用 cmake 编译 Clang/LLVM cmake .. # 编译 Clang/LLVM make # 安装 Clang/LLVM sudo make install ","permalink":"https://lifeislife.cn/posts/ubuntu-18-04-%E5%AE%89%E8%A3%85clang-llvm-11/","summary":"\u003ch2 id=\"从-apt-安装\"\u003e从 APT 安装\u003c/h2\u003e\n\u003cp\u003eInstall the GPG Key for \u003ccode\u003ehttps://apt.llvm.org/\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget -O - https://apt.llvm.org/llvm-snapshot.gpg.key \u003cspan class=\"p\"\u003e|\u003c/span\u003e sudo apt-key add -\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAdd the repo for Clang 11 \u003ccode\u003estable-old\u003c/code\u003e for Ubuntu 18.04 Bionic\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-11 main\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e sudo tee -a /etc/apt/sources.list\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get update\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eInstall practically everything (except \u003ccode\u003epython-clang-11\u003c/code\u003e which for some reason doesn\u0026rsquo;t work)\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libllvm-11-ocaml-dev libllvm11 llvm-11 llvm-11-dev llvm-11-doc llvm-11-examples llvm-11-runtime \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003eclang-11 clang-tools-11 clang-11-doc libclang-common-11-dev libclang-11-dev libclang1-11 clang-format-11 clangd-11 \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003elibfuzzer-11-dev lldb-11 lld-11 libc++-11-dev libc++abi-11-dev libomp-11-dev -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eMake Clang 11 and everything related to it defaults\u003c/p\u003e","title":"Ubuntu 18.04 安装Clang/LLVM 11"},{"content":"chown 命令用来变更文件或目录的拥有者或所属群组，通过 chown 改变文件的拥有者和群组。用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的文件列表，文件名也支持通配符。\n命令格式 chown [选项] [用户或组] [文件或目录] -c或--changes #效果类似“-v”参数，但仅回报更改的部分； -f或--quite或—-silent #不显示错误信息； -h或--no-dereference #只对符号连接的文件作修改，而不更改其他任何相关文件； -R或--recursive #递归处理，将指定目录下的所有文件及子目录一并处理； -v或--version #显示指令执行过程； --dereference #效果和“-h”参数相同； --help #在线帮助 --reference=\u0026lt;参考文件或目录\u0026gt; #把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同； --version #显示版本信息。 实例 将文件test.md拥有者改为nic\nchown nic test.md 将目录/home/nic/develop及其下面的所有文件、子目录的文件拥有者改为nic\nchown -R nic /home/nic/develop ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-chown%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8B%A5%E6%9C%89%E8%80%85/","summary":"\u003cp\u003echown 命令用来变更文件或目录的拥有者或所属群组，通过 chown 改变文件的拥有者和群组。用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的文件列表，文件名也支持通配符。\u003c/p\u003e","title":"每天学命令-chown 修改文件拥有者"},{"content":"-a #显示所有文件 -d #只显示目录（名称） -l #显示链接文件的原始文件 -f #显示所列出的文件或目录的完整目录路径 -i #不以阶梯的形式显示文件或目录名称 -q #将控制字符以?字符代替，显示文件和目录名称 -N #直接显示文件或目录的名称 -p #显示每个文件的权限信息 -u #显示文件所有者或者uid -g #显示文件所属组或者gid -s #显示每个文件的大小信息 -h #以可读的方式显示文件的大小信息 -D #显示最后修改日期 -v #按字母数字正序显示文件 -r #按字母数字倒序显示文件 -t #按最后时间排序显示文件 -C #在文件和目录列表上加上色彩，便于区分文件类型 -P pattern #只显示匹配正则表式的文件或目录名称 -I pattern #与上结果相反 实例 显示当前目录及其子目录下的文件及目录名称\n$ tree . ├── CODE_OF_CONDUCT.md ├── CONTRIBUTING.md ├── Fedora-35 │ ├── Dockerfile │ └── Readme.md ├── LICENSE ├── README.md ├── Ubuntu-20 │ ├── Dockerfile │ ├── Readme.md │ ├── init_edkrepo_conf.sh │ └── ubuntu20_dev_entrypoint.sh └── Windows-2022 ├── Dockerfile └── Readme.md 3 directories, 12 files 只显示一层目录结构\n$ tree -L 1 . ├── CODE_OF_CONDUCT.md ├── CONTRIBUTING.md ├── Fedora-35 ├── LICENSE ├── README.md ├── Ubuntu-20 └── Windows-2022 3 directories, 4 files 只显示目录不显示文件\n$ tree -d . ├── Fedora-35 ├── Ubuntu-20 └── Windows-2022 3 directories ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-tree%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-a   \u003cspan class=\"c1\"\u003e#显示所有文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-d   \u003cspan class=\"c1\"\u003e#只显示目录（名称）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-l   \u003cspan class=\"c1\"\u003e#显示链接文件的原始文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-f   \u003cspan class=\"c1\"\u003e#显示所列出的文件或目录的完整目录路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-i   \u003cspan class=\"c1\"\u003e#不以阶梯的形式显示文件或目录名称\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-q   \u003cspan class=\"c1\"\u003e#将控制字符以?字符代替，显示文件和目录名称\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-N   \u003cspan class=\"c1\"\u003e#直接显示文件或目录的名称\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-p   \u003cspan class=\"c1\"\u003e#显示每个文件的权限信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-u   \u003cspan class=\"c1\"\u003e#显示文件所有者或者uid\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-g   \u003cspan class=\"c1\"\u003e#显示文件所属组或者gid\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-s   \u003cspan class=\"c1\"\u003e#显示每个文件的大小信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-h   \u003cspan class=\"c1\"\u003e#以可读的方式显示文件的大小信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-D   \u003cspan class=\"c1\"\u003e#显示最后修改日期\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-v   \u003cspan class=\"c1\"\u003e#按字母数字正序显示文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-r   \u003cspan class=\"c1\"\u003e#按字母数字倒序显示文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-t   \u003cspan class=\"c1\"\u003e#按最后时间排序显示文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-C   \u003cspan class=\"c1\"\u003e#在文件和目录列表上加上色彩，便于区分文件类型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-P pattern    \u003cspan class=\"c1\"\u003e#只显示匹配正则表式的文件或目录名称\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-I pattern    \u003cspan class=\"c1\"\u003e#与上结果相反\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"实例\"\u003e实例\u003c/h2\u003e\n\u003cp\u003e显示当前目录及其子目录下的文件及目录名称\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ tree                 \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── CODE_OF_CONDUCT.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── CONTRIBUTING.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── Fedora-35\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e│   ├── Dockerfile\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e│   └── Readme.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── LICENSE\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── README.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── Ubuntu-20\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e│   ├── Dockerfile\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e│   ├── Readme.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e│   ├── init_edkrepo_conf.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e│   └── ubuntu20_dev_entrypoint.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e└── Windows-2022\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ├── Dockerfile\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    └── Readme.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"m\"\u003e3\u003c/span\u003e directories, \u003cspan class=\"m\"\u003e12\u003c/span\u003e files\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e只显示一层目录结构\u003c/p\u003e","title":"每天学命令-tree 显示目录结构"},{"content":" ASAP: As Soon As Possible. 请尽快完成 ACK: Acknowledgement. 承认，同意。表示接受代码的改动 CR: Code Review. 请求代码审查 CCN: Code Comments Needed.需要的代码注释：在这里有一些简短的注释在高层次上描述每个主要代码块的作用（例如，“处理 HTTP 请求中的标头”）会很有帮助 DOODOO: Documentation Out Of Date Or Obsolete.文档过时或过时：此文档似乎不正确：是否过时？ DNM: Do not merge. 不要合并 ditto: 多个重复的表述，下一次可以用 ditto 表示同上 IMO: In My Opinion 在我看来、依我看、依我所见 LGT1: Looks Good To 1. 如果有一个回复 LGTM 则可以添加为 LGT1，1 代表目前有 1 个赞 LGT2: Looks Good To 2. 如果有两个回复 LGTM 则可以添加为 LGT2，2 代表目前有 2 个赞 LGTM: Looks Good To Me. 代码已经过 review，可以合并 MCE: Must Check for Errors.必须检查错误：这里可能会发生错误或异常情况，但您没有任何代码来处理此类事件 MR：merge request. 合并请求 NACK/NAK: Negative acknowledgement. 不同意，不接受这次的改动 IMHO: In My Humble Opinion IMO 谦虚的说法 IMO: In My Opinion. 在我看来 IIRC: If I Recall Correctly. 如果我没有记错的话 PR：Pull Request. 拉取请求，给其他项目提交代码 PTAL: Please Take A Look. 提示项目 Owner/contributor review RFC: Request For Comment. 请求进行讨论，表示认为某个想法很好，邀请大家一起讨论一下 RCP: Repeated Code Pattern.重复代码模式：与上面几行非常相似的代码在许多不同的地方重复出现。找到一种方法来简化它（例如，定义一个隐藏细节的更高级别的 API，或者找到一个更集中的地方来执行这些操作，这样这里就不需要这段代码了）。 SGTM: Sounds Good To Me. 和上面那句意思差不多，也是已经通过了 review 的意思 TBD: To Be Done. 未完成，待续 TL;DR: Too Long; Don’t Read. PR 内容太多，没办法看 TMLI: Too Many Levels of Indentation.Too Many Levels of Indentation：缩进太深的代码很难阅读。在大多数情况下，可以重构代码以减少嵌套级别。 WIP: Work In Progress. 告诉项目维护者这个功能还未完成，方便维护者 review 已提交的代码 TBR: To Be Reviewed. 提示维护者进行 review TBD: To Be Done (or Defined/Discussed/Decided/Determined). 根据语境不同意义有所区别，但一般都是还没搞定的意思 ","permalink":"https://lifeislife.cn/posts/codereview%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%BC%A9%E5%86%99/","summary":"\u003cul\u003e\n\u003cli\u003eASAP: As Soon As Possible. 请尽快完成\u003c/li\u003e\n\u003cli\u003eACK: Acknowledgement. 承认，同意。表示接受代码的改动\u003c/li\u003e\n\u003cli\u003eCR: Code Review. 请求代码审查\u003c/li\u003e\n\u003cli\u003eCCN: Code Comments Needed.需要的代码注释：在这里有一些简短的注释在高层次上描述每个主要代码块的作用（例如，“处理 HTTP 请求中的标头”）会很有帮助\u003c/li\u003e\n\u003cli\u003eDOODOO: Documentation Out Of Date Or Obsolete.文档过时或过时：此文档似乎不正确：是否过时？\u003c/li\u003e\n\u003cli\u003eDNM: Do not merge. 不要合并\u003c/li\u003e\n\u003cli\u003editto: 多个重复的表述，下一次可以用 ditto 表示同上\u003c/li\u003e\n\u003cli\u003eIMO: In My Opinion 在我看来、依我看、依我所见\u003c/li\u003e\n\u003cli\u003eLGT1: Looks Good To 1. 如果有一个回复 LGTM 则可以添加为 LGT1，1 代表目前有 1 个赞\u003c/li\u003e\n\u003cli\u003eLGT2: Looks Good To 2. 如果有两个回复 LGTM 则可以添加为 LGT2，2 代表目前有 2 个赞\u003c/li\u003e\n\u003cli\u003eLGTM: Looks Good To Me. 代码已经过 review，可以合并\u003c/li\u003e\n\u003cli\u003eMCE: Must Check for Errors.必须检查错误：这里可能会发生错误或异常情况，但您没有任何代码来处理此类事件\u003c/li\u003e\n\u003cli\u003eMR：merge request. 合并请求\u003c/li\u003e\n\u003cli\u003eNACK/NAK: Negative acknowledgement. 不同意，不接受这次的改动\u003c/li\u003e\n\u003cli\u003eIMHO: In My Humble Opinion IMO 谦虚的说法\u003c/li\u003e\n\u003cli\u003eIMO: In My Opinion. 在我看来\u003c/li\u003e\n\u003cli\u003eIIRC: If I Recall Correctly. 如果我没有记错的话\u003c/li\u003e\n\u003cli\u003ePR：Pull Request. 拉取请求，给其他项目提交代码\u003c/li\u003e\n\u003cli\u003ePTAL: Please Take A Look. 提示项目 Owner/contributor review\u003c/li\u003e\n\u003cli\u003eRFC: Request For Comment. 请求进行讨论，表示认为某个想法很好，邀请大家一起讨论一下\u003c/li\u003e\n\u003cli\u003eRCP: Repeated Code Pattern.重复代码模式：与上面几行非常相似的代码在许多不同的地方重复出现。找到一种方法来简化它（例如，定义一个隐藏细节的更高级别的 API，或者找到一个更集中的地方来执行这些操作，这样这里就不需要这段代码了）。\u003c/li\u003e\n\u003cli\u003eSGTM: Sounds Good To Me. 和上面那句意思差不多，也是已经通过了 review 的意思\u003c/li\u003e\n\u003cli\u003eTBD: To Be Done. 未完成，待续\u003c/li\u003e\n\u003cli\u003eTL;DR: Too Long; Don’t Read. PR 内容太多，没办法看\u003c/li\u003e\n\u003cli\u003eTMLI: Too Many Levels of Indentation.Too Many Levels of Indentation：缩进太深的代码很难阅读。在大多数情况下，可以重构代码以减少嵌套级别。\u003c/li\u003e\n\u003cli\u003eWIP: Work In Progress. 告诉项目维护者这个功能还未完成，方便维护者 review 已提交的代码\u003c/li\u003e\n\u003cli\u003eTBR: To Be Reviewed. 提示维护者进行 review\u003c/li\u003e\n\u003cli\u003eTBD: To Be Done (or Defined/Discussed/Decided/Determined). 根据语境不同意义有所区别，但一般都是还没搞定的意思\u003c/li\u003e\n\u003c/ul\u003e","title":"CodeReview 中常见缩写"},{"content":"打开 Word 很快，但是一编辑就特别卡，尤其时拖动表格时几乎是逐帧移动。这是硬件图形加速问题。解决方式如下。\n打开 Word，点击左上角—\u0026gt;文件—\u0026gt;选项—\u0026gt;高级，一直拉到“显示”； 勾选禁用硬件图形加速； 取消勾选子像素定位平滑屏幕上的字体。 \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/office-%E8%A7%A3%E5%86%B3word%E7%BC%96%E8%BE%91%E5%8D%A1%E9%A1%BF/","summary":"\u003cp\u003e打开 Word 很快，但是一编辑就特别卡，尤其时拖动表格时几乎是逐帧移动。这是硬件图形加速问题。解决方式如下。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e打开 Word，点击左上角—\u0026gt;文件—\u0026gt;选项—\u0026gt;高级，一直拉到“显示”；\u003c/li\u003e\n\u003cli\u003e勾选\u003cstrong\u003e禁用硬件图形加速\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e取消勾选\u003cstrong\u003e子像素定位平滑屏幕上的字体\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/12/03/7215b5c4712d13d43182a8c610d64c37.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/12/03/7215b5c4712d13d43182a8c610d64c37.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"OFFICE-解决 Word 编辑卡顿"},{"content":"将仓库git clone到本地后发现本地缺失了一些远程仓库的分支。一般发生在git clone —depth 1设置克隆深度时发生。因为有些大型项目一次性克隆容易出错，所以只克隆一层深度。\n如远程有分支branch_a，克隆下来后使用git branch -av命令查看所有分支没有显示该分支，该如何解决？\ngit remote set-branches origin \u0026#39;branch_a\u0026#39; git fetch -v ","permalink":"https://lifeislife.cn/posts/git-clone%E4%B8%8B%E6%9D%A5%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8D%E5%AE%8C%E6%95%B4/","summary":"\u003cp\u003e将仓库\u003ccode\u003egit clone\u003c/code\u003e到本地后发现本地缺失了一些远程仓库的分支。一般发生在\u003ccode\u003egit clone —depth 1\u003c/code\u003e设置克隆深度时发生。因为有些大型项目一次性克隆容易出错，所以只克隆一层深度。\u003c/p\u003e","title":"Git clone下来的分支不完整"},{"content":"提交补丁的最佳实践 本文翻译自官方教程Git - MyFirstContribution，原文包含开发到提交的整个周期。但是想要提交的人应该都已经开发完代码了，所以本文用自己的实际例子重新写了一遍，省去了开发代码等流程，重点介绍如何使用 git send-email。\n环境准备 下载 OpenSBI 仓库 git clone https://github.com/riscv-software-src/opensbi.git cd opensbi 安装依赖 要从源代码构建 OpenSBI：\nmake 注：OpenSBI 的构建是可并行的。上面的命令可以添加-j#参数，如-j12。\n确认要解决的问题 在本文档中，我们将模拟提交一个简单的 Patch，.gitignore文件可以过滤不必要的文件，现在使用 VSCode 的用户越来越多，使用 VSCode 开发时常常会生成.vscode目录，但是这些文件不该被推送至远程，原仓库中的.gitignore文件中没有过滤该文件，我们给他加上。\n为了能够模拟一次发送多个commit的场景，我们将再添加一个.so用来过滤编译过程中生成的.so文件。\n建立工作空间 让我们先建立一个开发分支来进行我们的修改。\ngit checkout -b update_gitignore origin/master 我们将在这里做一些提交，以演示如何将一个带有多个补丁的主题同时送审。\n实现代码 过滤 .vscode 打开文件.gitignore，为该文件添加/.vscode/：\n# Object files *.o *.a *.dep #Build \u0026amp; install directories build/ install/ # Development friendly files tags cscope* /.vscode/ 为以上修改做一次提交：\n$ git status On branch update_gitignore Your branch is up to date with \u0026#39;origin/master\u0026#39;. Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: .gitignore $ git add .gitignore $ git commit -s 执行以上命令后将会弹出编辑框用来编写提交信息。主题行要少于 50 个字符，然后是一个空行（必须），然后是您的提交消息的正文。请记住要明确并提供更改的原因（理由），特别是如果无法从您的差异中轻松理解你的提交内容时。编辑提交消息时，不要删除上面 Signed-off-by 添加的 trailer。（由上面命令-s参数生成）。\n其他规范请详细查阅目标社区的提交规范，如OpenSBI要求主题行需要以 lib:， platform:, firmware:, docs:, utils: 或者 top:为前缀，修改.gitignore属于top范畴，所以我们需要将其加在主题行上。\ntop: filter .vscode folder Filter the workspace\u0026#39;s \u0026#39;.vscode\u0026#39; directory by adding \u0026#39;/.vscode/\u0026#39; to the.gitignore file. Signed-off-by: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; 继续用 git show 检查您的新提交。尤其不要出现不需要在本次提交的内容。通常使用不同的 IDE 都可能会无意间生成一些配置文件等，请注意将其剔除。\ncommit 5dc340c29979d4c5d8c4d5a6e881348239714434 (HEAD -\u0026gt; update_gitignore) Author: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; Date: Fri Nov 18 16:06:21 2022 +0800 top: filter .vscode folder Filter the workspace\u0026#39;s \u0026#39;.vscode\u0026#39; directory by adding \u0026#39;/.vscode/\u0026#39; to the.gitignore file. Signed-off-by: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; diff --git a/.gitignore b/.gitignore index 95692bb..90cf552 100644 --- a/.gitignore +++ b/.gitignore @@ -10,3 +10,5 @@ install/ # Development friendly files tags cscope* + +/.vscode/ 过滤 .cache 与上一节步骤类似，我们在.gitignore文件中再添加一个/.cache/字段用来过滤.cache文件夹。\n# Object files *.o *.a *.dep #Build \u0026amp; install directories build/ install/ # Development friendly files tags cscope* /.vscode/ /.cache/ 添加完我们就即使保存工作进度，新生成一个commit。\ngit add .gitignore git commit -s top: filter .cache folder Filter the workspace\u0026#39;s \u0026#39;.cache\u0026#39; directory by adding \u0026#39;/.cache/\u0026#39; to the.gitignore file. Signed-off-by: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; 以上我们就已经准备好所有的代码了，在大部分场景下可能修改的是.c或者.h等源文件，这就需要我们能够使代码编译、运行并且测试通过后再提交。\n这里为了演示提交流程，就没有涉及这些步骤。接下来我们就要准备提交的补丁文件了。\n准备提交补丁 OpenSBI 项目是通过电子邮件发送补丁来进行代码审查的，当补丁准备好并得到社区认可后，维护者就会应用（Apply）这些补丁。OpenSBI 项目不接受来自 Pull Request 的贡献，而且通过电子邮件发送的补丁需要以指定的方式进行审核。\n在研究如何将你的提交转化为电子邮件的补丁之前，让我们先分析一下最终的结果，即补丁系列（Patch Series）是什么样子。下面是 OpenSBI 邮件列表存档的网页界面上的补丁系列的摘要视图的一个例子。\n\u003c!DOCTYPE html\u003e Responsive Image 我们可以注意几点：\n每次提交都是以单独的邮件形式发送，提交信息的标题为主题，前缀为[PATCH i/n]，代表n个提交系列中的第 i 个提交。 每个补丁都是作为对cover letter的回复，cover letter的前缀为[PATCH 0/n]，序号为 0 的标题。 补丁系列的后续迭代被标记为 PATCH v2、PATCH v3，等等，以代替 PATCH。例如，[PATCH v2 1/3]将是第二次迭代中三个补丁的第一个补丁。每次迭代都有一个新的cover letter（如上面的[PATCH v2 0/3]），本身就是对前一次迭代的cover letter的回复（下面会有更多介绍）。 注：单一补丁的主题是以[PATCH]、[PATCH v2]等发送的，没有 i/n 编号。如上图中的第四个 Patch，就是一个单一补丁。\n什么是 cover letter 除了给每个补丁发一封邮件外，OpenSBI 社区还希望你的补丁能附带一封 cover letter。这是修改提交的一个重要组成部分，因为它概括了你想要做什么，以及为什么要这样做，比仅仅看你的补丁更明显。\n你的 cover letter 的标题应该是能简洁地涵盖你整个主题分支的目的。就像我们的提交信息标题一样。下面是我们的系列标题。\nUpdate gitignore --- cover letter 的正文是用来给评审员提供额外的背景。一定要解释任何你的补丁自己没有说清楚的东西，但要记住，由于 cover letter 没有记录在提交历史中，任何可能对未来版本库历史的读者有用的东西也应该在你的提交信息中出现。\n下文我们将介绍如何生成 cover letter 以及如何填写 cover letter。\n用 git send-email 发送补丁 前提条件 - 设置 git send-email 对 send-email 的配置会根据你的操作系统和电子邮件供应商而有所不同，配置可以参考文档如何使用 git-send-mail 给开源社区提交 Patch - 如云泊。\n准备初始补丁集 在准备邮件本身之前，你需要准备补丁。\ngit format-patch --cover-letter -o update_gitignore/ --base=auto update_gitignore@{u}..update_gitignore --cover-letter 选项告诉 format-patch 为你创建一个 cover letter 模板。在你准备发送之前，你将需要填写该模板。 -o update_gitignore/ 选项告诉 format-patch 把补丁文件放到目录update_gitignore中。这样发送多个commit时就可以使用命令一次性发送，因为 git send-email 可以接收一个目录并从那里发送所有补丁。 --base=auto 选项告诉命令记录”基本提交”，接收者将在此基础上应用补丁系列。自动值将使 format-patch 自动计算基本提交，即远程跟踪分支的最新提交和指定修订范围的合并基数。 update_gitignore@{u}..update_gitignore 选项告诉 format-patch 为你在 update_gitignore 分支上创建的提交生成补丁，因为它是从上游分叉出来的。@{u}的意思就是从分叉开始到最新的提交。 执行完该命令我们看看生成了哪些内容。\n$ git status On branch update_gitignore Your branch is ahead of \u0026#39;origin/master\u0026#39; by 2 commits. (use \u0026#34;git push\u0026#34; to publish your local commits) Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) update_gitignore/ $ ls update_gitignore 0000-cover-letter.patch 0001-top-filter-.vscode-folder.patch 0002-top-filter-.cache-folder.patch 该命令将为每次提交制作一个补丁文件。运行后，您可以用您喜欢的文本编辑器看一下每个补丁，确保一切正常。可以看到创建了一个-o参数中的update_gitignore文件夹，该文件夹下有三个文件，分别是 cover letter 和上文我们做的两次提交对应的补丁文件。\n分别打开他们，结果如下：\nFrom 30614e5469be4a2f930cca570836627a4e91f1d1 Mon Sep 17 00:00:00 2001 From: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; Date: Fri, 18 Nov 2022 16:41:32 +0800 Subject: [PATCH 0/2] *** SUBJECT HERE *** *** BLURB HERE *** Dominic Zhang (2): top: filter .vscode folder top: filter .cache folder .gitignore | 3 +++ 1 file changed, 3 insertions(+) base-commit: 880685586dcee950d209088a461443449a1693ce -- 2.17.1 From 5dc340c29979d4c5d8c4d5a6e881348239714434 Mon Sep 17 00:00:00 2001 From: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; Date: Fri, 18 Nov 2022 16:06:21 +0800 Subject: [PATCH 1/2] top: filter .vscode folder Filter the workspace\u0026#39;s \u0026#39;.vscode\u0026#39; directory by adding \u0026#39;/.vscode/\u0026#39; to the.gitignore file. Signed-off-by: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; --- .gitignore | 2 ++ 1 file changed, 2 insertions(+) diff --git a/.gitignore b/.gitignore index 95692bb..90cf552 100644 --- a/.gitignore +++ b/.gitignore @@ -10,3 +10,5 @@ install/ # Development friendly files tags cscope* + +/.vscode/ \\ No newline at end of file -- 2.17.1 From 30614e5469be4a2f930cca570836627a4e91f1d1 Mon Sep 17 00:00:00 2001 From: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; Date: Fri, 18 Nov 2022 16:20:37 +0800 Subject: [PATCH 2/2] top: filter .cache folder Filter the workspace\u0026#39;s \u0026#39;.cache\u0026#39; directory by adding \u0026#39;/.cache/\u0026#39; to the.gitignore file. Signed-off-by: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; --- .gitignore | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-) diff --git a/.gitignore b/.gitignore index 90cf552..bf9d716 100644 --- a/.gitignore +++ b/.gitignore @@ -11,4 +11,5 @@ install/ tags cscope* -/.vscode/ \\ No newline at end of file +/.vscode/ +/.cache/ \\ No newline at end of file -- 2.17.1 注：另外，你也可以使用 --rfc 参数，在你的补丁主题前加上[RFC PATCH]，而不是[PATCH]。RFC 是”请求评论”的意思，表示虽然你的代码还没有准备好提交，但你想开始代码审查过程。你也可能在列表中看到标有”WIP”的补丁，这意味着他们还没有完成，但希望审查者能看看他们目前的成果。你可以用--subject-prefix=WIP来添加这个标志。\n检查并确保你的补丁和 cover letter 模板存在于你指定的目录中，这就完成所有准备了。\n准备邮件 由于你在调用 format-patch 时使用了--cover-letter，你已经准备好了一个 cover letter 模板。在你喜欢的编辑器中打开它。\n你应该看到已经有一些标题存在。检查你的From:标题是否正确。然后修改你的Subject:。\n确保保留[PATCH 0/X]的部分；这是向 Git 社区表明这封邮件是一个补丁系列的开始，许多审查者会根据这种类型的标记过滤他们的邮件。\n接下来，你必须填写你的 cover letter 的正文。同样，关于应包括哪些内容，见上文。\n最后，信中会包括用于生成补丁的 Git 的版本。你可以不用管这个字符串。\n完善后的 cover letter 如下：\nFrom 30614e5469be4a2f930cca570836627a4e91f1d1 Mon Sep 17 00:00:00 2001 From: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; Date: Fri, 18 Nov 2022 16:41:32 +0800 Subject: [PATCH 0/2] Update gitignore vscode is a very popular IDE, and it often needs to generate a.vscode. cache directory to hold workspace configuration files that should not be committed to a remote repository, so we made some modifications to the gitignore file to filter such directories. Dominic Zhang (2): top: filter .vscode folder top: filter .cache folder .gitignore | 3 +++ 1 file changed, 3 insertions(+) base-commit: 880685586dcee950d209088a461443449a1693ce -- 2.17.1 发送邮件 到这里，你应该有一个目录 update_gitignore/，里面包含你的补丁和一封 cover letter。是时候把它发出去了！你可以像这样发送。\ngit send-email --to=target@example.com update_gitignore/*.patch 注：请查看 git help send-email 中的一些其他选项，你可能会发现这些选项很有价值，比如改变回复地址或添加更多的抄送地址或密送地址。\n注：当你发送一个真正的补丁时，它将被发送到 opensbi@lists.infradead.org - 但请不要把你的补丁集从教程中发送到真正的邮件列表中！现在你可以把它发送给你自己，以确保你了解它的形式。\n在你运行上面的命令后，你会为每个即将发出的补丁看到一个交互提示。这给了你最后一次机会来编辑或放弃发送一些东西（但还是那句话，不要用这种方式编辑代码）。一旦你在这些提示下按下 y 或 a，你的邮件就会被发送出去！Congratulation!\n发送补丁的更新版本 本节将重点介绍如何发送你的补丁集的 v2 版。我们将在 v2 版中重新使用我们的 update_gitignore 分支。在我们做任何改动之前，我们先新建一个名为update_gitignore-v1的分支，这个分支是我们没有做新的改动的分支。这样在后面我们就可以方便的进行对比差异。\ngit checkout update_gitignore git branch update_gitignore-v1 在更新补丁时，我们可能会遇到两种情况，一种是社区的意见只让修改最新的一个提交，一种是修改历史记录中的 commit。我们分别来处理这两种情况。\n如何修改最新的提交 比如只需要修改top: filter .cache folder这个 commit。因为它在我们的修改中是最新的 commit，所以我们可以直接对代码修改。比如我们做一个简单的修改，给修改的内容/.cache加个注释。\n# Object files *.o *.a *.dep #Build \u0026amp; install directories build/ install/ # Development friendly files tags cscope* /.vscode/ # Cache file /.cache/ git add .gitignore git commit --amend 注意！我们不需要生成新的commit，所以使用 --amend参数修改最新的commit message即可。执行这条命令会弹出编辑窗口，因为修改内容已经很明确，我们不需要在commit message里再做额外说明，直接保存退出即可。如果修改内容比较大，需要重新编写commit message。\n以上我们就完成了一次更新。\n如何修改历史记录中的提交 如果很不巧，社区要求修改的是top: filter .vscode folder这个提交的内容，那怎么办，因为它不是最新的提交，而是上一个提交，我们无法使用git commit --amend来直接对他修改，好在 Git 十分强大，不需要我们reset就可以完成这样的工作。\n同样我们也做一个简单的修改，为/.vscode/也添加一个注释。首先我们需要使用到git rebase这个强大的命令。本文只介绍使用到的功能，其他功能需要大家自行摸索。\ngit rebase -i 这条命令会弹出编辑窗口，-i参数表示以交互式方式进行变基（rebase）操作。弹出窗口内容如下：\npick 7175772 top: filter .vscode folder pick 52b63f3 top: filter .cache folder # Rebase 8806855..52b63f3 onto 8806855 (2 commands) # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \u0026#34;squash\u0026#34;, but discard this commit\u0026#39;s log message # x, exec = run command (the rest of the line) using shell # d, drop = remove commit # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out 窗口会显示所有未提交到远程的 commit，下面的注释也告诉了我们该如何使用。我们找到edit的行，可以看到解释为使用当前的 commit，但是在变基过程中会停下来让我们修改。这正是我们想要的。我们编辑当前的内容如下：\nedit 7175772 top: filter .vscode folder pick 52b63f3 top: filter .cache folder 表示我们需要编辑历史记录中的top: filter .vscode folder提交，但是另一个 commit 我们不做改变。保存并退出当前窗口后，会有如下提示。\nStopped at 7175772... top: filter .vscode folder You can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue 根据提示，我们可以进行一系列修改了，修改完使用git commit --amend保存，如果一切符合自己要求了，再使用git rebase --continue完成变基操作。\n我们先修改代码，可以看到代码已经回到了没有/.cache/的状态，我们添加一行注释：\n# Object files *.o *.a *.dep #Build \u0026amp; install directories build/ install/ # Development friendly files tags cscope* # VSCode config file /.vscode/ git add .gitignore git commit --amend 同样弹出窗口后我们直接保存退出，如果修改幅度较大，可以进一步补充说明。然后使用以下命令继续完成变基。\ngit rebase --continue 此时我们可以看到我们不仅修改了历史记录中的 commit，还保证了最新的 commit 没有丢失或者更改。\n准备更新版本的补丁集 $ git format-patch -v2 --cover-letter -o update_gitignore/ master..update_gitignore-v1 update_gitignore/v2-0000-cover-letter.patch update_gitignore/v2-0001-top-filter-.vscode-folder.patch update_gitignore/v2-0002-top-filter-.cache-folder.patch --range-diff master..update_gitignore-v1 参数告诉 format-patch 在 cover letter 中包括 update_gitignore-v1 和 update_gitignore 两个分支之间的差异。这有助于告诉评审人你的 v1 和 v2 补丁之间的差异。\n-v2 参数告诉 format-patch 将你的补丁输出为 v2 版本。例如，你可能注意到你的 v2 版补丁都被命名为 v2-000n-my-commit-subject.patch。-v2 也会将你的补丁格式化，在前面加上[PATCH v2]，而不是[PATCH]。\n运行此命令后，format-patch 会将补丁输出到 update_gitignore/ 目录，与 v1 版的补丁一起。使用一个目录可以方便在校对 v2 补丁时参考旧的 v1 补丁，但你需要注意只发送 v2 补丁。我们将使用 update_gitignore/v2-.patch这样的模式（而不是 update_gitignore/.patch，这将匹配 v1 和 v2 补丁）。\n再次编辑你的 cover letter。现在是一个很好的时间来提及你的上一个版本和现在有什么不同，如果它是重要的东西。你不需要在你的第二封 cover letter 中使用完全相同的内容；重点是向审查人员解释你所做的可能不那么明显的变化。\n我们就简单的写一下添加了注释。\nFrom 30614e5469be4a2f930cca570836627a4e91f1d1 Mon Sep 17 00:00:00 2001 From: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; Date: Fri, 18 Nov 2022 19:35:06 +0800 Subject: [PATCH v2 0/2] Update gitignore Add a comment for the folder name. Dominic Zhang (2): top: filter .vscode folder top: filter .cache folder .gitignore | 3 +++ 1 file changed, 3 insertions(+) -- 2.17.1 发送更新版本时你需要将新版本抄送给提出建议的人，你可以在你的 cover letter 中直接添加这些抄送行，在 Subject 行上面写上这样一行。\nCC: Name \u0026lt;name@example.com\u0026gt; 例如，把更新的邮件抄送给我自己：\nFrom 30614e5469be4a2f930cca570836627a4e91f1d1 Mon Sep 17 00:00:00 2001 From: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; CC: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; Date: Fri, 18 Nov 2022 19:35:06 +0800 Subject: [PATCH v2 0/2] Update gitignore Add a comment for the folder name. Dominic Zhang (2): top: filter .vscode folder top: filter .cache folder .gitignore | 3 +++ 1 file changed, 3 insertions(+) -- 2.17.1 现在再次发送电子邮件，注意你传入的参数。\ngit send-email --to target@example.com update_gitignore/v2-*.patch 恭喜你完成了一次补丁版本更新。\n对于一些社区，要求更新的版本需要在同一个 thread 上进行。如下示例这样：\n[PATCH 0/2] Here is what I did... [PATCH 1/2] Clean up and tests [PATCH 2/2] Implementation [PATCH v2 0/3] Here is a reroll [PATCH v2 1/3] Clean up [PATCH v2 2/3] New tests [PATCH v2 3/3] Implementation 就是更新的版本需要关联到之前的版本，而不能作为单独的一个列表。\n你还需要去找到你之前的 cover letter 的 Message-Id。你可以在发送第一个补丁系列时，从 git send-email 的输出中记下它。 例如：\n$ git send-email --to Dominic Zhang@gmail.com update_gitignore/v2-*.patch update_gitignore/v2-0000-cover-letter.patch update_gitignore/v2-0001-top-filter-.vscode-folder.patch update_gitignore/v2-0002-top-filter-.cache-folder.patch (mbox) Adding cc: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt; from line \u0026#39;From: Dominic Zhang \u0026lt;Dominic Zhang@gmail.com\u0026gt;\u0026#39; (mbox) Adding cc: Dominic Zhang \u0026lt;254758318@qq.com\u0026gt; from line \u0026#39;CC: Dominic Zhang \u0026lt;254758318@qq.com\u0026gt;\u0026#39; From: Dominic Zhang@gmail.com To: Dominic Zhang@gmail.com Cc: Dominic Zhang \u0026lt;254758318@qq.com\u0026gt; Subject: [PATCH v2 0/2] Update gitignore Date: Fri, 18 Nov 2022 19:54:54 +0800 Message-Id: \u0026lt;20221118115456.2242-1-Dominic Zhang@gmail.com\u0026gt; X-Mailer: git-send-email 2.17.1 你也可以从社区的邮箱列表中找到 Message ID，因为 OpenSBI 不要求在同一个 thread 回复，所以没有相关信息，这里以Git 社区的邮箱列表为例。随便点击一个补丁主题，在页面中找到permalink或者raw，点击打开即可找到 Message ID 信息。\n它的格式一般如下：\nMessage-Id: \u0026lt;foo.12345.author@example.com\u0026gt; \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 如果要发送更新版本，那么我们就需要找到上一版本的 Message ID。如发送的是 V3 版本，那么我们需要找到 V2 版本的 Message ID。并且在发送邮件时添加如下参数：\n$ git send-email --to Dominic Zhang@gmail.com --in-reply-to=\u0026#34;\u0026lt;foo.12345.author@example.com\u0026gt;\u0026#34; update_gitignore/v2-*.patch 只有一个 Patch 的更改 在某些情况下，你的非常小的变化可能只包括一个补丁。这时，你只需要发送一封邮件。你的提交信息应该已经很有意义了，你只需要生成补丁文件就可以发送了。\ngit format-patch -o update_gitignore/ HEAD^ HEAD^参数表示生成与上一个提交之间的差异。 ","permalink":"https://lifeislife.cn/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%90%91%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E6%8F%90patch/","summary":"\u003ch1 id=\"提交补丁的最佳实践\"\u003e提交补丁的最佳实践\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文翻译自官方教程\u003ca href=\"https://git-scm.com/docs/MyFirstContribution\"\u003eGit - MyFirstContribution\u003c/a\u003e，原文包含开发到提交的整个周期。但是想要提交的人应该都已经开发完代码了，所以本文用自己的实际例子重新写了一遍，省去了开发代码等流程，重点介绍如何使用 git send-email。\u003c/p\u003e","title":"手把手教你向开源社区提 Patch"},{"content":"确认 Debian 版本 $ cat /etc/os-release PRETTY_NAME=\u0026#34;Debian GNU/Linux 10 (buster)\u0026#34; NAME=\u0026#34;Debian GNU/Linux\u0026#34; VERSION_ID=\u0026#34;10\u0026#34; VERSION=\u0026#34;10 (buster)\u0026#34; VERSION_CODENAME=buster ID=debian HOME_URL=\u0026#34;https://www.debian.org/\u0026#34; SUPPORT_URL=\u0026#34;https://www.debian.org/support\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.debian.org/\u0026#34; 括号里的buster就是版本信息。\n获取镜像地址 打开debian | 清华大学开源软件镜像站，选择buster版本，复制所有镜像地址。\n\u003c!DOCTYPE html\u003e Responsive Image # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free 备份原文件 这也算是系统文件的一部分，还是保险一点，出错了再改回来。\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 打开并修改 sudo vim /etc/apt/sources.list vim用的不习惯的估计会和我一样找全选内容怎么操作。教给你了 在命令模式下，就是按一下esc键，然后输入ggvG。具体什么含义看VIM 笔记吧，选择后直接delete删除，镜像地址粘贴进去。保存退出。\n更新 sudo apt-get update sudo apt-get dist-upgrade sudo apt-get upgrade ","permalink":"https://lifeislife.cn/posts/linux%E6%9B%B4%E6%8D%A2debian%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/","summary":"\u003ch2 id=\"确认-debian-版本\"\u003e确认 Debian 版本\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ cat /etc/os-release               \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003ePRETTY_NAME\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Debian GNU/Linux 10 (buster)\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eNAME\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Debian GNU/Linux\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eVERSION_ID\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;10\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eVERSION\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;10 (buster)\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eVERSION_CODENAME\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ebuster\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eID\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003edebian\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eHOME_URL\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;https://www.debian.org/\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eSUPPORT_URL\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;https://www.debian.org/support\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eBUG_REPORT_URL\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;https://bugs.debian.org/\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e括号里的\u003ccode\u003ebuster\u003c/code\u003e就是版本信息。\u003c/p\u003e\n\u003ch2 id=\"获取镜像地址\"\u003e获取镜像地址\u003c/h2\u003e\n\u003cp\u003e打开\u003ca href=\"https://mirrors.tuna.tsinghua.edu.cn/help/debian/\"\u003edebian | 清华大学开源软件镜像站\u003c/a\u003e，选择\u003ccode\u003ebuster\u003c/code\u003e版本，复制所有镜像地址。\u003c/p\u003e","title":"更换 Debian 软件更新源"},{"content":"转载自huth (Thomas Huth)的一篇文章，原文已经 404，从网页快照中找回的文章。\nNote that this is a blog post for (new) QEMU developers. If you are just interested in using QEMU, you can certainly skip this text. Otherwise, in case you have ever been in touch with the QEMU device model (\u0026ldquo;qdev\u0026rdquo;), you are likely aware of the basic qdev code boilerplate already:\nstatic void mydev_realize(DeviceState *dev, Error **errp) { } static void mydev_instance_init(Object *obj) { } static Property mydev_properties[] = { DEFINE_PROP_xxx(\u0026#34;myprop\u0026#34;, MyDevState, field, ...), DEFINE_PROP_END_OF_LIST(), }; static void mydev_class_init(ObjectClass *oc, void *data) { DeviceClass *dc = DEVICE_CLASS(oc); dc-\u0026gt;realize = mydev_realize; dc-\u0026gt;desc = \u0026#34;My cool device\u0026#34;; dc-\u0026gt;props = mydev_properties; } static const TypeInfo mydev_info = { .name = TYPE_MYDEV, .parent = TYPE_SYS_BUS_DEVICE, .instance_size = sizeof(mydev_state), .instance_init = mydev_instance_init, .class_init = mydev_class_init, }; static void mydev_register_types(void) { type_register_static(\u0026amp;mydev_info); } type_init(mydev_register_types) There are three different initialization functions involved here, the class_init, the instance_init and the realize function. While it is quite obvious to distinguish the class_init function from the two others (it is used for initializing the class data, not the data that is used for an instance … this is similar to the object model with classes and instances in C++), I initially always wondered about the difference between the instance_init() and the realize() functions. Having fixed quite a lot of related bugs in the past months in the QEMU code base, I now know that a lot of other people are also not properly aware of the difference here, so I think it is now time to write down some information that I\u0026rsquo;m now aware of, to make sure that I don\u0026rsquo;t forget about this again, and maybe help others to avoid related bugs in the future ;-)\nFirst it is of course always a good idea to have a look at the documentation. While the documentation of TypeInfo (where instance_init() is defined) is not very helpful to understand the differences, the documentation of DeviceClass (where realize() is defined) has some more useful information: You can learn here that the object instantiation is done first, before the device is realized, i.e. the instance_init() function is called first, and the realize() function is called afterwards. The former must not fail, while the latter can return an error to its caller via a pointer to an “Error” object pointer.\nSo the basic idea here is that device objects are first instantiated, then these objects can be inspected for their interfaces and their creators can set up their properties to configure their settings and wire them up with other devices, before the device finally becomes \u0026ldquo;active\u0026rdquo; by being realized. It is important here to notice that devices can be instantiated (and also finalized) without being realized! This happens for example if the device is introspected: If you enter for example device_add xyz,help at the HMP monitor, or if you send the device-list-properties QOM command to QEMU to retrieve the device\u0026rsquo;s properties, QEMU creates a temporary instance of the device to query the properties of the object, without realizing it. The object gets destroyed (\u0026ldquo;finalized\u0026rdquo;) immediately afterwards.\nKnowing this, you can avoid a set of bugs which could be found with a couple of devices in the past:\nIf you want your device to provide properties for other parts of the QEMU code or for the users, and you want to add those properties via one of the many object_property_add*() functions of QEMU (instead of using the “props” field of the DeviceClass), then you should do this in the instance_init() and not in the realize() function. Otherwise the properties won\u0026rsquo;t show up when the user runs --device xyz,help or the device-list-properties QOM command to get some information about your device. instance_init() functions must really never fail, i.e. also not call abort() or exit(). Otherwise QEMU can terminate unexpectedly when a user simply wanted to have a look at the list of device properties with device_add xyz,help or the device-list-properties QOM command. If your device cannot work in certain circumstances, check for the error condition in the realize() function instead and return with an appropriate error there. Never assume that your device is always instantiated only with the machine that it was designed for. It\u0026rsquo;s of course a good idea to set the “user_creatable = false” flag in the DeviceClass of your device if your device cannot be plugged in arbitrary machines. But device introspection can still happen at any time, with any machine. So if you wrote a device called \u0026ldquo;mydev-a\u0026rdquo; that only works with --machine A, the user still can start QEMU with the option --machine B instead and then run device_add mydev-a,help or the device-list-properties QOM command. The instance_init() function of your device will be called to create a temporary instance of your device, even though the base machine is B and not A here. So you especially should take care to not depend on the availability of certain buses or other devices in the instance_init() function, nor use things like serial_hd() or nd_table[] in your instance_init() function, since these might (and should) have been used by the machine init function already. If your device needs to be wired up, provide properties as interfaces to the outside and let the creator of your device (e.g. the machine init code) wire your device between the device instantiation and the realize phase instead. Make sure that your device leaves a clean state after a temporary instance is destroyed again, i.e. don\u0026rsquo;t assume that there will be only one instance of your device which is created at the beginning right after QEMU has been started and is destroyed at the very end before QEMU terminates. Thus do not assume that the things that you do in your instance_init() don\u0026rsquo;t need explicit clean-up since the device instance will only be destroyed when QEMU terminates. Device instances can be created and destroyed at any time, so when the device is finalized, you must not leave any dangling pointers or references to your device behind you, e.g. in the QOM tree. When you create other objects in your instance_init() function, make sure to set proper parents of these objects or use an instance_finalize() function, so that the created objects get cleaned up correctly again when your device is destroyed. All in all, if you write code for a new QEMU device, it is likely a good idea to use the instance_init() function only for e.g. creating properties and other things that are required before device realization, and then do the main work in the realize() function instead.\n","permalink":"https://lifeislife.cn/posts/qemu-s-instance-init-vs-realize/","summary":"\u003cp\u003e转载自\u003ca href=\"https://github.com/huth\"\u003ehuth (Thomas Huth)\u003c/a\u003e的一篇文章，原文已经 404，从网页快照中找回的文章。\u003c/p\u003e\n\u003cp\u003eNote that this is a blog post for (new) QEMU developers. If you are just interested in using QEMU, you can certainly skip this text. Otherwise, in case you have ever been in touch with the QEMU device model (\u0026ldquo;qdev\u0026rdquo;), you are likely aware of the basic qdev code boilerplate already:\u003c/p\u003e","title":"QEMU's instance_init() vs. realize()"},{"content":"引言 统一可扩展固件接口 (UEFI) 规范描述了操作系统和平台固件之间的接口。UEFI 之前是可扩展固件接口规范 1.10 (EFI)。因此，一些代码和某些协议名称保留了 EFI 名称。除非另有说明，本规范中的 EFI 名称可假定为 UEFI 的一部分。\n该接口采用数据表的形式，其中包含与平台相关的信息，以及可供 OS 加载程序和 OS 使用的引导和运行时服务调用。它们共同提供了一个引导操作系统的标准环境。本规范是作为一个纯粹的接口规范设计的。因此，该规范定义了平台固件必须实现的接口和结构集。类似地，该规范定义了操作系统在引导时可能使用的一组接口和结构。无论是固件开发者选择如何实现所需的元素，还是操作系统开发者选择如何利用这些接口和结构，都由开发者自己决定。\n该规范的目的是定义一种方法，使操作系统和平台固件仅通信支持操作系统引导过程所必需的信息。这是通过平台和固件提供给操作系统的软件可见接口的正式和完整的抽象规范来实现的。\n本规范的目的是为操作系统和平台固件定义一种方式，以仅传递支持操作系统启动过程所需的信息。这是通过平台和固件呈现给操作系统的软件可见接口的抽象规范来实现的。\n使用这一正式定义，旨在运行在与受支持的处理器规范兼容的平台上的收缩包装操作系统将能够在各种系统设计上启动，而无需进一步的平台或操作系统定制。该定义还允许平台创新引入新特性和功能，以增强平台的能力，而不需要按照操作系统的引导顺序编写新代码。\n此外，抽象规范开辟了一条替代遗留设备和固件代码的路径。新的设备类型和相关代码可以通过相同定义的抽象接口提供同等的功能，同样不会影响 OS 引导支持代码。\n该规范适用于从移动系统到服务器的所有硬件平台。该规范提供了一组核心服务以及一组协议接口。协议接口的选择可以随着时间的推移而发展，并针对不同的平台市场细分进行优化。与此同时，该规范允许 oem 提供最大限度的可扩展性和定制能力，以实现差异化。在这方面，UEFI 的目的是定义一个从传统的“PC-AT”风格的引导世界到一个没有遗留 API 的环境的进化路径。\nUEFI 驱动模型扩展 对启动设备的访问是通过一系列的协议接口提供的。UEFI 驱动模型的一个目的是为 \u0026ldquo;PC-AT\u0026quot;式的 Option ROM（TODO）提供一个替代品。需要指出的是，写在 UEFI 驱动模型上的驱动，被设计为在预启动环境中访问启动设备。它们并不是为了取代高性能的、针对操作系统的驱动程序。\nUEFI 驱动模型被设计为支持执行模块化的代码，也被称为驱动，在预启动环境中运行。这些驱动程序可以管理或控制平台上的硬件总线和设备，也可以提供一些软件衍生的、平台特定的服务。\nUEFI 驱动模型还包含了 UEFI 驱动编写者所需的信息，以设计和实现平台启动 UEFI 兼容的操作系统可能需要的任何总线驱动和设备驱动的组合。\nUEFI 驱动模型被设计为通用的，可以适应任何类型的总线或设备。UEFI 规范描述了如何编写 PCI 总线驱动程序、PCI 设备驱动程序、USB 总线驱动程序、USB 设备驱动程序和 SCSI 驱动程序。提供了允许将 UEFI 驱动程序存储在 PCI Option ROM 中的其他详细信息，同时保持了与旧 Option ROM 镜像的兼容性。\nUEFI 规范的一个设计目标是使驱动镜像尽可能的小。然而，如果一个驱动程序需要支持多个处理器架构，那么也需要为每个支持的处理器架构提供一个驱动程序对象文件。为了解决这个空间问题，本规范还定义了 EFI 字节代码虚拟机（EFI Byte Code Virtual Machine）。一个 UEFI 驱动可以被编译成一个 EFI 字节代码对象文件。UEFI Specification-complaint（TODO）的固件必须包含一个 EFI 字节代码解释器。这使得支持多种处理器架构的单一 EFI 字节代码对象文件可以被运出。另一种节省空间的技术是使用压缩。该规范定义了压缩和解压算法，可用于减少 UEFI 驱动程序的大小，从而减少 UEFI 驱动程序存储在 ROM 设备中时的开销。\nOSV、IHV、OEM 和固件供应商可以使用 UEFI 规范中包含的信息来设计和实现符合本规范的固件、生成标准协议接口的驱动程序以及可用于引导 UEFI 兼容的操作系统加载程序操作系统。\n章节安排 本规范的章节组织如下：\n章节名 内容 引言/概述 介绍 UEFI 规范，并描述 UEFI 的主要组件。 启动管理器 管理器用于加载写入此规范的驱动程序和应用程序。 EFI 系统表和分区 描述了一个 EFI 系统表，它被传递给每个兼容的驱动程序和应用程序，并定义了一个基于 GUID 的分区方案。 块转换表 用于执行块 I/O 的布局和规则集，可提供单个块的断电写入原子性。 引导服务 包含在引导操作系统之前存在于 UEFI 兼容系统中的基本服务的定义。 运行时服务 包含在操作系统启动之前和之后存在于兼容系统中的基本服务的定义。 协议 EFI 加载图像协议描述已加载到内存的 UEFI 镜像。 设备路径协议提供了在 UEFI 环境中构建和管理设备路径所需的信息。 UEFI 驱动模型描述了一组服务和协议，适用于每个总线和设备类型。 控制台支持协议定义了I/O协议，处理系统用户在启动服务环境中执行的基于文本的信息的输入和输出。 媒介访问协议定义了加载文件协议，文件系统格式和媒介格式处理可移动媒介。 PCI 总线支持协议定义 PCI 总线驱动程序，PCI 设备驱动程序和 PCI Option ROM 布局。所描述的协议包括 PCI 根桥 I/O 协议和 PCI I/O协议。 SCSI 驱动程序模型和总线支持定义了 SCSI I/O协议和扩展SCSI Pass Thru 协议，用于抽象访问由 SCSI 主机控制器产生的 SCSI 通道。 iSCSI协议定义了通过TCP/IP传输SCSI数据。 USB 支持协议定义了 USB 总线驱动程序和 USB 设备驱动程序。 调试器支持协议描述了一组可选的协议，提供所需的服务，以实现一个源级调试器的 UEFI 环境。 压缩算法规范详细描述了压缩/解压缩算法，外加一个标准的EFI解压缩接口，用于启动时使用。 ACPI 协议可用于从平台上安装或删除 ACPI 表。 字符串服务：Unicode 排序协议允许在启动服务环境中运行的代码对给定语言的 Unicode 字符串执行词法比较函数;正则表达式协议用于根据正则表达式模式匹配 Unicode 字符串。 EFI 字节码虚拟机 定义 EFI 字节码虚拟处理器及其指令集。它还定义了如何将 EBC 对象文件加载到内存中，以及从本机代码到 EBC 代码再转换到本机代码的机制。 固件更新和报告 为设备提供一个抽象，以提供固件管理支持。 网络协议 SNP、PXE、BIS 和 HTTP 启动协议定义了在 UEFI 启动服务环境中执行时提供对网络设备访问的协议。 受管网络协议定义了 EFI 受管网络协议，它提供原始 (未格式化) 异步网络数据包 I/O 服务和托管网络服务绑定协议，用于定位 MNP 驱动支持的通信设备。 VLAN、EAP、Wi-Fi 和 Supplicant 协议定义了一个协议，为 VLAN 配置提供可管理性接口。 蓝牙协议定义。 TCP、IP、PIPsec、FTP、GTLS 和 Configurations 协议定义了 EFI TCPv4 (Transmission Control Protocol version 4) 协议和 EFI IPv4 (Internet Protocol version 4) 协议。 ARP、DHCP、DNS、HTTP 和 REST 协议定义了 ARP (Address Resolution Protocol) 协议接口和 EFI DHCPv4 协议。 UDP 和 MTFTP 协议定义了 EFI UDPv4 (User Datagram Protocol version 4) 协议，该协议在 EFI IPv4 协议上接口，并定义了 EFI MTFTPv4 协议接口，该接口建立在 EFI UDPv4 协议之上。 安全引导和驱动程序签名 介绍 Secure Boot 和生成 UEFI 数字签名的方法。 人机界面基础设施 (HII) 定义实现人机接口基础设施 (HII) 所需的核心代码和服务，包括管理用户输入和相关协议的代码定义的基本机制。 描述用于管理系统配置的数据和 api:描述旋钮和设置的实际数据。 用户标识 描述描述平台当前用户的服务。 安全技术 描述用于利用安全技术的协议，包括加密散列和密钥管理。 杂项协议 Timestamp 协议提供了一个独立于平台的接口来检索高分辨率的时间戳计数器。当调用 ResetSystem 时，重置通知协议提供注册通知的服务。 附录 GUID 和时间格式。 基于基本文本的控制台要求，符合 efi 系统需要提供通信能力。 设备路径使用数据结构的例子，定义各种硬件设备的引导服务。 状态代码列出了 UEFI 接口返回的成功、错误和警告代码。 通用网络驱动程序接口定义了32/64位硬件和软件通用网络驱动程序接口(UNDIs)。 使用简单指针协议。 使用 EFI 扩展 SCISI 直通协议。 压缩源代码的一个压缩算法的实现。 一个 EFI 解压缩算法的实现的解压源代码。 EFI 字节码虚拟机操作码列表提供了相应指令集的摘要。 字母功能列表按字母顺序标识所有 UEFI 接口功能。 EFI 1.10 协议变更和折旧清单标识了协议、GUID、修订标识符名称变更以及与 EFI 1.10 规范相比已弃用的协议。 平台错误记录描述了用于表示平台硬件错误的常见平台错误记录格式。 UEFI ACPI Data Table 定义了 UEFI ACPI 表格式。 硬件错误记录持久性使用。 引用 术语表 索引 提供规范中关键术语和概念的索引。 目标 “PC-AT”启动环境对行业内的创新提出了重大挑战。每一个新的平台功能或硬件创新都要求固件开发人员设计越来越复杂的解决方案，并且通常要求操作系统开发人员修改引导代码，然后客户才能从创新中受益。这可能是一个耗时的过程，需要大量的资源投资。\nUEFI 规范的主要目标是定义一个替代引导环境，可以减轻这些考虑。在这个目标中，该规范类似于其他现有的引导规范。本规范的主要属性可以概括为以下属性：\n一致的、可扩展的平台环境。该规范为固件定义了一个完整的解决方案，以描述所有平台特性和 OS 的 surface platform(TODO) 功能在引导过程中。这些定义非常丰富，足以涵盖一系列当代处理器设计。\n从固件中抽象操作系统。该规范定义了平台功能的接口。通过使用抽象接口，该规范允许在构建 OS 加载器时，而无需了解作为这些接口基础的平台和固件。这些接口代表了底层平台和固件实现与操作系统加载程序之间定义良好的稳定边界。这样的边界允许底层固件和操作系统加载程序更改，前提是两者都将交互限制在定义的接口上。\n合理的设备抽象，不需要遗留接口。“PC-AT”BIOS 接口要求操作系统加载程序对某些硬件设备的工作有特定的了解。该规范为 OS 加载器开发人员提供了一些不同的东西：抽象接口使得可以构建在一系列底层硬件设备上工作的代码，而无需明确了解该范围内每个设备的细节。\n从固件中提取 Option ROM。该规范定义了平台功能的接口，包括 PCI、USB 和 SCSI 等标准总线类型。支持的总线类型可能会随着时间的推移而增加，因此包括了一种扩展到未来总线类型的机制。这些定义的接口以及扩展到未来总线类型的能力是 UEFI 驱动程序模型的组件。UEFI 驱动模型的一个目的是解决现有“PC-AT”Option ROM 中存在的广泛问题。与 OS 加载程序一样，驱动程序使用抽象接口，因此可以构建设备驱动程序和总线驱动程序，而无需了解作为这些接口基础的平台和固件。\n架构上可共享的系统分区。扩展平台功能和添加新设备的计划通常需要软件支持。在许多情况下，当这些平台创新（TODO）在操作系统控制平台之前被激活时，它们必须由特定于平台而不是客户选择的操作系统的代码支持。解决这个问题的传统方法是在制造过程中将代码嵌入平台中（例如，在闪存设备中）。对这种持久存储的需求正在快速增长。该规范定义了大型海量存储媒介类型上的持久存储，以供平台支持代码扩展使用，以补充传统方法。规范中明确了其工作原理的定义，以确保固件开发商、OEM、操作系统供应商甚至第三方可以安全地共享空间，同时增加平台功能。\n可以通过多种方式定义提供这些属性的引导环境。实际上，在编写本规范时，已经存在几种替代方案，从学术角度来看可能是可行的。然而，考虑到当前围绕支持的处理器平台的基础设施能力，这些替代方案通常会带来很高的门槛。本规范旨在提供上面列出的属性，同时也认识到行业的独特需求，该行业在兼容性方面进行了大量投资，并且拥有大量无法立即放弃的系统安装基础。这些需求推动了对本规范中体现的附加属性的要求：\n进化性的，而不是革命性的。规范中的接口和结构旨在尽可能地减少初始实现的负担。虽然已经小注意保在接口本身中维护适当的抽象，但该设计还确保可以重用 BIOS 代码来实现接口，而只需要最少的额外编码工作。换句话说，在 PC-AT 平台上，规范最初可以作为基于现有代码的底层实现之上的薄接口（thin Interface TODO）层来实现。同时，抽象接口的引入提供了将来从遗留代码的迁移。一旦抽象被确立为固件和操作系统加载程序在引导期间交互的手段，开发人员就可以随意替换抽象接口下的遗留代码。类似的硬件遗留迁移也是可能的。由于抽象隐藏了设备的细节，因此可以移除底层硬件，并用提供改进功能、降低成本或两者兼而有之的新硬件替换它。显然，这需要编写新的平台固件来支持设备并通过抽象接口将其呈现给 OS 加载器。但是，如果没有接口抽象，则可能根本无法移除旧设备。 设计上的兼容性。系统分区结构的设计还保留了当前在“PC-AT”引导环境中使用的所有结构。因此，构建一个能够从同一磁盘引导传统操作系统或 EFI-aware 操作系统的单一系统是一件简单的事情。 简化了操作系统中立的平台增值的添加。该规范定义了一个开放的、可扩展的接口，它有助于创建平台“驱动程序”。这些可能类似于操作系统驱动程序，在引导过程中为新设备类型提供支持，或者它们可能用于实现增强的平台功能，例如容错或安全性。此外，这种扩展平台能力的能力从一开始就被设计到规范中。这旨在帮助开发人员避免在尝试将新代码挤入传统 BIOS 环境时所固有的许多挫败感。由于包含用于添加新协议的接口，OEM 或固件开发人员拥有以模块化方式向平台添加功能的基础设施。由于规范中定义的调用约定和环境，此类驱动程序可能会使用高级编码语言来实现。这反过来可能有助于降低创新的难度和成本。系统分区选项为此类扩展提供了非易失性存储器存储的替代方案。 建立在现有投入的基础上。在可能的情况下，规范避免在现有行业规范提供足够覆盖的领域重新定义接口和结构。例如，ACPI 规范为操作系统提供了发现和配置平台资源所需的所有信息。同样，规范设计的这种哲学选择旨在尽可能降低采用该规范的障碍。 目标受众 本文档主要适用于以下读者：\n将实现 UEFI 驱动程序的 IHV 和 OEM。 将创建支持的处理器平台的 OEM 厂商，旨在启动 shrink-wrap（TODO）的操作系统。 BIOS 开发人员，无论是创建通用 BIOS 和其他固件产品的人员，还是修改这些产品的支持人员。 操作系统开发人员将调整他们的 shrink-wrap（TODO）操作系统产品，用来在支持的基于处理器的平台上运行。 UEFI 设计概述 UEFI 的设计基于以下基本要素：\n重用现有的基于表格的接口。为了保持对现有基础支持代码（包括操作系统和固件）的投资，必须在希望符合 UEFI 规范的平台上，实现通常在与支持的处理器规范兼容的平台上，实现的许多现有规范。 （有关更多信息，请参阅附录 Q：参考资料。） 系统分区。系统分区定义了一个分区和文件系统，可允许多个供应商之间安全共享，并用于不同目的。包含单独的、可共享的系统分区的能力提供了增加平台附加值的机会，而不会显著增加对非易失性平台存储器的需求。 引导服务。引导服务为可在引导期间使用的设备和系统功能提供接口。设备访问是通过“句柄”（handles）和“协议”(protocols) 抽象出来的。这有利于重用现有 BIOS 代码，将基本实现要求保持在规范之外，而不会给访问设备的消费者带来负担。 运行时服务。提供了一组最小的运行时服务，以确保对基础平台的硬件资源进行适当的抽象，这些资源可能是操作系统在正常运行时需要的。 \u003c!DOCTYPE html\u003e Responsive Image 图 1-1 描述了用于完成平台和操作系统引导的符合 UEFI 规范的系统的各种组件的交互。\n平台固件能够从系统分区中检索操作系统加载器镜像。该规范提供了各种大容量存储设备类型，包括磁盘、CD-ROM 和 DVD，以及通过网络的远程启动。通过可扩展的协议接口，有可能增加其他的引导媒介类型，尽管如果这些媒介需要使用本文件中定义的协议以外的协议，可能需要修改操作系统加载器。\n一旦启动，操作系统加载程序将继续引导整个操作系统。为此，它可以使用本规范或其他所需规范定义的 EFI 引导服务和接口来探测、解析和初始化各种平台组件和管理它们的操作系统软件。在引导阶段，EFI 运行时服务也可供 OS 加载器使用。\nUEFI 驱动模型 本节描述了符合本规范的固件的驱动模型的目标。目标是让这个驱动模型为所有类型的总线和设备提供一个实现总线驱动和设备驱动的机制。在撰写本文时，支持的总线类型包括 PCI、USB 等。\n随着硬件架构的不断发展，平台中存在的总线数量和类型也在不断增加。这种趋势在高端服务器中尤为明显。然而，更多样化的总线类型被设计到桌面和移动系统，甚至一些嵌入式系统中。这种日益增长的复杂性，意味着在预启动环境中，需要一种简单的方法来描述和管理平台中的所有总线和设备。UEFI 驱动模型以协议、服务和启动服务的形式提供了这种简单的方法。\nUEFI 驱动程序模型目标 UEFI 驱动模型有以下目标：\n兼容 – 符合此规范的驱动程序必须保持与 EFI 1.10 规范和 UEFI 规范的兼容性。这意味着 UEFI 驱动程序模型利用 UEFI 2. 0 规范中的可扩展性机制来添加所需的功能。 简单 - 符合本规范的驱动程序必须易于实现，易于维护。UEFI 驱动模型必须允许驱动编写者专注于正在开发的特定设备的驱动。驱动程序不应关注平台策略或平台管理问题。这些考虑应该留给系统固件。 可扩展性 - UEFI 驱动模型必须能够适应所有类型的平台。这些平台包括嵌入式系统、移动和桌面系统，以及工作站和服务器。 灵活 - UEFI 驱动模型必须支持枚举所有设备的能力，或者只枚举启动所需操作系统的那些设备。最小的设备枚举提供了对更快速的启动能力的支持，而完整的设备媒体提供了在系统中存在的任何启动设备上执行操作系统安装、系统维护或系统诊断的能力。 可扩展性 - UEFI 驱动模型必须能够扩展到未来定义的总线类型。 可移植性 - 根据 UEFI 驱动模型编写的驱动，必须在不同平台和支持的处理器架构之间可移植。 可互操作性 - 驱动程序必须与其他驱动程序和系统固件共存，并且必须在不产生资源冲突的情况下进行操作。 描述复杂的总线层次结构 - UEFI 驱动模型必须能够描述各种总线拓扑结构，从非常简单的单总线平台到包含许多不同类型总线的非常复杂的平台。 驱动占用空间小 - 由 UEFI 驱动程序模型产生的可执行文件的大小必须最小化，以减少整体平台成本。虽然灵活性和可扩展性是目标，但支持这些所需的额外开销必须保持在最低水平，以防止固件组件的大小变得无法管理。 解决遗留 Option ROM 的问题 - UEFI 驱动模型必须直接解决遗留 Option ROM 的约束和限制。具体来说，必须能够建立同时支持 UEFI 驱动和传统 Option ROM 的插件卡，这种卡可以在传统 BIOS 系统和符合 UEFI 的平台上执行，而无需修改卡上的代码。该解决方案必须提供一个从传统 Option ROM 驱动程序迁移到 UEFI 驱动程序的进化路径。 遗留 Option ROM 问题 这个支持驱动模型的想法来自于对 UEFI 规范的反馈，它提供了一个明确的、由市场驱动的对传统选项 ROM（有时也被称为扩展 ROM）的替代要求。人们认为，UEFI 规范的出现代表了一个机会，通过用一种在 UEFI 规范框架内工作的替代机制来取代传统选项 ROM 镜像的构建和操作，从而摆脱隐含的限制。\n迁移要求 迁移要求涵盖了从最初实施本规范到未来所有平台和操作系统都实施本规范的过渡时期。在这一时期，有两个主要的兼容性考虑是很重要的。\n能够继续启动传统的操作系统； 能够在现有的平台上实现 UEFI，尽可能多地复用现有的固件代码，将开发资源和时间要求降到最低。 旧版操作系统支持 UEFI 规范代表了收缩式操作系统和固件在启动过程中进行通信的首选方式。然而，选择制作一个符合该规范的平台，并不排除该平台，也支持不了解 UEFI 规范的，现有传统操作系统二进制文件。\nUEFI 规范并不限制平台设计者，选择同时支持 UEFI 规范和更传统的 \u0026ldquo;PC-AT \u0026ldquo;启动基础架构。如果要实现这样的传统基础架构，应该按照现有的行业惯例来开发，这些惯例是在本规范范围之外定义的。在任何给定的平台上，支持的传统操作系统的选项是由该平台的制造商决定的。\n在旧平台上支持 UEFI 规范 UEFI 规范经过精心设计，允许以最少的开发工作扩展现有系统以支持它。特别是 UEFI 规范中定义的抽象结构和服务，都可以在遗留平台上得到支持\n例如，要在现有且受支持的基于 32 位的平台上实现此类支持，该平台使用传统 BIOS 来支持操作系统启动，需要提供额外的固件代码层。需要这些额外的代码来将服务和设备的现有接口转换为对本规范中定义的抽象的支持。\n本文档中使用的约定 数据结构描述 支持的处理器是“小端”机器。这种区别意味着内存中多字节数据项的低位字节位于最低地址，而高位字节位于最高地址。一些受支持的 64 位处理器可以配置为“小端”和“大端”操作。所有旨在符合本规范的实现都使用“小端”操作。\n在某些内存布局描述中，某些字段被标记为保留。软件必须将这些字段初始化为零并在读取时忽略它们。在更新操作中，软件必须保留任何保留字段。\n协议描述 协议描述一般有以下格式：\n协议名称：协议接口的正式名称。 摘要：协议接口的简要描述。 GUID：协议接口的 128 位 GUID (Globally Unique Identifier)。 协议接口结构：一种“c 风格”的数据结构定义，包含由该协议接口产生的过程和数据字段。 参数：协议接口结构中各字段的简要说明。 描述：对接口提供的功能的描述，包括调用者应该知道的任何限制和警告。 相关定义：协议接口结构或其任何过程中使用的类型声明和常量。 过程描述 过程描述通常具有以下格式：\n过程名称：过程的正式名称。 摘要：过程的简要说明。 原型：定义调用序列的“C 风格”过程标头。 参数：对程序原型中每个字段的简要描述。 描述：对接口所提供的功能的描述，包括调用者应该注意的任何限制和注意事项。 相关定义：仅由该过程使用的类型声明和常量。 返回的状态代码：对接口所返回的任何代码的描述。该过程需要实现本表中列出的任何状态代码。可以返回更多的错误代码，但是它们不会被标准的符合性测试所测试，而且任何使用该程序的软件，都不能依赖于实现可能提供的任何扩展错误代码。 指令描述 EBC 指令的指令描述一般有以下格式：\n指令名称：指令的正式名称。 语法：指令的简要描述。 描述：对指令所提供的功能的描述，并附有指令编码的详细表格。 操作：详细说明对操作数进行的操作。 行为和限制：逐项描述指令中涉及的每个操作数的行为，以及适用于操作数或指令的任何限制。 伪代码约定 提出伪代码是为了以更简洁的形式描述算法。本文件中的所有算法都不打算直接进行编译。代码是在与周围文本相对应的水平上呈现的。\n在描述变量时，列表是一个无序的同质对象的集合。一个队列是一个同质对象的有序列表。除非另有说明，否则假设排序为先进先出。\n伪代码以类似于 C 的格式呈现，在适当的地方使用 C 约定。编码风格，特别是缩进风格，是为了可读性，不一定符合 UEFI 规范的实现。\n排版约定 本文件采用了以下描述的排版和说明性惯例。\n纯文本：规范中的绝大部分描述性文本都使用普通文本字体。 纯文本（蓝色）：任何有下划线和蓝色的纯文本都表示与交叉参考资料的活动链接。点击该词，就可以跟踪超链接。 加粗：在文本中，粗体字标识了一个处理器寄存器的名称。在其他情况下，黑体字可以作为段落中的标题。 斜体：在文本中，斜体字可以用作强调，以引入一个新的术语或表示手册或规范的名称。 加粗等宽（暗红色）：计算机代码、示例代码段和所有原型代码段使用 BOLD Monospace 字体，颜色为暗红色。这些代码列表通常出现在一个或多个独立的段落中，尽管单词或片段也可以嵌入到一个正常的文本段落中。 加粗等宽（蓝色）：用粗体单色字体的字，下划线和蓝色的字，表示该功能或类型定义的代码定义的活动超链接。点击该词，即可进入超链接。 注意：出于管理和文件大小的考虑，每一页上只有第一次出现的参考文献是一个主动链接。同一页上的后续参考文献不会被主动链接到定义上，而是使用标准的、无下划线的 BOLD Monospace 字体。在页面上找到该名称的第一个实例（使用下划线的 BOLD Monospace 字体），点击该词即可跳转到该功能或类型的定义。\n斜体等宽：在代码或文本中，斜体字表示必须提供的变量信息的占位符名称（即参数）。 数字格式 在本标准中，二进制数字是由仅由西方阿拉伯数字 0 和 1 组成的任何数字序列表示的，后面紧跟一个小写的 b（例如，0101b）。在二进制数字表示中的字符之间可以包含下划线或空格，以增加可读性或划分领域边界（例如，0 0101 1010b 或 0_0101_1010b）。\n十六进制 十六进制数字在本标准中用 0x 表示，前面是仅由西阿拉伯数字 0 至 9 和/或大写英文字母 A 至 F 组成的任何数字序列（例如，0xFA23）。十六进制数字表示中的字符之间可以包含下划线或空格，以增加可读性或划定字段边界（例如，0xB FD8C FA23 或 0xB_FD8C_FA23）。\n十进制 在本标准中，小数是由仅由阿拉伯数字 0 到 9 组成的任何数字序列来表示的，后面不紧跟小写的 b 或小写的 h（例如，25）。本标准使用以下惯例来表示小数：\n小数点分隔符（即分隔数字的整数部分和小数部分）是一个句号； 千位数分隔符（即分隔数字部分的三位数组）是一个逗号； 千位数分隔符用于数字的整数部分，不用于数字的小数部分。 二进制前缀 本标准使用国际单位制（SI）中定义的前缀来表示 10 的幂值。见 \u0026ldquo;SI 二进制前缀 \u0026ldquo;标题下的 \u0026ldquo;UEFI 相关文件链接\u0026rdquo;（http://uefi.org/uefi）。\n\u003c!DOCTYPE html\u003e Responsive Image 本标准使用ISO/IEC 80000-13《数量和单位\u0026ndash;第 13 部分：信息科学和技术》和 IEEE 1514《二进制倍数前缀标准》中定义的二进制前缀，用于表示 2 的幂值。\n\u003c!DOCTYPE html\u003e Responsive Image 例如，4 KB 意味着 4000 个字节，4 KiB 意味着 4096 个字节。\n修订号 对 UEFI 规范的更新被认为是新的修订或勘误表，如下所述：\n当有实质性的新内容或可能修改现有行为的变化时，就会产生一个新的修订。新的修订版由一个主要的。次要的版本号来指定（例如：xx.yy）。在变化特别小的情况下，我们可能有一个 major.minor.minor 的命名惯例（例如 xx.yy.zz）。 当批准的规范更新不包括任何重要的新材料或修改现有行为时，就会产生勘误的版本。勘误的指定方法是在版本号后面加上一个大写字母，如 xx.yy 勘误 A。 ","permalink":"https://lifeislife.cn/posts/zh-uefi%E8%A7%84%E8%8C%83-1-%E5%BC%95%E8%A8%80/","summary":"\u003ch1 id=\"引言\"\u003e引言\u003c/h1\u003e\n\u003cp\u003e统一可扩展固件接口 (UEFI) 规范描述了操作系统和平台固件之间的接口。UEFI 之前是可扩展固件接口规范 1.10 (EFI)。因此，一些代码和某些协议名称保留了 EFI 名称。除非另有说明，本规范中的 EFI 名称可假定为 UEFI 的一部分。\u003c/p\u003e","title":"ZH-UEFI 规范 -1-引言"},{"content":"保留现场 使用 VSCode 远程登录失败，报错：Failed to connect to the remote extension host server (Error: WebSocket close with status code 1006)。\n解决方法 vim /etc/ssh/sshd_config AllowTcpForwarding no AllowAgentForwarding no # 替换为 AllowTcpForwarding yes AllowAgentForwarding yes 保存后重启 sshd 服务：\nsystemctl restart sshd ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3vscode%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5error-websocket-close-with-status-code-1006/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e使用 VSCode 远程登录失败，报错：Failed to connect to the remote extension host server (Error: WebSocket close with status code 1006)。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evim /etc/ssh/sshd_config\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eAllowTcpForwarding no\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eAllowAgentForwarding no\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 替换为\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eAllowTcpForwarding yes\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eAllowAgentForwarding yes\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e保存后重启 \u003ccode\u003esshd\u003c/code\u003e 服务：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemctl restart sshd\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"解决 VSCode 远程登录失败 Error: WebSocket close with status code 1006"},{"content":"简介 GitHub Actions 是 GitHub 在 2018 年推出的持续集成服务。它可以自动完成一些开发周期内的任务，如 Push 代码时自动编译，Pull 代码时自动执行测试脚本等等。\n我了解 GitHub Actions 的契机是，我在 GitHub 上保存了一些 Markdown 文档，我希望每次更新文档后自动使用 Pandoc 转换成 PDF 文档。接下来我们一起学习如何通过 GitHub Actions 实现这样的需求。\n首先我们先直观的了解一下它在 GitHub 的位置，如果打开一个仓库，它有图中绿色对号√，或者红色叉号×，说明这个项目配置了 GitHub Actions，绿色表示自动化的流程运行成功了，红色表示失败了。\n\u003c!DOCTYPE html\u003e Responsive Image 我们点开Actions按钮就可以查看具体的任务详情。下面我们先学习如何配置一个简单的 GitHub Actions。\n配置 GitHub Actions GitHub Actions 可以简单理解为一些自动化脚本，工具，目的就是为了减少重复工作，所以这些工具都可以做成普适性的工具。而 GitHub 官方就开放了一个这类工具的市场，我们可以在上面搜索自己想要的工具。因为初学 GitHub Actions 所以也不知道怎么写配置文件，我们可以直接搜索一个并应用它，看看别人是怎么写的。\n我们进入一个自己的仓库，点击Actions，搜索框中搜索PDF，在搜索结果中找到Create PDF · Actions这个工具。如果搜索到点击Configure。如果显示未找到，则点击set up a workflow yourself，同样搜索PDF。\n\u003c!DOCTYPE html\u003e Responsive Image 打开详情页面，拉到底，将Example usage。里的内容复制到编辑框中。点击右上角Start commit将会把我们新建的main.yml提交到仓库中。这就相当于创建了一个生成 PDF 的 GitHub Actions。当然每个 Actions 都有一些使用要求，比如这里还要根据介绍，创建几个文件夹，比如从哪个文件夹获取源文件，生成后的 PDF 又会放到哪个文件夹等。这里就不再介绍，我们先了解如何创建一个 Actions。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image Workflow 配置 GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows 目录。\nworkflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml or .yaml，比如 foo.yml or foo.yaml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows 目录里面有.yml or .yaml 文件，就会自动运行该文件（并行）。\n接下来我们逐个参数来解释都有哪些功能。\non 触发 workflow 的 GitHub 事件的名称。比如push代码时触发，其他人fork代码仓时触发等等。\n可以只有一个事件触发，\non: push 也可有多个事件触发，使用列表列举，\non: [push, fork] 所有支持的事件列表，请查看官方文档。\non.[push|fork].[tags|branches] 注意：从这里开始就会出现一个字段下有子字段，每个点号.分割一个子字段。如push或者fork可以作为on的子字段，tags或者branches可以作为push或者fork的子字段。在yaml文件中，缩进很重要，每个缩进都表示是从属关系，表示是该字段的子字段。千万要注意缩进关系，如果缩进出错，那么将无法解析yaml文件。\n指定触发事件时，可以限定分支或标签。\non: push: branches: - master 上面代码指定，只有 master 分支发生 push 事件时，才会触发 workflow。\nname 工作流程的名称。GitHub 在仓库的操作页面上显示工作流程的名称。如果省略 name，GitHub 将其设置为相对于仓库根目录的工作流程文件路径。\njobs workflow 运行包括一项或多项 jobs。jobs 默认是并行运行。要按顺序运行作业，可以使用 [job_id].needs 关键词在其他 job 上定义依赖项。\n每个作业在 runs-on 指定的运行器环境中运行。\njobs.[job_id] jobs 中的每个任务都有一个[job_id] ，且其必须为 jobs 对象中唯一的字符串键值。[job_id]必须以字母或_开头，并且只能包含字母数字字符、-或_。\njobs: first_job: # [job_id]，任务 id name: My first job second_job: name: My second job jobs.[job_id].[runs-on] runs-on 字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。\n- ubuntu-latest，ubuntu-18.04或ubuntu-16.04 - windows-latest，windows-2019或windows-2016 - macOS-latest或macOS-10.14 下面代码指定虚拟机环境为 ubuntu-18.04。\nruns-on: ubuntu-18.04 jobs.[job_id].name workflow 文件的主体是 jobs 字段，表示要执行的一项或多项任务。\njob_id 里面的 name 字段是任务的说明。它可以在网页端的 UI 上显示。\njobs: first_job: name: My first job # [job_name]，任务名称 second_job: name: My second job jobs.[job_id].needs needs 字段指定当前任务的依赖关系，即运行顺序。\njobs: job1: job2: needs: job1 job3: needs: [job1, job2] 上面代码中，job1 必须先于 job2 完成，而 job3 等待 job1 和 job2 的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。\njobs.[job_id].steps steps 字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。\n- jobs.[job_id].steps.name：步骤名称。 - jobs.[job_id].steps.run：该步骤运行的命令或者 action。 - jobs.[job_id].steps.env：该步骤所需的环境变量。 下面是一个完整的 workflow 文件的范例。\nname: Greeting from Mona on: push jobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 上面代码中，steps 字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。\njobs.[job_id].steps[*].uses 选择一个 action，可以理解为若干 steps.run，有利于代码复用。这也是 github action 最主要的功能。\n比如最常用的，下载本仓库的代码到工作区，就是使用的一个 action 完成的：\nsteps: - name: Check out Git repository uses: actions/checkout@v2 注：@v2 什么意思？ 表示 Action 的版本。我们如果不带版本号的话，就是默认使用最新版本。Github 官方强烈要求我们带上版本号。这样子的话，我们就不会出现：写好一个 Workflow，但是由于某个 Action 的作者一更新，我们的 Workflow 就崩了的问题\njobs.[job_id].steps.run 在 shell 中执行的命令：\nsteps: - uses: actions/checkout@v2 - name: create dir id: dir run: | mkdir output # create output dir 以上配置是在下载完本仓库的代码后，在仓库根目录新建一个output文件夹。注意run:后的|表示可以多行命令。如果没有|表示只能执行一条命令。\njobs.[job_id].steps.working-directory 用来指定在run命令在哪执行。\n- name: Create dir run: mkdir output working-directory: ./build jobs.[job_id].steps.shell 用来指定 shell 类型，如 Python，bash，powershell 等。\nsteps: - name: Display the path run: echo $PATH shell: bash 所有支持的类型请查看官方文档。\n如何跳过 GitHub Actions 在 commit message 中只要包含了下面几个关键词就会跳过 Github Actions。\n[skip ci] [ci skip] [no ci] [skip actions] [actions skip] 实例：自动使用 Pandoc 将 Markdown 文件转换为 PDF 以Dunky-Z/uefi-spec-zh项目中使用的 GitHub Actions 为例，解释如何实现将 Markdown 文件转换为 PDF。\n# CI 名为 MPPL name: MPPL # 在 Push 代码时触发 CI on: push jobs: # 任务名称为 convert_via_pandoc convert_via_pandoc: # 在 ubuntu-latest 系统上运行 runs-on: ubuntu-latest steps: # 步骤一：下载最新代码 - uses: actions/checkout@v2 # 步骤二：在项目根目录建立 output 文件夹放生成的 PDF 文件 - name: create file list id: files_list run: | mkdir output # create output dir # 步骤三：更新项目的子模块 - name: Git Sumbodule Update run: | git submodule update --init --remote --recursive # 步骤四：为运行的系统中安装需要的字体，因为原系统没有需要的中文字体 # 字体来源为项目目录的MPPL/fonts - name: add fonts run: | sudo apt-get install ttf-mscorefonts-installer sudo apt-get install fontconfig fc-list :lang=zh ls -lh /usr/share/fonts/ cp -rf ./MPPL/fonts/* /usr/share/fonts/ mkfontscale mkfontdir fc-cache fc-list # 步骤五：安装 pandoc 和 texlive - name: install pandoc run: | sudo apt-get update sudo apt-get install texlive-full sudo apt-get install pandoc sudo apt-get clean # 步骤六：使用 pandoc 命令生成 pdf - name: build pdf run: | cd src pandoc -f markdown-auto_identifiers --listings --pdf-engine=xelatex --template=../MPPL/templates/mppl.tex --output=../output/UEFI规范-中文.pdf *.md # 步骤七：将生成的结果上传到 GitHub - uses: actions/upload-artifact@master with: name: output path: output 注意事项 every step must define a uses or run key every step must define a uses or run key · Issue #2 · einaregilsson/beanstalk-deploy\n参考 GH actions: a step cannot have both the uses and run keys · Issue #318 · fhem/mod-Buienradar\nevery step must define a uses or run key · Issue #2 · einaregilsson/beanstalk-deploy\n","permalink":"https://lifeislife.cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github-actions/","summary":"\u003ch1 id=\"简介\"\u003e简介\u003c/h1\u003e\n\u003cp\u003eGitHub Actions 是 GitHub 在 2018 年推出的\u003ca href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\"\u003e持续集成服务\u003c/a\u003e。它可以自动完成一些开发周期内的任务，如 Push 代码时自动编译，Pull 代码时自动执行测试脚本等等。\u003c/p\u003e\n\u003cp\u003e我了解 GitHub Actions 的契机是，我在 GitHub 上保存了一些 Markdown 文档，我希望每次更新文档后自动使用 Pandoc 转换成 PDF 文档。接下来我们一起学习如何通过 GitHub Actions 实现这样的需求。\u003c/p\u003e","title":"如何使用 GitHub Actions"},{"content":"基本概念 明文与密文 Plaintext，明文，未经加密的消息，任何人都可以读 Ciphertext，密文，加密后的消息，不可读 Key，密钥，用于加密和解密（核心是算法） 加密与解密概念 加密 数据加密 的基本过程，就是对原来为 明文 的文件或数据按 某种算法 进行处理，使其成为 不可读 的一段代码，通常称为“密文”。通过这样的途径，来达到 保护数据 不被 非法人窃取、阅读的目的。\n解密 加密 的 逆过程 为 解密，即将该 编码信息 转化为其 原来数据 的过程。\n对称加密和非对称加密 加密算法分 对称加密 和 非对称加密，其中对称加密算法的加密与解密 密钥相同，非对称加密算法的加密密钥与解密 密钥不同，此外，还有一类 不需要密钥 的 散列算法。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 对称加密 对称加密算法 是应用较早的加密算法，又称为 共享密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。\n数据加密过程：在对称加密算法中，数据发送方 将 明文 (原始数据) 和 加密密钥 一起经过特殊 加密处理，生成复杂的 加密密文 进行发送。\n数据解密过程：数据接收方 收到密文后，若想读取原数据，则需要使用 加密使用的密钥 及相同算法的 逆算法 对加密的密文进行解密，才能使其恢复成 可读明文。\n非对称加密 非对称加密算法，又称为 公开密钥加密算法。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。 因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。\n如果使用 公钥 对数据 进行加密，只有用对应的 私钥 才能 进行解密。\n如果使用 私钥 对数据 进行加密，只有用对应的 公钥 才能 进行解密。\n数字签名 数字签名，顾名思义，就是用来证明自己身份的一种方式。在使用非对称加密算法通信时，如何验证发送者是真实的发送者，发送的信息没有篡改，就需要数字签名。一套 数字签名 通常定义两种 互补 的运算，一个用于 签名，另一个用于 验证。分别由 发送者 持有能够 代表自己身份 的 私钥（私钥不可泄露），由 接受者 持有与私钥对应的 公钥，能够在 接受 到来自发送者信息时用于 验证 其身份。\n加密算法详解 通过以上简介可以了解到，加密算法分为需要秘钥的和不需要秘钥的，需要秘钥的有可以分为对称加密与非对称加密两大类。接来来我们就详细探究一下各个加密算法。\n哈希算法（不可逆） 哈希算法可以将任意长度的输入数据，生成固定长度的输出（哈希值）。\n常见的哈希算法有如下：\n\u003c!DOCTYPE html\u003e Responsive Image 目前比较常用的是 MD5 和 SHA 系列（比如比特币用的 SHA256 算法，Git 中的 commit hash 用的 SHA1）。\nMD5 MD5（Message-Digest）典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。\nSHA1 SHA1(Secure Hash Algorithm) 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 $2 ^{64}$ 位的消息，SHA1 会产生一个 160 位的 消息摘要。\n对称加密（可逆） 对称加密算法是应用比较早的算法，在数据加密和解密的时用的都是同一个密钥，这就造成了密钥管理困难的问题。常见的对称加密算法有 DES、3DES、AES128、AES192、AES256。\nA5/1、A5/2及RC4 A5/1、A5/2及RC4他们都属于对称加密算法，并都属于流加密。先了解什么是流加密。\n在密码学中，流加密（英语：Stream cipher），是一种对称加密算法，加密和解密双方使用相同伪随机加密数据流（pseudo-random stream）作为密钥，明文数据每次与密钥数据流顺次对应加密，得到密文数据流。实践中通常把信息中的每一位跟密钥流的每一位进行异或 (xor) 运算来获得密文。\nDES DES(Data Encryption Standard) 是对称加密算法领域中的典型算法，是一种块加密算法(Block cipher)，其密钥默认长度为 56 位。块加密或者叫分组加密，这种加密方法是把明文分成几个固定大小的 block 块，然后分别对其进行加密。\nDES 加密算法是对 密钥进行保密，而 公开算法，包括加密和解密算法。这样，只有掌握了和发送方 相同密钥 的人才能解读由 DES 加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是 搜索密钥的编码。对于 56 位长度的 密钥 来说，如果用 穷举法 来进行搜索的话，其运算次数为 $2 ^{56}$ 次。\nAES AES 是美国国家标准技术研究所 NIST 旨在取代 DES 的 21 世纪的加密标准。AES 是块加密算法，也就是说，每次处理的数据是一块（16 字节），当数据不是 16 字节的倍数时填充，这就是所谓的分组密码（区别于基于比特位的流密码），16 字节是分组长度。AES 共有 ECB、CBC 等多种模式。\nSM4 SM4 算法于 2012 年被国家密码管理局确定为国家密码行业标准，最初主要用于 WAPI (WLAN Authentication and Privacy Infrastructure) 无线网络中。SM4 算法的出现为将我国商用产品上的密码算法由国际标准替换为国家标准提供了强有力的支撑。随后，SM4 算法被广泛应用于政府办公、公安、银行、税务、电力等信息系统中，其在我国密码行业中占据着极其重要的位置。类似于 DES、AES 算法，SM4 算法也是一种分组密码算法。\n非对称加密（可逆） 学习非对称加密之前，我们得了解如何进行安全高效地秘钥交换。我们不可能说通信双方在通信之前，先见个面协商一下秘钥 key，这样非常不方便，但是又不能直接把 key 秘钥通过一个不安全的信道发出去，这样就会被攻击者截获。\n所以我们需要有一种方法，可以让双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容，这就是秘钥交换的概念（key exchange）。\nDiffie–Hellman key exchange 迪菲-赫尔曼密钥交换（英语：Diffie–Hellman key exchange，缩写为 D-H）是一种安全协议。可以完成上述秘钥交换。\n\u003c!DOCTYPE html\u003e Responsive Image 通信双方 Alice 和 Bob 个准备一个大的质数，Alice 准备的质数是n=11, Bob 准备的质数是g=7，n和g是公开的，任何第三方都可以获取到这个信息。\nAlice 准备一个随机自然数x=3, 除了 Alice 没有人知道x是多少，Alice 通过计算g的x次方并且对 n 取模，得到结果大 A\nAlice 把计算得到的结果 A=2 发送给 Bob，这个信息是公开的，任何人可以获取到 A\nBob 同样准备一个随机自然数 y=6，除了 Bob 没有人知道 y 是多少，Bob 通过计算 g 的 y 次方并且对 n 取模，得到结果大 B\nBob 把计算结果 B=4，发送给 Alice，，这个信息是公开的，任何人可以获取到 B\nAlice 拿到 B 以后，对 B 求 x 次方并对 n 取模，得到 K1=9\nBob 拿到 A 以后，对 A 对 y 次方并对 n 取模，得到 K2=9\nK1 == K2，Alice 和 Bob 可以使用 K1，K2 作为 Key 进行通信加密。\n在整个通信过程中，攻击者是无法知道 x，y 以及 K1，K2 的，或者说计算的困难很大，感兴趣的同学可以在网上找到具体的数学问题，离散对数问题的求解。\nRSA Diffie–Hellman key exchange 发明后不久出现了 RSA，另一个进行公钥交换的算法。它使用了非对称加密算法。\nRSA 加密算法是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。\nRSA 所用到的数学原理可以参考阮一峰老师的文章RSA 算法原理（一），文章介绍了 RSA 用到的一些数学定理，不涉及证明，这对于了解 RSA 也就足够了。\n简单介绍一下秘钥是生成过程（摘自RSA 算法原理（二））：\n随机选择两个不相等的质数 $p$ 和 $q$。爱丽丝选择了$61$和$53$。（实际应用中，这两个质数越大，就越难破解。）\n计算$p$和$q$的乘积$n$。爱丽丝就把 $61$ 和 $53$ 相乘。 $$n = 61×53 = 3233$$\n$n$ 的长度就是密钥长度。$3233$ 写成二进制是 $110010100001$，一共有 $12$ 位，所以这个密钥就是 $12$ 位。实际应用中，RSA 密钥一般是 $1024$ 位，重要场合则为 $2048$ 位。\n计算 $n$ 的欧拉函数$\\varphi(n)$。根据公式： $$\\varphi(n) = (p-1)(q-1)$$\n爱丽丝算出$\\varphi(3233)$ 等于 $60×52$，即 $3120$。\n随机选择一个整数 $e$，条件是 $1\u0026lt; e \u0026lt; \\varphi(n)$，且 $e$ 与$\\varphi(n)$ 互质。 爱丽丝就在 $1$ 到 $3120$ 之间，随机选择了 $17$。（实际应用中，常常选择 $65537$。）\n计算 $e$ 对于$\\varphi(n)$ 的模反元素 $d$。\n所谓\u0026quot;模反元素\u0026quot;就是指有一个整数 $d$，可以使得 $ed$ 被$\\varphi(n)$ 除的余数为 $1$。\n$$ed ≡ 1 (mod \\varphi(n))$$ 这个式子等价于\n$$ed - 1 = k\\varphi(n)$$\n于是，找到模反元素 $d$，实质上就是对下面这个二元一次方程求解。\n$$ex + \\varphi(n)y = 1$$\n已知 $e=17$, $\\varphi(n)=3120$，\n$$17x + 3120y = 1$$\n这个方程可以用扩展欧几里得算法求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 $(x,y)=(2753,-15)$，即 $d=2753$。\n至此所有计算完成。\n将 $n$ 和 $e$ 封装成公钥，$n$ 和 $d$ 封装成私钥。\n在爱丽丝的例子中，$n=3233$，$e=17$，$d=2753$，所以公钥就是 $(3233,17)$，私钥就是$3233, 2753）$。\n实际应用中，公钥和私钥的数据都采用 ASN.1 格式表达。\nRSA 算法为何是可靠的呢？因为该算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。\n回顾上面的密钥生成步骤，一共出现六个数字：\n$$p,q,n,\\varphi(n),e,d$$\n这六个数字之中，公钥用到了两个（$n$和$e$），其余四个数字都是不公开的。其中最关键的是$d$，因为$n$和$d$组成了私钥，一旦$d$泄漏，就等于私钥泄漏。\n那么，有无可能在已知$n$和$e$的情况下，推导出$d$？\n$ed≡1 (mod φ(n))$。只有知道$e$和$φ(n)$，才能算出$d$。 $φ(n)=(p-1)(q-1)$。只有知道$p$和$q$，才能算出$φ(n)$。 $n=pq$。只有将$n$因数分解，才能算出 $p$ 和 $q$。 结论：如果 $n$ 可以被因数分解，$d$ 就可以算出，也就意味着私钥被破解。\n可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。\n举例来说，你可以对 3233 进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。\n12301866845301177551304949 58384962720772853569595334 79219732245215172640050726 36575187452021997864693899 56474942774063845925192557 32630345373154826850791702 61221429134616704292143116 02221240479274737794080665 351419597459856902143413 它等于这样两个质数的乘积：\n33478071698956898786044169 84821269081770479498371376 85689124313889828837938780 02287614711652531743087737 814467999489 × 36746043666799590428244633 79962795263227915816434308 76426760322838157396665112 79233373417143396810270092 798736308917 事实上，这大概是人类已经分解的最大整数（232 个十进制位，768 个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长 RSA 密钥就是 768 位。\n签名与证书 参考 Learn Cryptography 浅谈常见的七种加密算法及实现 - 掘金 RSA 算法原理（一） - 阮一峰的网络日志 RSA 算法原理（二） - 阮一峰的网络日志 加密解密 - 面试官：说一下你常用的加密算法_个人文章 - SegmentFault 思否 ","permalink":"https://lifeislife.cn/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","summary":"\u003ch1 id=\"基本概念\"\u003e基本概念\u003c/h1\u003e\n\u003ch2 id=\"明文与密文\"\u003e明文与密文\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ePlaintext，明文，未经加密的消息，任何人都可以读\u003c/li\u003e\n\u003cli\u003eCiphertext，密文，加密后的消息，不可读\u003c/li\u003e\n\u003cli\u003eKey，密钥，用于加密和解密（核心是算法）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"加密与解密概念\"\u003e加密与解密概念\u003c/h2\u003e\n\u003ch3 id=\"加密\"\u003e加密\u003c/h3\u003e\n\u003cp\u003e数据加密 的基本过程，就是对原来为 明文 的文件或数据按 某种算法 进行处理，使其成为 不可读 的一段代码，通常称为“密文”。通过这样的途径，来达到 保护数据 不被 非法人窃取、阅读的目的。\u003c/p\u003e","title":"加密算法总结"},{"content":"需求背景 如果参与 Linux、QEMU 或者 OpenSBI 等开源项目，不能通过在 GitHub 或者 Gitlab 平台提交pull request。而是需要将修改的代码，通过 Patch 形式提交到对应的listserv供 Maintainer 审核。那么如何创建 Patch 并发送呢？\n这里以向 OpenSBI 提交一个 Patch 为例。\n创建 Patch 首先将官方 Repository，Fork 到自己的 GitHub：\n\u003c!DOCTYPE html\u003e Responsive Image 回到自己的主页，找到刚刚 Fork 的 Repository，将其 Clone 到本地：\n\u003c!DOCTYPE html\u003e Responsive Image 修改代码与正常开发流程一直，修改完在git commit时需要加上Signed-off-by字段，因为 Merge 代码的人通常不是提交代码的人，有该字段才能证明是你修改了对应的代码。\n-s参数会自动加上Signed-off-by字段：\n$ git commit -s doc:fix some typos Signed-off-by: dominic \u0026lt;dominic@gmail.com\u0026gt; # Please enter the commit message for your changes. Lines starting # with \u0026#39;#\u0026#39; will be ignored, and an empty message aborts the commit. # # Date: Tue Sep 27 21:11:41 2022 +0800 # # On branch master # Your branch is up to date with \u0026#39;origin/master\u0026#39;. # # Changes to be committed: # modified: docs/domain_support.md # modified: docs/library_usage.md # modified: docs/platform_requirements.md # modified: docs/pmu_support.md 生成.patch文件：\n$ git format-patch HEAD^ 0001-doc-fix-some-typos.patch 在当前目录下会生成一个0001-doc-fix-some-typos.patch文件：\n$ git status On branch master Your branch is up to date with \u0026#39;origin/master\u0026#39;. Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) 0001-doc-fix-some-typos.patch nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) 这个文件就是我们要发送的文件，文件内容就是我们的代码修改，以及作者等信息：\n$ cat 0001-doc-fix-some-typos.patch From d404cb82f4c4aca15dcd35855d0bc96c5b4431d5 Mon Sep 17 00:00:00 2001 From: Dunky-Z \u0026lt;xxxxxxxxx@qq.com\u0026gt; Date: Tue, 27 Sep 2022 21:11:41 +0800 Subject: [PATCH] doc:fix some typos Signed-off-by: dominic \u0026lt;dominic@gmail.com\u0026gt; --- docs/domain_support.md | 6 +++--- docs/library_usage.md | 2 +- docs/platform_requirements.md | 2 +- docs/pmu_support.md | 10 +++++----- 4 files changed, 10 insertions(+), 10 deletions(-) diff --git a/docs/domain_support.md b/docs/domain_support.md index 73931f1..8963b57 100644 --- a/docs/domain_support.md +++ b/docs/domain_support.md @@ -2,7 +2,7 @@ OpenSBI Domain Support ====================== ... 配置 send-email 安装 git-email 通过git直接发送 Patch 需要使用git-email工具，得手动安装：\nsudo apt install git-email Windows 平台在安装 Git 时默认已安装\n生成 smtp 授权码 登录QQ 邮箱 - 帐户：\n\u003c!DOCTYPE html\u003e Responsive Image 开启 IMAP/SMTP 服务，并生成授权码：\n\u003c!DOCTYPE html\u003e Responsive Image 根据提示发送短信：\n\u003c!DOCTYPE html\u003e Responsive Image 记录下生成的授权码：\n\u003c!DOCTYPE html\u003e Responsive Image 配置.gitconfig Ubuntu 平台：~/.gitconfig Windows 平台：C:\\Users\\用户名\\.gitconfig\n[sendemail] smtpencryption = tls smtpserver = smtp.qq.com smtpuser = dominic_riscx@qq.com smtpserverport = 587 from = dominic_riscx@qq.com smtppass = xxxxxx cc = dominic@gmail.com #to = opensbi@lists.infradead.org 为了方便复制，单独注释：\n[sendemail] smtpencryption = # 加密方式，保持默认 smtpserver = # smtp 服务器地址，保持默认 smtpuser = # 邮箱地址，改为 QQ 邮箱地址，也就是用哪个邮箱发送，就填哪个 smtpserverport = # 端口号，保持默认 from = # 同 smtpuser smtppass = # 上文生成的 smtp 授权码 cc = # 抄送的邮箱地址 #to = opensbi@lists.infradead.org # 要发送的地址，这个字段我注释了，因为怕以后发邮件默认发到这个地址，这个字段可以在发送时单独填写 发送 Patch #$ git send-email patch文件名 $ git send-email 0001-doc-fix-some-typos.patch 0001-doc-fix-some-typos.patch # 提示往哪里发送，填写要接收的邮箱即可，我这里填写的是OpenSBI接收Patch的地址 To whom should the emails be sent (if anyone)? opensbi@lists.infradead.org Message-ID to be used as In-Reply-To for the first email (if any)? # 回车，保存默认（我还不清楚这里的作用） (mbox) Adding cc: Dunky-Z \u0026lt;xxxxxxxxx@qq.com\u0026gt; from line \u0026#39;From: Dunky-Z \u0026lt;xxxxxxxxx@qq.com\u0026gt;\u0026#39; (body) Adding cc: dominic \u0026lt;dominic@gmail.com\u0026gt; from line \u0026#39;Signed-off-by: dominic \u0026lt;dominic@gmail.com\u0026gt;\u0026#39; From: dominic_riscx@qq.com To: opensbi@lists.infradead.org Cc: dominic@gmail.com, Dunky-Z \u0026lt;xxxxxxxxx@qq.com\u0026gt; Subject: [PATCH] doc:fix some typos Date: Wed, 28 Sep 2022 10:35:30 +0800 Message-Id: \u0026lt;20220928023530.2344-1-dominic_riscx@qq.com\u0026gt; X-Mailer: git-send-email 2.34.1.windows.1 MIME-Version: 1.0 Content-Transfer-Encoding: 8bit The Cc list above has been expanded by additional addresses found in the patch commit message. By default send-email prompts before sending whenever this occurs. This behavior is controlled by the sendemail.confirm configuration setting. For additional information, run \u0026#39;git send-email --help\u0026#39;. To retain the current behavior, but squelch this message, run \u0026#39;git config --global sendemail.confirm auto\u0026#39;. Send this email? ([y]es|[n]o|[e]dit|[q]uit|[a]ll): y # y 确认发送 OK. Log says: Server: smtp.qq.com MAIL FROM:\u0026lt;dominic_riscx@qq.com\u0026gt; RCPT TO:\u0026lt;opensbi@lists.infradead.org\u0026gt; RCPT TO:\u0026lt;dominic@gmail.com\u0026gt; RCPT TO:\u0026lt;xxxxxxxxx@qq.com\u0026gt; From: dominic_riscx@qq.com To: opensbi@lists.infradead.org Cc: dominic@gmail.com, Dunky-Z \u0026lt;xxxxxxxxx@qq.com\u0026gt; Subject: [PATCH] doc:fix some typos Date: Wed, 28 Sep 2022 10:35:30 +0800 Message-Id: \u0026lt;20220928023530.2344-1-dominic_riscx@qq.com\u0026gt; X-Mailer: git-send-email 2.34.1.windows.1 MIME-Version: 1.0 Content-Transfer-Encoding: 8bit Result: 250 # 发送成功 前往The opensbi Archives，找到对应的月份，点击Theread，即可找到自己发送的 Patch，每个开源社区一般都会在如何提交 PR 的文档里公开 Patch Archive 网址，这里是以 OpenSBI 的网址。\n前往邮箱发送记录中也可以找到对应的 Patch 信息：\n\u003c!DOCTYPE html\u003e Responsive Image 以上就是完整的提交 Patch 过程。\n","permalink":"https://lifeislife.cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git-send-mail%E7%BB%99%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E6%8F%90%E4%BA%A4patch/","summary":"\u003ch1 id=\"需求背景\"\u003e需求背景\u003c/h1\u003e\n\u003cp\u003e如果参与 Linux、QEMU 或者 OpenSBI 等开源项目，不能通过在 GitHub 或者 Gitlab 平台提交\u003ccode\u003epull request\u003c/code\u003e。而是需要将修改的代码，通过 Patch 形式提交到对应的\u003ccode\u003elistserv\u003c/code\u003e供 Maintainer 审核。那么如何创建 Patch 并发送呢？\u003c/p\u003e","title":"如何使用 git-send-mail 给开源社区提交 Patch"},{"content":"目标、依赖、命令 目标就是我们要去 make xxx 的那个 xxx，就是我们最终要生成的东西。 依赖是用来生成目录的原材料 命令就是加工方法，所以 make xxx 的过程其实就是使用命令将依赖加工成目标的过程。 通配符 % 和 Makefile 自动推导 % 是 Makefile 中的通配符，代表一个或几个字母。也就是说%.o就代表所有以.o为结尾的文件。 所谓自动推导其实就是 Makefile 的规则。当 Makefile 需要某一个目标时，他会把这个目标去套规则说明，一旦套上了某个规则说明，则 Makefile 会试图寻找这个规则中的依赖，如果能找到则会执行这个规则用依赖生成目标。 Makefile 中定义和使用变量 Makefile 中定义和使用变量，和 shell 脚本中非常相似。相似的是都没有变量类型，直接定义使用，引用变量时用$var。 伪目标（.PHONY） 伪目标意思是这个目标本身不代表一个文件，执行这个目标不是为了得到某个文件或东西，而是单纯为了执行这个目标下面的命令。 伪目标一般都没有依赖，因为执行伪目标就是为了执行目标下面的命令。既然一定要执行命令了那就不必加依赖，因为不加依赖意思就是无条件执行。 伪目标可以直接写，不影响使用；但是有时候为了明确声明这个目标是伪目标会在伪目标的前面用.PHONY来明确声明它是伪目标。 Makfile 中引用其他 Makefile 有时候 Makefile 总体比较复杂，因此分成好几个 Makefile 来写。然后在主 Makefile 中引用其他的，用 include 指令来引用。引用的效果也是原地展开，和 C 语言中的头文件包含非常相似。 赋值 =最简单的赋值 :=一般也是赋值 以上这两个大部分情况下效果是一样的，但是有时候不一样。用=赋值的变量，在被解析时他的值取决于最后一次赋值时的值，所以你看变量引用的值时不能只往前面看，还要往后面看。用:=来赋值的，则是就地直接解析，只用往前看即可。\n?=如果变量前面并没有赋值过则执行这条赋值，如果前面已经赋值过了则本行被忽略。（实验可以看出：所谓的没有赋值过其实就是这个变量没有被定义过） +=用来给一个已经赋值的变量接续赋值，意思就是把这次的值加到原来的值的后面，有点类似于 strcat。（注意一个细节，+=续接的内容和原来的内容之间会自动加一个空格隔开） 注意：Makefile 中并不要求赋值运算符两边一定要有空格或者无空格，这一点比 shell 的格式要求要松一些。\nMakefile 的环境变量 makefile 中用 export 导出的就是环境变量。一般情况下要求环境变量名用大写，普通变量名用小写。 环境变量和普通变量不同，可以这样理解：环境变量类似于整个工程中所有 Makefile 之间可以共享的全局变量，而普通变量只是当前本 Makefile 中使用的局部变量。所以要注意：定义了一个环境变量会影响到工程中别的 Makefile 文件，因此要小心。 Makefile 中可能有一些环境变量可能是 makefile 本身自己定义的内部的环境变量或者是当前的执行环境提供的环境变量（譬如我们在 make 执行时给 makefile 传参。make CC=arm-linux-gcc，其实就是给当前 Makefile 传了一个环境变量 CC，值是 arm-linux-gcc。我们在 make 时给 makefile 传的环境变量值优先级最高的，可以覆盖 makefile 中的赋值）。这就好像 C 语言中编译器预定义的宏__LINE__ __FUNCTION__等一样。 Makefile 中使用通配符 *：若干个任意字符 ?：1 个任意字符 []：将 [] 中的字符依次去和外面的结合匹配 还有个%，也是通配符，表示任意多个字符，和*很相似，但是%一般只用于规则描述中，又叫做规则通配符。\nMakefile 的自动变量 为什么使用自动变量。在有些情况下文件集合中文件非常多，描述的时候很麻烦，所以我们 Makefile 就用一些特殊的符号来替代符合某种条件的文件集，这就形成了自动变量。 自动变量的含义：预定义的特殊意义的符号。就类似于 C 语言编译器中预制的那些宏__FILE__一样。 常见自动变量： $@：规则的目标文件名 $\u0026lt;：规则的依赖文件名 $^：依赖的文件集合 其他 Makefile 中的注释用# 在 makefile 的命令行中前面的@表示静默执行 Makefile 中默认情况下在执行一行命令前会先把这行命令给打印出来，然后再执行这行命令 如果你不想看到命令本身，只想看到命令执行就静默执行即可 ","permalink":"https://lifeislife.cn/posts/makefile%E5%9F%BA%E7%A1%80/","summary":"\u003ch2 id=\"目标依赖命令\"\u003e目标、依赖、命令\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e目标就是我们要去 make xxx 的那个 xxx，就是我们最终要生成的东西。\u003c/li\u003e\n\u003cli\u003e依赖是用来生成目录的原材料\u003c/li\u003e\n\u003cli\u003e命令就是加工方法，所以 make xxx 的过程其实就是使用命令将依赖加工成目标的过程。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"通配符--和-makefile-自动推导\"\u003e通配符 \u003ccode\u003e%\u003c/code\u003e 和 Makefile 自动推导\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e%\u003c/code\u003e 是 Makefile 中的通配符，代表一个或几个字母。也就是说\u003ccode\u003e%.o\u003c/code\u003e就代表所有以\u003ccode\u003e.o\u003c/code\u003e为结尾的文件。\u003c/li\u003e\n\u003cli\u003e所谓自动推导其实就是 Makefile 的规则。当 Makefile 需要某一个目标时，他会把这个目标去套规则说明，一旦套上了某个规则说明，则 Makefile 会试图寻找这个规则中的依赖，如果能找到则会执行这个规则用依赖生成目标。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"makefile-中定义和使用变量\"\u003eMakefile 中定义和使用变量\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eMakefile 中定义和使用变量，和 shell 脚本中非常相似。相似的是都没有变量类型，直接定义使用，引用变量时用\u003ccode\u003e$var\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"伪目标phony\"\u003e伪目标（\u003ccode\u003e.PHONY\u003c/code\u003e）\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e伪目标意思是这个目标本身不代表一个文件，执行这个目标不是为了得到某个文件或东西，而是单纯为了执行这个目标下面的命令。\u003c/li\u003e\n\u003cli\u003e伪目标一般都没有依赖，因为执行伪目标就是为了执行目标下面的命令。既然一定要执行命令了那就不必加依赖，因为不加依赖意思就是无条件执行。\u003c/li\u003e\n\u003cli\u003e伪目标可以直接写，不影响使用；但是有时候为了明确声明这个目标是伪目标会在伪目标的前面用\u003ccode\u003e.PHONY\u003c/code\u003e来明确声明它是伪目标。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"makfile-中引用其他-makefile\"\u003eMakfile 中引用其他 Makefile\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e有时候 Makefile 总体比较复杂，因此分成好几个 Makefile 来写。然后在主 Makefile 中引用其他的，用 \u003ccode\u003einclude\u003c/code\u003e 指令来引用。引用的效果也是原地展开，和 C 语言中的头文件包含非常相似。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"赋值\"\u003e赋值\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e=\u003c/code\u003e最简单的赋值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:=\u003c/code\u003e一般也是赋值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e以上这两个大部分情况下效果是一样的，但是有时候不一样。用\u003ccode\u003e=\u003c/code\u003e赋值的变量，在被解析时他的值取决于最后一次赋值时的值，所以你看变量引用的值时不能只往前面看，还要往后面看。用\u003ccode\u003e:=\u003c/code\u003e来赋值的，则是就地直接解析，只用往前看即可。\u003c/p\u003e","title":"Makefile 基础"},{"content":"脚本语言 常用的脚本语言有 sh、bash、csh、ksh、perl、python； 在 Linux 下常用的脚本语言其实就是 bash、sh； 脚本语言一般在嵌入式中应用，主要是用来做配置。（一个复杂的嵌入式程序都是可配置的，配置过程就是用脚本语言来实现的）自然不会使用过于复杂的脚本语言特性，因此只需要针对性的学习即可。 shell 脚本的运行机制 C/C++ 语言这种编写过程是：编写出源代码（源代码是不能直接运行的）然后编译链接形成可执行二进制程序，然后才能运行；而脚本程序不同，脚本程序编写好后源代码即可直接运行（没有编译链接过程）； shell 程序是解释运行的，所谓解释运行就是说当我们执行一个 shell 程序时，shell 解析器会逐行的解释 shell 程序代码，然后一行一行的去运行。（顺序结构） CPU 实际只认识二进制代码，根本不认识源代码。脚本程序源代码其实也不是二进制代码，CPU 也不认识，也不能直接执行。只不过脚本程序的编译链接过程不是以脚本程序源代码为单位进行的，而是在脚本运行过程中逐行的解释执行时才去完成脚本程序源代码转成二进制的过程（不一定是编译链接，因为这行脚本程序可能早就编译连接好了，这里我们只是调用它）。 动手写第一个 shell 编辑器与编译器 shell 程序是文本格式的，只要是文本编辑器都可以。但是因为我们的 shell 是要在 Linux 系统下运行的，所以换行符必须是\\n，而 Windows 下的换行符是\\r\\n，因此 Windows 中的编辑器写的 shell 不能在 Linux 下运行。 编译器不涉及，因为 shell 是解释性语言，直接编辑完就可以运行。 shell 程序运行的运行的三种方法 ./xx.sh，和运行二进制可执行程序方法一样。这样运行 shell 要求 shell 程序必须具有可执行权限。chmod a+x xx.sh 来添加可执行权限。 source xx.sh，source 是 Linux 的一个命令，这个命令就是用来执行脚本程序的。这样运行不需要脚本具有可执行权限。 bash xx.sh，bash 是一个脚本程序解释器，本质上是一个可执行程序。这样执行相当于我们执行了 bash 程序，然后把 xx.sh 作为 argv[1] 传给他运行。 hello world 程序和解释 shell 程序的第一行一般都是以#!/bin/sh开始，这行话的意思就是指定 shell 程序执行时被哪个解释器解释执行。所以我们这里写上/bin/sh意思就是这个shell将来被当前机器中/bin目录下的sh可执行程序执行。可以将第一行写为#!/bin/bash来指定使用bash执行该脚本。 脚本中的注释使用#，#开头的行是注释行。如果有多行需要注释，每行前面都要加#。（#就相当于是 C 语言中的//）; shell 程序的正文，由很多行 shell 语句构成。 shell 语法 shell 就是把以前命令行中键入执行的命令写成了程序。shell 其实就是为了避免反复的在命令行下手工输入而发明的一种把手工输入步骤记录下来，然后通过执行 shell 脚本程序就能再次复述原来记录的手工输入过程的一种技术。\nshell 中的变量定义和引用 变量定义和初始化。shell 是弱类型语言（语言中的变量如果有明确的类型则属于强类型语言；变量没有明确类型就是弱类型语言），和 C 语言不同。在 shell 编程中定义变量不需要制定类型，也没有类型这个概念。 变量定义时可以初始化，使用=进行初始化赋值。在 shell 中赋值的=两边是不能有空格的。 注意：shell 对语法非常在意，非常严格。很多地方空格都是必须没有或者必须有，而且不能随意有没有空格。 变量赋值，变量定义后可以再次赋值，新的赋值会覆盖老的赋值。shell 中并不刻意区分变量的定义和赋值，反正每个变量就是一个符号，这个符号的值就是最后一个给他赋值时的值。 变量引用。shell 中引用一个变量必须使用$符号，$符号就是变量解引用符号。 注意：$符号后面跟一个字符串，这个字符串就会被当作变量去解析。如果这个字符串本身没有定义，执行时并不会报错，而是把这个变量解析为空。也就是说在 shell 中没有被定义的变量其实就相当于是一个定义并赋值为空的变量。\n注意：变量引用的时候可以$var，也可以${var}。这两种的区别是在某些情况下只能用${var}而不能简单的$var。\nshell 中无引用、单引号和双引号的区别 shell 中使用字符串可以不加双引号，直接使用。而且有空格时也可以，但是缺陷是不能输出\u0026quot;或者其他转义字符。 shell 中也可以使用单引号来表示字符串，也是直接使用的，不能输出转义字符。 单引号中：完全字面替换（不可包含单引号本身） 双引号中： $加变量名可以取变量的值 反引号仍表示命令替换 \\$表示$的字面值（输出$符号） `表示`的字面值 \\\u0026quot;表示\u0026quot;的字面值 \\\\表示\\的字面值 除以上情况之外，在其它字符前面的\\无特殊含义，只表示字面值。\n单引号会原样输出，双引号可以调用命令：\nPATH_A=\u0026#34;`pwd`/include\u0026#34; PATH_B=\u0026#39;`pwd`/include\u0026#39; echo $PATH_A # /home/a/b/include echo $PATH_B # `pwd`/include shell 中调用 Linux 命令 直接执行 反引号括起来执行。有时候我们在 shell 中调用 Linux 命令是为了得到这个命令的返回值（结果值），这时候就适合用一对反引号 (键盘上 ESC 按键下面的那个按键，和~在一个按键上) 来调用执行命令。 shell 中的选择分支结构 shell 的 if 语言用法很多，在此只介绍常用的，其他感兴趣可以自己去学 典型if语言格式：\nif [ 表达式 ]; then xxx yyy zzz else xxx ddd uuu fi if 的典型应用 -f判断文件是否存在，注意[]里面前后都有空格，不能省略\n-d判断目录是否存在\n\u0026quot;str1\u0026quot; = \u0026quot;str2\u0026quot;判断字符串是否相等，注意用一个等号而不是两个\n判断数字是否相等\n-eq等于 -gt大于 -lt小于 -ge大于等于 -le小于等于 -z判断字符串是否为空，注意-z判断时如果变量本身没定义也是不成立（也就是说-z 认为没定义不等于为空）\n-o表示逻辑或，连接两个表达式\nif [ 10 -eq 10 -o ]; then \u0026amp;\u0026amp; ||表示逻辑与和逻辑或\nshell 中的循环结构 for 循环，要求能看懂、能改即可。不要求能够完全不参考写出来。因为毕竟嵌入式并不需要完全重新手写。\nwhile 循环，和 C 语言的循环在逻辑上无差别，要注意很多格式要求，譬如：while 后面的 [] 两边都有空格，[] 后面有分号（如果 do 放在一行的话），i++的写法中有两层括号。\necho 的创建和追加输入文件 在 shell 中可以直接使用 echo 指令新建一个文件，并且将一些内容传入这个文件中。创建文件并输入内容的关键就是\u0026gt;。 还可以使用 echo 指令配合追加符号\u0026gt;\u0026gt; 向一个已经存在的文件末尾追加输入内容。 shell 中其他值得关注的知识点 case 语句 shell 中的 case 语句和 C 语言中的 switch case 语句作用一样，格式有差异 shell 中的 case 语句天生没有 break，也不需要break，和 C 语言中的 switch case 不同。shell 中的 case 默认就是匹配上哪个执行哪个，不会说执行完了还去执行后面的其他 case 调用 shell 程序的传参 C 语言中可以通过 main 函数的 argc 和 argv 给程序传参 shell 程序本身也可以在调用时传参给他。在 shell 程序内部使用传参也是使用的一些特定符号来表示的，包括： $#表示调用该 shell 时传参的个数。（$#计数时只考虑真正的参数个数） $0、$1、$2·····则依次表示传参的各个参数 ./a.out aa bb cc # argc = 4 # argv[0] = ./a.out # argv[1] 是第一个有效参数···· source a.sh aa bb cc # $# = 3 # $0是执行这个 shell 程序的解析程序的名字 # $1是第一个有效参数的值 # $2是第 2 个有效参数的值····· while 循环和 case 语言和传参结合 shell 中的 break 关键字和 C 语言中意义相同（都是跳出）但是用法不同。因为 shell 中 case 语句默认不用 break 的，因此在 shell 中 break 只用于循环跳出。所以当 while 中内嵌 case 语句时，case 中的 break 是跳出外层的 while 循环的，不是用来跳出 case 语句的。 shell 中的$# $1等内置变量的值是可以被改变，被 shift 指令改变。shift 指令有点像左移运算符，把我们给 shell 程序的传参左移了一个移出去了，原来的$2变成了新的$1，原来的$#少了 1 个。 ","permalink":"https://lifeislife.cn/posts/%E5%B5%8C%E5%85%A5%E5%BC%8Fshell%E5%9F%BA%E7%A1%80/","summary":"\u003ch2 id=\"脚本语言\"\u003e脚本语言\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e常用的脚本语言有 sh、bash、csh、ksh、perl、python；\u003c/li\u003e\n\u003cli\u003e在 Linux 下常用的脚本语言其实就是 bash、sh；\u003c/li\u003e\n\u003cli\u003e脚本语言一般在嵌入式中应用，主要是用来做配置。（一个复杂的嵌入式程序都是可配置的，配置过程就是用脚本语言来实现的）自然不会使用过于复杂的脚本语言特性，因此只需要针对性的学习即可。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"shell-脚本的运行机制\"\u003eshell 脚本的运行机制\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eC/C++ 语言这种编写过程是：编写出源代码（源代码是不能直接运行的）然后编译链接形成可执行二进制程序，然后才能运行；而脚本程序不同，脚本程序编写好后源代码即可直接运行（没有编译链接过程）；\u003c/li\u003e\n\u003cli\u003eshell 程序是解释运行的，所谓解释运行就是说当我们执行一个 shell 程序时，shell 解析器会逐行的解释 shell 程序代码，然后一行一行的去运行。（顺序结构）\u003c/li\u003e\n\u003cli\u003eCPU 实际只认识二进制代码，根本不认识源代码。脚本程序源代码其实也不是二进制代码，CPU 也不认识，也不能直接执行。只不过脚本程序的编译链接过程不是以脚本程序源代码为单位进行的，而是在脚本运行过程中逐行的解释执行时才去完成脚本程序源代码转成二进制的过程（不一定是编译链接，因为这行脚本程序可能早就编译连接好了，这里我们只是调用它）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"动手写第一个-shell\"\u003e动手写第一个 shell\u003c/h2\u003e\n\u003ch3 id=\"编辑器与编译器\"\u003e编辑器与编译器\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eshell 程序是文本格式的，只要是文本编辑器都可以。但是因为我们的 shell 是要在 Linux 系统下运行的，所以换行符必须是\u003ccode\u003e\\n\u003c/code\u003e，而 Windows 下的换行符是\u003ccode\u003e\\r\\n\u003c/code\u003e，因此 Windows 中的编辑器写的 shell 不能在 Linux 下运行。\u003c/li\u003e\n\u003cli\u003e编译器不涉及，因为 shell 是解释性语言，直接编辑完就可以运行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"shell-程序运行的运行的三种方法\"\u003eshell 程序运行的运行的三种方法\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e./xx.sh\u003c/code\u003e，和运行二进制可执行程序方法一样。这样运行 shell 要求 shell 程序必须具有可执行权限。\u003ccode\u003echmod a+x xx.sh\u003c/code\u003e 来添加可执行权限。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esource xx.sh\u003c/code\u003e，\u003ccode\u003esource\u003c/code\u003e 是 Linux 的一个命令，这个命令就是用来执行脚本程序的。这样运行不需要脚本具有可执行权限。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebash xx.sh\u003c/code\u003e，\u003ccode\u003ebash\u003c/code\u003e 是一个脚本程序解释器，本质上是一个可执行程序。这样执行相当于我们执行了 \u003ccode\u003ebash\u003c/code\u003e 程序，然后把 \u003ccode\u003exx.sh\u003c/code\u003e 作为 \u003ccode\u003eargv[1]\u003c/code\u003e 传给他运行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"hello-world-程序和解释\"\u003ehello world 程序和解释\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eshell 程序的第一行一般都是以\u003ccode\u003e#!/bin/sh\u003c/code\u003e开始，这行话的意思就是指定 shell 程序执行时被哪个解释器解释执行。所以我们这里写上\u003ccode\u003e/bin/sh\u003c/code\u003e意思就是这个\u003ccode\u003eshell\u003c/code\u003e将来被当前机器中\u003ccode\u003e/bin\u003c/code\u003e目录下的\u003ccode\u003esh\u003c/code\u003e可执行程序执行。可以将第一行写为\u003ccode\u003e#!/bin/bash\u003c/code\u003e来指定使用\u003ccode\u003ebash\u003c/code\u003e执行该脚本。\u003c/li\u003e\n\u003cli\u003e脚本中的注释使用\u003ccode\u003e#\u003c/code\u003e，\u003ccode\u003e#\u003c/code\u003e开头的行是注释行。如果有多行需要注释，每行前面都要加\u003ccode\u003e#\u003c/code\u003e。（\u003ccode\u003e#\u003c/code\u003e就相当于是 C 语言中的\u003ccode\u003e//\u003c/code\u003e）;\u003c/li\u003e\n\u003cli\u003eshell 程序的正文，由很多行 shell 语句构成。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"shell-语法\"\u003eshell 语法\u003c/h2\u003e\n\u003cp\u003eshell 就是把以前命令行中键入执行的命令写成了程序。shell 其实就是为了避免反复的在命令行下手工输入而发明的一种把手工输入步骤记录下来，然后通过执行 shell 脚本程序就能再次复述原来记录的手工输入过程的一种技术。\u003c/p\u003e","title":"嵌入式 Shell 基础"},{"content":"使用背景 chattr命令可以修改 Linux 的文件属性，在类 Unix 等发行版中，该命令能够有效防止文件和目录被意外的删除或修改。文件在 Linux 中被描述为一个数据结构，chattr 命令在大多数现代 Linux 操作系统中是可用的，可以修改文件属性，一旦定义文件的隐藏属性，那么该文件的拥有者和 root 用户也无权操作该文件，只能解除文件的隐藏属性。这就可以有效的避免被误删除。\n命令格式 一个完整的命令一般由命令 (chattr)，可选项 (option)，操作符 (operator) 与属性 (attribute) 组成：\nchattr [option] [operator] [attribute] file [option] 可选项：\n-R， 递归更改目录及其内容的属性。 -V， 详细说明chattr的输出并打印程序版本。 -f， 隐藏大多数错误消息。 [operator] 操作符：\n+，追加指定属性到文件已存在属性中 -， 删除指定属性 =，直接设置文件属性为指定属性 [attribute] 属性如下：\na， 只能向文件中添加数据 A，不更新文件或目录的最后访问时间 i， 文件或目录不可改变 使用实例 lsattr 命令检查文件已有属性 -d：如果目标是目录，只会列出目录本身的隐藏属性，而不会列出所含文件或子目录的隐藏属性信息 -R：作用于目录时，会显示所有的子目录和文件的隐藏信息 $ lsattr clash --------------e------- clash/glados.yaml --------------e------- clash/clash-linux-386-v1.10.0 --------------e------- clash/Country.mmdb --------------e------- clash/cache.db --------------e------- clash/clash-linux-amd64-v1.10.0 --------------e------- clash/dashboard $ lsattr -d clash --------------e------- clash $ lsattr -R clash --------------e------- clash/glados.yaml --------------e------- clash/clash-linux-386-v1.10.0 --------------e------- clash/Country.mmdb --------------e------- clash/cache.db --------------e------- clash/clash-linux-amd64-v1.10.0 --------------e------- clash/dashboard clash/dashboard: --------------e------- clash/dashboard/manifest.webmanifest --------------e------- clash/dashboard/assets clash/dashboard/assets: --------------e------- clash/dashboard/assets/logo.b453e72f.png --------------e------- clash/dashboard/assets/index.408383.js --------------e------- clash/dashboard/assets/index.966f8a.css --------------e------- clash/dashboard/assets/vendor.ca5569.js --------------e------- clash/dashboard/sw.js --------------e------- clash/dashboard/workbox-7ce28d.js --------------e------- clash/dashboard/index.html 禁止对文件test.md重命名，移动或删除，也不能修改其内容 sudo chattr +i test.md 尝试修改该文件，将会被拒绝：\n$ rm -f ./test.md rm: cannot remove \u0026#39;./test.md\u0026#39;: Operation not permitted $ echo \u0026#39;Hello World!\u0026#39; \u0026gt; test.md bash: ./test.md: Operation not permitted $ mv ./test.md ./fileDir mv: cannot move \u0026#39;./test.md\u0026#39; to \u0026#39;./fileDir/test.md\u0026#39;: Operation not permitted 禁止修改文件夹fileDir及文件夹中的数据 mkdir ./fileDir \u0026amp;\u0026amp; touch ./fileDir/test.md sudo chattr +i -R ./fileDir 尝试修改文件夹中的内容：\n$ rm -rf ./fileDir rm: cannot remove \u0026#39;./fileDir/test.md\u0026#39;: Operation not permitted 允许向文件添加内容，禁止修改或删除内容，禁止移动文件 $ sudo chattr +a ./test.md $ lsattr ./test.md -----a--------e--- ./test.md $ echo \u0026#34;Hello World!\u0026#34; \u0026gt;\u0026gt; ./test.md # 追加内容 OK $ echo \u0026#34;hello\u0026#34;\u0026gt; ./test.md # 修改内容 NO bash: ./test.md: Operation not permitted 只允许在目录fileDir中建立和修改文件，但是禁止删除、移动文件 sudo chattr +a ./fileDir 取消某个属性 使用-操作符即可：\n# 先给文件添加属性a $ sudo chattr +a ./test.md $ lsattr ./test.md -----a--------e--- ./test.md # 取消属性a $ sudo chattr -a ./test.md $ lsattr ./test.md --------------e--- ./test.md ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-chattr%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7%E9%98%B2%E6%AD%A2%E8%AF%AF%E5%88%A0%E9%99%A4/","summary":"\u003ch2 id=\"使用背景\"\u003e使用背景\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003echattr\u003c/code\u003e命令可以修改 Linux 的文件属性，在类 Unix 等发行版中，该命令能够有效防止文件和目录被意外的删除或修改。文件在 Linux 中被描述为一个数据结构，\u003ccode\u003echattr\u003c/code\u003e 命令在大多数现代 Linux 操作系统中是可用的，可以修改文件属性，一旦定义文件的隐藏属性，那么\u003cstrong\u003e该文件的拥有者和 root 用户也无权操作该文件\u003c/strong\u003e，只能解除文件的隐藏属性。这就可以有效的避免被误删除。\u003c/p\u003e","title":"每天学命令-chattr 修改文件与目录属性防止误删除"},{"content":"使用 Pandoc 将test.md转换位 PDF 时，出现如下错误：\n! Undefined control sequence. \u0026lt;recently read\u0026gt; \\tightlist l.213 \\end{frame} pandoc: Error producing PDF from TeX source make: *** [test.pdf] Error 43 这是因为在 Markdown 文件中使用-表示无序列表，被转化成了\\tightlist但是 Pandoc 版本太老，不支持这个命令。（严格来说是 Pandoc 没有处理这个 LaTeX 命令，不是不支持，因为这是 LaTeX 命令和 Pandoc 没关系）。\n有两种方式解决，一是升级 Pandoc 版本，二是将处理\\tightlist的命令加到自己使用的模板中。\n\\providecommand{\\tightlist}{% \\setlength{\\itemsep}{0pt}\\setlength{\\parskip}{0pt}} 或者\n\\def\\tightlist{} ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3pandoc%E5%B0%86md%E8%BD%AC%E6%8D%A2%E4%B8%BApdf%E6%97%B6%E6%8A%A5%E9%94%99-error-tightlist/","summary":"\u003cp\u003e使用 Pandoc 将\u003ccode\u003etest.md\u003c/code\u003e转换位 PDF 时，出现如下错误：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e! Undefined control sequence.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u0026lt;recently read\u0026gt; \u003cspan class=\"se\"\u003e\\t\u003c/span\u003eightlist \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003el.213 \u003cspan class=\"se\"\u003e\\e\u003c/span\u003end\u003cspan class=\"o\"\u003e{\u003c/span\u003eframe\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epandoc: Error producing PDF from TeX \u003cspan class=\"nb\"\u003esource\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emake: *** \u003cspan class=\"o\"\u003e[\u003c/span\u003etest.pdf\u003cspan class=\"o\"\u003e]\u003c/span\u003e Error \u003cspan class=\"m\"\u003e43\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这是因为在 Markdown 文件中使用\u003ccode\u003e-\u003c/code\u003e表示无序列表，被转化成了\u003ccode\u003e\\tightlist\u003c/code\u003e但是 Pandoc 版本太老，不支持这个命令。（严格来说是 Pandoc 没有处理这个 LaTeX 命令，不是不支持，因为这是 LaTeX 命令和 Pandoc 没关系）。\u003c/p\u003e","title":"解决 Pandoc 将 MD 转换为 PDF 时报错 (error)\\tightlist"},{"content":"Markdown 简介 Markdown 是什么？ Markdown是一种轻量级标记语言，它以纯文本形式 (易读、易写、易更改) 编写文档，并最终以 HTML 格式发布。\nMarkdown也可以理解为将以 Markdown 语法编写的语言转换成 HTML 内容的工具。\n谁创造了它？ 它由Aaron Swartz和John共同设计，Aaron Swartz就是那位于去年（2013 年 1 月 11 日）自杀，有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。\n14 岁参与 RSS 1.0 规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年 7 月 19 日，因被控从 MIT 和 JSTOR 下载 480 万篇学术论文并以免费形式上传于网络被捕。 2013年 1 月自杀身亡。 为什么要使用它？ 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容 HTML，可以转换为 HTML 格式发布。 跨平台使用。 越来越多的网站支持 Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱 Word 怎么使用？ 如果不算扩展，Markdown 的语法绝对简单到让你爱不释手。\nMarkdown 语法主要分为如下几大部分：\n标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \\，符号\u0026rsquo;`\u0026rsquo;。\n谁在用？ Markdown 的使用者：\nGitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 语法介绍 标题 两种形式：\n使用=和-标记一级和二级标题。\n一级标题 ========= 二级标题 ---------\n使用#，可表示 1-6 级标题。\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题\n段落 段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。\n区块引用 区块引用需要在被引用的文本前加上 \u0026gt; 符号。\n\u0026gt; 这是一个区块引用实例， \u0026gt; Markdown. 这是一个区块引用实例，\nMarkdown.\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 \u0026gt; :\n\u0026gt; 平生不会相思， 才会相思， 便害相思。 \u0026gt; 空一缕余香在此， 盼千金游子何之。 平生不会相思， 才会相思， 便害相思。\n空一缕余香在此， 盼千金游子何之。\n引用的多层嵌套 区块引用可以嵌套（例如：引用内的引用）, 只要根据层次加上不同数量的 \u0026gt; :\n\u0026gt;\u0026gt;\u0026gt; 锄禾日当午，汗滴禾下土。 - 李绅 \u0026gt;\u0026gt; 山有木兮木有枝，心悦君兮君不知。 - 越人歌 \u0026gt; 去年今日此门中，人面桃花相映红。 - 崔护 锄禾日当午，汗滴禾下土。 - 李绅\n山有木兮木有枝，心悦君兮君不知。 - 越人歌\n去年今日此门中，人面桃花相映红。 - 题都城南庄\n锚点 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击跳转到指定章节。\n[点击跳转至区块引用](#区块引用) 点击跳转至区块引用\n代码区块 代码区块的建立是在每行加上 4 个空格或者一个制表符（如同写代码一样）。如 普通段落：\nvoid main() { printf(\u0026ldquo;Hello, Markdown.\u0026rdquo;); }\n代码区块：\nvoid main() { printf(\u0026quot;Hello, Markdown.\u0026quot;); } 注意:需要和普通段落之间存在空行。\n强调 Markdown 使用星号*和底线_作为标记强调字词的符号。\n斜体 *花自飘零水自流* 花自飘零水自流\n粗体 **花自飘零水自流** 花自飘零水自流\n删除线 ~~花自飘零水自流~~ 花自飘零水自流\n列表 使用·、+、或-标记无序列表，如：\n-（+*）第一项 -（+*）第二项 - （+*）第三项\n注意：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n效果：\n第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字，并辅以.，如：\n1 . 第一项 2 . 第二项 3 . 第三项\n效果：\n第一项 第二项 第三项 分割线 分割线最常使用就是三个或以上*，还可以使用-和_。\n链接 Markdown 支持两种形式的链接语法：行内式和参考式两种形式，行内式一般使用较多。\n行内式 []里写链接文字，()里写链接地址，()中的 \u0026quot;\u0026quot; 中可以为链接指定 title 属性，title 属性可加可不加。title 属性的效果是鼠标悬停在链接上会出现指定的 title 文字。[链接文字](链接地址 \u0026quot;链接标题\u0026quot;) 这样的形式。链接地址与链接标题前有一个空格。\n[MPPL: Markdown to PDF with Pandoc via Latex](https://github.com/Dunky-Z/MPPL) [MPPL: Markdown to PDF with Pandoc via Latex](https://github.com/Dunky-Z/MPPL \u0026#34;MPPL\u0026#34;) MPPL: Markdown to PDF with Pandoc via Latex\nMPPL: Markdown to PDF with Pandoc via Latex\n参考式 参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用的方式创建链接将非常好，它可以让你对链接进行统一的管理。\n参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加 [链接标记]:链接地址 \u0026quot;链接标题\u0026quot;, 链接地址与链接标题前有一个空格。\n全球最大的搜索引擎网站是 [Google][1]。 [1]:http://www.google.com \u0026#34;Google\u0026#34; 全球最大的搜索引擎网站是 Google。 图片 图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。\n语法中图片 Alt 的意思是如果图片因为某些原因不能显示，就用定义的图片 Alt 文字来代替图片。图片 Title 则和链接中的 Title 一样，表示鼠标悬停与图片上时出现的文字。Alt 和 Title 都不是必须的，可以省略，但建议写上。\n图片行内式 ![图片 Alt](图片地址 \u0026quot;图片Title\u0026quot;)\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Markdown-mark.svg/2880px-Markdown-mark.svg.png) \u003c!DOCTYPE html\u003e Responsive Image 图片参考式 在文档要插入图片的地方写 ![图片 Alt][标记]。\n在文档的最后写上 [标记]:图片地址 \u0026quot;Title\u0026quot;。\n![MarkdownLogo][MarkdownLogo] [MarkdownLogo]:../img/Markdown-mark.png \u0026#34;MarkdownLogo\u0026#34; 反斜杠\\ 相当于反转义作用。使符号成为普通符号。\n代码 对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进 (Tab), 另一种是利用 \u0026ldquo;`\u0026rdquo; 符号 (一般在 ESC 键下方) 包裹代码。\n插入行内代码，即插入一个单词或者一句代码的情况，使用 `code` 这样的形式插入。 插入多行代码，可以使用缩进或者 ``` code ```, 具体看示例。 代码行内式 PHP 打印堆栈信息 `debug_backtrace()`。 PHP 打印堆栈信息 debug_backtrace()。\n缩进式多行代码 缩进 4 个空格或是 1 个制表符。\n一个代码区块会一直持续到没有缩进的那一行 (或是文件结尾)。\n$closure = function () use($name) { return $name; } $closure = function () use($name) { return $name; } 用六个 ` 包裹多行代码 \u0026gt; ```c # 为了能够在 Markdown 里演示，所以加了\u0026gt;符号 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, World!\\n\u0026#34;); return 0; } \u0026gt; ``` #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, World!\\n\u0026#34;); return 0; } 内容目录 在段落中填写 [TOC] 以显示全文内容的目录结构。\n表格 不管是哪种方式, 第一行为表头, 第二行分隔表头和主体部分, 第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐, 在-右边加上:就右对齐。 简单方式:\n诗名|作者|朝代 -|-|- 白头吟|卓文君|两汉 锦瑟|李商隐|唐代 登科后|孟郊|唐代 诗名 作者 朝代 白头吟 卓文君 两汉 锦瑟 李商隐 唐代 登科后 孟郊 唐代 原生方式:\n|诗名|作者|朝代| |-|-|-| |白头吟|卓文君|两汉| |锦瑟|李商隐|唐代| |登科后|孟郊|唐代| 诗名 作者 朝代 白头吟 卓文君 两汉 锦瑟 李商隐 唐代 登科后 孟郊 唐代 为表格第二列指定方向:\n诗名|名句 -|-: 梦微之|君埋泉下泥销骨。 上邪|上邪，我欲与君相知，长命无绝衰。 诗名 名句 梦微之 君埋泉下泥销骨。 上邪 上邪，我欲与君相知，长命无绝衰。 注脚 在需要添加注脚的文字后加上脚注名字[^注脚名字], 称为加注。 然后在文本的任意位置(一般在最后)添加脚注, 脚注前必须有对应的脚注名字。\n使用 Markdown[^1] 可以效率的书写文档，直接转换成 HTML[^2]。 [^1]: Markdown 是一种纯文本标记语言 [^2]: HyperText Markup Language 超文本标记语言 LaTeX 公式 $ 表示行内公式 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 质能守恒方程可以用一个很简洁的方程式$E=mc^2$来表达。\n$$ 表示整行公式 $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$ $$\\sum_{i=1}^n a_i=0$$\n尝试一下 Chrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。 在线的Cmd Markdown 编辑阅读器 - 作业部落出品。 Windowns下的Typora — a markdown editor, markdown reader。 Mac下的 Mou 是国人贡献的，口碑很好。 Linux下的 ReText 不错。 当然，最终境界永远都是笔下是语法，心中格式化。\n注意：不同的 Markdown 解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。 虽然有人想出面搞一个所谓的标准化的 Markdown，没想到还惹怒了健在的创始人 John Gruber。\n以上基本是所有 traditonal Markdown 的语法。\n关于其它扩展语法可参见具体工具的使用说明。\n参考资料 Markdown 基本语法。 cdoco/markdown-syntax: Markdown 语法详解。 ","permalink":"https://lifeislife.cn/posts/markdown%E8%AF%AD%E6%B3%95%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/","summary":"\u003ch1 id=\"markdown-简介\"\u003eMarkdown 简介\u003c/h1\u003e\n\u003ch2 id=\"markdown-是什么\"\u003eMarkdown 是什么？\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eMarkdown\u003c/strong\u003e是一种轻量级\u003cstrong\u003e标记语言\u003c/strong\u003e，它以纯文本形式 (\u003cem\u003e易读、易写、易更改\u003c/em\u003e) 编写文档，并最终以 HTML 格式发布。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMarkdown\u003c/strong\u003e也可以理解为将以 Markdown 语法编写的语言转换成 HTML 内容的工具。\u003c/p\u003e","title":"Markdown 语法简明教程"},{"content":"需求背景 Markdown 中的表格，只要符合语法就能够正常渲染显示，但是符合语法但是 Markdown 源码却不一定易读。就如以下的这个表格，可以正常显示，但是源码在源文件中竖线不对齐，就阅读困难。\n源码：\n|诗名|作者|朝代| |-|-|-| |白头吟|卓文君|两汉| |锦瑟|李商隐|唐代| |登科后|孟郊|唐代| 显示效果：\n诗名 作者 朝代 白头吟 卓文君 两汉 锦瑟 李商隐 唐代 登科后 孟郊 唐代 我们可以手动将其竖线对齐，如下这样就易读许多：\n| 诗名 | 作者 | 朝代 | | ------ | ------ | ---- | | 白头吟 | 卓文君 | 两汉 | | 锦瑟 | 李商隐 | 唐代 | | 登科后 | 孟郊 | 唐代 | 显示效果保持一致。但是如果一个字符一个字符去手动对齐效率太低，也不符合 Markdown 设计初衷。这就用到了额外的插件，能够辅助我们完成这个工作。\nMarkdown All in One VSCode 插件中心搜索Markdown All in One安装。\n\u003c!DOCTYPE html\u003e Responsive Image 安装完成后，使用时右击窗口选择Format Document with：\n\u003c!DOCTYPE html\u003e Responsive Image 选择Markdown All in One即可自动对齐所有表格竖线：\n\u003c!DOCTYPE html\u003e Responsive Image 常见问题 格式化文档后仍未对齐 这是由于表格中同时有中英文，而中英文字体不等宽导致的。如果对阅读要求不高，可以不用管，实际上已经格式化完成了。如果需要对齐，那么可以查看编码字体与阅读字体推荐这篇文章的中文等宽字体下载并安装，即可正常对齐。\n","permalink":"https://lifeislife.cn/posts/markdown%E8%A1%A8%E6%A0%BC%E7%AB%96%E7%BA%BF%E8%87%AA%E5%8A%A8%E5%AF%B9%E9%BD%90/","summary":"\u003ch2 id=\"需求背景\"\u003e需求背景\u003c/h2\u003e\n\u003cp\u003eMarkdown 中的表格，只要符合语法就能够正常渲染显示，但是符合语法但是 Markdown 源码却不一定易读。就如以下的这个表格，可以正常显示，但是源码在源文件中竖线不对齐，就阅读困难。\u003c/p\u003e","title":"Markdown 表格竖线自动对齐"},{"content":"Introduction Document Version 20211203\nControl and Status Registers (CSRs) Machine-Level ISA, Version 1.12 本章介绍了机器模式（M-mode）中可用的机器级操作，这是 RISC-V 系统中最高权限的模式。M 模式用于对硬件平台的低级访问，是复位时进入的第一个模式。M 模式也可以用来实现那些在硬件中直接实现过于困难或成本高昂的功能。RISC-V 的机器级 ISA 包含一个共同的核心，根据支持的其他权限级别和硬件实现的其他细节来扩展。\nMachine-Level CSRs 除了本节中描述的机器级 CSRs 外，M-mode 代码还可以访问较低特权级别的所有 CSRs。\nMachine ISA Register misa misa CSR 是 WARL 读写寄存器，报告硬件 (hart) 支持的 ISA。该寄存器在任何实现中都必须是可读的，但是可以返回零值以指示未实现 misa 寄存器，这就需要通过一个单独的非标准机制确定 CPU 功能。\n\u003c!DOCTYPE html\u003e Responsive Image MXL（机器 XLEN）字段编码本机基本整数 ISA 宽度，如表 3.1 所示。MXL 字段在支持多个基本 ISA 宽度的实现中可能是可写的。M-mode 下的有效 XLEN, MXLEN，由 MXL 的设置给出，如果 misa 为零，则有一个固定的值。重置时，MXL 字段始终设置为最广泛支持的 ISA 变种。\n\u003c!DOCTYPE html\u003e Responsive Image misa CSR 为 MXLEN 位宽。如果从 misa 读取的值不为零，该值的 MXL 字段总是表示当前的 MXLEN。如果对 misa 的写操作导致 MXLEN 发生更改，则 MXL 的位置将以新的宽度移动到 misa 的最高有效两位。\n可以使用返回的 misa 值的符号上的分支，以及可能在符号上左移一个分支和第二个分支，来快速确定基本宽度。这些检查可以用汇编代码编写，而无需知道机器的寄存器宽度（XLEN）。基本宽度由 XLEN = 2^(MXL + 4) 给出。如果 misa 为零，则可以通过将立即数 4 放置在一个寄存器中，然后一次将寄存器左移 31 位来找到基本宽度。如果在一次移位后为零，则该机器为 RV32。如果两次移位后为零，则机器为 RV64，否则为 RV128。\nExtensions 字段编码了目前存有的标准扩展，其每个 bit 都对应了字母表中的一个字母（bit 0 编码扩展“A”是否存在，bit 1 编码扩展“B”是否存在\u0026hellip; 直至 bit 25 编码“Z”）。如果基础 ISA 是 RV32I、RV64I 或 RV128I，则置位“I”bit，否则如果基础 ISA 是 RV32E，则置位“E”bit。\nExtensions 字段是一个能包含可写位的 WARL 字段（如果实现允许修改所支持的 ISA）。\n复位（reset）时，Extensions 应包含所支持扩展的最大集，如果 E 和 I 都可用，则优先选择 I。\n在通过清除 misa 中相应 bit 来禁止一个标准扩展时，由该扩展所定义或修改的指令和 CSR 将恢复为该扩展未实现时的定义，或者保留行为（revert to their defined or reserved behaviors as if the extension is not implemented）。\nRV128 base ISA 的设计尚未完工，尽管预计本 specification 中大部分的剩余部分都将适用于 RV128，但本版本的文档仅关注 RV32 和 RV64。\n如果支持用户模式（user mode），则将“U”bit 置位；如果支持主管模式（supervisor mode），则将“S”bit 置位。\n如果存在任何非标准扩展（non-standard extensions），则将“X”bit 置位。\n\u003c!DOCTYPE html\u003e Responsive Image “E”位是只读的。除非将 misa 硬连线为零，否则“E”位始终读取为“I”位的补码（补集？）。同时支持 RV32E 和 RV32I 的实现可以通过清除“I”位来选择 RV32E。\n如果 ISA 功能 x 依赖 ISA 功能 y，则尝试启用功能 x 但禁用功能 y 会导致两个功能都被禁用。例如，设置“F” = 0 和“D” = 1 会导致同时清除“F”和“D”。\n具体实现可能会在 2 或多个 misa 字段的集体设置上施加额外约束，此时将它们的集体看作是一个 WARL 字段。试图向其中写入一个不支持的组合会导致这些 bits 被置为某个支持的组合。\n写 misa 可能会增加 IALIGN，例如，通过禁用 C 扩展。如果要写入 misa 的指令增加了 IALIGN，而后一条指令的地址未按 IALIGN 位对齐，则将抑制对 misa 的写入，从而使 misa 保持不变。\n在软件启用一个之前被禁用的扩展时，除该扩展另有规定（specified），否则所有单独与该扩展有关的状态都将是未指定的（unspecified）。\nMachine Vendor ID Register mvendorid mvendorid CSR 是一个 32 位只读寄存器，提供内核供应商的 JEDEC 制造商 ID。此寄存器在任何实现中都必须是可读的，但可以返回 0，表示该字段未实现或这是非商业实现。\n\u003c!DOCTYPE html\u003e Responsive Image JEDEC 制造商 ID 通常编码为单字节连续的 0x7f 代码的序列，以不等于 0x7f 的单字节 ID 终止，并且在每个字节的最高有效位中带有奇校验位。mvendorid 在 Bank 字段中编码单字节的连续代码，并在 Offset 字段中编码最后一个字节，丢弃奇偶校验位。例如，JEDEC 制造商 ID 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x8a（十二个连续代码，后跟 0x8a）将在 mvendorid 字段中编码为 0x60a。\n译者注：JEDEC 固态技术协会（JEDEC Solid State Technology Association）是固态及半导体工业界的一个标准化组织，它由约 300 家公司成员组成，约 3300 名技术人员通过 50 个不同的委员会运作，制定固态电子方面的工业标准。JEDEC 曾经是电子工业联盟（EIA）的一部分：联合电子设备工程委员会（Joint Electron Device Engineering Council，JEDEC）。该协会制定了一个制造商标识码的标准：Standard Manufacturer’s Identification Code，通过读取mvendorid寄存器值，查阅该标准即可确定制造商。\n注：用 JEDEC 的话来说，Bank 编号比 Continuation 的数量大 1；因此，mvendorid Bank 字段编码的值比 JEDEC Bank 编号小一。\n注：以前，供应商 ID 是 RISC-V 基金会分配的编号，但这与 JEDEC 在维护制造商 ID 标准方面的工作重复。在撰写本文时，向 JEDEC 注册制造商 ID 的一次性费用为 500 美元。\nMachine-Mode Privileged Instructions Environment Call and Breakpoint Trap-Return Instructions Wait for Interrupt 等待中断指令 (WFI) 为实现提供了一个提示，即当前的 hart 可以停止，直到需要服务中断。WFI 指令的执行也可以用来通知硬件平台合适的中断应该优先路由到这个 hart。WFI 在所有特权模式下都可用，并且可用于 U 模式 (可选地)。当 mstatus 中的 TW = 1 时，该指令可能会引发非法指令异常，如第 3.1.6.5 节所述。\n\u003c!DOCTYPE html\u003e Responsive Image 如果在 hart 停止时存在或稍后出现启用的中断，则中断 trap 将在以下指令上执行，即在 trap 处理程序中恢复执行并且 mepc = pc + 4。\n","permalink":"https://lifeislife.cn/posts/zh-the-risc-v-instruction-set-manual-volume-2-%E7%89%B9%E6%9D%83%E7%BA%A7%E6%9E%B6%E6%9E%84/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eDocument Version 20211203\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"control-and-status-registers-csrs\"\u003eControl and Status Registers (CSRs)\u003c/h1\u003e\n\u003ch1 id=\"machine-level-isa-version-112\"\u003eMachine-Level ISA, Version 1.12\u003c/h1\u003e\n\u003cp\u003e本章介绍了机器模式（M-mode）中可用的机器级操作，这是 RISC-V 系统中最高权限的模式。M 模式用于对硬件平台的低级访问，是复位时进入的第一个模式。M 模式也可以用来实现那些在硬件中直接实现过于困难或成本高昂的功能。RISC-V 的机器级 ISA 包含一个共同的核心，根据支持的其他权限级别和硬件实现的其他细节来扩展。\u003c/p\u003e","title":"ZH-The RISC-V Instruction Set Manual Volume 2-特权级架构"},{"content":"Markdownlint 简介 Markdown 标记语言旨在易于阅读、编写和理解。它的灵活性既是优点也是缺点。语法众多，因此格式可能不一致。某些构造在所有解析器中都不能很好地工作，应该避免。CommonMark 规范标准化解析器。\nMarkdownlint 是一个用于 Node.js 的静态分析工具，有一个标准规范，用于强制执行 Markdown 文件的标准和一致性。\nMarkdownlint 插件使用 markdownlint提供了多种使用场景下的解决方案，如命令行，编辑器甚至 GitHub Action。因为我平时写 Markdown 文档都是使用 VSCode，所以介绍一下 VSCode 下的使用。其他编辑器包括 VIM，Sublime 也都支持，可以前往官网查阅方法。\nVSCode 需要下载插件，Ctrl+Shift+X打开插件中心，搜索Markdownlint安装即可。\n安装插件后打开 Markdown 文档，如果有不符合规范的语法将会警告标识。如，标题前后没有空行，将会标识：\n\u003c!DOCTYPE html\u003e Responsive Image 提示违反了第 22 条规范，第 22 条规范的就是标题前后需要有空行隔开。\n目前有 53 条规范，可以在markdownlint/Rules.md查看所有规范的内容。\n当然这些规范也都可以自定义是否检查，比如第 24 条规定，文档内不可以有重复的标题，但是我就有重复标题的需求，那该如何关闭这个检查呢，Markdownlint 提供了配置的方式。\nCtrl+Shift+P打开运行窗口，输入 Markdownlint，找到Creat or open the markdownlint configuration file。\n\u003c!DOCTYPE html\u003e Responsive Image 创建一个配置文件，并输入以下内容，表示关闭第 24 条规范的检查：\n{ \u0026#34;MD024\u0026#34;: false, } 这样文档中将不会有第 24 条规范的检查警告，其他检查同理。\nMarkdownlint 自定义规则 MD001 - Heading levels should only increment by one level at a time 标题等级一次只能增加一级，不能跨级。\n原理：标题代表文档的结构，跳过时可能会造成混淆 - 特别是对于可访问性场景。\nMD002 - First heading should be a top-level heading 文档的第一个标题必须是最高级的标题（标题等级 1 级到 6 级逐渐降低）\nMD003 - Heading style 整篇文档需要采用一致的标题格式。\nMD004 - Unordered list style 无序列表格式需要一致。\nMD005 - Inconsistent indentation for list items at the same level 同一级的列表缩进必须一致 在有序列表中，前面的数字序号可以左对齐，也可以右对齐 MD006 - Consider starting bulleted lists at the beginning of the line 一级列表不能缩进。\n如下为报错：\nSome text * List item * List item MD007 - Unordered list indentation 无序列表嵌套缩进时默认采用两个空格。\nMD009 - Trailing spaces 行尾最多可以添加两个空格，超过会给出警告，两个空格正好可以用于换行。\nMD010 - Hard tabs 不能使用 tab 键缩进，要使用空格。\n原理：硬制表符通常由不同的编辑器以不一致的方式呈现，并且比空格更难处理。\nMD011 - Reversed link syntax 当遇到看似链接的文本，但语法似乎已反转（[] 和 () 反转）时，将触发此规则。\nMD012 - Multiple consecutive blank lines 文档中不能有连续的空行，在代码块中此规则不会生效。\nMD013 - Line length 默认行的最大长度是 80，此规则对代码块、表格、标题也生效。\nMD014 - Dollar signs used before commands without showing output 在代码块中，终端命令前不需要有美元符号 ($) 如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号 ($)。\nMD018 - No space after hash on atx style heading 在\u0026quot;atx\u0026quot;格式的标题中，#号和文字间需用一个空格隔开。\nMD019 - Multiple spaces after hash on atx style heading 在\u0026quot;atx\u0026quot;格式的标题中，#号和文字间只能用一个空格隔开，不能有多余的空格。\nMD020 - No space inside hashes on closed atx style heading 在\u0026quot;closed_atx\u0026quot;格式的标题中，文字和前后的#号之间需用一个空格隔开。\nMD021 - Multiple spaces inside hashes on closed atx style heading 在\u0026quot;closed_atx\u0026quot;格式的标题中，文字和前后的#号之间只能用一个空格隔开，不能有多余的空格。\nMD022 - Headings should be surrounded by blank lines 标题行的上下行必须都是空行。\nMD023 - Headings must start at the beginning of the line 标题行不能缩进。\nMD024 - Multiple headings with the same content 文档不能有内容重复的标题。\nMD025 - Multiple top-level headings in the same document 同一文档只能有一个最高级的标题，默认是只能有一个 1 级标题。\nMD026 - Trailing punctuation in heading 标题行末尾不能有以下标点符号。\nMD027 - Multiple spaces after blockquote symbol 创建引用区块时，右尖括号 ( \u0026gt; ) 和文字之间有且只能有一个空格。\nMD028 - Blank line inside blockquote 两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用\u0026gt;开头。\nMD029 - Ordered list item prefix 有序列表的前缀序号格式必须只用 1 或者从 1 开始的加 1 递增数字。\nMD030 - Spaces after list markers 列表（有序、无序）的前缀符号和文字之间用 1 个空格隔开 在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进 3 个空格。\nMD031 - Fenced code blocks should be surrounded by blank lines 单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块\nMD032 - Lists should be surrounded by blank lines 列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表。\n列表的缩进必须一致。\nMD033 - Inline HTML 文档中不允许使用 HTML 语句。\nMD034 - Bare URL used 单纯的链接地址需要用尖括号 (\u0026lt;\u0026gt;) 包裹，否则有些解释器不会解释为链接。\nMD035 - Horizontal rule style 创建水平线时整篇文档要统一 (consistent)，要和文档中第一次创建水平线使用的符号一致。\nMD036 - Emphasis used instead of a heading 不能用加粗代替标题。\nMD037 - Spaces inside emphasis markers 用于创建强调的符号和强调的的文字之间不能有空格。\nMD038 - Spaces inside code span elements 当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格 如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开。\nMD039 - Spaces inside link text 链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格。\nMD040 - Fenced code blocks should have a language specified 单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮。\nMD041 - First line in a file should be a top-level heading 文档的第一个非空行应该是文档最高级的标题，默认是 1 级标题。\nMD042 - No empty links 链接的地址不能为空。\nMD043 - Required heading structure 要求标题遵循一定的结构，默认是没有规定的结构。\nMD044 - Proper names should have the correct capitalization 指定一些名称，会检查它是否有正确的大写。\nMD045 - Images should have alternate text (alt text) 图片链接必须包含描述文本（alt text）。\nMD046 - Code block style 整篇文档采用一致的代码格式。\nMD047 - Files should end with a single newline character 文档需用一个空行结尾。\nMD048 - Code fence style 表示代码块的标记需要一直，可以是波浪号，也可以是点号。但是需要保持一致。\nMD049 - Emphasis style should be consistent 强调符号需要一直，如斜体。\nMD050 - Strong style should be consistent 加粗符号需要保持一致。\nMD051 - Link fragments should be valid 锚点需要表示正确。\n","permalink":"https://lifeislife.cn/posts/%E4%BD%BF%E7%94%A8markdownlint%E5%AF%B9markdown%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5/","summary":"\u003ch1 id=\"markdownlint-简介\"\u003eMarkdownlint 简介\u003c/h1\u003e\n\u003cp\u003eMarkdown 标记语言旨在易于阅读、编写和理解。它的灵活性既是优点也是缺点。语法众多，因此格式可能不一致。某些构造在所有解析器中都不能很好地工作，应该避免。CommonMark 规范标准化解析器。\u003c/p\u003e","title":"使用 Markdownlint 对 Markdown 文本格式检查"},{"content":"需求背景 在写 MD 文档时为了追求美观，表格通常都是对齐的，这就需要字体必须等宽，但是写代码时等宽字体的因为很瘦小，不容易阅读，所以想要一个插件能够在多个字体直接快速切换。万能 VSCode 啥都有，插件中心就有一款专门切换字体的插件Font Switcher。直接搜索安装。\n\u003c!DOCTYPE html\u003e Responsive Image 配置与使用 打开配置脚本settings.json，如果以前修改过字体，找到\u0026quot;editor.fontFamily\u0026quot;配置项，如果没有就直接添加。\n这是我的字体，添加你们机器上安装的字体，每个逗号间隔都是不同的字体，可以使用Font Switcher切换，需要注意的是，字体名没有空格不需要加单引号，加了也无妨，如果有空格，一定要加引号。\n\u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Sarasa Mono SC\u0026#39;, 微软雅黑，\u0026#39;Noto Sans Mono CJK SC\u0026#39;, \u0026#39;JetBrains Mono\u0026#39;, Consolas, monospace\u0026#34;, Ctrl+Shift+P打开运行窗口，输入Switch Font，选择切换的字体。如图：\n\u003c!DOCTYPE html\u003e Responsive Image ![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/15-17-44-dd742307432154f630585e05a1f57956-GIF 2022-9-12 15-17-27-836285.gif)\n","permalink":"https://lifeislife.cn/posts/vscode%E5%AD%97%E4%BD%93%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2/","summary":"\u003ch2 id=\"需求背景\"\u003e需求背景\u003c/h2\u003e\n\u003cp\u003e在写 MD 文档时为了追求美观，表格通常都是对齐的，这就需要字体必须等宽，但是写代码时等宽字体的因为很瘦小，不容易阅读，所以想要一个插件能够在多个字体直接快速切换。万能 VSCode 啥都有，插件中心就有一款专门切换字体的插件\u003ccode\u003eFont Switcher\u003c/code\u003e。直接搜索安装。\u003c/p\u003e","title":"VSCode 字体快速切换"},{"content":"保留现场 \u003c!DOCTYPE html\u003e Responsive Image 解决方法 命令行执行\nstty sane ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E9%94%AE%E5%8F%98%E6%88%90%E5%AD%97%E7%AC%A6m/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/14-49-58-a6e2e264bfab205e0838ad8e49adec81-20220912144956-12eead.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/14-49-58-a6e2e264bfab205e0838ad8e49adec81-20220912144956-12eead.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e命令行执行\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003estty sane\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"解决 Linux 终端回车键变成字符 M"},{"content":"需求背景 用过 Python 的都知道，Python 是不向后兼容的，也就是 Python3.X 开发的程序，使用 Python2.X 环境就无法正常运行。因为很多语法都改变了。现在接触到的大部分 Python 程序都是 Python3.X 开发的，但是偶尔也会遇到使用 Python2.X 的时候。这就需要灵活切换版本。\n一般 Linux 的各个发行版都预装了 Python2.X。我使用的 Debian 就预装了 Python2.7。\n$ python -V Python 2.7.16 但是我同时也安装了 Python3.7\n$ ls /usr/bin | grep \u0026#34;python*\u0026#34; dh_python2 python python2 python2.7 python3 python3.7 python3.7m python3m alias 修改别名 $ alias python=/usr/bin/python3 $ python -V Python 3.7.3 上面的别名修改只对当前终端有效。如果要使每个窗口都使用这个别名，将别名加入~/.bashrc，如 zsh 是则是~/.zshrc。\n软链接 和修改别名类似\nln -s python /usr/bin/python3 update-alternatives update-alternatives是 Debian 系统提供的一个工具，Ubuntu 是基于 Debian 的，所以 Ubuntu 也可以使用，其他发行版没有该工具。它可以用来方便快捷地切换应用版本，不仅仅用来切换 Python，其他应用程序有多个版本的也可以使用该工具。\nupdate-alternatives本质也是建立软链接，只不过有了统一的管理，首先我们需要使用--install参数，添加一些候选项，也就是执行python这个命令时，它可以有哪些选择，在这里就是python3.7.3和python2.7.16两个选择。\n# --install \u0026lt;链接\u0026gt; \u0026lt;名称\u0026gt; \u0026lt;路径\u0026gt; \u0026lt;优先级\u0026gt; sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2 sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.7 1 注意，这里的/usr/bin/python链接文件，两个可选项必须是一样的，这样这个链接文件才可以选择两个不同的可选项去链接。\npython是在命令行执行的命令。/usr/bin/python2.7是执行python命令后调用具体哪个版本。最后的数字2是优先级，也就是python2.7比python3.7优先级高，如果不指定版本，那么默认就是使用python2。\n我们再查看一下版本信息，发现是python2.7.16。说明是默认版本。并且python已被链接到我们管理的软链接上。\n$ python -V Python 2.7.16 $ ll /usr/bin | grep \u0026#34;python\u0026#34; lrwxrwxrwx 1 root python -\u0026gt; /etc/alternatives/python 查看python的可选配置，可以看到有两个可选配置，默认是python2，第一列是序号，如果我们想切换到python3，对应的数字2即可。\nroot at RISCX in ~ $ update-alternatives --config python There are 2 choices for the alternative python (providing /usr/bin/python). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/bin/python2.7 2 auto mode 1 /usr/bin/python2.7 2 manual mode 2 /usr/bin/python3.7 1 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number:2 update-alternatives: using /usr/bin/python3.7 to provide /usr/bin/python (python) in manual mode 再次查看版本信息，发现已经切换成功。\n$ python -V Python 3.7.3 执行update-alternatives经常会导致我的终端回车失效，可以参考解决 Linux 终端回车键变成字符 M\n--remove，删除可选项：\nsudo update-alternatives --remove python /usr/bin/python2.7 ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3linux%E4%B8%8B%E5%88%87%E6%8D%A2python%E7%89%88%E6%9C%AC/","summary":"\u003ch2 id=\"需求背景\"\u003e需求背景\u003c/h2\u003e\n\u003cp\u003e用过 Python 的都知道，Python 是不向后兼容的，也就是 Python3.X 开发的程序，使用 Python2.X 环境就无法正常运行。因为很多语法都改变了。现在接触到的大部分 Python 程序都是 Python3.X 开发的，但是偶尔也会遇到使用 Python2.X 的时候。这就需要灵活切换版本。\u003c/p\u003e","title":"Linux 下切换 Python 版本"},{"content":"保留现场 ImportError: No module named \u0026#39;ConfigParser\u0026#39; Command \u0026#34;python setup.py egg_info\u0026#34; failed with error code 1 in 解决方法 在 Python 3.x 版本后，ConfigParser.py 已经更名为 configparser.py 所以出错！\n可以切换 Python2 执行。\n也可以尝试将文件重命名为ConfigParser.py。\n以下为参考，每个人安装路径可能不一样，可以全局搜索configparser.py。\ncp /usr/lib/python3.7/configparser.py /usr/lib/python3.7/ConfigParser.py ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3python-no-module-named-configparser/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eImportError: No module named \u003cspan class=\"s1\"\u003e\u0026#39;ConfigParser\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eCommand \u003cspan class=\"s2\"\u003e\u0026#34;python setup.py egg_info\u0026#34;\u003c/span\u003e failed with error code \u003cspan class=\"m\"\u003e1\u003c/span\u003e in\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e在 Python 3.x 版本后，\u003ccode\u003eConfigParser.py\u003c/code\u003e 已经更名为 \u003ccode\u003econfigparser.py\u003c/code\u003e 所以出错！\u003c/p\u003e\n\u003cp\u003e可以切换 Python2 执行。\u003c/p\u003e\n\u003cp\u003e也可以尝试将文件重命名为\u003ccode\u003eConfigParser.py\u003c/code\u003e。\u003c/p\u003e","title":"解决 Python No module named 'ConfigParser'"},{"content":"保留现场 在 LaTeX 编译中报错：Missing character: There is no (U+00A0) (U+00A0) in font JetBrains Mono。\n探究原因 如果要搞清楚具体原因，就得从字符与字符编码说起了。解决办法直接跳到下一节吧。\n字符，就是“a”，“A”，“你”等书写符号。\n字符集，通常就是某种语言字符集合，比如英语就是ASCII 字符集，中文有GBK 字符集等\n注意，不是每种语言只对应一种字符集（比如 GB2312，GBK，GB18030 都包含了常用汉字，后者是前者的超集），而且字符集也不是只对应一种语言，例如 Unicode 字符集就包含所有语言字符，字符集只是设计者为了给字符编码（Code Point/Numbering）设计编码时，为了收录到命名的字符集合，但是通常设计者都为字符集设计了对应的编码规范。\n字符编码,给字符集里的字符编号。\n编码页，在 unicode 发明之前，各个地区都用 2 字节编码自己的字符集，相同的编码对应不同的字符，为了本地化，Windows 发明了编码页，来对应不同的字符集。\n字符编码，对给定的字符编码编码成字节表示。\n早期，字符被编号后，存储时就按照编号的方式存储，没有 encoding 的过程，后来发明 Unicode 后，发现如果按照 Unicode 的编号直接存储的话，对于英文字符就有很大存储浪费，因为任意字符都需要 2 字节存储，后来人们发明 UTF-8 这种编码方式，这样 UTF-8 就可以一个字节表示英文字符，2 个以上字节表示汉字字符。\n字体，定义了字符的图形表示，现在的软件展示字符时用 Unicode 表示，字体是 Unicode 编码和字符图形的映射，而以往比如 WindowsCMD 控制台，没有对应 Unicode，则用编码页来区分，所以字体就是字符编码金和代码页到字符图形的映射。\n文本文件存储在磁盘上，都是一系列的字节流，如果不告诉文本编辑器该文件的编码方式，编辑器会尝试用默认的编码（依赖于操作系统设置）又或者自己探测（detect，比如文件开头有 FFEF 或者 EFFF 字节就表明 UTF-16 编码，有很多 10，110 开头的字节，很可能是 UTF-8 编码）并尝试解码，如果没有猜对，那就会显示乱码。\n回到出错的问题，提示我们在字体 JetBrains Mono中没有U+00A0，我们搜索一下就知道这是一个 Unicode 字符NO-BREAK SPACE。我们通过上面的了解也知道了，字体就是字符编码到字符图像的映射，但是一个字体尤其是一些有专门用途的字体（比如 JetBrains Mono 设计初衷是为软件工程显示代码用的），它不会映射所有的字符，JetBrains Mono 这个字体里就没有映射 U+00A0。这就导致在 LaTeX 编译时无法在字体中找到对应的字符图像显示。\n所有解决办法就是要不替换掉这个字符，要不换个字体。\n解决方法 VSCode 正则搜索\\U00A0即可搜索到相关字符，将其替换成空格。\n参考 字符，字符集，字符编码，编码页，字体 - 简书\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3latex%E7%BC%96%E8%AF%91missing-character-there-is-no-u-00a0-u-00a0-in-font/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e在 LaTeX 编译中报错：Missing character: There is no   (U+00A0) (U+00A0) in font JetBrains Mono。\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e如果要搞清楚具体原因，就得从字符与字符编码说起了。解决办法直接跳到下一节吧。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e字符\u003c/strong\u003e，就是“a”，“A”，“你”等书写符号。\u003c/p\u003e","title":"解决 LaTeX 编译 Missing character There is no (U+00A0) in font"},{"content":"使用 MobaXertm 连接服务器后，想要在运行一个下载任务，使用\u0026amp;挂在后台后，退出 MobaXterm，后台的任务也随之中断，于是搜到这个nohup命令，可以完成我的需求。\nnohup意思是 No Hang Up，不要挂起的意思，即使退出终端也不会中断任务。\n为了方便以后查阅，这里总结一下关于后台运行相关的命令。首先是最常用的\u0026amp;符号。\n\u0026amp; 后台运行 比如执行编译任务时通常会占用终端前台，这时候无法再执行其他命令，除非再开一个终端，对于有 GUI 界面时，再开一个终端很方便，但是如果是服务器就只能再想办法了。 \u0026amp;可以将命令执行过程放在后台运行，如：\n$ make \u0026gt; make.log 2\u0026gt;\u0026amp;1 \u0026amp; [1] 16586 2\u0026gt;\u0026amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了make.log文件，即将标准出错也输出到make.log文件中。最后一个\u0026amp;，是让该命令在后台执行。 试想2\u0026gt;1代表什么，2与\u0026gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2\u0026gt;\u0026amp;1，\u0026amp;与1结合就代表标准输出了，就变成错误重定向到标准输出。\n在后台运行make进行编译，并将输出结果（错误和正常输出）都保存到make.log文件中，提交任务成功后，会显示进程 ID，编译的进程 ID 为 16586。\n有了进程 ID 我们可以监控，也可以中断进程：\n# 查看进程状态 ps -ef | grep 16586 # 中断进程 kill -9 16586 但是使用 \u0026amp;时关闭终端后，进程也会随之关闭。如果想要在后台持续运行程序，就需要nohup命令。\nnohup 使用 $ nohup make \u0026gt; make.log 2\u0026gt;\u0026amp;1 \u0026amp; [1] 112233 命令功能同上，但是终端关闭，后台程序也会继续执行。\nNOTE：终端关闭，是指带 GUI 的界面里终端，如果使用 SSH 等登陆，比如使用 MobaXterm，一个 session 相当于一个登陆账户，如果异常退出了这个账户，那么后台执行的程序也会中断。如果需要继续执行，需要正常退出账户，执行exit命令。\n汇总 fg # 将后台中的命令调至前台继续运行 bg # 将一个在后台暂停的命令，变成继续执行 (在后台执行) jobs # 查看当前有多少在后台运行的命令 kill %num # 终止进程num \u0026amp; # 加在命令后可以将其置于后台运行 ctrl + z # 置于后台，并且暂停不可执行 ctrl + c # 终止前台进程 ctrl + \\ # 退出 ctrl + d # 结束当前输入(即用户不再给当前程序发出指令)，那么Linux通常将结束当前程序 ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-nohup%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/","summary":"\u003cp\u003e使用 MobaXertm 连接服务器后，想要在运行一个下载任务，使用\u003ccode\u003e\u0026amp;\u003c/code\u003e挂在后台后，退出 MobaXterm，后台的任务也随之中断，于是搜到这个\u003ccode\u003enohup\u003c/code\u003e命令，可以完成我的需求。\u003c/p\u003e","title":"每天学命令-nohup 后台运行"},{"content":"技术没学多少，教程下满了硬盘，一直想专门部署 NAS 来存文件，但是一来要花钱，二来搭建 NAS 没有经验怕部署不好，没有现在硬盘直连舒适，所以将就用吧。\n自从有天忘了忘了休眠电脑，一个自动备份任务开启，在 40 度的高温天，满速跑了一天，下班回来硬盘直接报废。这就加速我折腾部署 NAS 的进程。\n准备阶段 威联通的几款中意的 NAS 放购物车很久了，如果硬盘没有这么早坏掉，可能在双十一就买整机了，现在离双十一还早，硬件价格都不便宜，想来想去还是买二手硬件攒一台更划算。如果买整机，硬盘加 NAS 主机就得五千大洋，只是用来存文件，部署个 Jellyfin 看电影用，属实奢侈了。\n￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥\n买二手就得从零开始学。生命不休，折腾不止。经过一次完整的 NAS 攒机过程发现，其实 NAS 就是安装了专用系统的一台电脑而已。这个专用系统就是面向网络存储开发的，如群晖，威联通，开源的 OMV，FreeNAS 等等。\n既然是一台电脑，其实攒 NAS 就和攒电脑一样，选配好以下几大件即可。\nCPU 主板 散热器 机箱 内存 电源 机箱风扇 下面分别介绍在攒机过程中遇到的一些概念，参数到底是什么意思。\nCPU CPU 型号字母数字都是什么意思 \u003c!DOCTYPE html\u003e Responsive Image Intel 是英特尔的英文名称，也是目前热门的 CPU 品牌； “酷睿”代表英特尔品牌下面向普通消费者的一个 CPU 系列，一般划分为 Core（酷睿）、Pentium（奔腾）、Celeron（赛扬）、Xeon（至强）、Atom（凌动）等； i5 代表这款 CPU 定位中端，在其下面还有 i3，在其上面还有 i7 和 i9，同一代中，数字越大，性能越强；但是不同代 - 数之间，性能不能直接相比，比如 12 代的 i5 在理论性能上是强于 10 代 i7 的。 12 代表这款 CPU 的代数，说明其已经发展到第十二代了，数字越大越新； 600 这三位数字代表 Intel SKU 型号划分，一般来说 Core i7 有固定几个 SKU，比方说 700；Core i5 有 600/500/400；Core i3 有 300/100 等等，一般来说数字越大说明隶属的 Core 系列越高级，同级别下比较，数字越大频率越高，换句话说性能就越强，比方说 Core i5-8600 默认 3.1GHz，睿频 4.3GHz，比 Core i5-8500 默认 3.0GHz，睿频 4.1GHz 要强。 K 带 K 的表示不锁频，可以配合 Z 系列主板进行超频操作，适合会超频玩家使用，比方说 i7-12700K，i5-12600K 等 F 带 F 的表示不带集成显卡，你必须配合独立显卡使用； 当然，除了例子中的这种情况，我们还会遇到其它 CPU 型号的后缀：\nK：表示支持超频且内置核显的 CPU 型号，例如型号：i5-12600K、i7-12700K； F：表示无内置核显，例如型号：i5-12400F、i7-12700F； KF：表示支持超频且无内置核显的 CPU 型号，例如型号：i5-12600KF，i7-12700KF。 T：表示低功耗版，相同型号下功耗更低，性能也差一些，例如型号：i7-10700T； X/XE：表示至尊旗舰级，例如型号：i9-10980XE。 KS：可以理解为官方超频版，提升了主频的版本，例如 i9-9900K 和 i9-9900KS，i9-9900KS 出厂的主频要高于 K，例如型号：i9-9900KS。 U：低电压，性能弱些但功耗低，通常出现在轻薄本中，举例型号：i7 10510U； H：标压，性能强，通常出现在游戏本中，举例型号：i5-11300H Y：超低电压，性能很弱功耗非常低，通常出现在轻薄本中，举例型号：i3-10110Y； HK：一般使用在 Intel 高端发烧级 CPU 上，可超频，举例型号：i9-11980HK； G：G1、G4 以及 G7 等，G 后面的数字表示核显性能强弱，数字越大代表核显性能越强，通常数字小于 4 的是集成的普通超高清 (UHD) 核显，大于等于 4 的是集成的高性能锐炬 (Iris) 核显。Intel 移动版 CPU 后缀，举例型号：i5-1155G7、i3-1115G4、i3-1005G1； HQ：标准电压，Q 板载四核，早期的老后缀，举例型号：i7-7700HQ； MQ：标准电压，Q 插拔四核，早期的老后缀，举例型号：i7-4810MQ； M：早期后缀 M 就是移动端 CPU，只是为了与台式机区别开，举例型号：i7-2620M。 主板 ATX，Micro-ATX，Mini-ITX 区别 在了解买啥主板时，不免会看到各种 TX，比如我买的这块七彩虹 B460iTX 主板，简称就是七彩虹 B460i，还有不带最后字母i的。他们有啥区别呢？其实这就是表示了主板的尺寸。主板尺寸常见的有三种尺寸：\n标准-ATX：30.5 厘米 x 24.4 厘米\nMicro-ATX：24.4 cm x 24.4 cm\nMini-ITX：17 厘米 x 17 厘米\n\u003c!DOCTYPE html\u003e Responsive Image 一般攒机会用标准 ATX，或者 MATX 也很常用，而 ITX 就常被用来搭建低功耗的服务器，如我们要搭建的 NAS。因为它是 7*24 小时不间断工作的，功耗是需要多考虑的。\n散热器 风冷与水冷 \u003c!DOCTYPE html\u003e Responsive Image 风冷就是散热鳍片加风扇。散热鳍片会穿入铜管，铜管与下方底座相连，底座与 CPU 直接接触。CPU 热量铜管底座传导给铜管，铜管传导给散热鳍片，散热鳍片铜管风扇散热。\n\u003c!DOCTYPE html\u003e Responsive Image 水冷就是水冷头加风扇。简单理解就是风冷的铜管换成了液体。液体流动传导比铜管更快。\n\u003c!DOCTYPE html\u003e Responsive Image 各有优缺点，风冷更安全，比较简单，性能上限比较低，而水冷在外观、性能方面有很大的优势，缺点就是相对比较贵，还有漏液风险，不过现在的水冷漏液概率很小。细分的话风冷还有下压式，下压式比较适合 itx 小机箱，而塔式就适合普通机箱，水冷也分一体式水冷和分体式水冷，常见的都是一体式水冷。\n机箱 塔式，机架与刀片区别 塔式服务器外形和普通家用服务器相差不多，塔式主机在主板扩展上有优势，一般预留接口较多，方便扩展。适用于入门和工作站。\n机架服务器的外观安装工业标准统一设计，需要配合机柜统一使用，主要用于企业服务器密集部署。机架服务器因为需要密集紧凑，所以在设计时会非常紧凑，充分利用有限的空间。机架服务器宽度 19 英寸，高度以 U 为单位 (1U=1.75 英寸 =44.45 毫米）.\n刀片服务器的主体结构是主体机箱中可以有许多热拔插的主板，每一块主板都可以独立运行自己的系统，这些主板可以集合成一个服务器集群，在集群模式下可以连接起来提供更好的网络以及共享资源。\n全塔，中塔与小塔区别 形容的是机箱的大小。\n普通机箱，只能放 mATX 主板和一个标准电源，仅有 1-2 个光驱位；\n中塔机箱 AT，X 主板甚至是 EATX 主板和一个标准电源，拥有 3-4 个光驱位；\n全塔机箱，可以在主板上下的位置都安放一个电源，一共放两个电源拥有 4 个以上的光驱位。\n\u003c!DOCTYPE html\u003e Responsive Image 内存 电源 全模组，半模组与非模组区别 总结一句话就是能不能拔掉不需要的供电线，能拔多少。\n非模组 一个都不能拔，电源线直接从电源内部引出，输出线缆固定，无法进行扩展。\n\u003c!DOCTYPE html\u003e Responsive Image 半模组 \u003c!DOCTYPE html\u003e Responsive Image 能拔一部分，输出设计上既有非模组电源的直出线，又有全模组电源的扩展接口。\n全模组 能全拔，所有线缆都能按需插上。因为一般一块主板不会把所有电源线都用上，这样只需要插上自己需要的线缆即可，可以保证走线清楚，机箱清爽。\n\u003c!DOCTYPE html\u003e Responsive Image 金牌，银牌和铜牌啥区别 金牌，银牌，铜牌指的是电源的转换效率。有钛金、白金、金牌、银牌、铜牌、白牌等档次，档次越高，转换效率也越高，但成本也越高，功率越小，相对成本也越高。每个“牌”对应的攻略转换或者参数也是不同的。\n白牌：最低要求是 20-100% 负载下，转换效率必须达到 80%；\n铜牌：与上同条件大于等于 82%，85%@50% 负载；\n银牌：大于等于 85%，88%@50% 负载；\n金牌：大于等于 87%，90%@50% 负载；\n白金牌：90%@20% 负载、92%@50% 负载、89%@100% 负载。\n钛金牌：要求 10%、20%、50%、100% 负载下的效率分别为 90%、94%、96%、92%。\n举个例子： 500w 金牌和 500w 铜牌，都能带动 500w 功耗的电脑。金牌电源在 100% 负载时，转换率超过 87%，可以算一下，500/0.87=575w 耗电。 铜牌 100% 负载转换率超过 82% 500/0.82=610w耗电，简单说就是好电源省电。\n硬盘 固态硬盘 机械硬盘 垂直盘 PMR 与叠瓦盘 SMR 区别 作者：一起学点什么 链接：https://www.zhihu.com/question/369882964/answer/2227127605\n垂直磁记录（Perpendicular magnetic recording，PMR），也称为传统磁性记录 (conventional magnetic recording，CMR)，由于 SMR 其实也是垂直式磁记录的一种，只是相较于垂直磁记录方式磁盘优化了写入密度，因此为了避免被认为所有垂直磁记录的硬盘都是 SMR 硬盘，大家也习惯把非 SMR 的垂直机械盘称为 CMR。\n最开始由于硬盘容量提升的需求，磁性记录颗粒的尺寸需要不断下降，导致出现了电磁学上的超顺磁效应（超顺磁性：当某些具有磁性的颗粒小于某个尺寸时，外场产生的磁取向力太小而无法抵抗热扰动的干扰，而导致其磁化性质与顺磁体（通俗来说就是指材料对磁场响应很弱的磁）相似。），这就限制了硬盘容量提升的潜力。\n之前硬盘厂商使用纵向（平行，Longitudinal Magnetic Recording，LMR）读写技术，磁性记录颗粒的易磁化方向相对于碟片是平行的，颗粒沿着碟片圆周以端对端排列，所以便有机会出现 SS（南）和 NN（北）的互斥排列。当颗粒的尺寸不断下降而密度不断提升，在室温的情况下颗粒便会对随机的热运动异常敏感，失去稳定性，导致出现比特（0 和 1）翻转的现象，记录的数据因此被破坏。\n\u003c!DOCTYPE html\u003e Responsive Image 而为了解决以上问题，后来就开发出了垂直磁记录技术（Perpendicular Recording）的硬盘，这种硬盘中的磁性记录颗粒的易磁化方向相对于碟片是垂直的，允许使用单极磁头配合磁记录介质下的软磁层将信息写入磁记录介质中，这样采用具有相同饱和磁化强度的材料所制备的垂直写入磁头，能产生远多于传统写入磁头所能产生的磁场。更大的写入磁场允许我们使用具有更高磁各向异性的材料来制备磁记录介质，而磁各向异性越强，出现超顺磁性效应的临界体积就越小，因此，碟片中的存储密度可以在一定程度内得到进一步的提高。\n但是这样虽然提高了硬盘的存储密度，但是很快也就达到了瓶颈，工程师又开始想新的方法来提高硬盘的存储密度，这就诞生了大家都知道的 SMR 叠瓦盘。\n\u003c!DOCTYPE html\u003e Responsive Image 叠瓦式机械硬盘（Shingled magnetic recording，SMR，直译为分层磁记录）：也是一种用于硬盘驱动器的磁存储数据记录技术，可提高存储密度和每个驱动器的整体存储容量。常规的硬盘驱动器通过写入彼此平行而不重叠的磁道来记录数据，例如 PMR。而叠瓦磁记录技术的硬盘写入的新磁道则与先前写入的磁道部分重叠，从而使先前的磁道更窄，因此能拥有更高的磁道密度，进而提高磁盘容量。使用叠瓦磁技术的磁道相互重叠，与用作屋顶的瓦片堆叠方式类似。之所以能这样做是因为磁盘写入磁头由于物理上的原因比读取磁头宽上许多，因而由正常方式写入的磁道宽度远比读取磁头所需的磁道宽度来得宽，此外为了避免磁道间相互干扰，磁道和磁道之间其实还有一部分空隙，因此读取信息的磁道仅占所有磁道的很小一部分，很大的磁盘空间都被浪费了，只是因为技术原因我们不能将写入磁头制作的和读取磁头一样小。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 由于磁道存在重叠，叠瓦式磁盘的写入过程较为复杂。如果我们随机写入一个磁道，由于写入磁头的宽度比磁道宽，因此写入会影响到临近磁道，如果这个临近磁道有数据，这些数据就也需要依次重写以免数据被破坏，依此类推。因此，SMR 磁盘一般分成很多块只能追加数据（顺序写入）的区域（Zone），这和固态硬盘的闪存页管理类似。使用“设备管理”（device-managed）方式的 SMR 磁盘通过内部固件处理了 SMR 磁盘复杂的写入问题，从而对用户封装了 SMR 磁盘的复杂性，令用户可以像使用 PMR 硬盘一样随机写入 SMR 硬盘。其他 SMR 磁盘则使用“主机管理”（host-managed）方式，需要操作系统识别 SMR 磁盘并拥有能对 SMR 磁盘进行正确顺序写入的驱动程序才能被正常使用。\n叠瓦盘相较于垂直盘性能也有一定下降，因为传统的 CMR 硬盘磁道之间不会互相干扰，写入数据时可以任意进行写入，而叠瓦盘由于在一个磁道写入数据时不可避免会影响相邻的磁道，需要将下一磁道的数据先拿出（暂时放入硬盘 CMR 缓冲区）再进行写入，而恢复下一磁道的数据则又会对下下磁道的数据进行影响，则又需要先取出下下磁道的数据，因此完成传统垂直硬盘一次的写入操作，叠瓦式硬盘则需要多次的写入，同样的数据量需要更多的写入操作，也会增大损坏的概率。\n配件选购 配件 型号 价格 主板 七彩虹 B460-ITX 300^1^ CPU I3-10100 600^1^ 机箱 Invasion X5 330^1^ 电源 振华冰山金蝶 550W 300^1^ 硬盘 西数 HC550 1390 SSD xxxxx 旧电脑拆的 散热器 利民 AX120 RSE 74 内存条 酷兽 DDR4 16G 245 合计 3239 1.表示二手价格\n主板 刚入门其实最头疼的就是到底买什么型号，因为各个配件之间又有兼容问题，比如相中了一款 ITX 的机箱，但是主板却是 ATX 的，主板都放不进机箱里，这就很麻烦。所以我们首先要确定一个配件，其余配件都安装这个配件的规格去买，并且都要适配这个配件。那么这个配件最好的选择就是主板。\n我们先确定自己要买一个什么样的主板，让所有其他的配件都适配这个主板。选择主板的好处是，主板上各个接口就能体现出这台 NAS 的性能。不至于配件买的太离谱。\n机箱 微型机箱买 ITX 板，MINI 机箱买 M-ATX 板和 ITX 板，中塔机箱买 ATX 板。因为 NAS 是个服务器，可能会永远被放在墙角，所以颜值不重要，实用才是王道，买一个盘位多实用性强的就行。\n在前期准备时看到很多推荐迎广的机箱，本来决定要买它，但是了解到 NAS 的本质就是一台电脑主机时，意识到为何不买个电脑机箱？为何要选择成品的机箱？虽然成品的 NAS 机箱有硬盘位，可热插拔。但是我为啥要去插拔服务器上的硬盘？\n当我有这个意识后，我的选择一下子多了起来，我最终选了逛淘宝偶然看的 Invasion 机箱。十分简约的外形，甚至还有玻璃侧罩，四格金属硬盘架专为 NAS 打造。只要不到三百块。于是立马转头打开小黄鱼，一搜还真有转卖的，升级版的 8 格硬盘架只要 330。收到货后也很满意，几乎是全新的，玻璃膜都没有撕，还送了俩风扇。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image CPU 选择 CPU 对于小白来说最重要的就是要选择带核显的 CPU，因为 NAS 上显卡其实没必要，CPU 的核显就绰绰有余了，如果既没有显卡也没有核显就会无法亮机。所以选择 CPU 时要选择带核显的，也就是 Intel 的 CPU 型号不带F的，比如我最终选择的 I3-10100。AMD 的 CPU 型号标识我也没弄清楚，可以自己搜索一下自己想要的 CPU 是否有核显。\n其次就是功耗，因为 NAS 要 7*24 小时运行，所以选择性能低一点的 CPU 就好了，另外就是需要关注 CPU 是否有音视频解码的能力。因为平时爱折腾，想着以后指不定在 NAS 上折腾些啥，所以选择了性能不算低的 I3-10100。两个月体验下来，性能还是过剩了，日常基本上都处于待机状态，只有周末看电影会用一下，CPU 利用率很低，好在日常功耗只有 30W。-\n\u003c!DOCTYPE html\u003e Responsive Image 安装 OVM (OpenMediaVaultt) 参考视频：蜗牛星际安装开源 NAS 系统 Openmediavault 及初始化配置（司波图）——OMV 系列教程 01\n为什么选择它 OpenMediaVault（以下均简称 OMV）是除 FreeNAS 外目前使用最广泛的开源 NAS 系统。\n预备软件下载 下载 OpenMediaVaultt 系统，我选择的是 ISO 格式 Old Stable 版本，虽然想用最新的版本，但是第一次安装没有成功，选择了旧版本安装成功了。\n下载 微 PE 工具箱，用来格式化系统盘，如果是新买的系统盘就不需要下载。\n下载 Rufus 轻松创建 USB 启动盘，这个必须要用的。\n制作启动盘 需要一个容量大于 4G 的 U 盘，用 Rufus 将 OMV 写入 U 盘即可。安装时会从 U 盘启动，然后将系统安装到插在主板上的系统盘内。\n启动盘制作就不详细说了，都是一键式操作。\n\u003c!DOCTYPE html\u003e Responsive Image 制作完后进入 U 盘内查看是否写入成功，U 盘内是否有文件，或者查看一下 U 盘使用大小，如果比系统 ISO 大小还小，那肯定没有写成功。我就制作了三遍才发现没有写成功，虽然能看到启动选项，但是进入安装就黑屏，因为根本没有可以安装的文件。\n如果没有制作成功，尝试格式化U 盘后重新制作。\n安装过程 参考视频即可，很详细。\n踩坑记录 # git sudo apt install git # python sudo apt install python # vim sudo apt install vim Docker 配置 安装 Portainer 管理容器 更换国内镜像源 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 网易 http://hub-mirror.c.163.com ustc http://docker.mirrors.ustc.edu.cn 阿里云 http://\u0026lt;你的 ID\u0026gt;.mirror.aliyuncs.com 或者使用一位网友提供的 http://1nj0zren.mirror.aliyuncs.com 因为可能有朋友看了比较老的教程（比如我，:( ），可能会用到一些停止服务的进行，如：\nhttps://dockerhub.azk8s.cn https://reg-mirror.qiniu.com https://registry.docker-cn.com 如果无法拉取镜像，检查是否用了这几个，如果用了请换镜像源。\n安装 Jellyfin 部署影音服务器 安装 Transmission 下载 安装 qBittorrent 下载 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 添加 tracker list ngosang/trackerslist: Updated list of public BitTorrent trackers\n\u003c!DOCTYPE html\u003e Responsive Image 安装 Jackett 搜索种子 Docker 中安装，选择网易的镜像，阿里的镜像太旧了。\n配置端口号9117，映射两个路径即可。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 安装过程参考How to configure Jackett plugin。\n点击这里下载源码，复制全文并保存为jackett.py文件。\n如果按照以上安装 qBittorrent 那么保存路径为共享文件夹下appdata/qBittorrent/nova3/engines/。\n如果没找到，找找是否有以下路径。\n~/.local/share/data/qBittorrent/nova3/engines/ # 或者 ~/.local/share/qBittorrent/nova3/engines/ 再在相同路径下，新建一个配置文件jackett.json，写入以下配置：\n{ \u0026#34;api_key\u0026#34;: \u0026#34;YOUR_API_KEY_HERE\u0026#34;, \u0026#34;tracker_first\u0026#34;: false, // 如果你登录 OMV 的地址是 192.168.0.1 \u0026#34;url\u0026#34;: \u0026#34;http://192.168.0.1:9117\u0026#34; } 安装 Hlink 硬链接持续做种 下载的文件名太过杂乱，可以用 TMM 等刮削工具刮削，重命名，建立影音库。但是重命名后就无法做种。想起了 Linux 有硬链接功能，在每天学命令-ln 软硬链接这篇文章中有详细说明。简言之就是创建的硬链接可以任意修改文件名，看上去是一份拷贝，但是实际不占用硬盘空间。\n下载的文件太多，又是文件夹嵌套，手动创建比较麻烦，有人专门为这个需求开源了一个项目hlink，可以批量创建硬链接。这里还是以使用 Docker 为例。\n配置 Docker 镜像名：likun7981/hlink 端口号：9090 目录映射：/media : /root/sharedfolder 环境变量：HLINK_HOME：/root/sharedfolder/appdata/hlink 选择自己放配置文件的目录即可\n/root/sharedfolder 是我挂载的硬盘的根目录，建议映射根目录，不要创建多个目录，比如映射/root/sharedfolder/movie 和/root/sharedfolder/music。因为硬链接不支持跨盘符创建，虽然我们本地 music 和 movie 是在一个盘符，但是这样映射在容器中就是两个盘，就会无法创建硬链接，所以只映射一个根目录。 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 配置 Hlink 浏览器输入 IP:9090，打开配置界面。\n添加一个新配置，注释十分详细，就不赘述了，但是路径一定要写对，可以新建两个测试目录，测试一下是否能够创建成功。\n\u003c!DOCTYPE html\u003e Responsive Image 两个重要配置解释：\n/** * /media 是容器里的目录，因为我只映射了一个目录，所以这就是容器的根目录 * 对应到我主机，就是/root/sharedfolder 这个目录 * 所以/media/downloads/qbittorrent/qbcomplete/movie * 就是/root/sharedfolder/downloads/qbittorrent/qbcomplete/movie * 后一个路径/media/media/movie 同理 * 等价于/root/sharedfolder/media/movie */ /** * 前一个路径是下载的路径，这里的文件都是不能重命名整理的 * 后一个路径是影音库的路径，hlink 执行完会在这里创建相同的文件链接 * 这个链接可以任意修改，移动，删除 */ pathsMapping: { \u0026#39;/media/downloads/qbittorrent/qbcomplete/movie\u0026#39;: \u0026#39;/media/media/movie\u0026#39;, }, /** * 设置 true 打开缓存，这样即使影音库里的文件被删除，移动 * 也不会创建新的硬链接 */ openCache: true, 缓存的文件信息在右上角编辑缓存可以查看，如果已经执行过创建硬链接但是没有显示，Shfit+F5刷新界面重试。\n踩坑记录 主板无法识别固态硬盘 因为想利用上三年前从笔记本上拆下来的固态，但没注意接口的协议。主板现在大多默认支持 NEVe 协议，但是我的硬盘是很久之前的 SATA 协议。这块 B460i 主板默认支持 NVMe 协议的，但是也支持 SATA 协议，需要更改跳帽。\n找了半天图片没有找到一样的，官网的图片是和说明书上的一样是拨动开关形式的，但是我买的二手的是跳帽（哭），不会是买到假的了吧。开关全部拨到左边才支持 SATA 协议。用跳帽也是一样，必须都连接的是左边两个引脚。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 无法识别 U 盘启动盘 引导模式有两种 UEFI 和 Legacy，这个在做启动盘时就确定了。如果主板使用的 UEFI 模式，而启动盘制作的是 Legacy 模式，就无法识别，需要在 Bios 里找到启动模式选择的相关选项，配置可以使用 Legacy 模式或者 UEFI。（记录这些时已经不想再进 Bios 了所以也没有图片，总之要配置引导方式，避免过滤了一些引导方式导致 U 盘无法识别）\n不同网段设备无法互通 OVM 无法挂载移动硬盘 报错：The filesystem label contains blanks. Please remove them by renaming the filesystem to be able to mount it.\n移动硬盘名里有空格，插到 Windows 上重命名一下即可。\nifconfig not found # ifconfig sudo apt install net-tools ll not found vim ~/.bashrc # 找到 #alias ll=’ls -l’，去掉前面的#就可以了。 source ~/.bashrc 参考 CPU 型号解读：教你 CPU 型号后缀怎么看？CPU 型号后面的字母和数字区别是什么？ - 知乎 从零开始搭建 NAS: 硬件篇 | Verne in GitHub 从零搭建一台 NAS：软件篇 | Verne in GitHub Intel CPU 型号解读以及如何粗略判断 Intel CPU 的性能 (i3、i5、i7 以及 CPU 的代数)_吮指原味张的博客-CSDN 博客_cpu 代数 NAS | 群晖安装 qBittorrent 套件并优化设置、替换 UI（非 docker 安装） | 醉渔小站 Docker 中国源 - 简书 金牌 铜牌 什么区别呀？ - 电源 - Antec 网站 机·科普贴：电脑电源金、银、铜牌到底是什么意思？_铜牌电源和金牌电源的区别 - 调色盘网络 【非模组电源，半模组电源，全模组电源有什么区别？】 - 知乎 电源全模组和非模组究竟有什么区别？_电脑电源_什么值得买 浅谈组装机机箱的选择（篇一：大小） - 知乎 哪種 PC 機箱尺寸最適合您的下一個版本？ - HowThere 199 元风冷/水冷散热器简单对比：谁才是你的爱 - 超能网 【教程】蜗牛星际安装开源 NAS 系统 Openmediavault 及初始化配置（司波图）——OMV 系列教程 01_哔哩哔哩_bilibili How to configure Jackett plugin · qbittorrent/search-plugins Wiki 安装 NAS Tools，打造自动化观影、追剧系统，NAS 媒体库整理工具，威联通 Docker 版 NAS Tools 安装教程~feat.威联通 HS 264_哔哩哔哩_bilibili Home | hlink ","permalink":"https://lifeislife.cn/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E5%8F%B0nas%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/","summary":"\u003cp\u003e技术没学多少，教程下满了硬盘，一直想专门部署 NAS 来存文件，但是一来要花钱，二来搭建 NAS 没有经验怕部署不好，没有现在硬盘直连舒适，所以将就用吧。\u003c/p\u003e\n\u003cp\u003e自从有天忘了忘了休眠电脑，一个自动备份任务开启，在 40 度的高温天，满速跑了一天，下班回来硬盘直接报废。这就加速我折腾部署 NAS 的进程。\u003c/p\u003e","title":"从零开始搭建一台 NAS 存储服务器"},{"content":"下载安装 点击下载 Linux 版本的 Clash，下载完成后解压缩。\nunzip clash-linux.zip sudo mv clash-linux /usr/local/bin/clash sudo chmod +x /usr/local/bin/clash 初步使用 下载配置文件，配置文件一般由订阅商（机场）提供，是一个 yaml 文件，编写了代理服务器的信息，以及访问规则等。这是最关键的一步。\nclash-linux-amd64-v1.10.0 -f 从订阅商那获取的配置文件.ymal -d . 可以尝试在 Git clone 时使用代理，如果可以正常下载，说明代理配置成功。\ngit clone https://github.com/twbs/bootstrap.git --config \u0026#34;http.proxy=127.0.0.1:7890\u0026#34; # 即可正常下载 开机启动 cd ~ sudo cp /usr/local/bin/clash /etc/ sudo vim /etc/systemd/system/clash.service 添加如下内容，并保存：\n[Unit] Description=Clash Daemon [Service] ExecStart=/usr/local/bin/clash -f /etc/clash/订阅的配置文件.yaml -d /etc/clash/ Restart=on-failure [Install] WantedBy=multi-user.target 启用 clash 服务\nsudo systemctl enable clash.service 启动 clash 服务\nsudo systemctl start clash.service 此外也可以停止或者禁用 clash 服务\nsudo systemctl stop clash.service sudo systemctl disable clash.service 查看运行状态：\nsudo systemctl status clash 查看 clash 服务日志\njournalctl -e -u clash.service 配置定期更新 crontab -e 添加如下内容：\n29 6 * * * root pgrep clash | xargs kill -s 9 30 6 * * * root cp /etc/clash/订阅的配置文件.yaml /etc/clash/backup.yaml 31 6 * * * root curl https://订阅链接.yaml \u0026gt; /etc/clash/订阅的配置文件.yaml 32 6 * * * root sudo systemctl start clash.service 重启 cron 服务\nsudo systemctl restart cron.service 使用 Dashboard 编辑/etc/clash/glados.yaml，修改以下配置，默认配置为127.0.0.1:9090。如果你的9090端口没有被占用，将其修改为0.0.0.0:9090即可，因为我的 NAS9090端口被占用，所以修改成了0.0.0.0:19090。\nexternal-controller: 0.0.0.0:19090 这样就可以在浏览器通过Nas IP:19090/ui访问 Dashboard，比如192.168.1.9:19090/ui。\n\u003c!DOCTYPE html\u003e Responsive Image 更方便的方式：使用 Docker 部署 version: \u0026#34;3.7\u0026#34; services: clash: image: dreamacro/clash-premium container_name: clash hostname: clash restart: unless-stopped ports: - 7890:7890 - 7891:7891 - 9090:9090 volumes: - /root/sharefolder/appdata/clash:/root/.config/clash # 修改为你的配置文件目录 environment: - TZ=Asia/Shanghai clash-dashboard: image: haishanh/yacd:master container_name: clash-dashboard ports: - \u0026#34;7880:80\u0026#34; restart: always environment: - TZ=Asia/Shanghai depends_on: - clash 这样就可以在浏览器通过Nas IP:7880访问 clash-dashboard，比如192.168.1.9:7880。点击配置，大概率显示无法连接到后端。修改后端地址位http://192.168.1.9:9090。\n\u003c!DOCTYPE html\u003e Responsive Image 定时更新：\ncrontab -e # 添加以下的内容 # 每隔 8 小时备份配置文件 0 */8 * * * cp /root/sharefolder/appdata/clash/config.yaml /root/sharedfolder/appdata/clash/config.yaml.bak # 每隔 8 小时延迟 5 分钟支更新配置文件 5 */8 * * * curl https://xxxxxxx \u0026gt; /root/sharedfolder/appdata/clash/config.yaml # 每隔 8 小时延迟 6 分钟修改配置文件 allow-lan: false 修改为true 6 */8 * * * sed -i \u0026#39;s/allow-lan: false/allow-lan: true/\u0026#39; /root/sharedfolder/appdata/clash/config.yaml # 每隔 8 小时延迟 7 分钟修改配置文件 external-controller: 7 */8 * * * sed -i \u0026#39;s/external-controller: 127.0.0.1:9090/external-controller: 0.0.0.0:9090/\u0026#39; /root/sharedfolder/appdata/clash/config.yaml # 每隔 8 小时延迟 8 分钟修改配置文件 external-ui: dashboard 注释掉，即不使用内置的dashboard，有的机场提供的配置文件没有这个配置，就不需要添加这行 8 */8 * * * sed -i \u0026#39;s/external-ui: dashboard/#external-ui: dashboard/\u0026#39; /root/sharefolder/appdata/clash/config.yaml # 每隔 8 小时延迟 9 分钟重启 clash 9 */8 * * * docker restart clash 10 */8 * * * docker restart clash-dashboard 参考 ghostxu97/clash-for-linux: Linux 环境安装配置 Clash 工具，以实现代理上网效果。包含下载、安装、配置、运行、测试以及开机自启动、定期自动更新订阅功能的操作文档，希望对你有所帮助\n","permalink":"https://lifeislife.cn/posts/linux%E4%B8%8B%E4%BD%BF%E7%94%A8clash%E4%BD%9C%E4%BB%A3%E7%90%86%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/","summary":"\u003ch2 id=\"下载安装\"\u003e下载安装\u003c/h2\u003e\n\u003cp\u003e点击下载 \u003ca href=\"https://glados.rocks/tools/clash-linux.zip\"\u003eLinux 版本的 Clash\u003c/a\u003e，下载完成后解压缩。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eunzip clash-linux.zip\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo mv clash-linux /usr/local/bin/clash\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo chmod +x /usr/local/bin/clash\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"初步使用\"\u003e初步使用\u003c/h2\u003e\n\u003cp\u003e下载配置文件，配置文件一般由订阅商（机场）提供，是一个 yaml 文件，编写了代理服务器的信息，以及访问规则等。这是最关键的一步。\u003c/p\u003e","title":"Linux 下使用 Clash 作代理并配置开机启动"},{"content":"","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3no-module-named-configparser/","summary":"","title":"解决 No module named 'ConfigParser'"},{"content":"解决方法 终端执行：\nstty sane 参考 command line - Pressing enter produces ^M instead of a newline - Ask Ubuntu\n","permalink":"https://lifeislife.cn/posts/linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E5%8F%98%E6%88%90-m/","summary":"\u003ch1 id=\"解决方法\"\u003e解决方法\u003c/h1\u003e\n\u003cp\u003e终端执行：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003estty sane\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"参考\"\u003e参考\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://askubuntu.com/questions/441744/pressing-enter-produces-m-instead-of-a-newline#comment578102_441744\"\u003ecommand line - Pressing enter produces ^M instead of a newline - Ask Ubuntu\u003c/a\u003e\u003c/p\u003e","title":"Linux 终端回车变成^M"},{"content":"","permalink":"https://lifeislife.cn/posts/linux%E5%88%87%E6%8D%A2%E4%B8%8D%E5%90%8Cpython%E7%89%88%E6%9C%AC/","summary":"","title":"Linux 切换不同 Python 版本"},{"content":"效果 下载 pdf.js 前往官网下载pdf.js。\n为了保证兼容性，建议下载旧版：\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 添加 pdfjs 到主题中 将下载文件夹命名为 pdfjs，拷贝到 themes/fluid/source/myjs 中。myjs目录为自己新建目录。并将该目录skip_render。\n打开 HEXO 的配置文件（不是主题的配置文件）_config.yml，搜索skip_render，配置如下：\nskip_render: [myjs/**] 如果不配置该选项，嵌入的 PDF 将会带有博客主题边框。如图：\n\u003c!DOCTYPE html\u003e Responsive Image 修改 viewer.js 直接使用下载的文件会报错：\nError: file origin does not match viewer\u0026#39;s 注释web/viewer.js文件中的相应内容：\n\u003c!DOCTYPE html\u003e Responsive Image 使用方法 在 Markdown 文档中使用 \u0026lt;iframe\u0026gt; 控件配合pdf.js 库完成 pdf 显示\n\u0026lt;iframe src=\u0026#39;/myjs/pdfjs/web/viewer.html?file=\u0026lt;src-to-pdf\u0026gt;\u0026#39; style=\u0026#39;width:100%;height:100%\u0026#39;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;src-to-pdf\u0026gt;：需要显示的 pdf 文件的链接 /myjs/pdfjs/web/viewer.html：改为自己的 pdfjs 目录 参考 Fluid -3- pdf.js PC，移动端查看 PDF - 又见苍岚 ","permalink":"https://lifeislife.cn/posts/hexo%E5%8D%9A%E5%AE%A2%E5%B5%8C%E5%85%A5pdf/","summary":"\u003ch1 id=\"效果\"\u003e效果\u003c/h1\u003e\n\u003ciframe src=\"/myjs/pdfjs/web/viewer.html?file=/misc/Markdown书写PDF输出优雅的解决方案.pdf\" style=\"width:100%;height:600px\"\u003e\u003c/iframe\u003e\n\u003ch1 id=\"下载-pdfjs\"\u003e下载 pdf.js\u003c/h1\u003e\n\u003cp\u003e前往\u003ca href=\"https://mozilla.github.io/pdf.js\"\u003e官网\u003c/a\u003e下载\u003ccode\u003epdf.js\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e为了保证兼容性，建议下载旧版：\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/03/18-02-32-6b30daefccbd074fc4a35844850845ea-20220903180230-1223af.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/03/18-02-32-6b30daefccbd074fc4a35844850845ea-20220903180230-1223af.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/03/18-02-57-878391ebdd45d2771db4af95418070bf-20220903180256-c4617f.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/03/18-02-57-878391ebdd45d2771db4af95418070bf-20220903180256-c4617f.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"HEXO 博客嵌入 PDF"},{"content":"用户态与内核态 目前为止的学习过程中，所有的程序都是运行在 Machine 模式下，但是在哪决定程序运行在什么模式下的呢？\n在学习抢占式多任务时，我们有了创建任务的概念，在汇编代码中有这么一段，使用到了mstatus寄存器：\n# Notice: default mstatus is 0 # Set mstatus.MPP to 3, so we still run in Machine mode after MRET. # Set mstatus.MPIE to 1, so MRET will enable the interrupt. li t0, 3 \u0026lt;\u0026lt; 11 | 1 \u0026lt;\u0026lt; 7 csrr a1, mstatus # a1 = mstatus or t0, t0, a1 # t0 = t0 | a1 csrw mstatus, t0 # mstatus = t0 j start_kernel # hart 0 jump to c mret返回后，是根据寄存器mstatus的MPP来决定接来来是处于什么模式，我们在上面将MPP配置为3， MPP的功能是 记录 Machine 模式下，前一个，特权级。这里解实现了在mret之后将模式设置为 Machine 模式（3）。\n\u003c!DOCTYPE html\u003e Responsive Image 因为mstatus上电后默认为全 0，所以如果不对其设置，那么在mret之后，就是运行在用户态（0）。\n如果想让程序跑在用户态，只要不对齐设置，保持默认即可：\n# Notice: default mstatus is 0 # Set mstatus.MPP to 3, so we still run in Machine mode after MRET. # Set mstatus.MPIE to 1, so MRET will enable the interrupt. li t0, 1 \u0026lt;\u0026lt; 7 csrr a1, mstatus # a1 = mstatus or t0, t0, a1 # t0 = t0 | a1 csrw mstatus, t0 # mstatus = t0 j start_kernel # hart 0 jump to c 为什么需要系统调用？因为在用户态一些资源（寄存器）的访问是受限的，所以需要封装一些函数，这些函数里会进行模式切换，然后访问需要的资源。\n那么如何进行模式的切换呢？这就需要ecall指令。它本质上是触发了异常，就会进入到 Machine 模式处理异常，在 Machine 模式下就相当于在内核态了，就没有访问资源的限制了。\n系统模式的切换 \u003c!DOCTYPE html\u003e Responsive Image ECALL指令实际就是主动触发异常，根据ECALL的权限级别产生不同的异常码，如下图：\n\u003c!DOCTYPE html\u003e Responsive Image 从 User 模式调用ECALL异常码等于 8，从 Supervisor 模式调用异常码等于 9，从 Machine 模式调用异常码等于 11。\n异常产生时epc寄存器的值存放的是ECALL指令本身的地址。\n如果想触发完异常接着往下执行，需要在异常处理逻辑里把 epc 寄存器值改为下一条指令地址，否则会进入死循环。\n系统调用的执行流程 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 系统调用的传参 系统调用作为操作系统的对外接口，由操作系统的实现负责定义。参考 Linux 的系统调用，RVOS 定义系统调用的传参规则如下：\n系统调用号放在a7中 系统调用参数使用a0-a5 返回值使用a0 \u003c!DOCTYPE html\u003e Responsive Image 系统调用的封装 \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","summary":"\u003ch2 id=\"用户态与内核态\"\u003e用户态与内核态\u003c/h2\u003e\n\u003cp\u003e目前为止的学习过程中，所有的程序都是运行在 Machine 模式下，但是在哪决定程序运行在什么模式下的呢？\u003c/p\u003e\n\u003cp\u003e在学习抢占式多任务时，我们有了创建任务的概念，在汇编代码中有这么一段，使用到了\u003ccode\u003emstatus\u003c/code\u003e寄存器：\u003c/p\u003e","title":"RISC-V 入门 - 系统调用"},{"content":"需求 工作时需要开启多个标签页，在同一个窗口里打开又查找不变，于是分为多个窗口，每个窗口里的标签页工作内容一致。如所有文档放在一个窗口，需要百度，Google 搜索时用单独的一个问题搜索窗口。这样就避免每次打开窗口都要挨个点一遍。\nEdge 设置 打开设置-更多工具 - 为窗口命名。即可重命名窗口\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image Chrome 设置 同上，路径基本一致都是在设置-更多工具中。\n升级 \u003c!DOCTYPE html\u003e Responsive Image 在使用过程中发现窗口太多任务栏太挤了，Chrome 自身有标签分组的功能，其实完全可以替代窗口。也可以满足我的需求。少数派有介绍，就不造轮子了。体验一段时间确实很好用。\n","permalink":"https://lifeislife.cn/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%91%BD%E5%90%8D/","summary":"\u003ch2 id=\"需求\"\u003e需求\u003c/h2\u003e\n\u003cp\u003e工作时需要开启多个标签页，在同一个窗口里打开又查找不变，于是分为多个窗口，每个窗口里的标签页工作内容一致。如所有文档放在一个窗口，需要百度，Google 搜索时用单独的一个问题搜索窗口。这样就避免每次打开窗口都要挨个点一遍。\u003c/p\u003e","title":"浏览器任务栏多窗口命名"},{"content":"调教背景 当有多个项目同时打开时，VSCode 窗口开得太多就找不到自己想要打开的窗口，因为窗口命名默认按照当前打开的文件命名的，不是很清楚。就需要挨个打开才能确定自己想要打开的窗口。\n如果能按照项目名命名窗口就会便捷许多，好在 VSCode 提供重命名的方式。同样的需求可能在浏览器中也会遇到，可以参考浏览器任务栏多窗口命名 - 如云泊。\n修改方式 File -\u0026gt; Preferences -\u0026gt; Setting 搜索 Window: Title 改成：\n${dirty}${rootName}${separator}${activeEditorMedium}${separator}${appName} 其他可用配置说明：\n\u0026#34;${activeEditorShort}\u0026#34;: 文件名 (例如 myFile.txt)。 \u0026#34;${activeEditorMedium}\u0026#34;: 相对于工作区文件夹的文件路径 (例如, myFolder/myFileFolder/myFile.txt)。 \u0026#34;${activeEditorLong}\u0026#34;: 文件的完整路径 (例如 /Users/Development/myFolder/myFileFolder/myFile.txt)。 \u0026#34;${activeFolderShort}\u0026#34;: 文件所在的文件夹名称 (例如, myFileFolder)。 \u0026#34;${activeFolderMedium}\u0026#34;: 相对于工作区文件夹的、包含文件的文件夹的路径, (例如 myFolder/myFileFolder)。 \u0026#34;${activeFolderLong}\u0026#34;: 文件所在文件夹的完整路径 (例如 /Users/Development/myFolder/myFileFolder)。 \u0026#34;${folderName}\u0026#34;: 文件所在工作区文件夹的名称 (例如 myFolder)。 \u0026#34;${folderpath}\u0026#34;: 文件所在工作区文件夹的路径 (例如 /Users/Development/myFolder)。 \u0026#34;${rootName}\u0026#34;: 打开的工作区或文件夹的名称 (例如 myFolder 或 myWorkspace)。 \u0026#34;${rootPath}\u0026#34;: 打开的工作区或文件夹的文件路径 (例如 /Users/Development/myWorkspace)。 \u0026#34;${appName}\u0026#34;: 例如 VS Code。 “${remoteName}”: 例如 SSH ${dirty}: 表明活动编辑器具有未保存更改的时间的指示器。 \u0026#34;${separator}\u0026#34;: 一种条件分隔符 (\u0026#34;-\u0026#34;), 仅在被包含值或静态文本的变量包围时显示 ","permalink":"https://lifeislife.cn/posts/vscode%E4%BB%BB%E5%8A%A1%E6%A0%8F%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%91%BD%E5%90%8D/","summary":"\u003ch2 id=\"调教背景\"\u003e调教背景\u003c/h2\u003e\n\u003cp\u003e当有多个项目同时打开时，VSCode 窗口开得太多就找不到自己想要打开的窗口，因为窗口命名默认按照当前打开的文件命名的，不是很清楚。就需要挨个打开才能确定自己想要打开的窗口。\u003c/p\u003e","title":"VSCode 任务栏多窗口命名"},{"content":"保留现场 升级pip时出现报错：\n\u003c!DOCTYPE html\u003e Responsive Image 解决方法 加上--user\npython -m pip install --upgrade pip --user ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3error-could-not-install-packages-due-to-an-environmenterror-%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e升级\u003ccode\u003epip\u003c/code\u003e时出现报错：\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/21-59-14-303384c2d30eca141422d200bd35470c-20220827215913-0ec1da.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/21-59-14-303384c2d30eca141422d200bd35470c-20220827215913-0ec1da.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e加上\u003ccode\u003e--user\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epython -m pip install --upgrade pip  --user\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"解决 ERROR Could not install packages due to an EnvironmentError 拒绝访问"},{"content":"编码字体 编码字体首要原则：等宽，等宽，还是 TMD 等宽！\nJetBrains Mono \u003c!DOCTYPE html\u003e Responsive Image Hack \u003c!DOCTYPE html\u003e Responsive Image Source Code Pro \u003c!DOCTYPE html\u003e Responsive Image Fira Mono \u003c!DOCTYPE html\u003e Responsive Image Consolas 保底字体，基本上 Windows 电脑都有预装。\n阅读字体 看多了黑体，其实有衬线的宋体才能体现中文文字之美。\n思源宋体 \u003c!DOCTYPE html\u003e Responsive Image 华文中宋 \u003c!DOCTYPE html\u003e Responsive Image 中文等宽字体 对于既想要满足编程字体又想要中文书写的，有几款等宽中文字体也不错。\nSarasa Gothic / 更纱黑体 \u003c!DOCTYPE html\u003e Responsive Image 思源黑体/Source Han Sans \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E7%BC%96%E7%A0%81%E5%AD%97%E4%BD%93%E4%B8%8E%E9%98%85%E8%AF%BB%E5%AD%97%E4%BD%93%E6%8E%A8%E8%8D%90/","summary":"\u003ch1 id=\"编码字体\"\u003e编码字体\u003c/h1\u003e\n\u003cp\u003e编码字体首要原则：等宽，等宽，还是 TMD 等宽！\u003c/p\u003e\n\u003ch2 id=\"jetbrains-mono\"\u003e\u003ca href=\"https://www.jetbrains.com/lp/mono/\"\u003eJetBrains Mono\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/20-50-54-1fe539cd3cb0a6bc28936cb76fd28644-20220827205054-dccd39.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/20-50-54-1fe539cd3cb0a6bc28936cb76fd28644-20220827205054-dccd39.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003ch2 id=\"hack\"\u003e\u003ca href=\"https://github.com/source-foundry/Hack\"\u003eHack\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/20-53-57-e5174c7461a1d5b578a44d71f4a201c9-20220827205356-b71842.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/20-53-57-e5174c7461a1d5b578a44d71f4a201c9-20220827205356-b71842.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"编码字体与阅读字体推荐"},{"content":"最简单的方式 使用参数指定安装路径：\npip install -t D:\\python3.5(32bit)\\Lib\\site-packages numpy 叨叨叨 如果电脑上安装了多个版本的Python的话，在需要使用pip安装新package时，就会遇到这个问题：我把package安装到哪了？\n因为每个版本的 Python 是有自己独立的pip，也有独立的lib目录的，管理的包也各不同。一般来说，使用默认的pip命令安装的位置，就是默认的python位置。\n比如我在终端敲下python，使用的是python3.6那么安装的package就会在C:\\Python36\\Lib\\site-packages（根据自己安装 Python 的路径稍有区别）。\n情景一：安装的都是 Python3.x 版本 有时候会遇到这样的需求，我准备跑的项目只能用python3.8，我得把package安装到python38里，怎么办？\n方法 1 把其中一个python环境变量删掉，留下（如果没有需要添加）python38的路径和script添加到环境变量。\n\u003c!DOCTYPE html\u003e Responsive Image 使用以下命令安装：\npython -m pip install xxxxx 因为默认Python已经被修改为python38。\n方法 2 使用文章开头的方式，最方便，直接指定 python 全局路径\npip install -t D:\\python3.5(32bit)\\Lib\\site-packages numpy 情景二：安装 Python2.x 与 Python3.x Python3.x 使用：\npy -3 -m pip install numpy Python2.x 使用：\npy -2 -m pip install numpy ","permalink":"https://lifeislife.cn/posts/%E5%A4%9A%E7%89%88%E6%9C%ACpython%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85package%E9%97%AE%E9%A2%98/","summary":"\u003ch2 id=\"最简单的方式\"\u003e最简单的方式\u003c/h2\u003e\n\u003cp\u003e使用参数指定安装路径：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epip install -t D:\u003cspan class=\"se\"\u003e\\p\u003c/span\u003eython3.5\u003cspan class=\"o\"\u003e(\u003c/span\u003e32bit\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"se\"\u003e\\L\u003c/span\u003eib\u003cspan class=\"se\"\u003e\\s\u003c/span\u003eite-packages numpy\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"叨叨叨\"\u003e叨叨叨\u003c/h2\u003e\n\u003cp\u003e如果电脑上安装了多个版本的\u003ccode\u003ePython\u003c/code\u003e的话，在需要使用\u003ccode\u003epip\u003c/code\u003e安装新\u003ccode\u003epackage\u003c/code\u003e时，就会遇到这个问题：我把\u003ccode\u003epackage\u003c/code\u003e安装到哪了？\u003c/p\u003e","title":"多版本 Python 使用 pip 安装 package 问题"},{"content":"保留现场 \u003c!DOCTYPE html\u003e Responsive Image Unable to load picture or PDF file \u0026#39;xxxxxx\u0026#39; \u0026lt;to be read again\u0026gt; xxxx 探究原因 图片链接错误，转换 PDF 过程中会先下载所有图片到AppData/Local/Temp/tex2pdf.****文件夹里，因为无法正常下载图片，所有报错。检查图片链接是否有效。\n解决方法 检查图片链接是否有效。\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3unable-to-load-picture-or-pdf-file/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/19-25-10-0001dfd98f5655f4cb7f8c57dbb72723-20220826192508-b7c23b.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/19-25-10-0001dfd98f5655f4cb7f8c57dbb72723-20220826192508-b7c23b.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eUnable to load picture or PDF file \u003cspan class=\"s1\"\u003e\u0026#39;xxxxxx\u0026#39;\u003c/span\u003e \u0026lt;to be \u003cspan class=\"nb\"\u003eread\u003c/span\u003e again\u0026gt; xxxx\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e图片链接错误，转换 PDF 过程中会先下载所有图片到\u003ccode\u003eAppData/Local/Temp/tex2pdf.****\u003c/code\u003e文件夹里，因为无法正常下载图片，所有报错。检查图片链接是否有效。\u003c/p\u003e","title":"解决 Unable to 加载 picture or PDF file"},{"content":"调教背景 在VSCode使用搜索/替换时，匹配的字符会“高亮”（高亮个屁），知道自己当前搜到到什么位置，如果匹配字符较少还好，如果匹配太多，默认的高亮就很难发现当前已经搜索到什么位置了。比如我当前在搜索“搜索”这两个字：\n\u003c!DOCTYPE html\u003e Responsive Image 大家还能看到我当前搜索到哪了吗？\n但是如果设置成这样呢？\n\u003c!DOCTYPE html\u003e Responsive Image 配置 搜索匹配时高亮颜色 \u003c!DOCTYPE html\u003e Responsive Image 添加如下配置：\n\u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;editor.findMatchBackground\u0026#34;: \u0026#34;#ff0000\u0026#34;, } 表示搜索匹配时高亮，高亮颜色为红色。自己可以选择合适的颜色。\n搜索结果高亮 与上面不同的是，搜索时会高亮所有的结果，但是点击箭头匹配到当前结果时就是上面的高亮，其余未匹配的状态就是下面的高亮：\n\u003c!DOCTYPE html\u003e Responsive Image \u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;editor.findMatchHighlightBackground\u0026#34;: \u0026#34;#ff00ff\u0026#34;, } 选择时颜色 \u003c!DOCTYPE html\u003e Responsive Image \u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;editor.selectionBackground\u0026#34;: \u0026#34;#2f00ff\u0026#34;, } 范围搜索时背景颜色 有时候搜索不是全局搜索，是在自己选中的范围内搜索，那这个范围也是可以高亮的，开启范围搜索需要点击搜索框的按钮，如图所示：\n\u003c!DOCTYPE html\u003e Responsive Image \u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;editor.findMatchHighlightBackground\u0026#34;: \u0026#34;#ff00ff\u0026#34;, \u0026#34;editor.findRangeHighlightBackground\u0026#34;: \u0026#34;#ff9900\u0026#34; } ","permalink":"https://lifeislife.cn/posts/vscode%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C-%E5%8C%B9%E9%85%8D%E9%AB%98%E4%BA%AE/","summary":"\u003ch1 id=\"调教背景\"\u003e调教背景\u003c/h1\u003e\n\u003cp\u003e在VSCode使用搜索/替换时，匹配的字符会“高亮”（高亮个屁），知道自己当前搜到到什么位置，如果匹配字符较少还好，如果匹配太多，默认的高亮就很难发现当前已经搜索到什么位置了。比如我当前在搜索“搜索”这两个字：\u003c/p\u003e","title":"VSCode搜索结果/匹配高亮"},{"content":"任务切换 任务简介 多任务与上下文 任务就是一个指令执行流。\n\u003c!DOCTYPE html\u003e Responsive Image 如果有多个 HART，那就可以同时执行多个指令执行流。\n协作式多任务\n协作式环境下，下一个任务被调度的前提是当前任务主动放弃处理器。\n抢占式多任务\n抢占式环境下，操作系统完全决定任务调度方案，操作系统可以剥夺当前任务对处理器的使用，将处理器提供给其它任务。\n协作式多任务 上下文切换 \u003c!DOCTYPE html\u003e Responsive Image 切换过程需要完成：\n保存上文（保存上一个任务的寄存器信息） 恢复下文（恢复下一个任务的寄存器信息） CPU 中有 32 个寄存器，保存各种状态，在切换过程中我们主要关注两个寄存器：ra(x1) 存放返回地址，mscratch 一个特权寄存器，指向当前处理的任务。\n切换过程 初始化寄存器，根据调用约定，ra都初始化为任务的第一条指令地址。mscratch开始指向 Task A。\n\u003c!DOCTYPE html\u003e Responsive Image Task A 稳定执行，当他想要放弃 CPU 时，就会执行 call swithc_to指令。执行call的过程中，就会把当前指令的下一条指令的地址放到 CPU 的ra寄存器。\n\u003c!DOCTYPE html\u003e Responsive Image 接下里跳转到swithc_to函数执行，该函数是切换上下文的核心函数。首先保存上文，将 CPU 中的寄存器信息全部保存：\n\u003c!DOCTYPE html\u003e Responsive Image 切换mscratch指针到下一个任务 Task B：\n\u003c!DOCTYPE html\u003e Responsive Image 恢复下文：\n\u003c!DOCTYPE html\u003e Responsive Image 当swithc_to函数执行到return时，接下来执行的指令就是 CPU 中ra保存的那条指令，也就是地址为j指令，这就是 Task B 的第一条指令，这样就完成了任务的切换。\n\u003c!DOCTYPE html\u003e Responsive Image 源码分析 切换核心函数 switch_to switch_to: csrrw t6, mscratch, t6 # swap t6 and mscratch beqz t6, 1f # Notice: previous task may be NULL reg_save t6 # save context of prev task # 把CPU的信息保存到内存 # Save the actual t6 register, which we swapped into # mscratch mv t5, t6 # t5 points to the context of current task csrr t6, mscratch # read t6 back from mscratch sw t6, 120(t5) # save t6 with t5 as base 1: # switch mscratch to point to the context of the next task csrw mscratch, a0 # Restore all GP registers # Use t6 to point to the context of the new task mv t6, a0 reg_restore t6 # 把内存里的信息恢复到CPU # Do actual context switching. ret 创建和初始化第一号任务 使用结构体context保存上下文中寄存器的信息：\nstruct context { /* ignore x0 */ reg_t ra; reg_t sp; reg_t gp; reg_t tp; reg_t t0; reg_t t1; reg_t t2; reg_t s0; reg_t s1; reg_t a0; reg_t a1; reg_t a2; reg_t a3; reg_t a4; reg_t a5; reg_t a6; reg_t a7; reg_t s2; reg_t s3; reg_t s4; reg_t s5; reg_t s6; reg_t s7; reg_t s8; reg_t s9; reg_t s10; reg_t s11; reg_t t3; reg_t t4; reg_t t5; reg_t t6; }; #define STACK_SIZE 1024 uint8_t task_stack[STACK_SIZE]; struct context ctx_task; 写一个任务函数，功能就是每隔1000 滴答打印一句话。\nvoid user_task0(void) { uart_puts(\u0026#34;Task 0: Created!\\n\u0026#34;); while (1) { uart_puts(\u0026#34;Task 0: Running...\\n\u0026#34;); task_delay(1000); } } 初始化任务，需要初始化栈，并把任务的首地址保存到context的ra寄存器。\nvoid sched_init() { w_mscratch(0); ctx_task.sp = (reg_t) \u0026amp;task_stack[STACK_SIZE - 1]; ctx_task.ra = (reg_t) user_task0; } 切换到第一个用户任务 switch_to函数的参数就是上下文，当执行到ret时也就切换到了user_task0。\nvoid schedule() { struct context *next = \u0026amp;ctx_task; switch_to(next); } 以上是单任务的情况，如果是多任务时，就用数组保存多个context，最大支持 10 个任务。\n#define MAX_TASKS 10 #define STACK_SIZE 1024 uint8_t task_stack[MAX_TASKS][STACK_SIZE]; struct context ctx_tasks[MAX_TASKS]; 使用简单的求模取余的方式确定下一个任务是哪一个：\n/* * _top is used to mark the max available position of ctx_tasks * _current is used to point to the context of current task */ static int _top = 0; static int _current = -1; /* * implment a simple cycle FIFO schedular */ void schedule() { if (_top \u0026lt;= 0) { panic(\u0026#34;Num of task should be greater than zero!\u0026#34;); return; } _current = (_current + 1) % _top; struct context *next = \u0026amp;(ctx_tasks[_current]); switch_to(next); } 因为多个任务协作，需要一个函数来表示主动放弃 CPU：\n/* * DESCRIPTION * task_yield() causes the calling task to relinquish the CPU and a new * task gets to run. */ void task_yield() { schedule(); } 调用关系 \u003c!DOCTYPE html\u003e Responsive Image 抢占式多任务 抢占式多任务：抢占式环境下，操作系统完全决定任务调度方案，操作系统可以剥夺当前任务对处理器的使用，将处理器提供给其他任务。\n寄存器 \u003c!DOCTYPE html\u003e Responsive Image 对 MSIP 写入 1 时触发 软中断，写入 0 时表示对中断进行应答，也就是处理完了软中断。\n任务同步与锁 并发与同步 并发：多个控制流同时执行\n多处理器多任务 单处理器多任务 单处理器任务 + 中断 同步：为了保证在并发执行的环境中各个控制流可以有效执行而采用的一种编程技术\n临界区、锁与死锁 临界区：在并发的程序执行环境中，所谓临界区指的是一个会访问共享资源的指令片段，而且当这样的多个指令片段同时访问某个共享资源时可能会引发问题。\n在并发环境下为了有效控制临界区的执行（同步），我们要做的是当有一个控制流进入临界区时，其他相关控制流必须等待。\n锁：一种常见的用来实现同步的技术\n不可睡眠锁 可睡眠锁 \u003c!DOCTYPE html\u003e Responsive Image 当发生中断时，右边的任务获取 CPU 资源，开始执行，但是获取锁时发现当前已经处于锁定状态，所以就处于等待状态。\n当下一个中断发生，左侧任务回去 CPU 后会继续执行，实际上左侧任务也不必等待，他可以一直执行，因为右侧任务一直无法获取锁。\n当然，右侧任务也可以一直触发中断，让左侧任务让出 CPU。也就是左侧任务逻辑上可以一直运行，但是实际还是会被打断。\n\u003c!DOCTYPE html\u003e Responsive Image 当左侧任务执行完释放锁，右侧任务就可以获取锁，并正常执行下去。\n\u003c!DOCTYPE html\u003e Responsive Image 死锁：当控制流执行路径中会涉及多个锁，并且这些控制流执行路径获取的顺序不同时就可能发送死锁。\n解决死锁：\n调整获取锁的顺序，比如保持一致 尽可能防止任务在持有一把锁同时申请其他锁 自旋锁 \u003c!DOCTYPE html\u003e Responsive Image 不能从 C 语言的层面去理解锁，应该要从指令级别去理解。上面的这种上锁方式是有问题的。\n如果两个控制流同时加锁，就可能同时获取了锁，因为在汇编指令级别，每条指令执行也是需要时间的：\n\u003c!DOCTYPE html\u003e Responsive Image AMOSWAP\nloop: lw a4, -20(s0) # 参数1 li a5, 1 # 参数 2 amoswap.w.aq a5, a5, (a4) # 将a5与a4指向的内存的值进行交换 # 将 1 与 a4 交换，表示如果原来上锁（1）那就什么都没做 # 如果原来没上锁（0）那就立即上锁 mv a3, a5 bnez a3,loop ![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/21-38-57-b7cece2166dba14bd128970cefdd2702-20220828213857-b116cd.png) ","permalink":"https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E4%B8%8E%E9%94%81/","summary":"\u003ch1 id=\"任务切换\"\u003e任务切换\u003c/h1\u003e\n\u003ch2 id=\"任务简介\"\u003e任务简介\u003c/h2\u003e\n\u003ch3 id=\"多任务与上下文\"\u003e多任务与上下文\u003c/h3\u003e\n\u003cp\u003e任务就是一个指令执行流。\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220826151826.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220826151826.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e如果有多个 HART，那就可以同时执行多个指令执行流。\u003c/p\u003e","title":"RISC-V 入门 - 任务切换与锁"},{"content":"如何计算堆的大小，只有算出可用空间才能对其管理。\nENTRY\n功能：用于设置入口点，即程序中执行的第一条指令 symbol 参数是一个符号的名称\nOUTPUT_ARCH\n功能：指定输出文件所适用的计算机体系架构\n为什么用 riscv64-unknown-elf-gcc，但是编译出来的文件是 32 位程序？ riscv64 是 host 是 64 位系统，编译 target 是由 gcc 的参数决定\nMEMORY\n功能：用于描述目标机器上内存区域的位置，大小和相关\nMEMORY { /* 内存类型为ROM，起始地址0，长度256K */ rom(rx):ORIGIN = 0, LENGTH = 256K /* 内存类型为RAM，起始地址0x40000000，长度4M */ ram(!rx):org = 0x40000000, l = 4M } TODO：括号里的 rx 含义是？\nSECTION\n功能：告诉链接器如何将 input sections 映射到 output sections，以及如何将 output sections 放置到内存中。\nSECTION { .=0x0000; .text:{*(.text)} .=0x8000000; .data:{*(.data)} .bss:{*(.bss)} }\u0026gt;ram PROVIDE\n功能：\n可以在 Linker Script 中定义符号（Symbols） 每个符号包括一个名字（name) 和一个对应的地址值（address） 在代码中可以访问这些符号，等同于访问一个地址。 .bss :{ PROVIDE(_bss_start = .); /* 当前地址赋值给符号_bss_start */ *(.sbss .sbss.*) *(.bss .bss.*) *(COMMON) PROVIDE(_bss_end = .); } \u0026gt;ram PROVIDE(_memory_start = ORIGIN(ram)); PROVIDE(_memory_end = ORIGIN(ram) + LENGTH(ram)); PROVIDE(_heap_start = _bss_end); /* 堆空间就是接在了bss段之后，所以堆开始地址就是bss结束地址 */ PROVIDE(_heap_size = _memory_end - _heap_start); /* 计算堆大小 */ .global表示全局变量，.word表示定义变量，下面的代码就是定义一些全局变量，方便在 C 代码中使用。\n/* mem.S */ .section .rodata .global HEAP_START HEAP_START: .word _heap_start .global HEAP_SIZE HEAP_SIZE: .word _heap_size .global TEXT_START TEXT_START: .word _text_start .global TEXT_END TEXT_END: .word _text_end .global DATA_START DATA_START: .word _data_start .global DATA_END DATA_END: .word _data_end .global RODATA_START RODATA_START: .word _rodata_start .global RODATA_END RODATA_END: .word _rodata_end .global BSS_START BSS_START: .word _bss_start .global BSS_END BSS_END: .word _bss_end /* * Following global vars are defined in mem.S */ extern uint32_t TEXT_START; extern uint32_t TEXT_END; extern uint32_t DATA_START; extern uint32_t DATA_END; extern uint32_t RODATA_START; extern uint32_t RODATA_END; extern uint32_t BSS_START; extern uint32_t BSS_END; extern uint32_t HEAP_START; extern uint32_t HEAP_SIZE; #define PAGE_SIZE 4096 static uint32_t _num_pages = _num_pages = (HEAP_SIZE / PAGE_SIZE) - 8; 实现 Page 级别的内存分配与释放\n日常使用的操作系统，都是以字节为单位分配空间，但是为了教学方便，RVOS 是以 Page 为单位分配内存。\n数据结构设计\n数组方式管理 将内存模拟为一个连续的数组，数组的前部预留 8 个 Page 来管理其余的内存。目前考虑管理的状态有：\n这 Page 是否被使用了 这个 Page 是不是最后一块分配的内存，方便我们释放内存时找到最后一块分配的内存 我们可以使用一个 8 bit 的flag来记录这些信息，flag bit[0]表示是否已使用，flag bit[1]表示是否是最后一个分配的页面。\n/* * Page Descriptor * flags: * - bit 0: flag if this page is taken(allocated) * - bit 1: flag if this page is the last page of the memory block allocated */ struct Page { uint8_t flags; }; 也就是每一个 Page 都由一个 8 bit 的结构体struct Page管理，我们总共分配了 8 个 Page 用来管理，一个 Page 占 4K，那么我们可以一个管理$8 \\times 4096 = 32768$个 Page。那就刚好可以管理$32768 \\times 4096 = 134217728 \\text{bit}$内存=128M。\n\u003c!DOCTYPE html\u003e Responsive Image Page 分配与释放接口设计\n/* * 分配连续n个可用物理页 * - npages: 需要分配的页的个数 */ void *page_alloc(int npages) { /* Note we are searching the page descriptor bitmaps. */ int found = 0; struct Page *page_i = (struct Page *)HEAP_START; for (int i = 0; i \u0026lt; (_num_pages - npages); i++) { if (_is_free(page_i)) { found = 1; /* * 找到第一个可用Page，继续判断是否有N个连续可用page */ struct Page *page_j = page_i; for (int j = i; j \u0026lt; (i + npages); j++) { if (!_is_free(page_j)) { found = 0; break; } page_j++; } /* * 找到了连续的N个可用page，将N个page设置为已分配状态 */ if (found) { struct Page *page_k = page_i; for (int k = i; k \u0026lt; (i + npages); k++) { _set_flag(page_k, PAGE_TAKEN); page_k++; } page_k--; _set_flag(page_k, PAGE_LAST); // 返回可用page首地址 return (void *)(_alloc_start + i * PAGE_SIZE); } } page_i++; } return NULL; } /* * 释放已分配的物理页 * - p: 待释放的首地址 */ void page_free(void *p) { /* * 判断非法输入，p不能为空或者超出最大可分配大小 */ if (!p || (uint32_t)p \u0026gt;= _alloc_end) { return; } /* 计算出这个首地址p所在的page的描述符，也就是找到第几个描述符在管理这块内存 */ struct Page *page = (struct Page *)HEAP_START; page += ((uint32_t)p - _alloc_start)/ PAGE_SIZE; /* 循环清空标识 */ while (!_is_free(page)) { if (_is_last(page)) { _clear(page); break; } else { _clear(page); page++;; } } } ","permalink":"https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","summary":"\u003cp\u003e如何计算堆的大小，只有算出可用空间才能对其管理。\u003c/p\u003e\n\u003cp\u003eENTRY\u003c/p\u003e\n\u003cp\u003e功能：用于设置入口点，即程序中执行的第一条指令\nsymbol 参数是一个符号的名称\u003c/p\u003e\n\u003cp\u003eOUTPUT_ARCH\u003c/p\u003e\n\u003cp\u003e功能：指定输出文件所适用的计算机体系架构\u003c/p\u003e","title":"RISC-V 入门 - 内存管理"},{"content":"总览 backgroundcolor 背景颜色 numbers 代码行号 \\lstset{ numbers = left, % 行号靠左 basicstyle = \\ttfamily, % 基本代码风格 keywordstyle = \\bfseries, % 关键字风格 commentstyle = \\ttfamily, % 注释的风格 frame = single, % 阴影效果 escapeinside=``, % 英文分号中可写入中文 xleftmargin=2em,xrightmargin=2em, aboveskip=1em, breaklines = true, language = C, % 语言选C } \u003c!DOCTYPE html\u003e Responsive Image \\lstset{ numbers = right, % 行号靠左 basicstyle = \\ttfamily, % 基本代码风格 keywordstyle = \\bfseries, % 关键字风格 commentstyle = \\ttfamily, % 注释的风格 frame = single, % 阴影效果 escapeinside=``, % 英文分号中可写入中文 xleftmargin=2em,xrightmargin=2em, aboveskip=1em, breaklines = true, language = C, % 语言选C } \u003c!DOCTYPE html\u003e Responsive Image stepnumber 间隔显示行号 \\lstset{ numbers = right, % 行号靠左 stepnumber = 2, % 每两行显示一次行号 } firstnumber 开始行号 firstnumber = 10 开始行号为 10 firstnumber = last 开始行号为上一段 listing 的结束行号 xleftmargin/xrightmargin/aboveskip/below 距离外部元素距离 设置代码块上下左右的距离，与外部元素的距离，而不是代码与边框的距离。\n\\lstset{ basicstyle = \\ttfamily, % 基本代码风格 numbers = left, % 行号靠左 keywordstyle = \\bfseries, % 关键字风格 commentstyle = \\ttfamily, % 注释的风格 frame = single, % 阴影效果 escapeinside=``, % 英文分号中可写入中文 xleftmargin=0em,xrightmargin=0em, aboveskip=0em,belowskip=0em, breaklines = true, language = C, % 语言选C } \u003c!DOCTYPE html\u003e Responsive Image \\lstset{ basicstyle = \\ttfamily, % 基本代码风格 numbers = left, % 行号靠左 keywordstyle = \\bfseries, % 关键字风格 commentstyle = \\ttfamily, % 注释的风格 frame = single, % 线框 escapeinside =``, % 英文分号中可写入中文 xleftmargin =5em, xrightmargin =0em, aboveskip =2em, belowskip =0em, breaklines = true, language = C, % 语言选C } \u003c!DOCTYPE html\u003e Responsive Image frame 边框样式 设置边框样式：\nnone:无框 single:单线框 leftline,topline,rightline,bottomline:上下左右的线 ltrb:上面参数的缩写，frame=lr 表示左右有线 LTRB:大写表示双线 \\lstset{ frame = single, % 线框 } \u003c!DOCTYPE html\u003e Responsive Image \\lstset{ frame = shadowbox, % 阴影 } \u003c!DOCTYPE html\u003e Responsive Image \\lstset{ frame = LR, % 左右边框双线 } \u003c!DOCTYPE html\u003e Responsive Image rulesepcolor 阴影颜色 \\lstset{ frame = shadowbox, % 阴影 rulesepcolor= \\color{ red!20!green!20!blue!20} , % 阴影颜色 } \u003c!DOCTYPE html\u003e Responsive Image rulecolor 边框颜色 \\lstset{ rulecolor = \\color{red}, % 边框颜色 } \u003c!DOCTYPE html\u003e Responsive Image frameround 边框倒角 \\lstset{ frameround = fftt, % 边框倒角，f表示尖角，t表示倒角，顺序是第一个字母表示右上角，顺时针 } \u003c!DOCTYPE html\u003e Responsive Image framesep 边框与代码的距离 代码不会移动，动的是边框。\n\\lstset{ framesep = 6em, % 边框与代码的距离 } \u003c!DOCTYPE html\u003e Responsive Image \\lstset{ framesep = 6em, % 边框与代码的距离 } \u003c!DOCTYPE html\u003e Responsive Image framexleftmargin/framexrightmargin/frameytopmargin/frameybottommargin 边框与代码距离 \\lstset{ framexleftmargin = -2em, % 左边框与代码距离 framexrightmargin = -5em, % 右边框与代码距离 framexbottommargin = 2em, % 下边框与代码距离 framextopmargin = 2em, % 上边框与代码距离 } \u003c!DOCTYPE html\u003e Responsive Image \\lstset{ framexleftmargin = 1em, % 左边框与代码距离 framexrightmargin = 1em, % 右边框与代码距离 framexbottommargin = 0em, % 下边框与代码距离 framextopmargin = 0em, % 上边框与代码距离 } \u003c!DOCTYPE html\u003e Responsive Image breaklines 强制换行 设置代码超长时自动换行：\n\\lstset{ breaklines = false, % 不换行 } \u003c!DOCTYPE html\u003e Responsive Image \\lstset{ breaklines = true, % 不换行 } \u003c!DOCTYPE html\u003e Responsive Image numberstyle/keywordstyle/identifierstyle/commentstyle/commentstyle 行号、关键字、标识符、注释的样式 \\definecolor{listing-background}{HTML}{F7F7F7} \\definecolor{listing-rule}{HTML}{B3B2B3} \\definecolor{listing-numbers}{HTML}{B3B2B3} \\definecolor{listing-text-color}{HTML}{000000} \\definecolor{listing-keyword}{HTML}{435489} \\definecolor{listing-identifier}{HTML}{435489} \\definecolor{listing-string}{HTML}{00999A} \\definecolor{listing-comment}{HTML}{8E8E8E} \\definecolor{listing-javadoc-comment}{HTML}{006CA9} \\lstset{ numberstyle = \\color{listing-numbers}, % 行号颜色 keywordstyle = \\color{listing-keyword}, % 关键字颜色 identifierstyle = \\color{listing-identifier}, % 变量颜色 commentstyle = \\color{listing-comment}, % 注释颜色 } \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/latex-listing%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/","summary":"\u003ch1 id=\"总览\"\u003e总览\u003c/h1\u003e\n\u003ch1 id=\"backgroundcolor-背景颜色\"\u003ebackgroundcolor 背景颜色\u003c/h1\u003e\n\u003ch1 id=\"numbers-代码行号\"\u003enumbers 代码行号\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-LaTeX\" data-lang=\"LaTeX\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e\\lstset\u003c/span\u003e\u003cspan class=\"nb\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    numbers             = left,             \u003cspan class=\"c\"\u003e% 行号靠左\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u003c/span\u003e    basicstyle          = \u003cspan class=\"k\"\u003e\\ttfamily\u003c/span\u003e,        \u003cspan class=\"c\"\u003e% 基本代码风格\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u003c/span\u003e    keywordstyle        = \u003cspan class=\"k\"\u003e\\bfseries\u003c/span\u003e,        \u003cspan class=\"c\"\u003e% 关键字风格\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u003c/span\u003e    commentstyle        = \u003cspan class=\"k\"\u003e\\ttfamily\u003c/span\u003e,        \u003cspan class=\"c\"\u003e% 注释的风格\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u003c/span\u003e    frame       = single,                   \u003cspan class=\"c\"\u003e% 阴影效果\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u003c/span\u003e    escapeinside=``,                        \u003cspan class=\"c\"\u003e% 英文分号中可写入中文\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u003c/span\u003e    xleftmargin=2em,xrightmargin=2em, aboveskip=1em,\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    breaklines          =   true,\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    language            = C,                \u003cspan class=\"c\"\u003e% 语言选C\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u003c/span\u003e\u003cspan class=\"nb\"\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211022328.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211022328.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"LaTex-listing 环境设置"},{"content":"折腾背景 Markdown 的简便性是 LaTeX 无法替代的，LaTeX 对排版的精准控制能力又是 Markdown 无法比拟的。一直在寻找一种能够将 Markdown 优雅地转换成 PDF 的解决方案，虽然早就听说也使用过 Pandoc 这把瑞士军刀，但是它太过强大，以致于一直都没用明白。只会简单的转换命令，但是实际效果并不好，最近学会了使用 LaTeX 模板的功能，这才让我眼前一亮，这才是我想要的结果。\n效果演示 基础环境配置 Markdown 生成 PDF 主要需要使用 Pandoc 和 LaTeX 两个工具，具体安装方式如下：\nPandoc 的安装 Pandoc 是由 John MacFarlane 开发的标记语言转换工具，可实现不同标记语言间的格式转换。\nWindows 下的安装：\n下载安装包直接安装即可 如果安装了 Chocolate：choco install pandoc 如果安装了 winget：winget install pandoc Linux/FreeBSD下的安装：\nPandoc 已经包含在大部分 Linux 发行版的官方仓库中，直接使用诸如apt/dnf/yum/pacman之类的安装工具直接安装即可 macOS 下的安装：\nbrew install pandoc 详细的安装说明参见：官方安装文档\nLaTeX 的安装 LaTeX 工具，建议安装 texlive。\nWindows 下的安装： 参考该文章下载完整 texlive，注意安装后需要再安装 cjk，cjk-fonts 等相关 package Linux/FreeBSD下的安装： 使用 apt/dnf/yum/pacman/pkg 等安装工具安装 texlive、texlive-latex 等相关软件包 macOS 下的安装： 使用 HomeBrew 安装 texlive 即可 模板配置 配置 Pandoc 模板 为保证生成的 pdf 格式（自动插入封面、目录页、页眉页脚等信息），在本地环境中安装模板，具体步骤是：\n下载MPPL: Markdown to PDF with Pandoc via Latex仓库 将template/mppl.latex拷贝到*/pandoc/templates目录下 Window 下：C:/Users/USERNAME/AppData/Roaming/pandoc/templates，如果Roaming没有pandoc目录，请手动创建！ Linux/FreeBSD/MacOS：~/.pandoc/templates/ 配置 LaTeX 模板 模板定制主要修改模板最前面的模板基础配置相关内容，主要可修改的包括：\n公司和组织，目前默认是\u0026quot;MPPL\u0026quot; 正文缩进，目前默认是 2em（2 个中文字符，4 个英文字符） 主要中文字体和英文字体：目前都是微软雅黑 页眉、页脚展示内容，目前是： 左页眉：title 右页眉：\u0026ldquo;企业机密 - 禁止外传\u0026rdquo; 左页脚：company 右页脚：页码 字体设置 目前页面默认的字体是微软雅黑，对于非 Windows 系统，可能不存在该字体，则有以下两种解决方案：\n手工安装微软雅黑字体（需要 msyh,msyhbd 两个文件） 修改为其他字体，如苹方、文泉驿等 若需要多个团队共同使用，建议采用方案一。\n如何生成 PDF PDF 文件指定 metadata 信息 在每个 Markdown 最前面增加以下主要 metadata 信息，metadata 内容开始行内容为三个“-”，结束行为三个“.”，示例如下：\ntitle: \u0026#34;MPPL\u0026#34; version: \u0026#34;0.1\u0026#34; subtitle: \u0026#34;Markdown to PDF with Pandoc via LaTeX\u0026#34; date: \u0026#34;2022-08\u0026#34; author: \u0026#34;Dominic\u0026#34; company: COMPANYNAME file-code: COMPANY-DEPARTMENT-00000000 logo: true logo-url: ./img/logo.png history: - version: V0.1 author: Dominic date: 2022-08-19 desc: 创建文档 其他可选配置项目如下：\nheader-left: 左页眉 header-right: 右页眉 footer-left: 左页脚 footer-right: 右页脚 CJKmainfont: 主要中文字体 mainfont: 主要字体 lot: 是否创建表格目录 lof: 是否创建图片目录 可选配置项中，建议除了 subtitle 外，全部在模板中定制，不在 Markdown 文件中定制\nMarkdown 其他编写要求 Pandoc 默认使用的 pandoc_markdown 格式，为避免 Markdown 转 pdf 格式异常，在编写 Markdown 的时候有几个原则要求：\n每个标题前后都必须有空行 每个表格前后都必须有空行 每个代码块前后收必须有空行 每个列表前后必须有空行 总之，不同文本类型之间都要有空行。\n生成 PDF 文件 pandoc --listings --pdf-engine=xelatex --template=mppl.latex README.md -o README.pdf 摆脱命令行，优雅的 VSCode 书写转换方案 VSCode 与插件安装 打开 VSCode 编辑器，在插件页搜索 markdown-preview-enhanced，接着点击 Install 按钮。详情参考VS Code 安装 MPE。\nMarkdown Preview Enhanced 以下简称 MPE\n使用 VSCode 书写 Markdown 新建文件以.md为后缀即可开始编辑 Markdown 文件，使用 MPE 实时预览与导出。\n\u003c!DOCTYPE html\u003e Responsive Image 配置 MPE 使用 Pandoc 导出 右击 MPE 的预览区域，可以看到 MPE 提供多种导出 PDF 的方案，如使用 Chrome 的 Puppeteer 导出，Prince 导出，Pandoc 导出等等。\n在未使用 Pandoc 前，我也一直使用 MPE 提供的 Chrome 方式导出，但是导出的 PDF 排版总是不尽如意。现在介绍如何使用 Pandoc 方式导出。\n\u003c!DOCTYPE html\u003e Responsive Image 创建 PDF 文档，你需要在 markdown 文件中的 front-matter 里声明 pdf_document 的输出类型：\n--- output: pdf_document: latex_engine: xelatex pandoc_args: [--template=mppl.latex,--listings] --- front-matter：文章的最开头，也就是上文元数据放的地方。和元数据放在一起即可，如图所示：\n\u003c!DOCTYPE html\u003e Responsive Image latex_engine：默认情况下 PDF 文档由 pdflatex 生成。你可以用 latex_engine 选项来定义你想用的引擎。支持的引擎有 pdflatex，xelatex，以及 lualatex。这里需要使用xelatex。\npandoc_args：配置 Pandoc 接受的一些参数，这里我们使用 --template=mppl.latex 和 --listings 来指定模板和使用 listings。这里配置的参数就是执行 Pandoc 时使用的参数，以后就不需要命令行输入了。这里使用上文的mppl.latex模板。\n配置完之后，右击预览界面，选择 Pandoc 导出，稍等片刻，即可生成 PDF 文件。\n\u003c!DOCTYPE html\u003e Responsive Image 常见问题解决 LaTeX 相关错误 VSCode 导出出错时报错信息较短，并且常常不知道具体报错原因及位置，因为是 LaTeX 转换成 PDF 的过程中出现的错误。报错位置是 LaTeX 中间源码的位置，而不是 VSCode 中的位置。这时候我常用的方法是先将 Markdown 转为 LaTeX，然后再转为 PDF，在 LaTeX 编辑器里就可以看到错误位置了。\n比如下面这个错误，我们能看到一些报错信息cant use \\spacefactor in math mode，但是并不知道具体哪里的错误。从信息里可以看出和\\LaTex有关，大概能推测出是使用了这个命令，因为文章里使用了这个命令的地方只有一处。但是如果有其他的错误，就很难确定了。\n\u003c!DOCTYPE html\u003e Responsive Image Markdown 转换 LaTeX 这里还是以模板仓库的README.md为例，当然这个文件是可以正常转换 PDF 的，不会报错。这里只是拿README.md做一个如何使用命令的演示。\npandoc --listings --template=mppl.latex -s README.md -o README.tex LaTeX 编辑器打开，以 TexStudio 为例 打开README.tex文件，编译： \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 我们可以快速的定位到问题出现的位置，只要搜索相关问题即可。\n\\LaTeX{} 这个宏不能用在数学模式下。但是因为我在 Markdown 里必须使用美元符号$$才能表示 LaTeX 环境，才能正确输出 LaTeX 符号，而 Markdown 转换成 LaTeX 源码时，这个宏就会被包裹在数学环境里，就会报错。如果我想在 PDF 里显示这个符号，那就在 Markdown 里不使用美元符号$$，而是直接输入\\LaTeX{}即可，再导出 PDF 时就不会报错。\n","permalink":"https://lifeislife.cn/posts/markdown%E4%B9%A6%E5%86%99pdf%E8%BE%93%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","summary":"\u003ch1 id=\"折腾背景\"\u003e折腾背景\u003c/h1\u003e\n\u003cp\u003eMarkdown 的简便性是 LaTeX 无法替代的，LaTeX 对排版的精准控制能力又是 Markdown 无法比拟的。一直在寻找一种能够将 Markdown 优雅地转换成 PDF 的解决方案，虽然早就听说也使用过 Pandoc 这把瑞士军刀，但是它太过强大，以致于一直都没用明白。只会简单的转换命令，但是实际效果并不好，最近学会了使用 LaTeX 模板的功能，这才让我眼前一亮，这才是我想要的结果。\u003c/p\u003e","title":"Markdown 书写 PDF 输出优雅的解决方案"},{"content":"IIC 概述 IIC（Inter-Integrated Circuit），也叫 I2C（Inter-IC Communication）总线，是一种串行通信协议，由 Philips 公司在 1980 年代初开发。IIC 总线用于连接微控制器、传感器和其他集成电路，它具有以下特点：\n双线制结构简单：由一条数据线（SDA）和一条时钟线（SCL）组成。 多主机并行通信：多个 Master 设备可同时接入同一条 IIC 总线上进行数据交换。 硬件资源占用少：只要两根线就可以连接多个器件。 数据传输速率快：现代 IIC 总线的最高传输速率可达到 400Kbps。 低功耗设计：使用者可以通过软件控制设备进入睡眠模式以减少功耗。 传输协议 写操作 主机要发出一个起始信号 主机发出一个设备地址用来确定是往那一个芯片写数据，以及写标记（0） 从设备回应（用来确定这个设备是香存在，然后就可以传输数据） 主设备发送一个字节数据给从设备，并等待回应 每传输一字节故据，接收方要有一个回应信号（确定故据是否接受完成），然后再传输下一个故据。 数据发送完之后，主机就会发送一个停止信号。 读操作 主机要发出一个起始信号 主机发出一个设备地址用来确定是往那一个芯片读数据，以及读标记（1） 从设备回应（用来确定这个设备是否存在），然后就可以传输数据 从设备发送一个字节放据给主设备，并等待回应 每传输一字节数据，接收方要有一个回应信号（确定数据是否接受完成），然后再传输下一个放据。 数据发送完之后，主芯片就会发送一个停止信号。 状态 空闲状态 SCL 和 SDA 都为高电平 此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。\n起始状态 \u003c!DOCTYPE html\u003e Responsive Image SCL 为高电平，SDA 由高电平变为低电平 标志着一次数据传输的开始。起始信号是由主控器主动建立的，在建立该信号之前 I2C 总线必须处于空闲状态。\n结束状态 SCL 为高电平，SDA 由低电平变为高电平 数据传输状态 SCL 高电平期间，SDL 保持稳定 SDL 为高电平表示 1，低电平表示 0 在 IIC 总线上传送的每一位数据都有一个时钟脉冲相对应 (或同步控制)，即在 SCL 串行时钟的配合下，数据在 SDA 上从高位向低位依次串行传送每一位的数据。进行数据传送时，在 SCL 呈现高电平期间，SDA 上的电平必须保持稳定，低电平为数据 0，高电平为数据 1。只有在 SCL 为低电平期间，才允许 SDA 上的电平改变状态。下图是 0xaa 在 IIC 总线上有效传输 (有效传输是指第 9 个时钟的高电平期间，从机给主机反馈了一个有效的应答位 0) 的图示\n\u003c!DOCTYPE html\u003e Responsive Image 在时序图中，MSB 代表的是 Most Significant Bit（最高位）。它表示二进制数中最左边的一位，也就是最高位。在一个 n 位的二进制数中，最高位的权值为 2^(n-1)。因此，MSB 在时序图中通常用来指示二进制数或数据字的最高位。同理，LSB 代表的是 Least Significant Bit（最低位）。它表示二进制数中最右边的一位，也就是最低位。\n应答状态 SCL 为高电平，SDA 由高电平变为低电平（上图最后的 ACK 标记） I2C 总线上的所有数据都是以 8 位字节传送的，发送器 (主机) 每发送一个字节，就在第 9 个时钟脉冲期间释放数据线，由从设备反馈一个应答信号。应答信号为低电平时，规定为有效应答位 (ACK 简称应答位)，表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位 (NACK)，一般表示接收器接收该字节没有成功。对于反馈有效应答位 ACK 的要求是，接收器在第 9 个时钟脉冲之前的低电平期间将 SDA 线拉低，并且确保在该时钟的高电平期间为稳定的低电平。\n以下四种情况 IIC 通信过程中会产生非应答位（NACK）：\n从机正在处理某些实时的操作无法与主机实现 IIC 通信的时候，从机会给主机反馈一个非应答 (NACK) 主机发送数据的过程中，从机无法解析发送的数据，从机也会给主机反馈一个非应答位 (NACK) 主机发送数据的过程中，从机无法再继续接收数据，从机也会给主机反馈一个非应答位 (NACK) 主机从从机中读取数据的过程中，主机不想再接收数据，主机会给从机反馈一个非应答位 (NACK)，注意，这种情况是主机给从机反馈一个非应答位 (NACK) 参考资料 IIC总线的原理与Verilog实现 - jgliu - 博客园 IIC时序分析 - 夏天师妹 - 博客园 ","permalink":"https://lifeislife.cn/posts/iic%E5%8D%8F%E8%AE%AE/","summary":"\u003ch1 id=\"iic-概述\"\u003eIIC 概述\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003eIIC（Inter-Integrated Circuit）\u003c/strong\u003e，也叫 I2C（Inter-IC Communication）总线，是一种串行通信协议，由 Philips 公司在 1980 年代初开发。IIC 总线用于连接微控制器、传感器和其他集成电路，它具有以下特点：\u003c/p\u003e","title":"IIC 协议"},{"content":"因为终端配置的原因，编译的结果输出是中文，这样搜索问题不如英文的表述精确。配置终端的语言为英文，就可以输出英文。\nexport LANG=en_US ","permalink":"https://lifeislife.cn/posts/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E4%BB%A5%E8%8B%B1%E6%96%87%E8%BE%93%E5%87%BA/","summary":"\u003cp\u003e因为终端配置的原因，编译的结果输出是中文，这样搜索问题不如英文的表述精确。配置终端的语言为英文，就可以输出英文。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eexport\u003c/span\u003e \u003cspan class=\"nv\"\u003eLANG\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003een_US\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"编译错误以英文输出"},{"content":"保留现场 void* foo(void *dst, ...) { // some code unsigned int offset = (unsigned int) dst % 8; // warning here! // some code continue... } 写驱动程序时经常会直接对地址进行修改，配置寄存器的值，也会将地址的值作为数据进行传递，这就会遇到一个问题，指针强转成整型，类型不匹配数据丢失的问题。\n探究原因 出现这个警告的原因是，将void*类型强转成unsigned int是不可移植的。什么叫不可移植呢？\n我们知道指针类型，在 32 位系统下是 4 字节，在 64 位系统下是 8 字节，而unsigned int不管在什么系统下都是是 4 字节，所以，如果将void*类型强转成unsigned int，在 64 位系统下就没有足够的空间保存真正的数据。\n解决方法 粗暴地用double来接收 先接收，再截断：\nvoid* foo(void *dst, ...) { // some code unsigned int offset = (unsigned int)(unsigned double) dst % 8; // warning here! // some code continue... } uintptr_t uintptr_t 保证足够宽，以便将 void* 转换为 uintptr_t 并再次返回将产生原始指针值。还有一个类型 intptr_t，它是有符号的；\n#include \u0026lt;stdint.h\u0026gt; // 或者 \u0026lt;inttypes.h\u0026gt; void* foo(void *dst, ...) { // some code unsigned int offset = (uintptr_t) dst % 8; // warning here! // some code continue... } ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3cast-from-pointer-to-integer-of-different-size/","summary":"\u003ch1 id=\"保留现场\"\u003e保留现场\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edst\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e...)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// some code\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eoffset\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003edst\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// warning here!\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// some code continue...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e写驱动程序时经常会直接对地址进行修改，配置寄存器的值，也会将地址的值作为数据进行传递，这就会遇到一个问题，指针强转成整型，类型不匹配数据丢失的问题。\u003c/p\u003e","title":"解决 cast from pointer to integer of different size"},{"content":"了解调试原理时看到了一个质量比较高的视频，【蛋饼嵌入式】一起探究调试原理。UP 通俗，形象地讲解了 DEBUG 的一些原理，值得反复观看，但是视频不如文字查阅效率高，遂记录了以下文稿内容。\n什么是 JTAG 1985 年，几家半导体厂商为了解决板级测试的问题，成立了 Joint Test Action Group（JTAG）联合测试行动小组，他们希望将测试点和测试电路集成在芯片内部引脚处。同时，留出一个统一协议的接口，大家都能通过这个接口来访问芯片的输入与输出状态。这样就省去了板级测试是的物理接触，同时还能进行逻辑性调试。后来 IEEE 组织，将这个方案制定成了标准 IEEE 1149.1，这就是现在我们常听到的 JTAG 调试。\n边界扫描技术 实现 JTAG 调试最重要的一个技术就是边界扫描技术，核心思想是给芯片的每一个输入输出引脚，添加一个移位寄存器单元，也称为边界扫描单元（Boundary Scan Cell，BSC）。通过它一边可以实现对芯片输出数据的截取，另一边可以完成对输入数据的替代。正常运行状态下，这些寄存器又是透明般的存在。\n\u003c!DOCTYPE html\u003e Responsive Image 这些位于引脚边界的移位寄存器，还可以串在一起，形成一条边界扫描链，以串行的方式从外部更新扫描单元上的数据，以及对外输出边界扫描单元捕获的数据。如果板上有多个这样的芯片，他们还能以菊花链的形式串联在一起，这样就大大方便了测试的过程。\n\u003c!DOCTYPE html\u003e Responsive Image 要实现对内部移位寄存器单元或者说对整个扫描链的访问和操作，便依赖于 JTAG 调试协议和相应的物理接口。JTAG 标准接口包括以下几个部分：\nTDI(Test Data In) TDO(Test Data Out) TCLK(Test Clock) TMS(Test Mode Select) TRST(Test Reset)：可选，用于复位 \u003c!DOCTYPE html\u003e Responsive Image 调试逻辑的实现，是通过芯片内部的 TAP（Test Access Port）来完成的。模式状态信号 TMS 配合测试时钟信号 TCLK，以一定的时序进入到 TAP 控制器后，由 TAP 控制器内部的状态机转化为相应的控制动作。从而完成数据的移位，引脚状态的捕获和更新。\n设备 ID 寄存器构成的扫描链，板卡一连上调试器，通过对这条扫描链的访问，就能够识别到被调试芯片的信号。存放调试机制相关配置的数据寄存器，所构成的扫描链，后面断点和单步调试时就会用到。以及移位的 BYPASS 寄存器，当调试链路上有多个芯片连接时，来减少总调试链路的长度。\n以上都属于数据寄存器构成扫描链，因为想要在他们之间进行切换，需要引入另外的指令寄存器，以及对应的扫描链，这样调试主机将不同的调试命令写到指令寄存器中，就可以选通需要调试的数据链路。数据与指令寄存器两种链路的切换，就通过 TAP 控制器完成。\n补充： 如果芯片支持 JTAG 调试，那么芯片上就必须有上述的四个接口，TDI，TDO，TCLK，TMS。 \u003c!DOCTYPE html\u003e Responsive Image 芯片外有个 Adapter 与之 Pin to Pin 连接，负责协议转换，把 USB 的 JTAG 控制信息按 JTAG 协议转换输出，满足协议定义的电气特性。 Adapter 与 Host 连接，Host 可以是我们的 PC，也可以是另一个嵌入式调试器。 Host 上通常需要运行一些软件，如 OpenOCD，负责把 GDB 的高级别命令转换成 JTAG 命令，并通过特定 Adapter 的要求进行打包，调用 OS 提供的 USB/ETH/PCI 驱动发送出去。 GDB 与 OpenOCD 通过一些远程协议，如 TCP/IP，进行通信。这样就能够调试 Chip。\n断点是如何实现的？ 通过以上 JTAG 调试接口，我们已经能够测试引脚的输入输出了，同时也获得了观察和改变芯片内部数据的机会，那么接下来我们如何进行调试呢？比如打个断点？\n断点作为一种干预性调试，根据调试行为的不同，分为监控模式和中止模式。\n监控模式（软件断点）：会触发异常，交由相应的软件程序来处理，处理器仍然处于运行状态。 中止模式（硬件断点），使处理器进入非正常运行的调试状态。 以 ARM 架构来说，最初工程师想到的办法是插入一条指令集中没有定义的无效指令，来替换掉希望打断指令处的源指令。这样内核运行到这条指令时，就会进入到无效指令的服务程序，在这个异常的服务程序中，我们再去做想要的调试操作，操作完成后，还原当时被替换的指令。并继续执行。\n后来 ARMv5 开始引入专门用于调试的BKPT指令，类似与 X86 指令集的INT3指令，但不管是不是专用指令，他们都属于软件中断。这意味着我想要实时地添加这种断点，就要求能够随时地更改程序，插入断点指令，而一般只有程序运行在 RAM 上，才方便这样操作。那如果直接从 FLASH 上取址运行的程序，因为 FLASH 先擦后写的物理特性，是无法通过随意插入指令来实现断点的。更不要说从只读存储器上运行的程序，比如说固化在 BIOS 中上电自检 POST 程序，面对这种情况，需要的就是硬件断点。\n硬件断点顾名思义，需要额外的硬件逻辑支持，主要起的作用就是暂存和比较，我们把这种实现特定逻辑的组合电路，称为宏单元（Macro Cell）。\n还记得我们前面说过 JTAG 协议，支持自定义扩展扫描链吗？硬件断点宏单元的控制和比较两种数据寄存器，就可以作为两条拓展扫描链，加入到 JTAG 调试框架中。\n你在调试软件中按下一个按钮，对应的那行代码地址，就会通过上述扫描链，被记录到断点宏单元相应的寄存器中，当然，调试器能够知道某行代码的地址，是依赖于编译时生成的 ELF 文件中的符号表信息。而当程序正常运行取址时，如果宏单元的寄存器，发现了总线上出现了记录过的地址，比较器就会发出调试状态信号，CPU 接收到这个信号后暂停运行，进入调试模式或者异常。\n因为每打一个断点，都需要宏单元相应的寄存器来保存地址信息。而寄存器数量是有限的，所以调试软件一旦和芯片建立起了连接，就会通过上述的另外一条控制寄存器获得该硬件断点宏单元所支持的最大断点数，这样你在调试过程中如果断点打多了，调试器就会报错。\n为什么调试器能够烧录程序呢？ 正常情况下，CPU 内核通过内部的系统总线，从 FLASH 或者 RAM 中获取运行的指令，交换数据，并在一定的驱动程序下，实现对 FLASH 的擦除和写入操作。为了把指令和数据直接给 CPU 内核，我们还需要定义一条扫描链，这条扫描链直接在系统总线上开了一个口子，通过上位机的调试信号，把相关的操作指令直接传到总线上，供 CPU 内核取用。\n\u003c!DOCTYPE html\u003e Responsive Image 那么整个调试器的下载过程是这样的：\n第一，通过调试器使得 CPU 进入调试模式； 第二，通过总线扫描链将 FLASH 编程算法与即将被下载的用户程序放到 RAM 中； 第三，将 CPU 的 PC 指针指向刚刚搬运完成的 RAM 地址起始处，并退出调试状态； 第四，CPU 将在正常状态下运行 RAM 中的 FLASH 编程算法。将用户代码烧录到确定位置上，执行完成后回到调试状态。 如果 RAM 空间不够大，以上操作还需要重复多次执行。\n需要注意的是，在第二步操作 RAM 时，是处于调试状态下，而调试时钟的速率是无法满足 RAM 或者 FLASH 的访问速率要求的，所以在这一过程中，CPU 会频繁的在系统时钟与调试时钟之间切换\n调试时钟下，总线扫描链先传递来要写入的数据和 RAM 地址，CPU 先分别暂存在内部通用寄存器中，接着扫描链传递写入指令，并切换为系统时钟。CPU 在正常状态下执行搬运指令，往 RAM 里写入数据，执行完成后回到调试状态，继续通过扫描链传递后面要写入的值，\nOpenOCD (Open On-Chip Debugger) OpenOCD（Open On-Chip Debugger）开源片上调试器，是一款开源软件，最初是由 Dominic Rath 同学还在大学期间发起的（2005 年）项目。OpenOCD 旨在提供针对嵌入式设备的调试、系统编程和边界扫描功能。\n参考资料 【蛋饼嵌入式】饮茶先？DEBUG 先！一起探究调试原理_哔哩哔哩_bilibili 浅谈 RISC-V 的 DEBUG 系统及其仿真 - 知乎 ESP32 JTAG Debug 01: JTAG 接口简介_哔哩哔哩_bilibili+\n","permalink":"https://lifeislife.cn/posts/debug%E5%8E%9F%E7%90%86/","summary":"\u003cp\u003e了解调试原理时看到了一个质量比较高的视频，\u003ca href=\"https://www.bilibili.com/video/BV1iN411Z7jk?spm_id_from=333.999.0.0\u0026amp;vd_source=7ff88341de4b5111bdf3db48b4e9ca44\"\u003e【蛋饼嵌入式】一起探究调试原理\u003c/a\u003e。UP 通俗，形象地讲解了 DEBUG 的一些原理，值得反复观看，但是视频不如文字查阅效率高，遂记录了以下文稿内容。\u003c/p\u003e\n\u003ch2 id=\"什么是-jtag\"\u003e什么是 JTAG\u003c/h2\u003e\n\u003cp\u003e1985 年，几家半导体厂商为了解决板级测试的问题，成立了 Joint Test Action Group（JTAG）联合测试行动小组，他们希望将测试点和测试电路集成在芯片内部引脚处。同时，留出一个统一协议的接口，大家都能通过这个接口来访问芯片的输入与输出状态。这样就省去了板级测试是的物理接触，同时还能进行逻辑性调试。后来 IEEE 组织，将这个方案制定成了标准 IEEE 1149.1，这就是现在我们常听到的 JTAG 调试。\u003c/p\u003e","title":"DEBUG 原理"},{"content":"SSH 总是被强行中断，尤其是用 VSCode 代码写的好好的，突然刷新窗口，不仅效率低，更惹人恼火。\n可以通过配置服务端或客户端的 SSH 来保持 SSH 链接：\n方法一：配置服务端 可以在服务端配置，让 server 每隔 30 秒向 client 发送一个 keep-alive 包来保持连接：\nvim /etc/ssh/sshd_config ClientAliveInterval 30 ClientAliveCountMax 60 第二行配置表示如果发送 keep-alive 包数量达到 60 次，客户端依然没有反应，则服务端 sshd 断开连接。如果什么都不操作，该配置可以让连接保持 30s*60，30 min\n重启本地 ssh\nsudo service ssh restart 如果找不到 ssh,”Failed to restart ssh.service: Unit ssh.service not found.” ，需要安装\nsudo apt-get install openssh-server 方法二：配置客户端 如果服务端没有权限配置，或者无法配置，可以配置客户端 ssh，使客户端发起的所有会话都保持连接：\nvim /etc/ssh/ssh_config ServerAliveInterval 30 ServerAliveCountMax 60 本地 ssh 每隔 30s 向 server 端 sshd 发送 keep-alive 包，如果发送 60 次，server 无回应断开连接。\n在 VSCode 里可以直接添加配置，效果一样： \u003c!DOCTYPE html\u003e Responsive Image Host 11.22.33.44 HostName 11.22.33.44 User user Port 112343 ServerAliveInterval 30 ServerAliveCountMax 60 ","permalink":"https://lifeislife.cn/posts/%E4%BF%9D%E6%8C%81ssh%E8%BF%9E%E6%8E%A5/","summary":"\u003cp\u003eSSH 总是被强行中断，尤其是用 VSCode 代码写的好好的，突然刷新窗口，不仅效率低，更惹人恼火。\u003c/p\u003e\n\u003cp\u003e可以通过配置服务端或客户端的 SSH 来保持 SSH 链接：\u003c/p\u003e\n\u003ch2 id=\"方法一配置服务端\"\u003e方法一：配置服务端\u003c/h2\u003e\n\u003cp\u003e可以在服务端配置，让 server 每隔 30 秒向 client 发送一个 keep-alive 包来保持连接：\u003c/p\u003e","title":"保持 SSH 连接"},{"content":"随着插件越装越多，标签栏右侧的按钮也越来越多，严重缩小了标题栏显示范围。这片按钮区域又有最大长度的限制，当按钮太多，就会隐藏到下拉菜单里（最右侧的三个点）。这样就会导致一些常用的按钮被隐藏，而不常用的按钮又占地方。那么怎样才能隐藏不需要的按钮呢？\n\u003c!DOCTYPE html\u003e Responsive Image \u0026#34;gitlens.menus\u0026#34;: { \u0026#34;editorGroup\u0026#34;: { \u0026#34;blame\u0026#34;: false, \u0026#34;compare\u0026#34;: true }, }, ","permalink":"https://lifeislife.cn/posts/vscode%E9%9A%90%E8%97%8F%E7%BC%96%E8%BE%91%E9%A1%B5%E9%9D%A2%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E6%8C%89%E9%92%AE/","summary":"\u003cp\u003e随着插件越装越多，标签栏右侧的按钮也越来越多，严重缩小了标题栏显示范围。这片按钮区域又有最大长度的限制，当按钮太多，就会隐藏到下拉菜单里（最右侧的三个点）。这样就会导致一些常用的按钮被隐藏，而不常用的按钮又占地方。那么怎样才能隐藏不需要的按钮呢？\u003c/p\u003e","title":"VSCode 隐藏编辑页面右上角的按钮"},{"content":"Docker 启动 version: \u0026#34;3.7\u0026#34; services: jellyfin: image: dockerproxy.com/linuxserver/jellyfin:latest container_name: jellyfin hostname: RISCX environment: - PUID=1000 - PGID=1000 - TZ=Asia/Shanghai - HTTP_PROXY:\u0026#39;http://192.168.1.9:7890\u0026#39; - HTTPS_PROXY:\u0026#39;http://192.168.1.9:7890\u0026#39; volumes: - /root/sharedfolder/appdata/jellyfin/config:/config - /root/sharedfolder/media:/media - /root/sharedfolder/appdata/jellyfin/cache:/cache devices: - /dev/dri:/dev/dri extra_hosts: - \u0026#34;api.themoviedb.org:108.138.246.55\u0026#34; - \u0026#34;image.themoviedb.org:104.16.61.155\u0026#34; - \u0026#34;www.36dm.com:104.21.80.200\u0026#34; network_mode: \u0026#34;host\u0026#34; restart: unless-stopped 初始化配置 就不挨个贴图了，建议将页面都设置为中文，有一点需要注意的是选择国家的时候，中国的英文全称是 People\u0026rsquo;s Republic of China，不是 China，需要仔细找一下。\n转码配置 主要配置硬解码，这样可以大大降低 CPU 的使用率，提高播放的流畅度。能够开启硬解需要 GPU 支持，如果 CPU 有核显，那么就可以开启硬解，如果没有，那么就算了吧，跳过。也可以通过下面的命令查看是否支持硬解。\ncat /proc/cpuinfo | grep \u0026#34;flags\u0026#34; 该命令将输出 CPU 的系统信息，并在输出结果中搜索\u0026quot;flags\u0026quot;（标志）行。如果该行中包含\u0026quot;vme\u0026quot;、\u0026ldquo;cmov\u0026rdquo;、\u0026ldquo;cx8\u0026rdquo;、\u0026ldquo;mmx\u0026rdquo;、\u0026ldquo;sse\u0026rdquo;、\u0026ldquo;sse2\u0026rdquo;、\u0026ldquo;sse3\u0026rdquo;、\u0026ldquo;ssse3\u0026rdquo;、\u0026ldquo;sse4_1\u0026rdquo;、\u0026ldquo;sse4_2\u0026rdquo;、\u0026ldquo;avx\u0026quot;等关键词，则说明该 CPU 支持视频硬解码。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 调用Potplayer本地解码 使用下面这个插件可以实现调用本地播放器播放视频，这样就可以使用 Potplayer 等播放器进行播放，而不是使用 Jellyfin 的内置播放器。文档写的十分详细，在这里就不再赘述了。\nkjtsune/embyToLocalPlayer: Emby/Jellyfin 调用外部本地播放器，并回传播放记录。适配 Plex。\n插件配置 所有插件都可以通过以下路径配置，后续不再赘述。所有地址都加上了代理地址https://mirror.ghproxy.com，请不要删掉，否则目录中的插件将无法加载。\n管理页面 -\u0026gt; 插件 -\u0026gt; 存储库 -\u0026gt; 添加存储库 -\u0026gt; 输入manifest.json地址 -\u0026gt; 确定\n\u003c!DOCTYPE html\u003e Responsive Image 在目录中找到刚刚添加的插件，点击安装即可。\n更换皮肤 https://mirror.ghproxy.com/https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 字幕刮削 弹幕刮削 Danmu 支持下载哔站，爱奇艺，腾讯，优酷，等视频的弹幕。\nhttps://mirror.ghproxy.com/https://github.com/cxfksword/jellyfin-plugin-danmu/releases/download/manifest/manifest_cn.json 字幕刮削 OpenSubtitles OpenSubtitles 没找到 manifest.json 地址，需要下载插件，然后上传到 Jellyfin 中安装。jellyfin/jellyfin-plugin-opensubtitles\nHome | opensubtitles.com注册账号，生成 API Key，然后在插件中配置即可。\n元数据 剧集重命名 Nriver/Episode-ReName: 电视剧/番剧自动化重命名工具, 一键批量改名. 可配合QBittorrent下载后自动重命名, 方便Emby自动刮削. 支持Windows, Linux, MacOS, Docker 和 群晖套件环境运行\n常规刮削 Metashark https://mirror.ghproxy.com/https://github.com/cxfksword/jellyfin-plugin-metashark/releases/download/manifest/manifest_cn.json 小日子刮削 Metatube 部署后端服务，然后在插件中配置后端地址即可。这里比较关键的是需要配置代理，并且代理需要通过WebUI设置允许来自局域网的连接，否则无法获取到数据。请参考这篇文章Linux 下使用 Clash 作代理并配置开机启动 | 夜云泊个人博客。代理协议最好选择socks5。\nmetatube: image: metatube/metatube-server:latest container_name: metatube ports: - 8180:8080 restart: unless-stopped environment: - http_proxy=socks5://192.168.1.9:7891 - https_proxy=socks5://192.168.1.9:7891 - USER_UID=1000 - USER_GID=1000 - TZ=Asia/Shanghai networks: - br-net-metatube depends_on: - metatube-postgres volumes: - /root/sharedfolder/appdata/metatube/run:/var/run command: -dsn \u0026#34;postgres://metatube:metatube@/metatube?host=/var/run/postgresql\u0026#34; -port 8080 -db-auto-migrate -db-prepared-stmt metatube-postgres: image: postgres:15-alpine container_name: metatube-postgres restart: unless-stopped environment: - USER_UID=1000 - USER_GID=1000 - POSTGRES_USER=metatube - POSTGRES_PASSWORD=metatube - POSTGRES_DB=metatube - TZ=Asia/Shanghai volumes: - /root/sharedfolder/appdata/metatube/db:/var/lib/postgresql/data - /root/sharedfolder/appdata/metatube/run:/var/run command: \u0026#34;-c TimeZone=Asia/Shanghai -c log_timezone=Asia/Shanghai -c listen_addresses=\u0026#39;\u0026#39; -c unix_socket_permissions=0777\u0026#34; networks: br-net-metatube: external: true \u003c!DOCTYPE html\u003e Responsive Image https://mirror.ghproxy.com/https://raw.githubusercontent.com/metatube-community/jellyfin-plugin-metatube/dist/manifest.json 欧美刮削 TheP**nDB Google 搜索 TheP**nDB 注册账号，生成 API Key，然后在插件中配置即可。\nhttps://mirror.ghproxy.com/https://raw.githubusercontent.com/ThePornDatabase/Jellyfin.Plugin.ThePornDB/main/manifest.json \u003c!DOCTYPE html\u003e Responsive Image 跳过片头 Intro-Skip https://mirror.ghproxy.com/https://raw.githubusercontent.com/ConfusedPolarBear/intro-skipper/master/manifest.json ","permalink":"https://lifeislife.cn/posts/jellyfin%E6%89%93%E9%80%A0%E6%9C%AC%E5%9C%B0%E5%BD%B1%E9%9F%B3%E5%BA%93/","summary":"\u003ch1 id=\"docker-启动\"\u003eDocker 启动\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yml\" data-lang=\"yml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eversion\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;3.7\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nt\"\u003eservices\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003ejellyfin\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eimage\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003edockerproxy.com/linuxserver/jellyfin:latest\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003econtainer_name\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003ejellyfin\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003ehostname\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eRISCX\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eenvironment\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003ePUID=1000\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003ePGID=1000\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eTZ=Asia/Shanghai  \u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eHTTP_PROXY:\u0026#39;http://192.168.1.9:7890\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eHTTPS_PROXY:\u0026#39;http://192.168.1.9:7890\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003evolumes\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/root/sharedfolder/appdata/jellyfin/config:/config\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/root/sharedfolder/media:/media\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/root/sharedfolder/appdata/jellyfin/cache:/cache\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003edevices\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003e/dev/dri:/dev/dri\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eextra_hosts\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;api.themoviedb.org:108.138.246.55\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;image.themoviedb.org:104.16.61.155\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"s2\"\u003e\u0026#34;www.36dm.com:104.21.80.200\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003enetwork_mode\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;host\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003erestart\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eunless-stopped\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"初始化配置\"\u003e初始化配置\u003c/h1\u003e\n\u003cp\u003e就不挨个贴图了，建议将页面都设置为中文，有一点需要注意的是\u003cstrong\u003e选择国家\u003c/strong\u003e的时候，\u003cstrong\u003e中国的英文全称是 People\u0026rsquo;s Republic of China\u003c/strong\u003e，不是 China，需要仔细找一下。\u003c/p\u003e","title":"Jellyfin 打造本地影音库"},{"content":"折腾背景 一直想找一个能够快速同步手机与电脑数据的工具，因为手机云服务的空间少的可怜，所以习惯隔一段时间将手机里的照片、视频还有一些文件导出到电脑上。但是每次备份文件都得连接数据线，并且没法增量备份，得手动挑选，也还挺麻烦的。\n逛 GitHub 时，无意间发现了 Syncthing，几乎符合了我所有的预期。\n开源，免费，自己电脑就可以当服务器，以后入了 NAS，可以自己搭建本地服务器。 同步速度快，取决 WIFI 的速度，目前使用 30M/s，基本满速。 多端支持，除了 IOS（反正我也没有 iOS 设备，嘿嘿），几乎全平台支持，包括 NAS 及路由器。 增量同步，再也不用挑文件备份了。 话不多说，开整。\n下载安装 直接进入Syncthing官网，下载安装。在 Ubuntu 下安装参考这里。Android 版本下载Syncthing。\n接下来以 Windows 与 Android 手机同步为例，下载安装后，打开syncthing.exe，即可打开管理界面，或者浏览器输入http://127.0.0.1:8384也可进入管理界面。\nWindows 界面：\n\u003c!DOCTYPE html\u003e Responsive Image Android 界面： \u003c!DOCTYPE html\u003e Responsive Image 设备配对 Windows 管理页面-\u0026gt;操作-\u0026gt;显示 ID，会显示本机的二维码：\n\u003c!DOCTYPE html\u003e Responsive Image Android 手机打开应用，切换到设备界面，点击右上角加号，点击二维码标识，即可扫描二维码，完成设备添加。\n\u003c!DOCTYPE html\u003e Responsive Image 如果正确添加，Windows 管理界面会显示 Android 设备：\n\u003c!DOCTYPE html\u003e Responsive Image Android 同步至 Windows 打开 Android 应用，切换到文件夹界面，点击右上角加号，配置同步的文件夹： \u003c!DOCTYPE html\u003e Responsive Image 根据下图提示，配置应用，记得保存： \u003c!DOCTYPE html\u003e Responsive Image 目录列表显示刚刚的配置： \u003c!DOCTYPE html\u003e Responsive Image 点击打开，开启与远程设备 Windows 同步：\n\u003c!DOCTYPE html\u003e Responsive Image 当返回时，Windows 端将会弹出通知，提示有 Android 设备的文件要分享到电脑，点击添加： \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 至此，Android 同步至 Windows 完成。此时在 Android 设备的文件夹中添加任意文件，都会同步到 Windows。\n如果是局域网内，发现设备的速度很慢，可以尝试设置静态的 IP。手机端 -\u0026gt; 设备 -\u0026gt; 链接图标。默认为 dynamic，将其改为 Windows 的 IP 和 syncthing 的端口。如tcp://192.168.1.9:22000。\n也可以在服务端配置手机的IP，手机IP可以通过设置中心-\u0026gt;关于手机-\u0026gt;状态-\u0026gt;IP地址查看。比如192.168.1.16，那么可以配置为tcp://192.168.1.16:22000。\nWindows 同步至 Android Windows 管理界面，添加文件夹： \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 点击保存后，与之前类似，Android 会提示有 Windows 设备的文件要分享到 Android，点击添加：\n如果 Android 设备没有弹出提示添加共享文件夹，那么打开应用侧边栏-\u0026gt;网页管理页面，将会有弹窗，如下图\n\u003c!DOCTYPE html\u003e Responsive Image 点击添加，配置文件夹目录等与之前类似。\n至此，Windows 同步至 Android 完成。此时在 Windows 设备的文件夹中添加任意文件，都会同步到 Android。\n使用技巧 Syncthing 支持三种工作模式 发送和接收，Send \u0026amp; Receive Folder，这是文件夹的默认模式，对文件夹的修改会发送，其他设备的修改也会同步回来。 仅发送 Send Only，这种模式表示仅仅将当前设备上的文件夹的改动发送到其他设备，用来隐式地表示其他同步设备上的文件不会被修改，或者其他设备上的修改可以被忽略。这种模式非常适合，将当前设备设定为工作设备，然后设定一台设备作为此设备的备份。 在 Send Only 模式下，集群中其他设备的修改都会被忽略，修改依然会接收，文件夹可能会出现 「out of sync」，但是没有修改会被应用到本地。 当 Send Only 文件夹出现 out of sync，那么一个红色的 Override Changes 会出现在文件夹详情中，点击该按钮会强制将当前主机的状态同步到其他剩余节点。任何对文件的修改，都会被当前主机上的版本所覆盖，任何不存在于当前主机节点的文件都会被删除，其他类似。 仅接收 Receive Only，这种模式下所有的修改都会被接收并应用，然后重新分发给其他使用 send-receive 模式的设备。但是本地的修改不会被分发给其他设备。这种模式适合于建立备份镜像（replication mirrors），或者备份目的主机的场景，这些情况下不期望有本地修改或者本地的修改是不允许的 当本地文件被删除时，Syncthing 会显示一个 Revert Local Changes 按钮。使用这个按钮会将本地的修改回撤，所有添加的文件会被删除，修改或删除的文件会重新从其他节点同步，比较容易理解，但是假如 A 设备设置仅发送，B 设备设置发送和接收，A 是不会同步 B 的更改的！ 忽略特定文件、目录 忽略列表，和 gitignore 类似。每一台设备上的 .stignore 都是分别设置的，不会进行同步。\n如果 A 的.stignore忽略了 test ，而 B 没有这样做，实际上会发生这样的事情：\nA 不会扫描和通知 B（广播）关于 test 的变动； B 对关于 test 的变动持开放的姿态，但不会收到任何关于 A 上面 test 的变动信息（可能接收到其它同步设备的）； B 会扫描 test 以及推送其关于 test 变动的信息，但会被 A 忽略，A 也会忽略其它同步设备关于 test 的信息； B 会接收来自其它同步设备推送的关于 test 的信息； 参考资料 Syncthing 又一款同步工具 | Verne in GitHub\nFolder Types — Syncthing documentation\n","permalink":"https://lifeislife.cn/posts/%E4%BD%BF%E7%94%A8syncthing%E5%A4%9A%E7%AB%AF%E4%B8%9D%E6%BB%91%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A4%87%E4%BB%BD/","summary":"\u003ch2 id=\"折腾背景\"\u003e折腾背景\u003c/h2\u003e\n\u003cp\u003e一直想找一个能够快速同步手机与电脑数据的工具，因为手机云服务的空间少的可怜，所以习惯隔一段时间将手机里的照片、视频还有一些文件导出到电脑上。但是每次备份文件都得连接数据线，并且没法增量备份，得手动挑选，也还挺麻烦的。\u003c/p\u003e","title":"使用 Syncthing 多端丝滑同步与备份"},{"content":"保留现场 remote: Resolving deltas: 100% (114/114) remote: Processing changes: refs: 1,done remote: ERROR: missing Change-Idincommit message footer remote: remote: Hint: To automatically insert Change-Id,installthe hook: remote: gitdir=$(git rev-parse --git-dir);scp-p -P XX XX@gerrit.xxxxx.com:hooks/commit-msg${gitdir}/hooks/ remote: And then amend the commit: remote: git commit --amend 探究原因 理解 change-id 代码审核是要对一个完整的变更进行审核，比如一次 Bug 修复，有多次提交 Commit，每次的 Commit Id 都不同，那么如何将多个不同的 Commit ID 关联到同一个 Chanege-Id 呢？我们需要将 Change-Id 添加到 Commit 的 footer（最后一行）中，这样就可以将多个 Commit 关联到同一个 Change-Id 了。\n\u003c!DOCTYPE html\u003e Responsive Image Change-Id 为避免与提交 Id 冲突，通常以大写字母 I 为前缀。此外，我们需要明确，Change-Id 是 Gerrit 的概念，不是 Git 的概念。你只有用 Gerrit 才会有 Change-Id，而 Git 只有提交 Id。\n那么这个 Change-Id 是怎么生成的呢？\n理解 git hooks 我在Git hooks 钩子的使用中有详细解释。在这里简单的介绍一下，钩子 (hooks) 是一些在.git/hooks目录的脚本，在被特定的事件触发后被调用。比如执行git commit，git push，git pull等命令时，脚本会被调用。\nGerrit 也提供了一个标准的commit-msg钩子，当我们在执行git commit时，会被调用。会自动生成Change-Id，并将其添加到commit的 footer 中。\n通常我们从远程下载代码后，会自动下载commit-msg钩子，并将其添加到.git/hooks目录中。正常来说hooks是不会加入代码仓库的，这应该取决于 Gerrit 的配置。\n这次错误应该是我在测试钩子的时候，将 Gerrit 标准钩子删除了，导致无法正确生成 Change-Id。\n解决方法 报错时其实已经提供了解决方式：\n# 提示让我们安装远程的钩子 remote: Hint: To automatically insert Change-Id,installthe hook: # 在命令行输入以下两条命令： # 这条命令将找到该项目的 git 目录,并将其赋值给 gitdir 这个变量 gitdir=$(git rev-parse --git-dir) # 执行 scp 命令,从 gerrit 代码服务器将钩子脚本文件 commit-msg 下载到项目的钩子目录下 (一般是 .git/hooks/) scp-p -P XX XX@gerrit.xxxxx.com:hooks/commit-msg${gitdir}/hooks/ 安装完之后重新git commit --amend，就可以正常生成 Change-Id 了。\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BA%A4gerrit-missing-change-id/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eremote: Resolving deltas: 100% \u003cspan class=\"o\"\u003e(\u003c/span\u003e114/114\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eremote: Processing changes: refs: 1,done   \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eremote: ERROR: missing Change-Idincommit message footer\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eremote:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eremote: Hint: To automatically insert Change-Id,installthe hook:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eremote:   \u003cspan class=\"nv\"\u003egitdir\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"k\"\u003e$(\u003c/span\u003egit rev-parse --git-dir\u003cspan class=\"k\"\u003e)\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003escp-p -P XX XX@gerrit.xxxxx.com:hooks/commit-msg\u003cspan class=\"si\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003egitdir\u003c/span\u003e\u003cspan class=\"si\"\u003e}\u003c/span\u003e/hooks/\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eremote: And \u003cspan class=\"k\"\u003ethen\u003c/span\u003e amend the commit:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eremote:   git commit --amend\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003ch3 id=\"理解-change-id\"\u003e理解 change-id\u003c/h3\u003e\n\u003cp\u003e代码审核是要对一个完整的变更进行审核，比如一次 Bug 修复，有多次提交 Commit，每次的 Commit Id 都不同，那么如何将多个不同的 Commit ID 关联到同一个 Chanege-Id 呢？我们需要将 Change-Id 添加到 Commit 的 footer（最后一行）中，这样就可以将多个 Commit 关联到同一个 Change-Id 了。\u003c/p\u003e","title":"解决提交 gerrit missing Change-Id"},{"content":"背景 公司使用 Gerrit 作为 Review 平台，但是每次提交代码都需要手动添加 Reviewer，还要抄送组内成员，这种重复性劳动，程序员是绝不能容忍的。gerrit 提供了发送邮件的功能。\n解决方法 官方示例：\ngit push ssh://john.doe@git.example.com:29418/kernel/common HEAD:refs/for/experimental%r=a@a.com,cc=b@o.com 最后的%是个分隔符，r='a@a.com表示 Reviewer 是a@a.com，cc=b@o.com表示抄送组内成员是b@o.com。\n注意！邮箱之间不能有空格！\n以一个仓库为例：\ngit push origin HEAD:refs/for/branch_dev_name%cc=zhangsan@qq.com,cc=lisi@qq.com,cc=wangerma@qq.com,cc=chenwu@qq.com 但是要这么写，岂不是把操作搞更复杂了。\n终极办法，打开项目路径下的.git目录。编辑config文件：\n原文件里有如下字段：\n[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true ignorecase = true [remote \u0026#34;origin\u0026#34;] url = git@github.com:Dunky-Z/Dunky-Z.github.io.git fetch = +refs/heads/*:refs/remotes/origin/* 我们可以将远程仓库名换成容易区分的名字，自己随意：\n[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true ignorecase = true [remote \u0026#34;origin\u0026#34;] url = git@github.com:Dunky-Z/Dunky-Z.github.io.git fetch = +refs/heads/*:refs/remotes/origin/* # 以下为新增内容 [remote \u0026#34;review\u0026#34;] url = git@github.com:Dunky-Z/Dunky-Z.github.io.git fetch = +refs/heads/*:refs/remotes/origin/* push = HEAD:refs/for/%cc=zhangsan@qq.com, cc=lisi@qq.com, cc=wangerma@qq.com, cc=chenwu@qq.com 下次想要推送需要 review 的代码，就直接执行git push review，其中push就相当于：\npush HEAD:refs/for/%cc=zhangsan@qq.com,cc=lisi@qq.com,cc=wangerma@qq.com,cc=chenwu@qq.com 参考资料 Gerrit Code Review - Uploading Changes\n","permalink":"https://lifeislife.cn/posts/gerrit%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%8A%84%E9%80%81%E6%8F%90%E9%86%92/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e公司使用 Gerrit 作为 Review 平台，但是每次提交代码都需要手动添加 Reviewer，还要抄送组内成员，这种重复性劳动，程序员是绝不能容忍的。gerrit 提供了发送邮件的功能。\u003c/p\u003e","title":"Gerrit 批量添加抄送提醒"},{"content":"有时需要通过make编译命令时确定代码中的宏定义，如编译不同的版本只需要使用不同的编译命令即可，而不需要修改内部代码。\n当前的需求是代码中有一部分代码通过宏定义来确定编译的是 DIE0 版本还是 DIE1 版本，如果定义了DIE_ORDINAL_0 就使用 DIE0 的基地址，如果未定义就使用 DIE1 的基地址。\n#define DIE_ORDINAL_0 #ifdef DIE_ORDINAL_0 #define PERIPH_BASE (SYS_BASE_ADDR_DIE0) #else #define PERIPH_BASE (SYS_BASE_ADDR_DIE1) #endif gcc 命令支持-D宏定义，相当于 C 中的全局#define，在 Makefile 中我们可以通过宏定义来控制源程序的编译。只要在 Makefile 中的 CFLAGS 中通过选项-D 来指定你于定义的宏即可。\nCFLAGS += -D DIE_ORDINAL_0 # 在编译的时候加上此选项就可以了 $(CC) $(CFLAGS) $^ -o $@ 这样的话，相当于设置了DIE_ORDINAL_0这个宏定义。但是我们想通过命令行的参数来决定是否使用这个宏定义，可以通过一些简单的方法获取：\nifeq ($(DIE0), y) CFLAGS +=-DDIE_ORDINAL_0 else CFLAGS +=-DDIE_ORDINAL_1 endif $(CC) $(CFLAGS) $^ -o $@ 从命令行找到DIE0这个参数，如果它等于y表示使用DIE_ORDINAL_0。如果不等于y则使用DIE_ORDINAL_1，因为我们代码里没有DIE_ORDINAL_1，所以就相当于没有定义DIE_ORDINAL_0。\n命令行示例：\n# 编译DIE0 make DIE0=\u0026#34;y\u0026#34; # 编译DIE1 make DIE0=\u0026#34;n\u0026#34; ","permalink":"https://lifeislife.cn/posts/makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/","summary":"\u003cp\u003e有时需要通过\u003ccode\u003emake\u003c/code\u003e编译命令时确定代码中的宏定义，如编译不同的版本只需要使用不同的编译命令即可，而不需要修改内部代码。\u003c/p\u003e\n\u003cp\u003e当前的需求是代码中有一部分代码通过宏定义来确定编译的是 DIE0 版本还是 DIE1 版本，如果定义了\u003ccode\u003eDIE_ORDINAL_0\u003c/code\u003e 就使用 DIE0 的基地址，如果未定义就使用 DIE1 的基地址。\u003c/p\u003e","title":"Makefile 确定宏定义"},{"content":"使用背景 在测试下载速度，或者测试加解密文件，亦或者制作文件系统时都需要一些指定大小的文件。Linux 有一些命令可以快速完成这样的任务。接下来介绍几个好用的命令。\n空洞文件 在 Unix 文件操作中，操作文件的位移量可以大于文件的当前长度，在下一次写操作时，就会把文件撑大（Extend），在文件里创建空洞（Hole），没有被实际写入的部分都是 0。空洞文件是否占用实际磁盘空间由文件系统觉得，Linux 中空洞文件不占用实际磁盘空间。\nfallocate fallocate用于将块预分配给文件。对于支持fallocate系统调用的文件系统，这可以通过分配块并将其标记为未初始化来快速完成，因此不需要对数据块进行 I/O 操作。这是创建文件而不是用零填充的更快的方法。大文件几乎可以立即创建，而不必等待任何 I/O 操作完成。\n语法：\nfallocate [-n] [-o offset] -l length filename d: 检测零并替换为空洞。 -n：指定文件的大小，单位为字节。 -o：指定文件的偏移量，可以跟二进制$2^{N}$后缀KiB，MiB，GiB，TiB，PiB和EiB（iB为可选，例如，K的含义与KiB的含义相同或后缀KB，MB，GB，PB和EB的十进制（$10^{N}$）。 -l：指定文件的大小，单位同上。 -p, --punch-hole: 将某个范围替换为空洞 (连带打开 -n)。 filename：指定文件名。 示例： 分配一个大小为512MB的文件，文件名为efi.img：\nfallocate -l 512M efi.img 将efi.img文件中的0替换为空洞：\nfallocate -d efi.img 从偏移 128M 的位置挖一个 10M 大小的洞\nfallocate -p -o 128M -l 10M efi.img dd Linux dd 命令用于读取、转换并输出数据。dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出\ndd 的原意为 data duplicator，但由于 dd 属于较低阶的资料处理工具，通常都会以管理者（root）权限来执行，如果稍有不慎，也很容易造成严重的后果（例如整颗硬碟的资料不见等等），所以有些人也把 dd 取名为 data destroyer。dd 指令教学与实用范例，备份与回复资料的小工具 - GT Wang\nif=FILE : 指定输入文件，若不指定则从标注输入读取。这里指定为/dev/zero 是 Linux 的一个伪文件，它可以产生连续不断的 null 流（二进制的 0）。 of=FILE : 指定输出文件，若不指定则输出到标准输出。 bs=BYTES : 每次读写的字节数，可以使用单位 K、M、G 等等。另外输入输出可以分别用 ibs、obs 指定，若使用 bs，则表示是 ibs 和 obs 都是用该参数。 count=BLOCKS : 读取的 block 数，block 的大小由 ibs 指定。 示例： 生成一个1g大小的文件，内容全为0，块大小为1M，文件名为efi.img：\ndd if=/dev/zero of=efi.img bs=1M count=1024 生成一个1g大小的文件，内容为随机数，块大小为10M，文件名为efi.img：\ndd if=/dev/urandom of=efi.img bs=10M count=1024 truncate -s：指定文件的大小，可以跟二进制$2^{N}$后缀KiB，MiB，GiB，TiB，PiB和EiB（iB为可选，例如，K的含义与KiB的含义相同或后缀KB，MB，GB，PB和EB的十进制（$10^{N}$）。 示例： 生成一个 100M 大小的文件，文件名为efi.img：\ntruncate -s 100M efi.img 参考 Linux 文件空洞与稀疏文件\n","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6/","summary":"\u003ch2 id=\"使用背景\"\u003e使用背景\u003c/h2\u003e\n\u003cp\u003e在测试下载速度，或者测试加解密文件，亦或者制作文件系统时都需要一些指定大小的文件。Linux 有一些命令可以快速完成这样的任务。接下来介绍几个好用的命令。\u003c/p\u003e","title":"每天学命令-生成指定大小文件"},{"content":"SPI 概述 SPI 是一种同步的、全双工的、高速的串行通信总线。\n\u003c!DOCTYPE html\u003e Responsive Image 4 线制 SPI 四个信号：\nSCLK：串行时钟信号，由主设备产生，用于同步数据传输。 CS：片选信号，由主设备产生，用于选择从设备。 MOSI：主设备输出，从设备输入，用于主设备向从设备传输数据。 MISO：主设备输入，从设备输出，用于从设备向主设备传输数据。 除了四线式 SPI 总线之外，还有三线式 SPI 总线和双线式 SPI 总线。\n四线式 SPI 总线，也称为标准 SPI 总线，由 SCLK、MOSI、MISO 和 SS（Slave Select）四个信号线组成。其中，SCLK 是时钟信号线；MOSI 是主设备向从设备发送数据的信号线；MISO 是从设备向主设备发送数据的信号线；SS 是从设备的片选信号线，用于选择要通信的从设备。\n三线式 SPI 总线将 MOSI 和 MISO 合并为单一的信号线。这种 SPI 总线有一个专门的叫做 MOMI 的信号线，既可以作为主设备向从设备发送数据的信号线，又可以作为从设备向主设备发送数据的信号线。\n双线式 SPI 总线（也称为 MICROWIRE 或 uWire），由一个串行数据线和一个时钟线组成。在这种 SPI 总线上，没有单独的片选信号线，而是使用一个帧选择控制位来选择相应的从设备。\n他们传输速率有差别吗？ 是的，SPI 总线的不同类型之间存在传输速率上的差别。一般情况下，四线式 SPI 总线的传输速度最快，而双线式 SPI 总线的传输速度最慢。但具体的传输速度会受到很多因素的影响，例如工作频率、数据线长度等等。如果要在实际应用中选择合适的 SPI 总线类型，需要考虑诸如这些因素的影响，并根据具体情况进行权衡取舍。 SPI 总线的传输速度快慢与其信号线数量有关。双线式 SPI 总线一共只有两条信号线：一个主设备 (Master) 输出时钟信号 (SCLK)，一个主设备通过该信号线读取从设备 (Slave) 的应答信号。而四线式 SPI 总线除了上述两条信号线外，还有两条用于数据传输的信号线：主设备通过 MOSI 信号线向从设备发送数据，从设备则通过 MISO 信号线将数据返回给主设备。由于四线式 SPI 总线有专门的数据传输信号线，故可以通过同时在这两条信号线上传输数据来实现更高的传输速率，从而比双线式 SPI 总线快一些。\n时钟极性和时钟相位 在 SPI 中，主机可以选择时钟极性和时钟相位。在空闲状态期间，CPOL 位设置时钟信号的极性。空闲状态是指传输开始时 CS 为高电平且在向低电平转变的期间，以及传输结束时 CS 为低电平且在向高电平转变的期间。CPHA 位选择时钟相位。根据 CPHA 位的状态，使用时钟上升沿或下降沿来采样和/或移位数据。主机必须根据从机的要求选择时钟极性和时钟相位。根据 CPOL 和 CPHA 位的选择，有四种 SPI 模式可用。表 1 显示了这 4 种 SPI 模式。\nSPI 模式 CPOL(Serial Clock Polarity) CPHA(Serial Clock Phase) 空闲状态下的时钟极性 采样时的时钟相位 移位数据的时钟相位 0 0 0 逻辑低电平 上升沿 下降沿 1 0 1 逻辑低电平 下降沿 上升沿 2 1 1 高电平 下降沿 上升沿 3 1 0 高电平 上升沿 下降沿 CPOL 和 CPHA 可以通过 SPI 的状态寄存器设置。\n显示了四种 SPI 模式下的通信示例。在这些示例中，数据显示在 MOSI 和 MISO 线上。传输的开始和结束用绿色虚线表示，采样边沿用橙色虚线表示，移位边沿用蓝色虚线表示。\n\u003c!DOCTYPE html\u003e Responsive Image 下图给出了 SPI 模式 1 的时序图。在此模式下，时钟极性为 0，表示时钟信号的空闲状态为低电平。此模式下的时钟相位为 1，表示数据在下降沿采样（由橙色虚线显示），并且数据在时钟信号的上升沿移出（由蓝色虚线显示）。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 多从机配置 标准 SPI 模式 \u003c!DOCTYPE html\u003e Responsive Image 在常规模式下，主机需要为每个从机提供单独的片选信号。一旦主机使能（拉低）片选信号，MOSI/MISO 线上的时钟和数据便可用于所选的从机。如果使能多个片选信号，则 MISO 线上的数据会被破坏，因为主机无法识别哪个从机正在传输数据。\n从上图可以看出，随着从机数量的增加，来自主机的片选线的数量也增加。这会快速增加主机需要提供的输入和输出数量，并限制可以使用的从机数量。可以使用其他技术来增加常规模式下的从机数量，例如使用多路复用器产生片选信号。\n菊花链模式 \u003c!DOCTYPE html\u003e Responsive Image 在菊花链模式下，所有从机的片选信号连接在一起，数据从一个从机传播到下一个从机。在此配置中，所有从机同时接收同一 SPI 时钟。来自主机的数据直接送到第一个从机，该从机将数据提供给下一个从机，依此类推。\n使用该方法时，由于数据是从一个从机传播到下一个从机，所以传输数据所需的时钟周期数与菊花链中的从机位置成比例。为使第 3 个从机能够获得数据，需要 24 个时钟脉冲，而常规 SPI 模式下只需 8 个时钟脉冲。下图显示了时钟周期和通过菊花链的数据传播。并非所有 SPI 器件都支持菊花链模式。请参阅产品数据手册以确认菊花链是否可用。\n\u003c!DOCTYPE html\u003e Responsive Image SPI 实现 参考资料 SPI 接口简介 | 亚德诺半导体\nSPI 协议 - 杰哥的{运维，编程，调板子}小笔记\n","permalink":"https://lifeislife.cn/posts/spi%E5%8D%8F%E8%AE%AE/","summary":"\u003ch1 id=\"spi-概述\"\u003eSPI 概述\u003c/h1\u003e\n\u003cp\u003eSPI 是一种同步的、全双工的、高速的串行通信总线。\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/19-17-11-68acbe1aebbf2173bbc3401dffd69c5a-20230814191709-b01232.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/19-17-11-68acbe1aebbf2173bbc3401dffd69c5a-20230814191709-b01232.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e4 线制 SPI 四个信号：\u003c/p\u003e","title":"SPI 协议"},{"content":"为什么需要虚拟内存？ CPU 访问内存的最自然的方式就是使用物理地址，这种方式称为物理寻址。1，计算机中并不是只有一个程序在运行，如果它们都是用物理寻址的方式，那么所有程序必须在链接之前确定好自己所用到的内存范围，否则两个程序就可能会发生冲突。2，程序大于内存的问题早在上世纪六十年代就出现，后来出现了覆盖技术（Overlay），把程序分割成许多片段。程序开始执行时，将覆盖管理模块装入内存，该管理模块立即装入并运行覆盖 0。执行完成后，覆盖 0 通知管理模块装入覆盖 1，或者占用覆盖 0 的上方位置（如果有空间），或者占用覆盖 0（如果没有空间）。把一个大程序分割成小的、模块化的片段是非常费时和枯燥的，并且易于出错。很少程序员擅长使用覆盖技术。\n为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。主要有三个功能：\n它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 它为每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的地址空间不被其他进程破坏。 什么是虚拟寻址？ 如果主存被分为长度为$M$的单字节大小的数组，每个字节都对应一个物理地址，CPU 通过这个唯一的地址访问主存，这样的方式就是物理寻址。 \u003c!DOCTYPE html\u003e Responsive Image 现代处理器使用虚拟寻址的方式。CPU 通过生成的虚拟地址来访问内存，这个地址在送到内存之前会被转换成物理地址。这个过程称为地址翻译。CPU 芯片上叫做内存管理单元（Memory Management Unit, MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。 \u003c!DOCTYPE html\u003e Responsive Image 虚拟内存作为缓存的工具 概念上而言，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。磁盘上活动的数组内容被缓存在主存中。在存储器结构中，较低层次上的磁盘的数据被分割成块，这些块作为和较高层次的主存之间的传输单元。主存作为虚拟内存的缓存。\n虚拟内存被分割为大小固定的块，这些块叫虚拟页（Virtual Page，VP），类似的物理内存也有物理页(Physical Page, PP)。虚拟页有三种不同的状态：\n未分配：VM 系统还未分配 (或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。 已缓存：当前已缓存在物理内存中的已分配页。 未缓存：未缓存在物理内存中的已分配页。 为了有助于清晰理解存储层次结构中不同的缓存概念，我们将使用术语SRAM缓存来表示位于 CPU 和主存之间的 Ll、L2 和 L3 高速缓存，并且用术语 DRAM 缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页。\n在存储层次结构中，DRAM 缓存的位置对它的组织结构有很大的影响。回想一下，DRAM 比 SRAM 要慢大约 10 倍，而磁盘要比 DRAM 慢大约 100000 多倍。因此，DRAM 缓存中的不命中比起 SRAM 缓存中的不命中要昂贵得多。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。（这些替换算法超出了我们的讨论范围）。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回，而不是直写。\n页表 虚拟内存系统可以完成以下这些功能，\n判定一个虚拟页是否缓存在 DRAM 中的某个地方； 可以确定这个虚拟页存放在哪个物理页中； 如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。 这些功能是由软硬件联合提供的，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表（page table）的数据结构。页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。\n图 9-4 展示了一个页表的基本组织结构。页表就是一个页表条目（Page Table Entry，PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。\nPTE 由两部分组成：\n有效位：表明了该虚拟页当前是否被缓存在 DRAM 中； 地址：表示 DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。 \u003c!DOCTYPE html\u003e Responsive Image 页命中与缺页 \u003c!DOCTYPE html\u003e Responsive Image l\n当 CPU 访问已被缓存的地址时，就叫做页命中。如访问上图 VP2，虚拟地址索引到 PTE2，此时有效位为 1，地址翻译硬件就知道该地址被缓存了。\n当 CPU 访问未被缓存的地址时，会导致缺页。如访问上图的 VP3，虚拟地址索引到 PTE3，此时有效位为 0，地址翻译硬件就知道该地址未被缓存，需要从磁盘中读取。\n这时会触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在 PP 3 中的 VP 4。如果 VP 4 已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改 VP 4 的页表条目，反映出 VP 4 不再缓存在主存中这一事实。\n接下来，内核从磁盘复制 VP 3 到内存中的 PP 3，更新 PTE 3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP 3 已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图 9-7 展示了在缺页之后我们的示例页表的状态。\n\u003c!DOCTYPE html\u003e Responsive Image 在虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做交换（swapping）或者页面调度（paging）。页从磁盘换入（或者页面调入）DRAM 和从 DRAM 换出（或者页面调出）磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度（demand paging）。\n虚拟内存作为内存管理的工具 之前我们只讨论了一个页表的情况，但是实际上操作系统为每个进程都分配了一个独立的页表。多个虚拟页面可以映射到同一个共享物理页面上。\n\u003c!DOCTYPE html\u003e Responsive Image 按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。特别地，VM 简化了链接和加载、代码和数据共享，以及应用程序的内存分配。\n简化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。例如，一个给定的 Linux 系统上的每个进程都使用类似的内存格式。对于 64 位地址空间，代码段总是从虚拟地址 0x400000 开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。 简化加载。虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中 .text 和 .data 节加载到一个新创建的进程中，Linux 加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。有趣的是，加载器从不从磁盘到内存实际复制任何数据。在每个页初次被引用时，要么是 CPU 取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作内存映射（memory mapping）。Linux 提供一个称为 mmap 的系统调用，允许应用程序自己做内存映射。 简化共享。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。 简化内存分配。虚拟内存为向用户进程提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如调用 malloc 的结果），操作系统分配一个适当数字（例如 k）个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的 k 个任意的物理页面。由于页表工作的方式，操作系统没有必要分配 k 个连续的物理内存页面。页面可以随机地分散在物理内存中。 虚拟内存作为内存保护的工具 操作系统中的用户程序不应该修改只读的代码段，也不应该读取或者修改内核中的代码和数据结构或者访问私有的以及其他的进程的内存，如果无法对用户进程的内存访问进行限制，攻击者就可以访问和修改其他进程的内存影响系统的安全。\n\u003c!DOCTYPE html\u003e Responsive Image 通过在页表中添加页面的保护属性，可以让操作系统在页面被访问时进行检查，如果页面被保护为只读，则操作系统会报错。\n在图 9-10 这个示例中，每个 PTE 中已经添加了三个许可位。SUP 位表示进程是否必须运行在内核（超级用户）模式下才能访问该页。运行在内核模式中的进程可以访问任何页面，但是运行在用户模式中的进程只允许访问那些 SUP 为 0 的页面。READ 位和 WRITE 位控制对页面的读和写访问。例如，如果进程 i 运行在用户模式下，那么它有读 VP 0 和读写 VP 1 的权限。然而，不允许它访问 VP 2。\n如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell 一般将这种异常报告为段错误（segmentation fault）。\n地址翻译 基本参数\n符号 描述 $$\\small N=2^n$$ 虚拟地址空间中的地址数量 $$\\small M=2^m$$ 物理地址空间中的地址数量 $$\\small P=2^p$$ 页的大小（字节） 虚拟地址（VA）的组成部分\n符号 描述 VPO 虚拟页面偏移量（字节） VPN 虚拟页号 TLBI TLB 索引 TLBT TLB 标记 物理地址（PA）的组成部分\n符号 描述 PPO 物理页面偏移量（字节） PPN 物理页号 CO 缓冲块内的字节偏移量 CI 高速缓存索引 CT 高速缓存标记 \u003c!DOCTYPE html\u003e Responsive Image 图 9-12 展示了 MMU 如何利用页表来实现地址翻译。CPU 中的一个控制寄存器，页表基址寄存器（Page Table Base Register，PTBR）指向当前页表。$n$ 位的虚拟地址包含两个部分：一个 $p$ 位的虚拟页面偏移（Virtual Page Offset，VPO）和一个$\\small (n-p)$位的虚拟页号（Virtual Page Number，VPN）。MMU 利用 VPN 来选择适当的 PTE。例如，VPN 0 选择 PTE 0，VPN 1 选择 PTE 1，以此类推。将页表条目中物理页号（Physical Page Number，PPN）和虚拟地址中的 VP。串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是 P 字节的，所以物理页面偏移（Physical Page Offset，PPO）和 VPO 是相同的。\n\u003c!DOCTYPE html\u003e Responsive Image 图 9-13a 展示了当页面命中时，CPU 硬件执行的步骤。\n第 1 步：处理器生成一个 虚拟地址，并把它传送给 MMU。 第 2 步：MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。 第 3 步：高速缓存/主存向 MMU 返回 PTE。 第 4 步：MMU 构造物理地址，并把它传送给高速缓存/主存。 第 5 步：高速缓存/主存返回所请求的数据字给处理器。 页面命中完全是由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成，如图 9-13b 所示。\n第 1 - 3 步：和图 9-13a 中的第 1 步到第 3 步相同。 第 4 步：PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。 第 5 步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。 第 6 步：缺页处理程序页面调入新的页面，并更新内存中的 PTE。 第 7 步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给 MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，在 MMU 执行了图 9-13b 中的步骤之后，主存就会将所请求字返回给处理器。 利用 TLB 加速地址翻译 每次 CPU 访问一个虚拟地址，MMU 就必须查找 PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。如果 PTE 碰巧缓存在 L1 中，那么开销就下降到 1 个或 2 个周期。为了消除这样的开销，在 MMU 中包括了一个关于 PTE 的小的缓存，称为翻译后备缓冲器（Translation Lookaside Buffer，TLB）。\nTLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块。TLB 通常有高度的相联度。如图 9-15 所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果 TLB 有$\\small T = 2^t$个组，那么 TLB 索引（TLBI）是由 VPN 的 $t$ 个最低位组成的，而 TLB 标记（TLBT）是由 VPN 中剩余的位组成的。\n\u003c!DOCTYPE html\u003e Responsive Image 图 9-16a 展示了当 TLB 命中时（通常情况）所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的 MMU 中执行的，因此非常快。\n第 1 步：CPU 产生一个虚拟地址。 第 2 - 3 步：MMU 从 TLB 中取出相应的 PTE。 第 4 步：MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。 第 5 步：高速缓存/主存将所请求的数据字返回给 CPU。 \u003c!DOCTYPE html\u003e Responsive Image 当 TLB 不命中时，MMU 必须从 L1 缓存中取出相应的 PTE，如图 9-16b 所示。新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。\n多级页表 32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了。\n页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。\n那怎么办呢？我们可以试着将页表再分页，4G 的空间需要 4M 的页表来存储映射。我们把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K。\n页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置。\n这样加起来正好 32 位，也就是用前 10 位定位到页目录表中的一项。将这一项对应的页表取出来共 1k 项，再用中间 10 位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后 12 位定位到页中的具体位置访问数据。\n\u003c!DOCTYPE html\u003e Responsive Image 你可能会问，如果这样的话，映射 4GB 地址空间就需要 4MB+4KB 的内存，这样不是更大 了吗？当然如果页是满的，当时是更大了，但是，我们往往不会为一个进程分配那么多内 存。 比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完 整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省多了\n当然对于 64 位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间 页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。也就是一级页表，二级页表，三级页表，四级页表。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","summary":"\u003ch2 id=\"为什么需要虚拟内存\"\u003e为什么需要虚拟内存？\u003c/h2\u003e\n\u003cp\u003eCPU 访问内存的最自然的方式就是使用物理地址，这种方式称为\u003cstrong\u003e物理寻址\u003c/strong\u003e。1，计算机中并不是只有一个程序在运行，如果它们都是用物理寻址的方式，那么所有程序必须在链接之前确定好自己所用到的内存范围，否则两个程序就可能会发生冲突。2，程序大于内存的问题早在上世纪六十年代就出现，后来出现了\u003cstrong\u003e覆盖技术\u003c/strong\u003e（Overlay），把程序分割成许多片段。程序开始执行时，将覆盖管理模块装入内存，该管理模块立即装入并运行覆盖 0。执行完成后，覆盖 0 通知管理模块装入覆盖 1，或者占用覆盖 0 的上方位置（如果有空间），或者占用覆盖 0（如果没有空间）。把一个大程序分割成小的、模块化的片段是非常费时和枯燥的，并且易于出错。很少程序员擅长使用覆盖技术。\u003c/p\u003e","title":"理解虚拟内存"},{"content":"在做CSAPP_LAB-Cache Lab时，实验要求对输入参数进行处理，如程序csim执行需要 4 个参数：\n./csim -s 4 -E 6 -b 4 -t \u0026lt;tracefile\u0026gt; 原先想通过字符串解析，一个个处理，但是看到了其他参考代码后发现了一个更简单的方法，可以通过getopt()函数来解析参数。\n函数的功能：解析命令行参数。 头文件 #include \u0026lt;unistd.h\u0026gt;\n在学习函数前需要了解与该函数相关的四个变量：\nint opterr：控制是否输出错误； 如果此变量的值非零，则 getopt 在遇到未知选项字符或缺少必需参数的选项时将错误消息打印到标准错误流 (终端)。该值默认为非零。如果将此变量设置为零，getopt 不会打印任何消息，但仍会返回问号?提示错误。\nint optopt：保存未知的选项； 当 getopt 遇到未知选项字符或缺少必需参数的选项时，它将该选项字符存储在此变量中。\nint optind：指向下一个要处理的参数； 此变量由 getopt 设置为要处理的 argv 数组的下一个元素的索引。一旦 getopt 找到所有选项参数，就可以使用此变量来确定其余非选项参数的开始位置。该变量的初始值为 1。\nchar * optarg：保存选项参数； 对于那些接受参数的选项，此变量由 getopt 设置为指向选项参数的值。\n函数原型：\nint getopt(int argc, char * const argv[], const char * options); 参数解析：\n参数argc 和argv 是由main()传递的参数个数和内容。 options 参数是一个字符串，它指定对该程序有效的选项字符。此字符串中的选项字符后面可以跟一个冒号（:），表示它需要一个必需的参数，这个参数可以与选项连写也可以空格分开，如-a13 or -a 13。如果选项字符后跟两个冒号（::），则其参数是可选的，如果有参数，那么参数不能与选项分割，如只能写成-a13而不能写成-a 13；这是一个 GNU 扩展。 实例：\n下面是一个示例，展示了通常如何使用 getopt。需要注意的关键点是：\n通常，getopt 在循环中被调用。当 getopt 返回 -1 表示没有更多选项存在时，循环终止。 switch 语句用于调度 getopt 的返回值。在典型使用中，每种情况只设置一个稍后在程序中使用的变量。 第二个循环用于处理剩余的非选项参数。 #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main (int argc, char **argv) { int aflag = 0; int bflag = 0; char *cvalue = NULL; int index; int c; opterr = 0; while ((c = getopt (argc, argv, \u0026#34;abc:\u0026#34;)) != -1) switch (c) { case \u0026#39;a\u0026#39;: aflag = 1; break; case \u0026#39;b\u0026#39;: bflag = 1; break; case \u0026#39;c\u0026#39;: cvalue = optarg; break; case \u0026#39;?\u0026#39;: if (optopt == \u0026#39;c\u0026#39;) fprintf (stderr, \u0026#34;Option -%c requires an argument.\\n\u0026#34;, optopt); else if (isprint (optopt)) fprintf (stderr, \u0026#34;Unknown option `-%c\u0026#39;.\\n\u0026#34;, optopt); else fprintf (stderr, \u0026#34;Unknown option character `\\\\x%x\u0026#39;.\\n\u0026#34;, optopt); return 1; default: abort (); } printf (\u0026#34;aflag = %d, bflag = %d, cvalue = %s\\n\u0026#34;, aflag, bflag, cvalue); for (index = optind; index \u0026lt; argc; index++) printf (\u0026#34;Non-option argument %s\\n\u0026#34;, argv[index]); return 0; } 以下是一些示例，展示了该程序使用不同的参数组合打印的内容：\n% testopt aflag = 0, bflag = 0, cvalue = (null) // 选项可以用空格分割 % testopt -a -b aflag = 1, bflag = 1, cvalue = (null) // 也可以连写 % testopt -ab aflag = 1, bflag = 1, cvalue = (null) // 必选参数，可以用空格分割 % testopt -c foo aflag = 0, bflag = 0, cvalue = foo // 必选参数，可以连写 % testopt -cfoo aflag = 0, bflag = 0, cvalue = foo // 没有对应的选项 % testopt arg1 aflag = 0, bflag = 0, cvalue = (null) Non-option argument arg1 // -a选项没有需要处理的参数，所以arg1无法处理 % testopt -a arg1 aflag = 1, bflag = 0, cvalue = (null) Non-option argument arg1 % testopt -c foo arg1 aflag = 0, bflag = 0, cvalue = foo Non-option argument arg1 % testopt -a -- -b aflag = 1, bflag = 0, cvalue = (null) Non-option argument -b % testopt -a - aflag = 1, bflag = 0, cvalue = (null) Non-option argument - 参考资料 原来命令行参数处理可以这么写-getopt？_huangxiaohu_coder 的博客-CSDN 博客 Linux 下 getopt() 函数的简单使用 - 青儿哥哥 - 博客园 Using Getopt (The GNU C Library)\n","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80getopt-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"\u003cp\u003e在做\u003ca href=\"https://dunky-z.github.io/2022/07/11/CSAPP-LAB-Cache-Lab/\"\u003eCSAPP_LAB-Cache Lab\u003c/a\u003e时，实验要求对输入参数进行处理，如程序\u003ccode\u003ecsim\u003c/code\u003e执行需要 4 个参数：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./csim -s \u003cspan class=\"m\"\u003e4\u003c/span\u003e -E \u003cspan class=\"m\"\u003e6\u003c/span\u003e -b \u003cspan class=\"m\"\u003e4\u003c/span\u003e -t \u0026lt;tracefile\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e原先想通过字符串解析，一个个处理，但是看到了其他参考代码后发现了一个更简单的方法，可以通过\u003ccode\u003egetopt()\u003c/code\u003e函数来解析参数。\u003c/p\u003e","title":"C 语言 getopt() 函数的用法"},{"content":"保留现场 Windows 环境下，使用 VSCode 的终端时，中文显示为乱码，如使用git status命令查看修改文件时，中文文件名就无法正常显示： \u003c!DOCTYPE html\u003e Responsive Image 探究原因 因为终端被替换成了 git bash，它对所有非英文的字符进行了转义。\n官方文档提到：\n输出路径的命令（例如ls-files、diff）将通过将路径名括在双引号中并以与 C 转义控制字符相同的方式用反斜杠转义这些字符来引用路径名中的异常字符（例如\\t用于 TAB, \\n 表示LF，\\\\表示反斜杠）或值大于 0x80 的字节（例如，八进制 \\302\\265 表示 UTF-8 中的“micro”）。如果此变量设置为 false，则高于 0x80 的字节不再被视为异常。无论此变量的设置如何，双引号、反斜杠和控制字符总是被转义。一个简单的空格字符不被认为是异常的。许多命令可以使用 -z 选项完全逐字输出路径名。默认值是 true。\n解决方法 命令行输入，取消转义：\ngit config --global core.quotepath false ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3vs-code%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8git-bash%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003eWindows 环境下，使用 VSCode 的终端时，中文显示为乱码，如使用\u003ccode\u003egit status\u003c/code\u003e命令查看修改文件时，中文文件名就无法正常显示：\n\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207162158602.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207162158602.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"解决 VS Code 终端使用 git bash 时中文乱码"},{"content":"技术背景 转载自^[片上网络（NoC）技术的背景、意义以及发展_碎碎思的博客-CSDN 博客]\n在过去的几十年里，集成电路制造工艺技术、封装与测试技术、设计方法学和 EDA 工具等微电子相关技术始终保持着快速的发展。根据国际半导体技术发展路线图（International Technology Roadmap for Semiconductors, ITRS）预测，到 2024 年 IC 制造技术将达到 2 nm。但是，全局互连线的性能提升程度明显低于晶体管性能提升程度。受到亚阈值漏电流功耗、动态功耗、器件可靠性以及全局互连线等影响，通过提升单个处理器核的性能来提升系统整体性能已变得非常难以实现，同时芯片设计的难度和复杂度也在进一步增加。片上系统（System on Chip, SoC）具有集成度高、功耗低、成本低、体积小等优点，已经成为超大规模集成电路系统设计的主流方向。随着片上系统 SoC 的应用需求越来越丰富、越来越复杂，片上多核 MPSoC (MultiprocessorSystem on Chip, MPSoC) 已经成为发展的必然趋势，同时 MPSoC 上集成的 IP 核数量也将会按照摩尔定律继续发展。目前，MPSoC 已经逐渐应用于网络通信、多媒体等嵌入式电子设备中。半导体工艺技术的快速发展为集成电路设计提供了很大的发展空间，同时也带来了一系列新的问题和挑战，如芯片的性能、功耗、可靠性、可扩展性等等。\n随着系统性能需求越来越高，处理器核之间的互连架构必须能够提供具有较低延迟和高吞吐率的服务，并且具有良好的可扩展性。传统的基于总线的集中式互连架构已经难以满足现今系统的性能需求，而基于报文交换的**片上网络（Network on Chip, NoC）**逐渐成为片上多核间通讯的首选互连架构。在 NoC 中，路由节点之间通过局部互连线相连接，每一个路由节点通过网络接口 NI 与一个本地 IP 核相连接，源路由节点和目的路由节点之间的数据通讯需要经过多个跳步来实现。因此，NoC 技术的出现使得片上系统 SoC 的设计也将从以计算为中心逐渐过渡到以通讯为中心。\n传统的 SoC 系统采用总线互连结构，如 所示。虽然人们已经提出了很多改进的总线结构，例如将共享总线改进为桥接多总线结构、层次化总线结构等更复杂的结构。但是当进入 MPSoC 时代，单芯片上集成的处理器核数越来越多时，总线结构在通讯性能、功耗、全局时钟同步、信号完整性以及信号可靠性等方面面临着巨大的挑战，这些复杂的改进型总线结构仍无法解决片上多核间通信所面临的问题。因此，MPSoC 上多核间的通讯问题已经成为制约系统性能提升的主要瓶颈。\n\u003c!DOCTYPE html\u003e Responsive Image NoC 的概念是由 Agarwal（1999 年）、Guerrier 和 Greiner（2000 年）、Dally 和 Towles（2001 年）、Benini 和 Micheli（2002 年）、Jantsch 和 Tenhunen（2003 年）等人逐步提出的。目前，对于 NoC 还没有一个统一的定义，大多数 NoC 研究者认为 NoC 是 SoC 系统的通讯子集，并且应该引入互联网络技术来解决片上多核的通讯问题。\nNoC 的意义 转载自^[片上网络（NoC）技术的背景、意义以及发展_碎碎思的博客-CSDN 博客]\n随着单芯片上集成的处理器核数越来越多，片上互连架构经历了从专用互连线，Bus，Crossbar 到 NoC。NoC 借鉴了分布式计算系统的通讯方式，采用数据路由和分组交换技术替代传统的总线结构，从体系结构上解决了 SoC 总线结构由于地址空间有限导致的可扩展性差，分时通讯引起的通讯效率低下，以及全局时钟同步引起的功耗和面积等问题。与传统的总线互连技术相比，片上网络具有如下优点：\n第一，网络带宽。总线结构互连多个 IP 核，共享一条数据总线，其缺点是同一时间只能有一对 IP 进行通信。随着系统规模的逐渐增大，总线结构的通信效率必然成为限制系统性能提升的瓶颈。片上网络具有非常丰富的信道资源，为系统提供了一个网络化的通信平台。网络中的多个节点可以同时利用网络中的不同物理链路进行信息交换，支持多个 IP 核并发地进行数据通信。随着网络规模的增大，网络上的信道资源也相应增多。因此，NoC 技术相对于 Bus 互连技术具有较高的带宽，以及更高的通信效率。当并发进行数据通信时网络会产生竞争，即会存在请求同一条物理链路的节点对。NoC 的路由节点通过分时复用物理链路来解决竞争，与 Bus 结构相比，NoC 能够降低竞争发生的概率。\n第二，可扩展性和设计成本。总线结构需要针对不同的系统需求单独进行设计，当系统功能扩展时，需要对现有的设计方案重新设计，从而严重影响设计的周期和资本投入。**NoC 中每个路由节点和本地 IP 核通过网络接口（NetworkInterface, NI）相连，当系统需要升级扩展新功能时，只需要将新增加的处理器核通过网络接口 NI 接入到网络中的路由节点即可，无需重新设计网络。**因此，片上网络具有良好的可扩展性。片上网络作为一个独立的片上互连结构，能够满足不同系统的应用需求，当网络中节点数量增加时，仅需要按照相应的拓扑结构规则继续增大网络的规模即可，缩短了产品的设计周期，节约了设计成本。\n第三，功耗。随着 SoC 规模的不断增大，总线上每次信息交互都需要驱动全局互连线，因此总线结构所消耗的功耗将显著增加，并且随着集成电路工艺的不断发展，想要保证全局时钟同步也将变得难以实现。而在 NoC 中，信息交互消耗的功耗与进行通讯的路由节点之间的距离密切相关，距离较近的两个节点进行通讯时消耗的功耗就比较低。\n第四，信号完整性和信号延迟。随着集成电路特征尺寸的不断减小，电路规模的不断增大，互连线的宽度和间距也在不断地减小，线间耦合电容相应增大，长的全局并行总线会引起较大的串扰噪声，从而影响信号的完整性以及信号传输的正确性。同时，互连线上的延迟将成为影响信号延迟的主要因素，总线结构全局互连线上的延迟将大于一个时钟周期，从而使得时钟的偏移很难管理。\n第五，全局同步。总线结构采用全局同步时钟，随着芯片集成度的提高，芯片的工作频率也在不断提高，在芯片内会形成很庞大的时钟树，因此很难实现片上各个模块的全局同步时钟。采用时钟树（Clock Tree）优化的方法可以改善由时钟翻转引起的时钟偏差和时钟抖动，但同步时钟网络所产生的动态功耗甚至可达总功耗的 40% 以上。为了提高系统的时钟频率，只能对全局互连线采用分布式流水线结构，或者采用全局异步局部同步（Global Asynchronous Local Synchronous,GALS）的时钟策略。\n","permalink":"https://lifeislife.cn/posts/noc-net-on-chip-%E6%80%BB%E7%BA%BF%E4%BA%92%E8%81%94%E6%9E%84%E6%9E%B6/","summary":"\u003ch2 id=\"技术背景\"\u003e技术背景\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e转载自^[\u003ca href=\"https://blog.csdn.net/pieces_thinking/article/details/77938041\"\u003e片上网络（NoC）技术的背景、意义以及发展_碎碎思的博客-CSDN 博客\u003c/a\u003e]\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在过去的几十年里，集成电路制造工艺技术、封装与测试技术、设计方法学和 EDA 工具等微电子相关技术始终保持着快速的发展。根据\u003ca href=\"https://zh.wikipedia.org/zh-sg/%E5%9B%BD%E9%99%85%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE\"\u003e国际半导体技术发展路线图\u003c/a\u003e（International Technology Roadmap for Semiconductors, ITRS）预测，到 2024 年 IC 制造技术将达到 2 nm。但是，全局互连线的性能提升程度明显低于晶体管性能提升程度。受到亚阈值漏电流功耗、动态功耗、器件可靠性以及全局互连线等影响，\u003cstrong\u003e通过提升单个处理器核的性能来提升系统整体性能已变得非常难以实现\u003c/strong\u003e，同时芯片设计的难度和复杂度也在进一步增加。片上系统（System on Chip, SoC）具有集成度高、功耗低、成本低、体积小等优点，已经成为超大规模集成电路系统设计的主流方向。随着片上系统 SoC 的应用需求越来越丰富、越来越复杂，片上多核 MPSoC (MultiprocessorSystem on Chip, MPSoC) 已经成为发展的必然趋势，同时 MPSoC 上集成的 IP 核数量也将会按照摩尔定律继续发展。目前，MPSoC 已经逐渐应用于网络通信、多媒体等嵌入式电子设备中。半导体工艺技术的快速发展为集成电路设计提供了很大的发展空间，同时也带来了一系列新的问题和挑战，如芯片的性能、功耗、可靠性、可扩展性等等。\u003c/p\u003e","title":"NOC(net-on-chip) 总线互联构架"},{"content":" 参考自PoC : How to build and test ACPI enabled kernel · riscv-non-isa/riscv-acpi Wiki\n准备环境及工具链 安装 RISC-V 工具链，需下载原发行版。好在 apt 可以安装。\n如果报错：riscv64-linux-gnu-gcc: error: unrecognized command line option ‘-mno-relax’; did you mean ‘-Wno-vla’?，多半是工具链原因，请按照以下方法安装！！！\nsudo apt remove gcc-riscv64-linux-gnu sudo apt install gcc-8-riscv64-linux-gnu 安装必要的三方库，以下为Ubuntu下的命令，其他平台可以参考这个文档。\nsudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \\ gawk build-essential bison flex texinfo gperf libtool patchutils bc \\ zlib1g-dev libexpat-dev git 下载源码 可能无法一次搭建成功，一些环境变量会经常用到，所以干脆把所有环境变量放到.bashrc。\nvim ~/.bashrc # 添加以下内容 export WORK_DIR=~/riscv64-acpi export GCC5_RISCV64_PREFIX=riscv64-unknown-elf- export MAINSPACE=~/riscv64-acpi/tianocore export PACKAGES_PATH=$MAINSPACE/edk2:$MAINSPACE/edk2-platforms export EDK_TOOLS_PATH=$MAINSPACE/edk2/BaseTools 首先，创建一个工作目录，我们将在其中下载并构建所有源代码。\nsource ~/.bashrc WORK_DIR=$PWD/riscv64-acpi mkdir -p $WORK_DIR cd $WORK_DIR 然后下载所有需要的源，它们是：qemu、opensbi、edk2、edk2-platforms、linux。\n下载地址更换成了加速镜像源，原来地址下载太慢，容易中断。下载地址更换成了加速镜像源，原来地址下载太慢，容易中断。有两个项目包含子模块，下载容易出错，所以--depth=1舍弃了多余的提交记录。\ngit clone --branch dev-upstream https://hub.fastgit.xyz/ventanamicro/qemu.git qemu git clone --branch dev-upstream https://hub.fastgit.xyz/ventanamicro/opensbi.git opensbi git clone --branch dev-upstream --recurse-submodules --depth=1 https://hub.fastgit.xyz/ventanamicro/edk2.git tianocore/edk2 git clone --branch dev-upstream --recurse-submodules --depth=1 https://hub.fastgit.xyz/ventanamicro/edk2-platforms.git tianocore/edk2-platforms git clone --branch dev-upstream https://hub.fastgit.xyz/ventanamicro/linux.git linux 编译构建 QEMU cd $WORK_DIR/qemu ./configure --target-list=riscv64-softmmu make -j $(nproc) OPENSBI 此处我们使用以riscv64-unknown-elf-为前缀的版本，则表示该版本GCC工具链会使用newlib作为C运行库。原文使用riscv64-linux-gnu-，表示GCC工具链会使用Linux的Glibc作为C运行库。但是本人未编译成功。故后面编译工具均使用riscv64-unknown-elf-，与原文不同。\ncd $WORK_DIR/opensbi make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- make PLATFORM=generic EDK2 固件 此处原文里设置了一些环境变量在开头我们设置了，请不要重新设置，尤其不能export WORKSPACE=pwd，因为与源码脚本的WORKSPACE冲突。\ncd $WORK_DIR/tianocore source edk2/edksetup.sh make -C edk2/BaseTools clean make -C edk2/BaseTools make -C edk2/BaseTools/Source/C source edk2/edksetup.sh BaseTools # 原文使用 -buildtarget RELEASE。但是提示 Not supported target RELEASE build -a RISCV64 -b DEBUG -D FW_BASE_ADDRESS=0x80200000 -D EDK2_PAYLOAD_OFFSET -p Platform/Qemu/RiscvVirt/RiscvVirt.dsc -t GCC5 ERROR StoreCurrentConfiguration:7: no such file or directory: /home/user/riscv64-acpi/tianocore/Conf/BuildEnv.sh\n不要设置export WORKSPACE=pwd！！！如果所有方法都不可行，直接把路径写死export CONF_PATH=$WORK_DIR/tianocore/edk2/Conf\nuuid/uuid.h: No such file or directory\nsudo apt install uuid-dev Not supported target RELEASE\n# 将build命令改为如下，使用DEBUG版本。 build -a RISCV64 -b DEBUG -D FW_BASE_ADDRESS=0x80200000 -D EDK2_PAYLOAD_OFFSET -p Platform/Qemu/RiscvVirt/RiscvVirt.dsc -t GCC5 Linux cd $WORK_DIR/linux make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- defconfig make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- -j $(nproc) Rootfs 您可以使用您选择的任何 rootfs。此示例使用 buildroot。\n此步耗时较久，与网络环境有关，如果网络不好可能按小时算。容易中断，需要重新下载。\ncd $WORK_DIR/ git clone https://hub.fastgit.xyz/buildroot/buildroot.git cd $WORK_DIR/buildroot make qemu_riscv64_virt_defconfig make rootfs-cpio 创建 EFI 分区并复制文件 fallocate -l 512M efi.img sgdisk -n 1:34: -t 1:EF00 $WORK_DIR/efi.img sudo losetup -fP $WORK_DIR/efi.img loopdev=`losetup -j $WORK_DIR/efi.img | awk -F: \u0026#39;{print $1}\u0026#39;` efi_part=\u0026#34;$loopdev\u0026#34;p1 sudo mkfs.msdos $efi_part mkdir -p /tmp/mnt sudo mount $efi_part /tmp/mnt/ sudo cp $WORK_DIR/linux/arch/riscv/boot/Image /tmp/mnt/ sudo umount /tmp/mnt sudo losetup -D $loopdev 运行 使用 virtio-blk 磁盘 原文参数-drive file=$WORK_DIR/buildroot/output/images/rootfs.ext2,format=raw,id=hd0需要更改如下。因为在编译 Rootfs 时的命令是make rootfs-cpio所以生成的是rootfs.cpio。无法找到rootfs.ext2\n$WORK_DIR/qemu/build/qemu-system-riscv64 -nographic \\ -machine virt,aclint=on,aia=aplic-imsic,acpi=on -cpu rv64,sscofpmf=true -smp 8 -m 2G \\ -bios $WORK_DIR/opensbi/build/platform/generic/firmware/fw_jump.elf \\ -kernel $WORK_DIR/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd \\ -drive file=$WORK_DIR/buildroot/output/images/rootfs.cpio,format=raw,id=hd0 \\ -device virtio-blk-device,drive=hd0 \\ -drive file=$WORK_DIR/efi.img,format=raw,id=hd1 \\ -device virtio-blk-device,drive=hd1 \\ -device virtio-net-device,netdev=usernet \\ -netdev user,id=usernet,hostfwd=tcp::9990-:22 ERROR 无法找到rootfs.ext2\n# 因为在编译 Rootfs 时的命令是 make rootfs-cpio 所以生成的是 rootfs.cpio # 原文参数 -drive file=$WORK_DIR/buildroot/output/images/rootfs.ext2,format=raw,id=hd0 \\ # 修改为 -drive file=$WORK_DIR/buildroot/output/images/rootfs.cpio,format=raw,id=hd0 \\ 无法找到RISCVVIRT.fd\n# 因为编译 EDK2 固件时，参数是-b DEBUG 版本，原文是 RELEASE 版本，这两个版本路径不一样，所以找不到 # 原文参数 -kernel $WORK_DIR/tianocore/Build/RiscvVirt/RELEASE_GCC5/FV/RISCVVIRT.fd \\ # 修改为 -kernel $WORK_DIR/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd \\ At EFI Shell:\nShell\u0026gt; fs0:\\Image root=/dev/vdb console=ttyS0 rootwait earlycon \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 使用 virtio-scsi 磁盘 $WORK_DIR/qemu/build/qemu-system-riscv64 -nographic \\ -machine virt,aclint=on,aia=aplic-imsic,acpi=on -cpu rv64,ssofpmf=true -smp 8 -m 2G \\ -bios $WORK_DIR/opensbi/build/platform/generic/firmware/fw_jump.elf \\ -kernel $WORK_DIR/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd \\ -device virtio-scsi-pci,id=scsi0,num_queues=4 \\ -device scsi-hd,drive=drive0,bus=scsi0.0,channel=0,scsi-id=0,lun=0 \\ -drive file=$WORK_DIR/buildroot/output/images/rootfs.cpio,format=raw,if=none,id=drive0 \\ -device virtio-scsi-pci,id=scsi1,num_queues=4 \\ -device scsi-hd,drive=drive1,bus=scsi0.0,channel=0,scsi-id=1,lun=0 \\ -drive file=$WORK_DIR/efi.img,format=raw,if=none,id=drive1 \\ -device virtio-net-device,netdev=usernet \\ -netdev user,id=usernet,hostfwd=tcp::9990-:22 At EFI Shell:\nShell\u0026gt; fs0:\\Image root=/dev/sda console=ttyS0 rootwait earlycon ","permalink":"https://lifeislife.cn/posts/%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95risc-v%E6%9E%B6%E6%9E%84%E4%B8%8B%E5%90%AF%E7%94%A8acpi%E7%9A%84%E5%86%85%E6%A0%B8/","summary":"\u003cblockquote\u003e\n\u003cp\u003e参考自\u003ca href=\"https://github.com/riscv-non-isa/riscv-acpi/wiki/PoC-:-How-to-build-and-test-ACPI-enabled-kernel\"\u003ePoC : How to build and test ACPI enabled kernel · riscv-non-isa/riscv-acpi Wiki\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"准备环境及工具链\"\u003e准备环境及工具链\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e安装 RISC-V 工具链，需下载原发行版。好在 apt 可以安装。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果报错：riscv64-linux-gnu-gcc: error: unrecognized command line option ‘-mno-relax’; did you mean ‘-Wno-vla’?，多半是工具链原因，请按照以下方法安装！！！\u003c/p\u003e","title":"构建和测试 RISC-V 架构下启用 ACPI 的内核"},{"content":"预备知识 开始这个实验前，需要学习《CSAPP 第六章-存储器层次结构》的相关内容，与缓存相关的内容，我也做了相关的CPU Cache 高速缓存学习记录可以参考。\n实验相关的文件可以从CS:APP3e, Bryant and O\u0026rsquo;Hallaron下载。\n其中，\nREADME：介绍实验目的和实验要求，以及实验的相关文件。需要注意的是，必须在 64-bit x86-64 system 上运行实验。需要安装 Valgrind 工具。 Writeup：实验指导。 Release Notes：版本发布信息。 Self-Study Handout：需要下载的压缩包，里面包含了待修改的源码文件等。 下载 Self-Study Handout 并解压，得到如下文件：\n├── cachelab.c # 一些辅助函数，如打印输出等，不需要修改 ├── cachelab.h # 同上 ├── csim.c # 需要完善的主文件，需要在这里模拟Cache ├── csim-ref # 已经编译好的程序，我们模拟的Cache需要与这个程序运行的结果保持一致 ├── driver.py # 驱动程序，运行 test-csim 和 test-trans ├── Makefile # 用来编译csim程序 ├── README # ├── test-csim # 测试缓存模拟器 ├── test-trans.c # 测试转置功能 ├── tracegen.c # test-trans 辅助程序 ├── traces # test-csim.c 使用的跟踪文件 │ ├── dave.trace │ ├── long.trace │ ├── trans.trace │ ├── yi2.trace │ └── yi.trace └── trans.c \u003c!DOCTYPE html\u003e Responsive Image Part A —— Writing A Cache Simulator 在 Part A，我们将在 csim.c 中编写一个缓存模拟器，它将 valgrind 内存跟踪作为输入，在此跟踪上模拟高速缓存的命中/未命中行为，并输出命中、未命中和驱逐的总数。\n这里的输入由valgrind通过以下命令生成的：\nvalgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l --log-fd=1表示将输出输出到标准输出； --tool=lackey：Lackey 是一个简单的 Valgrind 工具，可进行各种基本程序测量； --trace-mem=yes：Lackey 的一个参数，启用后，Lackey 会打印程序几乎所有内存访问的大小和地址； ls -l：是一个简单的程序，可以查看当前目录下的文件列表。 也就是检测ls -l程序在运行时访问内存的情况。\n执行结果像下面的形式：\n# [space]operation address,size I 0400639c,4 L 1ffeffec00,8 I 040063a0,2 S 1ffeffea50,8 I 040063a2,4 L 1ffeffebf0,8 I 040063a6,3 I 040063a9,3 L 1ffeffebf8,4 I 040063ac,7 操作字段表示内存访问的类型：I表示指令加载，L表示数据加载，S表示数据存储，M表示数据修改（即，数据加载后跟数据存储） ）。每个I之前都没有空格。每个M、L和S之前总是有一个空格。地址字段指定一个 64 位的十六进制内存地址。 size 字段指定操作访问的字节数。\n了解这些基础后，我们最主要的是要明确，我们需要实现一个什么样的程序，这个程序具体有哪些参数，怎么执行的。csim-ref是已经完成的可执行文件，它的用法是\n./csim-ref [-hv] -s \u0026lt;s\u0026gt; -E \u0026lt;E\u0026gt; -b \u0026lt;b\u0026gt; -t \u0026lt;tracefile\u0026gt; -h：打印帮助信息； -v：显示详细信息，如是 I，L 还是 M； -s \u0026lt;s\u0026gt;：组索引位数（$S=2^{s}$组个数）； -E \u0026lt;E\u0026gt;：关联性（每组的行数）； -b \u0026lt;b\u0026gt;：块位数（$B=2^{b}$ 是块大小）； -t \u0026lt;tracefile\u0026gt;：valgrind 生成的文件； 如：\n./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace hits:4 misses:5 evictions:3 如果显示详细信息可以执行：\n./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace L 10,1 miss M 20,1 miss hit L 22,1 hit S 18,1 hit L 110,1 miss eviction L 210,1 miss eviction M 12,1 miss eviction hit hits:4 misses:5 evictions:3 我们的目的就是要完善csim.c，使其能够使用上面相同的参数，得到与csim-ref相同的结果。 Cache Lab Implementa/on and Blocking这份 PPT 里有一些实验指导，可以参考。 首先需要解决的就是如何处理输入的参数，我们可以使用 PPT 里提到的getopt库来解决。\n#include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;cachelab.h\u0026#34; #include \u0026#34;getopt.h\u0026#34; static int S; // 组个数 static int s; // 组占的位数 static int E; static int B; static int hits = 0; static int misses = 0; static int evictions = 0; typedef struct _CacheLine { unsigned tag; struct _CacheLine *next; struct _CacheLine *prev; } CacheLine; typedef struct _Cache { CacheLine *head; CacheLine *tail; int *size; } Cache; static Cache *cache; void parse_option(int argc, char **argv, char **fileName) { int option; while ((option = getopt(argc, argv, \u0026#34;s:E:b:t:\u0026#34;)) != -1) { switch (option) { case \u0026#39;s\u0026#39;: s = atoi(optarg); // 传入的参数为占用的bit，需要转换为10进制 S = 1 \u0026lt;\u0026lt; s; case \u0026#39;E\u0026#39;: E = atoi(optarg); case \u0026#39;b\u0026#39;: B = atoi(optarg); case \u0026#39;t\u0026#39;: strcpy(*fileName, optarg); } } } void initialize_cache() { cache = malloc(S * sizeof(*cache)); for (int i = 0; i \u0026lt; S; i++) { cache[i].head = malloc(sizeof(CacheLine)); cache[i].tail = malloc(sizeof(CacheLine)); cache[i].head-\u0026gt;next = cache[i].tail; cache[i].tail-\u0026gt;prev = cache[i].head; (cache[i].size) = (int *)malloc(sizeof(int)); *(cache[i].size) = 0; } } /*! * @breif Add a new CacheLine to the Cache first line * @param nodeToDel CacheLine to be deleted * @param curLru Current Cache */ void insert_first_line(CacheLine *node, Cache *curLru) { node-\u0026gt;next = curLru-\u0026gt;head-\u0026gt;next; node-\u0026gt;prev = curLru-\u0026gt;head; curLru-\u0026gt;head-\u0026gt;next-\u0026gt;prev = node; curLru-\u0026gt;head-\u0026gt;next = node; *(curLru-\u0026gt;size) = *(curLru-\u0026gt;size) + 1; } void evict(CacheLine *nodeToDel, Cache *curLru) { nodeToDel-\u0026gt;next-\u0026gt;prev = nodeToDel-\u0026gt;prev; nodeToDel-\u0026gt;prev-\u0026gt;next = nodeToDel-\u0026gt;next; *(curLru-\u0026gt;size) = *(curLru-\u0026gt;size) - 1; } void update(unsigned address) { unsigned int mask = 0xFFFFFFFF; unsigned int maskSet = mask \u0026gt;\u0026gt; (32 - s); // 取出组索引 unsigned int targetSet = ((maskSet) \u0026amp; (address \u0026gt;\u0026gt; B)); // 取出标记 unsigned int targetTag = address \u0026gt;\u0026gt; (s + B); Cache curLru = cache[targetSet]; // 查找是否存与当前标记位相同的缓存行 CacheLine *cur = curLru.head-\u0026gt;next; bool found = 0; while (cur != curLru.tail) { if (cur-\u0026gt;tag == targetTag) { found = true; break; } cur = cur-\u0026gt;next; } if (found) { hits++; evict(cur, \u0026amp;curLru); insert_first_line(cur, \u0026amp;curLru); printf(\u0026#34;\u0026gt; hit!, set: %d \\n\u0026#34;, targetSet); } else { CacheLine *newNode = malloc(sizeof(CacheLine)); newNode-\u0026gt;tag = targetTag; if (*(curLru.size) == E) { // 如果缓存已满，则删除最后一个缓存行 evict(curLru.tail-\u0026gt;prev, \u0026amp;curLru); insert_first_line(newNode, \u0026amp;curLru); evictions++; misses++; printf(\u0026#34;\u0026gt; evic \u0026amp;\u0026amp; miss set:%d\\n\u0026#34;, targetSet); } else { misses++; insert_first_line(newNode, \u0026amp;curLru); printf(\u0026#34;\u0026gt; miss %d\\n\u0026#34;, targetSet); } } } void cache_simulate(char *fileName) { // 分配并初始化S组缓存 initialize_cache(); FILE *file = fopen(fileName, \u0026#34;r\u0026#34;); char op; unsigned int address; int size; while (fscanf(file, \u0026#34; %c %x,%d\u0026#34;, \u0026amp;op, \u0026amp;address, \u0026amp;size) \u0026gt; 0) { printf(\u0026#34;%c, %x %d\\n\u0026#34;, op, address, size); switch (op) { case \u0026#39;L\u0026#39;: update(address); break; case \u0026#39;M\u0026#39;: update(address); case \u0026#39;S\u0026#39;: update(address); break; } } } int main(int argc, char **argv) { char *fileName = malloc(100 * sizeof(char)); parse_option(argc, argv, \u0026amp;fileName); cache_simulate(fileName); printSummary(hits, misses, evictions); return 0; } ","permalink":"https://lifeislife.cn/posts/csapp-lab-cache-lab/","summary":"\u003ch2 id=\"预备知识\"\u003e预备知识\u003c/h2\u003e\n\u003cp\u003e开始这个实验前，需要学习《CSAPP 第六章-存储器层次结构》的相关内容，与缓存相关的内容，我也做了相关的\u003ca href=\"https://dunky-z.github.io/2022/07/10/CPU-Cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/\"\u003eCPU Cache 高速缓存学习记录\u003c/a\u003e可以参考。\u003c/p\u003e\n\u003cp\u003e实验相关的文件可以从\u003ca href=\"http://csapp.cs.cmu.edu/3e/labs.html\"\u003eCS:APP3e, Bryant and O\u0026rsquo;Hallaron\u003c/a\u003e下载。\u003c/p\u003e","title":"CSAPP-LAB-Cache Lab"},{"content":"存储器的层次结构 \u003c!DOCTYPE html\u003e Responsive Image 从 Cache、内存，到 SSD 和 HDD 硬盘，一台现代计算机中，就用上了所有这些存储器设备。其中，容量越小的设备速度越快，而且，CPU 并不是直接和每一种存储器设备打交道，而是每一种存储器设备，只和它相邻的存储设备打交道。比如，CPUCache 是从内存里加载而来的，或者需要写回内存，并不会直接写回数据到硬盘，也不会直接从硬盘加载数据到 CPUCache 中，而是先加载到内存，再从内存加载到 Cache 中。\n这样，各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降，也就构成了我们日常所说的存储器层次结构。\n高速缓存 缓存不是 CPU 的专属功能，可以把它当成一种策略，任何时候想要增加数据传输性能，都可以通过加一层缓存试试。\n存储器层次结构的中心思想是，对于每个$k$，位于$k$层的更快更小的存储设备作为位于$k+1$层的更大更慢的存储设备的缓存。下图展示了存储器层次结构中缓存的一般性概念。\n\u003c!DOCTYPE html\u003e Responsive Image 数据总是以块block为单位，在层与层之间来回复制。\n说回高速缓存，按照摩尔定律，CPU 的访问速度每 18 个月便会翻一翻，相当于每年增长 60%。内存的访问速度虽然不断增长，却远没有那么快，每年只增长 7% 左右。这样就导致 CPU 性能和内存访问的差距不断拉大。为了弥补两者之间差异，现代 CPU 引入了高速缓存。\n\u003c!DOCTYPE html\u003e Responsive Image CPU 的读（load）实质上就是从缓存中读取数据到寄存器（register）里，在多级缓存的架构中，如果缓存中找不到数据（Cache miss），就会层层读取二级缓存三级缓存，一旦所有的缓存里都找不到对应的数据，就要去内存里寻址了。寻址到的数据首先放到寄存器里，其副本会驻留到 CPU 的缓存中。\nCPU 的写（store）也是针对缓存作写入。并不会直接和内存打交道，而是通过某种机制实现数据从缓存到内存的写回（write back）。\n缓存到底如何与 CPU 和主存数据交换的？CPU 如何从缓存中读写数据的？缓存中没有读的数据，或者缓存写满了怎么办？我们先从 CPU 如何读取数据说起。\n缓存读取 CPU 发起一个读取请求后，返回的结果会有如下几种情况：\n缓存命中 (cache hit) 要读取的数据刚好在缓存中，叫做缓存命中。 缓存不命中 (cache miss) 发送缓存不命中，缓存就得执行一直放置策略(placement policy)，比如 LRU。来决定从主存中取出的数据放到哪里。 强制性不命中(compulsory miss)/冷不命中(cold miss)：缓存中没有要读取的数据，需要从主存读取数据，并将数据放入缓存。 冲突不命中(conflict miss)：缓存中有要读的数据，在采取放置策略时，从主存中取数据放到缓存时发生了冲突，这叫做冲突不命中。 高速缓存存储器组织结构 整个 Cache 被划分为 1 个或多个组 (Set)，$S$ 表示组的个数。每个组包含 1 个或多个缓存行(Cache line)，$E$ 表示一个组中缓存行的行数。每个缓存行由三部分组成：有效位(valid)，标记位（tag），数据块（cache block）。\n有效位：该位等于 1，表示这个行数据有效。 标记位：唯一的标识了存储在高速缓存中的块，标识目标数据是否存在当前的缓存行中。 数据块：一部分内存数据的副本。 \u003c!DOCTYPE html\u003e Responsive Image Cache 的结构可以由元组$(S,E,B,m)$表示。不包括有效位和标记位。Cache 的大小为 $C=S \\times E \\times B$.\n接下来看看 Cache 是如何工作的，当 CPU 执行数据加载指令，从内存地址 A 读取数据时，根据存储器层次原理，如果 Cache 中保存着目标数据的副本，那么就立即将数据返回给 CPU。那么 Cache 如何知道自己保存了目标数据的副本呢？\n假设目标地址的数据长度为$m$位，这个地址被参数 $S$ 和 $B$ 分成了三个字段：\n\u003c!DOCTYPE html\u003e Responsive Image 首先通过长度为$s$的组索引，确定目标数据保存在哪一个组 (Set) 中，其次通过长度为$t$的标记，确定在哪一行，需要注意的是此时有效位必须等于 1，最后根据长度为$b$的块偏移，来确定目标数据在数据块中的确切位置。\nQ：既然读取 Cache 第一步是组选择，为什么不用高位作为组索引，而使用中间的为作为组索引？ A：如果使用了高位作索引，那么一些连续的内存块就会映射到相同的高速缓存块。如图前四个块映射到第一个缓存组，第二个四个块映射到第二个组，依次类推。如果一个程序有良好的空间局部性，顺序扫描一个数组的元素，那么在任何时候，缓存中都只保存在一个块大小的数组内容。这样对缓存的使用率很低。相比而言，如果使用中间的位作为组索引，那么相邻的块总是映射到不同的组，图中的情况能够存放整个大小的数组片。 \u003c!DOCTYPE html\u003e Responsive Image 直接映射高速缓存 Direct Mapped Cache 根据每个组的缓存行数 $E$ 的不同，Cache 被分为不同的类。每个组只有一行$E=1$的高速缓存被称为直接映射高速缓存(direct-mapped cache)。\n\u003c!DOCTYPE html\u003e Responsive Image 当一条加载指令指示 CPU 从主存地址 A 中读取一个字 w 时，会将该主存地址 A 发送到高速缓存中，则高速缓存会根据组选择，行匹配和字抽取三步来判断地址 A 是否命中。\n组选择(set selection)：根据组索引值来确定属于哪一个组，如图中索引长度为 5 位，可以检索 32 个组 ($2^5=32$)。当$s=0$时，此时组选择的结果为set 0，当$s=1$时，此时组选择的结果为set 1。\n\u003c!DOCTYPE html\u003e Responsive Image 行匹配 (line match)：首先看缓存行的有效位，此时有效位为 1，表示当前数据有效。然后对比缓存行的标记0110与地址中的标记0110是否相等，如果相等，则表示目标数据在当前的缓存行中（缓存命中）。如果不一致或者有效位为 0，则表示目标数据不在当前的缓存行中（缓存不命中）。如果命中，就可以进行下一步字抽取。\n\u003c!DOCTYPE html\u003e Responsive Image 字抽取 (word extraction)：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于100时，表示目标数据起始地址位于字节 4 处。\n\u003c!DOCTYPE html\u003e Responsive Image 下面通过一个例子来解释清除这个过程。假设我们有一个直接映射高速缓存，描述为$(S,E,B,m) = (4,1,2,4)$。换句话说，高速缓存有 4 个组，每个组 1 行，每个数据块 2 个字节，地址长度为 4 位。\n\u003c!DOCTYPE html\u003e Responsive Image 从图中可以看出，8 个内存块，但只有 4 个高速缓存组，所以会有多个块映射到同一个高速缓存组中。例如，块 0 和块 4 都会被映射到组 0。\n下面我们来模拟当 CPU 执行一系列读的时候，高速缓存的执行情况，我们假设每次 CPU 读 1 个字节的字。\n读地址 0(0000) 的字： \u003c!DOCTYPE html\u003e Responsive Image 读地址 1(0001) 的字： \u003c!DOCTYPE html\u003e Responsive Image 读地址 13(1101) 的字： \u003c!DOCTYPE html\u003e Responsive Image 读地址 8(1000) 的字： \u003c!DOCTYPE html\u003e Responsive Image 读地址 0(0000) 的字： \u003c!DOCTYPE html\u003e Responsive Image 组相联高速缓存 Set Associative Cache 由于直接映射高速缓存的组中只有一行，所以容易发生冲突不命中。组相联高速缓存 (Set associative cache) 运行有多行缓存行。但是缓存行最大不能超过 $C/B$。\n如图一个组中包含了两行缓存行，这种我们称为 2 路相联高速缓存。\n\u003c!DOCTYPE html\u003e Responsive Image 组选择：与直接映射高速缓存的组选择过程一样。\n行匹配：因为一个组有多行，所以需要遍历所有行，找到一个有效位为 1，并且标记为与地址中的标记位相匹配的一行。如果找到了，表示缓存命中。\n字抽取：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于100时，表示目标数据起始地址位于字节 4 处。\n如果不命中，那么就需要从主存中取出需要的数据块，但是将数据块放在哪一行缓存行呢？如果存在空行 ($valid=0$)，那就放到空行里。如果没有空行，就得选择一个非空行来替换，同时希望 CPU 不会很快引用这个被替换的行。这里介绍几个替换策略。\n最简单的方式就是随机选择一行来替换，其他复杂的方式就是利用局部性原理，使得接下来 CPU 引用替换的行概率最小。如\n最不常使用 (LFU, Least Frequently Used)，选择使用次数最少的行。 最近最少使用 (LRU, Least Recently Used)，选择最近使用最少的行。 全相联高速缓存 Fully Associative Cache 整个 Cache 只有一个组，这个组包含了所有的缓存行。\n\u003c!DOCTYPE html\u003e Responsive Image 组选择：因为只有一个组，所有默认总是选择 set 0。实际上这不就直接可以忽略了，访问的地址也就只需要划分为标记和偏移。\n\u003c!DOCTYPE html\u003e Responsive Image 行匹配：同组相联高速缓存。\n字抽取：同组相联高速缓存。\n由于硬件实现及成本等原因，全相联高速缓存只适合做小规模的缓存。例如虚拟内存中的 TLB（翻译备用缓存器，Translation Lookaside Buffer）。\n缓存写入 写入 Cache 的性能比写入主内存要快，那么写入数据到底是写入 Cache 还是写入主内存呢？如果直接写入主内存里，Cache 里面的数据是否会失效呢？\n写直达 写直达策略（Write-Through）：当数据要写入主内存里面，写入前，会先去判断数据是否已经在 Cache 里面了。如果数据已经在 Cache 里了，先把数据写入更新到 Cache 里面，再写入到主内存里面；如果数据不在 Cache 里，就只更新主内存。\n写回 写回策略（Write-Back）：如果发现要写入的数据，就在 CPU Cache 里面，那么就只是更新 CPU Cache 里面的数据。同时，会标记 CPU Cache 里的这个 Block 是脏（Dirty）的，表示 CPU Cache 里面的这个 Block 的数据，和主内存是不一致的。如果发现，要写入的数据所对应的 Cache Block 里，放的是别的内存地址的数据，那么就要看一看，那个 Cache Block 里面的数据有没有标记成脏的。如果是脏的话，要先把这个 Cache Block 里面的数据，写入到主内存里面。然后，再把当前要写入的数据，写入到 Cache 里，同时把 Cache Block 标记成脏的。如果 Block 里面的数据没有被标记成脏的话，那么直接把数据写入到 Cache 里面，然后再把 Cache Block 标记成脏的就好了。\n在用了写回这个策略之后，在加载内存数据到 Cache 里面的时候，也要多出一步同步脏 Cache 的动作。如果加载内存里面的数据到 Cache 的时候，发现 Cache Block 里面有脏标记，也要先把 Cache Block 里的数据写回到主内存，才能加载数据覆盖掉 Cache。\n缓存一致性 CPU 缓存一致性 MESI 协议 - 如云泊\n参考资料 C/C++中 volatile 关键字详解 - chao_yu - 博客园 volatile 能解决 cache 的数据一致性吗？答案是不能_天才 2012 的博客-CSDN 博客_volatilewritecache cpu 缓存和 volatile - XuMinzhe - 博客园 【CSAPP-深入理解计算机系统】6-5. 直接映射高速缓存_哔哩哔哩_bilibili 24 张图 7000 字详解计算机中的高速缓存 - 腾讯云开发者社区 - 腾讯云\n","permalink":"https://lifeislife.cn/posts/cpu-cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/","summary":"\u003ch2 id=\"存储器的层次结构\"\u003e存储器的层次结构\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081652018.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081652018.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e从 Cache、内存，到 SSD 和 HDD 硬盘，一台现代计算机中，就用上了所有这些存储器设备。其中，容量越小的设备速度越快，而且，CPU 并不是直接和每一种存储器设备打交道，而是每一种存储器设备，只和它相邻的存储设备打交道。比如，CPUCache 是从内存里加载而来的，或者需要写回内存，并不会直接写回数据到硬盘，也不会直接从硬盘加载数据到 CPUCache 中，而是先加载到内存，再从内存加载到 Cache 中。\u003c/p\u003e","title":"CPU Cache 高速缓存"},{"content":"KeePass 安装 下载与安装\n官网： https://keepass.info/download.html\n下载完成后进行安装，默认安装位置是：C:\\Program Files (x86)\\KeePass Password Safe 2文件夹下，可以根据自己需要选择安装路径。\n更改中文语言\n中文语言包： KeePass-Chinese_Simplified\n将语言包下载后复制到安装路径下的Languages文件夹下，默认为：C:\\Program Files (x86)\\KeePass Password Safe 2\\Languages。重启软件。\n点击 View-\u0026gt;Change Language. 选择中文简体（Chinese-Simplified）。重启软件，即可完成语言更改。\n\u003c!DOCTYPE html\u003e Responsive Image 中文界面：\n\u003c!DOCTYPE html\u003e Responsive Image 基本使用 1.创建一个数据库\n点击 文件-》新建。弹出对话框为数据库创建管理密码。这个密码是唯一需要记忆的密码。当然如果追求更高的安全性，可以点击显示高级选项，提供更多的密码选项。\n\u003c!DOCTYPE html\u003e Responsive Image 2.添加记录\n点击添加记录，在弹出的窗口填入相关信息。即可完成密码添加。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 如果是第一次使用的网站，第一次注册密码。可以通过密码生成器，生成一个高强度的密码来添加记录。\n\u003c!DOCTYPE html\u003e Responsive Image 3.创建一个密码生成模板\n正常国内的网站可以使用的密码长度 6-16 位，可以使用大小写，数字，下划线。我们把这些选项勾选，密码长度设置 16 位。\n\u003c!DOCTYPE html\u003e Responsive Image 点击保存并给模板设置个名字方便下次使用\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 如果保存后想更改一下，比如再加个可以使用空格，可以重新勾选刚刚的选项，保存时点击小三角，选择刚刚保存的方案就可以覆盖。\n导入 Chrome 已保存的密码\n很多小伙伴在使用 KeePass 之前肯定在 Chrome 等浏览器里也保存了很多密码。想将其导入 KeePass 方便管理。Chrome 是可以导出密码的，KeePass 也可以导入密码。\n点击浏览器右上角，打开设置界面。找到密码\n\u003c!DOCTYPE html\u003e Responsive Image 找到已保存的密码-》导出密码。选择方便找到的路径，保存密码记录。\n\u003c!DOCTYPE html\u003e Responsive Image 打开 KeePass，点击文件-》导入，选择 Chrome 浏览器的格式。点击文件夹图标找到刚刚导出的密码文件。\n\u003c!DOCTYPE html\u003e Responsive Image 高级配置 KeePass 搭配坚果云实现云同步 登录坚果云创建个人同步文件夹，若没有先注册。\n\u003c!DOCTYPE html\u003e Responsive Image 最好单独建一个专门的文件夹\n\u003c!DOCTYPE html\u003e Responsive Image 将已经生成的数据库上传到这个文件夹下\n\u003c!DOCTYPE html\u003e Responsive Image 点击右上角进入账户信息，点击安全选项：\n\u003c!DOCTYPE html\u003e Responsive Image 点击添加应用\n\u003c!DOCTYPE html\u003e Responsive Image 输入应用名称，应用名称只是方便区分作用，所以和要同步的应用名称一致就好：\n\u003c!DOCTYPE html\u003e Responsive Image 点击生成密码：\n\u003c!DOCTYPE html\u003e Responsive Image 此时云盘端配置完成，切回到 KeePass 进行客户端配置。点击文件-》同步-》与网址（URL）同步\n\u003c!DOCTYPE html\u003e Responsive Image 网址： https://dav.jianguoyun.com/dav/KeePass/keepassData.kdbx\n注意：红色部分是个人同步文件夹的名称，绿色部分是上传的数据库全称，一定别忘了后缀\n**用户名：**你的坚果云登录名（邮箱或者手机号）\n密码：生成应用的密码，（不是登录坚果云的密码）\n点击确定，此时已经可以完成同步，但是每次同步仍然需要手动确定。参考了什么值得买上小乐 CSN的方法，通过触发器实现自动同步。\n触发器代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;TriggerCollection xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\u0026gt; \u0026lt;Triggers\u0026gt; \u0026lt;Trigger\u0026gt; \u0026lt;Guid\u0026gt;L2euC7Mr/EKh7nPjueuZvQ==\u0026lt;/Guid\u0026gt; \u0026lt;Name\u0026gt;SaveSync\u0026lt;/Name\u0026gt; \u0026lt;Events\u0026gt; \u0026lt;Event\u0026gt; \u0026lt;TypeGuid\u0026gt;s6j9/ngTSmqcXdW6hDqbjg==\u0026lt;/TypeGuid\u0026gt; \u0026lt;Parameters\u0026gt; \u0026lt;Parameter\u0026gt;1\u0026lt;/Parameter\u0026gt; \u0026lt;Parameter\u0026gt;kdbx\u0026lt;/Parameter\u0026gt; \u0026lt;/Parameters\u0026gt; \u0026lt;/Event\u0026gt; \u0026lt;/Events\u0026gt; \u0026lt;Conditions /\u0026gt; \u0026lt;Actions\u0026gt; \u0026lt;Action\u0026gt; \u0026lt;TypeGuid\u0026gt;tkamn96US7mbrjykfswQ6g==\u0026lt;/TypeGuid\u0026gt; \u0026lt;Parameters\u0026gt; \u0026lt;Parameter\u0026gt;SaveSync\u0026lt;/Parameter\u0026gt; \u0026lt;Parameter\u0026gt;0\u0026lt;/Parameter\u0026gt; \u0026lt;/Parameters\u0026gt; \u0026lt;/Action\u0026gt; \u0026lt;Action\u0026gt; \u0026lt;TypeGuid\u0026gt;Iq135Bd4Tu2ZtFcdArOtTQ==\u0026lt;/TypeGuid\u0026gt; \u0026lt;Parameters\u0026gt; \u0026lt;Parameter\u0026gt;https://dav.jianguoyun.com/dav/keePass/passwordSync.kdbx\u0026lt;/Parameter\u0026gt; \u0026lt;Parameter\u0026gt;123456\u0026lt;/Parameter\u0026gt; \u0026lt;Parameter\u0026gt;123456\u0026lt;/Parameter\u0026gt; \u0026lt;/Parameters\u0026gt; \u0026lt;/Action\u0026gt; \u0026lt;Action\u0026gt; \u0026lt;TypeGuid\u0026gt;tkamn96US7mbrjykfswQ6g==\u0026lt;/TypeGuid\u0026gt; \u0026lt;Parameters\u0026gt; \u0026lt;Parameter\u0026gt;SaveSync\u0026lt;/Parameter\u0026gt; \u0026lt;Parameter\u0026gt;1\u0026lt;/Parameter\u0026gt; \u0026lt;/Parameters\u0026gt; \u0026lt;/Action\u0026gt; \u0026lt;/Actions\u0026gt; \u0026lt;/Trigger\u0026gt; \u0026lt;/Triggers\u0026gt; \u0026lt;/TriggerCollection\u0026gt; 复制触发器代码，点击工具-》触发器，点击工具-》从剪切板粘贴触发器：\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 导入成功后，在触发器页面会多一个触发器：\n\u003c!DOCTYPE html\u003e Responsive Image 双击打开SaveSync,打开最后一个动作窗口：\n\u003c!DOCTYPE html\u003e Responsive Image 双击中间的条目：\n\u003c!DOCTYPE html\u003e Responsive Image 将信息换成同步云盘的信息：\n文件/网址： https://dav.jianguoyun.com/dav/KeePass/keepassData.kdbx\n注意：红色部分是个人同步文件夹的名称，绿色部分是上传的数据库全称，一定别忘了后缀\n**IO 连接 - 用户名：**你的坚果云登录名（邮箱或者手机号）\nIO 连接 - 密码：生成应用的密码，（不是登录坚果云的密码）\n点击确定，回到主页面，点击工具-》选项\n\u003c!DOCTYPE html\u003e Responsive Image 找到 高级，向下翻，在文件输入/输出连接 栏目里找到 写入数据库时使用文件交换 此项不勾选\n\u003c!DOCTYPE html\u003e Responsive Image 点击确定，返回主页面。此时点击保存按钮或者 Ctrl+S。即可与云盘进行同步。\nChrome 上使用插件实现密码自动填充与同步 在 KeePass 客户端安装KeePassRPC 插件：\n将其放入安装目录（.\\KeePass\\Plugins）文件夹下，退出软件，重启即可自动安装。\n在浏览器客户端安装浏览器插件Kee，若无法科学上网，可能需要自行百度搜索 Kee 插件\n\u003c!DOCTYPE html\u003e Responsive Image 安装完成后会跳出窗口提示授权，将 KeePass 客户端跳出的窗口中的红色授权码填入即可连接浏览器：\n\u003c!DOCTYPE html\u003e Responsive Image 使用 Kee\n\u003c!DOCTYPE html\u003e Responsive Image 再次使用浏览器填写密码是可以看到文本框会有 logo，Kee 会自动填写已保存的密码。如果第一次登陆，在登录后可以点击浏览器插件图标，找到 Save latest login，保存刚刚输入的密码。\n\u003c!DOCTYPE html\u003e Responsive Image 密码管理器的重要作用之一就是生成高强度密码，可以用 KeePass 客户端来生成，也可以是 Kee 这个插件的一个生成密码功能生成。英文版的是Generate new password\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8-keepass/","summary":"\u003ch2 id=\"keepass-安装\"\u003e\u003cstrong\u003eKeePass 安装\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e下载与安装\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e官网： \u003ca href=\"https://keepass.info/download.html\"\u003ehttps://keepass.info/download.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e下载完成后进行安装，默认安装位置是：\u003ccode\u003eC:\\Program Files (x86)\\KeePass Password Safe 2\u003c/code\u003e文件夹下，可以根据自己需要选择安装路径。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e更改中文语言\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e中文语言包： \u003ca href=\"https://www.keepass.com.cn/language#:~:text=%E5%9C%A8keepass%E4%B8%AD%EF%BC%8C%E5%8D%95%E5%87%BB,%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8Keepass%E3%80%82\"\u003eKeePass-Chinese_Simplified\u003c/a\u003e\u003c/p\u003e","title":"密码管理器-KeePass"},{"content":"volatile 能否解决缓存一致性问题 为何会产生这样的疑问，还得从一个工作中的 Bug 说起。在使用 PMP（Physical Memory Protect）对物理内存进行保护时，无法成功保护，简单来说 PMP 可以对一段物理内存设置保护，如保护这段内存不可写。测试时，先对这段内存写入0x1234，再读取这段内存。如果读取的值为0x0表示保护成功，但实际总能成功读取0x1234。\nvolatile int test; test = read(0xFF740000); print(\u0026#34;Before = %x\\n\u0026#34;, test); // 保护之前数据 Before = 0x1111 PMP(0xFF740000, 0x400); // 保护这段内存不可写 write(0xFF740000, 0x1234); // 写入数据 test = read(0xFF740000); print(\u0026#34;After = %x\\n\u0026#34;, test); // 预期读取为0x0，实际总能成功读取0x1234 因为读取的变量test设置为volatile，所以按照以往的理解，系统总是重新从它所在的内存读取数据，这里应该能正确读取出数据。\n但是忽略了一点，当使用volatile变量时，CPU 只是不再使用寄存器中的值，直接去内存中读取数据，这里的内存实际上是包括 Cache 的。\n所以当数据被 Cached 之后，当再次读取时，CPU 可能会直接读取 Cached 的数据，而不是去读取真正内存中的数据。因此，volatile 不能解决缓存一致性问题。\n关于 Cache 的详细信息，请参考CPU Cache 高速缓存 - 如云泊。\n","permalink":"https://lifeislife.cn/posts/volatile%E8%83%BD%E5%90%A6%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/","summary":"\u003ch1 id=\"volatile-能否解决缓存一致性问题\"\u003evolatile 能否解决缓存一致性问题\u003c/h1\u003e\n\u003cp\u003e为何会产生这样的疑问，还得从一个工作中的 Bug 说起。在使用 PMP（Physical Memory Protect）对物理内存进行保护时，无法成功保护，简单来说 PMP 可以对一段物理内存设置保护，如保护这段内存不可写。测试时，先对这段内存写入\u003ccode\u003e0x1234\u003c/code\u003e，再读取这段内存。如果读取的值为\u003ccode\u003e0x0\u003c/code\u003e表示保护成功，但实际总能成功读取\u003ccode\u003e0x1234\u003c/code\u003e。\u003c/p\u003e","title":"volatile 能否解决缓存一致性问题"},{"content":"CS 可视化 - 常用的 Git 命令 Author：Lydia Hallie 译：🌳🚀 CS Visualized: Useful Git Commands - DEV Community\n尽管 Git 是一个非常强大的工具，但我想大多数人都会同意，当我说它也可能是……一场彻头彻尾的噩梦当我执行某个命令时分支交互，它将如何影响历史记录？当我在master分支执行hard reset、force push到 origin、在.git文件夹执行rimraf的时候，为什么我的同事都哭了？\n我认为这将是创建一些最常见和最有用命令的可视化示例的完美用例！我介绍的许多命令都有可选参数，您可以使用这些参数来更改它们的行为。在我的示例中，我将介绍命令的默认行为，而不添加（太多）配置选项！\nMerging 拥有多个分支非常方便，可以将新更改彼此分开，并确保您不会意外地将未经批准或损坏的更改推送到生产环境。一旦更改获得批准，我们希望在我们的生产分支中获得这些更改！\n将更改从一个分支转移到另一个分支的一种方法是执行 git merge！Git 可以执行两种类型的合并：fast-forward 或​​ no-fast-forward。\n现在这可能没有多大意义，所以让我们看看差异！\nFast-forward (--ff) 如果当前分支与即将合并过来的分支相比，没有额外的提交，这种就是fast-forward合并。Git 很会偷懒，它会首先尝试最简单的方案，即fast-forward。这种合并方式不会创建新的提交，只是把另一个分支的提交记录直接合并到当前分支。\n\u003c!DOCTYPE html\u003e Responsive Image 完美的！我们现在可以在 master 分支上使用在 dev 分支上所做的所有更改。那么，no-fast-forward 到底是什么？\nNo-fast-foward (--no-ff) 如果与您要合并的分支相比，您当前的分支没有任何额外的提交，那就太好了，但不幸的是，这种情况很少见！如果我们在当前分支上提交了我们想要合并的分支没有的更改，Git 将执行 no-fast-forward 合并。\n使用 no-fast-forward 合并，Git 在活动分支上创建一个新的合并提交。提交的父提交指向活动分支和我们要合并的分支！\n\u003c!DOCTYPE html\u003e Responsive Image 没什么大不了的，完美的合并！ master 分支现在包含我们在 dev 分支上所做的所有更改。\nMerge Conflicts 尽管 Git 擅长决定如何合并分支和向文件添加更改，但它不能总是自己做出这个决定。当我们尝试合并的两个分支在同一个文件的同一行上发生更改时，可能会发生这种情况，或者如果一个分支删除了另一个分支修改的文件，等等。\n在这种情况下，Git 会要求您帮助决定我们要保留两个选项中的哪一个！假设在两个分支上，我们编辑了 README.md 中的第一行。\n\u003c!DOCTYPE html\u003e Responsive Image 如果我们想将 dev 合并到 master 中，这将导致合并冲突：您希望标题是 Hello! 还是 Hey!？\n当试图合并分支时，Git 会告诉你冲突发生在哪里。我们可以手动删除不想保留的更改，保存更改，再次添加更改的文件，然后提交更改\n\u003c!DOCTYPE html\u003e Responsive Image 耶！尽管合并冲突通常很烦人，但它完全有道理：Git 不应该自己决定选择哪一个更改。\nRebasing 我们刚刚看到了如何通过执行 git merge 将更改从一个分支应用到另一个分支。另一种将更改从一个分支添加到另一个的方法是执行git rebase。\ngit rebase 复制当前分支的提交，并将这些复制的提交放在指定分支的顶部。\n\u003c!DOCTYPE html\u003e Responsive Image 完美，我们现在可以在 dev 分支上使用在 master 分支上所做的所有更改！\n与合并相比，一个很大的区别是 Git 不会尝试找出要保留和不保留的文件。我们正在变基的分支总是有我们想要保留的最新更改！通过这种方式，您不会遇到任何合并冲突，并保持良好的线性 Git 历史记录。\n这个例子展示了基于 master 分支的变基。然而，在更大的项目中，您通常不想这样做。 git rebase 改变了项目的历史，因为为复制的提交创建了新的哈希！\n每当您在功能分支上工作并且主分支已更新时，重新定基都很棒。您可以获得分支上的所有更新，这将防止未来的合并冲突！\nInteractive Rebase 在重新提交提交之前，我们可以修改它们！我们可以使用 interactive rebase 来做到这一点。交互式变基对于您当前正在处理的分支也很有用，并且想要修改一些提交。\n我们可以对我们正在变基的提交执行 6 项操作：\nreword: Change the commit message edit: Amend this commit squash: Meld commit into the previous commit fixup: Meld commit into the previous commit, without keeping the commit\u0026rsquo;s log message exec: Run a command on each commit we want to rebase drop: Remove the commit 惊人的！这样，我们可以完全控制我们的提交。如果我们想删除一个提交，我们可以直接 drop 它。\n\u003c!DOCTYPE html\u003e Responsive Image 或者，如果我们想将多个提交压缩在一起以获得更清晰的历史记录，没问题！\n\u003c!DOCTYPE html\u003e Responsive Image 交互式变基使您可以对尝试变基的提交进行大量控制，即使在当前活动分支上也是如此！\nResetting 我们可能会提交我们以后不想要的更改。也许它是一个WIP提交，或者是一个引入错误的提交！在这种情况下，我们可以执行 git reset。\ngit reset 会删除所有当前暂存的文件，并让我们控制 HEAD 应该指向的位置。\nSoft reset 软重置将 HEAD 移动到指定的提交（或提交的索引与 HEAD 相比），而不会消除随后在提交中引入的更改！\n假设我们不想保留添加了style.css文件的提交9e78i，也不想保留添加了index.js文件的提交035cc。但是，我们确实希望保留新添加的 style.css 和 index.js 文件！软重置的完美用例。\n\u003c!DOCTYPE html\u003e Responsive Image 输入 git status 时，您会看到我们仍然可以访问对先前提交所做的所有更改。这很棒，因为这意味着我们可以修复这些文件的内容并在以后再次提交它们！\nHard reset 有时，我们不想保留某些提交引入的更改。与软重置不同，我们不再需要访问它们。Git 应该简单地将其状态重置回指定提交时的状态：这甚至包括工作目录和暂存文件中的更改！\n\u003c!DOCTYPE html\u003e Responsive Image Git 丢弃了在 9e78i 和 035cc 上引入的更改，并将其状态重置为提交 ec5be 时的状态。\nReverting 撤消更改的另一种方法是执行git revert。通过恢复某个提交，我们创建了一个包含恢复的更改的新提交！\n假设 ec5be 添加了一个 index.js 文件。后来，我们实际上意识到我们不再希望这次提交引入的这种变化！让我们恢复 ec5be 提交。\n\u003c!DOCTYPE html\u003e Responsive Image 完美的！提交9e78i恢复了由ec5be提交引入的更改。执行 git revert 非常有用，可以撤消某个提交，而无需修改分支的历史记录。\nCherry-picking 当某个分支包含在活动分支上引入了我们需要的更改的提交时，我们可以 cherry-pick 该命令！通过 cherry-pick 提交，我们在活动分支上创建了一个新提交，其中包含由 cherry-pick 提交所引入的更改。\n假设 dev 分支上的提交 76d12 添加了我们想要在 master 分支中的 index.js 文件的更改。我们不想要整个，我们只关心这一次提交！\n\u003c!DOCTYPE html\u003e Responsive Image 很酷，master 分支现在包含了 76d12 引入的更改！\nFetching 如果我们有一个远程 Git 分支，例如 GitHub 上的一个分支，则可能会发生远程分支具有当前分支没有的提交！也许另一个分支被合并了，你的同事推送了一个快速修复，等等。\n我们可以通过在远程分支上执行 git fetch 在本地获取这些更改！它不会以任何方式影响您的本地分支：fetch 只是下载新数据。\n\u003c!DOCTYPE html\u003e Responsive Image 我们现在可以看到自上次推送以来所做的所有更改！既然我们在本地拥有新数据，我们就可以决定要如何处理这些数据。\nPulling 虽然 git fetch 对于获取分支的远程信息非常有用，但我们也可以执行 git pull。 git pull 实际上是两个命令合二为一：git fetch 和 git merge。当我们从源中提取更改时，我们首先像使用 git fetch 一样获取所有数据，之后最新的更改会自动合并到本地分支中。\n\u003c!DOCTYPE html\u003e Responsive Image 太棒了，我们现在与远程分支完美同步，并拥有所有最新更改！\nReflog 每个人都会犯错，这完全没关系！有时你可能会觉得你把你的 git repo 搞砸了，以至于你只想完全删除它。\ngit reflog 是一个非常有用的命令，用于显示所有已采取的操作的日志！这包括合并、重置、恢复：基本上是对分支的任何更改。\n\u003c!DOCTYPE html\u003e Responsive Image 如果您犯了错误，您可以根据 reflog 提供给我们的信息通过重置 HEAD 轻松地重做此操作！\n假设我们实际上并不想合并 origin 分支。当我们执行 git reflog 命令时，我们看到合并前 repo 的状态是在 HEAD@{1}。让我们执行 git reset 将 HEAD 指向它在 HEAD@{1} 上的位置！\n\u003c!DOCTYPE html\u003e Responsive Image 我们可以看到最新的 action 已经推送到reflog了！\n","permalink":"https://lifeislife.cn/posts/zh-cs%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4/","summary":"\u003ch1 id=\"cs-可视化---常用的-git-命令\"\u003eCS 可视化 - 常用的 Git 命令\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAuthor：Lydia Hallie\n译：\u003ca href=\"https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1\"\u003e🌳🚀 CS Visualized: Useful Git Commands - DEV Community\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e尽管 Git 是一个非常强大的工具，但我想大多数人都会同意，当我说它也可能是……一场彻头彻尾的噩梦当我执行某个命令时分支交互，它将如何影响历史记录？当我在\u003ccode\u003emaster\u003c/code\u003e分支执行\u003ccode\u003ehard reset\u003c/code\u003e、\u003ccode\u003eforce push\u003c/code\u003e到 \u003ccode\u003eorigin\u003c/code\u003e、在\u003ccode\u003e.git\u003c/code\u003e文件夹执行\u003ccode\u003erimraf\u003c/code\u003e的时候，为什么我的同事都哭了？\u003c/p\u003e","title":"ZH-CS 可视化 - 常用的 Git 命令"},{"content":"数组初始化 int arr[6] = { [0]=5, [1]=6, [3] =10, [4]=11 }; 或 int arr[6] = { [0]=5, 6, [3] =10, 11 }; 或 int arr[6] = { [3] =10, 11, [0]=5, 6 }; (指定顺序可变) 均等效于：int arr[6] = {5, 6, 0, 10, 11, 0}; Note:\n若在某个指定初始化项目后跟有不至一个值，如[3]=10,11。则多出的数值用于对后续的数组元素进行初始化，即数值 11 用来初始化 arr[4]。 C 数组初始化一个或多个元素后，未初始化的元素将被自动地初始化为 0 或 NULL(针对指针变量)。未经过任何初始化的数组，所有元素的值都是不确定的。 GNU C 还支持[first … last]=value(…两侧有空格) 的形式，将该范围内的若干元素初始化为相同值。如：\nint arr[]={ [0 ... 3]=1, [4 ... 5]=2, [6 ... 9] =3}; 或 int arr[]={ [0 ... 3]=1, [4 ... 5]=2, [6 ... 8] =3, [9] =3}; 均等效于：int arr[10] = {1, 1, 1, 1, 2, 2, 3, 3, 3, 3}; 结构体初始化 对于结构体\nstruct Structure{ int a; int b; }; 或 struct Structure{ int a, b; }; 有以下几种初始化方式： 用.fieldname=指定待初始化成员名(成员初始化顺序可变)，推荐使用的方式，该方式初始化时不必严格按照定义时的顺序，灵活性很高。\nstruct Structure tStct = { .a = 1, .b = 2 }; 用fieldname:指定待初始化成员名(成员初始化顺序可变)，GCC 2.5 已废除，但仍接受\nstruct Structure tStct = { a : 1, b : 2 }; 用初始化列表初始化\nstruct Structure tStct = { 1, 2 }; 结构体数组初始化 方法一：\nstruct Structure ptStct[10] = { [2].b = 0x2B, [2].a = 0x2A, [0].a = 0x0A }; 方法二：该方法可以用于清除结构体。\nmemset(ptStct, 0, sizeof(struct Structure) * 10); 联合体初始化 可用.fieldname(或已废弃的fieldname:) 指示符来指定使用联合体的哪个元素，如：\nunion UnionT { int i; double d; }; union UnionT tUnion = { .d = 4 }; ","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84-%E7%BB%93%E6%9E%84%E4%BD%93-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-%E8%81%94%E5%90%88%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96/","summary":"\u003ch2 id=\"数组初始化\"\u003e数组初始化\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C\" data-lang=\"C\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003earr\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e11\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e \u003cspan class=\"err\"\u003e或\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003earr\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e11\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e \u003cspan class=\"err\"\u003e或\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003earr\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e6\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"err\"\u003e指定顺序可变\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"err\"\u003e均等效于：\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003earr\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNote:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e若在某个指定初始化项目后跟有不至一个值，如\u003ccode\u003e[3]=10,11\u003c/code\u003e。则多出的数值用于对后续的数组元素进行初始化，即数值 11 用来初始化 arr[4]。\u003c/li\u003e\n\u003cli\u003eC 数组初始化一个或多个元素后，未初始化的元素将被自动地初始化为 0 或 NULL(针对指针变量)。未经过任何初始化的数组，所有元素的值都是不确定的。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eGNU C 还支持\u003ccode\u003e[first … last]=value\u003c/code\u003e(\u003ccode\u003e…\u003c/code\u003e\u003cstrong\u003e两侧有空格\u003c/strong\u003e) 的形式，将该范围内的若干元素初始化为相同值。如：\u003c/p\u003e","title":"C语言数组/结构体/结构体数组/联合体初始化"},{"content":"功能 watch 命令的功能如其名，可以监视命令的执行结果。它实现的原理就是每隔一段时间执行一次命令，然后显示结果。他的用途很广，具体怎么用就靠想象力了。\n命令参数 -n # 或--interval watch默认每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。 -d # 或--differences 用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。 -t # 或-no-title 会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。 -h # 或--help # 查看帮助文档 实例 watch -d \u0026#39;ls -l | grep tmp\u0026#39; # 监测当前目录中 scf\u0026#39; 的文件的变化 ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-watch%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/","summary":"\u003ch2 id=\"功能\"\u003e功能\u003c/h2\u003e\n\u003cp\u003ewatch 命令的功能如其名，可以监视命令的执行结果。它实现的原理就是每隔一段时间执行一次命令，然后显示结果。他的用途很广，具体怎么用就靠想象力了。\u003c/p\u003e\n\u003ch2 id=\"命令参数\"\u003e命令参数\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-n # 或--interval  watch默认每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-d # 或--differences  用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-t # 或-no-title  会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-h # 或--help # 查看帮助文档\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"实例\"\u003e实例\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewatch -d \u0026#39;ls -l | grep tmp\u0026#39;       # 监测当前目录中 scf\u0026#39; 的文件的变化\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"每天学命令-watch 周期执行命令"},{"content":"Git hooks 简介 \u003c!DOCTYPE html\u003e Responsive Image Git 能在特定的重要动作发生时触发自定义脚本。比如，commit之前检查commit message是否符合约定的格式，push之前检查代码格式是否正确，是否编译通过等等。Git 就提供了hooks这样的机制。\n我们在哪能找到hooks呢？在初始化代码仓库git init时，Git 会自动为我们创建一个.git/hooks目录，里面存放了所有的钩子。因为.git是隐藏目录，显示隐藏目录后就可以找到hooks这个目录。\n在 VSCode 里一般默认把.git目录排除显示，所以打开项目目录时不会显示该目录，我们可以收到在 VSCode 显示.git目录：打开设置界面，搜索exclude找到图中的设置，将.git目录从排除列表中移除，即可在 VSCode 中显示.git目录。\n现在我们找到了hooks，该如何使用呢？ 所有默认的hooks都是以.sample为后缀，只需要移除.sample即可激活hooks。\n随便打开一个hooks文件，我们可以发现，实际是hooks就是一个个shell脚本。这些脚本会在特定的动作发生时被执行。示范的这些hooks都是shell脚本，实际上只要是文件名正确的可执行脚本都可以使用，如将pre-push内容改为python, Ruby等等脚本都可以。\n如何使用一个 hooks 以pre-commit这个hooks为例，来示范一下如何使用 Git hooks。\n打开.git/hooks/pre-commit.sample，这个hooks的大体功能是检查文件名是否包含非ASCII字符，如果包含，则无法执行commit操作，并提示用户修改文件名。\n删除pre-commit.sample的后缀\n➜ mv .git/hooks/pre-commit.sample .git/hooks/pre-commit 添加一个有汉字的文件名，如测试.md\n➜ touch 测试.md 将新文件提交\n➜ git add 测试.md ➜ git commit -m \u0026#34;测试\u0026#34; Error: Attempt to add a non-ASCII file name. This can cause problems if you want to work with people on other platforms. To be portable it is advisable to rename the file. If you know what you are doing you can disable this check using: git config hooks.allownonascii true 如果无法执行pre-commit可能未被赋予执行权限，修改一下权限即可：chmod +x .git/hooks/pre-commit\n我们可以发现，在进行commit操作时被中断了，会提示用户修改文件名。其他的hooks用法类似，我们可以自定义在什么时候可以push，什么时候可以rebase等等。\nhooks通常会被用来做提交代码前的一个检查，比如风格是否统一，编译是否通过等等。如果团队合作时，这样的检查最好能够与成员保持一致，但是hooks所在的.git目录是不会被Git自己版本管理的，换句话说，它不能推送到远端与成员共享。那么如何解决这个问题呢？\n如何同步hooks文件 方案一：与源码放在一起 代码仓库中新建一个hooks目录，将该目录同步到远程。其他成员下载代码时也会下载hooks目录，通过脚本的方式将hooks目录覆盖本地的.git/hooks目录。\n#!/bin/bash cp -r ./hooks/ .git/hooks/ chmod +x -R .git/hooks echo \u0026#39;Hooks sync to remote success!\u0026#39; exit 0 方案二：使用pre-commit框架 pre_commit 是 pre-commit 同名的开源应用，使用pre-commit，代码仓库里只需要有一个配置文件，所有成员都可以根据配置文件，使用pre_commit生成统一的hooks。\npre-commit随着发展，已经不单单只能用于git hooks的pre-commit阶段，而是能作用于所有git hooks的所有阶段，如上面说的prepare-commit-msg, commit-msg, post-commi等。\n安装pre-commit\npip install pre-commit 在项目目录下，添加配置文件 .pre-commit-config.yaml\ntouch .pre-commit-config.yaml 首先了解配置的格式\n顶层有一个参数名为 repos repos 中每个元素为 repo ，代表一个代码库，一般是github或gitlab链接。在使用时会从对应地址下载，如果出现下载慢的情况，可以在gitee搜索是否有相关镜像。 每个 repo 中有一个或多个 hook ，每个 hook 代表一个任务。 每个任务里可理解为一个命令行指令，例如flake8/yapf/black。 pre_commit官方提供了各种配置，我们可以根据需要选择一个合适的。比如我需要一个格式化C语言代码的配置，选择了mirrors-clang-format，还选了一个用来删除行尾空格的。\nrepos: - repo: https://github.com/pre-commit/pre-commit-hooks rev: v4.3.0 hooks: - id: trailing-whitespace - repo: https://github.com/pre-commit/mirrors-clang-format rev: v14.0.6 hooks: - id: clang-format types_or: [c] 参数的含义可以参考pre-commit的文档。每个id对应的其实都是一个程序，为了保证都能正常运行，还需要安装这些程序。一般在仓库的README中都会有提示如何安装。\n根据配置文件安装hooks 在项目根目录下运行：\npre-commit install 在执行git commit命令时将会自动检查。这个过程中，pre-commit会从仓库里下载代码，然后根据里面的配置执行相应的脚本。完成各种检查。\n常用命令 # 手动对所有的文件执行 hooks，新增 hook 的时候可以执行，使得代码均符合规范。直接执行该指令则无需等到 pre-commit 阶段再触发 hooks pre-commit run --all-files # 执行特定 hooks pre-commit run \u0026lt;hook_id\u0026gt; # 将所有的hook更新到最新的版本/tag pre-commit autoupdate # 指定更新 repo pre-commit autoupdate --repo https://github.com/pre-commit/mirrors-clang-format 参考资料 C++ 项目中使用 Pre-commit 协助实现代码规范检查_清欢守护者的博客-CSDN 博客\ngit push 之前自动编译验证 - 简书\n使用 pre-commit 实现代码检查_清欢守护者的博客-CSDN 博客\npre-commit\nGit 基本原理介绍 (32)——git hook 和 python_哔哩哔哩_bilibili\n","permalink":"https://lifeislife.cn/posts/git-hooks%E9%92%A9%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"\u003ch2 id=\"git-hooks-简介\"\u003eGit hooks 简介\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208271329199.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208271329199.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003eGit 能在特定的重要动作发生时触发自定义脚本。比如，\u003ccode\u003ecommit\u003c/code\u003e之前检查\u003ccode\u003ecommit message\u003c/code\u003e是否符合约定的格式，\u003ccode\u003epush\u003c/code\u003e之前检查代码格式是否正确，是否编译通过等等。Git 就提供了\u003ccode\u003ehooks\u003c/code\u003e这样的机制。\u003c/p\u003e","title":"Git hooks 钩子的使用"},{"content":"为什么需要缓存一致 目前主流电脑的 CPU 都是多核心的，多核心的有点就是在不能提升 CPU 主频后，通过增加核心来提升 CPU 吞吐量。每个核心都有自己的 L1 Cache 和 L2 Cache，只是共用 L3 Cache 和主内存。每个核心操作是独立的，每个核心的 Cache 就不是同步更新的，这样就会带来缓存一致性（Cache Coherence）的问题。\n举个例子，如图： \u003c!DOCTYPE html\u003e Responsive Image 有 2 个 CPU，主内存里有个变量x=0。CPU A 中有个需要将变量x加1。CPU A 就将变量x加载到自己的缓存中，然后将变量x加1。因为此时 CPU A 还未将缓存数据写回主内存，CPU B 再读取变量x时，变量x的值依然是0。\n这里的问题就是所谓的缓存一致性问题，因为 CPU A 的缓存与 CPU B 的缓存是不一致的。\n如何解决缓存一致性问题 通过在总线加 LOCK 锁的方式 在锁住总线上加一个 LOCK 标识，CPU A 进行读写操作时，锁住总线，其他 CPU 此时无法进行内存读写操作，只有等解锁了才能进行操作。\n该方式因为锁住了整个总线，所以效率低。\n缓存一致性协议 MESI 该方式对单个缓存行的数据进行加锁，不会影响到内存其他数据的读写。\n在学习 MESI 协议之前，简单了解一下总线嗅探机制（Bus Snooping）。要对自己的缓存加锁，需要通知其他 CPU，多个 CPU 核心之间的数据传播问题。最常见的一种解决方案就是总线嗅探。\n这个策略，本质上就是把所有的读写请求都通过总线广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。MESI 就是基于总线嗅探机制的缓存一致性协议。\nMESI 协议的由来是对 Cache Line 的四个不同的标记，分别是：\n状态 状态 描述 监听任务 Modified 已修改 该 Cache Line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中 Cache Line 必须时刻监听所有试图读该 Cache Line 相对于主存的操作，这种操作必须在缓存将该 Cache Line 写回主存并将状态改为 S 状态之前，被延迟执行 Exclusive 独享，互斥 该 Cache Line 有效，数据和内存中的数据一直，数据只存在于本 Cache Cache Line 必须监听其他缓存读主存中该 Cache Line 的操作，一旦有这种操作，该 Cache Line 需要改为 S 状态 Shared 共享的 该 Cache Line 有效，数据和内存中的数据一直，数据存在于很多个 Cache 中 Cache Line 必须监听其他 Cache Line 使该 Cache Line 无效或者独享该 Cache Line 的请求，并将 Cache Line 改为 I 状态 Invalid 无效的 该 Cache Line 无效 无 整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把各个状态之间的流转用表格总结了一下：\n当前状态 事件 行为 下个状态 M Local Read 从 Cache 中读，状态不变 M M Local Write 修改 cache 数据，状态不变 M M Remote Read 这行数据被写到内存中，使其他核能使用到最新数据，状态变为 S S M Remote Write 这行数据被写入内存中，其他核可以获取到最新数据，由于其他 CPU 修改该条数据，则本地 Cache 变为 I I 当前状态 事件 行为 下个状态 E Local Read 从 Cache 中读，状态不变 E E Local Write 修改数据，状态改为 M M E Remote Read 数据和其他 CPU 共享，变为 S S E Remote Write 数据被修改，本地缓存失效，变为 I I 当前状态 事件 行为 下个状态 S Local Read 从 Cache 中读，状态不变 S S Local Write 修改数据，状态改为 M，其他 CPU 的 Cache Line 状态改为 I M S Remote Read 数据和其他 CPU 共享，状态不变 S S Remote Write 数据被修改，本地缓存失效，变为 I I 当前状态 事件 行为 下个状态 I Local Read 1. 如果其他 CPU 没有这份数据，直接从内存中加载数据，状态变为 E；\n2. 如果其他 CPU 有这个数据，且 Cache Line 状态为 M，则先把 Cache Line 中的内容写回到主存。本地 Cache 再从内存中读取数据，这时两个 Cache Line 的状态都变为 S；\n3. 如果其他 Cache Line 有这份数据，并且状态为 S 或者 E，则本地 Cache Line 从主存读取数据，并将这些 Cache Line 状态改为 S E 或者 S I Local Write 1. 先从内存中读取数据，如果其他 Cache Line 中有这份数据，且状态为 M，则现将数据更新到主存再读取，将 Cache Line 状态改为 M；\n2. 如果其他 Cache Line 有这份数据，且状态为 E 或者 S，则其他 Cache Line 状态改为 I M I Remote Read 数据和其他 CPU 共享，状态不变 S I Remote Write 数据被修改，本地缓存失效，变为 I I ","permalink":"https://lifeislife.cn/posts/cpu%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7mesi%E5%8D%8F%E8%AE%AE/","summary":"\u003ch2 id=\"为什么需要缓存一致\"\u003e为什么需要缓存一致\u003c/h2\u003e\n\u003cp\u003e目前主流电脑的 CPU 都是多核心的，多核心的有点就是在不能提升 CPU 主频后，通过增加核心来提升 CPU 吞吐量。每个核心都有自己的 L1 Cache 和 L2 Cache，只是共用 L3 Cache 和主内存。每个核心操作是独立的，每个核心的 Cache 就不是同步更新的，这样就会带来缓存一致性（Cache Coherence）的问题。\u003c/p\u003e","title":"CPU 缓存一致性 MESI 协议"},{"content":"设置终端为 Gitbash 用惯了 Linux 终端的命令，Windows 的 shell 真的太不顺手了，但是 Gitbash 很多命令相似，可以将默认的 shell 换成 Gitbash。\n打开settings.json配置文件，添加如下\n\u0026#34;terminal.integrated.profiles.windows\u0026#34;: { \u0026#34;PowerShell -NoProfile\u0026#34;: { \u0026#34;source\u0026#34;: \u0026#34;PowerShell\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-NoProfile\u0026#34; ] }, \u0026#34;Git-Bash\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;D:\\\\Software\\\\Git\\\\bin\\\\bash.exe\u0026#34;, //bin路径下的bash，不是git-bash.exe。否则会打开外部窗口 \u0026#34;args\u0026#34;: [] } }, \u0026#34;terminal.integrated.defaultProfile.windows\u0026#34;: \u0026#34;Git-Bash\u0026#34;, \u003c!DOCTYPE html\u003e Responsive Image 修改终端配色 打开Base16 Terminal Colors for Visual Studio Code，选择一款配置复制\n\u003c!DOCTYPE html\u003e Responsive Image 打开 VScodesettings.json，替换如下\n\u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;terminal.background\u0026#34;:\u0026#34;#1C2023\u0026#34;, \u0026#34;terminal.foreground\u0026#34;:\u0026#34;#C7CCD1\u0026#34;, \u0026#34;terminalCursor.background\u0026#34;:\u0026#34;#C7CCD1\u0026#34;, \u0026#34;terminalCursor.foreground\u0026#34;:\u0026#34;#C7CCD1\u0026#34;, \u0026#34;terminal.ansiBlack\u0026#34;:\u0026#34;#1C2023\u0026#34;, \u0026#34;terminal.ansiBlue\u0026#34;:\u0026#34;#AE95C7\u0026#34;, \u0026#34;terminal.ansiBrightBlack\u0026#34;:\u0026#34;#747C84\u0026#34;, \u0026#34;terminal.ansiBrightBlue\u0026#34;:\u0026#34;#AE95C7\u0026#34;, \u0026#34;terminal.ansiBrightCyan\u0026#34;:\u0026#34;#95AEC7\u0026#34;, \u0026#34;terminal.ansiBrightGreen\u0026#34;:\u0026#34;#95C7AE\u0026#34;, \u0026#34;terminal.ansiBrightMagenta\u0026#34;:\u0026#34;#C795AE\u0026#34;, \u0026#34;terminal.ansiBrightRed\u0026#34;:\u0026#34;#C7AE95\u0026#34;, \u0026#34;terminal.ansiBrightWhite\u0026#34;:\u0026#34;#F3F4F5\u0026#34;, \u0026#34;terminal.ansiBrightYellow\u0026#34;:\u0026#34;#AEC795\u0026#34;, \u0026#34;terminal.ansiCyan\u0026#34;:\u0026#34;#95AEC7\u0026#34;, \u0026#34;terminal.ansiGreen\u0026#34;:\u0026#34;#95C7AE\u0026#34;, \u0026#34;terminal.ansiMagenta\u0026#34;:\u0026#34;#C795AE\u0026#34;, \u0026#34;terminal.ansiRed\u0026#34;:\u0026#34;#C7AE95\u0026#34;, \u0026#34;terminal.ansiWhite\u0026#34;:\u0026#34;#C7CCD1\u0026#34;, \u0026#34;terminal.ansiYellow\u0026#34;:\u0026#34;#AEC795\u0026#34; }, 修改后效果\n\u003c!DOCTYPE html\u003e Responsive Image 修改终端字体 方法一：打开 VScodesettings.json，加上下面这个配置，字体改成自己电脑上的字体\n\u0026#34;terminal.integrated.fontFamily\u0026#34;: \u0026#34;JetBrains Mono\u0026#34;, 方法二：打开设置页面，搜索terminal font\n\u003c!DOCTYPE html\u003e Responsive Image 修改后的效果\n\u003c!DOCTYPE html\u003e Responsive Image 解决中文乱码 git config --global core.quotepath false ","permalink":"https://lifeislife.cn/posts/vscode%E8%AE%BE%E7%BD%AE%E7%BB%88%E7%AB%AF%E4%B8%BAgitbash/","summary":"\u003ch2 id=\"设置终端为-gitbash\"\u003e设置终端为 Gitbash\u003c/h2\u003e\n\u003cp\u003e用惯了 Linux 终端的命令，Windows 的 shell 真的太不顺手了，但是 Gitbash 很多命令相似，可以将默认的 shell 换成 Gitbash。\u003c/p\u003e\n\u003cp\u003e打开\u003ccode\u003esettings.json\u003c/code\u003e配置文件，添加如下\u003c/p\u003e","title":"VSCode 设置终端为 Gitbash"},{"content":"预备知识 超线程技术 (Hyper-Threading)：就是利用特殊的硬件指令，把两个逻辑内核 (CPU core) 模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了 CPU 的闲置时间，提高的 CPU 的运行效率。\n我们常听到的双核四线程/四核八线程指的就是支持超线程技术的CPU.\n物理 CPU：机器上安装的实际 CPU, 比如说你的主板上安装了一个 8 核 CPU，那么物理 CPU 个数就是 1 个，所以物理 CPU 个数就是主板上安装的 CPU 个数。\n逻辑 CPU：一般情况，我们认为一颗 CPU 可以有多核，加上 Intel 的超线程技术 (HT), 可以在逻辑上再分一倍数量的 CPU core 出来；\n逻辑CPU数量 = 物理CPU数量 x CPU cores x 2(如果支持并开启HT) //前提是CPU的型号一致，如果不一致只能一个一个的加起来，不用直接乘以物理CPU数量 //比如你的电脑安装了一块4核CPU，并且支持且开启了超线程（HT）技术，那么逻辑CPU数量 = 1 × 4 × 2 = 8 Linux 下查看 CPU 相关信息, CPU 的信息主要都在/proc/cupinfo中。\n# 查看物理CPU个数 ➜ ~ cat /proc/cpuinfo|grep \u0026#34;physical id\u0026#34;|sort -u|wc -l 32 # 查看每个物理CPU中core的个数(即核数) ➜ ~ cat /proc/cpuinfo|grep \u0026#34;cpu cores\u0026#34;|uniq 1 # 或者 ➜ cat /proc/cpuinfo | grep \u0026#39;process\u0026#39; | sort | uniq | wc -l 1 # 查看逻辑CPU的个数 ➜ ~ cat /proc/cpuinfo|grep \u0026#34;processor\u0026#34;|wc -l 32 # 查看CPU的名称型号 ➜ ~ cat /proc/cpuinfo|grep \u0026#34;name\u0026#34;|cut -f2 -d:|uniq Intel Xeon Processor (Skylake, IBRS) Linux 查看某个进程运行在哪个逻辑 CPU 上\nps -eo pid,args,psr pid：进程 ID args：该进程执行时传入的命令行参数 psr：分配给进程的逻辑 CPU 例子：\n➜ ps -eo pid,args,psr | grep firefox 20118 /usr/lib/firefox/firefox -n 13 20208 /usr/lib/firefox/firefox -c 9 20266 /usr/lib/firefox/firefox -c 29 20329 /usr/lib/firefox/firefox -c 24 20499 /usr/lib/firefox/firefox -c 7 20565 /usr/lib/firefox/firefox -c 15 20596 /usr/lib/firefox/firefox -c 24 20760 /usr/lib/firefox/firefox -c 18 22110 /usr/lib/firefox/firefox -c 27 25857 /usr/lib/firefox/firefox -c 28 26347 /usr/lib/firefox/firefox -c 19 26899 /usr/lib/firefox/firefox -c 29 Linux 查看线程的 TID\nTID 就是 Thread ID，他和 POSIX 中pthread_t表示的线程 ID 完全不是同一个东西。\nLinux 中的 POSIX 线程库实现的线程其实也是一个轻量级进程 (LWP),这个 TID 就是这个线程的真实 PID.\n但是又不能通过getpid()函数获取，Linux 中定义了gettid()这个接口，但是通常都是未实现的，所以需要使用下面的方式获取 TID。\n使用 API 获取：\n#include \u0026lt;sys/syscall.h\u0026gt; pid_t tid; tid = syscall(__NR_gettid); // or syscall(SYS_gettid) 命令行方式获取：\n# 3种方法(推荐第三种方法) ➜ ps -efL | grep prog_name ➜ ls /proc/pid/task //文件夹名即TID ➜ ps -To \u0026#39;pid,lwp,psr,cmd\u0026#39; -p PID 什么是 CPU 亲和性 CPU 的亲和性 (Affinity)，属于一种调度属性，可以绑定进程到指定 CPU 上。 换句话说，就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器。\n为何会出现这种技术？在 SMP(Symmetric Multi-Processing 对称多处理) 架构下，调度器会试图保持进程在相同的 CPU 上运行，这意味着进程通常不会在处理器之间频繁迁移，进程迁移的频率小就意味着产生的负载小。\n又如，每个 CPU 本身自己会有缓存，缓存着进程使用的信息，而进程可能会被操作系统调度到其他 CPU 上，如此，CPU 缓存命中率就低了，当绑定 CPU 后，程序就会一直在指定的 CPU 跑，不会由操作系统调度到其他 CPU 上，性能有一定的提高。\n软亲和性: 就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，Linux 内核进程调度器天生就具有被称为 软 CPU 亲和性（affinity）的特性，这意味着进程通常不会在处理器之间频繁迁移。这种状态正是我们希望的，因为进程迁移的频率小就意味着产生的负载小。\n硬亲和性：简单来说就是利用 Linux 内核提供给用户的 API，强行将进程或者线程绑定到某一个指定的 CPU 核运行。\nCPU affinity 使用位掩码 (bitmask) 表示，每一位都表示一个 CPU, 置 1 表示\u0026quot;绑定\u0026quot;。最低位表示第一个逻辑 CPU, 最高位表示最后一个逻辑 CPU。\nCPU affinity 典型的表示方法是使用 16 进制，具体如下。\n0b00000000000000000000000000000001 = 0x00000001 表示 processor #0 0b00000000000000000000000001010101 = 0x00000055 表示 processors #0, #2, #4, #6 0b11111111111111111111111111111111 = 0xFFFFFFFF 表示所有 processors (#0 through #31) 使用taskset命令设置 CPU 亲和性 命令行形式\ntaskset [options] mask command [arg]... taskset [options] -p [mask] pid 参数解析 [OPTIONS]taskset 的可选参数\n-a, --all-tasks (旧版本中没有这个选项) 这个选项涉及到了linux中TID的概念,他会将一个进程中所有的TID都执行一次CPU亲和性设置. TID 就是 Thread ID，他和 POSIX 中 pthread_t 表示的线程 ID 完全不是同一个东西。 Linux中的POSIX线程库实现的线程其实也是一个进程(LWP),这个TID就是这个线程的真实PID.\n-p, --pid 操作已存在的PID,而不是加载一个新的程序\n-c, --cpu-list 声明CPU的亲和力使用数字表示而不是用位掩码表示. 例如 0,5,7,9-11.\n-h, --help 显示帮助信息\n-V, --version 显示版本信息\nmask : cpu 亲和性，当没有-c选项时，其值前无论有没有0x标记都是 16 进制的，当有-c选项时，其值是十进制的。\ncommand : 命令或者可执行程序\npid : 进程 ID，可以通过ps/top/pidof等命令获取\n[arg] command 的参数\n实例 使用指定的 CPU 亲和性运行一个新程序 taskset [-c] mask command [arg]... # 举例: 使用CPU0运行ls命令显示/etc/init.d下的所有内容 taskset -c 0 ls -al /etc/init.d/ 显示已经运行的进程的 CPU 亲和性 taskset -p pid # 举例:查看init进程(PID=1)的CPU亲和性 taskset -p 1 改变已经运行进程的 CPU 亲和性 taskset -p[c] mask pid 举例:打开2个终端,在第一个终端运行top命令,第二个终端中 首先运行:[~]# ps -eo pid,args,psr | grep top #获取top命令的pid和其所运行的CPU号 其次运行:[~]# taskset -cp 新的CPU号 pid #更改top命令运行的CPU号 最后运行:[~]# ps -eo pid,args,psr | grep top #查看是否更改成功 ➜ ~ ps -eo pid,args,psr | grep top 2501 nautilus-desktop 24 2634 /usr/libexec/xdg-desktop-po 18 2658 /usr/libexec/xdg-desktop-po 11 23848 top 6 ➜ ~ taskset -cp 10 23848 pid 23848\u0026#39;s current affinity list: 0-31 pid 23848\u0026#39;s new affinity list: 10 ➜ ~ ps -eo pid,args,psr | grep top 2501 nautilus-desktop 24 2634 /usr/libexec/xdg-desktop-po 18 2658 /usr/libexec/xdg-desktop-po 11 23848 top 10 一个用户要设定一个进程的 CPU 亲和性，如果目标进程是该用户的，则可以设置，如果是其他用户的，则会设置失败，提示 Operation not permitted.当然 root 用户没有任何限制。 任何用户都可以获取任意一个进程的 CPU 亲和性。\n程序 API 实现硬亲和性 以下实验使用的源码可以从这个仓库获取。\n以下是一些设置亲和性时会用到的宏定义及函数：\n#define _GNU_SOURCE #include \u0026lt;sched.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; //注意\u0026lt;pthread.h\u0026gt;包含\u0026lt;sched.h\u0026gt; /* MACRO */ // 对 CPU 集初始化，将其设置为空集 void CPU_ZERO(cpu_set_t *set); void CPU_ZERO_S(size_t setsize, cpu_set_t *set); // 将 CPU 加入到 CPU 集中 void CPU_SET(int cpu, cpu_set_t *set); void CPU_SET_S(int cpu, size_t setsize, cpu_set_t *set); // 将 CPU 从 CPU 集中移除 void CPU_CLR(int cpu, cpu_set_t *set); void CPU_CLR_S(int cpu, size_t setsize, cpu_set_t *set); // 判断 CPU 是否在 CPU 集中 int CPU_ISSET(int cpu, cpu_set_t *set); int CPU_ISSET_S(int cpu, size_t setsize, cpu_set_t *set); // 计算 CPU 集的大小 void CPU_COUNT(cpu_set_t *set); void CPU_COUNT_S(size_t setsize, cpu_set_t *set); // The following macros perform logical operations on CPU sets /* Store the logical AND of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */ void CPU_AND(cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2); void CPU_AND_S(size_t setsize, cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2); /* Store the logical OR of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */ void CPU_OR(cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2); void CPU_OR_S(size_t setsize, cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2); /* Store the logical XOR of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */ void CPU_XOR(cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2); void CPU_XOR_S(size_t setsize, cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2); /* Test whether two CPU set contain exactly the same CPUs. */ int CPU_EQUAL(cpu_set_t *set1, cpu_set_t *set2); int CPU_EQUAL_S(size_t setsize, cpu_set_t *set1, cpu_set_t *set2); /* The following macros are used to allocate and deallocate CPU sets: */ /* Allocate a CPU set large enough to hold CPUs in the range 0 to num_cpus-1 */ cpu_set_t *CPU_ALLOC(int num_cpus); /* Return the size in bytes of the CPU set that would be needed to hold CPUs in the range 0 to num_cpus-1. This macro provides the value that can be used for the setsize argument in the CPU_*_S() macros */ size_t CPU_ALLOC_SIZE(int num_cpus); /* Free a CPU set previously allocated by CPU_ALLOC(). */ void CPU_FREE(cpu_set_t *set); /* API */ /*该函数设置进程为 pid 的这个进程，让它运行在 mask 所设定的 CPU 上。如果 pid 的值为 0, *则表示指定的是当前进程，使当前进程运行在 mask 所设定的那些 CPU 上. *第二个参数 cpusetsize 是 mask 所指定的数的长度。通常设定为 sizeof(cpu_set_t). *如果当前 pid 所指定的进程此时没有运行在 mask 所指定的任意一个 CPU 上， *则该指定的进程会从其它 CPU 上迁移到 mask 的指定的一个 CPU 上运行. */ int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask); /*该函数获得 pid 所指示的进程的 CPU 位掩码，并将该掩码返回到 mask 所指向的结构中. *即获得指定 pid 当前可以运行在哪些 CPU 上. *同样，如果 pid 的值为 0.也表示的是当前进程 */ int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask); /* set CPU affinity attribute in thread attributes object */ int pthread_attr_setaffinity_np(pthread_attr_t *attr, size_t cpusetsize, const cpu_set_t *cpuset); /* get CPU affinity attribute in thread attributes object */ int pthread_attr_getaffinity_np(const pthread_attr_t *attr, size_t cpusetsize, cpu_set_t *cpuset); /* set CPU affinity of a thread */ int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset); /* get CPU affinity of a thread */ int pthread_getaffinity_np(pthread_t thread, size_t cpusetsize, cpu_set_t *cpuset); 程序中会使用syscall来获取一些内核数据，syscall是执行一个系统调用，根据指定的参数number和所有系统调用的接口来确定调用哪个系统调用，用于用户空间跟内核之间的数据交换，下面是syscall函数原型及一些常用的number：\n//syscall - indirect system call #define _GNU_SOURCE /* See feature_test_macros(7) */ #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; /* For SYS_xxx definitions */ int syscall(int number, ...); // 查看缓存内存页面的大小；打印用%ld 长整型。 sysconf(_SC_PAGESIZE); // 查看内存的总页数；打印用%ld 长整型。 sysconf(_SC_PHYS_PAGES) // 查看可以利用的总页数；打印用%ld 长整型。 sysconf(_SC_AVPHYS_PAGES) // 查看 CPU 的个数；打印用%ld 长整。 sysconf(_SC_NPROCESSORS_CONF) // 查看在使用的 CPU 个数；打印用%ld 长整。 sysconf(_SC_NPROCESSORS_ONLN) // 计算内存大小。 (long long)sysconf(_SC_PAGESIZE) * (long long)sysconf(_SC_PHYS_PAGES) // 查看最大登录名长度；打印用%ld 长整。 sysconf(_SC_LOGIN_NAME_MAX) // 查看最大主机长度；打印用%ld 长整。 sysconf(_SC_HOST_NAME_MAX) // 每个进程运行时打开的文件数目；打印用%ld 长整。 sysconf(_SC_OPEN_MAX) // 查看每秒中跑过的运算速率；打印用%ld 长整。 sysconf(_SC_CLK_TCK) 使用 2 种方式 (带和不带_S 后缀的宏) 获取当前进程的 CPU 亲和性 相关的宏通常都分为 2 种，一种是带_S后缀的，一种不是不带_S后缀的，从声明上看带_S后缀的宏都多出一个参数 setsize。\n从功能上看他们的区别是带_S后缀的宏是用于操作动态申请的CPU set(s)，所谓的动态申请其实就是使用宏 CPU_ALLOC 申请，\n参数 setsize 可以是通过宏 CPU_ALLOC_SIZE 获得，两者的用法详见下面的例子。\n#define _GNU_SOURCE #include \u0026lt;sched.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #undef WITH_S #ifdef WITH_S int main(void) { int i, nrcpus; cpu_set_t *pmask; size_t cpusize; unsigned long bitmask = 0; /* 获取逻辑 CPU 个数 */ nrcpus = sysconf(_SC_NPROCESSORS_CONF); pmask = CPU_ALLOC(nrcpus); cpusize = CPU_ALLOC_SIZE(nrcpus); CPU_ZERO_S(cpusize, pmask); /* 获取 CPU 亲和性 */ if (sched_getaffinity(0, cpusize, pmask) == -1) { perror(\u0026#34;sched_getaffinity\u0026#34;); CPU_FREE(pmask); exit(EXIT_FAILURE); } for (i = 0; i \u0026lt; nrcpus; i++) { if (CPU_ISSET_S(i, cpusize, pmask)) { bitmask |= (unsigned long)0x01 \u0026lt;\u0026lt; i; printf(\u0026#34;processor #%d is set\\n\u0026#34;, i); } } printf(\u0026#34;bitmask = %#lx\\n\u0026#34;, bitmask); CPU_FREE(pmask); exit(EXIT_SUCCESS); } #else int main(void) { int i, nrcpus; cpu_set_t mask; unsigned long bitmask = 0; CPU_ZERO(\u0026amp;mask); /* 获取 CPU 亲和性 */ if (sched_getaffinity(0, sizeof(cpu_set_t), \u0026amp;mask) == -1) { perror(\u0026#34;sched_getaffinity\u0026#34;); exit(EXIT_FAILURE); } /* 获取逻辑 CPU 个数 */ nrcpus = sysconf(_SC_NPROCESSORS_CONF); for (i = 0; i \u0026lt; nrcpus; i++) { if (CPU_ISSET(i, \u0026amp;mask)) { bitmask |= (unsigned long)0x01 \u0026lt;\u0026lt; i; printf(\u0026#34;processor #%d is set\\n\u0026#34;, i); } } printf(\u0026#34;bitmask = %#lx\\n\u0026#34;, bitmask); exit(EXIT_SUCCESS); } #endif # 直接运行，不设置亲和性，获取CPU亲和性为所有CPU都会被设置 ➜ Affinity git:(main) ./bin/main processor #0 is set processor #1 is set processor #2 is set processor #3 is set processor #4 is set processor #5 is set processor #6 is set processor #7 is set processor #8 is set processor #9 is set processor #10 is set processor #11 is set processor #12 is set processor #13 is set processor #14 is set processor #15 is set processor #16 is set processor #17 is set processor #18 is set processor #19 is set processor #20 is set processor #21 is set processor #22 is set processor #23 is set processor #24 is set processor #25 is set processor #26 is set processor #27 is set processor #28 is set processor #29 is set processor #30 is set processor #31 is set bitmask = 0xffffffff # 使用taskset设置亲和性，将main程序绑定到第1个CPU上，mask转化为16进制为0x1 ➜ Affinity git:(main) taskset 1 ./bin/main processor #0 is set bitmask = 0x1 # 使用taskset设置亲和性，将main程序绑定到第1,3,5,7个CPU上，mask转化为16进制为0x55 ➜ Affinity git:(main) taskset 55 ./bin/main processor #0 is set processor #2 is set processor #4 is set processor #6 is set bitmask = 0x55 # 使用taskset设置亲和性，将main程序绑定到第1,2,3,4个CPU上，mask转化为16进制为0xf ➜ Affinity git:(main) taskset F ./bin/main processor #0 is set processor #1 is set processor #2 is set processor #3 is set bitmask = 0xf 设置进程的 CPU 亲和性后再获取显示 CPU 亲和性 #define _GNU_SOURCE #include \u0026lt;sched.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; /* sysconf */ #include \u0026lt;stdlib.h\u0026gt; /* exit */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int i, nrcpus; cpu_set_t mask; unsigned long bitmask = 0; CPU_ZERO(\u0026amp;mask); CPU_SET(0, \u0026amp;mask); /* add CPU0 to cpu set */ CPU_SET(2, \u0026amp;mask); /* add CPU2 to cpu set */ CPU_SET(3, \u0026amp;mask); /* add CPU3 to cpu set */ /* 设置 CPU 亲和性 */ if (sched_setaffinity(0, sizeof(cpu_set_t), \u0026amp;mask) == -1) { perror(\u0026#34;sched_setaffinity\u0026#34;); exit(EXIT_FAILURE); } CPU_ZERO(\u0026amp;mask); if (sched_getaffinity(0, sizeof(cpu_set_t), \u0026amp;mask) == -1) { perror(\u0026#34;sched_getaffinity\u0026#34;); exit(EXIT_FAILURE); } /* get logical cpu number */ nrcpus = sysconf(_SC_NPROCESSORS_CONF); for (i = 0; i \u0026lt; nrcpus; i++) { if (CPU_ISSET(i, \u0026amp;mask)) { bitmask |= (unsigned long)0x01 \u0026lt;\u0026lt; i; printf(\u0026#34;processor #%d is set\\n\u0026#34;, i); } } printf(\u0026#34;bitmask = %#lx\\n\u0026#34;, bitmask); exit(EXIT_SUCCESS); } ➜ Affinity git:(main) ✗ ./bin/main processor #0 is set processor #2 is set processor #3 is set bitmask = 0xd 设置线程的 CPU 属性后再获取显示 CPU 亲和性 #define _GNU_SOURCE #include \u0026lt;pthread.h\u0026gt; //不用再包含\u0026lt;sched.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #define handle_error_en(en, msg) \\ do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0) int main(int argc, char *argv[]) { int s, j; cpu_set_t cpuset; pthread_t thread; thread = pthread_self(); /* Set affinity mask to include CPUs 0 to 7 */ CPU_ZERO(\u0026amp;cpuset); for (j = 0; j \u0026lt; 8; j++) CPU_SET(j, \u0026amp;cpuset); s = pthread_setaffinity_np(thread, sizeof(cpu_set_t), \u0026amp;cpuset); if (s != 0) { handle_error_en(s, \u0026#34;pthread_setaffinity_np\u0026#34;); } /* Check the actual affinity mask assigned to the thread */ s = pthread_getaffinity_np(thread, sizeof(cpu_set_t), \u0026amp;cpuset); if (s != 0) { handle_error_en(s, \u0026#34;pthread_getaffinity_np\u0026#34;); } printf(\u0026#34;Set returned by pthread_getaffinity_np() contained:\\n\u0026#34;); for (j = 0; j \u0026lt; CPU_SETSIZE; j++) //CPU_SETSIZE 是定义在\u0026lt;sched.h\u0026gt;中的宏，通常是 1024 { if (CPU_ISSET(j, \u0026amp;cpuset)) { printf(\u0026#34; CPU %d\\n\u0026#34;, j); } } exit(EXIT_SUCCESS); } ➜ Affinity git:(main) ./bin/main Set returned by pthread_getaffinity_np() contained: CPU 0 CPU 1 CPU 2 CPU 3 CPU 4 CPU 5 CPU 6 CPU 7 使用 seched_setaffinity 设置线程的 CPU 亲和性 #define _GNU_SOURCE #include \u0026lt;sched.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; // syscall int main(void) { pid_t tid; int i, nrcpus; cpu_set_t mask; unsigned long bitmask = 0; CPU_ZERO(\u0026amp;mask); CPU_SET(0, \u0026amp;mask); /* add CPU0 to cpu set */ CPU_SET(2, \u0026amp;mask); /* add CPU2 to cpu set */ // 获取线程 id tid = syscall(__NR_gettid); // or syscall(SYS_gettid); // 对指定线程 id 设置 CPU 亲和性 if (sched_setaffinity(tid, sizeof(cpu_set_t), \u0026amp;mask) == -1) { perror(\u0026#34;sched_setaffinity\u0026#34;); exit(EXIT_FAILURE); } nrcpus = sysconf(_SC_NPROCESSORS_CONF); for (i = 0; i \u0026lt; nrcpus; i++) { if (CPU_ISSET(i, \u0026amp;mask)) { bitmask |= (unsigned long)0x01 \u0026lt;\u0026lt; i; printf(\u0026#34;processor #%d is set\\n\u0026#34;, i); } } exit(EXIT_SUCCESS); } ➜ Affinity git:(main) ./bin/main processor #0 is set processor #2 is set 什么是中断亲和性 计算机中，中断是一种电信号，由硬件产生并直接送到中断控制器上，再由中断控制器向 CPU 发送中断信号，CPU 检测到信号后，中断当前工作转而处理中断信号。CPU 会通知操作系统已经产生中断，操作系统就会对中断进行处理。 这里有篇推文：CPU 明明 8 个核，网卡为啥拼命折腾一号核？生动的解释了中断亲和性。\n默认情况下，Linux 中断响应会被平均分配到所有 CPU 核心上，势必会发生写新的数据和指令缓存，并与 CPU 核心上原有进程产生冲突，造成中断响应延迟，影响进程处理时间。为了解决这个问题，可以将中断（或进程）绑定到指定 CPU 核心上，中断（或进程）所需要指令代码和数据有更大概率位于指定 CPU 本地数据和指令缓存内，而不必进行新的写缓存，从而提高中断响应（或进程）的处理速度。\n中断亲和性的使用场景 对于文件服务器、Web 服务器，把不同的网卡 IRQ 均衡绑定到不同的 CPU 上将会减轻某 CP 的负载，提高多个 CPU 整体处理中断的能力; 对于数据库服务器，把磁盘控制器绑到一个 CPU、把网卡绑定到另一个 CPU 将会提高数据库的响应时间、优化性能。\n合理的根据自己的生产环境和应用的特点来平衡 IRQ 中断有助于提高系统的整体吞吐能力和性能。\n中断绑定流程 关闭中断平衡守护进程 中断平衡守护进程（irqbalance daemon）会周期性地将中断平均地公平地分配给各个 CPU 核心，默认开启。为了实现中断绑定，首先需要将中断平衡守护进程关闭。\nsystemctl status irqbalance查看守护进程的运行状态 ➜ ~ systemctl status irqbalance ● irqbalance.service - irqbalance daemon Loaded: loaded (/lib/systemd/system/irqbalance.service; enabled; vendor preset: enable Active: active (running) since Thu 2022-05-19 14:46:20 CST; 1 weeks 1 days ago Main PID: 1062 (irqbalance) Tasks: 2 (limit: 4915) CGroup: /system.slice/irqbalance.service └─1062 /usr/sbin/irqbalance --foreground 5月 19 14:46:20 zdd systemd[1]: Started irqbalance daemon. systemctl stop irqbalance关闭中断平衡守护进程，中断响应默认都会由 CPU0 核心处理。或者systemctl disable irqbalance取消中断平衡守护进程开机重启。因为关闭中断平衡守护进程过于强硬，可以在不关闭中断平衡守护进程条件下，让某些 CPU 核心脱离中断平衡守护进程的管理。 绑定中断 中断绑定时，需要关闭系统中断平衡守护进程systemctl stop irqbalance计算机当前各种中断响应情况在 /proc/interrupts 文件中。\n\u003c!DOCTYPE html\u003e Responsive Image 第一列是中断 ID 号，CPU N 列是中断在第 n 个 CPU 核心上的响应次数，倒数第二列是中断类型，最后一列是描述。\n利用 echo 命令将 CPU 掩码写入 /proc/irq/中断 ID/smp_affinity 文件中，即可实现修改某一中断的 CPU 亲和性。例如\necho 0x0004 \u0026gt; /proc/irq /50/smp_affinity 参考资料 Linux 中 CPU 亲和性 (affinity) - LubinLew - 博客园 操作系统底层技术——CPU 亲和性_mb60ed33cfc44fa 的技术博客_51CTO 博客 linux 进程、线程与 CPU 的亲和性（affinity）_wx61d68abba262d 的技术博客_51CTO 博客 CPU 明明 8 个核，网卡为啥拼命折腾一号核？ Processor affinity - Wikipedia 什么？一个核同时执行两个线程？ linux 进程、线程与 CPU 的亲和性（affinity） - zhangwju - 博客园\n","permalink":"https://lifeislife.cn/posts/cpu%E4%BA%B2%E5%92%8C%E6%80%A7%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%BA%B2%E5%92%8C%E6%80%A7/","summary":"\u003ch2 id=\"预备知识\"\u003e预备知识\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://mp.weixin.qq.com/s/HwDqCk8vtMdSEVSCLHAsbg\"\u003e超线程技术 (Hyper-Threading)\u003c/a\u003e：就是利用特殊的硬件指令，把两个逻辑内核 (CPU core) 模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了 CPU 的闲置时间，提高的 CPU 的运行效率。\u003c/p\u003e","title":"CPU 亲和性与中断亲和性"},{"content":"内存 也就是内部存储器，主要用来运行程序的，典型的就是 RAM 随机存储器（Random Access Memory），那么随机是什么意思？所谓随机，指的是当存储器中的数据被读取或写入时，所需要的时间与这段信息所在的位置无关（任何位置读写速度一样）。\nDRAM（Dynamic Random Access Memory，动态随机存储器）是最为常见的系统内存。我们使用的电脑和手机的运行内存都是 DRAM。DRAM 使用电容存储，DRAM 只能将数据保持很短的时间。为了保持数据，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。数据的存储，请参考数据存储模型。我们知道，电容中的电荷很容易变化，所以随着时间推移，电容中的电荷数会增加或减少，为了确保数据不会丢失，DRAM 每隔一段时间会给电容刷新（充电或放电）。动态：定时刷新数据\nSRAM（Static Random Access Memory，静态随机存储器），它是一种具有静止存取功能的内存，其内部机构比 DRAM 复杂，可以做到不刷新电路即能保存它内部存储的数据。静态：不需要刷新\nDDR SDRAM（Double Data Rate SDRAM）：为双信道同步动态随机存取内存，是新一代的 SDRAM 技术。DDR 内存芯片的数据预取宽度（Prefetch）为 2 bit（SDRAM 的两倍）。\nDDR2 SDRAM（Double Data Rate Two SDRAM）：为双信道两次同步动态随机存取内存。DDR2 内存 Prefetch 又再度提升至 4 bit（DDR 的两倍）\nDDR3 SDRAM（Double Data Rate Three SDRAM）：为双信道三次同步动态随机存取内存。DDR3 内存 Prefetch 提升至 8 bit，即每次会存取 8 bits 为一组的数据。运算频率介于 800MHz -1600MHz 之间。\n\u003c!DOCTYPE html\u003e Responsive Image 外存 外部存储器，通常用来存储文件的，一般也叫 ROM（Read-only memory）只读存储器。\nCPU 连接内存和外存的连接方式不同。内存需要直接地址访问，所以是通过地址总线\u0026amp;数据总线的总线式访问方式连接的（好处是直接访问，随机访问；坏处是占用 CPU 的地址空间，大小受限）；外存是通过 CPU 的外存接口来连接的（好处是不占用 CPU 的地址空间，坏处是访问速度没有总线式快，访问时序较复杂）\n我们平时用的硬盘，SD 卡都属于 ROM，但是他们却可以写入？ROM 严格意义来讲确实是只读的，但是随着储存器的发展，出现了可擦可编程只读存储器（EPROM）、电可擦可编程只读存储器（EEPROM）形式的半导体存储器，以及 flash。他们都是可写的。ROM 就不再单单只表示只读存储器了，一般来说与 RAM 相对，掉电不易失的存储器都被当做 ROM。\nROM ROM（Read Only Memory）只读存储器，这种存储器（Memory）的内容任何情况下都不会改变，电脑与用户只能读取保存在这里的指令，和使用存储在 ROM 的资料，但不能变更或存入资料。ROM 被存储在一个非易失性芯片上，也就是说，即使在关机之后记忆的内容仍可以被保存，所以这种存储器多用来存储特定功能的程序，如固件。ROM 存储用来启动电脑的程序（如BIOS），电脑引导的时候 BIOS 提供一连串的指令对中央处理器（CPU）等组件进行初始化，在初始化过程中，BIOS 程序初始化并检查RAM。\nNorFlash 总线式访问，接到 SROM bank，优点是可以直接总线访问，一般用来启动。\nNandFlash SLC：容量小，价格高，稳定性高\nMLC：容量大，价格低，稳定性差，易出坏块\niNand SanDisk 公司出产的 eMMC\nmoviNand 三星公司出产的 eMMC\noneNAND 三星公司出的一种 Nand，价格贵，用的少\nSD 卡（Secure Digital Memory Card）\n\u003c!DOCTYPE html\u003e Responsive Image TF 卡（TransFLash Card, MicroSD）\n\u003c!DOCTYPE html\u003e Responsive Image MMC 卡\n\u003c!DOCTYPE html\u003e Responsive Image eMMC 卡（embeded MMC） 嵌入式的 MMC，可以当成一种芯片，内部做了坏块处理\nSATA 硬盘\n特点：机械式访问、磁存储原理、SATA 是接口。\n","permalink":"https://lifeislife.cn/posts/soc%E5%AD%98%E5%82%A8%E5%99%A8%E6%AF%94%E8%BE%83/","summary":"\u003ch2 id=\"内存\"\u003e内存\u003c/h2\u003e\n\u003cp\u003e也就是内部存储器，主要用来运行程序的，典型的就是 RAM 随机存储器（Random Access Memory），那么随机是什么意思？所谓随机，指的是当存储器中的数据被读取或写入时，所需要的时间与这段信息所在的位置无关（任何位置读写速度一样）。\u003c/p\u003e","title":"SoC 存储器比较"},{"content":" 对 Interlaken 协议文档的翻译加了一些自己的理解；\n8b/10b编码：在串行通道上传输时，将 8bits 数据编码为 10bits 数据，做一个转换，使各位数据之间有更多的 1 到 0 和 0 到 1 的跳变，以便接收设备检测这些跳变，能更容易地恢复时钟。64B/67B 编码编码的原因也是类似的。这样，在串行通道上传输 10 位数据，实际上只传输了 8 位。\n协议层（Protocol Layer） 传输格式 数据通过可配置数量的 SerDes 通道（Lane），再由 Interlaken 接口传输。在本文档中，通道被定义为两个 IC 之间的单工串行链路（simplex serial link）。该协议旨在与任意数量的通道一起运行（1 个或多个，没有上限）。实际实现时会固定一个数值，不会设计为可变值。\n接口发送数据的基本单位是一个 8 字节的字（Word）。用 8 字节是为了符合64B/67B 编码，用于描述突发（Burst）的控制字的大小也是 8 字节。通过使基本传输单元与控制字大小相等，可以很容易地调整接口的宽度。\n数据和控制字按顺序在通道上传输，从通道 0 开始，到通道 M 结束，并在下一个数据块中重复。图 4 说明了该过程\n\u003c!DOCTYPE html\u003e Responsive Image 64B/67B编码在每个通道上独立进行。传输通过两种基本数据类型实现：数据字和控制字，他们通过64B/67B 帧位（framing bits）进行区分。这两种数据字类型的格式如下图所示：\n\u003c!DOCTYPE html\u003e Responsive Image 数据和控制信息都是以位 66～0 的顺序传输的，框架层引入了 4 个附加控制字，详细信息后面将描述。\nBurst 结构（Burst Structure） 数据传输流程 Interlaken 接口的带宽在支持的通道上被划分为 Bursts。数据包通过一个或多个 Burst 在接口上传输。Burst 通过一个或多个控制字来描述。为了将任意大小的数据包分割成 Burst，定义以下两个参数：\nBurstMax：Burst 的最大大小（64Bytes 的倍数） BurstShort：Burst 的最小大小（最小 32Bytes，增量为 8Bytes） 该接口通常通过发送一个 BurstMax 长度的数据突发来运行，然后是一个控制字。发送设备中的调度逻辑可以自由选择信道服务的顺序，受流控状态的约束。Burst 在每个通道上传输，直到数据包完全传输，此时该通道上的新数据包传输才开始。\n因为接口是信道化的，数据包的结束可能会在几个信道上连续地出现，每个信道上的剩余数据量非常小。由于发射器和接收器的存储器可能被理想地设计成宽数据通路，它们需要以非常高的速率来处理这种情况。为了减少接收器和发射器的负担，BurstShort 参数保证了连续的 Burst 控制字之间的最小间隔。最小的 BurstShort 间隔是 32 字节，更大的值可以以 8 字节为增量。\n如果没有最小 Burst 的限制，那么数据包太小的话，发送器或者接收器就会频繁收到 end-of-packet，这就增加了处理负担。\n\u003c!DOCTYPE html\u003e Responsive Image 控制字格式 突发通过一个 8 字节的控制字来描述。控制字在数据流中通过使用位 [66:64] 的“0x10”控制代码和位 [63] = \u0026lsquo;1\u0026rsquo; 来标识突发和空闲控制字格式如第 16 页的图 7 所示：\n\u003c!DOCTYPE html\u003e Responsive Image 流控（Flow Control） Interlaken 的一个关键特性是能够传达每个通道背压（backpressure）。为了提供此功能，指定了两个选项：带外流控接口和带内通道。从语义上讲，流控制信息使用简单的开关机制来表示允许在特定通道上传输。\n开关流控制状态与每个通道的单个状态位进行通信。按照惯例，“1”标识“XON”状态，表示允许发送器在该通道上发送数据。 “0”标识“XOFF”状态，表示发送器不允许在该通道上发送数据。\n该协议没有 Credits 的概念；一旦通道被指示为 XON，发送器可以在该通道上发送尽可能多的数据，直到流控制状态更改为 XOFF。接收器选择在 XON 和 XOFF 状态之间切换的阈值是留给用户的可编程选项，取决于支持的通道数量、接收缓冲区的深度和给定环境的流控制延迟。\n流控制通道可以选择映射到 calendar，从而流控制可以映射到任何一组 calendar entry。例如，这些可以包括通道到 calendar entry 的一对一映射、一对多映射或插入空字段以匹配具有不同通道定义的设备。\nChannel Calendar 将通道映射到流控状态槽\n这个 Calendar 结构也可以用来提供链路级的流控制，Calendar 中的一个 bit 代表了在整个接口上传输数据的权限。链路状态的极性将与通道状态的极性相同：“1”表示允许传输，“0”表示立即停止传输。要启用此功能，可以为每个 Calendar entry 配置通道信息或链接信息。为了促进低延迟链路状态，接口需要提供足够的 Calendar entry，以便在每个突发/空闲控制字的相同位位置编程链路状态。例如，使用超过 16 个通道，这可以通过以下设置执行：\n\u003c!DOCTYPE html\u003e Responsive Image 使用此方法，link status将始终出现在突发/空闲控制字的位[55]中。\n带外流控 为了支持需要单工操作的系统，定义了带外流量控制选项。这是作为一个源同步接口实现的，并由以下信号指定：\n型号名称 功能 FC_CLK 与流控数据同步的时钟 FC_DATA 流量控制状态信息 (单比特) FC_SYNC 一种同步信号，用于标识流控制 calendar 的开头 每个信号的 pad 技术可以是 LVDS 或 LVCMOS。这些信号的逻辑时序关系如下图所示：\n\u003c!DOCTYPE html\u003e Responsive Image 带外流控制通道由 4 位 CRC 计算保护，该 CRC 计算覆盖了多达 64 位的流控制数据。根据^[P. Koopman and T. Chakravarty, Cyclic Redundancy Code (CRC) Polynomial Selection for Embedded Networks, The International Conference on Dependable Networks and Systems, DSN-2004.] 中的建议，CRC4 多项式为：\n$$ x^4+x+1 $$\n带内流控 当使用此选项时，接收器利用通过接口发送的控制字中的流控制状态，作为正常数据传输的一部分。提供此选项的目的是，需要最少数量的外部信号引脚的全双工实现。\n如 Figure 7 所示，控制字的流控制字段为 16 位，位于 bit[55:40]。控制字的位 [31:24] 也可以用于流控制的另外 8 位，总共 24 位。这些状态位表示每个 Interlaken Calendar 通道的 ON-OFF 流控制状态，当前 Calendar Entry X 在位 [55]，Calendar Entry X + 1 在位 [54]，依此类推。为了同步 calendar 的开始，在空闲/突发控制字中提供了“reset calendar”位。当该位为“1”时，calendar entry 0 的状态将出现在位 [55] 中。当“reset calendar”为“0”时，calendar 将从上一个控制字中保留的位置开始继续。当所有通道的流控状态被传输完，发送器将重置复位 calendar，然后重复上一轮顺序操作。Calendar 最后一个控制字中不需要的 bit（即，当通道数目不是状态数目的倍数时）被发送端置 0，接收端忽略。\n参考资料 ","permalink":"https://lifeislife.cn/posts/interlaken%E5%8D%8F%E8%AE%AE/","summary":"\u003cblockquote\u003e\n\u003cp\u003e对 Interlaken 协议文档的翻译加了一些自己的理解；\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e8b/10b编码\u003c/strong\u003e：在串行通道上传输时，将 8bits 数据编码为 10bits 数据，做一个转换，使各位数据之间有更多的 1 到 0 和 0 到 1 的跳变，以便接收设备检测这些跳变，能更容易地恢复时钟。\u003cstrong\u003e64B/67B 编码\u003c/strong\u003e编码的原因也是类似的。这样，在串行通道上传输 10 位数据，实际上只传输了 8 位。\u003c/p\u003e","title":"Interlaken 协议"},{"content":"AXI 组成部分：\nAXI4 协议中包含五种信道，通道之间相互独立且存在差别，通过通道进行通信之前需要使用 VALID/READY 进行握手，Read 和 Write 根据 Master 定义：\n读地址信道（Read Address Channel） 写地址信道（Write Address Channel） 读数据信道（Read Data Channel） 写数据信道（Write Data Channel） 写响应信道（Write Response Channel） 还有两种 Component\nMaster component Slave component 通信由 Master 发起，Master 可以对 Slave 进行读数据（read）或写（write）数据。每次读写操作都需要一个地址，读地址信道（Read Address Channel）和写地址信道（Write Address Channel）用于传输地址。在写完数据后，Master 需要确认 Slave 有没有收完数据，Slave 收到完整数据后，会通过写响应信道（Write Response Channel）给 Master 一个反馈（completion），表示写操作已经完成。\nVALID/READY 握手机制 AXI 五个信道相互独立，但是使用同一个握手机制来实现信息传递。\n在握手机制中，通信双方分别扮演发送方(Source) 和接收方（Destination），两者的操作（技能）并不相同。\n发送方置高 VALID 信号表示发送方已经将数据，地址或者控制信息已经就绪，并保持于消息总线上。\n接收方置高 READY 信号表示接收方已经做好接收的准备。\n当双方的 VALID/READY 信号同时为高，在时钟 ACLK 上升沿，完成一次数据传输。所有数据传输完毕后，双方同时置低自己的信号。\n每个通道都有自己的 VALID /READY 握手信号对：\n\u003c!DOCTYPE html\u003e Responsive Image 在握手过程中，还会用到 LAST 信号。LAST 信号存在 Write Data Channel 和 Read Data Channel 中，分别表示为 WLAST 和 RLAST，用于标记 burst 的最后一次数据传输，当 slave 接收到 LAST 信号后，说明本次数据传输完成。\n双向流控 所谓的双向流控机制，指的是发送方通过置起 VALID 信号控制发送的时机与速度，接收方也可以通过 READY 信号的置起与否控制接收速度。\n发送方拥有传输的主动权，但接收方在不具备接收能力时，也能够置低信号停止传输，反压发送方。\n握手过程分析 图中 INFORMATION 信号无底色区域表示此时数据已经准备好，已经有新的数据到达。\nVALID 信号先到\n发送方 VALID 信号早早就到了，但是接收方的 READY 信号在 T2 之前都没有发送。可能接收方在接收其他数据，或者被堵在数据通路上。\n过了 T2 后，READY 信号到来，此时开始传输，直到 T3 结束，传输完成。\n这里也体现了双向流控机制，发送方的 VALID 信号只要置高，再握手完成之前都不能置低，必须等到接收方 READY 信号置高。\n\u003c!DOCTYPE html\u003e Responsive Image READY 信号先到\nREADY 信号很自由，可以等待 VALID 信号到来再做响应，但也完全可以在 VALID 信号到来前就置高，表示接收端已经做好准备了。\n而且，READY 信号与 VALID 不同，接收方可以置起 READY 之后在 VALID 置高之前都可以随时再置低 READY 信号。\n\u003c!DOCTYPE html\u003e Responsive Image 信号同时同时到达\n这个最简单，两个信号都等着一个时钟上升沿就完成传输了。\n\u003c!DOCTYPE html\u003e Responsive Image 握手信号之间的依赖关系 为了防止死锁发生，信号之间要遵循一些规矩，举例来说，如上面提到的 READY 信号依赖 VALID 信号，但是 VALID 信号不能根据 READY 信号来判断是否数据已准备好，否则将会造成死锁。下面详细解释读写过程中需要遵循的依赖关系。\n单箭头指向的两个信号，信号的置高，低没有顺序要求。 双箭头表示箭头所指对象应迟于箭头出发信号发送。 Read transaction dependencies\n\u003c!DOCTYPE html\u003e Responsive Image Master 不得等待 Slave 置高 ARREADY Slave 可以在置高 ARREADY 之前等待 ARVALID 置高 Slave 能够在 ARVALID 置高之前先置高 ARREADY Slave 必须等待 ARVALID 和 ARREADY 都被置高，然后才置高 RVALID 以表示有效数据可用 在置高 RVALID 之前，Slave 不得等待 Master 置高 RREADY Master 可以在置高 RREADY 之前等待 RVALID 被置高 Master 可以在 RVALID 被置高之前置高 RREADY Write transaction dependencies\n\u003c!DOCTYPE html\u003e Responsive Image 在置高 AWVALID 或 WVALID 之前，Master 不得等待 Slave 置高 AWREADY 或 WREADY Slave 可以在置高 AWREADY 之前等待 AWVALID 或 WVALID，或两者都等待 Slave 可以在 AWVALID 或 WVALID 或两者都被置高之前置高 AWREADY 在置高 WREADY 之前，Slave 可以等待 AWVALID 或 WVALID，或两者都等待 Slave 可以在 AWVALID 或 WVALID 或两者都被置高之前置高 WREADY 在置高 BVALID 之前，Slave 必须等待 WVALID 和 WREADY 都被置高 Slave还必须在置高 BVALID 之前等待 WLAST 被置高，因为写入响应 BRESP 必须在写入事务的最后一次数据传输之后才发出信号 在置高 BVALID 之前，Slave 不得等待 Master 置高 BREADY Master 可以在置高 BREADY 之前等待 BVALID Master 可以在 BVALID 被置高之前置高 BREADY 地址结构（Address structure） AXI 协议是基于 Burst 的，地址结构里声明了一些传输过程中需要的信号，如起始地址，burst 传输长度，传输模式等等。\nBurst 在介绍 Burst transfer 之前，需要解释一下什么是 Burst。在手册的术语表中，与 AXI 传输相关的有三个概念，分别是 transfer(beat)、burst、transaction。\nAXI Transaction：the complete set of required operations on the AXI bus form the AXI Transaction.表示传输一段数据 (AXI burst) 所需的一整套操作； AXI Burst：any required payload data is transferred as an AXI Burst.表示 AXI 待传数据； AXI Beats：a burst can comprise multiple data transfers, or AXI Beats.表示 AXI burst 的组成，一个 Beat 就是一个 transfer。 三者的关系：在 AXI 传输事务（Transaction）中，数据以突发传输（Burst）的形式组织。一次突发传输中可以包含一至多个数据（Transfer）。每个 transfer 因为使用一个周期，又被称为一拍数据（Beat）。\n$$ \\text{Transaction} = M \\text{Burst} ,M \\geq 1 \\ \\text{Burst} = N \\text{Transfer( or Beat)} ,N \\geq 1 $$\n在地址通道中有三个信号控制进行控制，包括：\n\u003c!DOCTYPE html\u003e Responsive Image ARLEN(Burst Length)\n指一次突发传输中包含的数据传输 (transfer) 数量，在协议中使用 AxLen 信号控制。在 AXI4 中，INCR 类型最大支持长度为 256，其他类型最大长度为 16。而 AXI3 中这一数字无论何种模式均为 16。因此 AXI4 中 AxLen 信号位宽为 8bit，AXI3 中的 AxLen 则仅需要 4bit。\nARSIZE(Burst Size)\n指传输中的数据位宽，具体地，是每周期传输数据的字节数量，在协议中使用 AXSIZE 信号控制。突发传输数据宽度不能超过数据总线本身的位宽。而当数据总线位宽大于突发传输宽度时，将根据协议的相关规定，将数据在部分数据线上传输。\n\u003c!DOCTYPE html\u003e Responsive Image ARBURST(Burst Type)\nBurst Type：AXI 协议中支持不同的 Burst 传输类型，主要分 FIXED、INCR、WRAP。\n\u003c!DOCTYPE html\u003e Responsive Image FIXED 传输为地址固定传输，所有传输都会写在同一个地址中。主要应用在 FIFO 的传输中，因为 FIFO 为先入先出，只需要往同一个地址写数据即可。 INCR 传输为地址递增传输，可根据具体的配置有固定长度递增和非定长递增。大部分的数据传输都是使用这种方式，尤其是在内存访问中，可以大大提高效率。 WRAP 传输为地址回环传输，在一定长度后会回环到起始地址。主要应用在 Cache 操作中，因为 cache 是按照 cache line 进行操作，采用 wrap 传输可以方便的实现从内存中取回整个 cache line。 AXI burst 读操作：master 只需要发送 burst 的起始地址，slave 会根据 burst 的起始地址与 burst 场地自动进行地址计算，将对应的数据与响应发送到 master 侧。\n\u003c!DOCTYPE html\u003e Responsive Image AXI burst 写操作中，也只需要发送 burst 写的起始地址，slave 只需要接受起始地址，然后根据传输的长度将数据传输到对应的地址缓存中。只需要进行一次握手就可以实现地址通道的请求传输，避免系统总线的占用。\n\u003c!DOCTYPE html\u003e Responsive Image 数据结构（Data read and write structure） 读写数据结构中声明了几种数据传输方式。\n在介绍这些传输方式之前，需要了解WSTRB(Write strobes) 写选通信号。写选通信号 WSTRB 允许在写数据总线上进行 稀疏数据 传输。每个写选通信号对应写数据总线上的一个字节。当写选通断言时，表示写数据总线上对应的字节通道中包含将被更新到 memory 的有效信息。\n写数据总线上每 8 位具有一个写选通位，因此 WSTRB[n] 对应 WDATA[(8 x n) + 7 : (8 x n)]。默认情况下 WSTRB = 0xFFFF。也就是所有通路都是通的。\n\u003c!DOCTYPE html\u003e Responsive Image Narrow Transfer 当本次传输中数据位宽小于通道本身的数据位宽时，称为窄位宽数据传输，或者直接翻译成窄传输。如下图，传输总线为 32bit，但是每次只传了 8 bit。\n窄传输就是通过 STRB 信号指定有效传输数据的位宽来实现。针对一些特定的寄存器读写，或者在不同数据位宽的总线传输中会使用窄传输操作。如图，第一次传输时，WSTRB 信号为 0x01，WSTRB = b'001，表示 WDATA[7:0] 数据有效。\n需要注意在多笔连续的窄传输操作中，STRB 会随着地址递增进行响应的变化，这样方便在系统设计使用中可以方便的将窄传输合并，从而提升系统传输效率。\n\u003c!DOCTYPE html\u003e Responsive Image Unaligned Transfer AXI 协议规定单次 burst 传输中的数据，其地址不能跨越 4KB 边界。也就是在传输过程中会进行 4K 对齐。但是在某些时候，会期望在非对齐的地址开始一个突发，即非对齐传输。\n协议中之所以规定一个 burst 不能跨越 4K 边界是为了避免一次 burst 访问两个 slave（每个 slave 的地址空间是 4K/1K 对齐的）。4K 对齐最大原因是系统中定义一个 page 大小是 4K，而所谓的 4K 边界是指低 12bit 为 0 的地址。\n非对齐传输是指有些传输指令不是按照 word 对齐，而是按照 Byte 对齐进行传输。起始地址可能是任意的地址。如下图中，起始地址为 0x1，则在系统上需要按照非对齐的方式进行传输。第一次传输采用 strb 信号指定对应的 Byte 有效，后面的传输可以按照正常的传输进行。\n下图是一些传输示例，有阴影的格子表示当前字节不会被传输。\n图一为正常的对齐传输，传输起始地址为 0x00。\n图二为非对齐传输，起始地址为 0x01，第一个格子对应的 WSTRB = b'1110。\n图三同上，只是 Burst length 为 5。\n\u003c!DOCTYPE html\u003e Responsive Image 图四也为非对齐传输，起始地址为 0x07。对应的 WSTRB = b'1000。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/amba%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE-axi%E5%8D%8F%E8%AE%AE/","summary":"\u003ch2 id=\"axi\"\u003eAXI\u003c/h2\u003e\n\u003cp\u003e组成部分：\u003c/p\u003e\n\u003cp\u003eAXI4 协议中包含五种信道，通道之间相互独立且存在差别，通过通道进行通信之前需要使用 VALID/READY 进行握手，Read 和 Write 根据 Master 定义：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e读地址信道（Read Address Channel）\u003c/li\u003e\n\u003cli\u003e写地址信道（Write Address Channel）\u003c/li\u003e\n\u003cli\u003e读数据信道（Read Data Channel）\u003c/li\u003e\n\u003cli\u003e写数据信道（Write Data Channel）\u003c/li\u003e\n\u003cli\u003e写响应信道（Write Response Channel）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e还有两种 Component\u003c/p\u003e","title":"AMBA 总线协议-AXI 协议"},{"content":"简介 常说的状态机是有限状态机 FSM，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。 三个特征：\n状态总数（state）是有限的。 任一时刻，只处在一种状态之中。 某种条件下，会从一种状态转变（transition）到另一种状态。 设计状态机的关键点：当前状态、外部输入、下一个状态。\n状态机分类 Moore 型状态机 Moore 型状态机特点是：输出只与当前状态有关（与输入信号无关）。相对简单，考虑状态机的下一个状态时只需要考虑它的当前状态就行了。\nMealy 型状态机 Mealy 型状态机的特点是：输出不只和当前状态有关，还与输入信号有关。状态机接收到一个输入信号需要跳转到下一个状态时，状态机综合考虑 2 个条件（当前状态、输入值）后才决定跳转到哪个状态。\n实现一个简单的状态机 代码参考AstarLight/FSM-framework。\n以小明的一天设计出一个状态机，下图为状态转移图：\n\u003c!DOCTYPE html\u003e Responsive Image 首先，有限状态机的状态是有限的，我们可以定义一天中的状态：\nenum { GET_UP, GO_TO_SCHOOL, HAVE_LUNCH, DO_HOMEWORK, SLEEP, }; 状态机在没有事件的驱动下就是一潭死水，所以我们还需要定义出一些会发生的事件，去驱动状态机的运转：\nenum { EVENT1 = 1, EVENT2, EVENT3, }; 再定义一些在某个状态下需要处理的动作，也就是函数：\nvoid GetUp() { // do something printf(\u0026#34;xiao ming gets up!\\n\u0026#34;); } void Go2School() { // do something printf(\u0026#34;xiao ming goes to school!\\n\u0026#34;); } void HaveLunch() { // do something printf(\u0026#34;xiao ming has lunch!\\n\u0026#34;); } void DoHomework() { // do something printf(\u0026#34;xiao ming does homework!\\n\u0026#34;); } void Go2Bed() { // do something printf(\u0026#34;xiao ming goes to bed!\\n\u0026#34;); } 定义一个状态表结构，用来表示一个状态机的状态：\ntypedef struct FsmTable_s { int event; //事件 int CurState; //当前状态 void (*eventActFun)(); //函数指针 int NextState; //下一个状态 }FsmTable_t; 接下来，我们就可以这个结构定义一个状态表，状态机根据这个表进行状态的流转：\nFsmTable_t XiaoMingTable[] = { //{到来的事件，当前的状态，将要要执行的函数，下一个状态} { EVENT1, SLEEP, GetUp, GET_UP }, { EVENT2, GET_UP, Go2School, GO_TO_SCHOOL }, { EVENT3, GO_TO_SCHOOL, HaveLunch, HAVE_LUNCH }, { EVENT1, HAVE_LUNCH, DoHomework, DO_HOMEWORK }, { EVENT2, DO_HOMEWORK, Go2Bed, SLEEP }, }; 定义一个状态机结构，表示一个状态机：\ntypedef struct FSM_s { FsmTable_t* FsmTable; //指向的状态表 int curState; //FSM当前所处的状态 }FSM_t; 有了这些基本的结构，就可以写主函数了：\nint main() { FSM_t fsm; // 实例化一个状态机 InitFsm(\u0026amp;fsm); // 初始化状态机 int event = EVENT1; // 初始化事件，为了启动状态机流转， // 因为状态机只有在有时间发生时才会改变状态 //小明的一天,周而复始的一天又一天，进行着相同的活动 while (1) { printf(\u0026#34;event %d is coming...\\n\u0026#34;, event); FSM_EventHandle(\u0026amp;fsm, event); // 有了初始事件，我们就需要处理这个事件， // 再写一个处理事件的函数 printf(\u0026#34;fsm current state %d\\n\u0026#34;, fsm.curState); test(\u0026amp;event); Sleep(1); //休眠1秒，方便观察 } return 0; } // 测试用的，模拟事件的发生 void test(int *event) { if (*event == 3) { *event = 1; } else { (*event)++; } } 编写初始化状态机的函数：\nint g_state_max_num = 0; // 状态机的状态最大数量，根据状态表的大小来计算 // 初始化FSM void InitFsm(FSM_t* pFsm) { g_state_max_num = sizeof(XiaoMingTable) / sizeof(FsmTable_t); pFsm-\u0026gt;curState = SLEEP; // 初始状态为睡觉 pFsm-\u0026gt;FsmTable = XiaoMingTable; } 编写事件处理函数：\n/* 事件处理 */ void FSM_EventHandle(FSM_t* pFsm, int event) { FsmTable_t* pActTable = pFsm-\u0026gt;FsmTable; void (*eventActFun)() = NULL; //函数指针初始化为空 int NextState; int CurState = pFsm-\u0026gt;curState; /* 获取当前动作函数 */ for (int i = 0; i\u0026lt;g_max_num; i++) { //当且仅当当前状态下来个指定的事件，我才执行它 if (event == pActTable[i].event \u0026amp;\u0026amp; CurState == pActTable[i].CurState) { pActTable[i].eventActFun(); // 执行动作函数 FSM_StateTransfer(pFsm, pActTable[i].NextState); // 执行状态转移 break; } else { // do nothing } } } /* 状态迁移 */ void FSM_StateTransfer(FSM_t* pFsm, int state) { pFsm-\u0026gt;curState = state; } 参考资料 Linux 编程之有限状态机 FSM 的理解与实现 - Madcola - 博客园 JavaScript 与有限状态机 - 阮一峰的网络日志 有限状态机 - 维基百科，自由的百科全书\n","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e常说的状态机是有限状态机 FSM，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。\n三个特征：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e状态总数（state）是有限的。\u003c/li\u003e\n\u003cli\u003e任一时刻，只处在一种状态之中。\u003c/li\u003e\n\u003cli\u003e某种条件下，会从一种状态转变（transition）到另一种状态。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e设计状态机的关键点：当前状态、外部输入、下一个状态。\u003c/p\u003e","title":"C 语言实现简单有限状态机"},{"content":"重定位 位置无关编码 (PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。\n位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。\n我们在设计一个程序时，会给这个程序指定一个运行地址（链接地址）。就是说我们在编译程序时其实心里是知道我们程序将来被运行时的地址（运行地址）的，而且必须给编译器链接器指定这个地址（链接地址）才行。\n最后得到的二进制程序理论上是和你指定的运行地址有关的，将来这个程序被执行时必须放在当时编译链接时给定的那个地址（链接地址）下才行，否则不能运行（就叫位置有关代码）。但是有个别特别的指令他可以跟指定的地址（链接地址）没有关系，也就是说这些代码实际运行时不管放在哪里都能正常运行。\n运行地址：由运行时决定的（编译链接时是无法绝对确定运行时地址的）。\n链接地址：由程序员在编译链接的过程中，通过Makefile中-Ttext xxx或者在链接脚本中指定的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。\n举例：Linux 中的应用程序。gcc hello.c -o hello，这时使用默认的链接地址就是0x0，所以应用程序都是链接在0x0地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享 4G 的虚拟地址空间。所以应用程序都可以链接到 0 地址，因为每个进程都是从 0 地址开始的。（编译时可以不给定链接地址而都使用0x0）\n编译链接过程 每个过程的作用 预编译：预编译器执行。替换宏定义，删除注释等工作。 编译：编译器来执行。把源码.c .S编程机器码.o文件。 链接：链接器来执行。把.o文件中的各函数（段）按照一定规则（链接脚本来指定）累积在一起，形成可执行文件。 strip：strip 是把可执行程序中的符号信息给拿掉，以节省空间。（Debug 版本和 Release 版本） objcopy：由可执行程序生成可烧录的镜像bin文件。 编译后生成的段 段就是程序的一部分，我们把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段放在合适的位置。\n段名分为 2 种：一种是编译器链接器内部定好的，一种是程序员自己指定的、自定义的段名。 已有段名：\n代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西 数据段：（.data），数据段就是 C 语言中有显式初始化为非 0 的全局变量 bss 段：（.bss），又叫 ZI（zero initial）段，就是零初始化段，对应 C 语言中初始化为 0 的全局变量。 自定义段名：段名由程序员自己定义，段的属性和特征也由程序员自己定义。 C 语言中全局变量如果未显式初始化，值是 0。本质就是 C 语言把这类全局变量放在了 bss 段，从而保证了为 0。 C 运行时环境如何保证显式初始化为非 0 的全局变量的值在 main 之前就被赋值了？就是因为它把这类变量放在了.data 段中，而.data 段会在 main 执行之前被处理（初始化）。\n链接脚本 链接脚本做什么事？ 链接脚本其实是个规则文件，他是程序员用来指挥链接器工作的。链接器会参考链接脚本，并且使用其中规定的规则来处理.o文件中那些段，将其链接成一个可执行程序。\n链接脚本的关键内容有 2 部分：段名 + 地址（作为链接地址的内存地址）。把段，放到一个地址的意思。\n链接脚本就像是一个从上到下顺序执行的一个代码\n. 表示当前位置 = 表示赋值 * 表示通配符 链接脚本里的符号，可以在汇编源码里引用。\n一个简易示例：\nSECTIONS { . = 0xd0024000; # 当前地址为0xd0024000 .text : { start.o * (.text) # 所有的text段 } .data : { * (.data) } bss_start = .; # bss_start的值为当前地址，是执行到这里的地址，不是最上面. = 0xd0024000的地址 .bss : { * (.bss) } bss_end = .; } 怎么做？ 任务：在 SRAM 中将代码从 0xd0020010 重定位到 0xd0024000。\n第一点：通过链接脚本将代码链接到 0xd0024000 重定位代码的作用就是：在PIC执行完之前（在代码中第一句位置有关码执行之前）必须将整个代码搬移到0xd0024000位置去执行，这就是重定位。\n第二点：dnw 下载时将 bin 文件下载到 0xd0020010 这样就能完成，下载代码与运行代码位置不同。\n第三点：代码执行时通过代码前段的少量位置无关码将整个代码搬移到 0xd0024000。\n第四点：使用一个长跳转跳转到 0xd0024000 处的代码继续执行，重定位完成。\n长跳转：一种跳转指令，类似于分支指令 B，BL 等作用的指令，跳转指令通过给 PC（r15）赋一个新值来完成代码跳转。当我们执行完重定位后，实际上 SRAM 中有两份代码的镜像（一份是我们下载到 0xd0020010 处的，一份是重定位到 0xd0024000 处的），这两份代码内容完全相同。\n短跳转：短跳转指令可以实现向前或向后 32MB 的地址空间跳转。\n当链接地址和运行地址相同是，短跳转和长跳转实际效果一样。但是当链接地址和运行地址不同时，短跳转和长跳转就有差异了，这时候段跳转执行的是运行地址处的那一份，而长跳转执行的是链接地址的那一份。\n重定位实际就是在运行地址处执行一段位置无关码 PIC，让这段 PIC（也就是重定位代码）从运行地址处把整个程序镜像拷贝一份到链接地址处，完了之后使用一句长跳转指令从运行地址处直接跳转到链接地址处去执行同一个函数（led_blink），这样就实现了重定位之后的无缝连接。\n汇编代码：\n/* * 文件名： led.s * 作者： 朱老师（朱友鹏） * 描述： 演示重定位（在SRAM内部重定位） */ #define WTCON 0xE2700000 #define SVC_STACK 0xd0037d80 .global _start // 把_start链接属性改为外部，这样其他文件就可以看见_start了 _start: // 第1步：关看门狗（向WTCON的bit5写入0即可） ldr r0, =WTCON ldr r1, =0x0 str r1, [r0] // 第2步：设置SVC栈 ldr sp, =SVC_STACK // 第3步：开/关icache mrc p15,0,r0,c1,c0,0; // 读出cp15的c1到r0中 //bic r0, r0, #(1\u0026lt;\u0026lt;12) // bit12 置0 关icache orr r0, r0, #(1\u0026lt;\u0026lt;12) // bit12 置1 开icache mcr p15,0,r0,c1,c0,0; // 第4步：重定位 adr r0, _start // adr加载时就叫短加载，此处adr指令用于加载_start当前运行地址，详解见正文 ldr r1, =_start // ldr加载时如果目标寄存器是pc就叫长跳转，如果目标寄存器是r1等就叫长加载 // 此处ldr指令用于加载_start的链接地址:0xd0024000 // bss段的起始地址 ldr r2, =bss_start // 就是我们重定位代码的结束地址，重定位只需重定位代码段和数据段即可 // 该符号在链接脚本里定义 cmp r0, r1 // 比较_start的运行时地址和链接地址是否相等 beq clean_bss // 如果相等说明不需要重定位，所以跳过copy_loop，直接到clean_bss // 如果不相等说明需要重定位，那么会顺序执行下面的copy_loop进行重定位 // 重定位完成后继续执行clean_bss。 // 用汇编来实现的一个while循环 copy_loop: ldr r3, [r0], #4 // 源 r0内容写入r3，然后r0自增4 str r3, [r1], #4 // 目的 r3内容写入r1，然后r1自增4 // 这两句代码就完成了4个字节内容的拷贝 cmp r1, r2 // r1和r2都是用ldr加载的，都是链接地址，所以r1不断+4总能等于r2 bne copy_loop // 清bss段，其实就是在链接地址处把bss段全部清零 clean_bss: ldr r0, =bss_start ldr r1, =bss_end cmp r0, r1 // 如果r0等于r1，说明bss段为空，直接继续执行下面的代码 beq run_on_dram // 清除bss完之后的地址 mov r2, #0 clear_loop: str r2, [r0], #4 // 先将r2中的值放入r0所指向的内存地址（r0中的值作为内存地址）， cmp r0, r1 // 然后r0 = r0 + 4 bne clear_loop // 清理完bss段后重定位就结束了。然后当前的状况是： // 1、当前运行地址还在0xd0020010开头的（重定位前的）那一份代码中运行着。 // 2、此时SRAM中已经有了2份代码，1份在d0020010开头，另一份在d0024000开头的位置。 // 然后就要长跳转了。 run_on_dram: // 长跳转到led_blink开始第二阶段 ldr pc, =led_blink // ldr指令实现长跳转，把led_blink的值，写入pc寄存器 // 从这里之后就可以开始调用C程序了 //bl led_blink // bl指令实现短跳转 // 汇编最后的这个死循环不能丢 b . adr与 ldr 伪指令的区别：ldr和adr都是伪指令\nadr短加载，指令加载符号地址，加载的是运行时地址； ldr长加载，指令在加载符号地址时，加载的是链接地址； 重定位就是汇编代码中的copy_loop函数，代码的作用是使用循环结构来逐句复制代码到链接地址。 复制的源地址是 SRAM 的0xd0020010，复制目标地址是 SRAM 的0xd0024000，复制长度是bss_start减去_start，所以复制的长度就是整个重定位需要重定位的长度，也就是整个程序中代码段 + 数据段的长度。bss段（bss 段中就是 0 初始化的全局变量）不需要重定位。\n清除bss段是为了满足 C 语言的运行时要求（C 语言要求显式初始化为 0 的全局变量，或者未显式初始化的全局变量的值为 0，实际上 C 语言编译器就是通过清bss段来实现 C 语言的这个特性的）。一般情况下我们的程序是不需要负责清零bss段的（C 语言编译器和链接器会帮我们的程序自动添加一段头程序，这段程序会在我们的 main 函数之前运行，这段代码就负责清除bss）。但是在我们代码重定位了之后，因为编译器帮我们附加的代码只是帮我们清除了运行地址那一份代码中的bss，而未清除重定位地址处开头的那一份代码的bss，所以重定位之后需要自己去清除bss。\n","permalink":"https://lifeislife.cn/posts/%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/","summary":"\u003ch2 id=\"重定位\"\u003e重定位\u003c/h2\u003e\n\u003cp\u003e位置无关编码 (PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。\u003c/p\u003e\n\u003cp\u003e位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。\u003c/p\u003e","title":"链接脚本入门"},{"content":"存储器 存储器的层次结构 SRAM（Static Random-Access Memory，静态随机存取存储器） CPU 如果形容成人的大脑的话，那么 CPU Cache (高速缓存) 就好比人的记忆。它用的是 SRAM 芯片。\nSRAM 的“静态”的意思是，只要处于通电状态，里面的数据就保持存在，一旦断电，数据就会丢失。SRAM 里 1bit 数据需要 6-8 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间，能够存的数据有限。因为其电路简单，访问速度非常快。\n在 CPU 里，通常会有 L1、L2、L3 这样三层高速缓存。每个 CPU 核心都有一块属于自己的 L1 高速缓存，通常分成指令缓存和数据缓存，分开存放 CPU 使用的指令和数据。\nL2 的 Cache 同样是每个 CPU 核心都有的，不过它往往不在 CPU 核心的内部。所以，L2 Cache 的访问速度会比 L1 稍微慢一些。而 L3Cache，则通常是多个 CPU 核心共用的，尺寸会更大一些，访问速度自然也就更慢一些。\n你可以把 CPU 中的 L1Cache 理解为我们的短期记忆，把 L2/L3Cache 理解成长期记忆，把内存当成我们拥有的书架或者书桌。当我们自己记忆中没有资料的时候，可以从书桌或者书架上拿书来翻阅。这个过程中就相当于，数据从内存中加载到 CPU 的寄存器和 Cache 中，然后通过“大脑”，也就是 CPU，进行处理和运算。\nDRAM（Dynamic Random Access Memory，动态随机存取存储器） 内存用的芯片和 Cache 有所不同，它用的是一种叫作 DRAM 的芯片，比起 SRAM 来说，它的密度更高，有更大的容量，而且它也比 SRAM 芯片便宜不少。\nDRAM 被称为“动态”存储器，是因为 DRAM 需要靠不断地“刷新”，才能保持数据被存储起来。DRAM 的一个比特，只需要一个晶体管和一个电容就能存储。所以，DRAM 在同样的物理空间下，能够存储的数据也就更多，也就是存储的“密度”更大。但是，因为数据是存储在电容里的，电容会不断漏电，所以需要定时刷新充电，才能保持数据不丢失。DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问延时也就更长。\n\u003c!DOCTYPE html\u003e Responsive Image 从 Cache、内存，到 SSD 和 HDD 硬盘，一台现代计算机中，就用上了所有这些存储器设备。其中，容量越小的设备速度越快，而且，CPU 并不是直接和每一种存储器设备打交道，而是每一种存储器设备，只和它相邻的存储设备打交道。比如，CPUCache 是从内存里加载而来的，或者需要写回内存，并不会直接写回数据到硬盘，也不会直接从硬盘加载数据到 CPUCache 中，而是先加载到内存，再从内存加载到 Cache 中。\n这样，各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降，也就构成了我们日常所说的存储器层次结构。\n缓存 CPU cache 高速缓存 缓存不是 CPU 的专属功能，可以把它当成一种策略，任何时候想要增加数据传输性能，都可以通过加一层缓存试试。\n存储器层次结构的中心思想是，对于每个$k$，位于$k$层的更快更小的存储设备作为位于$k+1$层的更大更慢的存储设备的缓存。下图展示了存储器层次结构中缓存的一般性概念。\n\u003c!DOCTYPE html\u003e Responsive Image 数据总是以块block为单位，在层与层之间来回复制。\n说回高速缓存，按照摩尔定律，CPU 的访问速度每 18 个月便会翻一翻，相当于每年增长 60%。内存的访问速度虽然不断增长，却远没有那么快，每年只增长 7% 左右。这样就导致 CPU 性能和内存访问的差距不断拉大。为了弥补两者之间差异，现代 CPU 引入了高速缓存。\n\u003c!DOCTYPE html\u003e Responsive Image CPU 的读（load）实质上就是从缓存中读取数据到寄存器（register）里，在多级缓存的架构中，如果缓存中找不到数据（Cache miss），就会层层读取二级缓存三级缓存，一旦所有的缓存里都找不到对应的数据，就要去内存里寻址了。寻址到的数据首先放到寄存器里，其副本会驻留到 CPU 的缓存中。\nCPU 的写（store）也是针对缓存作写入。并不会直接和内存打交道，而是通过某种机制实现数据从缓存到内存的写回（write back）。\n缓存到底如何与 CPU 和主存数据交换的？CPU 如何从缓存中读写数据的？缓存中没有读的数据，或者缓存写满了怎么办？我们先从 CPU 如何读取数据说起。\n缓存读取 CPU 发起一个读取请求后，返回的结果会有如下几种情况：\n缓存命中 (cache hit) 要读取的数据刚好在缓存中，叫做缓存命中。 缓存不命中 (cache miss) 发送缓存不命中，缓存就得执行一直放置策略(placement policy)，比如 LRU。来决定从主存中取出的数据放到哪里。 强制性不命中(compulsory miss)/冷不命中(cold miss)：缓存中没有要读取的数据，需要从主存读取数据，并将数据放入缓存。 冲突不命中(conflict miss)：缓存中有要读的数据，在采取放置策略时，从主存中取数据放到缓存时发生了冲突，这叫做冲突不命中。 高速缓存存储器组织结构 整个 Cache 被划分为 1 个或多个组 (Set)，$S$ 表示组的个数。每个组包含 1 个或多个缓存行(Cache line)，$E$ 表示一个组中缓存行的行数。每个缓存行由三部分组成：有效位(valid)，标记位（tag），数据块（cache block）。\n有效位：该位等于 1，表示这个行数据有效。 标记位：唯一的标识了存储在高速缓存中的块，标识目标数据是否存在当前的缓存行中。 数据块：一部分内存数据的副本。 \u003c!DOCTYPE html\u003e Responsive Image Cache 的结构可以由元组$(S,E,B,m)$表示。不包括有效位和标记位。Cache 的大小为 $C=S \\times E \\times B$.\n接下来看看 Cache 是如何工作的，当 CPU 执行数据加载指令，从内存地址 A 读取数据时，根据存储器层次原理，如果 Cache 中保存着目标数据的副本，那么就立即将数据返回给 CPU。那么 Cache 如何知道自己保存了目标数据的副本呢？\n假设目标地址的数据长度为$m$位，这个地址被参数 $S$ 和 $B$ 分成了三个字段：\n\u003c!DOCTYPE html\u003e Responsive Image 首先通过长度为$s$的组索引，确定目标数据保存在哪一个组 (Set) 中，其次通过长度为$t$的标记，确定在哪一行，需要注意的是此时有效位必须等于 1，最后根据长度为$b$的块偏移，来确定目标数据在数据块中的确切位置。\nQ：既然读取 Cache 第一步是组选择，为什么不用高位作为组索引，而使用中间的为作为组索引？ A：如果使用了高位作索引，那么一些连续的内存块就会映射到相同的高速缓存块。如图前四个块映射到第一个缓存组，第二个四个块映射到第二个组，依次类推。如果一个程序有良好的空间局部性，顺序扫描一个数组的元素，那么在任何时候，缓存中都只保存在一个块大小的数组内容。这样对缓存的使用率很低。相比而言，如果使用中间的位作为组索引，那么相邻的块总是映射到不同的组，图中的情况能够存放整个大小的数组片。 \u003c!DOCTYPE html\u003e Responsive Image 直接映射高速缓存 Direct Mapped Cache 根据每个组的缓存行数 $E$ 的不同，Cache 被分为不同的类。每个组只有一行$E=1$的高速缓存被称为直接映射高速缓存(direct-mapped cache)。\n\u003c!DOCTYPE html\u003e Responsive Image 当一条加载指令指示 CPU 从主存地址 A 中读取一个字 w 时，会将该主存地址 A 发送到高速缓存中，则高速缓存会根据组选择，行匹配和字抽取三步来判断地址 A 是否命中。\n组选择(set selection)：根据组索引值来确定属于哪一个组，如图中索引长度为 5 位，可以检索 32 个组 ($2^5=32$)。当$s=0$时，此时组选择的结果为set 0，当$s=1$时，此时组选择的结果为set 1。\n\u003c!DOCTYPE html\u003e Responsive Image 行匹配 (line match)：首先看缓存行的有效位，此时有效位为 1，表示当前数据有效。然后对比缓存行的标记0110与地址中的标记0110是否相等，如果相等，则表示目标数据在当前的缓存行中（缓存命中）。如果不一致或者有效位为 0，则表示目标数据不在当前的缓存行中（缓存不命中）。如果命中，就可以进行下一步字抽取。\n\u003c!DOCTYPE html\u003e Responsive Image 字抽取 (word extraction)：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于100时，表示目标数据起始地址位于字节 4 处。\n\u003c!DOCTYPE html\u003e Responsive Image 下面通过一个例子来解释清除这个过程。假设我们有一个直接映射高速缓存，描述为$(S,E,B,m) = (4,1,2,4)$。换句话说，高速缓存有 4 个组，每个组 1 行，每个数据块 2 个字节，地址长度为 4 位。\n\u003c!DOCTYPE html\u003e Responsive Image 从图中可以看出，8 个内存块，但只有 4 个高速缓存组，所以会有多个块映射到同一个高速缓存组中。例如，块 0 和块 4 都会被映射到组 0。\n下面我们来模拟当 CPU 执行一系列读的时候，高速缓存的执行情况，我们假设每次 CPU 读 1 个字节的字。\n读地址 0(0000) 的字： \u003c!DOCTYPE html\u003e Responsive Image 读地址 1(0001) 的字： \u003c!DOCTYPE html\u003e Responsive Image 读地址 13(1101) 的字： \u003c!DOCTYPE html\u003e Responsive Image 读地址 8(1000) 的字： \u003c!DOCTYPE html\u003e Responsive Image 读地址 0(0000) 的字： \u003c!DOCTYPE html\u003e Responsive Image 组相联高速缓存 Set Associative Cache 由于直接映射高速缓存的组中只有一行，所以容易发生冲突不命中。组相联高速缓存 (Set associative cache) 运行有多行缓存行。但是缓存行最大不能超过 $C/B$。\n如图一个组中包含了两行缓存行，这种我们称为 2 路相联高速缓存。\n\u003c!DOCTYPE html\u003e Responsive Image 组选择：与直接映射高速缓存的组选择过程一样。\n行匹配：因为一个组有多行，所以需要遍历所有行，找到一个有效位为 1，并且标记为与地址中的标记位相匹配的一行。如果找到了，表示缓存命中。\n字抽取：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于100时，表示目标数据起始地址位于字节 4 处。\n如果不命中，那么就需要从主存中取出需要的数据块，但是将数据块放在哪一行缓存行呢？如果存在空行 ($valid=0$)，那就放到空行里。如果没有空行，就得选择一个非空行来替换，同时希望 CPU 不会很快引用这个被替换的行。这里介绍几个替换策略。\n最简单的方式就是随机选择一行来替换，其他复杂的方式就是利用局部性原理，使得接下来 CPU 引用替换的行概率最小。如\n缓存一致性协议 MESI 为什么需要缓存一致 目前主流电脑的 CPU 都是多核心的，多核心的有点就是在不能提升 CPU 主频后，通过增加核心来提升 CPU 吞吐量。每个核心都有自己的 L1 Cache 和 L2 Cache，只是共用 L3 Cache 和主内存。每个核心操作是独立的，每个核心的 Cache 就不是同步更新的，这样就会带来缓存一致性（Cache Coherence）的问题。\n举个例子，如图： \u003c!DOCTYPE html\u003e Responsive Image 有 2 个 CPU，主内存里有个变量x=0。CPU A 中有个需要将变量x加1。CPU A 就将变量x加载到自己的缓存中，然后将变量x加1。因为此时 CPU A 还未将缓存数据写回主内存，CPU B 再读取变量x时，变量x的值依然是0。\n这里的问题就是所谓的缓存一致性问题，因为 CPU A 的缓存与 CPU B 的缓存是不一致的。\n如何解决缓存一致性问题 通过在总线加 LOCK 锁的方式 在锁住总线上加一个 LOCK 标识，CPU A 进行读写操作时，锁住总线，其他 CPU 此时无法进行内存读写操作，只有等解锁了才能进行操作。\n该方式因为锁住了整个总线，所以效率低。\n缓存一致性协议 MESI 该方式对单个缓存行的数据进行加锁，不会影响到内存其他数据的读写。\n在学习 MESI 协议之前，简单了解一下总线嗅探机制（Bus Snooping）。要对自己的缓存加锁，需要通知其他 CPU，多个 CPU 核心之间的数据传播问题。最常见的一种解决方案就是总线嗅探。\n这个策略，本质上就是把所有的读写请求都通过总线广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。MESI 就是基于总线嗅探机制的缓存一致性协议。\nMESI 协议的由来是对 Cache Line 的四个不同的标记，分别是：\n状态 状态 描述 监听任务 Modified 已修改 该 Cache Line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中 Cache Line 必须时刻监听所有试图读该 Cache Line 相对于主存的操作，这种操作必须在缓存将该 Cache Line 写回主存并将状态改为 S 状态之前，被延迟执行 Exclusive 独享，互斥 该 Cache Line 有效，数据和内存中的数据一直，数据只存在于本 Cache Cache Line 必须监听其他缓存读主存中该 Cache Line 的操作，一旦有这种操作，该 Cache Line 需要改为 S 状态 Shared 共享的 该 Cache Line 有效，数据和内存中的数据一直，数据存在于很多个 Cache 中 Cache Line 必须监听其他 Cache Line 使该 Cache Line 无效或者独享该 Cache Line 的请求，并将 Cache Line 改为 I 状态 Invalid 无效的 该 Cache Line 无效 无 整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把各个状态之间的流转用表格总结了一下：\n当前状态 事件 行为 下个状态 M Local Read 从 Cache 中读，状态不变 M M Local Write 修改 cache 数据，状态不变 M M Remote Read 这行数据被写到内存中，使其他核能使用到最新数据，状态变为 S S M Remote Write 这行数据被写入内存中，其他核可以获取到最新数据，由于其他 CPU 修改该条数据，则本地 Cache 变为 I I 当前状态 事件 行为 下个状态 E Local Read 从 Cache 中读，状态不变 E E Local Write 修改数据，状态改为 M M E Remote Read 数据和其他 CPU 共享，变为 S S E Remote Write 数据被修改，本地缓存失效，变为 I I 当前状态 事件 行为 下个状态 S Local Read 从 Cache 中读，状态不变 S S Local Write 修改数据，状态改为 M，其他 CPU 的 Cache Line 状态改为 I M S Remote Read 数据和其他 CPU 共享，状态不变 S S Remote Write 数据被修改，本地缓存失效，变为 I I 当前状态 事件 行为 下个状态 I Local Read 1. 如果其他 CPU 没有这份数据，直接从内存中加载数据，状态变为 E；\n2. 如果其他 CPU 有这个数据，且 Cache Line 状态为 M，则先把 Cache Line 中的内容写回到主存。本地 Cache 再从内存中读取数据，这时两个 Cache Line 的状态都变为 S；\n3. 如果其他 Cache Line 有这份数据，并且状态为 S 或者 E，则本地 Cache Line 从主存读取数据，并将这些 Cache Line 状态改为 S E 或者 S I Local Write 1. 先从内存中读取数据，如果其他 Cache Line 中有这份数据，且状态为 M，则现将数据更新到主存再读取，将 Cache Line 状态改为 M；\n2. 如果其他 Cache Line 有这份数据，且状态为 E 或者 S，则其他 Cache Line 状态改为 I M I Remote Read 数据和其他 CPU 共享，状态不变 S I Remote Write 数据被修改，本地缓存失效，变为 I I 内存 计算机有五大组成部分，分别是：运算器、控制器、存储器、输入设备和输出设备。而内存就是其中的存储器。我们的数据和指令都需要先放到内存中，然后再被 CPU 执行。\n操作系统中程序并不能直接访问物理内存，我们的内存需要被分成固定大小的页（Page），然后再通过虚拟内存地址（Virtual Address）到物理内存地址（Physical Address）的地址转换（Address Translation），才能到达实际存放数据的物理内存位置。而我们的程序看到的内存地址，都是虚拟内存地址。那么如何进行转换的呢？\n简单页表 最简单的方式，就是建立一张虚拟内存到物理内存的映射表，在计算机里叫做页表（Page Table）。页表这个地址转换的办法，会把一个内存地址分成页号（Directory）和偏移量（Offset）两个部分，是不是似曾相识，因为在前面的高速缓存里，缓存的结构也是这样的。\n以一个 32 位地址举例，高 20 位是虚拟页号，可以从虚拟页表中找到物理页号的信息，低 12 位是偏移量，可以准确获得物理地址。 \u003c!DOCTYPE html\u003e Responsive Image 总结一下，对于一个内存地址转换，其实就是这样三个步骤：\n把虚拟内存地址，切分成页号和偏移量的组合； 从页表里面，查询出虚拟页号，对应的物理页号； 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。 \u003c!DOCTYPE html\u003e Responsive Image 但是这样的页表有个问题，它需要记录$2^{20}$个物理页表，这个存储关系，就好比一个 $2^{20}$大小的数组。一个页号是完整的 32 位的 4 字节（Byte），这样一个页表就需要 4MB 的空间。并且每个进程都会有这样一个页表，现代电脑正常都有成百上千个进程，如果用这样的页表肯定行不通的。\n多级页表 所以，在一个实际的程序进程里面，虚拟内存占用的地址空间，通常是两段连续的空间。而不是完全散落的随机的内存地址。而多级页表，就特别适合这样的内存地址分布。\n谈一谈内存管理，虚拟内存，多级页表 - 知乎\nTLB 内存保护 - 可执行空间保护 内存保护 - 地址空间布局随机化 Address Space Layout Randomization\n总线：计算机内部的高速公路 计算机由控制器、运算器、存储器、输入设备以及输出设备五大部分组成。CPU 所代表的控制器和运算器，要和存储器，也就是我们的主内存，以及输入和输出设备进行通信。那么计算机是用什么样的方式来完成，CPU 和内存、以及外部输入输出设备的通信呢？答案就是通过总线来通信。\n计算机里有不同的硬件设备，如果设备与设备之间都单独连接，那么就需要 N*N 的连线。那么怎么降低复杂度呢？与其让各个设备之间互相单独通信，不如我们去设计一个公用的线路。CPU 想要和什么设备通信，通信的指令是什么，对应的数据是什么，都发送到这个线路上；设备要向 CPU 发送什么信息呢，也发送到这个线路上。这个线路就好像一个高速公路，各个设备和其他设备之间，不需要单独建公路，只建一条小路通向这条高速公路就好了。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 三种线路和多总线架构 首先，CPU 和内存以及高速缓存通信的总线，这里面通常有两种总线。这种方式，我们称之为双独立总线（Dual Independent Bus，缩写为 DIB）。CPU 里，有一个快速的本地总线（Local Bus），以及一个速度相对较慢的前端总线（Front-side Bus）。\n现代的 CPU 里，通常有专门的高速缓存芯片。这里的高速本地总线，就是用来和高速缓存通信的。而前端总线，则是用来和主内存以及输入输出设备通信的。有时候，我们会把本地总线也叫作后端总线（Back-sideBus），和前面的前端总线对应起来。\n除了前端总线呢，我们常常还会听到 PCI 总线、I/O 总线或者系统总线（System Bus）。看到这么多总线的名字，你是不是已经有点晕了。这些名词确实容易混为一谈。其实各种总线的命名一直都很混乱，我们不如直接来看一看 CPU 的硬件架构图。对照图来看，一切问题就都清楚了。\n\u003c!DOCTYPE html\u003e Responsive Image CPU 里面的北桥芯片，把我们上面说的前端总线，一分为二，变成了三个总线。我们的前端总线，其实就是系统总线。CPU 里面的内存接口，直接和系统总线通信，然后系统总线再接入一个 I/O 桥接器（I/OBridge）。这个 I/O 桥接器，一边接入了我们的内存总线，使得我们的 CPU 和内存通信；另一边呢，又接入了一个 I/O 总线，用来连接 I/O 设备。\n事实上，真实的计算机里，这个总线层面拆分得更细。根据不同的设备，还会分成独立的 PCI 总线、ISA 总线等等。 \u003c!DOCTYPE html\u003e Responsive Image 在物理层面，其实我们完全可以把总线看作一组“电线”。不过呢，这些电线之间也是有分工的，我们通常有三类线路。\n数据线（Data Bus），用来传输实际的数据信息，也就是实际上了公交车的“人”。 地址线（Address Bus），用来确定到底把数据传输到哪里去，是内存的某个位置，还是某一个 I/O 设备。这个其实就相当于拿了个纸条，写下了上面的人要下车的站点。 控制线（ControlBus），用来控制对于总线的访问。虽然我们把总线比喻成了一辆公交车。那么有人想要做公交车的时候，需要告诉公交车司机，这个就是我们的控制信号。 尽管总线减少了设备之间的耦合，也降低了系统设计的复杂度，但同时也带来了一个新问题，那就是总线不能同时给多个设备提供通信功能。\n我们的总线是很多个设备公用的，那多个设备都想要用总线，我们就需要有一个机制，去决定这种情况下，到底把总线给哪一个设备用。这个机制，就叫作总线裁决（Bus Arbitraction）\n硬盘 DMA 过去几年，计算机产业一直在为提升 I/O 设备的速度而努力，从机械硬盘 HDD 到固态硬盘 SSD，从 SATA 协议到 PCIE 协议，虽然速度都几十上百倍的增加，但是仍然不够快。因为相比于 CPU 基本都是 2GHz 的频率（每秒会有 20 亿次的操作），SSD 硬盘的 IOPS 的 2 万次操作就显得微不足道。\n如果我们对于 I/O 的操作，都是由 CPU 发出对应的指令，然后等待 I/O 设备完成操作之后返回，那 CPU 有大量的时间其实都是在等待 I/O 设备完成操作。特别是当传输的数据量比较大的时候，比如进行大文件复制，如果所有数据都要经过 CPU，实在是有点儿太浪费时间了。\n因此，计算机工程师们，就发明了DMA 技术，也就是直接内存访问（Direct Memory Access）技术，来减少 CPU 等待的时间。\n什么是 DMA 本质上，DMA 技术就是我们在主板上放一块独立的芯片。在进行内存和 I/O 设备的数据传输的时候，我们不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器（DMA Controller，简称 DMAC）。这块芯片，我们可以认为它其实就是一个协处理器（Co-Processor）。\nDMAC 最有价值的地方体现在，当我们要传输的数据特别大、速度特别快，或者传输的数据特别小、速度特别慢的时候。\n比如说，我们用千兆网卡或者硬盘传输大量数据的时候，如果都用 CPU 来搬运的话，肯定忙不过来，所以可以选择 DMAC。而当数据传输很慢的时候，DMAC 可以等数据到齐了，再向 CPU 发起中断，让 CPU 去处理，而不是让 CPU 在那里忙等待。\n\u003c!DOCTYPE html\u003e Responsive Image 首先，CPU 还是作为一个主设备，向 DMAC 设备发起请求。这个请求，其实就是在 DMAC 里面修改配置寄存器。 CPU 修改 DMAC 的配置的时候，会告诉 DMAC 这样几个信息： 源地址的初始值：数据要从哪里传输过来。如果我们要从内存里面写入数据到硬盘上，那么就是要读取的数据在内存里面的地址 传输时候的地址增减方式：数据是从大的地址向小的地址传输，还是从小的地址往大的地址传输 传输的数据长度：也就是我们一共要传输多少数据 设置完这些信息之后，DMAC 就会变成一个空闲的状态（Idle）。 如果我们要从硬盘上往内存里面加载数据，这个时候，硬盘就会向 DMAC 发起一个数据传输请求。这个请求并不是通过总线，而是通过一个额外的连线。 然后，我们的 DMAC 需要再通过一个额外的连线响应这个申请。 DMAC 这个芯片，就向硬盘的接口发起要总线读的传输请求。数据就从硬盘里面，读到了 DMAC 的控制器里面。 DMAC 再向我们的内存发起总线写的数据传输请求，把数据写入到内存里面。 DMAC 会反复进行上面第 6、7 步的操作，直到 DMAC 的寄存器里面设置的数据长度传输完成。 数据传输完成之后，DMAC 重新回到第 3 步的空闲状态。 所以，整个数据传输的过程中，我们不是通过 CPU 来搬运数据，而是由 DMAC 这个芯片来搬运数据。但是 CPU 在这个过程中也是必不可少的。因为传输什么数据，从哪里传输到哪里，其实还是由 CPU 来设置的。这也是为什么，DMAC 被叫作 协处理器。\n参考资料 【硬件科普】电脑主板右下角的散热片下面究竟隐藏着什么？详解主板南桥芯片组的功能和作用_哔哩哔哩_bilibili\n","permalink":"https://lifeislife.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E4%B8%8Eio%E7%B3%BB%E7%BB%9F/","summary":"\u003ch2 id=\"存储器\"\u003e存储器\u003c/h2\u003e\n\u003ch3 id=\"存储器的层次结构\"\u003e存储器的层次结构\u003c/h3\u003e\n\u003ch4 id=\"sramstatic-random-access-memory静态随机存取存储器\"\u003eSRAM（Static Random-Access Memory，静态随机存取存储器）\u003c/h4\u003e\n\u003cp\u003eCPU 如果形容成人的大脑的话，那么 CPU Cache (高速缓存) 就好比人的记忆。它用的是 SRAM 芯片。\u003c/p\u003e\n\u003cp\u003eSRAM 的“静态”的意思是，只要处于通电状态，里面的数据就保持存在，一旦断电，数据就会丢失。SRAM 里 1bit 数据需要 6-8 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间，能够存的数据有限。因为其电路简单，访问速度非常快。\u003c/p\u003e","title":"计算机组成原理-存储与 IO 系统"},{"content":"建立数据通路：指令 + 运算=CPU 指令周期\nFetch（取得指令）：从内存里把指令加载到指令寄存器中。 Decode（指令译码） Execute（执行指令） 重复操作这三步，这个循环称为指令周期。 不同的步骤在不同组件内完成 \u003c!DOCTYPE html\u003e Responsive Image 机器周期/CPU周期：从内存里读取一条指令的最短时间。 时钟周期：就是机器的主频，一个 CPU 周期由多个时钟周期组成。\n\u003c!DOCTYPE html\u003e Responsive Image 操作元件：组合逻辑元件，ALU，功能是在特定的输入下，生成特定的输出。 存储元件：状态元件，寄存器。\n将操作元件，操作原件通过数据总线的方式连接起来，就建立了数据通路了。\n控制器：循环执行取址-译码，产生控制信号交给 ALU 处理。电路特别复杂，CPU 如果支持 2000 个指令，意味着控制器输出的信号有 2000 个不同的组合。\nCPU 需要的电路\n根据输入计算出结果的一个电路，ALU 能够进行状态读写的电路元件，寄存器 按照固定周期，不停实现 PC 寄存器自增的电路 译码电路，能够对于拿到的内存地址获取对应的数据或者指令 Q : CPU 好像一个永不停歇的机器，一直在不停地读取下一条指令去运行。那 为什么 CPU 还会有满载运行和 Idle 闲置的状态呢？ A：CPU 还会有满载运行和 Idle 闲置的状态，指的系统层面的状态。即使是 Idle 空闲状态，CPU 也在执行循环指令。 操作系统内核有 idle 进程，优先级最低，仅当其他进程都阻塞时被调度器选中。idle 进程循环执行 HLT 指令，关闭 CPU 大部分功能以降低功耗，收到中断信号时 CPU 恢复正常状态。CPU 在空闲状态就会停止执行，即切断时钟信号，CPU 主频会瞬间降低为 0，功耗也会瞬间降为 0。由于这个空闲状态是十分短暂的，所以你在任务管理器也只会看到 CPU 频率下降，不会看到降为 0。当 CPU 从空闲状态中恢复时，就会接通时钟信号，CPU 频率就会上升。所以你会在任务管理器里面看到 CPU 的频率起伏变化。\n实现一个完整的 CPU，除了组合逻辑电路，还需要时序逻辑电路。因为组合逻辑电路只是处理固定输入，得到固定输出，这种电路只能协助我们完成一些计算工作，干不了太复杂的工作。\n时序逻辑电路可以解决这几个问题：\n自动运行问题 时序电路接通之后可以不停地开启和关闭开关，进入一个自动运行的状态。这个使得我们上一讲说的，控制器不停地让 PC 寄存器自增读取下一条指令成为可能。 存储问题 通过时序电路实现的触发器，能把计算结果存储在特定的电路里面， 而不是像组合逻辑电路那样，一旦输入有任何改变，对应的输出也会改变。 时序协调问题 无论是程序实现的软件指令，还是到硬件层面，各种指令的操作都有先后的顺序要求。时序电路使得不同的事件按照时间顺序发生。 解决自动运行问题 实现时序逻辑电路的第一步就需要一个时钟。CPU 的主频是一个晶振来实现的，晶振生成的电路信号就是我们的时钟信号。\n实现如图所示，我们在原先一般只放一个开关的信号输入端，放上了两个开 关。一个开关 A，一开始是断开的，由我们手工控制；另外一个开关 B，一开始是合上的， 磁性线圈对准一开始就合上的开关 B。\n于是，一旦我们合上开关 A，磁性线圈就会通电，产生磁性，开关 B 就会从合上变成断 开。一旦这个开关断开了，电路就中断了，磁性线圈就失去了磁性。于是，开关 B 又会弹 回到合上的状态。这样一来，电路接通，线圈又有了磁性。我们的电路就会来回不断地在开 启、关闭这两个状态中切换。\n这个不断切换的过程，对于下游电路来说，就是不断地产生新的 0 和 1 这样的信号。如果 你在下游的电路上接上一个灯泡，就会发现这个灯泡在亮和暗之间不停切换。这个按照固定的周期不断在 0 和 1 之间切换的信号，就是我们的时钟信号。\n\u003c!DOCTYPE html\u003e Responsive Image 一般这样产生的时钟信号，就像你在各种教科书图例中看到的一样，是一个振荡产生的 0、1 信号。\n\u003c!DOCTYPE html\u003e Responsive Image 这种电路，其实就相当于把电路的输出信号作为输入信号，再回到当前电路。这样的电路构 造方式呢，我们叫作反馈电路（Feedback Circuit）。\n上面这个反馈电路一般可以用下面这个示意图来表 示，其实就是一个输出结果接回输入的反相器（Inverter），也就是我们之前讲过的非门。\n\u003c!DOCTYPE html\u003e Responsive Image 解决存储问题\n有了时钟信号，我们的系统里就有了一个像“自动门”一样的开关。利用这个开关和相同的 反馈电路，我们就可以构造出一个有“记忆”功能的电路。\n我们先来看下面这个 RS 触发器电路。这个电路由两个或非门电路组成。我在图里面，把它 标成了 A 和 B。\n或非门真值表：\nNOR 0 1 0 1 0 1 0 0 \u003c!DOCTYPE html\u003e Responsive Image 在这个电路一开始，输入开关都是关闭的，所以或非门（NOR）A 的输入是 0 和 0。对 应到我列的这个真值表，输出就是 1。而或非门 B 的输入是 0 和 A 的输出 1，对应输出 就是 0。B 的输出 0 反馈到 A，和之前的输入没有变化，A 的输出仍然是 1。而整个电 路的输出 Q，也就是 0。 当我们把 A 前面的开关 R 合上的时候，A 的输入变成了 1 和 0，输出就变成了 0，对应 B 的输入变成 0 和 0，输出就变成了 1。B 的输出 1 反馈给到了 A，A 的输入变成了 1 和 1，输出仍然是 0。所以把 A 的开关合上之后，电路仍然是稳定的，不会像晶振那样 振荡，但是整个电路的输出 Q 变成了 1。 这个时候，如果我们再把 A 前面的开关 R 打开，A 的输入变成和 1 和 0，输出还是 0，对应的 B 的输入没有变化，输出也还是 1。B 的输出 1 反馈给到了 A，A 的输入变成了 1 和 0，输出仍然是 0。这个时候，电路仍然稳定。开关 R 和 S 的状态和上面的第一步是一样的，但是最终的输出 Q 仍然是 1，和第 1 步里 Q 状态是相反的。我们的输入和刚才第二步的开关状态不一样，但是输出结果仍然保留在了第 2 步时的输出没有发生变 化。 这个时候，只有我们再去关闭下面的开关 S，才可以看到，这个时候，B 有一个输入必然是 1，所以 B 的输出必然是 0，也就是电路的最终输出 Q 必然是 0。 这样一个电路，我们称之为触发器（Flip-Flop）。接通开关 R，输出变为 1，即使断开开 关，输出还是 1 不变。接通开关 S，输出变为 0，即使断开开关，输出也还是 0。也就是， 当两个开关都断开的时候，最终的输出结果，取决于之前动作的输出结果，这个也就是我们说的记忆功能。\n面向流水线的指令设计 单指令周期处理器 一条 CPU 指令的执行，有三步：取得指令，译码，执行。需要一个时钟周期。自然设计指令时，我们也希望一整条指令能在一个时钟周期内完成。这就是单指令周期处理器。\n不过，时钟周期是固定的，但是指令的电路复杂程度是不同的，所以实际一条指令执行的时间是不同的。从前面的学习中也知道，随着门电路层数的增加，门延迟的存在，计算复杂的指令需要的时间更长。\n不同指令的执行时间不同，但是我们需要让所有指令都在一个时钟周期内完成，那就只好把执行时间最长的那个指令和时钟周期设成一样。\n\u003c!DOCTYPE html\u003e Responsive Image 所以，在单指令周期处理器里面，无论是执行一条用不到 ALU 的无条件跳转指令，还是一条计算起来电路特别复杂的浮点数乘法运算，我们都等要等满一个时钟周期。这样时钟频率就无法提高，因为太高了，有些复杂指令无法在一个时钟周期内运行完。\n到这可能就有人发问了，之前不是说一个 CPU 时钟周期，可以认为是完成一条简单指令的时间。为什么单指令周期处理器上，却成了执行一条最复杂的指令的时间？\n这是因为，无论是 PC 上使用的 Intel CPU，还是手机上使用的 ARM CPU，都不是单指令周期处理器，而是采用了一种叫作指令流水线（Instruction Pipeline）的技术。\n流水线设计 CPU 执行指令的过程和我们做饭一样，我们不会等米饭蒸好再洗菜，不会等肉腌好再切菜，而是蒸饭时，可以洗菜，腌肉时可以切菜。\nCPU 的指令执行过程，其实也是由各个电路模块组成的。我们在取指令的时候，需要一个译码器把数据从内存里面取出来，写入到寄存器中；在指令译码的时候，我们需要另外一个译码器，把指令解析成对应的控制信号、内存地址和数据；到了指令执行的时候，我们需要的则是一个完成计算工作的 ALU。\n\u003c!DOCTYPE html\u003e Responsive Image 这样一来，我们就不用把时钟周期设置成整条指令执行的时间，而是拆分成完成这样的一个一个小步骤需要的时间。同时，每一个阶段的电路在完成对应的任务之后，也不需要等待整个指令执行完成，而是可以直接执行下一条指令的对应阶段。\n如果我们把一个指令拆分成“取指令 - 指令译码 - 执行指令”这样三个部分，那这就是一个三级的流水线。如果我们进一步把“执行指令”拆分成“ALU 计算（指令执行）- 内存访问 - 数据写回”，那么它就会变成一个五级的流水线。\n五级的流水线，就表示我们在同一个时钟周期里面，同时运行五条指令的不同阶段。这个时候，虽然执行一条指令的时钟周期变成了 5，但是我们可以把 CPU 的主频提得更高了。我们不需要确保最复杂的那条指令在时钟周期里面执行完成，而只要保障一个最复杂的流水线级的操作，在一个时钟周期内完成就好了。\n如果某一个操作步骤的时间太长，我们就可以考虑把这个步骤，拆分成更多的步骤，让所有步骤需要执行的时间尽量都差不多长。\n既然流水线可以增加我们的吞吐率，你可能要问了，为什么我们不把流水线级数做得更深 呢？为什么不做成 20 级，乃至 40 级呢？这个其实有很多原因，我在之后几讲里面会详细讲解。这里，我先讲一个最基本的原因，就是增加流水线深度，其实是有性能成本的。\n我们用来同步时钟周期的，不再是指令级别的，而是流水线阶段级别的。每一级流水线对应 的输出，都要放到流水线寄存器（Pipeline Register）里面，然后在下一个时钟周期，交给下一个流水线级去处理。所以，每增加一级的流水线，就要多一级写入到流水线寄存器的操作。虽然流水线寄存器非常快，比如只有 20 皮秒（ps，10−12 秒）。\n但是，如果我们不断加深流水线，这些操作占整个指令的执行时间的比例就会不断增加。最后，我们的性能瓶颈就会出现在这些 overhead 上。如果我们指令的执行有 3 纳秒，也就 是 3000 皮秒。我们需要 20 级的流水线，那流水线寄存器的写入就需要花费 400 皮秒，占了超过 10%。如果我们需要 50 级流水线，就要多花费 1 纳秒在流水线寄存器上，占到 25%。这也就意味着，单纯地增加流水线级数，不仅不能提升性能，反而会有更多的 overhead 的开销。所以，设计合理的流水线级数也是现代 CPU 中非常重要的一点。\nFPGA/ASIC/TPU FPGA CPU 是由简单的门电路搭积木一样搭建出来的，那一个 CPU 里有多少个晶体管这样的电路开关呢？一个四核 i7 的 Intel CPU，有 20 亿个晶体管。那么问题来了，我们要设计一个 CPU，就要想办法连接这 20 亿个晶体管。\n连接一次已经很难了，我们还要根据问题重新调整连接。设计更简单的特定功能的芯片，少说要几个月。而设计一个 CPU 往往以年计。在这个过程中，硬件工程师要设计、验证各种各样的方案，可能会遇到各种 BUG。如果每验证一个方案都要生产一块芯片，这代价太高了。\n我们有没有什么办法，不用单独制造一块专门的芯片来验证 硬件设计呢？能不能设计一个硬件，通过不同的程序代码，来操作这个硬件之前的电路连线，通过“编程”让这个硬件 变成我们设计的电路连线的芯片呢？\n这个，就是我们接下来要说的 FPGA，也就是现场可编程门阵列（Field-Programmable Gate Array）。\nP 代表 Programmable，也就是说这 是一个可以通过编程来控制的硬件。 G 代表 Gate，它就代表芯片里面的门电路。我们能够去进行编程组合的就是这样一个一个门电路。 A 代表的 Array，叫作阵列，说的是在一块 FPGA 上，密密麻麻列了大量 Gate 这样的门电路。 F，不太容易理解。它其实是说，一块 FPGA 这样的板子，可以进行在“现场”多次地进行编程。它不像 PAL（Programmable Array Logic，可编程阵列逻辑）这样更古老的硬件设备，只能“编程”一次，把预先写好的程序一次性烧录到硬件里面，之后就不能再修改了。 我们之前说过，CPU 其实就是通过晶体管，来实现各 种组合逻辑或者时序逻辑。那么，我们怎么去“编程”连接这些线路呢？\nFPGA 的解决方案分三步：\n第一，用存储换功能实现组合逻辑。在实现 CPU 的功能的时候，我们需要完成各种各样的电路逻辑。在 FPGA 里，这 些基本的电路逻辑，不是采用布线连接的方式进行的，而是 预先根据我们在软件里面设计的逻辑电路，算出对应的真值表，然后直接存到一个叫作 LUT（Look-Up Table，查找 表）的电路里面。这个 LUT 呢，其实就是一块存储空间，里面存储了“特定的输入信号下，对应输出 0 还是 1”。\n\u003c!DOCTYPE html\u003e Responsive Image 第二，对于需要实现的时序逻辑电路，我们可以在 FPGA 里面直接放上 D 触发器，作为寄存器。这个和 CPU 里的触发器没有什么本质不同。不过，我们会把很多个 LUT 的电路和寄存器组合在一起，变成一个叫作逻辑簇（Logic Cluster）的东西。在 FPGA 里，这样组合了多个 LUT 和寄 存器的设备，也被叫做 CLB Configurable Logic Block，可配置逻辑块）。\n可以把 CLB 想象成函数或者 API，设计更复杂的功能，不用重新造轮子，只需要调用函数或者 API 即可。设计芯片也是一样，不用再从门电路开始搭建，可以通过 CLB 组合搭建。\n\u003c!DOCTYPE html\u003e Responsive Image 第三，FPGA 是通过可编程逻辑布线，来连接各个不同的 CLB，最终实现我们想要实现的芯片功能。这个可编程逻辑布线，你可以把它当成我们的铁路网。整个铁路系统已经铺 好了，但是整个铁路网里面，设计了很多个道岔。我们可以 通过控制道岔，来确定不同的列车线路。在可编程逻辑布线 里面，“编程”在做的，就是拨动像道岔一样的各个电路开 关，最终实现不同 CLB 之间的连接，完成我们想要的芯片 功能。\nASIC 除了 CPU，GPU 以及 FPGA，我们还需要用到很多其他芯片，比如除了音视频的芯片，或者专门用来挖矿的芯片。尽管 CPU 也能实现这些功能，但是有点大炮打蚊子的感觉。\n于是针对一些特殊场景，单独设计一个芯片，我们称这些芯片为 ASIC（Application-Specific Integrated Circuit），专用集成电路。设计精简，制造成本低。\n其实我们的 FPGA 也能做 ASIC 的事情，每次对 FPGA 进行编程，就是把 FPGA 电路编程了一个 ASIC。但是如果全用 FPGA，同样会浪费。因为每一个 LUT 电路，都可以实现与门以及或门，这比单纯连死的与门或者或门，用到的晶体管数量要多的多。自然功耗也要大得多，单片 FPGA 的生产制造成本也比 ASIC 要高。\nFPAG ASIC 一次性成本 极低，约等于 0 高 量产成本 高 低 延迟 低 低 开发周期 短 长 市场风险 低 高 开发环境 设置 FPGA 需要硬件知识，编程和配置门槛很高 需要底层硬件变成，开发难度很高 TPU TPU（Tensor Processing Unit）张量处理器；\n","permalink":"https://lifeislife.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%A4%84%E7%90%86%E5%99%A8/","summary":"\u003ch2 id=\"建立数据通路指令--运算cpu\"\u003e建立数据通路：指令 + 运算=CPU\u003c/h2\u003e\n\u003cp\u003e指令周期\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFetch（取得指令）：从内存里把指令加载到指令寄存器中。\u003c/li\u003e\n\u003cli\u003eDecode（指令译码）\u003c/li\u003e\n\u003cli\u003eExecute（执行指令）\n重复操作这三步，这个循环称为指令周期。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e不同的步骤在不同组件内完成\n\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011556148.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011556148.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"计算机组成原理-处理器"},{"content":"Gitee 图床挂了，但是各大云服务厂商提供的对象存储服务免费额度，对于个人小博客来说也够用了。下面介绍如何将图床更换为腾讯云 COS。\n下载原有图片 从gitee下载整个仓库。保持原有目录结构。\n配置腾讯云 COS 注册腾讯云账号，创建 COS 存储桶，选择公有读私有写。创建 COS 存储桶地址：https://console.cloud.tencent.com/cos，创建存储桶后可以在存储桶里打开防盗链设置。\n创建桶\u0026ndash;选择地域\u0026ndash;填写名称\u0026ndash;选择公有读私有写\u0026ndash;点击创建。\n\u003c!DOCTYPE html\u003e Responsive Image 如果忘了设置读写权限可以按一下方法设置； \u003c!DOCTYPE html\u003e Responsive Image 选择菜单\u0026ndash;文件列表。上传下载好的文件夹（整个仓库的文件夹）。鼠标放到选择文件出现上传文件夹选项，或者将文件夹拖入浏览器。\n\u003c!DOCTYPE html\u003e Responsive Image 配置 Picgo \u003c!DOCTYPE html\u003e Responsive Image COS 版本：V5 设定 Secreid，设定 Secrekey，设定 APPID： APPID、SecretID 与 SecretKey 点此直达获取。 选择继续使用\u0026ndash;创建秘钥。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 设定存储空间名，设定存储区域： 点此获取存储空间名以及存储区域。桶名称即存储空间名，所属区域：ap-shanghai即确认存储区域。\n\u003c!DOCTYPE html\u003e Responsive Image 指定存储区域： 指定上传到 COS 的目录，比如我原先从gitee下载来的图床的仓库名是markdown_picbed，图片又保存在markdown_picbed/img目录下，那么就指定markdown_picbed/img目录。\n\u003c!DOCTYPE html\u003e Responsive Image 替换旧图床 URL VSCode 全局替换：\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E6%9B%BF%E6%8D%A2gitee%E5%9B%BE%E5%BA%8A%E4%B8%BA%E8%85%BE%E8%AE%AF%E4%BA%91cos/","summary":"\u003cp\u003e\u003ca href=\"https://cloud.tencent.com/developer/article/1964208\"\u003eGitee 图床挂了\u003c/a\u003e，但是各大云服务厂商提供的对象存储服务免费额度，对于个人小博客来说也够用了。下面介绍如何将图床更换为腾讯云 COS。\u003c/p\u003e\n\u003ch2 id=\"下载原有图片\"\u003e下载原有图片\u003c/h2\u003e\n\u003cp\u003e从\u003ccode\u003egitee\u003c/code\u003e下载整个仓库。保持原有目录结构。\u003c/p\u003e","title":"替换 Gitee 图床为腾讯云 COS"},{"content":"静态链接 库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。\n第三章 目标文件里有什么 目标文件的格式 目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。\n现在 PC 平台流形的可执行文件格式，主要是 Windows 下的 PE（Portable Executable）和 Linux 下的 ELF（Executable Linkable Format）,它们都是 COFF（Common file format）格式的变种。\n指令和数据分开存放的好处：\n一方面当程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被设置成可读写和只读，这样可以防止程序的指令被有意或无意地改写。\n另一方面是现代 CPU 有强大的缓存体系，由于缓存很重要，所以程序必须尽量提高缓存命中率。指令区和数据区分离有利于提高程序的局部性。现代 CPU 的缓存一般都被设计成数据缓存和指令缓存，所以程序的指令和数据分开存放对于 CPU 的缓存命中率提高有好处。\n第三个原因，也是最重要的原因，就是当系统中运行着多个该进程副本时，他们的指令都是一样的，所以内存中只需要保存一份程序的指令部分。\n真正了牛逼的程序员对自己的程序每一个字节都了如指掌。\nobjdump -h SimpleSsection.o # 打印elf文件各个段的信息 size SimpleSsection.o # 查看elf文件各个段的长度 objdump -s -d SimpleSsection.o # -s将所有段内容以十六进制打印，-d将所有包含指令的段反汇编 段名称 内容 .data - 初始化的全局变量 - 局部静态变量 .rodata 只读数据段，对这个段的任何修改都是非法的，保证了程序的安全性。 有时候编译器会把字符串放到 data 段\n- 只读变量 const 修饰 - 字符串常量 .bss 不占磁盘空间， - 未初始化的全局变量 - 未初始化的局部静态变量 - 初始化为 0 的静态变量 .comment 存放编译器版本信息，比如字符串“GCC：（GNU）4.2.0” .line 调试时的行号表，即源代码行号与编译后指令的对应表 .note 额外的编译器信息，如程序公司名，版本号 .symtab Symbol Table 符号表 .plt 动态链接的跳转表 .got 动态链接的全局入口表 段名称都是.前缀，表示这些表名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名称。比如可以加入一个music段，里面存一首 mp3 音乐，运行起来后就会播放音乐，打算自定义段不能使用.作为前缀，以免与系统保留段名冲突。\nQ: 如何将一个二进制文件，如图片，MP3 文件作为目标文件的一个段？ A: 可以使用 objcopy 工具，比如有一个图片 image..jpg，大小为 0x2100 字节： $ objcopy -I binary -O elf32-i388 -B i38 image.jpg image.o\n正常情况下编译出来的目标文件，代码会放到.text段，但是有时候你希望变量或者某些代码能放到你指定的段中去，以实现某些特定的功能。比如为了满足某些硬件的内存和 IO 地址布局。GCC 提供了扩展机制，使得程序员可以指定变量所处的段：\n__attribute__((section(\u0026#34;FOO\u0026#34;))) int global = 42; __attribute__((section(\u0026#34;BAR\u0026#34;))) void foo; ELF 文件结构 使用readelf命令查看 elf 文件详细信息。\nELF 魔数，确认文件类型。\n文件类型\n常量 值 含义 ET_REL 1 可重定位文件，一般问.o文件 ET_EXEC 2 可执行文件 ET_DYN 3 共享目标文件，一般为.so文件 机器类型\n常量 值 含义 EM_M32 1 AT\u0026amp;T WE 32100 EM_SPARC 2 SPARC EM_M386 3 Intel x86 EM_68K 4 Motorola 68000 EM_88K 5 Motorola 88000 EM_860 6 Intel 80860 段表是保存各个段的基本属性的结构。段表是除文件头外最重要的结构。编译器，链接器和装载器都是依靠段表来定位和访问各个段的属性。\n链接的接口 - 符号 符号表结构 链接过程的本质就是要把多个不同的目标文件之间相互粘到一起。\n目标文件 B 要用到目标文件 A 的函数foo，我们称目标文件 A定义了函数foo，目标文件 B引用了目标文件 A 的函数foo。\n链接中，我们将函数和变量统称为符号，函数名或变量名就是符号名。、\n每一个目标文件都会有一个相应的符号表，表里记录了目标文件中所用到的所有符号。每个符号都有一个对应值，叫符号值，对于变量和函数来说，符号值就是他们的地址。\n符号类型：\n定义在本目标文件的全局符号，可以被其他目标引用。 在本目标文件中应用的全局符号，却没有定义在本目标文件。 段名称，也就是段起始地址。 局部符号，一些静态变量等。 行号信息。 最重要的就是第一类和第二类。链接只关心全局符号的相互粘合，其他都是次要的。\n可以使用 readelf objdump nm等命令查看符号信息。\n特殊符号 一些特殊符号，没有在程序中定义，但是可以直接声明并引用它：\n__executable_start，程序起始地址，不是入口地址，是程序最开始的地址。 __etext __etext etext 代码段结束地址，代码段最末尾的地址。 _edata edata 数据段结束地址，数据段最末尾地址。 __end end 程序结束地址。 符号修饰 符号应与对应的函数或者变量同名，但是在 C 语言发明时，已经存在了很多库和目标文件，如果再用一样的函数或变量就会冲突为了避免冲突，C 语言编译后符号名前会加上下划线_，如foo变成_foo，Fortran 语言编译后会在符号前后加上下划线_foo_。\nC++具有类，继承，重载等复杂机制，为了支持这些复杂特性，人们发明了符号修饰和符号改编。\n函数签名包含了一个函数的信息，包括函数名，参数类型，所在类和名称空间等信息。它用于识别不同的函数。在编译器和链接器处理符号时，使用某种名称修饰的方法，是的每个函数签名对应一个修饰后名称。\n由于不同的编译器采用不同的名字修饰方式，必然导致由不同编译器编译产生的目标文件无法正常互相链接，这是导致不同编译器之间不能互操作的主要原因之一。\nextern C C++为了兼容 C，C++编译器会将在extern C 的大括号内部的代码当做 C 语言代码处理，这样就不会使用 C++的名称修饰机制。（也就不会在编译的时候加上下划线）\n但是 C 语言并不支持extern C关键字，又不能为同一个库函数写两套头文件，这时候就可以用 C++的宏，__cplusplus。C++编译器会在编译 C++的程序时默认定义这个宏，我们可以用条件宏来判断当前编译单元是不是 C++代码。\n#ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif void *memset(void *, int , size_t); #ifdef __cplusplus } #endif 弱符号与强符号 我们经常碰到符号重定义，多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候就会出现符号重定义的错误。比如在两个文件中定义了相同的全局变量。\n对于C/C++来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。\n也可以使用 GCC 的__attribute__((weak))来定义任何一个强符号为弱符号。\n不允许强符号被多次定义，如果多次定义，则链接器报重复定义错误； 如果一个符号在某文件中是强符号，在其他文件中都是弱符号，那么选择强符号。 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。 第四章 静态链接 空间地址分配 可执行文件中的代码段和数据段就是多个文件合并而来的，对于多个文件链接器如何将它们合并到输出文件？\n按序叠加：最简单的方式，按照输入文件顺序依次合并。这会导致大量碎片，比如 x86 的硬件，段的装载地址和空间的对齐单位是页，也就是 4096 字节，那么如果一个段的长度只有 1 字节，它在内存里也要占用 4096 字节。\n相似段合并：将所有相同性质的段合并在一起。\n现在的链接器基本上采用第二种。使用这种方法的链接器都采用一种叫两步链接的方法。\n第一步，空间与地址分配。扫描所有的输入目标文件，并且获得各个段的长度，属性和位置，并将输入目标文件中的符号表所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步，链接器将能够获得所有输入目标文件的段长度，并且将他们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。\n第二部，符号解析与重定位。使用上面收集到的信息，读取输入文件中段的数据，重定位信息。并且进行符号解析与重定位，调整代码中的地址。\nVMA（Virtual Memory Address）虚拟地址，LMA（Load Memory Address）加载地址。正常情况这两个值是一样的。\n链接之前目标文件的所有短 VMA 都是 0，因为虚拟空间还没有被分配，默认为 0，链接之后各个段就会被分配相应的虚拟地址。\nLinux 下，ELF 可执行文件默认从地址0x8048000开始分配。\n符号解析与重定位 objdump -d 查看代码段反汇编结果 源代码在编译成目标文件时并不知道函数的调用地址。需要通过链接时重定位。\n链接器如何知道哪些指令需要被调整？这就用到了重定位表。\n重定位表就是 ELF 文件的一个段，所以其实重定位表也可以叫重定位段。\nobjdump -r 查看重定位表 每个要被重定位的地方叫一个重定位入口（Relocation Entry）。\n重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，或引用到定义在其他文件的符号。重定位过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，他就要确定这个符号的目标地址。这时候链接器就会取查找由所有输入目标文件的符号表组成的全局符号表，找到对应的符号进行重定位。\nreadelf -s 查看符号表 对于 32 位 x86 平台下的 ELF 文件的重定位入口所修正的指令寻址方式只有两种：\n绝对近址 32 位寻址 相对近址 32 位寻址 x86 基本重定位类型\n宏定义 值 重定位修正方法 R_386_32 1 绝对寻址修正 S+A R_386_PC32 2 相对寻址修正 S+A-P A = 保存在被修正位置的值 P = 被修正的位置 (相对于段开始的偏移量或者虚拟地址)，注意，该值可通过 r_offset 计算得到 S = 符号的实际地址，即由 r_info的高 24 位指定的符号的实际地址\n第六章 可执行文件的装载与进程 程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。\nCOMMON 块 Q:在目标文件中，编译器为什么不直接把未初始化的全局变量也当做未初始化的局部静态变量一样处理，为它在 BSS 段分配空间，而是将其标记为一个 COMMON 类型的变量？ A:当编译器将一个编译单元编译成目标文件时，如果该编译单元包含了弱符号（未初始化的全局变量就是典型），那么该弱符号最终所占大小未知，因为有可能其他编译单元中该符号所占空间比当前的大所以编译器此时无法为该符号在 BSS 段分配空间。但链接器在链接过程中可以确定弱符号大小，因为当链接器读取所有输入目标文件后，任何一个弱符号大小都可以确定，所以它可以在最终输出文件的 BSS 段为其分配空间。总体来看，未初始化全局变量最终还是被放在 BSS 段。\nGCC 的-fno-common吧所有未初始化的全局变量不以 COMMON 块形式处理。\n__attribute__扩展也可以实现，int global __attribute__((nocommon))。这样未初始化的全局变量就是强符号。\nQ: 为什么静态运行库里面一个目标文件只包含一个函数？比如 libc.o 里面 printf.o 只包含 printf() 函数，strlen.o 只有 strlen 函数？ A:因为链接器在链接静态库时是以目标文件为单位的，比如我们引用了静态库中的 printf 函数，那么链接器就会把库中包含 printf 函数的那个目标文件链接进来，如果很多函数写在一个目标文件中，就将没用到的函数一起链接进了输出结果中。\n链接的过程控制 第 6 章 可执行文件的装载与进程 程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。\n可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件又被叫做映像文件 (Image)。\nSegment 和 Section 很难从中文翻译上区分，ELF 文件按 Section 存储的，从装载的角度 ELF 文件又可以按照 Segment 划分。\n段地址对齐 可执行文件需要被装载，装载一般通过虚拟内存页映射机制完成，页是映射的最小单位，对于 x86 处理器来说，默认页大小为 4096 字节，所以内存空间的长度必须是 4096 的整数倍，并且这段空间在物理内存和进程虚拟地址空间的起始地址必须是 4096 的整数倍。\n第 7 章 动态链接 第七章 动态链接 为什么要动态链接？ 内存和磁盘空间：如果两个程序都用到一个静态库，链接时就会有静态库的两个副本，运行时就会占用两份内存。 程序的开发与发布：一个程序用到的静态库如果有更新，那么程序就需要重新链接，发布给用户。 要解决以上问题，最简单的方法就是把程序的模块相互分割开来，形成独立的文件，而不再将它们静态链接。就是不对目标文件进行链接，而等到程序运行时再链接。这就是动态链接的基本思想。\n动态链接模块的装载地址是从0x00000000开始的。\n共享对象的最终装载地址在编译时是不确定的。\n地址无关代码 静态共享库：将程序的各个模块交给操作系统管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。\n装载时重定位：程序在编译时被装载的目标地址为0x1000，但是在装载时操作系统发现0x1000这个地址已经被别的程序使用了，从0x4000开始有一块足够大的空间可以容纳，那么该程序就可以被装载至0x4000，程序指令和数据所有引用都只需要加上0x3000偏移量即可。因为他们在程序中的相对位置是不会改变的。\n地址无关代码为了解决共享对象指令中对绝对地址的重定位问题，基本想法是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。\n模块中四类地址引用：\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 模块内部调用或者跳转 不需要重定位，本身就是地址无关的。\n模块内部数据访问 指令中不能包含数据的绝对地址，所以使用相对寻址的方式。\n模块间数据访问 把跟地址相关的部分放到数据段里面。ELF 的做法是在数据段里面建立一个指向这些数据的指针数据，称为全局偏移表（GOT）。当代码需要引用全局变量时，可以通过 GOT 间接引用。\n链接器在装载时会查找每个变量的地址，填充 GOT 每个项，当指令中需要访问变量时，程序会先找到 GOT，根据 GOT 中对应的地址，找到对应的变量。GOT 本身放在数据段，所以他可以在模块装载时被修改，并且每个进程有独立副本，相互不影响。\n以访问变量 b 为例，程序首先计算出变量 b 的地址在 GOT 中的位置，即\n0x10000000 + 0x454 + 0x118c + 0xfffffff8 = 0x100015d8\n0xfffffff8为-8的补码表示，然后使用寄存器间接寻址方式给变量 b 赋值 2。\n模块间调用跳转 类似于模块机数据访问，不同的是 GOT 中相应项保存的是目标函数的地址。\n各种地址引用方式\n指令跳转，调用 数据访问 模块内部 相对跳转和调用 相对地址访问 模块外部 间接跳转和调用（GOT） 间接访问（GOT） Q : -fpic 和-fPIC 的区别？ A: 都是 GCC 产生地址无关代码的参数。-fpic产生的代码较小，-fPIC产生的代码较大。因为地址无关代码和硬件平台相关，在一些平台上-fpic会受到限制，比如全局符号的数量或者代码长度等，而后者没有这样的限制。\nQ: 如果一个共享对象 lib.so 中定义了一个全局变量 G，进程 A 和进程 B 都是用了 lib.so。那么当进程 A 改变这个全局变量时，进程 B 的 G 是否受到影响？ A: 不会，应当 lib.so 被加载时，它的数据段部分在每个进程都有独立的副本。如果是同一个进程里的线程 A 和线程 B，那么他们是共享数据 G 的。\n如果代码不是地址无关的，它就不能被多个进程共享，就失去了节省内存的优点。但是装载是重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数是需要做一次计算当前地址以及间接地址寻址的过程。\n延迟绑定 PLT 动态链接要比静态链接慢，一是因为动态链接下，对全局和静态数据的访问都要进行复杂的 GOT 定位，然后间接寻址。另外，程序开始执行时，动态链接器都要进行一次链接工作。\n而在一个程序运行过程中，可能很多函数在程序执行完时都不会用到，如果一开始就把所有函数链接好实际就是一种浪费，所有 ELF 采用了一种叫做延迟绑定的做法，基本思想就是当函数第一次使用时才进行绑定（符号查找，重定位等）。\nELF 使用 PLT（Procedure Linkage Table）来实现延迟绑定。以调用bar()函数为例，之前的做法是通过 GOT 中的相应项进行跳转，而延迟绑定下，在这过程中间加了一层 PLT 间接跳转。每个外部函数在 PLT 中都有一个对应项，比如bar()在 PLT 中项的地址为bar@plt。\nbar@plt: jmp *(bar@GOT) push n push moduleID jump _dl_runtime_resolve 第一条是指令通过 GOT 间接跳转的指令，如果链接器在初始化阶段已经初始化该项，并将bar()地址填入该项，那么就能正确跳转到bar()。但是为了延迟绑定，链接器初始化时并没有将bar()地址填入，而是将第二条指令push n的地址填入了bar@GOT中，这一步不需要查找符号，代价很低。\n第一条指令的效果就是跳转到第二条指令，第二条指令将数字n压入堆栈，这个数字是bar这个符号引用在重定位表.rel.plt中的下标。第三条指令将模块 ID 压入堆栈，最后跳转到_dl_runtime_resolve。\n_dl_runtime_resolve进行一系列工作后将bar()真正地址填入到bar@GOT。\n一旦bar()这个函数被解析完，当面再次调用bar@plt时，第一条jump指令就能跳转到bar()的真正地址。bar()函数返回时根据堆栈里保存的EIP直接返回到调用者，而不会执行bar@plt中第二条指令。那段代码只会在符号未被解析时执行一次。\nPLT 在 ELF 文件中以独立段存在，段名通常叫做.plt，因为它本身是一些地址无关的代码，所以可以跟代码段合并成同一个可读可执行的 Segment 被装载入内存。\n动态链接相关结构 .interp 段\nobjdump -s a.out Contents of section .interp: 804811 2f6c6962 2f6c696d 6c696e78 782e736f /lib/ld-linux.so.2 里面保存的就是可执行文件所需要的动态链接器的路径，在 Linux 下，可执行文件动态链接器几乎都是/lib/ld-linux.so.2。\n这是个软链接，会他会指向系统中安装的动态链接器。当系统中的 Glibc 库更新时，软链接也会指向新的动态链接器，所以.interp段不需要修改。\n可以通过以下命令查看可执行文件需要的动态链接器的路径：\n$ readelf -l a.out | grep interpreter [Requesting program interpreter: /lib/ld-linux.so.2] .dynamic 段\n动态链接 ELF 中最重要的结构，这里保存了动态链接器所需要的基本信息，如依赖哪些共享对象，动态链接符号表的位置，动态链接重定位表的位置，共享对象初始化代码的地址等。\n动态符号表\nProgram1程序一来Lib.so，引用到了里面的foobar()函数，那么对于Program1来说，称Program1导入（Import）了foobar函数，foobar是Program1的导入函数。\n而站在Lib.so角度来说，它定义了foobar函数，我们称Lib.so导出（Export）了foobar函数，foobar是Lib.so的导出函数。\n为了表示动态链接这些模块之间的符号导入导出关系，ELF 专门有一个叫做动态符号表的段来保存这些信息，段名通常叫.dynsym。\n.dynsym只保存与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。\n动态链接重定位表\nPIC 模式的共享对象也需要重定位。\n对于使用 PIC 技术的可执行文件或共享对象来说，虽然代码段不需要重定位，但是数据段还包含了绝对地址的引用，因为代码段中绝对地址相关的部分被分离出来，变成了 GOT，而 GOT 实际上是数据段的一部分。\n目标文件的重定位在静态链接时完成，共享对象的重定位在装载时完成。\n目标文件里包含专门用于重定位信息的重定位表，比如.rel.text表示是代码段重定位表，.rel.data表示数据段重定位表。\n共享对象里类似的重定位表叫做.rel.dyn和.rel.plt。.rel.dyn实际上是对数据引用的修正，它所修正的位置位于.got以及数据段；.rel.plt实际上是对代码引用的修正，它所修正的位置位于.got.plt。\n用以下命令可以查看重定位表；\n\u003c!DOCTYPE html\u003e Responsive Image printf这个重定位入口，它的类型为R_386_JUMP_SLOT，它的偏移为0x000015d8。它实际位于.got.plt中，前三项是被系统占用的，第四项开始才是真正存放导入函数地址的地方，刚好是0x000015c8 + 4 * 3 = 0x000015d4，即__gmon_start__。\n当动态链接器要进行重定位时，先查找printf的地址，假设链接器在全局符号表中找到printf的地址为0x08801234，那么链接器就会将这个地址填入.got.plt中偏移为0x000015d8的位置。从而实现了地址重定位，即动态链接最关键的一步。\n\u003c!DOCTYPE html\u003e Responsive Image 动态链接时进程堆栈初始化信息 动态链接的步骤和实现 动态链接分为三步：启动动态链接本身，装载所有的共享对象，重定位和初始化。\nQ：动态链接器本身是动态链接还是静态链接？ A：动态链接器本身应该是静态链接的，它不能依赖于其他共享对象，动态链接器本身使用来帮助其他 ELF 文件解决共享对象依赖问题的，如果它也依赖其他共享对象，那就陷入矛盾了。\nQ：动态链接器本身必须是 PIC 的吗？ A：动态链接器可以是 PIC 的也可以不是，但是往往用 PIC 会简单一些。\nQ：动态链接器可以被当做可执行文件运行，那么它的装载地址是多少？ A：ld.so 的装载地址跟一般的共享对象一样，即0x00000000。这个装载地址是一个无效的装载地址，作为一个共享库，内核在装载它时会为其选择一个合适的装载地址。\n显示运行时链接 第 10 章 内存 程序的内存布局 在 32 位操作系统里，有 4GB 的寻址能力，大部分操作系统会将一部分挪给内核使用，应用程序无法直接访问这段内存。这部分称为内核空间。Windows 默认将高地址的 2GB 分给内核，Linux 默认分 1GB 给内核。\n剩下的称为用户空间，在用户空间里也有一些特殊的地址区间：\n栈：维护函数调用上下文，通常在用户空间的最高地址处分配。 堆：用来容纳程序动态分配的内存区域，当使用 malloc 或者 new 分配内存时，得到的内存来自于堆。通常在栈下方。 可执行文件映像：存储可执行文件再内存里的映像，由装载器在装载时将可执行文件的内存读取活映射到这里。 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。比如NULL。 \u003c!DOCTYPE html\u003e Responsive Image 栈与调用惯例 栈保存了一个函数调用所需要的维护信息，通常这被称为栈帧。一般包括如下几个方面：\n函数的返回地址和参数 临时变量 保存的上下文 一个函数的调用流程：\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image I386 标准函数进入和退出指令序列，基本形式：\npush ebp mov ebp, esp sub esp, x [push reg1] ... [push regn] 函数实际内存 [pop regn] ... [pop reg1] mov esp, ebp pop ebp ret Hot Patch Prologue 热补丁 在 Windows 函数里，有些函数尽管使用了标准的进入指令序列，但是在这些指令之前却插入了一些特殊内容：\nmov edi,edi 这条指令没有任何用，在汇编之后会成为一个占用 2 字节的机器码，纯粹为了占位符而存在，使用这条指令开头的函数整体看起来是这样的：\nnop nop nop nop nop FUNCTION: mov edi,edi push ebp mov ebp, esp 其中 nop 占 1 个字节，也是占位符，FUNCTION 为一个标号，表示函数入口，本身不占空间。\n设计成这样的函数在运行时可以很容易被其他函数替换掉，在上面的指令序列中调用的函数是 FUNCTION，但是我们可以做一些修改，可以在运行时刻意改成调用函数 REPLACEMENT_FUNCTION。首先在进程内存空间任意处写入 REPLACEMENT_FUNCTION 的定义：\nREPLACEMENT_FUNCTION: push ebp mov ebp, esp ... mov esp, ebp pop ebp ret 然后修改原函数的内容：\nLABEL: # 标号不占字节 jmp REPLACEMENT_FUNCTION # 占5字节，刚好五个nop FUNCTION: # 函数入口标号，不占字节 jmp LABEL # 近跳指令，占2字节，跳跃到上方，即使截获失败也不影响原函数执行 push ebp mov ebp, esp ... 将 5 个nop换成一个jmp指令，然后将占用两个字节的mov edi,edi换成另一个jmp指令。因为这个jmp指令跳转的距离非常近，因此被汇编器翻译成了一个“近跳”指令，这种指令只占用两个字节。但只能跳跃到当前地址前后 127 个字节范围的目标位置。\n这里的替换机制，可以实现一种叫做钩子（HOOK）的技术，允许用户在某时刻截获特定函数的调用。\n函数传递参数时压栈顺序，传递参数是寄存器传参还是栈传参等等都需要遵守一定的约定，否则函数将无法正确执行，这样的约定称为调用惯例。\n一个调用惯例一般会规定如下几个方面：\n函数参数的传递顺序和方式 调用方压栈，函数自己从栈用取参数 调用方压栈顺序：从左至右，还是从右至左？ 栈的维护方式 参数出栈，可以由调用方完成还是由函数自己完成？ 名字修饰的策略 为了链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰，不同调用惯例有不同的名字修饰策略 没有显示指定调用惯例的函数默认是cdecl惯例 int _cdecl foo(int n, float m) _cdel 是非标准关键字，在不同编译器中写法不同，在 gcc 中使用的是__attribute__((cdecl))\n附录 文件名 英文名 Linux 扩展名 英文名 Windows 扩展名 功能 DSO-Dynamic Shared Objects ELF 动态链接文件，动态共享对象，共享对象 .so DLL-Dynamic Linking Library 动态链接库 .dll 1111 Static Shared Library 静态共享库 2222 2222 2222 2222 2222 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 ","permalink":"https://lifeislife.cn/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","summary":"\u003ch2 id=\"静态链接\"\u003e静态链接\u003c/h2\u003e\n\u003cp\u003e库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。\u003c/p\u003e\n\u003ch2 id=\"第三章-目标文件里有什么\"\u003e第三章 目标文件里有什么\u003c/h2\u003e\n\u003ch3 id=\"目标文件的格式\"\u003e目标文件的格式\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e目标文件\u003c/strong\u003e从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。\u003c/p\u003e","title":"程序员的自我修养笔记"},{"content":"什么是 Die-to-Die 接口 Author：Synopsys 译：What is a Die-to-Die Interface? – How it Works | Synopsys\n定义 裸片到裸片（Die2Die）接口是一个功能块，它提供组装在同一封装中的两个硅管芯之间的数据接口。芯片到芯片接口利用非常短的通道连接封装内的两个芯片，以实现功率效率和非常高的带宽效率，这超出了传统芯片到芯片接口所能达到的效果。\nDie2Die 接口通常由 PHY 和控制器块组成，控制器块在两个 die 上的内部互连结构之间提供无缝连接。Die2Die 的 PHY 使用高速 SerDes 架构或高密度并行架构实现，经过优化以支持多种先进的 2D、2.5D 和 3D 封装技术。\nDie2Die 接口是推动行业趋势从单片 SoC 设计转向同一封装中的多 Die SoC 组件的关键推动力。这种方法减轻了人们对小型工艺节点的高成本/低产量日益增长的担忧，并提供了额外的产品模块化和灵活性。\nDie-to-Die 接口如何工作？ Die2Die 的接口，就像任何其他芯片到芯片的接口一样，在两个芯片之间建立了可靠的数据链路。\n接口在逻辑上分为物理层、链路层和事务层。它在芯片运行期间建立和维护链路，同时向应用程序提供连接到内部互连结构的标准化并行接口。\n通过添加诸如前向纠错 (FEC) 和/或循环冗余码 (CRC) 和重试等错误检测和纠正机制来保证链路可靠性。\n物理层架构可以是基于 SerDes 或基于并行的。\n基于 SerDes 的架构包括并行到串行（串行到并行）数据转换、阻抗匹配电路和时钟数据恢复或时钟转发功能。它可以支持更高带宽的 NRZ 信令或 PAM-4 信令，最高可达 112 Gbps。SerDes 架构的主要作用是尽量减少简单 2D 类型封装（如有机基板）中的 I/O 互连数量。\n基于并行的架构包括许多并行的低速简单收发器，每个收发器都由驱动器和具有转发时钟技术的接收器组成，以进一步简化架构。它支持 DDR 类型的信令。并行架构的主要作用是最大限度地降低密集 2.5D 型封装（如硅中介层）的功耗。\nDie2Die 的优势 现代芯片实现趋向于基于在封装中组装多个裸片以提高模块化和灵活性的解决方案。当（单片）芯片尺寸接近全光罩尺寸时，这种多管芯方法还通过将功能分成几个管芯来提高产量，从而促进更具成本效益的解决方案。\nDie 之间的接口必须满足此类系统的所有关键要求：\n电源效率。多芯片系统实现应该与等效的单片实现一样节能。Die2Die 链接使用短距离、低损耗的信道，没有明显的不连续性。PHY 架构利用良好的通道特性来降低 PHY 复杂性并节省功耗。\n低延迟。将服务器或加速器 SoC 划分为多个 Die 不应导致内存架构不统一，因为访问不同 Die 中的内存具有显着不同的延迟。Die2Die 接口实现了简化的协议，并直接连接到芯片互连结构，以最大限度地减少延迟。\n高带宽效率。高级服务器、加速器和网络交换机需要在 Die 之间传输大量数据。Die2Die 接口必须能够支持所有需要的带宽，同时减少 Die 边缘的占用。通常使用两种替代方案来实现此目标：通过以非常高的每通道数据速率（高达 112 Gbps）部署 PHY 来最小化所需通道的数量，或者通过使用更精细的凸块间距（微凸块）来增加 PHY 的密度) 在大量并行化以实现所需带宽的低数据速率通道（高达 8 Gbps/通道）上。\n健壮的链接。Die2Die 链接必须没有错误。该接口必须实现足够强大的低延迟错误检测和纠正机制，以检测所有错误并以低延迟纠正它们。这些机制通常包括 FEC 和重试协议。\nDie-to-Die 接口用例 通过将多个 Die 组合到一个封装中，小芯片提供了另一种扩展摩尔定律的方法，同时实现了产品模块化和工艺节点优化。小芯片用于计算密集型、工作负载繁重的应用程序，如高性能计算 (HPC)。\n针对 HPC、网络、超大规模数据中心和人工智能 (AI) 等应用程序的 die-to-die 接口有四个主要用例：\nScale SoC 目标是通过虚拟（裸片到裸片）连接来连接裸片，从而提高计算能力并为服务器和 AI 加速器创建多个 SKU，从而实现裸片之间的紧密耦合性能。\nSplit SoC 目标是启用非常大的 SoC。大型计算和网络交换机芯片正在接近光罩限制。将它们分成几个裸片会带来技术可行性、提高产量、降低成本并扩展摩尔定律。\nAggregate 其目的是聚合在不同模具中实现的多种不同的功能，以利用每个功能的最佳工艺节点，降低功率，并改善 FPGA、汽车和 5G 基站等应用的外形尺寸。\nDisaggregate 目标是将中央芯片与 I/O 芯片分离，以便将中央芯片轻松迁移到高级工艺，同时将 I/O 芯片保持在保守节点中，以降低产品演进的风险/成本，实现重用并缩短时间在服务器、FPGA、网络交换机和其他应用程序中投放市场。\nDie-to-Die 接口和 Synopsys Synopsys 结合了广泛的 Die2Die 112G USR/XSR 和 HBI PHY IP、控制器 IP 和中介层专业知识产品组合，提供全面的 die-to-die IP 解决方案，以支持芯片拆分、芯片分解、计算扩展和聚合的功能。基于 SerDes 的 112G USR/XSR PHY 和基于并行的 8G OpenHBI PHY 可用于高级 FinFET 工艺。可配置控制器使用具有重放和可选 (FEC) 功能的纠错机制，以最大限度地降低可靠芯片到芯片链接的误码率。它支持用于连贯和非连贯数据通信的 Arm® 特定接口。\nQ\u0026amp;A PHY 架构 SerDes 架构 reticle LCD 厂掩膜版叫 Mask,Fab 里掩膜版叫 reticle，两者有什么区别？ - 知乎 原文参考 What is a Die-to-Die Interface? – How it Works | Synopsys\n","permalink":"https://lifeislife.cn/posts/zh-%E4%BB%80%E4%B9%88%E6%98%AFdie-to-die%E6%8E%A5%E5%8F%A3/","summary":"\u003ch1 id=\"什么是-die-to-die-接口\"\u003e什么是 Die-to-Die 接口\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAuthor：Synopsys\n译：\u003ca href=\"https://www.synopsys.com/glossary/what-is-die-to-die-interface.html\"\u003eWhat is a Die-to-Die Interface? – How it Works | Synopsys\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\u003cp\u003e裸片到裸片（Die2Die）接口是一个功能块，它提供组装在同一封装中的两个硅管芯之间的数据接口。芯片到芯片接口利用非常短的通道连接封装内的两个芯片，以实现功率效率和非常高的带宽效率，这超出了传统芯片到芯片接口所能达到的效果。\u003c/p\u003e","title":"ZH-什么是 Die-to-Die 接口"},{"content":"可执行程序放到指定目录 默认情况下 QtCreator 会将编译链接后的可执行程序与中间生成的文件防盗build-***-文件中，如何能将可执行文件生成在指定目录？\n修改.pro:\nCONFIG(debug ,debug|release){ DESTDIR = ../debug }else{ DESTDIR = ../release } debug版本放在../debug目录中，release版本放在../release目录中。\n屏蔽 qDebug 输出 CONFIG(debug ,debug|release){ DEFINES -= QT_NO_DEBUG_OUTPUT }else{ DEFINES += QT_NO_DEBUG_OUTPUT } QT_NO_DEBUG_OUTPUT即为屏蔽 qDebug 输出的宏定义，可以在debug版本中不屏蔽 qDebug 输出，release版本中屏蔽 qDebug 输出。\n参考 QT 屏蔽 qDebug()、qWarning() 打印信息_qq_35173114 的博客-CSDN 博客_qwarning QT 的 QDebug 无法输出日志_amwha 的专栏 - 程序员宅基地_qdebug 打印不出来 - 程序员宅基地 Qt Creator 中的.pro 文件的详解_hebbely 的博客-CSDN 博客_qt 的 pro 文件\n","permalink":"https://lifeislife.cn/posts/qt%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E5%B1%8F%E8%94%BDqdebug%E8%BE%93%E5%87%BA/","summary":"\u003ch2 id=\"可执行程序放到指定目录\"\u003e可执行程序放到指定目录\u003c/h2\u003e\n\u003cp\u003e默认情况下 QtCreator 会将编译链接后的可执行程序与中间生成的文件防盗\u003ccode\u003ebuild-***-\u003c/code\u003e文件中，如何能将可执行文件生成在指定目录？\u003c/p\u003e\n\u003cp\u003e修改\u003ccode\u003e.pro\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eCONFIG(debug ,debug|release){\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    DESTDIR = ../debug\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e}else{\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    DESTDIR = ../release\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003edebug\u003c/code\u003e版本放在\u003ccode\u003e../debug\u003c/code\u003e目录中，\u003ccode\u003erelease\u003c/code\u003e版本放在\u003ccode\u003e../release\u003c/code\u003e目录中。\u003c/p\u003e","title":"Qt 编译后的程序放到指定目录，屏蔽 qDebug 输出"},{"content":"QOM 简介 QOM(QEMU Object Model) 是 QEMU 的一个模块，用于描述虚拟机的结构，包括虚拟机的 CPU、内存、硬盘、网络、输入输出设备等。QEMU 为了方便整个系统的构建，实现了自己的一套的面向对象机制，也就是 QOM(QEMU Object Model)。它能够方便的表示各个设备（Device）与总线（Bus）之间的关系。\n这个模型主要包含四个结构体：\nObject: 是所有对象的 基类 Base Object ObjectClass: 是所有类对象的基类 TypeInfo：是用户用来定义一个 Type 的工具型的数据结构 TypeImpl：TypeInfo 抽象数据结构，TypeInfo 的属性与 TypeImpl 的属性对应 在 QEMU 里要初始化一个对象需要完成四步：\n将 TypeInfo 注册 TypeImpl 实例化 Class（ObjectClass） 实例化 Object 添加 Property \u003c!DOCTYPE html\u003e Responsive Image QOM 中的面向对象 继承 在 QEMU 中通过 TypeInfo 来定义一个类。\n例如 x86_base_cpu_type_info 就是一个 class，\nstatic const TypeInfo x86_base_cpu_type_info = { .name = X86_CPU_TYPE_NAME(\u0026#34;base\u0026#34;), .parent = TYPE_X86_CPU, .class_init = x86_cpu_base_class_init, }; 利用结构体包含来实现继承。这应该是所有的语言实现继承的方法，在 C++ 中，结构体包含的操作被语言内部实现了，而 C 语言需要自己实现。\n例如 x86_cpu_type_info 的 parent 是 cpu_type_info, 他们的结构体分别是 X86CPU 和 CPUState。\nstatic const TypeInfo x86_cpu_type_info = { .name = TYPE_X86_CPU, .parent = TYPE_CPU, // ... .instance_size = sizeof(X86CPU), }; static const TypeInfo cpu_type_info = { .name = TYPE_CPU, .parent = TYPE_DEVICE, // ... .instance_size = sizeof(CPUState), }; 在 X86CPU 中包含一个 CPUState。\nstruct X86CPU { /*\u0026lt; private \u0026gt;*/ CPUState parent_obj; /*\u0026lt; public \u0026gt;*/ CPUNegativeOffsetState neg; 静态成员 静态成员变量可以在类的多个对象中访问，但是要在类外声明。不同对象访问的其实是同一个实体，静态成员变量被多个对象共享。\nstatic const TypeInfo x86_cpu_type_info = { .name = TYPE_X86_CPU, .parent = TYPE_CPU, .instance_size = sizeof(X86CPU), .instance_init = x86_cpu_initfn, .instance_post_init = x86_cpu_post_initfn, .abstract = true, .class_size = sizeof(X86CPUClass), .class_init = x86_cpu_common_class_init, }; 其中 X86CPU 描述的是非静态成员，而 X86CPUClass 描述的是静态的成员。也就是说class_init初始化静态成员，instance_init初始化非静态成员。\n那么何时初始化静态成员呢？首先得告诉系统，咱有class_init这个初始化函数，等需要的时候随时可以调用它初始化，所有先解决如何将这个初始化函数注册到系统中？\n在target/i386/cpu.c最后使用了type_init。在qemu/include/qemu/module.h中有一个type_init宏定义，除了type_init还有其他宏，比如block_init，opts_init等。每个宏都表示一类module，通过module_init构造出来。我们展开这个宏，\nstatic void __attribute__((constructor)) do_qemu_init_x86_cpu_register_types(void) { register_module_init(x86_cpu_register_types, MODULE_INIT_QOM); } 通过 gcc 扩展属性__attribute__((constructor))可以让 do_qemu_init_x86_cpu_register_types 在运行 main 函数之前运行。 register_module_init 会让 x86_cpu_register_types 这个函数挂载到 init_type_list[MODULE_INIT_QOM] 这个链表上。\n\u003c!DOCTYPE html\u003e Responsive Image 到底，所有的 TypeInfo 通过 type_init 都被放到 type_table 上了，之后通过 Typeinfo 的名称调用 type_table_lookup 获取到 TypeImpl 了。\n到这里，将TYPE_X86_CPU注册进类系统，包括其初始化函数，这部分也就是 QEMU 中类型的构造。那么何时调用静态成员初始化函数呢？也就是类型的初始化。\n静态成员是所有的对象公用的，其初始化显然要发生在所有的对象初始化之前。\nmain qemu_init select_machine object_class_get_list object_class_foreach g_hash_table_foreach object_class_foreach_tramp type_initialize type_initialize x86_cpu_common_class_init select_machine 需要获取所有的 TYPE_MACHINE 的 class, 其首先会调用所有的class_list，其会遍历 type_table，遍历的过程中会顺带 type_initialize 所有的 TypeImpl 进而调用的 class_init。\n说完类型的初始化，再讲一下对象的初始化，也就是初始化非静态成员，也就是instance_init在何时被调用？\n对象初始化，通过调用 object_new 来实现初始化。\nobject_initialize_with_type 初始化一个空的 :Object::properties object_init_with_type 如果 object 有 parent，那么调用 object_init_with_type 首先初始化 parent 的 调用TypeImpl::instance_init main qemu_init qmp_x_exit_preconfig qemu_init_board machine_run_board_init pc_init_v6_1 pc_init1 x86_cpus_init x86_cpu_new object_new object_new_with_type object_initialize_with_type object_init_with_type x86_cpu_initfn 多态 多态是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。为了实现多态，QOM 实现了一个非常重要的功能，就是动态类型转换。我们可以使用相关的函数，将一个Object的指针在运行时转换为子类对象的指针，可以将一个ObjectClass的指针在运行时转换为子类的指针。这样就可以调用子类中定义的函数指针来完成相应的功能。\nQEMU 定义了一些列的宏封来进行动态类型转换：\n//include/qom/object.h /** * DECLARE_INSTANCE_CHECKER: * @InstanceType: instance struct name * @OBJ_NAME: the object name in uppercase with underscore separators * @TYPENAME: type name * * Direct usage of this macro should be avoided, and the complete * OBJECT_DECLARE_TYPE macro is recommended instead. * * This macro will provide the instance type cast functions for a * QOM type. */ #define DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \\ static inline G_GNUC_UNUSED InstanceType * \\ OBJ_NAME(const void *obj) \\ { return OBJECT_CHECK(InstanceType, obj, TYPENAME); } /** * DECLARE_CLASS_CHECKERS: * @ClassType: class struct name * @OBJ_NAME: the object name in uppercase with underscore separators * @TYPENAME: type name * * Direct usage of this macro should be avoided, and the complete * OBJECT_DECLARE_TYPE macro is recommended instead. * * This macro will provide the class type cast functions for a * QOM type. */ #define DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME) \\ static inline G_GNUC_UNUSED ClassType * \\ OBJ_NAME##_GET_CLASS(const void *obj) \\ { return OBJECT_GET_CLASS(ClassType, obj, TYPENAME); } \\ \\ static inline G_GNUC_UNUSED ClassType * \\ OBJ_NAME##_CLASS(const void *klass) \\ { return OBJECT_CLASS_CHECK(ClassType, klass, TYPENAME); } /** * DECLARE_OBJ_CHECKERS: * @InstanceType: instance struct name * @ClassType: class struct name * @OBJ_NAME: the object name in uppercase with underscore separators * @TYPENAME: type name * * Direct usage of this macro should be avoided, and the complete * OBJECT_DECLARE_TYPE macro is recommended instead. * * This macro will provide the three standard type cast functions for a * QOM type. */ #define DECLARE_OBJ_CHECKERS(InstanceType, ClassType, OBJ_NAME, TYPENAME) \\ DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \\ \\ DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME) /** * OBJECT_DECLARE_TYPE: * @InstanceType: instance struct name * @ClassType: class struct name * @MODULE_OBJ_NAME: the object name in uppercase with underscore separators * * This macro is typically used in a header file, and will: * * - create the typedefs for the object and class structs * - register the type for use with g_autoptr * - provide three standard type cast functions * * The object struct and class struct need to be declared manually. */ #define OBJECT_DECLARE_TYPE(InstanceType, ClassType, MODULE_OBJ_NAME) \\ typedef struct InstanceType InstanceType; \\ typedef struct ClassType ClassType; \\ \\ G_DEFINE_AUTOPTR_CLEANUP_FUNC(InstanceType, object_unref) \\ \\ DECLARE_OBJ_CHECKERS(InstanceType, ClassType, \\ MODULE_OBJ_NAME, TYPE_##MODULE_OBJ_NAME) /** * OBJECT: * @obj: A derivative of #Object * * Converts an object to a #Object. Since all objects are #Objects, * this function will always succeed. */ #define OBJECT(obj) \\ ((Object *)(obj)) /** * OBJECT_CLASS: * @class: A derivative of #ObjectClass. * * Converts a class to an #ObjectClass. Since all objects are #Objects, * this function will always succeed. */ #define OBJECT_CLASS(class) \\ ((ObjectClass *)(class)) /** * OBJECT_CHECK: * @type: The C type to use for the return value. * @obj: A derivative of @type to cast. * @name: The QOM typename of @type * * A type safe version of @object_dynamic_cast_assert. Typically each class * will define a macro based on this type to perform type safe dynamic_casts to * this object type. * * If an invalid object is passed to this function, a run time assert will be * generated. */ #define OBJECT_CHECK(type, obj, name) \\ ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \\ __FILE__, __LINE__, __func__)) /** * OBJECT_CLASS_CHECK: * @class_type: The C type to use for the return value. * @class: A derivative class of @class_type to cast. * @name: the QOM typename of @class_type. * * A type safe version of @object_class_dynamic_cast_assert. This macro is * typically wrapped by each type to perform type safe casts of a class to a * specific class type. */ #define OBJECT_CLASS_CHECK(class_type, class, name) \\ ((class_type *)object_class_dynamic_cast_assert(OBJECT_CLASS(class), (name), \\ __FILE__, __LINE__, __func__)) /** * OBJECT_GET_CLASS: * @class: The C type to use for the return value. * @obj: The object to obtain the class for. * @name: The QOM typename of @obj. * * This function will return a specific class for a given object. Its generally * used by each type to provide a type safe macro to get a specific class type * from an object. */ #define OBJECT_GET_CLASS(class, obj, name) \\ OBJECT_CLASS_CHECK(class, object_get_class(OBJECT(obj)), name) 以OBJECT_DECLARE_TYPE(X86CPU, X86CPUClass, X86_CPU)为例，宏展开如下：\ntypedef struct X86CPU X86CPU; typedef struct X86CPUClass X86CPUClass; G_DEFINE_AUTOPTR_CLEANUP_FUNC(X86CPU, object_unref) static inline G_GNUC_UNUSED X86CPU *X86_CPU(const void *obj) { return ((X86CPU *)object_dynamic_cast_assert( ((Object *)(obj)), (TYPE_X86_CPU), \u0026#34;~/core/vn/docs/qemu/res/qom-macros.c\u0026#34;, 64, __func__)); } static inline G_GNUC_UNUSED X86CPUClass *X86_CPU_GET_CLASS(const void *obj) { return ((X86CPUClass *)object_class_dynamic_cast_assert( ((ObjectClass *)(object_get_class(((Object *)(obj))))), (TYPE_X86_CPU), \u0026#34;~/core/vn/docs/qemu/res/qom-macros.c\u0026#34;, 64, __func__)); } static inline G_GNUC_UNUSED X86CPUClass *X86_CPU_CLASS(const void *klass) { return ((X86CPUClass *)object_class_dynamic_cast_assert( ((ObjectClass *)(klass)), (TYPE_X86_CPU), \u0026#34;~/core/vn/docs/qemu/res/qom-macros.c\u0026#34;, 64, __func__)); } OBJECT_DECLARE_TYPE通常在头文件中使用，效果是：\n创建了X86CPU和X86CPUClass的typedef 用G_DEFINE_AUTOPTR_CLEANUP_FUNC注册类型 创建了三个类型转换函数 X86_CPU : 将任何一个 object 指针 转换为 X86CPU（Object 转子对象） X86_CPU_GET_CLASS : 根据 object 指针获取到 X86CPUClass X86_CPU_CLASS : 根据 ObjectClass 指针转换到 X86CPUClass（基类转子类） 这里的转换依赖内存布局，子类型的第一个成员总是基类型。子类转基类就很容易，只需要强制类型转换就可以实现。\n参考 QEMU 中的面向对象 : QOM | Deep Dark Fantasy 浅谈 QEMU 的对象系统 - 简书\n","permalink":"https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-qom/","summary":"\u003ch2 id=\"qom-简介\"\u003eQOM 简介\u003c/h2\u003e\n\u003cp\u003eQOM(QEMU Object Model) 是 QEMU 的一个模块，用于描述虚拟机的结构，包括虚拟机的 CPU、内存、硬盘、网络、输入输出设备等。QEMU 为了方便整个系统的构建，实现了自己的一套的面向对象机制，也就是 QOM(QEMU Object Model)。它能够方便的表示各个设备（Device）与总线（Bus）之间的关系。\u003c/p\u003e","title":"QEMU 源码分析-QOM"},{"content":"基础概念 RGB 和 YUV 都属于一种颜色编码方式，或者说颜色空间。\nRGB 色彩模式是工业界的一种颜色标准，是通过对红、绿、蓝三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB 即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。\n在 YUV 空间中，Y 代表亮度，其实 Y 就是图像的灰度值；UV 代表色差，U 和 V 是构成彩色的两个分量。在现代彩色电视系统中，通常采用三管彩色摄影机或彩色 CCD 摄影机进行取像，然后把取得的彩色图像信号经分色、分别放大校正后得到 RGB，再经过矩阵变换电路得到亮度信号 Y 和两个色差信号 B\u0026ndash;Y(即 U)、R\u0026ndash;Y(即 V)，最后发送端将亮度和色差三个信号分别进行编码，用同一信道发送出去。这种色彩的表示方法就是所谓的 YUV 色彩空间表示。\n解析 RGB 格式 RGB16 RGB16 数据格式主要有二种：RGB565 和 RGB555。\nRGB565，每个像素用 16 比特位表示，占 2 个字节，RGB 分量分别使用 5 位、6 位、5 位。\n//获取高字节的5个bit R = color \u0026amp; 0xF800; //获取中间6个bit G = color \u0026amp; 0x07E0; //获取低字节5个bit B = color \u0026amp; 0x001F; RGB555，每个像素用 16 比特位表示，占 2 个字节，RGB 分量都使用 5 位 (最高位不用)。\n//获取高字节的5个bit R = color \u0026amp; 0x7C00; //获取中间5个bit G = color \u0026amp; 0x03E0; //获取低字节5个bit B = color \u0026amp; 0x001F; RGB24 RGB24 图像每个像素用 24 比特位表示，占 3 个字节，注意：在内存中 RGB 各分量的排列顺序为：BGR BGR BGR。\nRGB32 RGB32 图像每个像素用 32 比特位表示，占 4 个字节，R，G，B 分量分别用 8 个 bit 表示，存储顺序为 B，G，R，最后 8 个字节保留。注意：在内存中 RGB 各分量的排列顺序为：BGRA BGRA BGRA \u0026hellip;\u0026hellip;。\n本质就是带 alpha 通道的 RGB24，与 RGB32 的区别在与，保留的 8 个 bit 用来表示透明，也就是 alpha 的值。\nR = color \u0026amp; 0x0000FF00; G = color \u0026amp; 0x00FF0000; B = color \u0026amp; 0xFF000000; A = color \u0026amp; 0x000000FF; YUV 采样 \u003c!DOCTYPE html\u003e Responsive Image YUV444：一个像素就有 YUV 三个值，和 RGB 类似；一个 YUV 占 8+8+8 = 24bits 3 个字节。 YUV422：第一个像素有 YUV 三个值，第二个像素只有 Y，与前一个像素共用 UV；一个 YUV 占 8+4+4 = 16bits 2 个字节。 YUV420：上下四个像素共用一个 UV。一个 YUV 占 8+2+2 = 12bits 1.5 个字节。 转换 YUV2RGB $$ R = Y + 1.403 \\times (V-128)\\ G=Y-0.343 \\times (U-128) - 0.714 \\times (V-128)\\ B=Y + 1.770 \\times (U-128) $$\nRGB2YUV $$ Y = 0.299 \\times R + 0.587 \\times G + 0.114 \\times B\\ U = -0.169 \\times R - 0.331 \\times G + 0.500 \\times B + 128\\ V = 0.500 \\times R - 0.419 \\times G - 0.081 \\times B + 128\\ $$\n浮点型运算比较耗时，将所有运算换成位运算，提高效率。具体推倒过程见色彩转换系列之 RGB 格式与 YUV 格式互转原理及实现_小武的博客-CSDN 博客_rgb yuv\nY= ((R \u0026lt;\u0026lt; 6) + (R \u0026lt;\u0026lt; 3) + (R \u0026lt;\u0026lt; 2) + R + (G \u0026lt;\u0026lt; 7) + (G \u0026lt;\u0026lt; 4) + (G \u0026lt;\u0026lt; 2) + (G \u0026lt;\u0026lt; 1) + (B \u0026lt;\u0026lt; 4) + (B \u0026lt;\u0026lt; 3) + (B \u0026lt;\u0026lt; 2) + B) \u0026gt;\u0026gt; 8 U= (-((R \u0026lt;\u0026lt; 5) + (R \u0026lt;\u0026lt; 3) + (R \u0026lt;\u0026lt; 1)+ R) - ((G \u0026lt;\u0026lt; 6) + (G \u0026lt;\u0026lt; 4) + (G \u0026lt;\u0026lt; 2)+G) + (B \u0026lt;\u0026lt; 7) + 32768) \u0026gt;\u0026gt; 8 V= ((R \u0026lt;\u0026lt; 7) - ((G \u0026lt;\u0026lt; 6) + (G \u0026lt;\u0026lt; 5) + (G \u0026lt;\u0026lt; 3) + (G \u0026lt;\u0026lt; 3) + G) - ((B \u0026lt;\u0026lt; 4) + (B \u0026lt;\u0026lt; 2) + B) + 32768 )\u0026gt;\u0026gt; 8 参考 RGB 和 YUV - 简书 颜色空间 YUV 简介_网络资源是无限的-CSDN 博客_yuv 颜色空间 图解 RGB565、RGB555、RGB16、RGB24、RGB32、ARGB32 等格式的区别_handy 周-CSDN 博客_rgb565 图解 YU12、I420、YV12、NV12、NV21、YUV420P、YUV420SP、YUV422P、YUV444P 的区别_handy 周-CSDN 博客_yv12\n","permalink":"https://lifeislife.cn/posts/rgb%E4%B8%8Eyuv%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/","summary":"\u003ch2 id=\"基础概念\"\u003e基础概念\u003c/h2\u003e\n\u003cp\u003eRGB 和 YUV 都属于一种颜色编码方式，或者说颜色空间。\u003c/p\u003e\n\u003cp\u003eRGB 色彩模式是工业界的一种颜色标准，是通过对红、绿、蓝三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB 即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。\u003c/p\u003e","title":"RGB 与 YUV 颜色空间"},{"content":"计算机指令 上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0 表示不打孔，1 表示打孔），送入特殊的计算机中执行。\n从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。\n从软件的角度来看，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。\n不同的 CPU 能够听懂的语言不太一样。也就是 CPU 支持的语言不一样，这里的语言叫指令集（Instruction Set）。\n一个计算机程序由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作存储程序型计算机（Stored-program Computer）。\n了解了计算机指令和计算机指令集，接下来我们来看看，平时编写的代码，到底是怎么变成一条条计算机指令，最后被 CPU 执行的呢？我们拿一小段真实的 C 语言程序来看看。\n// test.c int main() { int a = 1; int b = 2; a = a + b; } 通过编译器，可以将上述代码编译成汇编代码，再通过汇编器，将汇编代码编译成机器码，最后通过 CPU 执行。\n在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。\n$ gcc -g -c test.c $ objdump -d -M intel -S test.o test.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;main\u0026gt;: int main() { 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp int a = 1; 4: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x4],0x1 int b = 2; b: c7 45 f8 02 00 00 00 mov DWORD PTR [rbp-0x8],0x2 a = a + b; 12: 8b 45 f8 mov eax,DWORD PTR [rbp-0x8] 15: 01 45 fc add DWORD PTR [rbp-0x4],eax } 18: 5d pop rbp 19: c3 ret 左侧有一堆数字，这些就是一条条机器码；右边有一系列的push、mov、add、pop 等，这些就是对应的汇编代码。\n了解了这个过程，下面我们放大局部，来看看这一行行的汇编代码和机器指令，到底是什么意思。\n常见的指令可以分成五大类。\n第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。\n第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。\n第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。\n第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。\n最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。\n指令跳转 CPU 如何执行指令的 代码经过软件层面的编译后就是一条条二进制指令，指令交由 CPU 中几百亿个晶体管去执行。我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。而寄存器就是 CPU 内部，由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。\nN 个触发器或者锁存器，就可以组成一个N位（Bit）的寄存器，能够保存 N位的数据。比方说，我们用的64位 Intel服务器，寄存器就是64 位的。\n一个 CPU 里面会有很多种不同功能的寄存器。这里介绍三种比较特殊的。\nPC 寄存器（Program Counter Register），我们也叫指令地址寄存器（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。\n指令寄存器（Instruction Register），用来存放当前正在执行的指令。\n条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。\n除此之外还有整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。\n实际上，一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。\n而有些特殊指令，比如上一讲我们讲到 J 类指令，也就是跳转指令，会修改 PC 寄存器里面的地址值。\n从 if…else 来看程序的执行和跳转 首先看如下的例程，\n// test.c #include \u0026lt;time.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { srand(time(NULL)); int r = rand() % 2; int a = 10; if (r == 0) { a = 1; } else { a = 2; } gcc -g -c test.c objdump -d -M intel -S test.o 编译后打印出汇编代码如下：\nif (r == 0) 3b: 83 7d fc 00 cmp DWORD PTR [rbp-0x4],0x0 3f: 75 09 jne 4a \u0026lt;main+0x4a\u0026gt; { a = 1; 41: c7 45 f8 01 00 00 00 mov DWORD PTR [rbp-0x8],0x1 48: eb 07 jmp 51 \u0026lt;main+0x51\u0026gt; } else { a = 2; 4a: c7 45 f8 02 00 00 00 mov DWORD PTR [rbp-0x8],0x2 51: b8 00 00 00 00 mov eax,0x0 } 可以看到，这里对于 r == 0的条件判断，被编译成了 cmp 和 jne 这两条指令。\ncmp 指令比较了前后两个操作数的值，这里的DWORD PTR 代表操作的数据类型是 32位的整数，而 [rbp-0x4] 则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量 r 的值。第二个操作数 0x0 就是我们设定的常量0的 16 进制表示。cmp 指令的比较结果，会存入到条件码寄存器当中去。\n在这里，如果比较的结果是 True，也就是 r == 0，就把零标志条件码（对应的条件码是 ZF，Zero Flag）设置为 1。除了零标志之外，Intel 的 CPU 下还有进位标志（CF，Carry Flag）、符号标志（SF，Sign Flag）以及溢出标志（OF，Overflow Flag），用在不同的判断条件下。\ncmp 指令执行完成之后，PC 寄存器会自动自增，开始执行下一条 jne 的指令。\n跟着的 jne 指令，是 jump if not equal 的意思，它会查看对应的零标志位。如果为0，会跳转到后面跟着的操作数 4a 的位置。这个 4a，对应这里汇编代码的行号，也就是上面设置的 else 条件里的第一条指令。当跳转发生的时候，PC 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 4a 这个地址。这个时候，CPU 再把 4a 地址里的指令加载到指令寄存器中来执行。\n跳转到执行地址为 4a 的指令，实际是一条 mov 指令，第一个操作数和前面的 cmp 指令一样，是另一个 32 位整型的寄存器地址，以及对应的 2 的16 进制值 0x2。mov 指令把 2 设置到对应的寄存器里去，相当于一个赋值操作。然后，PC寄存器里的值继续自增，执行下一条 mov 指令。\n这条 mov 指令的第一个操作数eax，代表累加寄存器，第二个操作数0x0则是 16 进制的0的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的 if 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 jmp 的无条件跳转指令。跳转的地址就是这一行的地址51。我们的 main 函数没有设定返回值，而mov eax, 0x0 其实就是给 main 函数生成了一个默认的为 0 的返回值到累加器里面。if 条件里面的内容执行完成之后也会跳转到这里，和 else 里的内容结束之后的位置是一样的。\n函数调用：为什么会发生 Stack Overflow 静态链接 既然我们的程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在 Linux 下可以运行，而在 Windows 下却不行呢？反过来，Windows 上的程序在 Linux 上也是一样不能执行的。可是我们的 CPU 并没有换掉，它应该可以识别同样的指令呀？\n将以下两个例程编译，然后通过 objdump 命令看看它们的汇编代码。\n// add_lib.c int add(int a, int b) { return a+b; } // link_example.c #include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; int b = 5; int c = add(a, b); printf(\u0026#34;c = %d\\n\u0026#34;, c); } gcc -g -c add_lib.c link_example.c objdump -d -M intel -S add_lib.o objdump -d -M intel -S link_example.o add_lib.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;add\u0026gt;: 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 89 7d fc mov DWORD PTR [rbp-0x4],edi 7: 89 75 f8 mov DWORD PTR [rbp-0x8],esi a: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] d: 8b 45 f8 mov eax,DWORD PTR [rbp-0x8] 10: 01 d0 add eax,edx 12: 5d pop rbp 13: c3 ret link_example.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;main\u0026gt;: 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 48 83 ec 10 sub rsp,0x10 8: c7 45 fc 0a 00 00 00 mov DWORD PTR [rbp-0x4],0xa f: c7 45 f8 05 00 00 00 mov DWORD PTR [rbp-0x8],0x5 16: 8b 55 f8 mov edx,DWORD PTR [rbp-0x8] 19: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 1c: 89 d6 mov esi,edx 1e: 89 c7 mov edi,eax 20: b8 00 00 00 00 mov eax,0x0 25: e8 00 00 00 00 call 2a \u0026lt;main+0x2a\u0026gt; 2a: 89 45 f4 mov DWORD PTR [rbp-0xc],eax 2d: 8b 45 f4 mov eax,DWORD PTR [rbp-0xc] 30: 89 c6 mov esi,eax 32: 48 8d 3d 00 00 00 00 lea rdi,[rip+0x0] # 39 \u0026lt;main+0x39\u0026gt; 39: b8 00 00 00 00 mov eax,0x0 3e: e8 00 00 00 00 call 43 \u0026lt;main+0x43\u0026gt; 43: b8 00 00 00 00 mov eax,0x0 48: c9 leave 49: c3 ret 既然代码已经被我们“编译”成了指令，我们不妨尝试运行一下 ./link_example.o。\n然而我们并不能成功运行，会得到一条cannot execute binary file: Exec format error 的错误。\n我们再仔细看一下 objdump 出来的两个文件的代码，会发现两个程序的地址都是从 0 开始的。如果地址是一样的，程序如果需要通过 call 指令调用函数的话，它怎么知道应该跳转到哪一个文件里呢？\n无论是这里的运行报错，还是 objdump 出来的汇编代码里面的重复地址，都是因为add_lib.o以及 link_example.o 并不是一个可执行文件（Executable Program），而是目标文件（Object File）。只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。\n通过 gcc 的-o参数，可以生成对应的可执行文件。\n$ gcc -o link-example add_lib.o link_example.o $ ./link_example c = 15 ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。\n\u003c!DOCTYPE html\u003e Responsive Image 链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。\n\u003c!DOCTYPE html\u003e Responsive Image 在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。\n为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。其中一个非常重要的原因就是，两个操作系统下可执行文件的格式不一样。\n我们今天讲的是 Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作 PE（Portable Executable Format）的文件格式。Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。\n如果我们有一个可以能够解析 PE 格式的装载器，我们就有可能在 Linux 下运行 Windows 程序了。这样的程序真的存在吗？没错，Linux 下著名的开源项目 Wine，就是通过兼容 PE 格式的装载器，使得我们能直接在 Linux 下运行 Windows 程序的。而现在微软的 Windows 里面也提供了 WSL，也就是 Windows Subsystem for Linux，可以解析和加载 ELF 格式的文件。\n程序装载 程序装载面临的挑战 可执行程序加载后占用的内存空间应该是连续的。 这点很好理解，指令正常都是顺序执行的。 我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。 计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用了。 我们把指令里用到的内存地址叫作虚拟内存地址（Virtual Memory Address），实际在内存硬件里面的空间地址，我们叫物理内存地址（Physical Memory Address）。\n程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了。对于任何一个程序来说，它看到的都是同样的内存地址。我们维护一个虚拟内存到物理内存的映射表，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。\n内存分段 这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫分段（Segmentation）。这里的段，就是指系统分配出来的那个连续的内存空间。\n分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处，第一个就是内存碎片（Memory Fragmentation）的问题。\n\u003c!DOCTYPE html\u003e Responsive Image 我们可以通过内存交换（Memory Swapping）技术解决。\n我们可以把 Python 程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里面。不过读回来的时候，我们不再把它加载到原来的位置，而是紧紧跟在那已经被占用了的 512MB 内存后面。这样，我们就有了连续的 256MB 内存空间，就可以去加载一个新的 200MB 的程序。\n如果你自己安装过 Linux 操作系统，你应该遇到过分配一个 swap 硬盘分区的问题。这块分出来的磁盘空间，其实就是专门给 Linux 操作系统进行内存交换用的。\n硬盘的访问速度要比内存慢很多，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。\n内存分页 既然问题出在内存碎片和内存交换的空间太大上，那么解决问题的办法就是，少出现一些内存碎片，并且让需要交换写入或者从磁盘装载的数据更少一点。于是就有了内存分页（Paging）。\n和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小。而对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。\n从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。页的尺寸一般远远小于整个程序的大小。在 Linux 下，我们通常只设置成 4KB。\n由于内存空间都是预先划分好的，也就没有了不能使用的碎片，而只有被释放出来的很多 4KB 的页。即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，让整个机器被内存交换的过程给卡住。\n分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。\n实际上，我们的操作系统，的确是这么做的。当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的缺页错误（Page Fault）。我们的操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。\n动态链接 如果我们有很多个程序都要通过装载器装载到内存里面，那里面链接好的同样的功能代码，也都需要再装载一遍，再占一遍内存空间。在一个运行上百个进程的系统中，这将会造成极大的资源浪费。\n共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接（dynamic linking）是由一个叫做动态链接器（dynamic linker）的程序来执行的。Linux 中为.so文件，Windows 中为.dll文件。\n\u003c!DOCTYPE html\u003e Responsive Image PIC （Position-Independent Code） 要想要在程序运行的时候共享代码，也有一定的要求，就是这些机器码必须是“地址无关”的。也就是说，我们编译出来的共享库文件的指令代码，放在哪个内存地址都能正常运行。\n\u003c!DOCTYPE html\u003e Responsive Image 对于所有动态链接共享库的程序来讲，虽然我们的共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的。我们没办法、也不应该要求动态链接同一个共享库的不同程序，必须把这个共享库所使用的虚拟内存地址变成一致。如果这样的话，我们写的程序就必须明确地知道内部的内存地址分配。\n如何才能实现地址无关？\n动态代码库内部的变量和函数调用都很容易解决，我们只需要使用相对地址（Relative Address）就好了。各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。因为整个共享库是放在一段连续的虚拟内存地址中的，无论装载到哪一段地址，不同指令之间的相对地址都是不变的。\nPLT 和 GOT // lib.h #ifndef LIB_H #define LIB_H void show_me_the_money(int money); #endif // lib.c #include \u0026lt;stdio.h\u0026gt; void show_me_the_money(int money) { printf(\u0026#34;Show me USD %d from lib.c \\n\u0026#34;, money); } // show_me_poor.c #include \u0026#34;lib.h\u0026#34; int main() { int money = 5; show_me_the_money(money); } gcc lib.c -fPIC -shared -o lib.so gcc -o show_me_poor show_me_poor.c ./lib.so -fpic 选项指示编译器生成与位置无关的代码。-shared选项指示链接器创建一个共享的目标文件。\n然后，我们再通过 gcc 编译 show_me_poor 动态链接了 lib.so 的可执行文件。在这些操作都完成了之后，我们把 show_me_poor 这个文件通过 objdump 出来看一下。\n$ objdump -d -M intel -S show_me_poor …… 0000000000400540 \u0026lt;show_me_the_money@plt-0x10\u0026gt;: 400540: ff 35 12 05 20 00 push QWORD PTR [rip+0x200512] # 600a58 \u0026lt;_GLOBAL_OFFSET_TABLE_+0x8\u0026gt; 400546: ff 25 14 05 20 00 jmp QWORD PTR [rip+0x200514] # 600a60 \u0026lt;_GLOBAL_OFFSET_TABLE_+0x10\u0026gt; 40054c: 0f 1f 40 00 nop DWORD PTR [rax+0x0] 0000000000400550 \u0026lt;show_me_the_money@plt\u0026gt;: 400550: ff 25 12 05 20 00 jmp QWORD PTR [rip+0x200512] # 600a68 \u0026lt;_GLOBAL_OFFSET_TABLE_+0x18\u0026gt; 400556: 68 00 00 00 00 push 0x0 40055b: e9 e0 ff ff ff jmp 400540 \u0026lt;_init+0x28\u0026gt; …… 0000000000400676 \u0026lt;main\u0026gt;: 400676: 55 push rbp 400677: 48 89 e5 mov rbp,rsp 40067a: 48 83 ec 10 sub rsp,0x10 40067e: c7 45 fc 05 00 00 00 mov DWORD PTR [rbp-0x4],0x5 400685: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 400688: 89 c7 mov edi,eax 40068a: e8 c1 fe ff ff call 400550 \u0026lt;show_me_the_money@plt\u0026gt; 40068f: c9 leave 400690: c3 ret 400691: 66 2e 0f 1f 84 00 00 nop WORD PTR cs:[rax+rax*1+0x0] 400698: 00 00 00 40069b: 0f 1f 44 00 00 nop DWORD PTR [rax+rax*1+0x0] …… 在 main 函数调用 show_me_the_money 的函数的时候，对应的代码是这样的：\ncall 400550 \u0026lt;show_me_the_money@plt\u0026gt; 这里后面有一个@plt 的关键字，代表了我们需要从PLT，也就是过程链接表（Procedure Link Table）里面找要调用的函数。对应的地址呢，则是 400550 这个地址。\n那当我们把目光挪到上面的 400550 这个地址，你又会看到里面进行了一次跳转，这个跳转指定的跳转地址，你可以在后面的注释里面可以看到，GLOBAL_OFFSET_TABLE+0x18。这里的 GLOBAL_OFFSET_TABLE，就是我接下来要说的全局偏移表。\n400550: ff 25 12 05 20 00 jmp QWORD PTR [rip+0x200512] # 600a68 \u0026lt;_GLOBAL_OFFSET_TABLE_+0x18\u0026gt; 在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张全局偏移表（GOT，Global Offset Table）。虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。\n虽然不同的程序调用的同样的动态库，各自的内存地址是独立的，调用的又都是同一个动态库，但是不需要去修改动态库里面的代码所使用的地址，而是各个程序各自维护好自己的 GOT，能够找到对应的动态库就好了。\n二进制编码 原码表示法，左侧第一位是符号位，符号位为 1 时表示负数，为 0 时表示正数。 补码表示法，我们不再把这一位当成单独的符号位，在剩下几位计算出的十进制前加上正负号，而是在计算整个二进制值的时候，在左侧最高位前面加个负号。\n比如，一个 4 位的二进制补码数值 1011，转换成十进制，就是 $-1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = -5$\n一个 4 位的二进制数，可以表示从 -8 到 7 这 16 个整数，不会白白浪费一位。\n字符集：表示的可以是字符的一个集合。比如说“第一版《新华字典》里面出现的所有汉字”，这是一个中文字符集。比如，我们日常说的Unicode，其实就是一个字符集，包含了 150 种语言的 14 万个不同的字符。\n字符编码：对于字符集里的这些字符，怎么一一用二进制表示出来的一个字典。我们上面说的 Unicode，就可以用UTF-8、UTF-16，乃至 UTF-32 来进行编码，存储成二进制。\n同样的文本，采用不同的编码存储下来。如果另外一个程序，用一种不同的编码方式来进行解码和展示，就会出现乱码。\n锟斤拷 烫烫烫 Unicode 编码一直持续在收录各种字元，这就可能会出现各种作业系统支援的 Unicode 字元不一样。这也就会导致 A 上的一个用 Unicode 编码的字元，在 B 上就会出现无法显示的情况。为了避免这种情况，在 Unicode 中定义了一个特殊字元�，它的 Unicode 编码为 0xFFFD。\n假如 A 支援特殊字元⬆，但是 B 并不支援这个⬆，那么在 B 中将会用�来代替。\n这个字元用 UTF-8 编码后，十六进位表示为0xEF 0XBF 0XBD。如果连续出现两个⬆符号，那么用 UTF-8 编码后的十六进位则表示为0xEF 0XBF 0XBD 0xEF 0XBF 0XBD，这时候再转码成 GBK，因为 GBK 中用两个位元组表示一个字元，那么上述的字元就成了锟（0xEFBF），斤（0xBDEF），拷（0xBFBD）。出现锟斤拷的原因就是 UTF-8 转码 GBK 的过程中出现了问题。当然如果想要出现锟斤拷，则至少需要两个字元出现乱码。\n而“烫烫烫”，则是因为如果你用了 Visual Studio 的调试器，默认使用 MBCS 字符集。“烫”在里面是由 0xCCCC 来表示的，而 0xCC 又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。\n理解电路 从以上的学习可以知道，最终执行的程序都是二进制的指令。那为何计算机最终选择了二进制呢？接下来看看计算机在硬件层面究竟是怎么表示二进制的，以此你就会明白，为什么计算机会选择二进制。\n加法器 乘法器 浮点数和定点数 ","permalink":"https://lifeislife.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/","summary":"\u003ch2 id=\"计算机指令\"\u003e计算机指令\u003c/h2\u003e\n\u003cp\u003e上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0 表示不打孔，1 表示打孔），送入特殊的计算机中执行。\u003c/p\u003e","title":"计算机组成原理-指令和运算"},{"content":"解决方法 方法一：\ngit config --global http.sslVerify \u0026#34;false\u0026#34; 方法二：\ngit config --global https.sslVerify \u0026#34;false\u0026#34; 方法三： 这可能是因为版本库的大小和 git 的默认缓冲区大小，所以通过下述操作（在 git bash 上），git 的缓冲区大小会增加。\n//在仓库init后，添加以下配置 git config http.postBuffer 524288000 //如果仓库不是自己的，可以添加以下配置 git config --global http.postBuffer 524288000 方法四： 网速太慢，换个网速快的环境。\nReference windows - git clone error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 - Stack Overflow 解决 OpenSSL SSL_read: Connection was reset, errno 10054 問題\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3openssl-ssl-read-connection-was-reset-errno-10054/","summary":"\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e方法一：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global http.sslVerify \u0026#34;false\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e方法二：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global https.sslVerify \u0026#34;false\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e方法三：\n这可能是因为版本库的大小和 git 的默认缓冲区大小，所以通过下述操作（在 git bash 上），git 的缓冲区大小会增加。\u003c/p\u003e","title":"解决 OpenSSL SSL_read: Connection was reset, errno 10054"},{"content":"变长数组 想必很多学习 C 语言的人都会在书上看到，数组在初始化时必须要确定长度（维度），也就是说定义数组时，维度一定要用常量。但是在编程中很多人肯定发现了，及时像下面这样写，编译器也不会报错。\nint n; int array[n]; 这是怎么回事？难道以前我学的是错的吗？当然不是。最官方的解释应该是 C 语言的规范和编译器的规范说明了。\n在 ISO/IEC9899 标准的 6.7.5.2 Array declarators 中明确说明了数组的长度可以为变量的，称为变长数组（VLA，variable length array）。（注：这里的变长指的是数组的长度是在运行时才能决定，但一旦决定在数组的生命周期内就不会再变。） 在 GCC 标准规范的 6.19 Arrays of Variable Length 中指出，作为编译器扩展，GCC 在 C90 模式和 C++ 编译器下遵守 ISO C99 关于变长数组的规范。 原来这种语法确实是 C 语言规范，GCC 非常完美的支持了 ISO C99。但是在 C99 之前的 C 语言中，变长数组的语法是不存在的。\n这种变长数组有什么好处呢？它可以实现与alloca函数一样的效果，在栈上进行动态的空间分配，并且在函数返回时自动释放内存，无需手动释放。\nalloca 函数用来在栈上分配空间，当函数返回时自动释放，无需手动再去释放；\n可变数组示例： 所有可变修改 (VM) 类型的声明必须在块范围或函数原型范围内。使用 static 或 extern 存储类说明符声明的数组对象不能具有可变长度数组 (VLA) 类型。但是，使用静态存储类说明符声明的对象可以具有 VM 类型（即，指向 VLA 类型的指针）。最后，使用 VM 类型声明的所有标识符都必须是普通标识符，因此不能是结构或联合的成员。\nextern int n; int A[n]; // Error - file scope VLA. extern int (*p2)[n]; // Error - file scope VM. int B[100]; // OK - file scope but not VM. void fvla(int m, int C[m][m]) // OK - VLA with prototype scope. { typedef int VLA[m][m] // OK - block scope typedef VLA. struct tag { int (*y)[n]; // Error - y not ordinary identifier. int z[n]; // Error - z not ordinary identifier. }; int D[m]; // OK - auto VLA. static int E[m]; // Error - static block scope VLA. extern int F[m]; // Error - F has linkage and is VLA. int (*s)[m]; // OK - auto pointer to VLA. extern int (*r)[m]; // Error - r had linkage and is // a pointer to VLA. static int (*q)[m] = \u0026amp;B; // OK - q is a static block // pointer to VLA. } 零长数组 GNU/GCC 在标准的 C/C++ 基础上做了有实用性的扩展，零长度数组（Arrays of Length Zero）就是其中一个知名的扩展。使用零长数组，把它作为结构体的最后一个元素非常有用：\nstruct line { int length; char contents[0]; }; struct line *thisline = (struct line *) malloc (sizeof (struct line) + this_length); thisline-\u0026gt;length = this_length; 从上例就可以看出，零长数组在有固定头部的可变对象上非常适用，我们可以根据对象的大小动态地去分配结构体的大小。\n在 Linux 内核中也有这种应用，例如由于 PID 命名空间的存在，每个进程 PID 需要映射到所有能看到其的命名空间上，但该进程所在的命名空间在开始并不确定（但至少为 init 命名空间），需要在运行是根据 level 的值来确定，所以在该结构体后面增加了一个长度为 1 的数组（因为至少在一个init命名空间上），使得该结构体 pid 是个可变长的结构体，在运行时根据进程所处的命名空间的 level 来决定 numbers 分配多大。（注：虽然不是零长度的数组，但用法是一样的）\nstruct pid { atomic_t count; unsigned int level; /* lists of tasks that use this pid */ struct hlist_head tasks[PIDTYPE_MAX]; struct rcu_head rcu; struct upid numbers[1]; }; 什么 0 长度数组不占用存储空间 0 长度数组与指针实现有什么区别呢，为什么 0 长度数组不占用存储空间呢？\n其实本质上涉及到的是一个 C 语言里面的数组和指针的区别问题。char a[1] 里面的 a 和 char *b 的 b 相同吗？\n《Programming Abstractions in C》（Roberts, E. S.，机械工业出版社，2004.6）82 页里面说。\n“arr is defined to be identical to \u0026amp;arr[0]”.\n也就是说，char a[1]里面的a实际是一个常量，等于\u0026amp;a[0]。而char *b是有一个实实在在的指针变量b存在。所以，a=b是不允许的，而b=a是允许的。\n本质上因为数组名它只是一个偏移量，数组名这个符号本身代 表了一个不可修改的地址常量 （注意：数组名永远都不会是指针！ ），但对于这个数组的大小，我们可以进行动态分配，对于编译器而言，数组名仅仅是一个符号，它不会占用任何空间，它在结构体中，只是代表了一个偏移量，代表一个不可修改的地址常量！\nReferences alloca 函数用来在栈上分配空间，当函数返回时自动释放，无需手动再去释放\nC 语言 0 长度数组 (可变数组/柔性数组) 详解_OSKernelLAB(gatieme)-CSDN 博客_柔性数组\n零长数组（柔性数组、可变数组）的使用_禾仔仔的博客-CSDN 博客\nZero Length - Using the GNU Compiler Collection (GCC)\n","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84/","summary":"\u003ch2 id=\"变长数组\"\u003e变长数组\u003c/h2\u003e\n\u003cp\u003e想必很多学习 C 语言的人都会在书上看到，\u003cstrong\u003e数组在初始化时必须要确定长度（维度）\u003c/strong\u003e，也就是说定义数组时，维度一定要用常量。但是在编程中很多人肯定发现了，及时像下面这样写，编译器也不会报错。\u003c/p\u003e","title":"C 语言中的变长数组与零长数组"},{"content":"","permalink":"https://lifeislife.cn/posts/ssh%E5%8E%9F%E7%90%86/","summary":"","title":"SSH 原理"},{"content":" 1.大部分转载自QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北 2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改 3.部分内容根据自己理解补充添加\n概述 我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：\n虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间； 虚拟机里面的物理内存（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存； 物理机的虚拟内存（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间； 物理机的物理内存（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。 内存虚拟化的关键在于维护 GPA 到 HVA 的映射关系。\n页面分配和映射的两种方式 要搞清楚 QEMU system emulation 的仿真架构，首先对于 Host OS，将 QEMU 作为进程启动，然后对于 QEMU 进程，会仿真各种硬件和运行 Guest OS，在这层 OS 上运行要全系统模拟的应用程序，因此对于 Guest OS 管理的内存要实现到 QEMU 进程的虚拟空间的转换需要 softMMU（即需要对 GPA 到 HVA 进行转换）。从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。\n影子页表 Shadow Page Table，SPT 第一种方式就是软件的方式，影子页表（Shadow Page Table）。\nKVM 通过维护记录 GVA-\u0026gt;HPA 的影子页表 SPT，减少了地址转换带来的开销，可以直接将 GVA 转换为 HPA。\n内存映射要通过页表来管理，页表地址应该放在 CR3 寄存器里面。在软件虚拟化的内存转换中，GVA 到 GPA 的转换通过查询 CR3 寄存器来完成，CR3 中保存了 Guest 的页表基地址，然后载入 MMU 中进行地址转换。\n在加入了 SPT 技术后，当 Guest 访问 CR3 时，KVM 会捕获到这个操作 EXIT_REASON_CR_ACCESS，之后 KVM 会载入特殊的 CR3 和影子页表，欺骗 Guest 这就是真实的 CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。\n本来的过程是，客户机要通过 cr3 找到客户机的页表，实现从 GVA 到 GPA 的转换，然后在宿主机上，要通过 cr3 找到宿主机的页表，实现从 HVA 到 HPA 的转换。 为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。 在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。\n\u003c!DOCTYPE html\u003e Responsive Image 为了快速检索 Guest 页表对应的影子页表，KVM 为每个客户机维护了一个 hash 表来进行客户机页表到影子页表之间的映射。对于每一个 Guest 来说，其页目录和页表都有唯一的 GPA，通过页目录/页表的 GPA 就可以在哈希链表中快速地找到对应的影子页目录/页表。\n当 Guest 切换进程时，Guest 会把待切换进程的页表基址载入 CR3，而 KVM 将会截获这一特权指令。KVM 在哈希表中找到与此页表基址对应的影子页表基址，载入 Guest CR3，使 Guest 在恢复运行时 CR3 实际指向的是新切换进程对应的影子页表。\n影子页表的引入，减少了 GVA-\u0026gt;HPA 的转换开销，但是缺点在于需要为 Guest 的每个进程都维护一个影子页表，这将带来很大的内存开销。同时影子页表的建立是很耗时的，如果 Guest 的进程过多，将导致影子页表频繁切换。\n因此 Intel 和 AMD 在此基础上提供了基于硬件的虚拟化技术 EPT。\n扩展页表 Extent Page Table，EPT Intel 的 EPT（Extent Page Table）技术和 AMD 的 NPT（Nest Page Table）技术都对内存虚拟化提供了硬件支持。这两种技术原理类似，都是在硬件层面上实现 GVA 到 HPA 之间的转换。下面就以 EPT 为例分析一下 KVM 基于硬件辅助的内存虚拟化实现。\nEPT 在原有客户机页表对客户机虚拟地址 GVA 到客户机物理地址 GPA 映射的基础上，又引入了 EPT 页表来实现客户机物理地址 GPA 到宿主机物理地址 HPA 的另一次映射。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。\n即 EPT 技术采用了在两级页表结构，即原有 Guest OS 页表对 GVA-\u0026gt;GPA 映射的基础上，又引入了 EPT 页表来实现 GPA-\u0026gt;HPA 的另一次映射，这两次地址映射都是由硬件自动完成。\n有了 EPT，在GPA-\u0026gt;HPA转换的过程中，缺页会产生 EPT 缺页异常。KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。\nKVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。\n这里，我们重点看第二种方式。因为使用了 EPT 之后，客户机里面的页表映射，也即从 GVA 到 GPA 的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而 EPT 重点帮我们解决的就是从 GPA 到 HPA 的转换问题。因为要经过两次页表，所以 EPT 又 tdp(two dimentional paging)。\nEPT 的页表结构也是分为四层，EPT Pointer（EPTP）指向 PML4 的首地址。\n\u003c!DOCTYPE html\u003e Responsive Image QEMU 的主要工作 内存虚拟化的目的就是让虚拟机能够无缝的访问内存。有了 Intel EPT 的支持后，CPU 在 VMX non-root 状态时进行内存访问会再做一次 EPT 转换。在这个过程中，QEMU 会负责以下内容：\n首先需要从自己的进程地址空间中申请内存用于 Guest 需要将上一步中申请到的内存的虚拟地址（HVA）和 Guest 的物理地址之间的映射关系传递给 KVM（kernel），即 GPA-\u0026gt;HVA 需要组织一系列的数据结构来管理虚拟内存空间，并在内存拓扑结构更改时将最新的内存信息同步至 KVM 中\nQEMU 和 KVM 的工作分界 QEMU 和 KVM 之间是通过 KVM 提供的 ioctl() 接口进行交互的。在内核的 kvm_vm_ioctl() 中，设置虚拟机内存的系统调用【kernel 就是一系列系统调用函数接口和处理逻辑，其中有个处理”创建/设置虚拟机内存“的系统调用接口】为 VM_SET_USER_MEMORY_REGION：\nstatic long kvm_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg) { /* ... */ case KVM_SET_USER_MEMORY_REGION: { // 在 KVM 中注册用户空间传入的内存信息 struct kvm_userspace_memory_region kvm_userspace_mem; r = -EFAULT; // 将传入的数据结构复制到内核空间 if (copy_from_user(\u0026amp;kvm_userspace_mem, argp, sizeof kvm_userspace_mem)) goto out; // 实际进行处理的函数 r = kvm_vm_ioctl_set_memory_region(kvm, \u0026amp;kvm_userspace_mem, 1); if (r) goto out; break; } /* ... */ } 可以看到这里需要传递的参数类型为 kvm_userspace_memory_region：\n/* for KVM_SET_USER_MEMORY_REGION */ struct kvm_userspace_memory_region { __u32 slot; // slot 编号 [参考：https://www.cnblogs.com/LoyenWang/p/11922887.html] __u32 flags; // 标志位，例如是否追踪脏页、是否可用等 __u64 guest_phys_addr; // Guest 物理地址，即 GPA __u64 memory_size; // 内存大小，单位 bytes __u64 userspace_addr; // 从 QEMU 进程地址空间中分配内存的起始地址，即 HVA }; KVM_SET_USER_MEMORY_REGION这个 ioctl 主要目的就是设置GPA-\u0026gt;HVA的映射关系，KVM 会继续调用kvm_vm_ioctl_set_memory_region()，在内核空间维护并管理 Guest 的内存。\n相关数据结构 AddressSpace 结构体定义 QEMU 用 AddressSpace 结构体表示 Guest 中 CPU/设备看到的内存【也就是Guest OS 可以在 QEMU 进程虚存中用到的所有内存，是 MemoryRegion 的集合，即 GPA 的整体】，类似于物理机中地址空间的概念，但在这里表示的是 Guest 的一段地址空间，如内存地址空间 address_space_memory 、I/O 地址空间address_space_io，它在 QEMU 源码memory.c中定义：\n/** * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects */ struct AddressSpace { /* private: */ struct rcu_head rcu; char *name; MemoryRegion *root; /* Accessed via RCU. */ struct FlatView *current_map; int ioeventfd_nb; struct MemoryRegionIoeventfd *ioeventfds; QTAILQ_HEAD(, MemoryListener) listeners; QTAILQ_ENTRY(AddressSpace) address_spaces_link; }; 每个 AddressSpace 一般包含一系列的 MemoryRegion：root指针指向根级 MemoryRegion，而 root 可能有自己的若干个 sub-regions（子节点），于是形成树状结构。这些 MemoryRegion 通过树连接起来，树的根即为 AddressSpace 的 root 域。\n全局变量 另外，QEMU 中有两个全局的静态 AddressSpace，在 memory.c 中定义：\nstatic AddressSpace address_space_memory; // 内存地址空间 static AddressSpace address_space_io; // I/O 地址空间 其 root 域分别指向之后会提到的两个 MemoryRegion 类型变量：system_memory、system_io。\nMemoryRegion 结构体定义 MemoryRegion 表示在 Guest Memory Layout 中的一段内存区域【也就是单元级 GPA 的概念，Guest OS 可以管理到的那些 Guest 物理内存单元】，它是联系 GPA 和 RAMBlocks（描述真实内存）之间的桥梁，在memory.h中定义：\nstruct MemoryRegion { /* All fields are private - violators will be prosecuted */ const MemoryRegionOps *ops; // 回调函数集合 void *opaque; MemoryRegion *parent; // 父 MemoryRegion 指针 Int128 size; // 该区域内存的大小 target_phys_addr_t addr; // 在 Address Space 中的地址，即 HVA void (*destructor)(MemoryRegion *mr); ram_addr_t ram_addr; // MemoryRegion 的起始地址，即 GPA bool subpage; bool terminates; bool readable; bool ram; // 是否表示 RAM bool readonly; /* For RAM regions */ bool enabled; // 是否已经通知 KVM 使用这段内存 bool rom_device; bool warning_printed; /* For reservations */ MemoryRegion *alias; // 是否为 MemoryRegion alias target_phys_addr_t alias_offset; // 若为 alias，在原 MemoryRegion 中的 offset unsigned priority; bool may_overlap; QTAILQ_HEAD(subregions, MemoryRegion) subregions; // 子区域链表头 QTAILQ_ENTRY(MemoryRegion) subregions_link; // 子区域链表节点 QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced; const char *name; // MemoryRegion 的名字，调试时使用 uint8_t dirty_log_mask; // 表示哪一种 dirty map 被使用，共分三种 unsigned ioeventfd_nb; MemoryRegionIoeventfd *ioeventfds; }; 全局变量 在 QEMU 的 exec.c 中也定义了两个静态的 MemoryRegion 指针变量：\nstatic MemoryRegion *system_memory; // 内存 MemoryRegion，对应 address_space_memory static MemoryRegion *system_io; // I/O MemoryRegion，对应 address_space_io 与两个全局 AddressSpace 对应，即 AddressSpace 的 root 域指向这两个 MemoryRegion。\nMemoryRegion 的类型 MemoryRegion 有多种类型，可以表示一段 RAM、ROM、MMIO、alias(别名)。\n若为 alias 则表示一个 MemoryRegion 的部分区域，例如，QEMU 会为 pc.ram 这个表示 RAM 的 MemoryRegion 添加两个 alias：ram-below-4g 和 ram-above-4g，之后会看到具体的代码实例。\n另外，MemoryRegion 也可以表示一个 container，这就表示它只是其他若干个 MemoryRegion 的容器。\n那么要如何创建不同类型的 MemoryRegion 呢？\n在 QEMU 中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将 MemoryRegion 划分为以下三种类型：\n根级 MemoryRegion：直接通过 memory_region_init 初始化，没有自己的内存，用于管理 subregion，例如 system_memory： void memory_region_init(MemoryRegion *mr, const char *name, uint64_t size) { mr-\u0026gt;ops = NULL; mr-\u0026gt;parent = NULL; mr-\u0026gt;size = int128_make64(size); if (size == UINT64_MAX) { mr-\u0026gt;size = int128_2_64(); } mr-\u0026gt;addr = 0; mr-\u0026gt;subpage = false; mr-\u0026gt;enabled = true; mr-\u0026gt;terminates = false; // 非实体 MemoryRegion，搜索时会继续前往其 subregions mr-\u0026gt;ram = false; // 根级 MemoryRegion 不分配内存 mr-\u0026gt;readable = true; mr-\u0026gt;readonly = false; mr-\u0026gt;rom_device = false; mr-\u0026gt;destructor = memory_region_destructor_none; mr-\u0026gt;priority = 0; mr-\u0026gt;may_overlap = false; mr-\u0026gt;alias = NULL; QTAILQ_INIT(\u0026amp;mr-\u0026gt;subregions); memset(\u0026amp;mr-\u0026gt;subregions_link, 0, sizeof mr-\u0026gt;subregions_link); QTAILQ_INIT(\u0026amp;mr-\u0026gt;coalesced); mr-\u0026gt;name = g_strdup(name); mr-\u0026gt;dirty_log_mask = 0; mr-\u0026gt;ioeventfd_nb = 0; mr-\u0026gt;ioeventfds = NULL; } 可以看到 mr-\u0026gt;addr 被设置为 0，而 mr-\u0026gt;ram_addr 则并没有初始化。\n实体 MemoryRegion：通过memory_region_init_ram()初始化，有自己的内存（从 QEMU 进程地址空间中分配），大小为size，例如ram_memory、 pci_memory： void *pc_memory_init(MemoryRegion *system_memory, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, ram_addr_t below_4g_mem_size, ram_addr_t above_4g_mem_size, MemoryRegion *rom_memory, MemoryRegion **ram_memory) { MemoryRegion *ram, *option_rom_mr; /* ...*/ /* Allocate RAM. We allocate it as a single memory region and use * aliases to address portions of it, mostly for backwards compatibility * with older qemus that used qemu_ram_alloc(). */ ram = g_malloc(sizeof(*ram)); // 调用 memory_region_init_ram 对 ram_memory 进行初始化 memory_region_init_ram(ram, \u0026#34;pc.ram\u0026#34;, below_4g_mem_size + above_4g_mem_size); vmstate_register_ram_global(ram); *ram_memory = ram; /* ... */ } void memory_region_init_ram(MemoryRegion *mr, const char *name, uint64_t size) { memory_region_init(mr, name, size); mr-\u0026gt;ram = true; mr-\u0026gt;terminates = true; mr-\u0026gt;destructor = memory_region_destructor_ram; mr-\u0026gt;ram_addr = qemu_ram_alloc(size, mr); } 可以看到这里是先调用了memory_region_init()，之后设置 RAM 属性，并继续调用qemu_ram_alloc()分配内存。\n别名 MemoryRegion：通过memory_region_init_alias() 初始化，没有自己的内存，表示实体 MemoryRegion 的一部分。通过 alias 成员指向实体 MemoryRegion，alias_offset为在实体 MemoryRegion 中的偏移量，例如ram_below_4g、ram_above_4g： void *pc_memory_init(MemoryRegion *system_memory, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, ram_addr_t below_4g_mem_size, ram_addr_t above_4g_mem_size, MemoryRegion *rom_memory, MemoryRegion **ram_memory) { MemoryRegion *ram_below_4g, *ram_above_4g; /* ... */ ram_below_4g = g_malloc(sizeof(*ram_below_4g)); // 调用 memory_region_init_alias 对 ram_below_4g 进行初始化 memory_region_init_alias(ram_below_4g, \u0026#34;ram-below-4g\u0026#34;, ram, 0, below_4g_mem_size); /* .. void memory_region_init_alias(MemoryRegion *mr, const char *name, MemoryRegion *orig, target_phys_addr_t offset, uint64_t size) { memory_region_init(mr, name, size); mr-\u0026gt;alias = orig; // 指向实体 MemoryRegion mr-\u0026gt;alias_offset = offset; //通过 offset 得到实体的某一个部分 } RAMBlock 结构体定义 MemoryRegion 用来描述一段逻辑层面上的内存区域，而记录实际分配的内存地址信息的结构体则是 RAMBlock，在ramblock.h中定义：\nstruct RAMBlock { struct rcu_head rcu; struct MemoryRegion *mr; uint8_t *host; uint8_t *colo_cache; /* For colo, VM\u0026#39;s ram cache */ ram_addr_t offset; ram_addr_t used_length; ram_addr_t max_length; void (*resized)(const char*, uint64_t length, void *host); uint32_t flags; /* Protected by iothread lock. */ char idstr[256]; /* RCU-enabled, writes protected by the ramlist lock */ QLIST_ENTRY(RAMBlock) next; QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers; int fd; size_t page_size; /* dirty bitmap used during migration */ unsigned long *bmap; /* bitmap of already received pages in postcopy */ unsigned long *receivedmap; /* * bitmap to track already cleared dirty bitmap. When the bit is * set, it means the corresponding memory chunk needs a log-clear. * Set this up to non-NULL to enable the capability to postpone * and split clearing of dirty bitmap on the remote node (e.g., * KVM). The bitmap will be set only when doing global sync. * * NOTE: this bitmap is different comparing to the other bitmaps * in that one bit can represent multiple guest pages (which is * decided by the `clear_bmap_shift\u0026#39; variable below). On * destination side, this should always be NULL, and the variable * `clear_bmap_shift\u0026#39; is meaningless. */ unsigned long *clear_bmap; uint8_t clear_bmap_shift; /* * RAM block length that corresponds to the used_length on the migration * source (after RAM block sizes were synchronized). Especially, after * starting to run the guest, used_length and postcopy_length can differ. * Used to register/unregister uffd handlers and as the size of the received * bitmap. Receiving any page beyond this length will bail out, as it * could not have been valid on the source. */ ram_addr_t postcopy_length; }; 可以看到在 RAMBlock 中 host 和 offset 域分别对应了 HVA 和GPA，因此也可以说 RAMBlock 中存储了GPA-\u0026gt;HVA的映射关系，另外每一个 RAMBlock 都会指向其所属的 MemoryRegion。\n全局变量 ram_list QEMU 在ramlist.h中定义了一个全局变量ram_list，以链表的形式维护了所有的 RAMBlock：\ntypedef struct RAMList { QemuMutex mutex; RAMBlock *mru_block; /* RCU-enabled, writes protected by the ramlist lock. */ QLIST_HEAD(, RAMBlock) blocks; DirtyMemoryBlocks *dirty_memory[DIRTY_MEMORY_NUM]; uint32_t version; QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers; } RAMList; extern RAMList ram_list; 每一个新分配的 RAMBlock 都会被插入到ram_list的头部。如需查找地址所对应的 RAMBlock，则需要遍历ram_list，当目标地址落在当前RAMBlock的地址区间时，该 RAMBlock 即为查找目标。\nAS、MR、RAMBlock 之间的关系 \u003c!DOCTYPE html\u003e Responsive Image FlatView AddressSpace 的 root 域及其子树共同构成了 Guest 的物理地址空间，但这些都是在 QEMU 侧定义的。要传入 KVM 进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其转换为一个“平坦”的地址模型，也就是一个从零开始、只包含地址信息的数据结构，这在 QEMU 中通过 FlatView 来表示。每个 AddressSpace 都有一个与之对应的 FlatView 指针 current_map，表示其对应的平面展开视图。\n结构体定义 FlatView 在memory.c中定义：\n/* Flattened global view of current active memory hierarchy. Kept in sorted * order. */ struct FlatView { struct rcu_head rcu; unsigned ref; FlatRange *ranges; // 对应的 FlatRange 数组 unsigned nr; // FlatRange 的数目 unsigned nr_allocated; // 当前数组的项数 struct AddressSpaceDispatch *dispatch; MemoryRegion *root; }; 其中，ranges是一个数组，记录了 FlatView 下所有的 FlatRange。\nFlatRange 在 FlatView 中，FlatRange 表示在 FlatView 中的一段内存范围，同样在memory.c中定义：\n/* Range of memory in the global map. Addresses are absolute. */ struct FlatRange { MemoryRegion *mr; // 指向所属的 MemoryRegion hwaddr offset_in_region; // 在全局 MemoryRegion 中的 offset，对应 GPA AddrRange addr; // 代表的地址区间，对应 HVA uint8_t dirty_log_mask; bool romd_mode; bool readonly; bool nonvolatile; }; 每个 FlatRange 对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中，具体的地址范围由一个 AddrRange 结构来描述：\n/* * AddrRange 用于表示 FlatRange 的起始地址及大小 */ struct AddrRange { Int128 start; Int128 size; }; MemoryRegionSection 结构体定义 在 QEMU 中，还有几个起到中介作用的结构体，MemoryRegionSection 就是其中之一。\n之前介绍的 FlatRange 代表一个物理地址空间的片段，偏向于描述在 Host 侧即 AddressSpace 中的分布【Guest 的物理空间】，而 MemoryRegionSection 则代表在 Guest 侧即 MemoryRegion 中的片段。MemoryRegionSection 在memory.h中定义：\n/** * MemoryRegionSection: describes a fragment of a #MemoryRegion * * @mr: the region, or %NULL if empty * @address_space: the address space the region is mapped in * @offset_within_region: the beginning of the section, relative to @mr\u0026#39;s start * @size: the size of the section; will not exceed @mr\u0026#39;s boundaries * @offset_within_address_space: the address of the first byte of the section * relative to the region\u0026#39;s address space * @readonly: writes to this section are ignored */ //只是起到描述的作用，描述了是哪个 AddressSpace 的 MemoryRegion， //并且在 MemoryRegion 中的 offset，和在 AddressSpace 展开为平坦内存的 offset struct MemoryRegionSection { MemoryRegion *mr; // 所属的 MemoryRegion MemoryRegion *address_space; // 关联的 AddressSpace target_phys_addr_t offset_within_region; // 在 MemoryRegion 内部的 offset uint64_t size; // Section 的大小 target_phys_addr_t offset_within_address_space; // 在 AddressSpace 内部的 offset bool readonly; // 是否为只读 }; offset_within_region：在所属 MemoryRegion 中的offset。一个AddressSpace 可能由多个 MemoryRegion 组成，因此该 offset 是局部的 offset_within_address_space：在所属 AddressSpace 中的 offset，它是全局的 和其他数据结构之间的关系 \u003c!DOCTYPE html\u003e Responsive Image AddressSpace 的root指向对应的根级MemoryRegion，current_map指向AddressSpace 的root通过generate_memory_topology()生成的 FlatView FlatView 中的ranges数组表示该MemoryRegion 所表示的Guest地址区间【GPA 的整个平坦物理空间】，并按照地址的顺序进行排列 MemoryRegionSection 由ranges数组中的 FlatRange 对应生成，作为注册到 KVM中的基本单位 QEMU 在用户空间申请内存后，需要将内存信息通过一系列系统调用传入内核空间的 KVM，由 KVM 侧进行管理，因此 QEMU 侧也定义了一些用于向 KVM 传递参数的结构体。\n以下为KVM相关的数据结构。\nKVMSlot 在 kvm_init.h中定义，是 KVM 中内存管理的基本单位：\ntypedef struct KVMSlot { hwaddr start_addr; // Guest 物理地址，GPA ram_addr_t memory_size; // 内存大小 void *ram; // QEMU 用户空间地址，HVA int slot; // Slot 编号 int flags; // 标志位，例如是否追踪脏页、是否可用等 /* Dirty bitmap cache for the slot */ unsigned long *dirty_bmap; unsigned long dirty_bmap_size; /* Cache of the address space ID */ int as_id; /* Cache of the offset in ram address space */ ram_addr_t ram_start_offset; } KVMSlot; KVMSlot 类似于内存插槽的概念。\nkvm_userspace_memory_region 调用ioctl(KVM_SET_USER_MEMORY_REGION)时需要向 KVM 传递的参数，在kvm.h中定义\n/* for KVM_SET_USER_MEMORY_REGION */ struct kvm_userspace_memory_region { __u32 slot; // slot 编号 __u32 flags; // 标志位，例如是否追踪脏页、是否可用等 __u64 guest_phys_addr; // Guest 物理地址，GPA __u64 memory_size; // 内存大小，bytes __u64 userspace_addr; // 从 QEMU 进程空间分配的起始地址，HVA }; MemoryListener 结构体定义 为了监控虚拟机的物理地址访问，对于每一个 AddressSpace，都会有一个 MemoryListener 与之对应。每当物理映射GPA-\u0026gt;HVA发生改变时，就会回调这些函数。MemoryListener 是对一些事件的回调函数合集，在memory.h中定义：\n/** * MemoryListener: callbacks structure for updates to the physical memory map * * Allows a component to adjust to changes in the guest-visible memory map. * Use with memory_listener_register() and memory_listener_unregister(). */ struct MemoryListener { void (*begin)(MemoryListener *listener); void (*commit)(MemoryListener *listener); void (*region_add)(MemoryListener *listener, MemoryRegionSection *section); void (*region_del)(MemoryListener *listener, MemoryRegionSection *section); void (*region_nop)(MemoryListener *listener, MemoryRegionSection *section); void (*log_start)(MemoryListener *listener, MemoryRegionSection *section); void (*log_stop)(MemoryListener *listener, MemoryRegionSection *section); void (*log_sync)(MemoryListener *listener, MemoryRegionSection *section); void (*log_global_start)(MemoryListener *listener); void (*log_global_stop)(MemoryListener *listener); void (*eventfd_add)(MemoryListener *listener, MemoryRegionSection *section, bool match_data, uint64_t data, EventNotifier *e); void (*eventfd_del)(MemoryListener *listener, MemoryRegionSection *section, bool match_data, uint64_t data, EventNotifier *e); /* Lower = earlier (during add), later (during del) */ unsigned priority; MemoryRegion *address_space_filter; QTAILQ_ENTRY(MemoryListener) link; }; 全局变量 memory_listeners 所有的 MemoryListener 都会挂在全局变量memory_listeners链表上，在memory.c中定义：\nstatic QTAILQ_HEAD(, MemoryListener) memory_listeners = QTAILQ_HEAD_INITIALIZER(memory_listeners); 在memory.c中枚举了ListenerDirection:\nenum ListenerDirection { Forward, Reverse }; 重要数据结构总览 结构体名 说明 AddressSpace VM 能看到的一段地址空间，偏向 Host 侧【注意指的是偏向】 MemoryRegion 地址空间中一段逻辑层面的内存区域，偏向 Guest 侧 RAMBlock 记录实际分配的内存地址信息，存储了 GPA-\u0026gt;HVA 的映射关系 FlatView MemoryRegion 对应的平面展开视图，包含一个 FlatRange 类型的 ranges 数组 FlatRange 对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中 MemoryRegionSection 表示 MemoryRegion 中的片段 MemoryListener 回调函数集合 KVMSlot KVM 中内存管理的基本单位，表示一个内存插槽 kvm_userspace_memory_region 调用 ioctl(KVM_SET_USER_MEMORY_REGION) 时需要向 KVM 传递的参数 具体实现机制 QEMU 的内存申请流程大致可分为三个部分：回调函数的注册、AddressSpace 的初始化、实际内存的分配。下面将根据在 vl.c 的 main() 函数中的调用顺序分别介绍。\n回调函数的注册 \u003c!DOCTYPE html\u003e Responsive Image int main() └─ static int configure_accelerator() └─ int kvm_init() // 初始化 KVM ├─ int kvm_ioctl(KVM_CREATE_VM) // 创建 VM ├─ int kvm_arch_init() // 针对不同的架构进行初始化 └─ void memory_listener_register() // 注册 kvm_memory_listener └─ static void listener_add_address_space() // 调用 region_add 回调 └─ static void kvm_region_add() // region_add 对应的回调实现 └─ static void kvm_set_phys_mem() // 根据传入的 section 填充 KVMSlot └─ static int kvm_set_user_memory_region() └─ int ioctl(KVM_SET_USER_MEMORY_REGION) 进入configure_accelerator()后，QEMU会先调用configure_accelerator()设置 KVM 的加速支持，之后进入kvm_init()。该函数主要完成对 KVM 的初始化，包括一些常规检查如 CPU 个数、KVM 版本等，之后通过kvm_ioctl(KVM_CREATE_VM)与内核交互，创建 KVM 虚拟机。在kvm_init()的最后，会调用memory_listener_register()注册kvm_memory_listener：\nstatic int kvm_init(MachineState *ms) { MachineClass *mc = MACHINE_GET_CLASS(ms); // 打开/dev/kvm s-\u0026gt;fd = qemu_open_old(\u0026#34;/dev/kvm\u0026#34;, O_RDWR); // 创建 VM do { ret = kvm_ioctl(s, KVM_CREATE_VM, type); } while (ret == -EINTR); /* ... */ ret = kvm_arch_init(s); // 针对不同的架构进行初始化 // 对于以下 AddressSpace，设置其对应的 listener kvm_memory_listener_register(s, \u0026amp;s-\u0026gt;memory_listener, \u0026amp;address_space_memory, 0, \u0026#34;kvm-memory\u0026#34;); memory_listener_register(\u0026amp;kvm_coalesced_pio_listener, \u0026amp;address_space_io); /* ... */ } void memory_listener_register(MemoryListener *listener, AddressSpace *as) { MemoryListener *other = NULL; /* Only one of them can be defined for a listener */ assert(!(listener-\u0026gt;log_sync \u0026amp;\u0026amp; listener-\u0026gt;log_sync_global)); listener-\u0026gt;address_space = as; if (QTAILQ_EMPTY(\u0026amp;memory_listeners) || listener-\u0026gt;priority \u0026gt;= QTAILQ_LAST(\u0026amp;memory_listeners)-\u0026gt;priority) { QTAILQ_INSERT_TAIL(\u0026amp;memory_listeners, listener, link); } else { QTAILQ_FOREACH(other, \u0026amp;memory_listeners, link) { if (listener-\u0026gt;priority \u0026lt; other-\u0026gt;priority) { break; } } QTAILQ_INSERT_BEFORE(other, listener, link); } if (QTAILQ_EMPTY(\u0026amp;as-\u0026gt;listeners) || listener-\u0026gt;priority \u0026gt;= QTAILQ_LAST(\u0026amp;as-\u0026gt;listeners)-\u0026gt;priority) { QTAILQ_INSERT_TAIL(\u0026amp;as-\u0026gt;listeners, listener, link_as); } else { QTAILQ_FOREACH(other, \u0026amp;as-\u0026gt;listeners, link_as) { if (listener-\u0026gt;priority \u0026lt; other-\u0026gt;priority) { break; } } QTAILQ_INSERT_BEFORE(other, listener, link_as); } listener_add_address_space(listener, as); } 最后的listener_add_address_space()主要是将 listener 注册到其对应的 AddressSpace 上，并根据 AddressSpace 对应的 FlatRange 数组，生成 MemoryRegionSection【MemoryRegionSection就像是为FlatRange数组设置的一种中介表示，便于传入KVM，因为传入KVM应该是对平坦内存的一种表示】，并注册到 KVM 中：\nstatic void listener_add_address_space(MemoryListener *listener, AddressSpace *as) { FlatView *view; FlatRange *fr; if (listener-\u0026gt;begin) { listener-\u0026gt;begin(listener); } /* 开启内存脏页记录 */ if (global_dirty_tracking) { if (listener-\u0026gt;log_global_start) { listener-\u0026gt;log_global_start(listener); } } /* 遍历 AddressSpace 对应的 FlatRange 数组，并将其转换成 MemoryRegionSection */ view = address_space_get_flatview(as); FOR_EACH_FLAT_RANGE(fr, view) { MemoryRegionSection section = section_from_flat_range(fr, view); /* 将 section 所代表的内存区域注册到 KVM 中 */ if (listener-\u0026gt;region_add) { listener-\u0026gt;region_add(listener, \u0026amp;section); } if (fr-\u0026gt;dirty_log_mask \u0026amp;\u0026amp; listener-\u0026gt;log_start) { listener-\u0026gt;log_start(listener, \u0026amp;section, 0, fr-\u0026gt;dirty_log_mask); } } if (listener-\u0026gt;commit) { listener-\u0026gt;commit(listener); } flatview_unref(view); } 由于此时 AddressSapce 尚未初始化，所以此处的循环为空，仅是在全局注册了kvm_memory_listener。最后调用了kvm_memory_listener-\u0026gt;region_add()，对应的实现是kvm_region_add()，该函数最终会通过ioctl(KVM_SET_USER_MEMORY_REGION)，将 QEMU 侧申请的内存信息传入 KVM 进行注册，这里的流程会在下一部分进行分析。\nAddressSpace 的初始化 \u003c!DOCTYPE html\u003e Responsive Image int main() └─ void cpu_exec_init_all() ├─ static void memory_map_init() | ├─ void memory_region_init() // 初始化 system_memory/io 这两个全局 MemoryRegion | ├─ void set_system_memory_map() // address_space_memory-\u0026gt;root = system_memory | | └─ static void memory_region_update_topology() // 为 MemoryRegion 生成 FlatView | | └─ static void address_space_update_topology() // as-\u0026gt;current_map = new_view | | └─ static void address_space_update_topology_pass() | | └─ static void kvm_region_add() // region_add 对应的回调实现 | | └─ static void kvm_set_phys_mem() // 根据传入的 section 填充 KVMSlot | | └─ static int kvm_set_user_memory_region() | | └─ int ioctl(KVM_SET_USER_MEMORY_REGION) | | | └─ void memory_listener_register() // 注册对应的 MemoryListener | └─ static void listener_add_address_space() | └─ static void io_mem_init() └─ void memory_region_init_io() // ram/rom/unassigned/notdirty/subpage-ram/watch └─ void memory_region_init() 第一部分在全局注册了kvm_memory_listener，但由于AddressSpace 尚未初始化，实际上并未向 KVM 中注册任何实际的内存信息。QEMU 在main()函数中会继续调用cpu_exec_init_all()对AddressSpace进行初始化，该函数实际上是对两个 init 函数的封装调用：\nvoid cpu_exec_init_all(void) { qemu_mutex_init(\u0026amp;ram_list.mutex); /* The data structures we set up here depend on knowing the page size, * so no more changes can be made after this point. * In an ideal world, nothing we did before we had finished the * machine setup would care about the target page size, and we could * do this much later, rather than requiring board models to state * up front what their requirements are. */ finalize_target_page_bits(); io_mem_init(); // 初始化六个I/O MemoryRegion memory_map_init(); // 初始化两个全局 AddressSpace，以及对应的 MemoryRegion、FlatView qemu_mutex_init(\u0026amp;map_client_list_lock); } 先来看memory_map_init()，主要用来初始化两个全局的系统地址空间system_memory、system_io\nstatic void memory_map_init(void) { system_memory = g_malloc(sizeof(*system_memory)); // 1. 初始化 system_memory memory_region_init(system_memory, NULL, \u0026#34;system\u0026#34;, UINT64_MAX); // 2. 设置 address_space_memory 关联 system_memory // 这两个都是全局变量，也就是把内存地址空间和 IO 地址空间于对应的 MemoryRegion 联系起来 //及其对应的 FlatView address_space_init(\u0026amp;address_space_memory, system_memory, \u0026#34;memory\u0026#34;); system_io = g_malloc(sizeof(*system_io)); // 1. 初始化 system_io memory_region_init_io(system_io, NULL, \u0026amp;unassigned_io_ops, NULL, \u0026#34;io\u0026#34;, 65536); // 2. 设置 address_space_io 关联 system_io // 及其对应的 FlatView address_space_init(\u0026amp;address_space_io, system_io, \u0026#34;I/O\u0026#34;); } 这里比较重要的是address_space_init()，先设置 AddressSpace 对应的 MemoryRegion，之后根据system_memory更新address_space_memory对应的 FlatView：\nvoid address_space_init(AddressSpace *as, MemoryRegion *root, const char *name) { memory_region_ref(root); // 将 address_space_memory 的 root 域指向 system_memory as-\u0026gt;root = root; as-\u0026gt;current_map = NULL; as-\u0026gt;ioeventfd_nb = 0; as-\u0026gt;ioeventfds = NULL; QTAILQ_INIT(\u0026amp;as-\u0026gt;listeners); QTAILQ_INSERT_TAIL(\u0026amp;address_spaces, as, address_spaces_link); as-\u0026gt;name = g_strdup(name ? name : \u0026#34;anonymous\u0026#34;); // 根据 system_memory 更新 address_space_memory 对应的 FlatView address_space_update_topology(as); address_space_update_ioeventfds(as); } address_space_update_topology()会继续调用generate_memory_topology()生成 AddressSpace 对应的 FlatView视图：\nstatic void address_space_update_topology(AddressSpace *as) { MemoryRegion *physmr = memory_region_get_flatview_root(as-\u0026gt;root); flatviews_init(); if (!g_hash_table_lookup(flat_views, physmr)) { generate_memory_topology(physmr); } address_space_set_flatview(as); } address_space_update_topology()会先调用generate_memory_topology()生成system_memory更新后的视图new_view，再将address_space_memory的current_map指向这个new_view，最后销毁old_view：\nstatic void address_space_set_flatview(AddressSpace *as) { FlatView *old_view = address_space_to_flatview(as); MemoryRegion *physmr = memory_region_get_flatview_root(as-\u0026gt;root); FlatView *new_view = g_hash_table_lookup(flat_views, physmr); assert(new_view); if (old_view == new_view) { return; } if (old_view) { flatview_ref(old_view); } flatview_ref(new_view); if (!QTAILQ_EMPTY(\u0026amp;as-\u0026gt;listeners)) { FlatView tmpview = { .nr = 0 }, *old_view2 = old_view; if (!old_view2) { old_view2 = \u0026amp;tmpview; } address_space_update_topology_pass(as, old_view2, new_view, false); address_space_update_topology_pass(as, old_view2, new_view, true); } /* Writes are protected by the BQL. */ qatomic_rcu_set(\u0026amp;as-\u0026gt;current_map, new_view); if (old_view) { flatview_unref(old_view); } /* Note that all the old MemoryRegions are still alive up to this * point. This relieves most MemoryListeners from the need to * ref/unref the MemoryRegions they get---unless they use them * outside the iothread mutex, in which case precise reference * counting is necessary. */ if (old_view) { flatview_unref(old_view); } } 在address_space_update_topology_pass()的最后，会调用MEMORY_LISTENER_UPDATE_REGION这个宏，触发region_add对应的回调函数kvm_region_add()。\n这个宏在memory.c中定义，会将 FlatView 中的 FlatRange 转换为 MemoryRegionSection，作为入参传递给kvm_region_add()：\n/* No need to ref/unref .mr, the FlatRange keeps it alive. */ #define MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...) \\ do { \\ MemoryRegionSection mrs = section_from_flat_range(fr, \\ address_space_to_flatview(as)); \\ MEMORY_LISTENER_CALL(as, callback, dir, \u0026amp;mrs, ##_args); \\ } while(0) 而kvm_region_add()实际上是对kvm_set_phys_mem()的封装调用。该函数比较复杂，会根据传入的section填充 KVMSlot，再传递给kvm_set_user_memory_region()：\nstatic int kvm_set_user_memory_region(KVMMemoryListener *kml, KVMSlot *slot, bool new) { KVMState *s = kvm_state; struct kvm_userspace_memory_region mem; int ret; // 根据 KVMSlot 填充 kvm_userspace_memory_region mem.slot = slot-\u0026gt;slot | (kml-\u0026gt;as_id \u0026lt;\u0026lt; 16); mem.guest_phys_addr = slot-\u0026gt;start_addr; mem.userspace_addr = (unsigned long)slot-\u0026gt;ram; mem.flags = slot-\u0026gt;flags; if (slot-\u0026gt;memory_size \u0026amp;\u0026amp; !new \u0026amp;\u0026amp; (mem.flags ^ slot-\u0026gt;old_flags) \u0026amp; KVM_MEM_READONLY) { /* Set the slot size to 0 before setting the slot to the desired * value. This is needed based on KVM commit 75d61fbc. */ mem.memory_size = 0; ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, \u0026amp;mem); if (ret \u0026lt; 0) { goto err; } } mem.memory_size = slot-\u0026gt;memory_size; ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, \u0026amp;mem); slot-\u0026gt;old_flags = mem.flags; return ret; } 可以看到这里又将 KVMSlot 转换为 kvm_userspace_memory_region，作为ioctl()的参数，交给内核中的 KVM 进行内存的注册【设置GPA-\u0026gt;HVA的映射关系，在内核空间维护并管理 Guest 的内存】。\n至此 QEMU 侧负责管理内存的数据结构均已完成初始化，可以参考下面的图片了解各数据结构之间的对应关系\n\u003c!DOCTYPE html\u003e Responsive Image 实际内存的分配 \u003c!DOCTYPE html\u003e Responsive Image int main() └─ void machine-\u0026gt;init(ram_size, ...) └─ static void pc_init_pci(ram_size, ...) // 初始化虚拟机 └─ static void pc_init1(system_memory, system_io, ram_size, ...) ├─ void memory_region_init(pci_memory, \u0026#34;pci\u0026#34;, ...) // pci_memory, rom_memory └─ void pc_memory_init() // 初始化内存，分配实际的物理内存地址 ├─ void memory_region_init_ram() // 创建 pc.ram, pc.rom 并分配内存 | ├─ void memory_region_init() | └─ ram_addr_t qemu_ram_alloc() | └─ ram_addr_t qemu_ram_alloc_from_ptr() | ├─ void vmstate_register_ram_global() // 将 MR 的 name 写入 RAMBlock 的 idstr | └─ void vmstate_register_ram() | └─ void qemu_ram_set_idstr() | ├─ void memory_region_init_alias() // 初始化 ram_below_4g, ram_above_4g └─ void memory_region_add_subregion() // 在 system_memory 中添加 subregions └─ static void memory_region_add_subregion_common() └─ static void memory_region_update_topology() // 为 MemoryRegion 生成 FlatView └─ static void address_space_update_topology() // as-\u0026gt;current_map = new_view └─ static void address_space_update_topology_pass() └─ static void kvm_region_add() // region_add 对应的回调实现 └─ static void kvm_set_phys_mem() // 根据传入的 section 填充 KVMSlot └─ static int kvm_set_user_memory_region() └─ int ioctl(KVM_SET_USER_MEMORY_REGION) 之前的回调函数注册、AddressSpace 的初始化，实际上均没有对应的物理内存。【实际的内存是在 RAMBlock 中】\n我们再回到 qemu 启动的 main 函数中。接下来的初始化过程会调用 pc_init1。在这里面，对于 CPU 虚拟化，我们会调用 pc_cpus_init。另外，pc_init1 还会调用pc_memory_init，进行内存的虚拟化。\nvoid *pc_memory_init(MemoryRegion *system_memory, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, ram_addr_t below_4g_mem_size, ram_addr_t above_4g_mem_size, MemoryRegion *rom_memory, MemoryRegion **ram_memory) { MemoryRegion *ram, *option_rom_mr; // 两个实体 MR: pc.ram, pc.rom MemoryRegion *ram_below_4g, *ram_above_4g; // 两个别名 MR: ram_below_4g, ram_above_4g /* Allocate RAM. We allocate it as a single memory region and use * aliases to address portions of it, mostly for backwards compatibility * with older qemus that used qemu_ram_alloc(). */ ram = g_malloc(sizeof(*ram)); // 创建 ram // 分配具体的内存（实际上会创建一个 RAMBlock 并将其 offset 值写入 ram.ram_addr，对应 GPA） memory_region_init_ram(ram, \u0026#34;pc.ram\u0026#34;, below_4g_mem_size + above_4g_mem_size); // 将 MR 的 name 写入 RAMBlock 的 idstr vmstate_register_ram_global(ram); *ram_memory = ram; // 创建 ram_below_4g 表示 4G 以下的内存 ram_below_4g = g_malloc(sizeof(*ram_below_4g)); memory_region_init_alias(ram_below_4g, \u0026#34;ram-below-4g\u0026#34;, ram, 0, below_4g_mem_size); // 将 ram_below_4g 挂在 system_memory 下 memory_region_add_subregion(system_memory, 0, ram_below_4g); if (above_4g_mem_size \u0026gt; 0) { ram_above_4g = g_malloc(sizeof(*ram_above_4g)); memory_region_init_alias(ram_above_4g, \u0026#34;ram-above-4g\u0026#34;, ram, below_4g_mem_size, above_4g_mem_size); memory_region_add_subregion(system_memory, 0x100000000ULL, ram_above_4g); } /* ... */ } 这里的重点在于memory_region_init_ram()，它通过qemu_ram_alloc()获取 ram 这个 MemoryRegion 对应的 RAMBlock 的offset，并存入ram.ram_addr，这样就可以在ram_list中根据该字段查找 MR 对应的 RAMBlock：\nvoid memory_region_init_ram(MemoryRegion *mr, const char *name, uint64_t size) { memory_region_init(mr, name, size); // 填充字段，初始化默认值 mr-\u0026gt;ram = true; // 表示为 RAM mr-\u0026gt;terminates = true; // 表示为实体 MemoryRegion mr-\u0026gt;destructor = memory_region_destructor_ram; mr-\u0026gt;ram_addr = qemu_ram_alloc(size, mr); // 这里保存 RAMBlock 的 offset，即 GPA } 而 qemu_ram_alloc() 最终会调用 qemu_ram_alloc_from_ptr()，创建一个对应大小 RAMBlock 并分配内存，返回对应的 GPA 地址存入 mr-\u0026gt;ram_addr 中：\nram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host, MemoryRegion *mr) { RAMBlock *new_block; // 创建一个 RAMBlock size = TARGET_PAGE_ALIGN(size); // 页对齐 new_block = g_malloc0(sizeof(*new_block)); // 初始化 new_block new_block-\u0026gt;mr = mr; // 将 new_block-\u0026gt; 指向入参的 MemoryRegion new_block-\u0026gt;offset = find_ram_offset(size); // 从 ram_list 中的 RAMBlock 之间找到一段可以满足 size 需求的 gap，并返回起始地址的 offset，对应 GPA if (host) { // 新建的 RAMBlock host 字段为空，跳过 new_block-\u0026gt;host = host; new_block-\u0026gt;flags |= RAM_PREALLOC_MASK; } else { if (mem_path) { // 未指定 mem_path #if defined (__linux__) \u0026amp;\u0026amp; !defined(TARGET_S390X) new_block-\u0026gt;host = file_ram_alloc(new_block, size, mem_path); if (!new_block-\u0026gt;host) { new_block-\u0026gt;host = qemu_vmalloc(size); qemu_madvise(new_block-\u0026gt;host, size, QEMU_MADV_MERGEABLE); } #else fprintf(stderr, \u0026#34;-mem-path option unsupported\\n\u0026#34;); exit(1); #endif } else { if (xen_enabled()) { xen_ram_alloc(new_block-\u0026gt;offset, size, mr); } else if (kvm_enabled()) { // 从这里继续 /* some s390/kvm configurations have special constraints */ new_block-\u0026gt;host = kvm_vmalloc(size); // 实际上还是调用 qemu_vmalloc(size) } else { new_block-\u0026gt;host = qemu_vmalloc(size); // 从 QEMU 的线性空间中分配 size 大小的内存，返回 HVA } qemu_madvise(new_block-\u0026gt;host, size, QEMU_MADV_MERGEABLE); } } new_block-\u0026gt;length = size; // 将 length 设置为 size QLIST_INSERT_HEAD(\u0026amp;ram_list.blocks, new_block, next); // 将该 RAMBlock 插入 ram_list 头部 ram_list.phys_dirty = g_realloc(ram_list.phys_dirty, // 重新分配 ram_list.phys_dirty 的内存空间 last_ram_offset() \u0026gt;\u0026gt; TARGET_PAGE_BITS); memset(ram_list.phys_dirty + (new_block-\u0026gt;offset \u0026gt;\u0026gt; TARGET_PAGE_BITS), 0, size \u0026gt;\u0026gt; TARGET_PAGE_BITS); cpu_physical_memory_set_dirty_range(new_block-\u0026gt;offset, size, 0xff); // 对该 RAMBlock 对应的内存标记为 dirty qemu_ram_setup_dump(new_block-\u0026gt;host, size); if (kvm_enabled()) kvm_setup_guest_memory(new_block-\u0026gt;host, size); return new_block-\u0026gt;offset; } 这样一来ram【其实就是system memory，整个Guest物理空间的大小】对应的 RAMBlock 中就分配好了 GPA 和 HVA，就可以将内存信息同步至 KVM 侧了。\n最后回到pc_memory_init()中，在分配完实际内存后，会先调用memory_region_init_alias()初始化ram_below_4g、ram_above_4g这两个alias，之后调用memory_region_add_subregion()将这两个 alias 指向ram这个实体 MemoryRegion。如下图，该函数最终会触发kvm_region_add()回调，将实际的内存信息传入 KVM 注册。该过程如下图所示，与之前分析的流程相同，此处不再赘述。\n\u003c!DOCTYPE html\u003e Responsive Image 总结 虚拟机的内存管理也是需要用户态的 qemu 和内核态的 KVM 共同完成。为了加速内存映射，需要借助硬件的 EPT 技术。\nQEMU 侧 创建一系列 MemoryRegion，分别表示 Guest 中的 RAM、ROM 等区域。MemoryRegion之间通过 alias 或 subregions 的方式维护相互之间的关系，从而进一步细化区域的定义\n对于一个实体 MemoryRegion（非 alias），在初始化内存的过程中 QEMU 会创建它所对应的 RAMBlock。该 RAMBlock 通过调用qemu_ram_alloc_from_ptr()从 QEMU 的进程地址空间中以 mmap 的方式分配内存，并负责维护该 MemoryRegion 对应内存的起始 GPA/HVA/size 等相关信息【在qemu_ram_alloc_from_ptr中创建的新RAMBlock有offset、host的赋值，即GPA-\u0026gt;HVA的对应关系】\nAddressSpace 表示 Guest 的物理地址空间。如果 AddressSpace 中的 MemoryRegion 发生变化，则注册的 listener 会被触发，将所属的 MemoryRegion 树展开生成一维的 FlatView，比较 FlatRange 是否发生了变化。如果是，则调用相应的方法对 MemoryRegionSection 进行检查，更新 QEMU 中的 KVMSlot，同时填充kvm_userspace_memory_region结构体，作为ioctl()的参数更新 KVM 中的kvm_memory_slot\nKVM 侧 当 QEMU 通过ioctl()创建 vcpu 时，调用kvm_mmu_create()初始化 MMU 相关信息。 当 KVM 要进入 Guest 前，vcpu_enter_guest()=\u0026gt;kvm_mmu_reload()会将根级页表地址加载到 VMCS，让 Guest 使用该页表\n当发生EPT Violation 时，VM-EXIT到 KVM 中。如果是缺页，则根据 GPA 算出 gfn，再根据 gfn 找到对应的 KVMSlot，从中得到对应的 HVA。然后根据 HVA 算出对应的 pfn，确保该 Page 位于内存中。填好缺失的页之后，需要更新 EPT，完善其中缺少的页表项，逐层补全页表\n\u003c!DOCTYPE html\u003e Responsive Image 虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即 mmap 分配的虚拟内存空间被访问的时候，先查看 EPT 页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。 如果没有映射过，则虚拟机会通过VM-Exit指令回到宿主机模式，通过 handle_ept_violation 补充页表映射。先是通过 handle_mm_fault为虚拟机的物理内存空间分配真正的物理页面，然后通过 __direct_map 添加 EPT 页表映射。 \u003c!DOCTYPE html\u003e Responsive Image Reference “QEMU 内存空间虚拟化及内存管理” - B10g | FΓom 许大仙 【原创】Linux 虚拟化 KVM-Qemu 分析（五）之内存虚拟化 - LoyenWang - 博客园 KVM/Qemu 工作原理系列目录_xiongwenwu 的专栏-CSDN 博客_qemu 目录结构 QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北\n","permalink":"https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/","summary":"\u003cblockquote\u003e\n\u003cp\u003e1.大部分转载自\u003ca href=\"https://abelsu7.top/2019/07/07/kvm-memory-virtualization/\"\u003eQEMU 内存虚拟化源码分析 | Keep Coding | 苏易北\u003c/a\u003e\n2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改\n3.部分内容根据自己理解补充添加\u003c/p\u003e","title":"QEMU 源码分析-内存虚拟化"},{"content":"保留现场 \u003c!DOCTYPE html\u003e Responsive Image 探究原因 本地记录的服务器信息和现有的产生了冲突\n解决方法 方法一 将known_hosts文件的内容全部删除。\nC:\\Users\\user name\\.ssh\\known_hosts\n方法二 搜遍全网几乎都是上述方法，应该绝大部分人通过上述方法都能解决。如果你也跟我一样不走运，不管是重新生成公私钥，还是删除hnow_hosts都不行，那么可以尝试修改 VSCode 使用的ssh.exe。Windows 下默认使用的是环境变量里配置的OpenSSH提供的ssh.exe。你可以将环境变量里的OpenSSH删除。然后在VSCode设置里搜索remote，也就是设置插件remote ssh。\n将 Path 强制设置成Git安装包内的ssh.exe\n\u003c!DOCTYPE html\u003e Responsive Image 或者mobaxterm安装包内的ssh.exe\n参考 Debug | VSCode | 过程试图写入的管道不存在 - CodeAntenna\nVScode 通过 remote ssh 连接虚拟机 \u0026amp; 报错 过程试图写入的管道不存在（已解决）_Tasdily 的博客-CSDN 博客_vscode 过程试图写入的管道不存在\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201192309069.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201192309069.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e本地记录的服务器信息和现有的产生了冲突\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003ch3 id=\"方法一\"\u003e方法一\u003c/h3\u003e\n\u003cp\u003e将\u003ccode\u003eknown_hosts\u003c/code\u003e文件的内容全部删除。\u003c/p\u003e","title":"解决 VSCode 配置远程连接，过程试图写入的管道不存在"},{"content":"简介 FrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。\n\u003c!DOCTYPE html\u003e Responsive Image 帧缓冲主要结构 fb_info 该结构体记录当前帧缓冲设备的状态信息，如果系统中有多个帧缓冲设备，就需要两个fb_info结构，这个结构只在内核中可以看到，对用户空间不可见。\nfb_var_screeninfo 该结构体记录指定的帧缓冲设备和显示模式中可以被修改的信息，其中包括显示器分辨率等信息。\nfb_fix_screeninfo 该结构体表示帧缓冲设备中一些不能修改的参数，包括特定的显示模式，屏幕缓冲区的物理地址，显示缓冲区的长度信息。\nfb_ops LCD底层硬件操作接口集。比如fb_open、fb_release、fb_read、fb_write、fb_ioctl、fb_mmap等：\nfb_cmap fb_cmap指定颜色映射，用于以内核可以理解的方式存储用户的颜色定义。\n\u003c!DOCTYPE html\u003e Responsive Image 帧缓冲显示原理 帧缓冲设备是一种显示抽象的设备，也可以被理解为它是一个内存区域，上面的应用程序可以直接对显示缓冲区进行读和写操作，就像访问文件的通用接口一样，用户可以认为帧缓冲是一块内存，能读取数据的内存块也可以向这个内存写入数据，因此显示器显示图形界面实际上根据根据的是指定的内存数据块内的数据。\n帧缓冲的显示缓冲区位于 Linux 内核地址空间，应用程序不能直接访问内核地址空间，在 Linux 中，只有一个内存的内核地址空间映射到用户地址空间才可以由用户访问，内存的映射是通过MMAP函数实现的在 Linux 中。对于帧缓冲，虚拟地址是通过内存映射的方法将显示缓冲区内核地址映射到用户空间的，然后用户可以通过读和写这部分的虚拟地址来访问显示缓冲区，在屏幕上绘图。\n使用流程 使用帧缓冲之前应该首先确定 Linux 系统上已安装了帧缓冲驱动，可以在目录/dev/下查找fb*如，/dev/fb0, /dev/fb1等设备来确定是否安装。如果没有需要安装一个帧缓冲驱动的模块到内核，或者重新编译内核生成一个带帧缓冲模块的镜像。\n使用帧缓冲需要进入控制台模式，即纯命令行的模式进行编程。一般可以通过快捷键CTRL+ALT+F1进入控制台模式，CTRL+ALT+F7切回图形窗口。如果控制台模式没有登录，可以CTRL+ALT+F6尝试登录。\n因硬件显示设备的物理显示区是通过帧缓存区操作，而帧缓存区是处于内核空间，应用程序不能随意操作，此时可以通过系统调用mmap把帧缓存映射到用户空间，在用户空间中创建出帧缓存映射区（用户图像数据缓存区），以后只需把用户图像数据写入到帧缓存映射区就可在硬件设备上显示图像。\n具体实现流程如下：\n打开帧缓冲设备/dev/f0 在Linux的/dev目录的寻找b*设备文件然后使用读写模式打开它，Linux 系统将使用通用的open系统调用来完成功能， open的功能原型如下：\nint open(const char *path, int oflags); Path是准备打开的文件或设备的路径参数； oflags指定打开文件时使用的参数； flags参数的指定，是通过组合文件访问模式和其他的可选模式一起的，可以支持多个模式或，参数必须是指定下列文件的访问模式。 只读：O_RDONLLY 只写：O_WRONLY 读写：O_RDWR 简而言之， open函数建立设备文件的访问路径。如果操作成功，它返回一个文件描述符，只是一个文件描述符，它将不使用其他任何正在运行的进程共享。如果两个程序同时打开相同的文件，将得到两个不同的文件描述符。如果他们执行文件写入操作，他们将操作每个文件描述符，不会发生冲突，写完之后退出。他们的数据不会互相交织在一起的，但会互相的彼此覆盖 (后写完的内容覆盖前面写的内容)，两个程序来读取和写入的文件位置看似一样但是有各自不同拷贝所以不会发生交织。如果open调用未能返回1，则将全局变量errno设置为指示失败的原因。\n通过系统调用ioctl函数获得帧设备相关信息 通过顿缓冲文件描述符，屏幕的分辨率、颜色深度等信息可以被获得，帧缓冲驱动中存放了这些对应的信息，必须使用 Linux 系统调用ioctl首先将帧缓冲的文件描述符和fb_var_screeninfo 结构体对应起来。\n结构体fb_var_screeninfo包含以下三个重要数据结构：\n屏幕的 x 方向分辨率，像素作为单位。 屏幕的 Y 方向分辨率，像素作为单位。 屏幕的像素颜色深度，每个像素用多少比特数表示。 ioctl函数原型如下：\nextern int ioctl (int __fd, unsigned long int __request, ...) __THROW; ioctl调用实现访问设备驱动各种各样的配置信息功能，它提供了一个控制设备的行为和配置底层服务接口的驱动函数，各种设备驱动程序，例如套接字和系统终端，还有磁带机都有ioctl命令可以支持。\n__fd：ioctl命令中是该帧缓冲的文件描述符； __request：ioctl函数将要执行的命令，实现参数给定的对象描述符中指定的函数操作，各种设备支持的功能是有差异的 FBIOGET_VSCREENINFO命令字返回与Framebuffer有关的固定的信息； FBIOGET_VSCREENINFO命令字返回与 Framebuffer 有关的可变的信息； 第三个参数是一个指针用来指向结构体fb_var_screeninfo。 最后使用者可以通过结构体fb_var_screeninfo来获得屏幕的分辨率和颜色位深和其他重要的屏幕信息。根据这些信息可以计算屏幕缓冲区的大小：屏幕缓冲区大小 (以字节为单位) = 屏幕宽度x高度x屏幕颜色深度/8\n帧缓冲映射 在进行帧缓冲的MMAP映射之前，要先得到帧缓冲文件描述符，才能像屏幕上面显示，必须首先将缓冲区的内核地址映射映射到用户地址空间。Linux 系统将使用MMAP系统调用完成功能，MMAP函数原型如下：\nextern void *mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off_t __offset) __THROW; __addr：返回一个指向mmap函数的内存区域的指针，与内容相关的文件指针，通过指针可以访问帧缓冲区的内存区域。\n__len：可以请求使用特定内存地址，通过设置地址参数，如果值为0，将自动分配指针，这是推荐的做法，否则会降低程序的可移植性，因为不同的系统可用的地址范围是不一样的。\n__prot：设置内存访问的权限设定，通过端口相关的参数定义，位的定义值如下：\nPORT_EXEC:允许内存段的执行。 PORT_NONE:无法访问内存段。 PORT_READ:允许读取内存段。 PORT_WRITE:允许编写内存段。 __flags：改变控制参数标志，能够影响该内存段的作用域，如下所示：\nMAP_FIXED:内存段必须位于addr中指定的地址。 MAP_SHARED:内存的修改保存到一个文件中。 MAP_PRIVATE:内存段是私人的，变化仅在本地范围内有效。 __fd：是通过一个open调用得到的访问文件的描述符。\noffset：用于指定访问数据的开始偏移量在内存段中，和访问普通文件使用方式是相同的，再指定文件描述符参数，以及访问的数据长度参数即可。\n读写帧缓冲 MMAP返回的指针，可以访问到帧缓冲内存区，可以定位到屏幕缓冲区具体为每个显示像素的位置，通过读函数调用读取对应的位置数据在帧缓冲内存中，相反写操作对应于内存的写入数据可以显示内容写到屏幕上。\n解除帧缓冲映射 在绘图完成后，帧缓冲文件描述符必须被释放之前，解除帧缓冲区的地址映射，使用 Linux 系统调用完成mmap函数的逆函数实现，即是munmap，函数的原型如下：\nextern int munmap (void *__addr, size_t __len) __THROW; addr参数应该与调用MMAP时指定的参数值一致， len参数也应该与之前调用MMAP时指定的len参数保持一致。\nmmap调用返回0成功，失败则返回1，同时将全局变量erno设置为指示失败的原因。\n调用close关闭设备 使用帧缓冲设备后，应关闭相应的文件描述符，使用 Linux 系统标准的函数完成关闭功能，close函数的原型如下：\nextern int close (int __fd); close的参数和在开始调用open时指定的参数一致，文件描述符释放后可以重用，结束调用成功返回0，失败返回1。\n帧缓冲实例 以下代码摘自xianjimli/linux-framebuffer-tools: linux framebuffer tool，演示了帧缓冲设备的使用流程。\nfb_info_t *linux_fb_open(const char *filename) { uint32_t size = 0; fb_info_t *fb = NULL; struct fb_fix_screeninfo fix; struct fb_var_screeninfo var; return_value_if_fail(filename != NULL, NULL); fb = (fb_info_t *)calloc(1, sizeof(fb_info_t)); return_value_if_fail(fb != NULL, NULL); // 打开帧缓冲设备，O_RDWR 读写模式 fb-\u0026gt;fd = open(filename, O_RDWR); if (fb-\u0026gt;fd \u0026lt; 0) { log_debug(\u0026#34;open %s failed(%d)\\n\u0026#34;, filename, errno); free(fb); return NULL; } // 通过系统调用 ioctl 函数获得帧设备相关信息 // FBIOGET_FSCREENINFO 命令字返回与 Framebuffer 有关的固定的信息 if (ioctl(fb-\u0026gt;fd, FBIOGET_FSCREENINFO, \u0026amp;fix) \u0026lt; 0) goto fail; //命令字返回与 Framebuffer 有关的可变的信息 if (ioctl(fb-\u0026gt;fd, FBIOGET_VSCREENINFO, \u0026amp;var) \u0026lt; 0) goto fail; var.xoffset = 0; var.yoffset = 0; // 显示 ioctl(fb-\u0026gt;fd, FBIOPAN_DISPLAY, \u0026amp;(var)); log_debug(\u0026#34;fb_info_t: %s\\n\u0026#34;, filename); log_debug(\u0026#34;fb_info_t: xres=%d yres=%d bits_per_pixel=%d mem_size=%d\\n\u0026#34;, var.xres, var.yres, var.bits_per_pixel, fb_size(fb)); log_debug(\u0026#34;fb_info_t: red(%d %d) green(%d %d) blue(%d %d)\\n\u0026#34;, var.red.offset, var.red.length, var.green.offset, var.green.length, var.blue.offset, var.blue.length); fb-\u0026gt;w = var.xres; fb-\u0026gt;h = var.yres; fb-\u0026gt;bpp = var.bits_per_pixel / 8; fb-\u0026gt;line_length = fix.line_length; size = fb_size(fb); // 帧缓冲映射 // PROT_READ | PROT_WRITE:可读写 // MAP_SHARED：内存的修改保存到一个文件 fb-\u0026gt;data = (uint8_t *)mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fb-\u0026gt;fd, 0); if (fb-\u0026gt;data == MAP_FAILED) { log_debug(\u0026#34;map framebuffer failed.\\n\u0026#34;); goto fail; } log_debug(\u0026#34;line_length=%d mem_size=%d\\n\u0026#34;, fix.line_length, fb_size(fb)); log_debug(\u0026#34;xres_virtual =%d yres_virtual=%d xpanstep=%d ywrapstep=%d\\n\u0026#34;, var.xres_virtual, var.yres_virtual, fix.xpanstep, fix.ywrapstep); return fb; fail: log_debug(\u0026#34;%s is not a framebuffer.\\n\u0026#34;, filename); close(fb-\u0026gt;fd); free(fb); return NULL; } 感兴趣可以下载源码编译运行，其中/bin/fbshow可以使用帧缓冲设备显示图片。图形界面下直接运行可能提示无法运行，需要Chrtl+Alt+F1切换到控制台模式。\n\u003c!DOCTYPE html\u003e Responsive Image LCD 与 Framebuffer 的关系 \u003c!DOCTYPE html\u003e Responsive Image LCD 控制器首先通过 VDEN 信号，使能。接下来根据 VCLK 时钟信号，在像素点上“喷涂”不同的颜色（打个比方），控制器有 VD（video data）信号，传送不同颜色信息。每来一个时钟信号，就向右移动一个像素，根据行同步信号 HSYNC，就从最右边移动到最左边。当移动到右下角时根据垂直同步信号 VSYNC。\n那么问题来了，不同颜色的信息从哪里来？就是从上文介绍的 Framebuffer 中来的。\n很多人都会说操纵 LCD 显示就是操纵 FrameBuffer，表面上来看是这样的。实际上是 FrameBuffer 就是 Linux 内核驱动申请的一片内存空间，然后 LCD 内有一片 sram，CPU 内部有个 LCD 控制器，它有个单独的 dma 用来将 FrameBuffer 中的数据拷贝到 LCD 的 sram 中去 拷贝到 LCD 的 sram 中的数据就会显示在 LCD 上，LCD 驱动和 FrameBuffer 驱动没有必然的联系，它只是驱动 LCD 正常工作的，比如有信号传过来，那么 LCD 驱动负责把信号转成显示屏上的内容，至于什么内容这就是应用层要处理的。\n静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。 DMA（Direct Memory Access），直接内存访问。使用 DMA 的好处就是它不需要 CPU 的干预而直接服务外设，这样 CPU 就可以去处理别的事务，从而提高系统的效率。\nReference Linux 驱动之 Framebuffer 子系统 | 量子范式 Linux 驱动开发（9）——- framebuffer 驱动详解 | 码农家园 嵌入式系统中帧缓冲显示模块的设计与实现 - 中国知网 research/framebuffer/fivechess/fivechess-0.1 at master · tsuibin/research 五子棋 framebuffer 版 - 尚码园 FrameBuffer 驱动程序分析_深入剖析 Android 系统-CSDN 博客_framebuffer xianjimli/linux-framebuffer-tools: linux framebuffer tool 韦东山_嵌入式 Linux_第 2 期_Linux 高级驱动视频教程_免费试看版_哔哩哔哩_bilibili Linux LCD Frambuffer 基础介绍和使用（1） - 知乎\n","permalink":"https://lifeislife.cn/posts/linux%E5%B8%A7%E7%BC%93%E5%86%B2/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003eFrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。\u003c/p\u003e","title":"Linux 帧缓冲"},{"content":"保留现场 linux\u0026gt; ssh -p 2221 xxx@gerrit.com xxx@gerrit.com: Permission denied(publickey) 探究原因 本次出错是在测试是否能连接 gerrit 时。连接 GitHub 也可能会出现。只要用到 ssh 功能的都有可能。\n出错的原因：\n网页（如 gerrit,github）没有设置公钥，一般为id_rsa.pub内容； 本地生成了多个公私钥，配对配错了； 本地没有配置好git，比如git config时用户名或者邮箱填错； 需要开启 ssh 代理； 解决方法 生成密钥cd ~/.ssh \u0026amp;\u0026amp; ssh-keygen 复制公钥内容，添加到网页中github或者gerrit的设置里。cat id_rsa.pub | xclip 配置git账户 git config --global user.name \u0026quot;bob\u0026quot; git config --global user.email bob@... 以上检查无误，仍然报错\n开启ssh代理 eval $(ssh-agent -s) 将私钥加入代理 ssh-add ~/.ssh/id_rsa 登陆用户时启动 ssh-agent 如果不幸你的问题就是需要开启ssh-agent，那么每次重启电脑都需要开启一次。这也是相当麻烦的，可以通过将以下配置添加到~/.bashrc中，让 Linux 启动时自动开启ssh-agent。\n# Add following code at the end of ~/.bashrc # Check if ~/.pid_ssh_agent exists. if [ -f ~/.pid_ssh_agent ]; then source ~/.pid_ssh_agent # Check process of ssh-agent still exists. TEST=$(ssh-add -l) if [ -z \u0026#34;$TEST\u0026#34; ]; then # Reinit if not. NEED_INIT=1 fi else NEED_INIT=1 # PID file doesm\u0026#39;t exist, reinit it. fi # Try start ssh-agent. if [ ! -z \u0026#34;$NEED_INIT\u0026#34; ]; then echo $(ssh-agent -s) | sed -e \u0026#39;s/echo[ A-Za-z0-9]*;//g\u0026#39; \u0026gt; ~/.pid_ssh_agent # save the PID to file. source ~/.pid_ssh_agent fi 参考 ssh - Git: How to solve Permission denied (publickey) error when using Git? - Stack Overflow\nLinux 登陆用户时启动 ssh-agent 并复用 - Fenying\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3git-ssh-permission-deniedpublickey/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003elinux\u0026gt; ssh -p \u003cspan class=\"m\"\u003e2221\u003c/span\u003e xxx@gerrit.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003exxx@gerrit.com: Permission denied\u003cspan class=\"o\"\u003e(\u003c/span\u003epublickey\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e本次出错是在测试是否能连接 gerrit 时。连接 GitHub 也可能会出现。只要用到 ssh 功能的都有可能。\u003c/p\u003e\n\u003cp\u003e出错的原因：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e网页（如 gerrit,github）没有设置公钥，一般为\u003ccode\u003eid_rsa.pub\u003c/code\u003e内容；\u003c/li\u003e\n\u003cli\u003e本地生成了多个公私钥，配对配错了；\u003c/li\u003e\n\u003cli\u003e本地没有配置好\u003ccode\u003egit\u003c/code\u003e，比如\u003ccode\u003egit config\u003c/code\u003e时用户名或者邮箱填错；\u003c/li\u003e\n\u003cli\u003e需要开启 ssh 代理；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e生成密钥\u003ccode\u003ecd ~/.ssh \u0026amp;\u0026amp; ssh-keygen\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e复制公钥内容，添加到网页中\u003ccode\u003egithub\u003c/code\u003e或者\u003ccode\u003egerrit\u003c/code\u003e的设置里。\u003ccode\u003ecat id_rsa.pub | xclip\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e配置\u003ccode\u003egit\u003c/code\u003e账户\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egit config --global user.name \u0026quot;bob\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit config --global user.email bob@...\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e以上检查无误，仍然报错\u003c/p\u003e","title":"解决 ssh permission denied(publickey)"},{"content":"安装 Node.js 过程 进入该网站下载 | Node.js 也可以进入该网站下载历史版本，Previous Releases | Node.js\n进入 download 目录，\ncd download wget https://nodejs.org/dist/v10.16.3/node-v10.16.3-linux-x64.tar.xz -O nodejs.tar.xz 解压\ntar -xvf node-v10.16.3-linux-x64.tar.xz 改名 Node.js\nmv node-v10.16.3-linux-x64 nodejs 将 npm，node 两个程序建立软连接，能够全局可用\nln -s /download/nodejs/bin/npm /usr/local/bin/ ln -s /download/nodejs/bin/node /usr/local/bin/ 检查是否安装\nnode -v npm -v 安装 hexo 过程 npm i hexo-cli -g hexo -v 如果出现命令未找到到错误，说明 hexo 还未加入全局变量。 将下面命令加入\nvim ~/.bashrc export PATH=/usr/local/nodejs/lib/node_modules/hexo-cli/bin/:$PATH Reference Previous Releases | Node.js Linux 安装 Node.js | F2E 前端技术论坛 Linux 下安装 node 及 npm - SegmentFault 思否 超详细 Hexo+Github 博客搭建小白教程 - 知乎\n","permalink":"https://lifeislife.cn/posts/linux%E5%AE%89%E8%A3%85nodejs/","summary":"\u003ch2 id=\"安装-nodejs-过程\"\u003e安装 Node.js 过程\u003c/h2\u003e\n\u003cp\u003e进入该网站\u003ca href=\"https://nodejs.org/zh-cn/download/\"\u003e下载 | Node.js\u003c/a\u003e\n也可以进入该网站下载历史版本，\u003ca href=\"https://nodejs.org/en/download/releases/\"\u003ePrevious Releases | Node.js\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e进入 download 目录，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-gdscript3\" data-lang=\"gdscript3\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecd\u003c/span\u003e \u003cspan class=\"n\"\u003edownload\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ewget\u003c/span\u003e \u003cspan class=\"n\"\u003ehttps\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"o\"\u003e//\u003c/span\u003e\u003cspan class=\"n\"\u003enodejs\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eorg\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003edist\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ev10\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"mf\"\u003e16.3\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003ev10\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"mf\"\u003e16.3\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003elinux\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003ex64\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etar\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003exz\u003c/span\u003e  \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eO\u003c/span\u003e \u003cspan class=\"n\"\u003enodejs\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etar\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003exz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e解压\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar -xvf node-v10.16.3-linux-x64.tar.xz\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e改名 Node.js\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emv node-v10.16.3-linux-x64 nodejs\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e将 npm，node 两个程序建立软连接，能够全局可用\u003c/p\u003e","title":"Linux 安装 Node.js 以及 hexo"},{"content":"简介 __attribute__ 其实是个编译器指令，告诉编译器声明的特性，或者让编译器进行更多的错误检查和高级优化。\n__attribute__ 可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。每一类都包含数十种属性，本文不会逐一解释，只抛砖引玉，完整属性可以查看链接中的官方文档。\n一个属性说明符的形式是__attribute__ ((attribute-list))。一个属性列表是一个可能为空的逗号分隔的属性序列，其中每个属性都是以下的一个。\n属性为空。空属性会被忽略。 一个单词（可能是未使用的标识符，也可能是 const 等保留字）。 一个单词，后面跟着括号中的属性参数。这些参数采用以下形式之一： 一个标识符。例如，mode属性使用这种形式。 一个标识符，后跟一个逗号和一个以逗号分隔的非空表达式列表。例如，format属性使用这种形式。 一个可能是空的逗号分隔的表达式列表。例如，format_arg属性使用这种形式，该列表是一个单一的整数常量表达式，而alias属性也使用这种形式，该列表是一个单一的字符串常量。 使用方法 函数属性 alias 该属性可以设置函数的别名。\nvoid __f() { printf(\u0026#34;__attribute__ test\\n\u0026#34;); }; void f() __attribute__((weak, alias(\u0026#34;__f\u0026#34;))); int main() { f(); return 0; } /*--- 输出 ---*/ //__attribute__ test 函数f()的别名为__f()，调用f()即调用__f()。\nalloc_size alloc_size属性用来告诉编译器，函数的返回值指向内存，其中的大小由一个或两个函数参数给出。GCC 使用这些信息来提高__builtin_object_size的正确性。\nalloc_size后面可以跟一到二个参数，alloc_size 后面跟的参数是指定使用函数的第几个参数。\n函数的参数的个数只有一个，那么 alloc_size 的参数只能是 1。通过__builtin_object_size 获取的值 就是传入的参数值。如图，我们给函数my_malloc 传入的值是100 ，那么我们通过__builtin_object_size 获取的值就是100。\n函数的参数的个数多余两个，那么alloc_size 的最多可以指定两个参数。传入两个参数，__builtin_object_size的值是这两个参数的乘积。传入一个参数，__builtin_object_size的值就是这个参数的值。如图，my_callocd函数指定的参数是alloc_size(2,3)，通过__builtin_object_size获取的值就是my_callocd传入的第二和三个参数的乘积（2*3=6）。\nvoid *my_calloc(int a) __attribute__((alloc_size(1))); void *my_realloc(int a, int b, int c) __attribute__((alloc_size(2, 3))); void *my_calloc(int a) { return NULL; } void *my_realloc(int a, int b, int c) { return NULL; } int main() { void *const p = my_calloc(100); printf(\u0026#34;size : %ld\\n\u0026#34;, __builtin_object_size(p, 0)); void *const a = my_realloc(1, 2, 3); printf(\u0026#34;size : %ld\\n\u0026#34;, __builtin_object_size(a, 1)); return 0; } /*--- 输出 ---*/ //100 //6 constructor (priority) / destructor (priority) constructor属性使该函数在执行进入main()之前被自动调用。同样地，destructor属性使函数在main()完成后或exit()被调用后被自动调用。具有这些属性的函数对于初始化将在程序执行过程中隐含使用的数据非常有用。\nconstructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。\n若有多个 constructor 且想控制优先级的话，可以写成 attribute((constructor(101)))，里面的数字越小优先级越高，1 ~ 100 为系统保留。\n变量属性 cleanup 该属性在变量作用域结束时，调用指定的一个函数。这个属性只能应用于自动函数范围的变量；它不能应用于参数或具有静态存储期限的变量。该函数必须接受一个参数，一个指向与变量兼容的类型的指针。函数的返回值（如果有的话）被忽略。\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void test_cleanup(char **str) { printf(\u0026#34;after cleanup: %s\\n\u0026#34;, *str); free(*str); } int main(int argc, char **argv) { char *str __attribute__((__cleanup__(test_cleanup))) = NULL; str = (char *)malloc((sizeof(char)) * 100); strcpy(str, \u0026#34;test\u0026#34;); printf(\u0026#34;before cleanup : %s\\n\u0026#34;, str); return 0; } /*--- 输出 ---*/ //before cleanup : test //after cleanup: test 作用域结束包括大括号结束、return、goto、break、exception等各种情况。在上面的实验中，main函数返回标志变量str作用域结束，所以最后才打印after cleanup: test。\n类型属性 aligned (alignment) 这个属性指定了函数的最小对齐方式，以字节为单位。对齐的大小只能增加，不能减小。\n#include \u0026lt;stdio.h\u0026gt; struct stu { char sex; int length; char name[2]; char value[15]; } __attribute__((aligned(1))); struct stu my_stu; int main() { printf(\u0026#34;%d \\n\u0026#34;, sizeof(my_stu)); printf(\u0026#34;%p %p,%p,%p \\n\u0026#34;, \u0026amp;my_stu, \u0026amp;my_stu.length, \u0026amp;my_stu.name, \u0026amp;my_stu.value); return 0; } /*--- __attribute__((aligned(1)));输出 ---*/ //28 //0x55af2ba25020 0x55af2ba25024,0x55af2ba25028,0x55af2ba2502a /*--- __attribute__((aligned(4)));输出 ---*/ //28 //0x556fbce54020 0x556fbce54024,0x556fbce54028,0x556fbce5402a /*--- __attribute__((aligned(8)));输出 ---*/ //32 //0x5646e130e040 0x5646e130e044,0x5646e130e048,0x5646e130e04a 由以上代码实验结果发现，默认对齐代下为 4 字节，小于这个值就被忽略，大于 4 字节才生效。\nRefernece attribute 机制使用 - 简书 C 语言复杂声明解析_wangweixaut061 的专栏-CSDN 博客_c 语言复杂声明 attribute 你知多少？\n","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80-attribute-%E4%BD%BF%E7%94%A8/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e__attribute__\u003c/code\u003e 其实是个编译器指令，告诉编译器声明的特性，或者让编译器进行更多的错误检查和高级优化。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__attribute__\u003c/code\u003e 可以设置\u003ca href=\"https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Function-Attributes.html#Function-Attributes\"\u003e函数属性（Function Attribute）\u003c/a\u003e、\u003ca href=\"https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Variable-Attributes.html#Variable-Attributes\"\u003e变量属性（Variable Attribute）\u003c/a\u003e和\u003ca href=\"https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Type-Attributes.html#Type-Attributes\"\u003e类型属性（Type Attribute）\u003c/a\u003e。每一类都包含数十种属性，本文不会逐一解释，只抛砖引玉，完整属性可以查看链接中的官方文档。\u003c/p\u003e","title":"C 语言__attribute__使用"},{"content":"简介 typedef为 C 语言的关键字，作用是为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char 等）和自定义的数据类型（struct 等）。在使用语法上类似与static，extern等。 typedef 行为有点像 #define 宏，用其实际类型替代同义字。不同点是 typedef在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。\n基本使用方法 示例 1：\nint a; ———— 传统变量声明表达式 int myint_t; ———— 使用新的类型名myint_t替换变量名a typedef int myint_t; ———— 在语句开头加上typedef关键字，myint_t就是我们定义的新类型 示例 2：\nvoid (*pfunA)(int a); ———— 传统变量（函数）声明表达式 void (*PFUNA)(int a); ———— 使用新的类型名PFUNA替换变量名pfunA typedef void (*PFUNA)(int a); ———— 在语句开头加上typedef关键字，PFUNA就是我们定义的新类型 促使我写这篇文章的原因不是如何去用typedef，而是在代码中看不懂如何简化了一个复杂声明。比如上文的\ntypedef void (*PFUNA)(int a); 本以为是将void类型替换成了(*PFUNA)(int a)，但是语法上这明显讲不通啊。现在明白了，这就是将void (*pfunA)(int a);类型名换成了PFUNA。以后就可以用PFUNA来声明变量。比如\nPFUNA arr[10] 表示声明了一个大小为10的数组，数组的元素是PFUNA类型。将PFUNA类型展开就是，这是一个函数指针，函数参数为int类型，返回值为void类型。完整的含义就是，声明了一个大小为10的数组，数组元素是函数指针，函数参数为int类型，返回值为void类型。\n代码简化 typedef可以为复杂的声明定义一个新的简单的别名。关于复杂声明，可以阅读这篇C 语言复杂声明。 方法是：在原来的声明里逐步用别名替换一部分复杂声明，递归操作，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：\n//复杂声明 void (*b[10]) (void (*)()); 变量名为b，先替换右边部分括号里的，pFunParam为别名\ntypedef void (*pFunParam)(); 再替换左边的变量b，pFunx为别名二：\ntypedef void (*pFunx)(pFunParam); 简化后的声明：\npFunx b[10]; 减少错误 定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如：\n// 这多数不符合我们的意图，它只声明了一个指向字符变量的指针， // 和一个字符变量； char* pa, pb; 以下则可行：\ntypedef char* PCHAR; PCHAR pa, pb; 这种用法很有用，特别是char* pa, pb的定义，初学者往往认为是定义了两个字符型指针，其实不是，而用typedef char* PCHAR就不会出现这样的问题，减少了错误的发生。\n直观简洁 声明struct新对象时，必须要带上struct\nstruct tagPOINT1 { int x; int y; }; struct tagPOINT1 p1; 在经常使用这个结构体时，就显得麻烦，可以用typedef简化\ntypedef struct tagPOINT { int x; int y; }POINT; 定义平台无关的类型 当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。\ntypedef unsigned int u_32t; 掩饰复合类型 typedef 还可以掩饰复合类型，如指针和数组。\n例如，你不用像下面这样重复定义有 81 个字符元素的数组：\nchar line[81]; 定义一个 typedef，每当要用到相同类型和大小的数组时，可以这样：\ntypedef char Line[81]; 此时 Line 类型即代表了具有 81 个元素的字符数组，使用方法如下：\nLine text, secondline; 同样，可以象下面这样隐藏指针语法：\ntypedef char * pstr; 这里将带我们到达第一个 typedef 陷阱。标准函数 strcmp()有两个const char *类型的参数。因此，它可能会误导人们象下面这样声明 mystrcmp()：\nint mystrcmp(const pstr, const pstr); 用 GNU 的 gcc 和 g++编译器，是会出现警告的，按照顺序，const pstr被解释为char* const（一个指向 char 的指针常量），两者表达的并非同一意思。为了得到正确的类型，应当如下声明：\ntypedef const char* pstr; typedef 和存储类关键字 typedef 就像 auto，extern，mutable，static，和 register 一样，是一个存储类关键字。这并不是说 typedef 会真正影响对象的存储特性；它只是说在语句构成上，typedef 声明看起来象 static，extern 等类型的变量声明。下面将带到第二个陷阱：\ntypedef register int FAST_COUNTER; // 错误 编译通不过。问题出在你不能在声明中有多个存储类关键字。因为符号 typedef 已经占据了存储类关键字的位置，在 typedef 声明中不能用 register（或任何其它存储类关键字）。\nReference typedef 介绍_liitdar 的博客-CSDN 博客_typedef\n关于 typedef 的用法总结_IT 民工-CSDN 博客_typedef\n","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80typedef%E7%94%A8%E6%B3%95/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003etypedef\u003c/code\u003e为 C 语言的关键字，作用是为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char 等）和自定义的数据类型（struct 等）。在使用语法上类似与\u003ccode\u003estatic\u003c/code\u003e，\u003ccode\u003eextern\u003c/code\u003e等。\n\u003ccode\u003etypedef\u003c/code\u003e 行为有点像 \u003ccode\u003e#define\u003c/code\u003e 宏，用其实际类型替代同义字。不同点是 \u003ccode\u003etypedef\u003c/code\u003e在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。\u003c/p\u003e","title":"C 语言 typedef 用法"},{"content":"折腾背景 一些常用的离线软件在重新安装，重装电脑或者更好环境时，调教好的配置总需要重新设置一遍，甚是麻烦。但是这些设置通常都保存在配置文件里，只要能备份好这些配置文件，下次重装后覆盖就可以恢复所需设置。\n现在的问题就是如何备份这些配置文件，可以选择各类网盘，硬盘等等。但是这些多少都有点炮打蚊子，小题大做。而且定时备份也不是很方便。既然配置文件都很小，其实就是个文本文件，那有个万能免费存储地 GitHub 就派上用场了。我们只要把配置文件定时 push 到 GitHub 即可，以后随时可以 clone 下来。\n首先建立一个私密仓库，用来专门存放配置文件。其次通过批处理命令，将配置文件复制到本地仓库的文件夹下。最后设置定时任务。\n折腾过程 新建仓库 这一步不用赘述了，主要就是要勾选私密仓库，保护隐私，一些配置文件可能会包含个人信息。\n批处理 将仓库克隆到本地后就是个文件夹，这一步主要就是如何能把安装在不同位置的软件的配置文件，都汇集到这个仓库下。通过批处理命令可以快速，方便的完成。\necho Start backup config files! # 打印这句话 copy D:\\Tools\\MouseInc\\MouseInc.json D:\\Develop\\fxxk-config\\mouseinc # 将前者复制到后者 copy D:\\Tools\\JD\\Config.ini D:\\Develop\\fxxk-config\\jd cd /d D:\\Develop\\fxxk-config # 切换目录 # git推送的一些命令 git add . git commit -m \u0026#34;update\u0026#34; git push # 防止窗口闪退 pause 一些常用命令参考WindowDos 批处理指导。\n定时任务 控制面板-管理工具 - 任务计划程序 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/windows%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","summary":"\u003ch2 id=\"折腾背景\"\u003e折腾背景\u003c/h2\u003e\n\u003cp\u003e一些常用的离线软件在重新安装，重装电脑或者更好环境时，调教好的配置总需要重新设置一遍，甚是麻烦。但是这些设置通常都保存在配置文件里，只要能备份好这些配置文件，下次重装后覆盖就可以恢复所需设置。\u003c/p\u003e","title":"Windows 批处理定时任务"},{"content":"保留现场 apt工具损坏了，在修复时使用了sudo apt-get install -f命令，中途会提示需要安装libpng12-0，但是始终无法安装，会提示如下错误。\nUnpacking libpng12-0:amd64 (1.2.50-2+deb8u3) ... dpkg: error processing archive libpng12-0_1.2.50-2+deb8u3_amd64.deb (--install): unable to install new version of \u0026#39;/usr/lib/ x86_64-linux-gnu/libpng12.so.0\u0026#39;: No such file or directory Errors were encountered while processing: libpng12-0_1.2.50-2 +deb8u3_amd64.deb 探究原因 具体原因未知，网上答案众说纷纭。\n解决方法 这个问题遇到的人还挺多的，解决方法也各不相同，我先说我自己最终解决的方法。\n方法一 将软件源更换成中科院的源，使用 Linux 自带的软件和更新工具，具体方法参考这篇文章。更换完之后可以重新尝试安装，有人换源后即可成功安装。\n如果未能安装成功，可能曾经手动添加过软件源，将其删除。\n# 将所有内容注释 vim /etc/apt/sources.list 方法二 下载已安装的库文件libpng12.so.0，可以从该链接下载。\n将该文件复制到它本该安装的位置。\nsudo cp libpng12.so.0 /usr/lib/x86_64-linux-gnu/ 方法三 sudo add-apt-repository ppa:linuxuprising/libpng12 sudo apt update sudo apt install libpng12-0 ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3unable-to-install-libpng12-so-0/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eapt\u003c/code\u003e工具损坏了，在修复时使用了\u003ccode\u003esudo apt-get install -f\u003c/code\u003e命令，中途会提示需要安装\u003ccode\u003elibpng12-0\u003c/code\u003e，但是始终无法安装，会提示如下错误。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eUnpacking libpng12-0:amd64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e1.2.50-2+deb8u3\u003cspan class=\"o\"\u003e)\u003c/span\u003e ... dpkg: error \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eprocessing archive libpng12-0_1.2.50-2+deb8u3_amd64.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e--install\u003cspan class=\"o\"\u003e)\u003c/span\u003e: unable to install new version of \u003cspan class=\"s1\"\u003e\u0026#39;/usr/lib/\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003ex86_64-linux-gnu/libpng12.so.0\u0026#39;\u003c/span\u003e: No such file or directory \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eErrors were encountered \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e processing: libpng12-0_1.2.50-2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e+deb8u3_amd64.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e具体原因未知，网上答案众说纷纭。\u003c/p\u003e","title":"解决 unable to install libpng12.so.0"},{"content":"Trap 简介 控制流（Control Flow）和 Trap 控制流（Control Flow） 从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列 $$a_0,a_1,\\dotsb,a_{n-1}$$ 每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。 异常控制流（Exceptional Control Flow, ECF） 系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。 exception interrupt RISC-V 把 ECF 统称为 Trap。\nRISC-V Trap 处理中涉及的寄存器 寄存器 全称 用途说明 mtvec Machine Trap-Vector Base-Address 它保存发生异常时处理器需要跳转到的地址。 mepc Machine Exception Program Counter 当 trap 发生时，hart 会将发生 trap 所对应的指令的地址值（pc）保存在 mepc 中。 mcause Machine Cause 当 trap 发生时，hart 会设置该寄存器通知我们 trap 发生的原因。 mtval Machine Trap Value 它保存了 exception 发生时的附加信息：譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身，对于其他异常，它的值为 0。 mstatus Machine Status 用于跟踪和控制 hart 的当前操作状态（特别地，包括关闭和打开全局中断）。 mscratch Machine Scratch Machine 模式下专用寄存器，我们可以自己定义其用法，譬如用该寄存器保存当前在 hart 上运行的 task 的上下文（context）的地址。 mtvec（Machine Trap-Vector Base-Address） \u003c!DOCTYPE html\u003e Responsive Image WARL: Write Any Values, Read Legal Values\nBASE：trap 入口函数的基地址，必须保证四字节对齐；\nMODE：进一步用于控制入口函数的地址配置方式：\nDirect，所有异常和中断发生后，PC都跳转到BASE指定的地址处；\n\u003c!DOCTYPE html\u003e Responsive Image 通常中断处理函数内部会有switch case条件语句，通过不同的中断采用不同的处理方式。\nreg_t trap_handler(reg_t epc, reg_t cause) { reg_t return_pc = epc; reg_t cause_code = cause \u0026amp; 0xfff; if (cause \u0026amp; 0x80000000) { /* Asynchronous trap - interrupt */ switch (cause_code) { case 3: uart_puts(\u0026#34;software interruption!\\n\u0026#34;); break; case 7: uart_puts(\u0026#34;timer interruption!\\n\u0026#34;); break; case 11: uart_puts(\u0026#34;external interruption!\\n\u0026#34;); break; default: uart_puts(\u0026#34;unknown async exception!\\n\u0026#34;); break; } } else { /* Synchronous trap - exception */ printf(\u0026#34;Sync exceptions!, code = %d\\n\u0026#34;, cause_code); panic(\u0026#34;OOPS! What can I do!\u0026#34;); //return_pc += 4; } return return_pc; } Vectored，异常的处理方式同上，但是中断的入口地址以数组方式排列；\ntrap_vector: # save context(registers). csrrw t6, mscratch, t6 # swap t6 and mscratch reg_save t6 # Save the actual t6 register, which we swapped into # mscratch mv t5, t6 # t5 points to the context of current task csrr t6, mscratch # read t6 back from mscratch sw t6, 120(t5) # save t6 with t5 as base # Restore the context pointer into mscratch csrw mscratch, t5 # call the C trap handler in trap.c csrr a0, mepc csrr a1, mcause call trap_handler # trap_handler will return the return address via a0. csrw mepc, a0 # restore context(registers). csrr t6, mscratch reg_restore t6 # return to whatever we were doing before trap. mret MODE可取值如下：\n\u003c!DOCTYPE html\u003e Responsive Image 采用Vectored方式效率更高。\nmepc（Machine Exception Program Counter） \u003c!DOCTYPE html\u003e Responsive Image 当trap发生时，pc会被替换为 mtvec设定的地址，同时hart 会设置mepc为当前指令或者下一条指令的地址（处理异常时，mepc 为当前指令的地址，处理中断时，mepc 为下一条指令的地址）。\n当我们需要退出trap 时可以调用特殊的 mret 指令，该指令会将mepc中的值恢复到pc中（实现返回的效果）；\n在处理 trap 的程序中我们可以修改 mepc 的值达到改变mret 返回地址的目的。\nmcause（Machine Cause） \u003c!DOCTYPE html\u003e Responsive Image 当 trap 发生时，hart 会设置该寄存器通知我们 trap 发生的原因。\n最高位 Interrupt 为 1 时标识了当前 trap 为interrupt，否则是exception。\n剩余的 Exception Code 用于标识具体的interrupt或者exception 的种类。\n\u003c!DOCTYPE html\u003e Responsive Image mtval（Machine Trap Value） \u003c!DOCTYPE html\u003e Responsive Image 当 trap 发生时，除了通过mcause 可以获取exception的种类 code 值外，hart 还提供了 mtval 来提供exception 的其他信息来辅助我们执行更进一步的操作。\n具体的辅助信息由特定的硬件实现定义，RISC-V 规范没有定义具体的值。但规范定义了一些行为，譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身等。\nmstatus（Machine Status） \u003c!DOCTYPE html\u003e Responsive Image 寄存器各个位可以大致分为以下三类，其中x可以为U,S,M。表示用户模式以及两种特权模式。\nxIE（x=M/S/U）: 分别用于打开（1）或者关闭（0）M/S/U 模式下的全局中断。当 trap 发生时，hart会自动将 xIE 设置为 0。\nxPIE（x=M/S/U）:当 trap 发生时用于保存 trap 发生之前的 xIE 值。\nxPP（x=M/S）:当 trap 发生时用于保存 trap 发生之前的权限级别值。注意没有 UPP。因为异常只会从低权限向高权限跳转，通常低权限如user模式，会被置于上方，高权限如内核一般都会画在下方，这也解释了异常，中断处理为什么叫trap，因为是向下陷入的过程。\n其他标志位涉及内存访问权限、虚拟内存控制等，暂不考虑。\nTrap 处理流程 主要为 Exception，下一章详解 Interrupt。\n初始化 将trap的基地址写入寄存器，\n\u003c!DOCTYPE html\u003e Responsive Image Top Half 把 mstatus 的 MIE 值复制到 MPIE 中，清除 mstatus中的 MIE 标志位，效果是中断被禁止。 设置mepc，同时PC被设置为 mtvec。（需要注意的是，对于exception， mepc指向导致异常的指令；对于 interrupt，它指向被中断的指令的下一条指令的位置。） 根据 trap 的种类设置 mcause，并根据需要为mtval设置附加信息。 将 trap 发生之前的权限模式保存在 mstatus 的 MPP 域中，再把hart 权限模式更改为 M（也就是说无论在任何 Level 下触发trap，hart 首先切换到 Machine 模式）。 Bottom Half 保存（save）当前控制流的上下文信息（利用 mscratch）； 调用 C 语言的 trap handler; 从 trap handler 函数返回，mepc的值有可能需要调整； 恢复（restore）上下文的信息； 执行MRET指令返回到 trap之前的状态。 trap_vector: # save context(registers). csrrw t6, mscratch, t6 # swap t6 and mscratch reg_save t6 # Save the actual t6 register, which we swapped into # mscratch mv t5, t6 # t5 points to the context of current task csrr t6, mscratch # read t6 back from mscratch sw t6, 120(t5) # save t6 with t5 as base # Restore the context pointer into mscratch csrw mscratch, t5 # call the C trap handler in trap.c csrr a0, mepc csrr a1, mcause call trap_handler # trap_handler will return the return address via a0. csrw mepc, a0 # restore context(registers). csrr t6, mscratch reg_restore t6 # return to whatever we were doing before trap. mret 退出 trap：编程调用 MRET 指令 针对不同权限级别下如何退出 trap 有各自的返回指令xRET（x = M/S/U）。以在 M 模式下执行mret 指令为例，会执行如下操作：\n当前 Hart 的权限级别 = mstatus.MPP；mstatus.MPP = U（如果 hart 不支持 U 则为 M） mstatus.MIE = mstatus.MPIE; mstatus.MPIE = 1 pc = mepc 中断 中断分类 本地（Local）中断\n软中断software interrupt 定时器中断 timer interrupt 全局（Global）中断\n外部中断 externel interrupt RISC-V 中断编程中涉及的寄存器 寄存器 全称 用途说明 mie Machine Interrupt Enable 用于进一步控制（打开和关闭）software interrupt/timer interrupt/external interrupt mip Machine Interrupt Pending 它列出目前已发生等待处理的中断。 mie(Machine Interrupt Enable) \u003c!DOCTYPE html\u003e Responsive Image 打开（1）或者关闭（0）M/S/U 模式下对应的 External/Timer/Software 中断。\nmip(Machine Interrupt Pending) \u003c!DOCTYPE html\u003e Responsive Image 获取当前 M/S/U 模式下对应的 External/Timer/Software 中断是否发生。\n中断处理流程 中断处理 把 mstatus 的 MIE 值复制到 MPIE 中，清除 mstatus 中的 MIE 标志位，效果是中断被禁止。 当前的 PC 的下一条指令地址被复制到 mepc 中，同时 PC 被设置为mtvec。注意如果我们设置 mtvec.MODE = vetcored，PC =mtvec.BASE + 4 × exception-code。 根据 interrupt 的种类设置 mcause，并根据需要为 mtval 设置附加信息。 将 trap 发生之前的权限模式保存在 mstatus 的 MPP 域中，再把hart 权限模式更改为 M。 退出中断 以在 M 模式下执行 mret 指令为例，会执行如下操作：\n当前 Hart 的权限级别 = mstatus.MPP; mstatus.MPP= U（如果 hart 不支持 U 则为 M） mstatus.MIE = mstatus.MPIE; mstatus.MPIE = 1 pc = mepc PLIC（Platform-Level Interrupt Controller） PLIC 简介 HART 只能处理一个中断，PLIC 相当于一个控制中心，它通过中断类型，优先级等等来选出一个需要处理的中断。协调多个中断，服务一个 HART。\n\u003c!DOCTYPE html\u003e Responsive Image enum { UART0_IRQ = 10, //Interrupt Source ID RTC_IRQ = 11, VIRTIO_IRQ = 1, /* 1 to 8 */ VIRTIO_COUNT = 8, PCIE_IRQ = 0x20, /* 32 to 35 */ VIRTIO_NDEV = 0x35 /* Arbitrary maximum number of interrupts */ }; Interrupt Source ID 范围：1 ~ 53（0x35） 0 预留不用 PLIC本身也是一个外设，RISC-V 规范规定，PLIC 的寄存器编址采用内存映射（memory map）方式。每个寄存器的宽度为 32-bit。\n具体寄存器编址采用 base + offset 的格式，且 base 由各个特定platform 自己定义。针对 QEMU-virt，其 PLIC 的设计参考了FU540-C000，base 为 0x0c000000。\nstatic const MemMapEntry virt_memmap[] = { [VIRT_DEBUG] = { 0x0, 0x100 }, [VIRT_MROM] = { 0x1000, 0xf000 }, [VIRT_TEST] = { 0x100000, 0x1000 }, [VIRT_RTC] = { 0x101000, 0x1000 }, [VIRT_CLINT] = { 0x2000000, 0x10000 }, [VIRT_ACLINT_SSWI] = { 0x2F00000, 0x4000 }, [VIRT_PCIE_PIO] = { 0x3000000, 0x10000 }, [VIRT_PLIC] = { 0xc000000, VIRT_PLIC_SIZE(VIRT_CPUS_MAX * 2) }, [VIRT_UART0] = { 0x10000000, 0x100 }, [VIRT_VIRTIO] = { 0x10001000, 0x1000 }, [VIRT_FW_CFG] = { 0x10100000, 0x18 }, [VIRT_FLASH] = { 0x20000000, 0x4000000 }, [VIRT_PCIE_ECAM] = { 0x30000000, 0x10000000 }, [VIRT_PCIE_MMIO] = { 0x40000000, 0x40000000 }, [VIRT_DRAM] = { 0x80000000, 0x0 }, }; PLIC 编程接口 - 寄存器 Priority 功能：设置某一路中断源的优先级 内存映射地址：BASE + (interrupt-id) * 4\n每个 PLIC 中断源对应一个寄存器，用于配置该中断源的优先级。 QEMU-virt 支持 7 个优先级。0 表示对该中断源禁用中断。其余优先级，1 最低，7 最高。 如果两个中断源优先级相同，则根据中断源的 ID 值进一步区分优先级，ID 值越小的优先级越高。 Pending 功能：用于指示某一路中断源是否发生 内存映射地址：BASE + 0x1000 + ((interrupt-id) / 32) * 4\n每个 PLIC 包含 2 个 32 位的 Pending 寄存器，因为总共有 54 个中断源，每一个 bit 对应一个中断源，如果为 1 表示该中断源上发生了中断（进入Pending 状态），有待 hart 处理，否则表示该中断源上当前无中断发生。 Pending 寄存器中断的 Pending 状态可以通过claim 方式清除。 第一个 Pending 寄存器的第 0 位对应不存在的 0 号中断源，其值永远为 0。 Enable 功能：针对某个 hart 开启或者关闭某一路中断源 内存映射地址：BASE + 0x2000 + (hart) * 0x80\n每个 Hart 有 2 个 Enable 寄存器（Enable1 和 Enable2）用于针对该Hart 启动或者关闭某路中断源。 每个中断源对应 Enable 寄存器的一个 bit，其中Enable1 负责控制 1 ~ 31 号中断源；Enable2 负责控制 32 ~ 53 号中断源。将对应的 bit 位设置为 1 表示使能该中断源，否则表示关闭该中断源。 Threshold 功能：针对某个 hart 设置中断源优先级的阈值 内存映射地址：BASE + 0x200000 + (hart) * 0x1000\n每个 Hart 有 1 个 Threshold 寄存器用于设置中断优先级的阈值。 所有小于或者等于（\u0026lt;=）该阈值的中断源即使发生了也会被 PLIC 丢弃。特别地，当阈值为 0 时允许所有中断源上发生的中断；当阈值为 7 时丢弃所有中断源上发生的中断。 Claim/Complete 功能：如下 内存映射地址：BASE + 0x200004 + (hart) * 0x1000\nClaim 和 Complete 是同一个寄存器，每个 Hart 一个。 对该寄存器执行读操作称之为 Claim，即获取当前发生的最高优先级的中断源ID。Claim 成功后会清除对应的 Pending 位。 对该寄存器执行写操作称之为 Complete。所谓 Complete指的是通知PLIC 对该路中断的处理已经结束。 void external_interrupt_handler() { int irq = plic_claim(); // if (irq == UART0_IRQ){ uart_isr(); } else if (irq) { printf(\u0026#34;unexpected interrupt irq = %d\\n\u0026#34;, irq); } if (irq) { plic_complete(irq); // } } \u003c!DOCTYPE html\u003e Responsive Image CLINT （Core Local INTerruptor） 定时器中断，属于本地中断的一种，由芯片内部CLINT设备产生的中断。\nRISC-V 规范规定，CLINT 的寄存器编址采用内存映射（memory map）方式。 具体寄存器编址采用base + offset的格式，且 base 由各个特定 platform 自己定义。针对 QEMU-virt，其 CLINT 的设计参考了 SFIVE，base 为 0x2000000。 CLINT 编程接口 - 寄存器 (Timer 部分) mtime 功能：real-time 计数器（counter） 内存映射地址：BASE + 0xbff8\n由晶振产生，系统全局唯一，在 RV32 和 RV64 上都是 64-bit。系统必须保证该计数器的值始终按照一个固定的频率递增。 上电复位时，硬件负责将 mtime 的值恢复为 0。 mtimecmp 功能：定时器比较寄存器 内存映射地址：BASE + 0x4000 + (hart) * 8)\n每个 hart 一个 mtimecmp 寄存器，64-bit。\n上电复位时，系统不负责设置 mt`imecmp 的初值。\n当mtime \u0026gt;= mtimecmp 时，CLINT 会产生一个 timer 中断。如果要使能该中断需要保证全局中断打开并且mie.MTIE 标志位置 1。\n当 timer 中断发生时，hart 会设置 mip.MTIP，程序可以在 mtimecmp 中写入新的值清除mip.MTIP。\n时钟节拍 tick 操作系统中最小的时间单位； Tick 的单位（周期）由硬件定时器的周期决定 （通常为 1 ~ 100ms）； Tick 周期越小，也就是1s内产生的中断越多，系统的精度越高，但开销越大。 ","permalink":"https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-trap%E5%92%8Cexception/","summary":"\u003ch1 id=\"trap-简介\"\u003eTrap 简介\u003c/h1\u003e\n\u003ch2 id=\"控制流control-flow和-trap\"\u003e控制流（Control Flow）和 Trap\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e控制流（Control Flow）\n从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列\n$$a_0,a_1,\\dotsb,a_{n-1}$$\n每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。\u003c/li\u003e\n\u003cli\u003e异常控制流（Exceptional Control Flow, ECF）\n系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。\n\u003cul\u003e\n\u003cli\u003eexception\u003c/li\u003e\n\u003cli\u003einterrupt\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRISC-V 把 \u003ccode\u003eECF\u003c/code\u003e 统称为 \u003ccode\u003eTrap\u003c/code\u003e。\u003c/p\u003e","title":"RISC-V 入门-Trap"},{"content":"测试代码时经常需要上传文件至服务器端运行，每次上传都需要通过第三方传输工具如 FileZilla，有了SFTP插件，可以直接在 VSCode 上编译成功后，一键上传本地文件。\n安装插件 打开插件中心，搜索sftp，安装量最高的就是我们需要的插件，点击安装。\n\u003c!DOCTYPE html\u003e Responsive Image 配置插件 插件安装完成后，输入快捷键Control + Shift + P 弹出命令面板，然后输入sftp:config，回车，当前工程的.vscode文件夹下就会自动生成一个sftp.json文件，我们需要在这个文件里配置的内容可以是：\n{ \u0026#34;host\u0026#34;: \u0026#34;192.168.xxx.xxx\u0026#34;, //服务器 ip \u0026#34;port\u0026#34;: 22, //端口，sftp 模式是 22 \u0026#34;username\u0026#34;: \u0026#34;\u0026#34;, //用户名 \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, //密码 \u0026#34;protocol\u0026#34;: \u0026#34;ftp\u0026#34;, //模式，sfpt 或者 ftp \u0026#34;agent\u0026#34;: null, \u0026#34;privateKeyPath\u0026#34;: null, //存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件） \u0026#34;passphrase\u0026#34;: null, \u0026#34;passive\u0026#34;: false, \u0026#34;interactiveAuth\u0026#34;: false, \u0026#34;remotePath\u0026#34;: \u0026#34;/root/node/build/\u0026#34;, //服务器上的文件地址 \u0026#34;context\u0026#34;: \u0026#34;./server/build\u0026#34;, //本地的文件地址 \u0026#34;uploadOnSave\u0026#34;: true, //监听保存并上传 \u0026#34;syncMode\u0026#34;: \u0026#34;update\u0026#34;, \u0026#34;watcher\u0026#34;: { //监听外部文件 \u0026#34;files\u0026#34;: false, //外部文件的绝对路径 \u0026#34;autoUpload\u0026#34;: false, \u0026#34;autoDelete\u0026#34;: false }, \u0026#34;ignore\u0026#34;: [ //指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹 //注意每一行后面有逗号，最后一行没有逗号 //忽略项 \u0026#34;**/.vscode/**\u0026#34;, \u0026#34;**/.git/**\u0026#34;, \u0026#34;**/.DS_Store\u0026#34; ] } 插件使用 可以直接右击文件，选择Upload，会将文件上传至配置好的remotePath。\n可以Control + Shift + P输入sftp，选择想要执行的命令，命令都是字面意思，不多做解释。 \u003c!DOCTYPE html\u003e Responsive Image 如果有多个 IP 需要配置，可以在sftp.json文件中，通过方括号[]添加。比如\n[ { \u0026#34;host\u0026#34;: \u0026#34;192.168.xxx.01\u0026#34;, //服务器 ip \u0026#34;port\u0026#34;: 22, //端口，sftp模式是22 \u0026#34;username\u0026#34;: \u0026#34;\u0026#34;, //用户名 \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, //密码 \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, //模式，sfpt 或者 ftp \u0026#34;agent\u0026#34;: null, }, { \u0026#34;host\u0026#34;: \u0026#34;192.168.xxx.02\u0026#34;, //服务器 ip \u0026#34;port\u0026#34;: 22, //端口，sftp模式是22 \u0026#34;username\u0026#34;: \u0026#34;\u0026#34;, //用户名 \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, //密码 \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, //模式，sfpt 或者 ftp \u0026#34;agent\u0026#34;: null, }, { \u0026#34;host\u0026#34;: \u0026#34;192.168.xxx.03\u0026#34;, //服务器 ip \u0026#34;port\u0026#34;: 22, //端口，sftp模式是22 \u0026#34;username\u0026#34;: \u0026#34;\u0026#34;, //用户名 \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, //密码 \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, //模式，sfpt 或者 ftp \u0026#34;agent\u0026#34;: null, } ] ","permalink":"https://lifeislife.cn/posts/vscode%E4%BD%BF%E7%94%A8sftp%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%87%B3%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","summary":"\u003cp\u003e测试代码时经常需要上传文件至服务器端运行，每次上传都需要通过第三方传输工具如 FileZilla，有了\u003ccode\u003eSFTP\u003c/code\u003e插件，可以直接在 VSCode 上编译成功后，一键上传本地文件。\u003c/p\u003e","title":"VSCode 使用 sftp 插件上传本地文件至局域网服务器"},{"content":"","permalink":"https://lifeislife.cn/posts/c%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D/","summary":"","title":"C 程序内存区域分配"},{"content":"内容总结自 B 站 Up【蛋饼嵌入式】我提着鞋带拎自己？嵌入式芯片启动过程全解析，彻底理解 bootloader\n当你按下电源开关的那一瞬间，第一行代码如何在芯片上运行起来的呢？嵌入式软件代码需要一定的方式烧录到芯片中才能运行，除了物理刻蚀，无论是通讯端口的传输或者调试端口的烧录，都需要驱动程序的支持。所以说是程序烧录了程序，软件启动了软件。\n这就像自己提着自己的鞋带，把自己拎起来。靴子（Boot）,鞋带（Strap），提鞋带（Loader）。这就是Boot Strap Loader的命名来源。通常称BootLoader，中文翻译为自举。\nBootLoader是芯片最初运行的代码吗？当然不是，其实每一块芯片在出厂时都在其内部的ROM中，烧录了它最基础的软件。CPU 搬运并运行的第一条代码的默认位置，就在ROM的地址空间。所以一切的起始都在硬件上。\n以 X86 架构的鼻祖 8086 芯片为例，按下开关的一瞬间，芯片 Reset 引脚接收到了电平跳变，在一连串电路的作用下，代码段寄存器CS恢复成0XFFFF，指令指针寄存器IP恢复成0X0000，他们组合成 20 位的地址正好等于 ROM 中存放第一条代码的位置。之后取出这里的指令在跳转到别处。\nARM 架构的芯片也是类似的过程，对于 32 位的芯片，通电后，PC指针寄存器复位至零地址，随后从中断向量表表头的 reset 向量处获取下一个跳转的地址。这时候的代码已经以二进制形式存储，处理器可以直接搬到自身缓存中运行。有了这部分代码，就能跳转到存放有更多更复杂的代码的地址。执行硬件自检，基本的初始化操作，提供基础的输入输出支持。之后可以将操作系统从外部的存储空间加载到内部。代码就这样接力式的流转起来。\n\u003c!DOCTYPE html\u003e Responsive Image 所以我们把出厂就写在ROM里，负责启动后续用户软件的软件，称为Boot ROM或者ROM Code。现在不一定是用只读存储器（Read Only Memory），但是至少是一块掉电不易失的存储器，现在主要用EEPROM，NOR Flash。我们一般没有权限修改它，但是它也不完全是黑盒，大部分芯片都会有外部启动配置引脚，通常是以拨码快关的形式。对于 PC 机来说，Boot ROM就是我们常说的BIOS，它也有启动配置途径。而且提供了交互界面，用于配置部分功能和选择后续的引导设备。\n\u003c!DOCTYPE html\u003e Responsive Image 除了芯片自带的Boot ROM，还需要再给自己实际的应用程序，写一个二次引导代码或者 N 次引导代码，用作操作系统，文件系统加载等等。我们所说的Bootloader时，其实大多数就是这样的二次引导代码。\n这些事其实Boot ROM它也能做，但是Boot ROM实现的功能和配置方法不灵活，但是Bootloader是开发人员可以而完全控制的引导代码。\n在设计Bootloader时，MCU的引导步骤就开始和嵌入式 Linux 或者 PC 有所不同。这一定程度与芯片架构所采用的的存储方案有关。\n先来说MCU，与SOC相比MCU的主要特征是单核和或多核同构的微处理器，单核或多核同构，主频 \u0026lt; 1GHz，没有MMU内存管理单元，只能运行实时操作系统。常见MCU内核：\n\u003c!DOCTYPE html\u003e Responsive Image 程序的主要运行介质为NOR Flash，因为和RAM一样有分离的地址线和数据线。并且可以以字节长度精确寻址，所以程序不需要拷贝到RAM中运行的。\n以英飞凌家的 TC27x 系列 MCU 为例，上电后的默认取址位置是0x8FFF 8000，这就是他的Boot ROM在NorFlash中的地址。并且这块Boot Rom分为SSW，BSL，TF。\n\u003c!DOCTYPE html\u003e Responsive Image SSW 每次上电必须运行，他会根据写在program flash，PFO地址的前 32byte 中的配置字，来决定SSW执行完的跳转地址。我们可以选择一个合适的跳转地址，比如0x80000020，放上自己写的Bootloader。也可以选择不跳转，运行厂家提供的Bootloader（BSL）。\nMCU下的Bootloader主要完成的事情有以下：\n关闭看门狗，初始化中断和 trap 向量表，进行时钟和外设初始化，让芯片正常运行起来。 提供CAN,UART, ETH等用于通讯功能的驱动，能够接收外部数据传输请求。 提供FLASH的读写与擦除驱动，设计服务来对通讯端口接收到的更新代码进行校验、存储，以及跳转操作系统或后续应用程序代码。 如有必要，还会开发一些基础诊断服务，串口交互程序等等。 那么运行 Linux 的SOC和 PC 的这一过程有何不同呢。还是先看存储方案，运行嵌入式 Linux 的 SoC。一般将它的操作系统，文件系统和他的应用程序放在nand flash中。运行代码前，现将代码搬运到SRAM中，相比MCU多了一道步骤。\n\u003c!DOCTYPE html\u003e Responsive Image 对于SOC的Boot ROM 和 PC 的BIOS而言，他们结束运行前的最终任务，是将某些代码从nand flash搬运到SRAM中，其中最重要的内容就是Boot Loader。\n而一般SOC的Bootloader，又分为SPL（Secondary Program Loader）和uBOOT两个阶段。SPL的 Secondary 就是相对于BootROM而言，他就像是接力赛中的第二棒选手。SPL会初始化更大空间的外部DRAM，再把uBoot搬运到外部DRAM中去运行。uBoot作为第三棒选手，开始运行它的初始化程序。之后再根据系统环境变量，将 OS 内核搬运到外部DRAM中去运行。OS 再完成根文件系统的加载等等等等。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90/","summary":"\u003cp\u003e内容总结自 B 站 Up\u003ca href=\"https://www.bilibili.com/video/BV1AN411R7Be/?spm_id_from=333.788.recommend_more_video.1\"\u003e【蛋饼嵌入式】我提着鞋带拎自己？嵌入式芯片启动过程全解析，彻底理解 bootloader\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e当你按下电源开关的那一瞬间，第一行代码如何在芯片上运行起来的呢？嵌入式软件代码需要一定的方式烧录到芯片中才能运行，除了物理刻蚀，无论是通讯端口的传输或者调试端口的烧录，都需要驱动程序的支持。所以说是\u003cstrong\u003e程序烧录了程序，软件启动了软件\u003c/strong\u003e。\u003c/p\u003e","title":"芯片启动过程全解析"},{"content":"概念 定时器（Timer），又叫计时器，顾名思义，它的主要功能就是计时。因为 CPU 计时会占用大量资源，而定时器独立于 CPU，专门用来计时。单核 CPU 好比人的大脑，一心不可二用，它只能知道自己当前要干什么。人可以用闹钟来提醒自己某个时间需要做某件事，而 CPU 就需要定时器来完成这样的工作。\n当定时器被开启后，里面的计数器就以计数器时钟的频率开始运行，内部的计数值不断增加。例如一个时钟为1MHz的定时器，被开启后每隔1us计数值就会加 1。但计数值不可能无限增加，最大值比如65535。将这个十进制数转为二进制数后应该是一个 16 位的二进制数1111 1111 1111 1111。所以我们需要有一个 16 位大小的存储空间来存储它。那这就是一个 16 位定时器。\n功能 定时器可以让 SoC 在执行主程序的同时，可以 (通过定时器) 具有计时功能，到了一定时间 (计时结束) 后，定时器会产生中断提醒 CPU，CPU 会去处理中断并执行定时器中断的 ISR，从而去执行预先设定好的事件。打个比方，定时器就像一个秘书，CPU 就是老板。老板每天都有很多事要做，具体时间安排不想操心，就安排给秘书。秘书每天就是盯着表，到点就提醒老板要做某事。\n原理 外设的工作频率是与它所挂载在的外设总线的时钟频率相同的。但工作频率不是时钟频率，工作频率到时钟频率需要进行一次分频。这个可调节的分频值使得定时器的计时更加灵活。这个分频值就是需要设置的第一个参数预分频系数。\n$$ 计数器时钟频率 = 工作频率/(预分频系数+1) $$\n$$ 定时频率 = 计时器时钟频率/(自动重载值+1) $$\n假设定时器时钟频率为1MHz，那定时1ms该如何做？计数 1000 次即可。最大的计数值就是自动重载值，是我们需要设置的第二个参数。定时器被打开后，计数值就增加，一旦达到自动重载值就会出发定时器溢出中断，就实现了定时1ms。\n计数模式 \u003c!DOCTYPE html\u003e Responsive Image 中心计数：计数器从 0 开始计数到自动装入的值 -1，产生一个计数器溢出事件，0 然后向下计数到 1 并且产生一个计数器溢出事件，然后再从 0 开始重新计数。\n向上计数：计数器从 0 计数到自动加载值 (TIMx_ARR) ，然后重新从 0 开始计数并且产生一个计数器溢出事件。\n向下计数：计数器从自动装入的值 (TIMx_ARR) 开始向下计数到 0，然后从自动装入的值重新开始，并产生一个计数器向下溢出事件。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E5%AE%9A%E6%97%B6%E5%99%A8timer%E5%9F%BA%E7%A1%80/","summary":"\u003ch2 id=\"概念\"\u003e概念\u003c/h2\u003e\n\u003cp\u003e定时器（Timer），又叫计时器，顾名思义，它的主要功能就是计时。因为 CPU 计时会占用大量资源，而定时器独立于 CPU，专门用来计时。单核 CPU 好比人的大脑，一心不可二用，它只能知道自己当前要干什么。人可以用闹钟来提醒自己某个时间需要做某件事，而 CPU 就需要定时器来完成这样的工作。\u003c/p\u003e","title":"定时器 Timer 基础"},{"content":"保留现场 我在线程中直接调用了 QTextEdit 的 append 函数时，候就会出现下面的错误：\nQObject::connect: Cannot queue arguments of type \u0026#39;QTextCursor\u0026#39; (Make sure \u0026#39;QTextCursor\u0026#39; is registered using qRegisterMetaType().) 探究原因 原因是我们不能通过线程来修改 UI，较为安全的修改用户界面的方式是向 UI 窗口发送信号 (signal)，较为简单的方式是使用 Qt threading 类。\n解决方法 在窗口类中定义信号和槽，并声明和实现一个接口函数，这个接口函数由线程调用，在接口函数中 emit 一个信号，示例代码如下：\n//mainwindow.h signals: void AppendText(const QString \u0026amp;text); private slots: void SlotAppendText(const QString \u0026amp;text); public: void Append(const QString \u0026amp;text); //mainwindow.cpp connect(this,SIGNAL(AppendText(QString)),this,SLOT(SlotAppendText(QString))); void ClassName::Append(const QString \u0026amp;text) { emit AppendText(\u0026#34;ok: string1\u0026#34;); } //thread.cpp void ThreadClassName::SlotAppendText(const QString \u0026amp;text) { mText.append(text); } ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3qt-qobject-connect-cannot-queue-arguments-of-type-qtextcursor%E9%94%99%E8%AF%AF/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e我在线程中直接调用了 QTextEdit 的 append 函数时，候就会出现下面的错误：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eQObject::connect: Cannot queue arguments of \u003cspan class=\"nb\"\u003etype\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;QTextCursor\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eMake sure \u003cspan class=\"s1\"\u003e\u0026#39;QTextCursor\u0026#39;\u003c/span\u003e is registered using qRegisterMetaType\u003cspan class=\"o\"\u003e()\u003c/span\u003e.\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e原因是\u003cstrong\u003e我们不能通过线程来修改 UI，较为安全的修改用户界面的方式是向 UI 窗口发送信号 (signal)\u003c/strong\u003e，较为简单的方式是使用 Qt threading 类。\u003c/p\u003e","title":"解决 Qt-QObject::connect: Cannot queue arguments of type‘QTextCursor’错误"},{"content":"保留现场 \u003c!DOCTYPE html\u003e Responsive Image 探究原因 磁盘检测不能通过，可能是因为系统突然断电或其它未正常关闭系统导致。\n解决方法 根据提示可以看到是dev/sda5这个扇区出现了异常，所以通过fsck命令修复文件系统。详细命令解释。\n将sda5改为自己损坏的扇区即可，等待一段时间修复完成后，输入exit即可重启。\nfsck -y /dev/sda5 ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3linux%E5%90%AF%E5%8A%A8%E5%87%BA%E7%8E%B0fsck-exited-with-status-code-4/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112041102634.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112041102634.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e磁盘检测不能通过，可能是因为系统突然断电或其它未正常关闭系统导致。\u003c/p\u003e","title":"解决 Linux 启动出现 fsck exited with status code 4"},{"content":"问题简介 本文基于【Qt】窗体间传递数据（跨控件跨类），三种情况与处理方法\n已知三个窗体，A 为 B C 的父控件，B 与 C 互为兄弟控件 那么参数传递分三种情况：\nB 向 A（C 向 A）传递参数 B 向 C（C 向 B）传递参数 A 向 B（A 向 C）传递参数 三个空间关系模型参考如下，\n\u003c!DOCTYPE html\u003e Responsive Image B 向 A（C 向 A）传递参数 //B.h class B { signals: void toA([ParamList]); } //B.cpp B::B() { emit toA([ParamList]); } //A.h class A { private: B *b; private slots: void fromB([ParamList]); } //A.cpp A::A() { b = new B; connect(b, SIGNAL(toA([ParamList])), this, SLOT(fromB([ParamList]))); } void A::fromB([ParamList]) { //get[ParamList] } B 向 C（C 向 B）传递参数 //A.h { private: B *b; C *c; } //A.cpp A::A() { b = new B; c = new C; connect(b, SIGNAL(toC([ParamList]), c, SLOT(fromB([ParamList]))); } //B.h class B { signals: void toC([ParamList]); } //B.cpp B::B() { emit toC([ParamList]); } //C.h class C { private slots: void fromB([ParamList]); } //C.cpp void C::fromB([ParamList]) { //get[ParamList] } A 向 B（A 向 C）传递参数 //B.h class B { public: void fromA([ParamList]); } //B.cpp void B::fromA([ParamList]) { //get[ParamList] } //A.h class A { private: B *b; } //A.cpp A:A() { b = new B; b-\u0026gt;fromA([ParamList]); } ","permalink":"https://lifeislife.cn/posts/qt%E8%B7%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E7%B1%BB%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/","summary":"\u003ch2 id=\"问题简介\"\u003e问题简介\u003c/h2\u003e\n\u003cp\u003e本文基于\u003ca href=\"https://blog.csdn.net/shihoongbo/article/details/48681979\"\u003e【Qt】窗体间传递数据（跨控件跨类），三种情况与处理方法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e已知三个窗体，A 为 B C 的父控件，B 与 C 互为兄弟控件\n那么参数传递分三种情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eB 向 A（C 向 A）传递参数\u003c/li\u003e\n\u003cli\u003eB 向 C（C 向 B）传递参数\u003c/li\u003e\n\u003cli\u003eA 向 B（A 向 C）传递参数\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e三个空间关系模型参考如下，\u003c/p\u003e","title":"Qt 跨窗口，控件类传递数据"},{"content":"安装 Linux sudo apt-get install clang-format windows 每每到这时候就越能感受到用 Linux 作为开发环境的优势，Windows 安装就稍显复杂了。\n你可以选择安装完整的 LLVM，在bin目录可以看到clang-format.exe。安装完后，将 bin 目录添加到环境变量中。\n你也可以只下载clang-format.exe，从LLVM Snapshot Builds下载安装包。在下载页面的底部。同样你需要将单独下载的文件加入到环境变量中。\n\u003c!DOCTYPE html\u003e Responsive Image 使用 入门使用 Linux 可以直接命令行，使用以 LLVM 代码风格格式化main.cpp, 结果直接写到main.cpp\nclang g-format -i main.cpp -style=LLVM 进阶配置 如果每次编码都命令行执行一遍那也太麻烦了，而且每次修改也不止一个文件。最好的方式就是每次保存文件时自动格式化。比如 VSCode 已经内置了Clang-Format稍作配置即可实现，接下来介绍几种常见 IDE 如何配置Clang-Format。\nVSCode VSCode 最常用，因为内置了Clang-Format也最容易配置。\n安装C/C++插件，Ctrl+Shift+X打开应用商店，搜索C/C++找到下图插件，安装后会自动安装Clang-Format程序，无需单独下载。默认安装路径为： C:\\Users\\(你的用户名)\\.vscode\\extensions\\ms-vscode.cpptools-1.7.1\\LLVM\\bin\\clang-format.exe。 \u003c!DOCTYPE html\u003e Responsive Image 打开设置页面（左下角齿轮 - 设置），搜索format，勾选Format On Save，每次保存文件时自动格式化文档。下方的设置是决定每次格式化是整个文档，还是做过修改的内容。默认是file，对整个文档进行格式化。 \u003c!DOCTYPE html\u003e Responsive Image 仍在设置页面搜索Clang，配置如下。.clang-format文件最后详解。 \u003c!DOCTYPE html\u003e Responsive Image 效果图 \u003c!DOCTYPE html\u003e Responsive Image QtCreator 安装Beautifier插件：帮助（Help）-关于插件（About Plugins）- Beautifier勾选，重启 QtCreator。 \u003c!DOCTYPE html\u003e Responsive Image 工具（Tool）- Beautifier，配置如图。该配置，保存文档时自动格式化，并选择Clang-Format作为格式化工具。 \u003c!DOCTYPE html\u003e Responsive Image 配置Clang-Format程序路径，如果开头已经apt install安装过，这里会自动补全。 \u003c!DOCTYPE html\u003e Responsive Image Use predefined style可以选择内置的一些代码风格，如LLVM，Google等。 Use customized style使用自定义的一些代码风格。点击添加（Add）将配置文件粘贴进去即可，具体配置文件见最后。 别忘了点击OK保存。 Eclipse 安装cppstyle插件：Help - Eclipse Marketplace - 搜索cppstyle。\n下载cpplint。 可以去github上下载cpplint的源码，下载完之后解压放到某个目录下。\n在Window - Preferences - C/C++ - CppStyle页面把clang-format的路径添加进去，然后把cpplint的目录指向刚才下载的styleguide目录下的cpplint/cpplint.py就可以了。勾选下面的Enable cpplint，Run clang-format on file save，然后点击Apply and Close保存修改并退出。如下图所示。 \u003c!DOCTYPE html\u003e Responsive Image 此时再保存代码，将会出现如下错误，因为我们还未给当前项目编写配置文件.clang-format。将最后一章提到的配置文件放到当前项目的下即可，程序会自动搜索。\nCannot find .clang-format or _clang-format configuration file under any level parent directories of path. Clang-format will default to Google style. 配置简介 上文多次提到了.clang-format配置文件，该文件决定了代码如何格式化，现在来介绍如何使用该文件。\n导出.clang-format文件 如果重新编写一份配置文件，需要考虑的东西太多，clang-format内置了一些常见风格，我们可以根据已有的配置文件稍作修改，形成自己的代码风格。所以我们先导出一份内置的配置文件。\nclang-format -style=可选格式名 -dump-config \u0026gt; .clang-format # 可选格式最好写预设那那几个写最接近你想要的格式。比如我想要接近 Google C++ style 的。我就写-style=google 各个选项的含义 这里给出了配置的含义，感兴趣也可以查看官方文档，还提供了一些有案例，描述更清晰。\n一些比较明显的代码分格区别\n# 括号是分行，还是不分行，只有当 BreakBeforeBraces 设置为 Custom 时才有效 BraceWrapping: AfterCaseLabel: true # class 定义后面 AfterClass: true # 控制语句后面 AfterControlStatement: true AfterEnum: true AfterFunction: true AfterNamespace: true AfterObjCDeclaration: true AfterStruct: true AfterUnion: true AfterExternBlock: true BeforeCatch: true BeforeElse: true # 缩进大括号，if else 语句后面的括号缩进 IndentBraces: false SplitEmptyFunction: true SplitEmptyRecord: true SplitEmptyNamespace: true BreakBeforeBinaryOperators: None BreakBeforeBraces: Custom # tab 宽度 TabWidth: 4 # 换行缩进字符数 IndentWidth: 4 # 宏定义对齐 AlignConsecutiveMacros: AcrossEmptyLinesAndComments 基于LLVM代码风格修改的个人使用版本：\n--- Language: Cpp # BasedOnStyle: LLVM AccessModifierOffset: -2 AlignAfterOpenBracket: Align # 宏定义对齐 AlignConsecutiveMacros: AcrossEmptyLinesAndComments AlignConsecutiveAssignments: true AlignConsecutiveDeclarations: true AlignConsecutiveBitFields: true AlignEscapedNewlines: Right AlignOperands: true AlignTrailingComments: true AllowAllArgumentsOnNextLine: true AllowAllConstructorInitializersOnNextLine: true AllowAllParametersOfDeclarationOnNextLine: true AllowShortBlocksOnASingleLine: Never AllowShortCaseLabelsOnASingleLine: false # 是否允许短方法单行，只有一行的函数将不会分行，直接写在函数名后 AllowShortFunctionsOnASingleLine: false AllowShortLambdasOnASingleLine: All AllowShortIfStatementsOnASingleLine: Never AllowShortLoopsOnASingleLine: false AlwaysBreakAfterDefinitionReturnType: None AlwaysBreakAfterReturnType: None AlwaysBreakBeforeMultilineStrings: false AlwaysBreakTemplateDeclarations: MultiLine BinPackArguments: true BinPackParameters: true # 括号是分行，还是不分行，只有当 BreakBeforeBraces 设置为 Custom 时才有效 BraceWrapping: AfterCaseLabel: true # class 定义后面 AfterClass: true # 控制语句后面 AfterControlStatement: true AfterEnum: true AfterFunction: true AfterNamespace: true AfterObjCDeclaration: true AfterStruct: true AfterUnion: true AfterExternBlock: false BeforeCatch: true BeforeElse: true # 缩进大括号 IndentBraces: false SplitEmptyFunction: true SplitEmptyRecord: true SplitEmptyNamespace: true BreakBeforeBinaryOperators: None BreakBeforeBraces: Custom BreakBeforeInheritanceComma: false BreakInheritanceList: BeforeColon BreakBeforeTernaryOperators: true BreakConstructorInitializersBeforeComma: false BreakConstructorInitializers: BeforeColon BreakAfterJavaFieldAnnotations: false BreakStringLiterals: true ColumnLimit: 100 CommentPragmas: \u0026#39;^ IWYU pragma:\u0026#39; CompactNamespaces: false ConstructorInitializerAllOnOneLineOrOnePerLine: false ConstructorInitializerIndentWidth: 4 ContinuationIndentWidth: 4 Cpp11BracedListStyle: true DeriveLineEnding: true DerivePointerAlignment: false DisableFormat: false ExperimentalAutoDetectBinPacking: false FixNamespaceComments: true ForEachMacros: - foreach - Q_FOREACH - BOOST_FOREACH IncludeBlocks: Preserve IncludeCategories: - Regex: \u0026#39;^\u0026#34;(llvm|llvm-c|clang|clang-c)/\u0026#39; Priority: 2 SortPriority: 0 - Regex: \u0026#39;^(\u0026lt;|\u0026#34;(gtest|gmock|isl|json)/)\u0026#39; Priority: 3 SortPriority: 0 - Regex: \u0026#39;.*\u0026#39; Priority: 1 SortPriority: 0 IncludeIsMainRegex: \u0026#39;(Test)?$\u0026#39; IncludeIsMainSourceRegex: \u0026#39;\u0026#39; IndentCaseLabels: false IndentGotoLabels: true IndentPPDirectives: None # 换行缩进字符数 IndentWidth: 4 IndentWrappedFunctionNames: false JavaScriptQuotes: Leave JavaScriptWrapImports: true KeepEmptyLinesAtTheStartOfBlocks: true MacroBlockBegin: \u0026#39;\u0026#39; MacroBlockEnd: \u0026#39;\u0026#39; MaxEmptyLinesToKeep: 1 NamespaceIndentation: None ObjCBinPackProtocolList: Auto ObjCBlockIndentWidth: 0 ObjCSpaceAfterProperty: false ObjCSpaceBeforeProtocolList: true PenaltyBreakAssignment: 2 PenaltyBreakBeforeFirstCallParameter: 19 PenaltyBreakComment: 300 PenaltyBreakFirstLessLess: 120 PenaltyBreakString: 1000 PenaltyBreakTemplateDeclaration: 10 PenaltyExcessCharacter: 1000000 PenaltyReturnTypeOnItsOwnLine: 60 PointerAlignment: Right ReflowComments: true SortIncludes: true SortUsingDeclarations: true SpaceAfterCStyleCast: false SpaceAfterLogicalNot: false SpaceAfterTemplateKeyword: true SpaceBeforeAssignmentOperators: true SpaceBeforeCpp11BracedList: false SpaceBeforeCtorInitializerColon: true SpaceBeforeInheritanceColon: true SpaceBeforeParens: ControlStatements SpaceBeforeRangeBasedForLoopColon: true SpaceInEmptyBlock: false SpaceInEmptyParentheses: false SpacesBeforeTrailingComments: 1 SpacesInAngles: false SpacesInConditionalStatement: false SpacesInContainerLiterals: true SpacesInCStyleCastParentheses: false SpacesInParentheses: false SpacesInSquareBrackets: false SpaceBeforeSquareBrackets: false Standard: Latest StatementMacros: - Q_UNUSED - QT_REQUIRE_VERSION TabWidth: 8 UseCRLF: false UseTab: Never ... 格式化最新的commit代码 clang-format还提供一个clang-format-diff.py脚本，用来格式化patch，code review提交代码前，跑一遍下面的代码。\n// 格式化最新的 commit，并直接在原文件上修改 git diff -U0 HEAD^ | clang-format-diff.py -i -p1 常见问题 如何看懂官方文档并编写配置文件 官方文档里有各种设置的示例代码，即使不知道想要的格式化是哪个配置参数，翻一翻官方文档是示例大概率能找到。那么找到了想要的配置参数，如何在文件里配置呢？\n以宏定义对齐为例。我们想要宏定义的值保持对齐的状态，如下一节图片所示。可以翻一遍官方文档，可以发现这个示例代码对应的参数可能是我们想要的，AlignConsecutiveMacros翻译为对齐连续的宏定义。那应该八九不离十了。\n\u003c!DOCTYPE html\u003e Responsive Image 找到了参数如何编写配置文件呢？可以继续看这个参数下面的更多示例，每一个示例都对应一个配置可能值Possible values。\nACS_None (in configuration: None) Do not align macro definitions on consecutive lines. ACS_None为这个配置的缩写，None表示在配置文件里的值。该配置表示不对宏定义进行对齐操作，在配置文件里可以添加如下：\nAlignConsecutiveMacros: None ACS_Consecutive (in configuration: Consecutive) Align macro definitions on consecutive lines. This will result in formattings like:\n#define SHORT_NAME 42 #define LONGER_NAME 0x007f #define EVEN_LONGER_NAME (2) #define foo(x) (x * x) /* some comment */ #define bar(y, z) (y + z) ACS_Consecutive为这个配置的缩写，Consecutive表示在配置文件里的值。该配置表示对连续的宏定义进行对齐，在配置文件里可以添加如下：\nAlignConsecutiveMacros: Consecutive 宏定义对齐失效 # 宏定义对齐 AlignConsecutiveMacros: AcrossEmptyLinesAndComments 使用宏定义对齐更详细的配置，可以参考官方文档。使用该配置一定要使用等宽的字体，否则配置生效但是显示不正确。 比如我是用微软雅黑字体作为编码字体，因为该字体每个字符不等宽，导致格式化正确，但是显示不正确。\n\u003c!DOCTYPE html\u003e Responsive Image 如果将字体换位等宽字体如常用的Consolas，就可以正常显示。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/clang-format%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/","summary":"\u003ch2 id=\"安装\"\u003e安装\u003c/h2\u003e\n\u003ch3 id=\"linux\"\u003eLinux\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install clang-format\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"windows\"\u003ewindows\u003c/h3\u003e\n\u003cp\u003e每每到这时候就越能感受到用 Linux 作为开发环境的优势，Windows 安装就稍显复杂了。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e你可以选择安装完整的 LLVM，在\u003ccode\u003ebin\u003c/code\u003e目录可以看到\u003ccode\u003eclang-format.exe\u003c/code\u003e。安装完后，将 \u003ccode\u003ebin\u003c/code\u003e 目录\u003cstrong\u003e添加到环境变量\u003c/strong\u003e中。\u003c/p\u003e","title":"Clang-Format 格式化代码"},{"content":"代码整洁之道 整洁代码 整洁之道 代码是我们最终用来表达需求的那种语言，代码永存；\n时时保持代码整洁，稍后等于永不（Later equals never）；\n整洁代码力求集中，每个函数、每个类和每个模块都全神贯注于一件事；\n整洁代码简单直接，从不隐藏设计者的意图；\n整洁代码应当有单元测试和验收测试。它使用有意义的命名，代码通过其字面表达含义；\n消除重复代码，提高代码表达力。\n有意义的命名 避免误导 \u0026ldquo;一组账号\u0026quot;别用accountList表示，List对程序员有特殊含义，可以用 accountGroup、bunchOfAccounts、甚至是accounts；\n不使用区别较小的名称，ZYXControllerForEfficientHandlingOfStrings和 ZYXControllerForEfficientStorageOfStrings难以辨别；\n不使用小写 l、大写 O 作变量名，看起来像常量 1、0。\n做有意义的区分 不以数字系列命名(a1、a2、a3)，按照真实含义命名；\nProduct/ProductInfo/ProductData 意思无区别，只统一用一个；\n别写冗余的名字，变量名别带variable、表名别带table。\n使用读得出来的名称 genymdhms（生成日期，年、月、日、时、分、秒）肯定不如generation timestamp（生成时间戳）方便交流。 使用可搜索的名称 单字母名称和数字常量很难在上下文中找出。名称长短应与其作用域大小相对应，越是频繁出现的变量名称得越容易搜索 (越长)。 命名时避免使用编码 把类型和作用域编码进名称里增加了解码负担。意味着新人除了了解代码逻辑之外，还需要学习这种编码语言；\n别使用匈牙利语标记法(格式：[Prefix]-BaseTag-Name 其中 BaseTag 是数据类型的缩写，Name 是变量名字)，纯属多余。例如，szCmdLine的前缀sz表示“以零结束的字符串”；\n不必用m_前缀来表明成员变量；\n接口和实现别在名称中编码。接口名IShapeFactory的前导\u0026quot;I\u0026quot;是废话。如果接口和实现必须选一个编码，宁可选实现，ShapeFactoryImp都比对接口名称编码来的好。\n避免思维映射 不应当让读者在脑中把你的名称翻译为他们熟知的名称。例如，循环计数器自然有可能被命名为i或j或k，但千万别用字母l；\n专业程序员了解，明确是王道，编写能方便他人理解的代码。\n类名、方法名 类名应当是名词或名词短语，方法名应当是动词或动词短语。 命名不要耍宝幽默 言到意到，意到言到，不要在命名上展示幽默感。 每个概念用一个词 fetch、retrieve、get约定一个一直用即可。 尽管使用计算机科学术语 只有程序员才会读你的代码，不需要按照问题所在邻域取名称。 别用双关语 add方法一般语义是：根据两个值获得一个新的值。如果要把单个值加入到某个集合，用insert或append命名更好，这里用add就是双关语了。 添加有意义的语境 很少有名称能自我说明，需要用良好命名的类、函数、或者命名空间来放置名称，给读者提供语境，如果做不到的话，给名称添加前缀就是最后一招了。 函数 越短越好 短小，20 行封顶；\nif/else/while语句的代码块应该只有一行，该行应该是一个函数调用语句；\n函数的缩进层级不应该多于一层或两层。\n一个函数只做一件事 如果函数只是做了该函数名下同一抽象层上的步骤，则函数只做了一件事；\n要判断函数是否不止做了一件事，就是要看是否能再拆出一个函数；\n每个函数一个抽象层级 向下规则：让代码拥有自顶向下的阅读顺序。每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能循抽象层级向下阅读了。 switch 语句 把 switch 埋在较低的抽象层级，一般可以放在抽象工厂底下，用于创建多态对象。 使用描述性的名称 函数越短小、功能越集中，就越便于取个好名字；\n别害怕长名称，长而具有描述性的名称，要比短而令人费解的名称好，要比描述性的长注释好；\n别害怕花时间取名字。\n函数参数 参数越少越好，0 参数最好，尽量避免用三个以上参数；\n参数越多，编写组合参数的测试用例就越困难；\n别用标识参数，向函数传入bool值是不好的，这意味着函数不止做一件事。可以将此函数拆成两个；\n如果函数需要两个、三个或者三个以上参数，就说明其中一些参数应该封装成类了；\n将参数的顺序编码进函数名，减轻记忆参数顺序的负担，例如 assertExpectedEqualsActual(expected, actual)。\n副作用 (函数在正常工作任务之外对外部环境所施加的影响) 检查密码并且初始化session的方法命名为checkPasswordAndInitializeSession而非 checkPassword，即使违反单一职责原则也不要有副作用；\n避免使用\u0026quot;输出参数\u0026rdquo;，如果函数必须修改某种状态，就修改所属对象的状态吧。\n设置 (写) 和查询 (读) 分离 ```C if(set(\u0026quot;username\u0026quot;, \u0026quot;unclebob\u0026quot;)) { ... } ``` 含义模糊不清。应该改为: ```c if (attributeExists(\u0026quot;username\u0026quot;)) { setAttribute(\u0026quot;username\u0026quot;, \u0026quot;unclebob\u0026quot;); } ``` 使用异常代替返回错误码 返回错误码会要求调用者立刻处理错误，从而引起深层次的嵌套结构；\nif (deletePate(page) == E_OK) { if (xxx() == E_OK) { if (yyy() == E_OK) { log(); } else { log(); } } else { log(); } } else { log(); } 所以需要用try catch异常机制；\ntry { deletePage(); xxx(); yyy(); zzz(); } catch (Exception e) { log(e-\u0026gt;getMessage()); } try/catch代码块丑陋不堪，所以最好把try和 catch代码块的主体抽离出来，单独形成函数。\ntry { do(); } catch (Exception e) { handle(); } 不要写重复代码 重复是软件中一切邪恶的根源。当算法改变时需要修改多处地方。 结构化编程 只要函数保持短小，偶尔出现的return、break、continue语句没有坏处，甚至还比单入单出原则更具有表达力。goto只有在大函数里才有道理，应该尽量避免使用。\n并不需要一开始就按照这些规则写函数，没人做得到。想些什么就写什么，然后再打磨这些代码，按照这些规则组装函数。\n注释 若编程语言足够有表现力，我们就不需要注释；\n注释总是一种失败，因为我们无法找到不用注释就能表达自我的方法；\n代码在演化，注释却不总是随之变动，会变得越来越不准确。\n用代码来阐述 创建一个与注释所言同一事物的函数即可，\n// check to see if the employee is eligible for full benefits if ((employee.falgs \u0026amp; HOURLY_FLAG) \u0026amp;\u0026amp; (employee.age \u0026gt; 65)) 应替换为\nif (employee.isEligibleForFullBenefits()) 好注释 法律信息，并且只要有可能就指向标准许可或者外部文档，而不是放全文；\n提供基本信息，如解释某个抽象方法的返回值；\n对意图的解释，反应了作者某个决定后面的意图；\n阐释。把某些晦涩的参数或者返回值的意义翻译成可读的形式(更好的方法是让它们自身变得足够清晰，但是类似标准库的代码我们无法修改)；\nif (b.compareTo(a) == 1) //b \u0026gt; a 警示。// don't run unless you have some time to kill；\nTODO注释；\n放大 一些看似不合理之物的重要性。\n坏注释 自言自语；\n多余的注释。把逻辑在注释里写一遍不能比代码提供更多信息，读它不比读代码简单。一目了然的成员变量别加注释，显得很多余；\n误导性注释；\n遵循规矩的注释。每个函数都加注释、每个变量都加注释是愚蠢的；\n日志式注释。有了代码版本控制工具，不必在文件开头维护修改时间、修改人这类日志式的注释；\n能用函数或者变量表示就别用注释；\n// does the module from the global list \u0026lt;mod\u0026gt; // depend on the subsystem we are part of? if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem()) 可以改为：\nArrayList moduleDependees = smodule.getDependSubsystems(); String ourSubSystem = subSysMod.getSubSystem(); if (moduleDependees.contains(ourSubSystem)) 位置标记。标记多了会被我们忽略掉；\n///////////////////// Actions //////////////////////////\n右括号注释；\ntry { while () { if () { ... } // if ... } // while ... } // try 如果你想标记右括号，其实应该做的是缩短函数\n署名 /* add by rick */ 源代码控制工具会记住你，署名注释跟不上代码的演变；\n注释掉的代码。会导致看到这段代码其他人不敢删除，使用版本控制系统，可以大胆删除需要注释的代码；\n信息过多。别在注释中添加有趣的历史话题或者无关的细节；\n没解释清楚的注释。注释的作用是解释未能自行解释的代码，如果注释本身还需要解释就太遗憾了；\n短函数的函数头注释。为短函数选个好名字比函数头注释要好；\n非公共API函数的javadoc/phpdoc注释。\n格式 垂直格式 短文件比长文件更易于理解。平均200行，最多不超过500行的单个文件可以构造出色的系统；\n像报纸一样排版，由略及详，层层递进；\n区隔: 封包声明、导入声明、每个函数之间，都用空白行分隔开，空白行下面标识着新的独立概念，表示一个思路的开始\n靠近: 紧密相关的代码应该互相靠近，例如一个类里的属性之间别用空白行隔开；\npublic class ReporterConfig { //The class name of the reporter listener private String m_className; //The properties of the reporter listener private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); } } ///////////////////////对比//////////////////////////////////// public class ReporterConfig { private String m_className; private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); } } 变量声明应尽可能靠近其使用位置：循环中的控制变量应该总是在循环语句中声明；\n成员变量应该放在类的顶部声明，不要四处放置；\n如果某个函数调用了另外一个，就应该把它们放在一起。我们希望底层细节最后展现出来，不用沉溺于细节，所以调用者尽可能放在被调用者之上；\n执行同一基础任务的几个函数应该放在一起。\n水平格式 一行代码不必死守80字符的上限，偶尔到达100字符不超过120字符即可；\n区隔与靠近: 空格强调左右两边的分割。赋值运算符两边加空格，函数名与左圆括号之间不加空格，乘法运算符在与加减法运算符组合时不用加空格(a*b - c)；\n不必水平对齐。例如声明一堆成员变量时，各行不用每一个单词都对齐，代码自动格式化工具通常会把这类对齐消除掉；\npublic class　FitNesseExpediter implements ResponseSender { private　Socket　socket; private　InputStream　input; private　OutputStream　output; private　Request　request; }　短小的if、while、函数里最好也不要违反缩进规则，不要这样:if (xx == yy) z = 1；\nwhile语句为空，最好分行写分号；\nwhile(1) ; 团队规则 团队绝对不要用各种不同的风格来编写源代码，这样会增加其复杂度。 对象和数据结构 数据抽象 对象：暴露行为 (接口),隐藏数据 (私有变量) ； 数据结构：没有明显的行为 (接口),暴露数据。如DTO(Data Transfer Objects)、Entity； 数据，对象的反对称性 使用数据结构便于在不改动现在数据结构的前提下添加新函数；使用对象便于在不改动既有函数的前提下添加新类；\n使用数据结构难以添加新数据结构，因为必须修改所有函数；使用对象难以添加新函数，因为必须修改所有类；\n万物皆对象只是个传说，有时候我们也会在简单数据结构上做一些过程式的操作。\nLaw of Demeter 模块不应该了解它所操作对象的内部情形；\nclass C的方法f只应该调用以下对象的方法：\nC\n在方法f里创建的对象\n作为参数传递给方法f的对象\nC持有的对象\n方法不应调用 由任何函数返回的对象 的方法。下面的代码违反了 demeter 定律：\nfinal String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。\n错误处理 错误处理很重要，但是不能凌乱到打乱代码逻辑。 使用异常而不是返回错误码 如果使用错误码，调用者必须在函数返回时立刻处理错误，但这很容易被我们忘记；\n错误码通常会导致嵌套if else。\n先写 try-catch 语句 当编写可能会抛异常的代码时，先写好try-catch再往里堆逻辑。 在 catch 里尽可能的记录 在catch里尽可能的记录错误信息，记录失败的操作以及失败的类型 依调用者定义异常类 对错误分类有很多方式。可以依其来源分类：是来自组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？ 别返回 null 值 返回null值只要一处没检查null，应用程序就会失败；\n当想返回null值的时候，可以试试抛出异常，或者返回特例模式的对象。\n别传递 null 值 在方法中传递null值是一种糟糕的做法，应该尽量避免；\n在方法里用if或assert过滤null值参数，但是还是会出现运行时错误，没有良好的办法对付调动者意外传入的null值，恰当的做法就是禁止传入null值。\n边界 将第三方代码干净利落地整合进自己的代码中 避免公共 API 返回边界接口，或者将边界接口作为参数传递给 API。将边界保留在近亲类中；\n不要在生产代码中试验新东西，而是编写测试来理解第三方代码；\n避免我们的代码过多地了解第三方代码中的特定信息。\n学习性测试是一种精确试验，帮助我们增进对 API 的理解。\n单元测试 TDD(Test-driven development) 三定律 First Law: You may not write production code until you have written a failing unit test.\nSecond Law: You may not write more of a unit test than is sufficient to fail, and not compiling is failing.\nThird Law: You may not write more production code than is sufficient to pass the currently failing test.\n保持测试整洁 脏测试等同于没测试，测试代码越脏生产代码越难修改；\n测试代码和生产代码一样重要；\n整洁的测试代码最应具有的要素是：整洁性。测试代码中不要有大量重复代码的调用。\n每个测试一个断言 每个测试函数有且仅有一个断言语句；\n每个测试函数中只测试一个概念。\n整洁的测试依赖于 FIRST 规则 fast: 测试代码应该能够快速运行，因为我们需要频繁运行它；\nindependent: 测试应该相互独立，某个测试不应该依赖上一个测试的结果，测试可以以任何顺序进行；\nrepeatable: 测试应可以在任何环境中通过；\nself-validating: 测试应该有bool值输出，不应通过查看日志来确认测试结果，不应手工对比两个文本文件确认测试结果；\ntimely: 及时编写测试代码。单元测试应该在生产代码之前编写，否则生产代码会变得难以测试。\n类 类的组织 以下针对 JAVA 语言，其他语言类似，变量在前，方法在后，公有在前，私有在后。\n公共静态常量\n私有静态变量\n私有实体变量\n公共函数\n私有工具函数\n如果测试需要调用一个函数或变量，可以设为保护类型。\n类应该短小 对于函数我们计算代码行数衡量大小，对于类我们使用权责来衡量；\n类的名称应当描述其权责。类的命名是判断类长度的第一个手段，如果无法为某个类命以准确的名称，这个类就太长了。类名包含模糊的词汇，如Processor、Manager、Super，这种现象就说明有不恰当的权责聚集情况；\n单一权责原则（Single Responsibility Principle，SRP）: 类或者模块应该有一个权责——只有一条修改的理由 (A class should have only one reason to change.)；\n系统应该由许多短小的类而不是少量巨大的类组成；\n类应该只有少量的实体变量，如果一个类中每个实体变量都被每个方法所使用，则说明该类具有最大的内聚性。创建最大化的内聚类不太现实，但是应该以高内聚为目标，内聚性越高说明类中的方法和变量互相依赖、互相结合形成一个逻辑整体；\n保持内聚性就会得到许多短小的类。如果你想把一个大函数的某一小部分拆解成单独的函数，拆解出的函数使用了大函数中的 4 个变量，不必将 4 个变量作为参数传递到新函数里，仅需将这 4 个变量提升为大函数所在类的实体变量，但是这么做却因为实体变量的增多而丧失了类的内聚性，更好多做法是让这 4 个变量拆出来，拥有自己的类。将大函数拆解成小函数往往是将类拆分为小类的时机。\n为了修改而组织 类应当对扩展开放，对修改封闭 (开放闭合原则)；\n在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。\n系统 将系统的构造与使用分开 软件系统应将起始过程和之后的运行逻辑分开。 分解 main 将全部构造过程搬迁到 main或者被称之为main的模块中，涉及系统其余部分时，假设所有对象都已经正确构造；\n依赖注入 (DI)，控制反转 (IoC) 是分离构造与使用的强大机制。\n迭代 表达力 作者把代码写的越清晰，其他人理解代码就越快；\n太多时候我们深入于要解决的问题中，写出能工作的代码之后，就转移到下一个问题上，没有下足功夫调整代码让后来者易于阅读。多少尊重一下我们的手艺，花一点点时间在每个函数和类上。\n尽可能少的类和方法 为了保持类和函数的短小，我们可能会早出太多细小的类和方法；\n类和方法数量太多，有时是由毫无意义的教条主义导致的。\n以上 4 条规则优先级依次递减。重要的是测试、消除重复、表达意图 并发编程 为什么要并发编程 并发总能改进性能；\n编写并发程序无需修改设计；\n在采用Web或EJB容器的时候，理解并发问题并不重要。\n防御并发代码问题的原则与技巧 遵循单一职责原则。分离并发代码与非并发代码；\n限制临界区数量、限制对共享数据的访问；\n避免使用共享数据，使用对象的副本；\n线程尽可能地独立，不与其他线程共享数据。\n","permalink":"https://lifeislife.cn/posts/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","summary":"\u003ch1 id=\"代码整洁之道\"\u003e代码整洁之道\u003c/h1\u003e\n\u003ch2 id=\"整洁代码\"\u003e整洁代码\u003c/h2\u003e\n\u003ch3 id=\"整洁之道\"\u003e整洁之道\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e代码是我们最终用来表达需求的那种语言，代码永存；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e时时保持代码整洁，稍后等于永不（\u003cstrong\u003eLater equals never\u003c/strong\u003e）；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e整洁代码力求集中，每个函数、每个类和每个模块都全神贯注于一件事；\u003c/p\u003e","title":"《代码整洁之道》读书笔记"},{"content":"git pull == git fetch + git merge git pull --rebase == git fetch + git rebase 拆解来看这两个命令就是在拉取远端代码后，是合并还是进行变基操作。\n假设当前有三个提交A,B,C，并且分支feature都与远程代码同步。\n\u003c!DOCTYPE html\u003e Responsive Image 我们在feature上做了一些修改，并产生了E提交，远程也有用户进行了更新到了D提交。\n\u003c!DOCTYPE html\u003e Responsive Image 此时我们需要git fetch获取最新的代码，然后git merge解决冲突后重新git add git commit，得到F提交。最后git push即可成功推送，得到如下的关系\n\u003c!DOCTYPE html\u003e Responsive Image 而使用git rebase将会创建一个新的提交F，F的文件内容和上面F的一样，但我们将 E 提交废除，当它不存在（图中用虚线表示）。由于这种删除，避免了菱形的产生，保持提交曲线为直线。\n\u003c!DOCTYPE html\u003e Responsive Image 在rebase的过程中，有时也会有冲突，这时 Git 会停止rebase并让用户去解决冲突，解决完冲突后，用git add添加修改的文件，然后不用执行git commit，直接执行git rebase --continue，这样 git 会继续 apply 余下的补丁。\n","permalink":"https://lifeislife.cn/posts/git-git-pull%E4%B8%8Egit-pull-rebase%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit \u003cspan class=\"nv\"\u003epull\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e git fetch + git merge\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit pull --rebase \u003cspan class=\"o\"\u003e==\u003c/span\u003e git fetch + git rebase\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e拆解来看这两个命令就是在拉取远端代码后，是合并还是进行变基操作。\u003c/p\u003e\n\u003cp\u003e假设当前有三个提交\u003ccode\u003eA,B,C\u003c/code\u003e，并且分支\u003ccode\u003efeature\u003c/code\u003e都与远程代码同步。\u003c/p\u003e","title":"Git-git pull 与 git pull --rebase 的区别"},{"content":"用户一修改了文件名，并推送到了远端。用户二也修改了文件名，在进行推送时，就会被拒绝。\n\u003c!DOCTYPE html\u003e Responsive Image 拉取最新代码后发现有相同的文件，只是文件名不同。index1.htm和index2.htm两个文件内容是完全相同的。\n\u003c!DOCTYPE html\u003e Responsive Image 查看当前状态，可知有其他想把文件名修改为index2.htm。此时只需要根据提示，删除index.htm。协商后决定保留哪一个文件，比如我们决定保留index1.htm。那么删除index2.htm。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 最后在commit一次，即可顺利推送。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/git%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E8%A2%AB%E5%A4%9A%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E6%96%87%E4%BB%B6%E5%90%8D%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/","summary":"\u003cp\u003e用户一修改了文件名，并推送到了远端。用户二也修改了文件名，在进行推送时，就会被拒绝。\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282158733.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282158733.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"Git 同一文件被多人修改了文件名该如何处理"},{"content":"用户一修改了文件名，并提交远端。 \u003c!DOCTYPE html\u003e Responsive Image 用户二修改了文件内容，也进行了推送， \u003c!DOCTYPE html\u003e Responsive Image 当然会被无情拒绝， \u003c!DOCTYPE html\u003e Responsive Image 解决这个问题也十分简单，Git 可以智能的感知到只是文件名被修改，只需要一个git pull命令就可以解决。弹出弹窗可以直接保存退出，默认不变就行。\n","permalink":"https://lifeislife.cn/posts/git%E4%BB%96%E4%BA%BA%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E4%BA%86%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/","summary":"\u003cp\u003e用户一修改了文件名，并提交远端。\n\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272319842.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272319842.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e用户二修改了文件内容，也进行了推送，\n\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272320474.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272320474.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"Git 他人同时修改了文件名和文件内容该如何处理"},{"content":"不同人修改了文件的相同区域，如果向远端推送，肯定会被拒绝。这时候就需要解决冲突，\n\u003c!DOCTYPE html\u003e Responsive Image 首先拉取远端最新的代码，会提示有冲突的文件， \u003c!DOCTYPE html\u003e Responsive Image 打开冲突的文件，git 会对冲突区域进行标记，\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;到======区域表示远端的代码。======到\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;表示本地的代码。这时候就需要自己来判断需要哪些代码，也可以增删一些内容，修改完成后将这些标识符号删除，然后保存退出。 \u003c!DOCTYPE html\u003e Responsive Image git status查看当前状态，提示还有未合并的路径，需要进行commit操作。 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 及时git push当前代码。\n","permalink":"https://lifeislife.cn/posts/git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E7%9B%B8%E5%90%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%90%8C%E5%8C%BA%E5%9F%9F/","summary":"\u003cp\u003e不同人修改了文件的相同区域，如果向远端推送，肯定会被拒绝。这时候就需要解决冲突，\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272217729.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272217729.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"Git 不同人修改了相同文件的相同区域"},{"content":"保留现场 探究原因 查阅了一个网上的答案，大意就是，你删除了属于你的文件夹，但其中包含属于另一个用户的文件时，文件可能会卡住，就会在 Trash 目录里不会被彻底删除。\n解决方法 sudo rm -rv /home/\u0026lt;your_username\u0026gt;/.local/share/Trash/expunged/* PS：发现一个好用的磁盘分析工具，Linux 内置应用Disk Usage Analyzer。按Win键后搜索框搜索即可打开。\n图形化的方式快速找到占用空间较大的目录，文件。可以右击直接删除。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/linux%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E4%BB%8D%E7%84%B6%E5%9C%A8trash%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E8%AF%A5%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4trash%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e查阅了一个\u003ca href=\"https://askubuntu.com/questions/351400/deleting-contents-of-local-share-trash-expunged\"\u003e网上的答案\u003c/a\u003e，大意就是，你删除了属于你的文件夹，但其中包含属于另一个用户的文件时，文件可能会卡住，就会在 Trash 目录里不会被彻底删除。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo rm -rv /home/\u0026lt;your_username\u0026gt;/.local/share/Trash/expunged/*\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ePS：发现一个好用的磁盘分析工具，Linux 内置应用\u003ccode\u003eDisk Usage Analyzer\u003c/code\u003e。按\u003ccode\u003eWin\u003c/code\u003e键后搜索框搜索即可打开。\u003c/p\u003e","title":"Linux 文件删除仍然在 Trash 目录下占用空间，该如何删除 Trash 下的文件"},{"content":" 确定需要合并的commit \u003c!DOCTYPE html\u003e Responsive Image 变基操作，以需要合并的commit下方的结点为基准。 \u003c!DOCTYPE html\u003e Responsive Image 交互式变基，squash表示合并到上方commit \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 编写合并commit的message，保留原先的不变 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/git%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%A4%9A%E4%B8%AAcommit/","summary":"\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e确定需要合并的\u003ccode\u003ecommit\u003c/code\u003e\n\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242323497.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242323497.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e变基操作，以需要合并的\u003ccode\u003ecommit\u003c/code\u003e下方的结点为基准。\n\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242324125.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242324125.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"Git 如何合并连续的多个 commit"},{"content":" git fetch git merge 或者 git pull ","permalink":"https://lifeislife.cn/posts/git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egit fetch\u003c/code\u003e \u003ccode\u003egit merge\u003c/code\u003e\n或者\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit pull\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"Git 不同人修改了同一文件的不同区域该如何处理"},{"content":"以下操作仅限于维护自己的分支，不建议对团队共享的代码进行修改。\n以最近三次提交为例，假设想要修改第二个提交的message。可以使用git rebase命令 \u003c!DOCTYPE html\u003e Responsive Image git rebase -i 27d2f -i交互式变基 27d2f需要改变message的提交的父节点 \u003c!DOCTYPE html\u003e Responsive Image 弹出页面可以使用提供的命令进行操作，比如pick意思就是挑选需要的commit。本次任务需要修改message，从下方帮助文档里可以找到reword命令，可以保留commit，只修改message。\n\u003c!DOCTYPE html\u003e Responsive Image 保存退出后，会弹出另外一个界面。\n\u003c!DOCTYPE html\u003e Responsive Image 在这里就可以真正修改需要更新的message。保存退出即可。\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/git%E4%BF%AE%E6%94%B9%E8%80%81%E6%97%A7commit%E7%9A%84message/","summary":"\u003cp\u003e\u003cstrong\u003e以下操作仅限于维护自己的分支，不建议对团队共享的代码进行修改。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e以最近三次提交为例，假设想要修改第二个提交的\u003ccode\u003emessage\u003c/code\u003e。可以使用\u003ccode\u003egit rebase\u003c/code\u003e命令\n\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222255230.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222255230.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"Git 修改老旧 commit 的 message"},{"content":"commit提交后觉得描述信息不准确，想重新修改message内容，该如何操作？\ngit commit --amend 弹出页面就和git commit操作时的一样，将其改为新内容即可。\n","permalink":"https://lifeislife.cn/posts/git%E4%BF%AE%E6%94%B9%E6%9C%80%E6%96%B0commit%E7%9A%84message/","summary":"\u003cp\u003e\u003ccode\u003ecommit\u003c/code\u003e提交后觉得描述信息不准确，想重新修改\u003ccode\u003emessage\u003c/code\u003e内容，该如何操作？\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit commit --amend\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e弹出页面就和\u003ccode\u003egit commit\u003c/code\u003e操作时的一样，将其改为新内容即可。\u003c/p\u003e","title":"Git 修改最新 commit 的 message"},{"content":"保留现场 undefined reference to sleep同样的问题。 在使用 C 语言线程函数时，需要包含#include \u0026lt;pthread\u0026gt;，编译时就会报这种错误。\n探究原因 pthread 库不是 Linux 系统默认的库，连接时需要使用静态库 libpthread.a，所以在使用pthread_create()创建线程，以及调用pthread_atfork()函数建立fork处理程序时，需要链接该库。\n解决方法 gcc thread.c -o thread -lpthread 如果是Makefile配置的编译条件，在Makefile文件中加上如下：\nCFLAGS += -lpthread ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3c%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eundefined reference to sleep\u003c/code\u003e同样的问题。\n在使用 C 语言线程函数时，需要包含\u003ccode\u003e#include \u0026lt;pthread\u0026gt;\u003c/code\u003e，编译时就会报这种错误。\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003epthread\u003c/code\u003e 库不是 \u003ccode\u003eLinux\u003c/code\u003e 系统默认的库，连接时需要使用静态库 \u003ccode\u003elibpthread.a\u003c/code\u003e，所以在使用\u003ccode\u003epthread_create()\u003c/code\u003e创建线程，以及调用\u003ccode\u003epthread_atfork()\u003c/code\u003e函数建立\u003ccode\u003efork\u003c/code\u003e处理程序时，需要链接该库。\u003c/p\u003e","title":"解决 C 语言 undefined reference to pthread_join"},{"content":"保留现场 在运行中的界面上点击按钮没有效果，像是按钮上层有其他遮盖层。\n探究原因 widget的父控件上又添加了其他Widget，覆盖在了按钮上，因此无法点击。通过new得到的控件，默认显示在比它new的早的控件上面。\n解决方法 // 将有按钮的那一层widget置于上层 widget-\u0026gt;raise(); ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3qt%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%97%A0%E5%93%8D%E5%BA%94/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e在运行中的界面上点击按钮没有效果，像是按钮上层有其他遮盖层。\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ewidget\u003c/code\u003e的父控件上又添加了其他\u003ccode\u003eWidget\u003c/code\u003e，覆盖在了按钮上，因此无法点击。通过\u003ccode\u003enew\u003c/code\u003e得到的控件，默认显示在比它\u003ccode\u003enew\u003c/code\u003e的早的控件上面。\u003c/p\u003e","title":"解决 QT 点击按钮无响应"},{"content":"保留现场 在新窗口中的构造函数中添加控件运行后却没有显示\n探究原因 新建的工程师 MainWindow 子类工程，没有设置父窗口。\n没有将控件的父窗口设置成自己定义的 widget。\n#include\u0026lt;QMainWindow\u0026gt; QMainWindow::QMainWindow(QMainWindow*parent) : QMainWindow(parent), ui(new Ui::QMainWindow) { ui-\u0026gt;setupUi(this); QPushButton* button_1 = new QPushButton(\u0026#34;add\u0026#34;); QPushButton* button_1 = new QPushButton(\u0026#34;del\u0026#34;); } 解决方法 方法 1：给按钮控件设置父窗口：QWidget，并且把按钮添加到父窗口中。\n#include\u0026lt;QMainWindow\u0026gt; #include\u0026lt;QPushButton\u0026gt; #include\u0026lt;QHBoxLayout\u0026gt; QMainWindow::QMainWindow(QMainWindow*parent) : QMainWindow(parent), ui(new Ui::QMainWindow) { ui-\u0026gt;setupUi(this); QWidget* w = new QWidget(); this-\u0026gt;setCentralWidget(w); QHBoxLayout* hLayout = new QHBoxLayout(); QPushButton* button_1 = new QPushButton(\u0026#34;add\u0026#34;); QPushButton* button_1 = new QPushButton(\u0026#34;del\u0026#34;); hLayout-\u0026gt;addWidget(button_1); hLayout-\u0026gt;addWidget(button_2); w-\u0026gt;setLayout(hLayout); } 方法 2：手动指定父窗口\n#include\u0026lt;QMainWindow\u0026gt; #include\u0026lt;QPushButton\u0026gt; #include\u0026lt;QHBoxLayout\u0026gt; QMainWindow::QMainWindow(QMainWindow*parent) : QMainWindow(parent), ui(new Ui::QMainWindow) { ui-\u0026gt;setupUi(this); QPushButton* button_1 = new QPushButton(\u0026#34;add\u0026#34;); QPushButton* button_1 = new QPushButton(\u0026#34;del\u0026#34;); button_1-\u0026gt;setParent(this); button_2-\u0026gt;setParent(this); button_2-\u0026gt;move(300,100); } ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3qt%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%86%99%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e在新窗口中的构造函数中添加控件运行后却没有显示\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e新建的工程师 MainWindow 子类工程，没有设置父窗口。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e没有将控件的父窗口设置成自己定义的 widget。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u0026lt;QMainWindow\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eQMainWindow\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eQMainWindow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eQMainWindow\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eparent\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eQMainWindow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eparent\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eui\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eUi\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eQMainWindow\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     \u003cspan class=\"n\"\u003eui\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esetupUi\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     \u003cspan class=\"n\"\u003eQPushButton\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ebutton_1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eQPushButton\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;add\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     \u003cspan class=\"n\"\u003eQPushButton\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ebutton_1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eQPushButton\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;del\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e方法 1：给按钮控件设置父窗口：QWidget，并且把按钮添加到父窗口中。\u003c/p\u003e","title":"解决 QT 在构造函数中写的控件不显示的问题"},{"content":"保留现场 手动执行update()或者repaint()都不能执行paintEvent函数。\n探究原因 如果是代码new出来的控件，检查是否正确显示，比如有没有加入到layout中。或者有没有设置父窗口（可能被其他空间遮挡）。\n检查控件width或者height大小是否不为 0。如果为 0，也不会出出发paintEvent。\n解决方法 参考 QT 在构造函数中写的控件不显示\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3qwidget%E4%B8%ADupdate%E4%B8%8D%E6%89%A7%E8%A1%8Cpaintevent/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e手动执行\u003ccode\u003eupdate()\u003c/code\u003e或者\u003ccode\u003erepaint()\u003c/code\u003e都不能执行\u003ccode\u003epaintEvent\u003c/code\u003e函数。\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e如果是代码\u003ccode\u003enew\u003c/code\u003e出来的控件，检查是否正确显示，比如有没有加入到\u003ccode\u003elayout\u003c/code\u003e中。或者有没有设置父窗口（可能被其他空间遮挡）。\u003c/p\u003e","title":"QWidget 中 update 不执行 paintEvent"},{"content":"保留现场 QVector\u0026lt;uint32_t\u0026gt; buttonPins(3); 声明了一个长度为 3 的vector数组，编译是会报这个错误。\n探究原因 编译器可能无法区分这是一个成员函数声明还是一个成员变量声明，也就是产生歧义。\n解决方法 方法 1：\nQVector\u0026lt;uint32_t\u0026gt; buttonPins = QVector\u0026lt;uint32_t\u0026gt;(3);//明确这是一个成员变量 方法 2：默认构造函数里面进行成员变量的初始化\nMainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow),buttonPins(3){} 方法 3：列表初始化\nQVector\u0026lt;uint32_t\u0026gt; buttonPins{0, 0, 0}; ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3c-%E4%B8%ADvector%E5%A3%B0%E6%98%8E%E9%94%99%E8%AF%AFexpected-parameter-declarator/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eQVector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003euint32_t\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ebuttonPins\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e声明了一个长度为 3 的\u003ccode\u003evector\u003c/code\u003e数组，编译是会报这个错误。\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e编译器可能无法区分这是一个成员函数声明还是一个成员变量声明，也就是产生歧义。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e方法 1：\u003c/p\u003e","title":"解决 C++中 vector 声明错误 expected parameter declarator"},{"content":"保留现场 比如在一个枚举类型中，会告诉你某行有这种错误。又或者，在一个宏定义语句中出现这种错误。\n探究原因 一般来说，出现这种情况，是语句中有些定义的名字发生了冲突。\n解决方法 定位错误位置，搜索是否有同名的函数，变量等等。改个名字。\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3expected-identifier-before---token/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e比如在一个枚举类型中，会告诉你某行有这种错误。又或者，在一个宏定义语句中出现这种错误。\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e一般来说，出现这种情况，是语句中有些定义的名字发生了冲突。\u003c/p\u003e","title":"解决 expected identifier before‘(’token"},{"content":"QEMU 模拟外设的原理 QEMU 主要是实现了 CPU 核的模拟，可以读写某个地址。 QEMU 的模拟外设的原理很简单：硬件即内存。 要在 QEMU 上模拟某个外设，思路就是：\nCPU 读某个地址时，QEMU 模拟外设的行为，把数据返回给 CPU CPU 写某个地址时，QEMU 获得数据，用来模拟外设的行为。 即：要模拟外设备，我们只需要针对外设的地址提供对应的读写函数即可。 以 GPIO 为例：\n\u003c!DOCTYPE html\u003e Responsive Image QEMU 为GPIO内存地址提供读写回调函数，\nstatic void sifive_gpio_write(void *opaque, hwaddr offset, uint64_t value, unsigned int size) static uint64_t sifive_gpio_read(void *opaque, hwaddr offset, unsigned int size) 给外设地址提供读写函数 怎么描述某段地址：基地址、大小？如何给这段地址提供读写函数呢？这段地址设置好后，如何添加进system_memory去？有 2 种方法。\n法 1：memory_region_init_io/memory_region_add_subregion 以SIFIVE_UART为例，\nmemory_region_init_io(\u0026amp;s-\u0026gt;mmio, NULL, \u0026amp;uart_ops, s, TYPE_SIFIVE_UART, 0x2000); memory_region_add_subregion(address_space, base, \u0026amp;s-\u0026gt;mmio); memory_region_init_io函数初始化iomem，读写函数，大小。 memory_region_add_subregion函数s-\u0026gt;iomem指定了基地址，并添加进system_memory中。 以后，客户机上的程序读写这块地址时，就会导致对应的读写函数被调用。\n法 2：memory_region_init_io/sysbus_init_mmio/sysbus_mmio_map 以SIFIVE_GPIO为例，\nmemory_region_init_io(\u0026amp;s-\u0026gt;mmio, OBJECT(dev), \u0026amp;gpio_ops, s, TYPE_SIFIVE_GPIO, SIFIVE_GPIO_SIZE); sysbus_init_mmio(SYS_BUS_DEVICE(dev), \u0026amp;s-\u0026gt;mmio); memory_region_init_io函数初始化iomem，读写函数，大小。 sysbus_init_mmio将mmin传给设备；\nsysbus_mmio_map(SYS_BUS_DEVICE(\u0026amp;s-\u0026gt;gpio), 0, memmap[SIFIVE_E_DEV_GPIO0].base); sysbus_mmio_map从设备中吧mmio添加进system_memory并指定基地址。\n","permalink":"https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%A4%96%E8%AE%BE%E6%A8%A1%E6%8B%9F%E4%BB%A5gpio%E4%B8%BA%E4%BE%8B/","summary":"\u003ch2 id=\"qemu-模拟外设的原理\"\u003eQEMU 模拟外设的原理\u003c/h2\u003e\n\u003cp\u003eQEMU 主要是实现了 CPU 核的模拟，可以读写某个地址。\nQEMU 的模拟外设的原理很简单：\u003cstrong\u003e硬件即内存\u003c/strong\u003e。\n要在 QEMU 上模拟某个外设，思路就是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCPU 读某个地址时，QEMU 模拟外设的行为，把数据返回给 CPU\u003c/li\u003e\n\u003cli\u003eCPU 写某个地址时，QEMU 获得数据，用来模拟外设的行为。\n即：要模拟外设备，我们只需要针对外设的地址提供对应的读写函数即可。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e以 GPIO 为例：\u003c/p\u003e","title":"QEMU 源码分析-外设模拟（以 GPIO 为例）"},{"content":"QOM 简介 QOM(QEMU Object Model) 是 QEMU 的一个模块，用于描述虚拟机的结构，包括虚拟机的 CPU、内存、硬盘、网络、输入输出设备等。QEMU 为了方便整个系统的构建，实现了自己的一套的面向对象机制，也就是 QOM(QEMU Object Model)。它能够方便的表示各个设备（Device）与总线（Bus）之间的关系。\n这个模型主要包含四个结构体：\nObject: 是所有对象的 基类 Base Object ObjectClass: 是所有类对象的基类 TypeInfo：是用户用来定义一个 Type 的工具型的数据结构 TypeImpl：TypeInfo 抽象数据结构，TypeInfo 的属性与 TypeImpl 的属性对应 在 QEMU 里要初始化一个对象需要完成四步：\n将 TypeInfo 注册 TypeImpl 实例化 Class（ObjectClass） 实例化 Object 添加 Property \u003c!DOCTYPE html\u003e Responsive Image 如何描述硬件 一个板子上有很多硬件：芯片，LED、按键、LCD、触摸屏、网卡等等。芯片里面也有很多部件，比如 CPU、GPIO、SD 控制器、中断控制器等等。\n这些硬件，或是部件，各有不同。怎么描述它们？\n每一个都使用一个 TypeInfo 结构体来描述，TypeInfo 是用户用来定义一个 Type 的工具型的数据结构。它包含了很多成员变量，这些成员合在一起描述了一个设备类型。\n// include/qom/object.h struct TypeInfo { const char *name; const char *parent; size_t instance_size; size_t instance_align; void (*instance_init)(Object *obj); void (*instance_post_init)(Object *obj); void (*instance_finalize)(Object *obj); bool abstract; size_t class_size;\u000bvoid (*class_init)(ObjectClass *klass, void *data); void (*class_base_init)(ObjectClass *klass, void *data); void *class_data;\u000bInterfaceInfo *interfaces; }; 这个结构体我们在刚刚也提到，他在图里是独立的，在注册的时候会将它的信息都传给 Typeimpl 结构体。\n我们以 Timer 为例，我们要添加一个 Timer 外设，首先就要定义一个 Typeinfo 结构体。他在代码中像这样。我们只看 name，这里用一个宏赋值，这个宏是个我们定义的字符串，它唯一标识了这个硬件。这些结构体在运行时会被注册进程序里，保存在一个链表中备用，为什么是备用，因为不是每一个硬件都会被用到。\n// hw/timer/dw_timer.c static const TypeInfo dw_timer_info = { .name = TYPE_DW_TIMER, .parent = TYPE_SYS_BUS_DEVICE, .instance_size = sizeof(DWTimerState), .instance_init = dw_timer_init, .class_init = dw_timer_class_init, }; 这些结构体在运行时会被注册进程序里，保存在一个链表中备用，为什么是备用，因为不是每一个硬件都会被用到。\n如何注册硬件 什么是注册，说白了就是将一些可能需要的信息添加到系统中，在系统运行时能够随时调用到。就拿 Timer 来说，现在将一些信息添加到了列表，系统运行起来时我可以随时从链表中取出 Timer 这个设备的信息，用来实例化一个 Timer，但是我没有注册 Timer，也就是没有将其加入到链表，那我后期就无法找到它。\n怎么注册这些TypeInfo结构体呢？在实现的源码中有这个函数 dw_timer_register_types()，他是用来注册 Timer 这个设备的。\n我们追根溯源，调用过程如下，\n\u003c!DOCTYPE html\u003e Responsive Image 分配一个 TypeImpl 结构体，使用 Typeinfo 来设置它 把 TypeImpl 加入链表：type_table 在 QEMU 里面，有一个全局的哈希表 type_table，用来存放所有定义的类。在 type_new 里面，我们先从全局表里面根据名字 type_table_lookup 查找找这个类。\n如果找到，说明这个类曾经被注册过，就报错； 如果没有找到，说明这是一个新的类，则将 Typeinfo 里面信息填到 TypeImpl 里面。type_table_add 会将这个类注册到全局的表里面。 \u003c!DOCTYPE html\u003e Responsive Image 以上的过程可以用上图来表示。Typeinfo 通过 type_new() 生成一个对应的 TypeImpl 类型，并以 name 为关键字添加到名为 type_table 的一个 hash table 中。\n什么时候注册这些设备呢？不需要我们去调用注册函数，以 Timer 为例，在 hw/timer/dw_timer.c 中有如下代码，一般在最后一行：\ntype_init(dw_timer_register_types) F12找到这个宏定义，我们追根溯源，调用过程如下\ntype_init() -\u0026gt; module_init() -\u0026gt; register_module_init() type_init(dw_timer_register_types) #define type_init(function) module_init(function, MODULE_INIT_QOM) #define module_init(function, type) \\ static void __attribute__((constructor)) do_qemu_init_ ## function(void) \\ { \\ register_module_init(function, type); \\ } void register_module_init(void (*fn)(void), module_init_type type) { ModuleEntry *e; //构造 ModuleEntry ModuleTypeList *l; //构造链表 e = g_malloc0(sizeof(*e)); e-\u0026gt;init = fn; //设置初始化函数，fn 即 sifive_gpio_register_types e-\u0026gt;type = type; l = find_type(type); QTAILQ_INSERT_TAIL(l, e, node);//将 ModuleEntry 插入链表尾 } type_init是个宏定义，调用了__attribute__((constructor))函数，我们知道这个 C 语言中位数不多的在main函数执行前，执行的函数。函数中调用了register_module_init注册函数，说明在main函数执行前，已经注册好硬件了。该函数将一个新的ModuleEntry加到链表里。\n注意，注册的只是个函数，并不是注册了设备。也就是已上过程，只是把一个 ModuleEntry 放到了一个链表里，这个 ModuleEntry 带了两个信息，一个是函数，一个是类型。这个函数就是我们真正的注册注册函数。\n已上过程大概是如下所示：\n\u003c!DOCTYPE html\u003e Responsive Image 那什么时候还真正注册设备呢，我们就得回到主函数，它有以下调用流程，在 module_call_init 中，我们会找到 MODULE_INIT_QOM 这种类型对应的 ModuleTypeList 找出列表中所有的 ModuleEntry，然后调用每个 ModuleEntry 的 init 函数。\n\u003c!DOCTYPE html\u003e Responsive Image // softmmu/runstate.c module_call_init(MODULE_INIT_QOM); // utils/module.csoftmmu/runstate.c void module_call_init(module_init_type type) { ModuleTypeList *l; ModuleEntry *e; // 找到 MODULE_INIT_QOM 这种类型对应的 ModuleTypeList l = find_type(type); QTAILQ_FOREACH(e, l, node) { e-\u0026gt;init(); } } 初始化设备 到这里我们需要注意，我们在注册设备的时候虽然将设备从 Typeinfo 变成了 TypeImpl，把 Typeinfo 里的信息都复制到了 TypeImpl，但是 class_init 还没有被调用，也即这个类现在还处于纸面的状态。\n什么时候才真正初始化这个类呢，这得等在用到它的时候。我们在一块板子上才会用到一个设备。我们使用的是 Sifive-e 这个板子，准确来说我们用的不是这个板子，我们只是在原先的代码上做了修改。\n为了方便描述，就当是用的 sifive-e 这个板子。在实现的源码里，有 object_initialize_child函数，跟踪一下调用流程可以看到最后在 type_initialize 函数中初始化了类。同时我们也看到在 object_init_with_type 函数中实例化了类。这个稍后再讲。\n// hw/riscv/sifive_e.c\u000bstatic void sifive_e_soc_init(Object *obj) { MachineState *ms = MACHINE(qdev_get_machine()); SiFiveESoCState *s = RISCV_E_SOC(obj); . . . object_initialize_child(obj, \u0026#34;timer\u0026#34;, \u0026amp;s-\u0026gt;timer, TYPE_DW_TIMER); } object_initialize_child(obj, name, \u0026amp;s-\u0026gt;timer, TYPE_DW_TIMER); object_initialize_child_internal() object_initialize_child_with_props() object_initialize_child_with_propsv() object_initialize() object_initialize_with_type() type_initialize() { if (ti-\u0026gt;class_init) { ti-\u0026gt;class_init(ti-\u0026gt;class, ti-\u0026gt;class_data); } } object_init_with_type() { if (ti-\u0026gt;instance_init) { ti-\u0026gt;instance_init(obj); } } 在调用 class_init 函数时，其实就是调用的设备模块下的 dw_timer_class_init，这个函数中又是一些配置，尤其是 realize 函数的配置。还有一些属性的配置，如 Timer 的频率。\n到这里，我们才有有了一个真正意义上的设备类。\nhw/timer/dw_timer.c static void dw_timer_class_init(ObjectClass *klass, void *data) { // 这里又是一些配置，尤其是回调函数的配置 DeviceClass *dc = DEVICE_CLASS(klass); dc-\u0026gt;reset = dw_timer_reset; // 设置 Timer 基本属性如频率等 device_class_set_props(dc, dw_timer_properties); dc-\u0026gt;vmsd = \u0026amp;vmstate_dw_timer; dc-\u0026gt;realize = dw_timer_realize; } 实例化设备 说白了初始化过程就是在配置各种结构体成员的过程，比如刚刚的初始化过程就是在配置 DeviceClass 这个类的各个成员。实际上我们还没有真正实例化 Timer，我们还不能使用它。\n我们只有在实例化后才能使用它，也就是之前提到的 instance_init()。但是在 QEMU 中要实例化一个设备，不仅仅需要调用 instance_init，还需要调用刚刚初始化时设置的 realize 函数。\nstatic const TypeInfo dw_timer_info = { .name = TYPE_DW_TIMER, .parent = TYPE_SYS_BUS_DEVICE, .instance_size = sizeof(DWTimerState), .instance_init = dw_timer_init, .class_init = dw_timer_class_init, }; // hw/timer/dw_timer.c static void dw_timer_init(Object *obj) { DWTimerState *s = DWTIMER(obj); // 为这段内存注册回调函数 memory_region_init_io(\u0026amp;s-\u0026gt;iomem, obj, \u0026amp;dw_timer_ops, s, \u0026#34;dw_timer\u0026#34;, 0x2000); sysbus_init_mmio(SYS_BUS_DEVICE(obj), \u0026amp;s-\u0026gt;iomem); } 这两个函数的功能很像，具体细节差异我也还没弄明白，但是需要注意的是 instance_init 一定要在 realize 之前完成，并且没有错误。否则将无法完成实例化。\n// hw/timer/dw_timer.c static void dw_timer_realize(DeviceState *dev, Error **errp) { DWTimerState *s = DWTIMER(dev); sysbus_init_irq(SYS_BUS_DEVICE(dev), \u0026amp;s-\u0026gt;irq); for (int i = 0; i \u0026lt; n; i++) { s-\u0026gt;timer[i] = timer_new_ns(QEMU_CLOCK_VIRTUAL, dw_timer_interrupt, s); } } instance_init 这个函数主要完成的工作就是为一段内存绑定了读写函数，为什么要这么做，我们再往下看。\n如何操作设备 设备创建完成了，那 QEMU 是如何模拟设备的行为的？这也是 QEMU 驱动开发最重要的一步，因为以上的部分是实现设备所必须的，我们只需要参考其他已经实现的模块，修改成我们的信息即可。\n但是每个 IP 的寄存器不同，他们的功能也就不同，这是我们真正需要实现的内容。我们知道写驱动其实就是操作各个 IP 的寄存器，以实现想要的功能。对应到 QEMU 中，就成了在操作各个寄存器时，我们要在 QEMU 中将驱动寄存器的功能先模拟出来，再返回给驱动程序。\n以 Timer 为例我想要获取 TimerNLoadCount 的值，真实硬件有这个寄存器保存了值，但是 QEMU 上我们就得维护一个变量去保存这个值。在需要的时候能读取到。比如代码里比较重要的参数是 offset，这个参数是基于外设基地址的偏移，其实就是寄存器的偏移量。比如我们查看 Timer 的手册，TimerNLoadCount 偏移量为 0，所以当我们在驱动中读取地址为 0x2000000 时，代码就会走到这里，因为我们维护了一个 timer_n_load_count 变量，所以我直接将这个变量当前值返回即可，这就是这个寄存器的值。我们要写这个寄存器也同理，我们需要更新 timer_n_load_count 这个变量。\n// hw/timer/dw_timer.c static uint64_t dw_timer_read(void *opaque, hwaddr offset, unsigned size) { DWTimerState *s = opaque; int index = 0; switch (offset) { case TimerNLoadCount: case 1*0x14: case 2*0x14: index = offset / 0x14; return s-\u0026gt;timer_n_load_count[index]; . . . } static void dw_timer_write(void *opaque, hwaddr offset, uint64_t val64, unsigned size) { DWTimerState *s = opaque; uint32_t value = val64; int index = 0; int change = 0;\u000bswitch (offset) { case TimerNLoadCount: case 1*0x14: case 2*0x14: index = (offset) / 0x14; s-\u0026gt;timer_n_load_count[index] = value; set_alarm_time(s,index); return; . . . } 读写函数写好了，需要给谁调用呢。我们刚刚提到了，这是个回调函数，我们需要给一段内存注册这个回调函数。如代码所示。我们给 Timer iomem 绑定了读写函数。具体哪一段地址还没定，但是我们定了 0x2000 这么长一段。我觉得这里应该是最高位的一个寄存器偏移量。因为再高就没啥用了，或者就是 SoC 里定的寄存器空间大小 0x1000。这里应该是为了图省事写的一个值。\n// hw/timer/dw_timer.c static const MemoryRegionOps dw_timer_ops = { .read = dw_timer_read, .write = dw_timer_write, .endianness = DEVICE_NATIVE_ENDIAN, }; static void dw_timer_init(Object *obj) { DWTimerState *s = DWTIMER(obj); // 为这段内存注册回调函数 memory_region_init_io(\u0026amp;s-\u0026gt;iomem, obj, \u0026amp;dw_timer_ops, s, \u0026#34;dw_timer\u0026#34;, 0x2000); sysbus_init_mmio(SYS_BUS_DEVICE(obj), \u0026amp;s-\u0026gt;iomem); } 下面在hw/riscv/sifive_e.c里会映射寄存器空间到 QEMU 的内存空间。\n// hw/riscv/sifive_e.c sysbus_mmio_map(SYS_BUS_DEVICE(\u0026amp;s-\u0026gt;timer), 0, memmap[SIFIVE_E_DEV_TIMER].base); 参考 QEMU 中基于 QOM 的 VFIO 类的定义 - EwanHai - 博客园 ","permalink":"https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9F%E5%A4%96%E8%AE%BE%E5%88%9B%E5%BB%BA/","summary":"\u003ch1 id=\"qom-简介\"\u003eQOM 简介\u003c/h1\u003e\n\u003cp\u003eQOM(QEMU Object Model) 是 QEMU 的一个模块，用于描述虚拟机的结构，包括虚拟机的 CPU、内存、硬盘、网络、输入输出设备等。QEMU 为了方便整个系统的构建，实现了自己的一套的面向对象机制，也就是 QOM(QEMU Object Model)。它能够方便的表示各个设备（Device）与总线（Bus）之间的关系。\u003c/p\u003e","title":"QEMU 源码分析 - 虚拟外设创建"},{"content":"公司的也在用 git，但是账号和地址肯定都不同，需要配置两个不同的提交环境。\n生成两个 Key 生成第一个 Key 如果电脑上已经在用 Git 了就无需重新生成 key，用当前的就可以。key 保存在~/.ssh文件夹内。\n如果第一次使用，就使用以下命令重新生成：\n➜ .ssh ssh-keygen -t rsa -C home_pc Generating public/private rsa key pair. Enter file in which to save the key (/home/dominic/.ssh/id_rsa): id_rsa_pc home_pc就是个备注名，假设我们这个 key 是平时捣腾 GitHub 玩，用来和 GitHub 同步用的，id_rsa_pc是生成的文件名，打开id_rsa_pc.pub可以看到生成的 key 最后就是备注名（如下）。\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABR/Fyj7Pz+e+/////////////////ZbdPGtHB86fLQYh/uR+TKcCERedrDKzGPdVt8= home_pc 配置 GitHub SSH 路径为：\nGithub-头像-settings-SSH and GPG keys-New SSH key 测试连通 ssh -T git@github.com 生成第二 Key 这个 key 就打算用来和公司代码同步用，所以备注名换成了work_ubuntu，文件名也换成了id_rsa_work。\n➜ .ssh ssh-keygen -t rsa -C work_ubuntu Generating public/private rsa key pair. Enter file in which to save the key (/home/dominic/.ssh/id_rsa): id_rsa_work 配置公司 SSH 和 GitHub 类似，根据自己公司使用的平台设置。\n配置本地账户 因为本地的代码仓库可能是从 GitHub 下载的，也有从公司仓库下载的。那么提交代码时就需要为仓库配置指定的用户名和邮箱。以前只有一个 GitHub，所以配置时使用的是-global参数，任何一个仓库都是配置的相同的用户名与邮箱，而现在需要区分。\n取消全局配置 # 取消全局 用户名/邮箱 配置 git config --global --unset user.name git config --global --unset user.email 单独配置代码仓 进入项目目录，有.git目录的那一级。\n# 单独设置每个repo 用户名/邮箱 git config user.email “xxxx@xx.com” git config user.name “xxxx” ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E4%B8%A4%E4%B8%AAgit%E8%B4%A6%E6%88%B7/","summary":"\u003cp\u003e公司的也在用 git，但是账号和地址肯定都不同，需要配置两个不同的提交环境。\u003c/p\u003e\n\u003ch2 id=\"生成两个-key\"\u003e生成两个 Key\u003c/h2\u003e\n\u003ch3 id=\"生成第一个-key\"\u003e生成第一个 Key\u003c/h3\u003e\n\u003cp\u003e如果电脑上已经在用 Git 了就无需重新生成 key，用当前的就可以。key 保存在\u003ccode\u003e~/.ssh\u003c/code\u003e文件夹内。\u003c/p\u003e","title":"解决一台电脑配置两个 GIT 账户"},{"content":"C 语言常常因为声明的语法问题而受到人们的批评，特别是涉及到函数指针的语法。C 语言的语法力图使声明和使用相一致。对于简单的情况，C 语言的做法是很有效的，但是，如果情况比较复杂，则容易让人混淆，原因在于，C 语言的声明不能从左至右阅读，而且使用了太多的圆括号。 在 C 中，声明的形式为（dcl 是 declaration 的简写）：\ndcl: optional *\u0026#39;s direct-dcl（含有可选\u0026#34;*\u0026#34;的direct-dcl） direct-dcl name (dcl) direct-dcl() direct-dcl[optional size] 简而言之，声明符dc1(可以理解成间接声明) 就是前面可能带有多个*的direcr-dclo。direct-dcl可以是name、由一对圆括号括起来的dcl、后面跟有一对圆括号的direct-dcl、后面跟有用方括号括起来的表示可选长度的direc-dcl。\n根据该规则进行逆向解析，就可以得到正确的声明。简化一下：TypeName Declarator;其中，Declarator就是声明中的那个name。当你遇到任何你不能理解的声明时，这个法则就是救命稻草。最简单的例子：\nint aInt; 这里，int是TypeName，aInt是Declarator。\n再说明一下结合紧密度。在声或定义变量时，可以使用一些修饰比如*，[]，()等。()（非函数声明中的()）具有最高的紧密度，其次才是函数和数组的()和[]。\n没有*的声明称为直接声明（direct-dcl），而有*称为声明（dcl）。直接声明要比声明结合的紧。分解声明时，先读出结合紧的。在这里，我把direct-dcl称为更紧的结合，它比dcl结合得紧。\n最后，需要你用英语来读出这个声明。对于[]，应该读成array of。\n对于复杂的定义，可以将其分解。比如T (*p)()可以分解成T D1()，D1读作：function returning T。其中D1是*p。那么该声明应该读成：p is a poniter to。二者合在一起，就变成了 p is a pointer to function returning T，即：p是指向返回T类对象的函数的指针。\n再看一个稍微复杂的示例：\nT (*pfa[])(); 根据dcl和direct-dcl，可以分解成T1 D1（因为结合紧密度），T1也就是T ()，那么应该读作： D1 is function returning T。\nD1又可以写成T2 D2，其中T2是T1 []，可以分解成T1 D2[]，读作：array of D2 function returning T。\nD2是指针，读作：pointers to。那么整个 T (*pfa[])() 应该读作：pfa is an array of pointers to function returning T，即：pfa是个存放指向返回 T 类对象函数的指针的数组。\n换种方式看，在这个例子中，pfa是名字，T(*[])()是类型。将(*pfa[])视为一体（direct-dcl），称为D1，那么可以写成T D1()，function returning object of T。在D1中，将*pfa视为一体（dcl），称为D2，那么*pfa[]应该是D2[]（direct-dcl），array of D2。合起来就是 array of D2 function returning object of T。D2是*pfa（dcl），替换到前面这句话，结果就是 array of pointers to function returning object of T。\n有了这些说明，可以试着做一下下面的题，看看自己是否真的理解了：\nchar **argv // argv: pointer to pointer to char // 指向 char 型指针的指针 int (*daytab)[13] // daytab: pointer to array[13] of int // 指向 int 型数组的指针 int *daytab[13] // daytab: array[13] of pointer to int // 存放 int 型指针的数组 void *comp() // comp: function returning pointer to void // 返回值为指向 void 型指针的函数 void (*comp)() // comp: pointer to function returning void // 指向返回值为 void 型函数的指针 char (*(*x())[])() // x: function returning pointer to array[] of // pointer to function returning char // 返回值为 char 型的函数 char (*(*x[3])())[5] // x: array[3] of pointer to function returning // pointer to array[5] of char 理解复杂声明可用的“右左法则”：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：\nint (*func)(int *p); 首先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int*类型的形参，返回值类型是int。\nint (*func[5])(int *); func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int*类型的形参，返回值类型为int。\n在 C++中，规则比 C 要复杂一些。不过，基本思想保持不变，按照 C 的原则来理解复杂的声明，基本上就能满足要求了。没有在这里列出 C++的规则一方面是因为太广，不能覆盖全；另一个原因就是，按照 C 的规则来就足够了，毕竟 C++要与 C 兼容。\n","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/","summary":"\u003cp\u003eC 语言常常因为声明的语法问题而受到人们的批评，特别是涉及到函数指针的语法。C 语言的语法力图使声明和使用相一致。对于简单的情况，C 语言的做法是很有效的，但是，如果情况比较复杂，则容易让人混淆，原因在于，C 语言的声明不能从左至右阅读，而且使用了太多的圆括号。\n在 C 中，声明的形式为（dcl 是 declaration 的简写）：\u003c/p\u003e","title":"C 语言复杂声明"},{"content":"完整代码详见GitHub CyclicBuffer。\n什么是循环缓冲区 \u003c!DOCTYPE html\u003e Responsive Image 循环缓冲区通常应用在模块与模块之间的通信，可以减少程序挂起的时间，节省内存空间。\n如图所示，蓝色箭头表示读取指针，红色表示写入指针。写入指针可以在缓冲区有剩余空间时不中断地写入数据，读取指针可以在循环缓冲区有数据时不停读取。\n如何设计循环缓冲区 为了方便两个进程之间的通信，我们在共享内存中创建循环缓冲区。基本原理如图：\n\u003c!DOCTYPE html\u003e Responsive Image 结构体定义 typedef struct CyclicBuffer { uint8_t buf[CYCBUFFSIZ]; //缓冲区 uint8_t read; //读指针 uint8_t write; //写指针 uint32_t valid_size; //已写入数据数 } CyCBuf; 写入数据 void cycbuff_write(CyCBuf *cycbuff, uint8_t ch) { while (cycbuff_isfull(cycbuff)) ; cycbuff-\u0026gt;buf[cycbuff-\u0026gt;write] = ch; cycbuff-\u0026gt;write++; cycbuff-\u0026gt;write %= CYCBUFFSIZ; cycbuff-\u0026gt;valid_size++; } 写入数据前，要检查缓冲区是否已满，如果已满就得挂起等待。直到缓冲区有空间再进行写入。\n写入指针每次写完向后偏移一位，valid_size记录当前缓冲区中有效数据个数。\n读取数据 uint8_t cycbuff_read(CyCBuf *cycbuff) { uint8_t ch; while (cycbuff_isempty(cycbuff)) ; ch = cycbuff-\u0026gt;buf[cycbuff-\u0026gt;read]; cycbuff-\u0026gt;read++; cycbuff-\u0026gt;read %= CYCBUFFSIZ; cycbuff-\u0026gt;valid_size--; return ch; } 读取数据前，要检查缓冲区是否为空，如果为空就要挂起等待。\n判断空 bool cycbuff_isempty(CyCBuf *cycbuff) { if (cycbuff-\u0026gt;valid_size == 0) return true; return false; } 判断满 bool cycbuff_isfull(CyCBuf *cycbuff) { if (cycbuff-\u0026gt;valid_size == CYCBUFFSIZ) return true; return false; } 本次实验中，为了方便期间，用valid_size保存有效数据个数，没有用读写指针是否重合来判断，这就无需再考虑读写指针重合时，是空还是满。\n数据收发流程 服务端 - 写入 void server(CyCBuf *cycbuff, SHMS *shms) { cycbuff_init(cycbuff); while (1) { puts(\u0026#34;Enter Message: \u0026#34;); uint8_t ch[BUFFERSIZE]; fgets(ch, BUFFERSIZE, stdin); for (size_t i = 0; ch[i] != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; i \u0026lt; BUFFERSIZE; i++) { cycbuff_write(cycbuff, ch[i]); } cycbuff_write(cycbuff, \u0026#39;\\n\u0026#39;); } exit(0); } SHMS *shms为共享内存相关数据，有关共享内存的使用可以参考进程间通信（IPC）之共享内存（SharedMemory）。\n客户端 - 读取 void client(CyCBuf *cycbuff, SHMS *shms) { printf(\u0026#34;Server operational: shm id is %d\\n\u0026#34;, shms-\u0026gt;shmid); while (1) { uint8_t ch; puts(\u0026#34;Recv Message: \u0026#34;); while (1) { ch = cycbuff_read(cycbuff); if (ch == \u0026#39;\\n\u0026#39;) { printf(\u0026#34;\\n\u0026#34;); break; } fflush(stdout); printf(\u0026#34;%c\u0026#34;, ch); } } } 读取数据以回车符为分界，当读到回车符时进行换行处理，并等待接收下一波数据。\n实验结果 \u003c!DOCTYPE html\u003e Responsive Image Reference Circular buffer\n","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0cyclicbuffer%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA/","summary":"\u003cp\u003e完整代码详见\u003ca href=\"https://github.com/Dunky-Z/learning-linux/tree/main/helloworld/c/CyclicBuffer\"\u003eGitHub CyclicBuffer\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"什么是循环缓冲区\"\u003e什么是循环缓冲区\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211021171456.gif\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211021171456.gif\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e循环缓冲区通常应用在模块与模块之间的通信，可以减少程序挂起的时间，节省内存空间。\u003c/p\u003e","title":"C 语言共享内存实现 CyclicBuffer 循环缓冲区"},{"content":"保留现场 使用scanf()获取输入时，因为涉及键盘缓冲区的问题，每次输入后想要把缓冲清空，但是在 gcc 编译后，使用fflush无法清空缓冲区。\n探究原因 C 标准 (ISO/IEC 9899:1999 standard) 规定fflush(stdin)操作是未定义的\u0026lt;参看《ISO/IEC 9899:1999 standard》p270\u0026gt;;。也就是说不一定能实现刷新功能，但有的编译器可能不遵循标准，对fflush(stdin)操作不予警告，并且有时可能产生正确的结果，但最好不要这样使用。\n解决方法 通过 while 循环把输入流中的余留数据“吃”掉：\nint c; while ((c=getchar()) != ‘\\n’ \u0026amp;\u0026amp; c != EOF); ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e使用\u003ccode\u003escanf()\u003c/code\u003e获取输入时，因为涉及键盘缓冲区的问题，每次输入后想要把缓冲清空，但是在 gcc 编译后，使用\u003ccode\u003efflush\u003c/code\u003e无法清空缓冲区。\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003eC 标准 (ISO/IEC 9899:1999 standard) 规定\u003ccode\u003efflush(stdin)\u003c/code\u003e操作是未定义的\u0026lt;参看《ISO/IEC 9899:1999 standard》p270\u0026gt;;。也就是说不一定能实现刷新功能，但有的编译器可能不遵循标准，对\u003ccode\u003efflush(stdin)\u003c/code\u003e操作不予警告，并且有时可能产生正确的结果，但最好不要这样使用。\u003c/p\u003e","title":"解决 gcc 编译后 fflush 失效"},{"content":"操作系统定义与分类 操作系统（英语：Operating System，缩写：OS）是一组系统软件程序，狭义上就是内核如 Linux，广义上就是内核加一组软件组成的发行包，如 Ubuntu，Debian：\n• 主管并控制计算机操作、运用和运行硬件、软件资源\n• 提供公共服务来组织用户交互。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 硬件的基本概念 \u003c!DOCTYPE html\u003e Responsive Image Hart Platform 不能说是个板子，应该理解为芯片。早期的板子就是一块芯片加上各种外设，但是随着技术发展，板子越来越小，外设却并没有变少，是因为外设都被集成到了芯片中。当所有外设都被集成，那么芯片就是 platform。 SoC(System on Chip) 片上系统 \u003c!DOCTYPE html\u003e Responsive Image QEMU 模拟 virt 这个平台，这个平台有八个 Hart。\n地址映射 \u003c!DOCTYPE html\u003e Responsive Image 为了方便访问外设，现在主流的 platform 会对外设的内存地址做一个映射。映射到 platform 的真实物理地址。对真实物理地址进行操作时，就是对外设的地址进行操作。\n物理地址从最低位到最高位都被分配给了各种外设。\n引导过程介绍 \u003c!DOCTYPE html\u003e Responsive Image 通电后，会先到箭头所指的地址，这个地址就是对应的 ROM 外设首地址。ROM 相当于一个小硬盘，断电后不会丢失数据。这里面固化了一些指令。\n主要就是跳转指令，运行到 kernel 段继续执行。\n\u003c!DOCTYPE html\u003e Responsive Image 八核同时会执行这个过程。\n以上是硬件的部分过程，软件该如何写？\n\u003c!DOCTYPE html\u003e Responsive Image 为了简化学习流程和降低调试难度，目前只支持单核，其余七个核处于空转状态。\n如何判断当前 Hart 是不是第一个？ \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 这些寄存器必须使用以下的指令读写：\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 以上指令就是将寄存器值进行一次交换，只不过这个过程是原子性的，不能被打断。\nCSRRW经常会用在伪指令CSRW中，完整指令中，第一步向x0写入数据，就是空操作，第二步将rs写入csr。这个伪指令就是完成了一个写入csr的操作。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image mhartid就是machine hart id。\n学习以上几个指令，就可以完成判断 hart 是否为第一个的工作了，\n\u003c!DOCTYPE html\u003e Responsive Image csrr t0, mhartid #读寄存器值 mv tp, t0 # bnez t0, park # 跳转指令，不等于 0 就跳转到 park 标签 wfi 休眠指令 如何初始化栈空间 如何跳转到 C 语言环境 # start.S #include \u0026#34;platform.h\u0026#34; # size of each hart\u0026#39;s stack is 1024 bytes .equ STACK_SIZE, 1024 .global _start .text _start: # park harts with id != 0 csrr t0, mhartid # read current hart id mv tp, t0 # keep CPU\u0026#39;s hartid in its tp for later usage. bnez t0, park # if we\u0026#39;re not on the hart 0 # we park the hart # Setup stacks, the stack grows from bottom to top, so we put the # stack pointer to the very end of the stack range. slli t0, t0, 10 # shift left the hart id by 1024 ###### 初始化栈空间 ###### # set the initial stack pointer to the end of the first stack space la sp, stacks + STACK_SIZE # move the current hart stack pointer to its place in the stack space add sp, sp, t0 ###### 初始化栈空间 ###### ###### 跳转到C语言环境 ###### j start_kernel # hart 0 jump to c, start_kernel is the entry point of the kernel ###### 跳转到C语言环境 ###### park: wfi j park stacks: # allocate space for all the harts stacks .skip STACK_SIZE * MAXNUM_CPU .end # End of file // kernel.c void start_kernel(void) { while (1) {}; // stop here! } 通过 UART 打印信息 连接方式 \u003c!DOCTYPE html\u003e Responsive Image 真实的硬件开发是有一个快开发板，但是这个课程里使用的是 QEMU 来模拟开发板的硬件环境。如果要在程序里打印一段信息，正常的情况是在开发板上连接显示器，但是这里是通过将信息用串口传到主机上，然后用主机的屏幕显示信息。\n串口线里是有两根线，负责收信息和发信息。\nUART 特点 \u003c!DOCTYPE html\u003e Responsive Image 并行就是需要多根线，比如有两根线，那么就可以一次发送两位。但是串行节省材料。 数据通信就会涉及同步的问题，同步的话需要一根时钟线来协商好发送时间和接收时间。而 UART 使用异步，发送的数据不仅仅是真实的数据，还会带有一些标识信息。这些标识可以判断出是收还是发。 物理接口 \u003c!DOCTYPE html\u003e Responsive Image UART 通讯协议 \u003c!DOCTYPE html\u003e Responsive Image 图示中横轴可以表示时间，纵轴表示高低电平。\n在需要发送数据时，会进行“下拉”1bit，1bit 持续的时间就是波特率分之一秒。\n数据在发送过程中可能会受到干扰，会产生畸变，所以需要检验位来判断是否发生畸变。\n\u003c!DOCTYPE html\u003e Responsive Image 初始化 \u003c!DOCTYPE html\u003e Responsive Image 在软件中，配置 UART 就是配置寄存器的信息。\n在板子上有个元器件叫晶振（crystal），他会产生固定频率的时钟。一种是 1.8432MHZ，一种是 7.3728MHZ。想要获得指定的输出频率就需要对寄存器进行配置。查表可以得到配置信息。比如获得 38.4K 频率的输出，就要配置寄存器值为 3。\n\u003c!DOCTYPE html\u003e Responsive Image LCR 寄存器功能比较多，将第 7 位设置为 1 就是用来设置波特率。\n图中DLL和DLM寄存器就是需要配置的寄存器。因为 UART 寄存器都是 8 位的，将值0x0003高位0x00存在DLM中，将低位0x03存入DLL。\n","permalink":"https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-rvos%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/","summary":"\u003ch2 id=\"操作系统定义与分类\"\u003e操作系统定义与分类\u003c/h2\u003e\n\u003cp\u003e操作系统（英语：Operating System，缩写：OS）是一组系统软件程序，狭义上就是内核如 Linux，广义上就是内核加一组软件组成的发行包，如 Ubuntu，Debian：\u003c/p\u003e","title":"RISC-V 入门-RVOS 系统引导"},{"content":"相关概念 Core 在使用半导体作为内存的材料前，人类是利用线圈当作内存的材料（发明者为王安），线圈就叫作 core ，用线圈做的内存就叫作 core memory。如今，半导体工业澎勃发展，已经没有人用core memory 了，不过，在许多情况下，人们还是把记忆体叫作 core 。\nCore dump 我们在开发（或使用）一个程序时，最怕的就是程序莫明其妙地宕掉。虽然系统没事，但我们下次仍可能遇到相同的问题。于是这时操作系统就会把程序宕掉时的内存内容 dump 出来（现在通常是写在一个叫 core 的 file 里面），让我们做为参考。这个动作就叫作 core dump。\n如何获取 Core 文件 1、在一些 Linux 版本下，默认是不产生core文件的，首先可以查看一下系统core文件的大小限制：\n$:~/segfault$ ulimit -c 0 2、可以看到默认设置情况下，本机 Linux 环境下发生段错误时不会自动生成core文件，下面设置下core文件的大小限制（单位为 KB）：\n$:~/segfault$ ulimit -c 1024 $:~/segfault$ ulimit -c 1024 3、重新运行程序，如果发生段错误，就会生成core文件。\n出现段错误的可能原因 访问不存在的内存地址 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; void main() { int *ptr = NULL; *ptr = 0; } 访问系统保护的内存地址 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; void main() { int *ptr = (int *)0; *ptr = 100; } 访问只读的内存地址 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; void main() { char *ptr = \u0026#34;test\u0026#34;; strcpy(ptr, \u0026#34;TEST\u0026#34;); } 栈溢出 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; void main() { main(); } 段错误信息获取 程序发生段错误时，提示信息很少，下面有几种查看段错误的发生信息的途径。\ndmesg dmesg 可以在应用程序 crash 掉时，显示内核中保存的相关信息。如下所示，通过dmesg命令可以查看发生段错误的程序名称、引起段错误发生的内存地址、指令指针地址、堆栈指针地址、错误代码、错误原因等。\n$:~/segfault$ dmesg [ 2329.479037] segfault3[2700]: segfault at 80484e0 ip 00d2906a sp bfbbec3c error 7 in libc-2.10.1.so[cb4000+13e000] -g 使用 gcc 编译程序的源码时，加上-g参数，这样可以使得生成的二进制文件中加入可以用于 gdb 调试的有用信息。\n$:~/segfault$ gcc -g -o segfault3 segfault3.c nm 使用 nm 命令列出二进制文件中的符号表，包括符号地址、符号类型、符号名等，这样可以帮助定位在哪里发生了段错误。\npanfeng@ubuntu:~/segfault$ nm segfault3 08049f20 d _DYNAMIC 08049ff4 d _GLOBAL_OFFSET_TABLE_ 080484dc R _IO_stdin_used w _Jv_RegisterClasses 08049f10 d __CTOR_END__ 08049f0c d __CTOR_LIST__ 08049f18 D __DTOR_END__ 08049f14 d __DTOR_LIST__ 080484ec r __FRAME_END__ 08049f1c d __JCR_END__ 08049f1c d __JCR_LIST__ 0804a014 A __bss_start 0804a00c D __data_start 08048490 t __do_global_ctors_aux 08048360 t __do_global_dtors_aux 0804a010 D __dso_handle w __gmon_start__ 0804848a T __i686.get_pc_thunk.bx 08049f0c d __init_array_end 08049f0c d __init_array_start 08048420 T __libc_csu_fini 08048430 T __libc_csu_init U __libc_start_main@@GLIBC_2.0 0804a014 A _edata 0804a01c A _end 080484bc T _fini 080484d8 R _fp_hw 080482bc T _init 08048330 T _start 0804a014 b completed.6990 0804a00c W data_start 0804a018 b dtor_idx.6992 080483c0 t frame_dummy 080483e4 T main U memcpy@@GLIBC_2.0 ldd 使用 ldd 命令查看二进制程序的共享链接库依赖，包括库的名称、起始地址，这样可以确定段错误到底是发生在了自己的程序中还是依赖的共享库中。\n$:~/segfault$ ldd ./segfault3 linux-gate.so.1 =\u0026gt; (0x00e08000) libc.so.6 =\u0026gt; /lib/tls/i686/cmov/libc.so.6 (0x00675000) /lib/ld-linux.so.2 (0x00482000) 调试方法和技巧 使用 gcc 和 gdb 调试流程 为了能够使用 gdb 调试程序，在编译阶段加上-g 参数， $:~/segfault$ gcc -g -o segfault3 segfault3.c 使用 gdb 命令调试程序： $:~/segfault$ gdb -q ./segfault3 Reading symbols from ./segfault3...done. (gdb) 进入 gdb 后，运行程序： (gdb) run Starting program: ./segfault3 Program received signal SIGSEGV, Segmentation fault. 0x001a306a in memcpy () from /lib/tls/i686/cmov/libc.so.6 (gdb) 从输出看出，程序收到SIGSEGV信号，触发段错误，并提示地址0x001a306a、调用 memcpy 报的错，位于/lib/tls/i686/cmov/libc.so.6库中。\n完成调试后，输入quit命令退出 gdb： 适用场景 仅当能确定程序一定会发生段错误的情况下使用。\n当程序的源码可以获得的情况下，使用-g参数编译程序。\n一般用于测试阶段，生产环境下 gdb 会有副作用：使程序运行减慢，运行不够稳定，等等。\n即使在测试阶段，如果程序过于复杂，gdb 也不能处理。\n使用 core 文件和 gdb 在上节中提到段错误会触发SIGSEGV信号，通过man 7 signal，可以看到SIGSEGV默认的handler会打印段错误出错信息，并产生core文件，由此我们可以借助于程序异常退出时生成的core文件中的调试信息，使用 gdb 工具来调试程序中的段错误。\n调试流程 运行有段错误的程序，生成 core 文件。 gdb 加载 core 文件 $:~/segfault$ gdb ./segfault3 ./core Reading symbols from /home/panfeng/segfault/segfault3...done. warning: Can\u0026#39;t read pathname for load map: 输入/输出错误. Reading symbols from /lib/tls/i686/cmov/libc.so.6...(no debugging symbols found)...done. Loaded symbols for /lib/tls/i686/cmov/libc.so.6 Reading symbols from /lib/ld-linux.so.2...(no debugging symbols found)...done. Loaded symbols for /lib/ld-linux.so.2 Core was generated by `./segfault3\u0026#39;. Program terminated with signal 11, Segmentation fault. #0 0x0018506a in memcpy () from /lib/tls/i686/cmov/libc.6 从输出看出，同上节中一样的段错误信息。\n适用场景 适合于在实际生成环境下调试程序的段错误（即在不用重新发生段错误的情况下重现段错误）。\n当程序很复杂，core 文件相当大时，该方法不可用。\n使用 objdump 调试流程 使用 dmesg 命令，找到最近发生的段错误输出信息： $:~/segfault$ dmesg ... ... [17257.502808] segfault3[3320]: segfault at 80484e0 ip 0018506a sp bfc1cd6c error 7 in libc-2.10.1.so[110000+13e000] 其中，对我们接下来的调试过程有用的是发生段错误的地址：80484e0和指令指针地址：0018506a。\n使用objdump生成二进制的相关信息，重定向到文件中： $:~/segfault$ objdump -d ./segfault3 \u0026gt; segfault3Dump 其中，生成的segfault3Dump文件中包含了二进制文件的segfault3的汇编代码。\n在segfault3Dump文件中查找发生段错误的地址： panfeng@ubuntu:~/segfault$ grep -n -A 10 -B 10 \u0026#34;80484e0\u0026#34; ./segfault3Dump 121- 80483df: ff d0 call *%eax 122- 80483e1: c9 leave 123- 80483e2: c3 ret 124- 80483e3: 90 nop 125- 126-080483e4 \u0026lt;main\u0026gt;: 127- 80483e4: 55 push %ebp 128- 80483e5: 89 e5 mov %esp,%ebp 129- 80483e7: 83 e4 f0 and $0xfffffff0,%esp 130- 80483ea: 83 ec 20 sub $0x20,%esp 131: 80483ed: c7 44 24 1c e0 84 04 movl $0x80484e0,0x1c(%esp) 132- 80483f4: 08 133- 80483f5: b8 e5 84 04 08 mov $0x80484e5,%eax 134- 80483fa: c7 44 24 08 05 00 00 movl $0x5,0x8(%esp) 135- 8048401: 00 136- 8048402: 89 44 24 04 mov %eax,0x4(%esp) 137- 8048406: 8b 44 24 1c mov 0x1c(%esp),%eax 138- 804840a: 89 04 24 mov %eax,(%esp) 139- 804840d: e8 0a ff ff ff call 804831c \u0026lt;memcpy@plt\u0026gt; 140- 8048412: c9 leave 141- 8048413: c3 ret 通过对以上汇编代码分析，得知段错误发生main函数，对应的汇编指令是movl $0x80484e0,0x1c(%esp)，接下来打开程序的源码，找到汇编指令对应的源码，也就定位到段错误了。\n适用场景 不需要-g参数编译，不需要借助于core文件，但需要有一定的汇编语言基础。 2、如果使用了 gcc 编译优化参数（-O1，-O2，-O3）的话，生成的汇编指令将会被优化，使得调试过程有些难度。\n使用 catchsegv catchsegv命令专门用来扑获段错误，它通过动态加载器（ld-linux.so）的预加载机制（PRELOAD）把一个事先写好的库（/lib/libSegFault.so）加载上，用于捕捉断错误的出错信息。\n$:~/segfault$ catchsegv ./segfault3 Segmentation fault (core dumped) *** Segmentation fault Register dump: EAX: 00000000 EBX: 00fb3ff4 ECX: 00000002 EDX: 00000000 ESI: 080484e5 EDI: 080484e0 EBP: bfb7ad38 ESP: bfb7ad0c EIP: 00ee806a EFLAGS: 00010203 CS: 0073 DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 007b Trap: 0000000e Error: 00000007 OldMask: 00000000 ESP/signal: bfb7ad0c CR2: 080484e0 Backtrace: /lib/libSegFault.so[0x3b606f] ??:0(??)[0xc76400] /lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xe6)[0xe89b56] /build/buildd/eglibc-2.10.1/csu/../sysdeps/i386/elf/start.S:122(_start)[0x8048351] Memory map: 00258000-00273000 r-xp 00000000 08:01 157 /lib/ld-2.10.1.so 00273000-00274000 r--p 0001a000 08:01 157 /lib/ld-2.10.1.so 00274000-00275000 rw-p 0001b000 08:01 157 /lib/ld-2.10.1.so 003b4000-003b7000 r-xp 00000000 08:01 13105 /lib/libSegFault.so 003b7000-003b8000 r--p 00002000 08:01 13105 /lib/libSegFault.so 003b8000-003b9000 rw-p 00003000 08:01 13105 /lib/libSegFault.so 00c76000-00c77000 r-xp 00000000 00:00 0 [vdso] 00e0d000-00e29000 r-xp 00000000 08:01 4817 /lib/libgcc_s.so.1 00e29000-00e2a000 r--p 0001b000 08:01 4817 /lib/libgcc_s.so.1 00e2a000-00e2b000 rw-p 0001c000 08:01 4817 /lib/libgcc_s.so.1 00e73000-00fb1000 r-xp 00000000 08:01 1800 /lib/tls/i686/cmov/libc-2.10.1.so 00fb1000-00fb2000 ---p 0013e000 08:01 1800 /lib/tls/i686/cmov/libc-2.10.1.so 00fb2000-00fb4000 r--p 0013e000 08:01 1800 /lib/tls/i686/cmov/libc-2.10.1.so 00fb4000-00fb5000 rw-p 00140000 08:01 1800 /lib/tls/i686/cmov/libc-2.10.1.so 00fb5000-00fb8000 rw-p 00000000 00:00 0 08048000-08049000 r-xp 00000000 08:01 303895 /home/segfault/segfault3 08049000-0804a000 r--p 00000000 08:01 303895 /home/segfault/segfault3 0804a000-0804b000 rw-p 00001000 08:01 303895 /home/segfault/segfault3 09432000-09457000 rw-p 00000000 00:00 0 [heap] b78cf000-b78d1000 rw-p 00000000 00:00 0 b78df000-b78e1000 rw-p 00000000 00:00 0 bfb67000-bfb7c000 rw-p 00000000 00:00 0 [stack] 如何避免段错误 出现段错误时，首先应该想到段错误的定义，从它出发考虑引发错误的原因。\n在使用指针时，定义了指针后记得初始化指针，在使用的时候记得判断是否为 NULL。\n在使用数组时，注意数组是否被初始化，数组下标是否越界，数组元素是否存在等。\n在访问变量时，注意变量所占地址空间是否已经被程序释放掉。\n在处理变量时，注意变量的格式控制是否合理等。\nReference ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3segmentation-fault-core-dumped/","summary":"\u003ch2 id=\"相关概念\"\u003e相关概念\u003c/h2\u003e\n\u003ch3 id=\"core\"\u003eCore\u003c/h3\u003e\n\u003cp\u003e在使用半导体作为内存的材料前，人类是利用线圈当作内存的材料（发明者为王安），线圈就叫作 \u003ccode\u003ecore\u003c/code\u003e ，用线圈做的内存就叫作 \u003ccode\u003ecore memory\u003c/code\u003e。如今，半导体工业澎勃发展，已经没有人用\u003ccode\u003ecore memory\u003c/code\u003e 了，不过，在许多情况下，人们还是把记忆体叫作 \u003ccode\u003ecore\u003c/code\u003e 。\u003c/p\u003e","title":"解决 Segmentation fault (core dumped)"},{"content":"汇编语法介绍 一条典型的 RISC-V 汇编语句由三个部分组成[label:][operation][comment]。 后缀.s和.S区别：后者纯汇编。\nlabel(标号) operation 可以有以下多种类型： instruction (指令) ：直接对应二进制机器指令的宇符串 pseudo-instruction (伪指令) ：为了提高编写代码的效率，可以用一条伪指令指示汇编器产生多条实际的指令 (instructions)。 directive (指示/伪操作) ：通过类似指令的形式(以\u0026quot;.\u0026ldquo;开头),通知汇编器如何控制代码的产生等，不对应具体的指令。 macro：采用.macro/.endm 自定义的宏 例子 .macro do_nothing # directive nop # pseudo-instruction nop # pseudo-instruction .endm # directive .text # directive .global _start # directive _start: # Label li x6, 5 # pseudo-instruction li x7, 4 # pseudo-instruction add x5, x6, x7 # instruction do_nothing # Calling macro stop: j stop # statement in one line .end # End of file comment（注释）以#开头到行尾 RISC-V 汇编指令总览 操作对象 寄存器 32个通用寄存器,x0 ~ x31（注意：本章节课程仅涉及RV32I的通用寄存器组）； 在 RISC-V 中，Hart 在执行算术逻辑运算时所操作的数据必须直接来自寄存器。 内存 Hart可以执行在寄存器和内存之间的数据读写操作； 读写操作使用字节 (Byte) 为基本单位进行寻址； RV32可以访问最多2^32个字节的内存空间。 编码格式 \u003c!DOCTYPE html\u003e Responsive Image 指令长度：32bit，本文讨论的都是 RV32 指令集\n指令对齐：指令加载到内存是以 32bit 对齐\nfunct3、funct7和opcode一起决定指令类型，funct3表示占 3bit，funct7占 7bit。\nopcode映射关系：\n[1:0] 永远为 11 [4:2] 为下图横轴 [6:5] 为下图纵轴，三部分决定指令的类型。 以BEQ指令为例opcode=1100011。[4:2]=000，[6:5]=11查表可得BEQ指令类型为BRANCH。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 小端序 主机字节序 (HBO-Host Byte Order) 一个多字节整数在计算机内存中存储的字节顺序称主机字节序 (HBO- Host Byte Order，或者叫本地字节序) 不同类型 CPU 的 HBO 不同，这与 CPU 的设计有关。分为大端序 (Big-Endian) 和小端序 (Little-Endian) \u003c!DOCTYPE html\u003e Responsive Image 指令分类 \u003c!DOCTYPE html\u003e Responsive Image rd（register destination）目标寄存器，rs（register source）源寄存器，大小都是 5bit，因为可以表示2^5=32寄存器。\n\u003c!DOCTYPE html\u003e Responsive Image 指令详解 算术运算指令 ADD 算数指令只包含加减，不包含乘除，乘除运算有专门的扩展。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 数据传送顺序是由后向前，和正常的编码习惯类似。\nSUB Substract 练习\n现知道某条 RISC-V 的机器指令在内存中的值为b3 05 95 00,从左往右为从低地址到高地址，单位为字节，请将其翻译为对应的汇编指令。\n确定字节序 在 RISC-V 中存放是小端序，根据题意真正指令应该是00 95 05 b3 转换二进制 机器码是二进制，所以需要将上述指令值转换为二进制，可得0000000 01001 01010 000 01011 0110011 查阅手册 查阅The RISC-V Instruction Set Manual Volume I: Unprivileged ISA找到RV32/64G Instruction Set Listings指令表格，低 7 位是opcode，查表可得0110011对应操作码有多个SLLI SRAI SUB等等，此时再看最高位00000000,可以确定是ADD指令 将分割的二进制转成十进制 0000000 9 10 000 11 010011-\u0026gt;ADD x11 x10 x9 ADDI ADD Immediate \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image LUI Load Upper Immediate \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image LI \u003c!DOCTYPE html\u003e Responsive Image AUIPC \u003c!DOCTYPE html\u003e Responsive Image 经常用于构造一个相对地址。\nLA \u003c!DOCTYPE html\u003e Responsive Image 基于算术运算指令实现的其他伪指令 x0寄存器具有特殊含义，往里写数据没有意义 NOP指令主要为了占位，空转\n\u003c!DOCTYPE html\u003e Responsive Image 逻辑运算指令 \u003c!DOCTYPE html\u003e Responsive Image NOT 10101010 11111111(-1) -------- XOR 01010101 移位运算指令 \u003c!DOCTYPE html\u003e Responsive Image 算数移位 只有右移，没有左移。左移会把最高位覆盖。\n\u003c!DOCTYPE html\u003e Responsive Image 10001000 \u0026gt;\u0026gt; 2 = 11100001 内存读写指令 加载，内存读，将数据从内存读入寄存器\nStore，内存写，将数据从寄存器写出到内存\n\u003c!DOCTYPE html\u003e Responsive Image 为何对 word 的 加载 不区分无符号和有符号方式 (RV32)？RV32 下寄存器是 4 字节，加载 word 也是 4 字节，自然不需要扩展。\n\u003c!DOCTYPE html\u003e Responsive Image 为何 store 不区分有符号还是无符号？因为从目的地址只有 1 字节，不管是写 1 字节，2 字节，还是 4 字节，都只用到最低的 1 字节。不需要考虑符号\n立即数分两个地方存，为了解码效率\n条件分支指令 \u003c!DOCTYPE html\u003e Responsive Image 指令格式中的立即数 (imm) 存放有些奇怪，第 [1-4] 位和第 [11] 位放在一起，第 [5-10] 位和第 [12] 位放在一起。这是为了迎合硬件处理效率，编程时不需要考虑立即数存储方式。\n\u003c!DOCTYPE html\u003e Responsive Image 无条件跳转指令 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image int a = 1; int b = 1; void sum() { a = a+b; return; // jalr x0 0(x5) 当前指令的下一条指令存到x0中，并跳转到（0 + x5)，也就是sum的下一条指令 } void _start() { sum(); // jal x5 sum 把sum的下一条指令存到x5，然后跳转到sum ... } 如何解决长距离跳转？使用 AUIPC 来构建一个大数，配合 JALR 使用。如 auipc x6,imm-20 jalr x1,x6,imm-12\n\u003c!DOCTYPE html\u003e Responsive Image RISC-V 指令寻址模式总结 \u003c!DOCTYPE html\u003e Responsive Image 汇编函数调用约定 函数调用过程概述 栈（stack）数据结构，在函数调用过程中会用来保存变量，函数地址等等。\n\u003c!DOCTYPE html\u003e Responsive Image 栈帧里保存的变量是自动变量，会被内存自动释放。\n为何要有调用者与被调用者保存的概念\n\u003c!DOCTYPE html\u003e Responsive Image 函数调用过程中就会有参数和返回值的传递，自己写的函数可能由别人来调用，如果没有约定好某个参数存放位置，就不能够顺利执行函数。\n\u003c!DOCTYPE html\u003e Responsive Image 因为寄存器需要经常在编程中使用，所以 ABI 名就是寄存器的别名。\n这些寄存器其实都可以设置成被调用者保存，也就是在被调用函数中保存一遍为啥还要分这么多 答：因为保存一遍效率低\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 尾调用实例 # Calling Convention # Demo to create a leaf routine # # void _start() # { # // calling leaf routine # square(3); # } # # int square(int num) # { # return num * num; # } .text # Define beginning of text section .global _start # Define entry _start _start: la sp, stack_end # prepare stack for calling functions li a0, 3 # pass 3 to square call square # call square # the time return here, a0 should stores the result stop: j stop # Infinite loop to stop execution # int square(int num) square: # prologue addi sp, sp, -8 # reserve space for local variables sw s0, 0(sp) # save s0 sw s1, 4(sp) # save s1 # `mul a0, a0, a0` should be fine, # programing as below just to demo we can contine use the stack mv s0, a0 # s0 = a0 mul s1, s0, s0 # s1 = s0 * s0 mv a0, s1 # a0 = s1 # epilogue lw s0, 0(sp) # restore s0 lw s1, 4(sp) # restore s1 addi sp, sp, 8 # release space for local variables ret # return from function # add nop here just for demo in gdb nop # allocate stack space stack_start: .rept 10 # reserve 10 words for stack .word 0 # fill with 0 .endr # end of repeat stack_end: .end # End of file 非尾调用实例 # Calling Convention # Demo how to write nested routines # # void _start() # { # // calling nested routine # aa_bb(3, 4); # } # # int aa_bb(int a, int b) # { # return square(a) + square(b); # } # # int square(int num) # { # return num * num; # } .text # Define beginning of text section .global _start # Define entry _start _start: la sp, stack_end # prepare stack for calling functions # aa_bb(3, 4); li a0, 3 # load argument a li a1, 4 # load argument b call aa_bb # call aa_bb stop: j stop # Infinite loop to stop execution # int aa_bb(int a, int b) # return a^2 + b^2 aa_bb: # prologue addi sp, sp, -16 # decrement stack pointer by 16 bytes sw s0, 0(sp) # save s0 sw s1, 4(sp) # save s1 sw s2, 8(sp) # save s2 sw ra, 12(sp) # save ra # cp and store the input params mv s0, a0 # copy a to s0 mv s1, a1 # copy b to s1 # sum will be stored in s2 and is initialized as zero li s2, 0 # initialize s2 to zero mv a0, s0 # copy s0 to a0 jal square # call square add s2, s2, a0 # add a0 to s2 mv a0, s1 # copy s1 to a0 jal square # call square add s2, s2, a0 # add a0 to s2 mv a0, s2 # copy s2 to a0 # epilogue lw s0, 0(sp) # restore s0 lw s1, 4(sp) # restore s1 lw s2, 8(sp) # restore s2 lw ra, 12(sp) # restore ra addi sp, sp, 16 # increment stack pointer by 16 bytes ret # return from aa_bb # int square(int num) square: # prologue addi sp, sp, -8 # decrement stack pointer by 8 bytes sw s0, 0(sp) # save s0 sw s1, 4(sp) # save s1 # `mul a0, a0, a0` should be fine, # programing as below just to demo we can contine use the stack mv s0, a0 # copy a to s0 mul s1, s0, s0 # s1 = a * a mv a0, s1 # copy s1 to a0 # epilogue lw s0, 0(sp) # restore s0 lw s1, 4(sp) # restore s1 addi sp, sp, 8 # increment stack pointer by 8 bytes ret # return from square # add nop here just for demo in gdb nop # allocate stack space stack_start: .rept 10 # allocate 10 words of stack space .word 0 # initialize stack space to 0 .endr # end of stack allocation stack_end: .end # End of file 汇编与 C 混合编程 前提 遵守 ABI（Abstract Binary Interface）的规定\n数据类型大小，布局，对齐 函数调用约定 系统调用约定 等等 RISC-V 函数调用约定规定\n函数参数采用寄存器a0-a7 函数返回值采用寄存器a0,a1 汇编嵌入 C 语言 # ASM call C .text # Define beginning of text section .global _start # Define entry _start .global foo # foo is a C function defined in test.c _start: la sp, stack_end # prepare stack for calling functions # RISC-V uses a0 ~ a7 to transfer parameters li a0, 1 li a1, 2 call foo #调用了C语言函数 # RISC-V uses a0 \u0026amp; a1 to transfer return value # check value of a0 stop: j stop # Infinite loop to stop execution nop # just for demo effect stack_start: .rept 10 .word 0 .endr stack_end: .end # End of file call foo就是在调用 C 语言函数，foo。 .global foo告诉编译器foo函数定义在外面。\nC 语言嵌入汇编 下图中为简化写法\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-risc-v%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/","summary":"\u003ch2 id=\"汇编语法介绍\"\u003e汇编语法介绍\u003c/h2\u003e\n\u003cp\u003e一条典型的 RISC-V 汇编语句由三个部分组成\u003ccode\u003e[label:][operation][comment]\u003c/code\u003e。\n后缀\u003ccode\u003e.s\u003c/code\u003e和\u003ccode\u003e.S\u003c/code\u003e区别：后者纯汇编。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003elabel(标号)\u003c/li\u003e\n\u003cli\u003eoperation 可以有以下多种类型：\n\u003cul\u003e\n\u003cli\u003einstruction (指令) ：直接对应二进制机器指令的宇符串\u003c/li\u003e\n\u003cli\u003epseudo-instruction (伪指令) ：为了提高编写代码的效率，可以用一条伪指令指示汇编器产生多条实际的指令 (instructions)。\u003c/li\u003e\n\u003cli\u003edirective (指示/伪操作) ：通过类似指令的形式(以\u0026quot;.\u0026ldquo;开头),通知汇编器如何控制代码的产生等，不对应具体的指令。\u003c/li\u003e\n\u003cli\u003emacro：采用.macro/.endm 自定义的宏\n例子\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e.macro do_nothing  # directive\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  nop    # pseudo-instruction\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  nop    # pseudo-instruction\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e.endm      # directive\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  .text    # directive\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  .global _start  # directive\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e_start:     # Label\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  li x6, 5  # pseudo-instruction\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  li x7, 4  # pseudo-instruction\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  add x5, x6, x7  # instruction\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  do_nothing  # Calling macro\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003estop:  j stop    # statement in one line\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  .end    # End of file\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003ecomment（注释）以\u003ccode\u003e#\u003c/code\u003e开头到行尾\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"risc-v-汇编指令总览\"\u003eRISC-V 汇编指令总览\u003c/h2\u003e\n\u003ch3 id=\"操作对象\"\u003e操作对象\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e寄存器\n\u003cul\u003e\n\u003cli\u003e32个通用寄存器,\u003ccode\u003ex0 ~ x31\u003c/code\u003e（注意：本章节课程仅涉及RV32I的通用寄存器组）；\u003c/li\u003e\n\u003cli\u003e在 RISC-V 中，Hart 在执行算术逻辑运算时所操作的数据必须直接来自寄存器。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e内存\n\u003cul\u003e\n\u003cli\u003eHart可以执行在寄存器和内存之间的数据读写操作；\u003c/li\u003e\n\u003cli\u003e读写操作使用字节 (Byte) 为基本单位进行寻址；\u003c/li\u003e\n\u003cli\u003eRV32可以访问最多\u003ccode\u003e2^32\u003c/code\u003e个字节的内存空间。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"编码格式\"\u003e编码格式\u003c/h3\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826142737.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826142737.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"RISC-V 入门-RISC-V 汇编语言编程"},{"content":"学习过程中查看了printf()源码，遇到了这样的函数定义，\nvoid printf(char *fmt, ...){ char buf[256]; va_list args; memset(buf, 0, sizeof(buf)); va_start(args, fmt); vsprint(buf, fmt, args); va_end(args); puts(buf); } 参数中的三个点号，就是 C 语言中可变参数的标识。这样的函数称为可变参数函数。这种函数需要固定数量的强制参数（mandatory argument），后面是数量可变的可选参数（optional argument）。\n这种函数必须至少有一个强制参数。可选参数的类型可以变化。可选参数的数量由强制参数的值决定，或由用来定义可选参数列表的特殊值决定。\nC 语言中最常用的可变参数函数例子是printf（）和 scanf（）。这两个函数都有一个强制参数，即格式化字符串。格式化字符串中的转换修饰符决定了可选参数的数量和类型。\n可变参数函数要获取可选参数时，必须通过一个类型为 va_list 的对象，它包含了参数信息。这种类型的对象也称为参数指针（argument pointer），它包含了栈中至少一个参数的位置。可以使用这个参数指针从一个可选参数移动到下一个可选参数，由此，函数就可以获取所有的可选参数。va_list 类型被定义在头文件 stdarg.h 中。\n当编写支持参数数量可变的函数时，必须用 va_list 类型定义参数指针，以获取可选参数。在下面的讨论中，va_list 对象被命名为 argptr。可以用 4个宏来处理该参数指针，这些宏都定义在头文件 stdarg.h 中：\n宏 va_start 使用第一个可选参数的位置来初始化 argptr 参数指针。该宏的第二个参数必须是该函数最后一个有名称参数的名称。必须先调用该宏，才可以开始使用可选参数。\nvoid va_start(va_list argptr, lastparam); 展开宏 va_arg 会得到当前 argptr 所引用的可选参数，也会将 argptr 移动到列表中的下一个参数。宏 va_arg 的第二个参数是刚刚被读入的参数的类型。\ntype va_arg(va_list argptr, type); 当不再需要使用参数指针时，必须调用宏 va_end。如果想使用宏 va_start 或者宏 va_copy 来重新初始化一个之前用过的参数指针，也必须先调用宏 va_end。va_end被定义为空。它只是为实现与 va_start 配对 (实现代码对称和\u0026quot;代码自注释\u0026quot;(根据代码就能知道功能，不需要额外注释) 功能)\nvoid va_end(va_list argptr); 宏 va_copy 使用当前的src值来初始化参数指针 dest。然后就可以使用 dest中的备份获取可选参数列表，从src 所引用的位置开始。\nvoid va_copy(va_list dest, va_list src); // 函数 add() 计算可选参数之和 // 参数：第一个强制参数指定了可选参数的数量，可选参数为 double 类型 // 返回值：和值，double 类型 double add( int n, ... ) { int i = 0; double sum = 0.0; va_list argptr; va_start( argptr, n ); // 初始化 argptr for ( i = 0; i \u0026lt; n; ++i ) // 对每个可选参数，读取类型为 double 的参数， sum += va_arg( argptr, double ); // 然后累加到 sum 中 va_end( argptr ); return sum; } 简易printf函数\n#include \u0026lt;stdarg.h\u0026gt; /* minprintf: minimal printf with variable arqument list */ void minprintf(char *fmt, ...) { GPIO va_list ap; /* points to each unnamed arq in turn */ char *p, *sval; int ival; double dval; va_start(ap, fmt); /* make ap point to 1st unnamed arg */ for (p = fmt; *p; p++) { if (*p != \u0026#39;%\u0026#39;) { putchar(*p); continue; } } switch (*++p) { case \u0026#39;d\u0026#39;: ival = va_arg(ap, int); printf(\u0026#34;%d\u0026#34;, ival); break; case \u0026#39;f\u0026#39;: dval = va_arg(ap, double); printf(\u0026#34;%f\u0026#34;, dval); break; case \u0026#39;s\u0026#39;: for (sval = va_arq(ap, char *); *sval; sval++) putchar(*sval); break; default: putchar(*p); break; } va_end(ap); /* clean up when done */ } ","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/","summary":"\u003cp\u003e学习过程中查看了\u003ccode\u003eprintf()\u003c/code\u003e源码，遇到了这样的函数定义，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e...){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003ebuf\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e256\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eva_list\u003c/span\u003e \u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003ememset\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebuf\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebuf\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003eva_start\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003evsprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebuf\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003eva_end\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003eputs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebuf\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e参数中的三个点号，就是 C 语言中可变参数的标识。这样的函数称为可变参数函数。这种函数需要固定数量的\u003cstrong\u003e强制参数\u003c/strong\u003e（mandatory argument），后面是\u003cstrong\u003e数量可变的可选参数\u003c/strong\u003e（optional argument）。\u003c/p\u003e","title":"C 语言可变参数"},{"content":"在命令行编译项目时，经常遇到编译结果太长，覆盖了最先输出的结果，此时就需要将结果输出到文件再查看。命令如下：\nmake \u0026gt; make.log 2\u0026gt;\u0026amp;1 # make 编译命令 # make.log 输出文件名 # 2 文件描述符，标准错误 # \u0026gt; 重定向符，输出 # \u0026amp;1 文件描述符\u0026amp;，文件描述符1 标准输入 该命令功能即将make编译时输出，标准错误重定向为标准输入，写入到make.log文件中。符号的含义可以参考Linux 文件描述符\n","permalink":"https://lifeislife.cn/posts/linux%E4%B8%8B%E5%B0%86%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6/","summary":"\u003cp\u003e在命令行编译项目时，经常遇到编译结果太长，覆盖了最先输出的结果，此时就需要将结果输出到文件再查看。命令如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emake \u0026gt; make.log 2\u0026gt;\u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# make 编译命令\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# make.log 输出文件名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 2 文件描述符，标准错误\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# \u0026gt; 重定向符，输出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# \u0026amp;1 文件描述符\u0026amp;，文件描述符1 标准输入\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e该命令功能即将\u003ccode\u003emake\u003c/code\u003e编译时输出，标准错误重定向为标准输入，写入到\u003ccode\u003emake.log\u003c/code\u003e文件中。符号的含义可以参考\u003ca href=\"\"\u003eLinux 文件描述符\u003c/a\u003e\u003c/p\u003e","title":"Linux 下将编译结果输出到文件"},{"content":"前言 Linux 中一切皆文件，比如 C++ 源文件、视频文件、Shell 脚本、可执行文件等，就连键盘、显示器、鼠标等硬件设备也都是文件。\n一个 Linux 进程可以打开成百上千个文件，为了表示和区分已经打开的文件，Linux 会给每个文件分配一个编号（一个 ID），这个编号就是一个整数，被称为文件描述符（File Descriptor）。\n文件描述符是什么？ 一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。\n除了文件描述符表，系统还需要维护另外两张表：\n打开文件表（Open file table） i-node 表（i-node table） 文件描述符表每个进程都有一个，打开文件表和 i-node 表整个系统只有一个，它们三者之间的关系如下图所示。\n\u003c!DOCTYPE html\u003e Responsive Image 对上图的说明：\n在进程A 中，文件描述符 1 和20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。 进程 A 的文件描述符 2和进程B 的文件描述符2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B是父子进程关系），或者是不同的进程独自去调用open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。 进程 A 的描述符0和进程B的描述符3分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。 通过文件描述符，可以找到文件指针，从而进入打开文件表。该表存储了以下信息：\n文件偏移量，也就是文件内部指针偏移量。调用read()或者write() 函数时，文件偏移量会自动更新，当然也可以使用 lseek() 直接修改。 状态标志，比如只读模式、读写模式、追加模式、覆盖模式等。 i-node 表指针。 然而，要想真正读写文件，还得通过打开文件表的 i-node 指针进入\ni-node 表，该表包含了诸如以下的信息： 文件类型，例如常规文件、套接字或 FIFO。 文件大小。 时间戳，比如创建时间、更新时间。 文件锁。 标准文件描述符 文件描述符 用途 POSIX 名称 stdio 流 0 标准输入 STDIN FILENO stdin 1 标准输出 STDOUT FILENO stdout 2 标准错误 STDERR FILENO stderr 标准文件描述符通常会和重定向符\u0026lt;,\u0026gt;,\u0026lt;\u0026lt;,\u0026gt;\u0026gt;结合使用。箭头向左表示输入重定向，向右表示输出重定向。文件描述符中的0通常省略。如0\u0026lt; ~ \u0026lt;，0\u0026lt;\u0026lt; ~ \u0026lt;\u0026lt;。\n标准输入 使用wc命令统计文档中有多少行字，命令格式如下，详细介绍参考这篇文章。\nwc [选项] [文件名] $ cat test.txt This is a test file. Hello world! $ wc -l \u0026lt;test.txt 2 这里的重定向符号\u0026lt;作用就是将test.txt的内容作为标准输入，传递给wc命令。\n标准输出与标准错误 这个我们每天都在接触，但是可能没有留意。假设我当前目录下只有一个test.txt文件，执行如下命令\n$ cat text.txt This is a test file. Hello world! #标准输出1 $ cat text.md cat: test.md: No such file or directory #标准错误2 $ ls text.txt text.md 1\u0026gt;file.out 2\u0026gt;file.err # 执行后,没有任何返回值. 原因是, 返回值都重定向到相应的文件中了,而不再前端显示 $ cat file.out text.txt $ cat file.err cat: test.md: No such file or directory \u0026amp;描述符 \u0026amp; 是一个描述符，如果1或2前不加\u0026amp;，会被当成一个普通文件。\n1\u0026gt;\u0026amp;2 意思是把标准输出重定向到标准错误。 2\u0026gt;\u0026amp;1 意思是把标准错误输出重定向到标准输出。 \u0026amp;\u0026gt;filename 意思是把标准输出和标准错误输出都重定向到文件 filename 中\n参考 Linux Shell 重定向（输入输出重定向）精讲\n","permalink":"https://lifeislife.cn/posts/linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003eLinux 中一切皆文件，比如 C++ 源文件、视频文件、Shell 脚本、可执行文件等，就连键盘、显示器、鼠标等硬件设备也都是文件。\u003c/p\u003e\n\u003cp\u003e一个 Linux 进程可以打开成百上千个文件，为了表示和区分已经打开的文件，Linux 会给每个文件分配一个编号（一个 ID），这个编号就是一个整数，被称为\u003cstrong\u003e文件描述符\u003c/strong\u003e（File Descriptor）。\u003c/p\u003e","title":"Linux 文件描述符"},{"content":"需求 通常函数的注释一般都比较长，而且每个函数注释都格式一致，例如下面的函数注释模板。如果每次写注释都要复制一遍比较麻烦，复制完还要删除多余的字符。但是现有的编辑器一般都支持快捷输入。下面介绍在 VSCode 中如何快捷输入注释模板。\n方法 Ctrl+Shift+P打开编辑器命令窗口 - 输入snippets-选择Preferences:Configure User Snippets-选择·c.json· \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 更改如下：\n{ // Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the // same ids are connected. // Example: // \u0026ldquo;Print to console\u0026rdquo;: { // \u0026ldquo;prefix\u0026rdquo;: \u0026ldquo;log\u0026rdquo;, // \u0026ldquo;body\u0026rdquo;: [ // \u0026ldquo;console.log(\u0026rsquo;$1\u0026rsquo;);\u0026rdquo;, // \u0026ldquo;$2\u0026rdquo; // ], // \u0026ldquo;description\u0026rdquo;: \u0026ldquo;Log output to console\u0026rdquo; // } \u0026ldquo;Function comment\u0026rdquo;: { \u0026ldquo;prefix\u0026rdquo;: \u0026ldquo;funcom\u0026rdquo;, \u0026ldquo;body\u0026rdquo;: [ \u0026ldquo;/\u0026rdquo; \u0026ldquo; Description: \u0026quot; \u0026ldquo;Input Parameter: \u0026quot; \u0026ldquo; Output Parameter: \u0026quot; \u0026ldquo;Return: \u0026quot; \u0026ldquo;/ \u0026quot; ], \u0026ldquo;description\u0026rdquo;: \u0026ldquo;function comment\u0026rdquo; } ```\nprefix:输入时的缩写，触发器 body:内容 description:描述 参考资料 VSCode 利用 Snippets 设置超实用的代码块 - 掘金\n","permalink":"https://lifeislife.cn/posts/vscode%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/","summary":"\u003ch2 id=\"需求\"\u003e需求\u003c/h2\u003e\n\u003cp\u003e通常函数的注释一般都比较长，而且每个函数注释都格式一致，例如下面的函数注释模板。如果每次写注释都要复制一遍比较麻烦，复制完还要删除多余的字符。但是现有的编辑器一般都支持快捷输入。下面介绍在 VSCode 中如何快捷输入注释模板。\u003c/p\u003e","title":"VScode 快速添加注释模板"},{"content":"需求 通常函数的注释一般都比较长，而且每个函数注释都格式一致，例如下面的函数注释模板。如果每次写注释都要复制一遍比较麻烦，复制完还要删除多余的字符。但是现有的编辑器一般都支持快捷输入。下面介绍在 QtCreator 中如何快捷输入注释模板。\n/* * Description: // 函数功能、性能等的描述 * Input Parameter: // 输入参数说明，包括每个参数的作 * Output Parameter: // 对输出参数的说明。 * Return: // 函数返回值的说明 */ 方法 QtCreator-菜单栏工具（Tool）- 选项（Options）- 文本编辑器（Text Editor）- 片段（Snippets） 组（Group）选择C++-添加（Add） \u003c!DOCTYPE html\u003e Responsive Image 现在要为我们的触发（Trigger）起个名字，因为是函数注释，我起了个funcom，然后在下方空白框里填入注释模板。Apply 保存。如图 \u003c!DOCTYPE html\u003e Responsive Image 在需要添加注释模板的地方输入funcom即可提示快捷输入，回车即可添加注释模板。 \u003c!DOCTYPE html\u003e Responsive Image 我们可以看到片段里有很多熟悉的内容，比如if else，我们在写代码时输入if else自动补全花括号其实就是在这里设置的。同理，我们还可以设置一些其他需要的快捷输入内容。比如行注释，文件注释，经常使用的代码框架等等。\n","permalink":"https://lifeislife.cn/posts/qtcreator%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/","summary":"\u003ch2 id=\"需求\"\u003e需求\u003c/h2\u003e\n\u003cp\u003e通常函数的注释一般都比较长，而且每个函数注释都格式一致，例如下面的函数注释模板。如果每次写注释都要复制一遍比较麻烦，复制完还要删除多余的字符。但是现有的编辑器一般都支持快捷输入。下面介绍在 QtCreator 中如何快捷输入注释模板。\u003c/p\u003e","title":"QtCreator 快速添加注释模板"},{"content":"保留现场 修改了 UI 文件后，在代码中无法调用新增的内容。\n探究原因 导致ui_*.h文件没有更新的原因是源代码中#include ui_*.h的位置和实际生成的位置不同，引用的是老的ui_*.h\n解决方法 方法一：\n项目设置文件.pro内增加 UI_DIR=./UI，同时删除掉源代码目录中ui_*.h，clear all,-\u0026gt;qmake-\u0026gt;rebuilt all 方法二：\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/qt%E4%BF%AE%E6%94%B9ui%E6%96%87%E4%BB%B6%E4%B8%8D%E7%94%9F%E6%95%88/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e修改了 UI 文件后，在代码中无法调用新增的内容。\u003c/p\u003e\n\u003ch2 id=\"探究原因\"\u003e探究原因\u003c/h2\u003e\n\u003cp\u003e导致\u003ccode\u003eui_*.h\u003c/code\u003e文件没有更新的原因是源代码中\u003ccode\u003e#include ui_*.h\u003c/code\u003e的位置和实际生成的位置不同，引用的是老的\u003ccode\u003eui_*.h\u003c/code\u003e\u003c/p\u003e","title":"Qt 修改 UI 文件不生效"},{"content":"保留现场 QtCreator 构建项目时，会在统计目录新建一个build-xxx-debug的目录，如果想要自己修改这个目录的位置，名称，该怎么办。\n解决方法 仅修改工具（Tool）–\u0026gt;选项 (Options)–\u0026gt;构建和运行 (Build\u0026amp;Run) 中Default build directory：./%{CurrentBuild:Name}是不会生效的。\n将工具–\u0026gt;选项–\u0026gt;构建和运行中Default build directory修改为./%{CurrentBuild:Name}（改为你想要的目标目录都行）；\n把 QtCreator 关闭，把工程目录下后缀名为.pro.user的文件删掉；\n用 QtCreator 打开工程，会提示你创建构建目录，此时提示的就是你修改后的Default build directory中填写的目录；\n其中.pro.user文件记录了编译器、构建工具链、构建目录、版本…..等工程编译相关信息，想要更换项目的编译环境，得删除这个文件，由 QtCreator 自动重新创建。\n","permalink":"https://lifeislife.cn/posts/qtcreator%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%9B%AE%E5%BD%95/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003eQtCreator 构建项目时，会在统计目录新建一个\u003ccode\u003ebuild-xxx-debug\u003c/code\u003e的目录，如果想要自己修改这个目录的位置，名称，该怎么办。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e仅修改工具（Tool）–\u0026gt;选项 (Options)–\u0026gt;构建和运行 (Build\u0026amp;Run) 中\u003ccode\u003eDefault build directory：./%{CurrentBuild:Name}\u003c/code\u003e是不会生效的。\u003c/p\u003e","title":"QtCreator 修改项目构建目录"},{"content":"需求 因为现在大部分情况下是先从远程 Clone 下来代码，所以这一功能用的不多。但是如果自己想把本地已有的代码同步到远程，本文就可以解决这一的需求。\n方法 GitHub 新建一个仓库，并复制 SSH 地址\ngit@github.com:git201901/git_learning.git git remote add 名称\npc:git-learning suling$ git remote add github git@github.com:git201901/git_learning.git 这里的github就是自定义的一个名称，用于替换后面的远程地址。方便后续git push github以及git fetch github。\n","permalink":"https://lifeislife.cn/posts/git%E6%8A%8A%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5%E5%88%B0github/","summary":"\u003ch2 id=\"需求\"\u003e需求\u003c/h2\u003e\n\u003cp\u003e因为现在大部分情况下是先从远程 Clone 下来代码，所以这一功能用的不多。但是如果自己想把本地已有的代码同步到远程，本文就可以解决这一的需求。\u003c/p\u003e\n\u003ch2 id=\"方法\"\u003e方法\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGitHub 新建一个仓库，并复制 SSH 地址\u003c/p\u003e","title":"Git-把本地仓库同步到 GitHub"},{"content":"链接时缺失了相关目标文件 这是最典型最常见的情况。比如新添加了一个模块fun.h fun.c两个文件，其他文件中使用了这个模块里的函数，如果编译时忘记加上这两个文件，调用fun模块函数的地方，就会报undefined reference错误。\n这个问题在编辑器中一般不容易发现，因为头文件包含是正确的，编辑器能够找到相关的函数及其实现，所以在编写代码时不会报错。\n链接时缺少相关的库文件 这个原因和上一条类似，我们在调用静态库中的函数时，编译时如果没有将静态库一起编译，就会报同样的错误。\n链接的库文件中又使用了另一个库文件 在使用第三方库时，一定要在编译中加入第三方库的路径。\n多个库文件链接顺序问题 在链接命令中给出所依赖的库时，需要注意库之间的依赖顺序，依赖其他库的库一定要放到被依赖库的前面，这样才能真正避免 undefined reference 的错误，完成编译链接。\n声明与实现不一致 这个原因也比较典型，注意排查声明与实现的参数是否一致，返回值是否一致。\n在 c++代码中链接 c 语言的库 在C++代码中，调用了C语言库的函数，因此链接的时候找不到，解决方法是在相关文件添加一个extern \u0026quot;C\u0026quot;的声明即可。\n总结 顾名思义，这个错误就是未定义你使用的内容导致的。所以要排查使用的内容是否能够被正确“找到”。使用的时候有没有声明，有没有定义，声明与定义是否一致，编译时能否正确链接等等。\n相关参考 \u0026ldquo;undefined reference to\u0026rdquo; 问题汇总及解决方法\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3undefined-reference-to%E9%97%AE%E9%A2%98/","summary":"\u003ch2 id=\"链接时缺失了相关目标文件\"\u003e链接时缺失了相关目标文件\u003c/h2\u003e\n\u003cp\u003e这是最典型最常见的情况。比如新添加了一个模块\u003ccode\u003efun.h fun.c\u003c/code\u003e两个文件，其他文件中使用了这个模块里的函数，如果编译时忘记加上这两个文件，调用\u003ccode\u003efun\u003c/code\u003e模块函数的地方，就会报\u003ccode\u003eundefined reference\u003c/code\u003e错误。\u003c/p\u003e","title":"解决 Undefined reference to 问题"},{"content":"‘\n具体实例可以参考Marc Pony\n指针传参 C 语言中，全局变量用结构体封装，设计函数时，将参数以结构体指针形式传入。\n定义获取变量的方法/函数 定义一个函数以get/set全局变量，利用static变量，将全局变量作用域限定于该函数，将全局变量隐藏起来。\n善用static 把全局变量定义在某一个 .c 文件中，并定义为 static 类型，然后定义一系列操作这个变量的函数，头文件里面只有操作函数，没有变量的声明\n","permalink":"https://lifeislife.cn/posts/c-c-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/","summary":"\u003cp\u003e‘\u003c/p\u003e\n\u003cp\u003e具体实例可以参考\u003ca href=\"https://blog.csdn.net/maple_2014/article/details/109541104\"\u003eMarc Pony\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"指针传参\"\u003e指针传参\u003c/h2\u003e\n\u003cp\u003eC 语言中，全局变量用结构体封装，设计函数时，将参数以结构体指针形式传入。\u003c/p\u003e\n\u003ch2 id=\"定义获取变量的方法函数\"\u003e定义获取变量的方法/函数\u003c/h2\u003e\n\u003cp\u003e定义一个函数以\u003ccode\u003eget/set\u003c/code\u003e全局变量，利用\u003ccode\u003estatic\u003c/code\u003e变量，将全局变量作用域限定于该函数，将全局变量隐藏起来。\u003c/p\u003e","title":"C/C++如何避免过多使用全局变量"},{"content":"C 语言中各个数据类型的大小 类型 大小 范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 结构体 (struct) 待分析，需要考虑字节对齐 联合 (union) 所有成员中最长的 枚举 (enum) 根据数据类型 单层结构体大小 如果结构体中的成员数据类型相同，这样的情况最简单，结构体大小=数据类型*数据个数。\n#include \u0026lt;stdio.h\u0026gt; typedef struct Test1 { int a; int b; } T1; typedef struct Test2 { char a; char b; } T2; int main() { T1 t1; int siz01 = sizeof(t1); printf(\u0026#34;%d\\n\u0026#34;, siz01); //8 T2 t2; int siz02 = sizeof(t2); printf(\u0026#34;%d\\n\u0026#34;, siz02); //2 return 0; } 但是结构体中通常数据类型都各不相同，成员按照定义时的顺序依次存储在连续的内存空间。和数组不一样的是，结构体的大小不是所有成员大小简单的相加，需要考虑到地址对齐问题。看下面这样的一个结构体：\n#include \u0026lt;stdio.h\u0026gt; typedef struct Test3 { int a; char b; int c; } T3; int main() { T3 t3; int siz03 = sizeof(t3); printf(\u0026#34;t3: %d\\n\u0026#34;, siz03); //t3: 12 return 0; } 用sizeof求该结构体的大小，发现值为12。int占4个字节，char占1个字节，结果应该是9个字节才对啊，为什么呢？\n先介绍一个相关的概念——偏移量。偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员int a的偏移量为0。第二个成员char b的偏移量是第一个成员的偏移量加上第一个成员的大小0+4,其值为4；第三个成员int c的偏移量是第二个成员的偏移量加上第二个成员的大小4+1,其值为5。\n即结构体的大小等于最后一个成员变量的地址与第一个成员变量的地址之差，再加上最后一个成员变量的大小。\n如果不考虑对齐的情况，变量在内存中的存放如下，\n//t3 ________ 0 |aaaabccc| 7 8 |c | 15 ‾‾‾‾‾‾‾‾ 当我们凭直觉去用4+1+4=9来计算结构体大小时并不会觉得有什么错，但是通过内存的排放可以直观的看到，第三个变量的存放有点奇怪。CPU 从内存中读取肯定也是极为不便的。实际存储变量时，地址要求对齐的。编译器在编译程序时会遵循两条原则：\n结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。 我们在回头分析上述的例子，前两个成员的偏移量0 4都满足要求，但第三个成员的偏移量为5，并不是自身int大小的整数倍。编译器在处理时会在第二个成员后面补上3个空字节，使得第三个成员的偏移量变成8。结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为12，满足公倍数要求。\n直观描述这个结构体在内存中的存储如下，星号*表示该段内存因为内存对齐被占用，也就是其实际大小。字母个数表示其单独拿出来的大小\n//t3 ________ 0 |aaaab***| 7 8 |cccc | 15 ‾‾‾‾‾‾‾‾ 再看一例，\n#include \u0026lt;stdio.h\u0026gt; typedef struct Test4 { int a; short b; } T4; int main() { T4 t4; int siz04 = sizeof(t4); printf(\u0026#34;t4: %d\\n\u0026#34;, siz04); //t4: 8 return 0; } 成员int a的偏移量为 0；成员short b的偏移量为 4，都不需要调整。但计算出来的大小为6，显然不是成员int a大小的整数倍。因此，编译器会在成员int b后面补上2个字节，使得结构体的大小变成8从而满足第二个公倍数要求。\n由此可见，结构体类型需要考虑到字节对齐的情况，不同的顺序会影响结构体的大小。\n#include \u0026lt;stdio.h\u0026gt; typedef struct Test5 { char a; int b; char c; } T5; typedef struct Test6 { char a; char b; int c; } T6; int main() { T5 t5; int siz05 = sizeof(t5); printf(\u0026#34;t5: %d\\n\u0026#34;, siz05); //t5: 12 T4 t6; int siz06 = sizeof(t6); printf(\u0026#34;t6: %d\\n\u0026#34;, siz06); //t6: 8 return 0; } 两个结构体成员都一样，但是一个大小为12一个大小为8。我们将其在内存的存储画出来就可以明白，\n//t5 ________ 0 |a***bbbb| 7 8 |c*** | 15 ‾‾‾‾‾‾‾‾ //t6 ________ 0 |ab**cccc| 7 ‾‾‾‾‾‾‾‾ 总结：\n结构体大小等于最后一个成员的偏移量加上最后一个成员的大小 结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数 不同的顺序会影响结构体的大小 嵌套结构体大小 对于嵌套的结构体，需要将其展开。对结构体求sizeof时，上述两种原则变为：\n展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。 结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。 #include \u0026lt;stdio.h\u0026gt; typedef struct Test7 { short a; struct { char b; int c; } tt; int d; } T7; int main() { T7 t7; int siz07 = sizeof(t7); printf(\u0026#34;t7: %d\\n\u0026#34;, siz07); //t7: 16 return 0; } 根据原则一，tt的偏移量应该是4，而不是2。\n在内存中的存储，\n//t7 ________ 0 |aa**b***| 7 8 |ccccdddd| 15 ‾‾‾‾‾‾‾‾ #include \u0026lt;stdio.h\u0026gt; typedef struct Test8 { char a; struct { char b; int c; } tt; char d; char e; char f; char g; char h; } T8; int main() { T8 t8; int siz08 = sizeof(t8); printf(\u0026#34;t8: %d\\n\u0026#34;, siz08); //t8: 20 return 0; } 结构体tt单独计算占用空间为8，而t8则是20，不是8的整数倍，这说明在计算sizeof(t8)时，将嵌套的结构体tt展开了，这样t8中最大的成员为tt.c，占用 4 个字节，20为 4 的整数倍。如果将tt当做一个整体，结果应该是24了。\n在内存中的存储，\n//t8 ________ 0 |a***b***| 7 8 |ccccdefg| 15 16 |h*** | 31 ‾‾‾‾‾‾‾‾ 另一个特殊的例子是结构体中包含数组，其大小计算应当和处理嵌套结构体一样，将其展开，如下例子：\n#include \u0026lt;stdio.h\u0026gt; typedef struct Test9 { char a; float b; int c[2]; } T9; int main() { T9 t9; int siz09 = sizeof(t9); printf(\u0026#34;t9: %d\\n\u0026#34;, siz09); //t9: 16 return 0; } char a占一个字节，偏移量为0，short b占四字节，偏移量为2，不是最大成员的整数倍，这里取最大成员是int或者short的大小的倍数。而不是整个数组int c[2]的倍数。所以short b偏移量扩展为4。\n内存中存储，\n//t9 ________ 0 |a***bbbb| 7 8 |cccccccc| 15 ‾‾‾‾‾‾‾‾ 总结：\n展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。 结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。 想象在内存中的存储，保证对齐要求，基本上可以比较准确的算出来 ","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80sizeof-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%A4%A7/","summary":"\u003ch2 id=\"c-语言中各个数据类型的大小\"\u003eC 语言中各个数据类型的大小\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e类型\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e大小\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e范围\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003echar\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e-128 到 127 或 0 到 255\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eunsigned char\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e0 到 255\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003esigned char\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e-128 到 127\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eint\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e2 或 4 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eunsigned int\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e2 或 4 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e0 到 65,535 或 0 到 4,294,967,295\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eshort\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e2 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e-32,768 到 32,767\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eunsigned short\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e2 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e0 到 65,535\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003elong\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e4 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e-2,147,483,648 到 2,147,483,647\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eunsigned long\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e4 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e0 到 4,294,967,295\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e结构体 (struct)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e待分析，需要考虑字节对齐\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e联合 (union)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e所有成员中最长的\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e枚举 (enum)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e根据数据类型\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"单层结构体大小\"\u003e单层结构体大小\u003c/h2\u003e\n\u003cp\u003e如果结构体中的成员数据类型相同，这样的情况最简单，\u003ccode\u003e结构体大小=数据类型*数据个数\u003c/code\u003e。\u003c/p\u003e","title":"C 语言 sizeof(结构体) 到底有多大"},{"content":"简介 我们经常用到命令行参数，比如最常见的 Linux 命令，显示所有文件ls -a,ls其实就是一个程序，-a就是该程序需要解析的一个参数。那么如何能让 Qt 程序也能解析命令行参数，从命令行启动呢？\nQt 从 5.2 版开始提供了两个类QCommandLineOption和QCommandLineParser来解析应用的命令行参数。\n添加程序属性信息，帮助，版本 一个程序启动后，我们会在命令行看到程序的一些简要信息，以及可以使用-v命令显示其版本信息，这些通用的参数以及被 Qt 分装好，可以直接使用。\n#include \u0026#34;mainwindow.h\u0026#34; #include \u0026lt;QApplication\u0026gt; #include \u0026lt;QCommandLineParser\u0026gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); QCommandLineParser parser; // 定义解析实例 parser.setApplicationDescription(\u0026#34;TestCommandLine\u0026#34;); // 描述可执行程序的属性 parser.addHelpOption(); // 添加帮助命令 parser.addVersionOption(); // 添加版本选择命令 parser.process(a); // 把用户的命令行的放入解析实例 MainWindow w; w.show(); return a.exec(); } 运行结果：\n➜ ./CommandLine -h Usage: ./CommandLine [options] TestCommandLine Options: -h, --help Displays help on commandline options. --help-all Displays help including Qt specific options. -v, --version Displays version information. 自定义参数 #include \u0026#34;mainwindow.h\u0026#34; #include \u0026lt;QApplication\u0026gt; #include \u0026lt;QCommandLineParser\u0026gt; #include \u0026lt;QCommandLineOption\u0026gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); QCommandLineParser parser; // 定义解析实例 parser.setApplicationDescription(\u0026#34;TestCommandLine\u0026#34;); // 描述可执行程序的属性 parser.addHelpOption(); // 添加帮助命令 parser.addVersionOption(); // 添加版本选择命令 QCommandLineOption CommandExe(\u0026#34;c\u0026#34;, QGuiApplication::translate(\u0026#34;main\u0026#34;,\u0026#34;Take the first argument as a command to execute, \u0026#34; \u0026#34;rather than reading commands from a script or standard input. \u0026#34; \u0026#34;If any fur‐\\ther arguments are given, \u0026#34; \u0026#34;the first one is assigned to $0,\u0026#34; \u0026#34; rather than being used as a positional parameter.\u0026#34;)); parser.addOption(CommandExe); parser.process(a); // 把用户的命令行的放入解析实例 MainWindow w; w.show(); return a.exec(); } 运行结果：\n➜ ./CommandLine -h Usage: ./CommandLine [options] TestCommandLine Options: -h, --help Displays help on commandline options. --help-all Displays help including Qt specific options. -v, --version Displays version information. -c Take the first argument as a command to execute, rather than reading commands from a script or standard input. If any fur‐ her arguments are given, the first one is assigned to $0, rather than being used as a positional parameter. 获取参数值 如果需要从命令行获取参数值，那么必须要给参数值，指定一个名字。如，参数接收的是路径，可以setValueName(\u0026quot;path\u0026quot;)，如，参数接收的是个数值，可以setValueName(\u0026quot;value\u0026quot;)。\n如果不设置参数值名称，那么将无法获取其值。\n","permalink":"https://lifeislife.cn/posts/qt%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E5%90%AF%E5%8A%A8qt%E7%A8%8B%E5%BA%8F/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e我们经常用到命令行参数，比如最常见的 Linux 命令，显示所有文件\u003ccode\u003els -a\u003c/code\u003e,\u003ccode\u003els\u003c/code\u003e其实就是一个程序，\u003ccode\u003e-a\u003c/code\u003e就是该程序需要解析的一个参数。那么如何能让 Qt 程序也能解析命令行参数，从命令行启动呢？\u003c/p\u003e","title":"Qt 命令行带参数启动 Qt 程序"},{"content":"需求 同一个项目，不同的开发者修改了不同的文件，如何解决同步冲突。\n模拟 用户一修改 第一个用户新建一个分支， \u003c!DOCTYPE html\u003e Responsive Image 以上命令就是新建一个分支feature/add_git_commands 将其与远端分支origin/feature/add_git_commands相关联，并切换到该分支。\n\u003c!DOCTYPE html\u003e Responsive Image 修改 readme 文件，并推送到远端。因为新建分支时已经做了与远端关联，所以可以直接git push。\n用户二修改 第二个用户，首先拉取远端分支。\n\u003c!DOCTYPE html\u003e Responsive Image git branch -v查看本地分支，保持不变，但是git branch -av查看所有分支，可以发现多了两个远端分支。 \u003c!DOCTYPE html\u003e Responsive Image 新建本地分支，保持与远端分支名相同。\n\u003c!DOCTYPE html\u003e Responsive Image 此时再对与 readme 不同的文件进行修改，提交，推送都会比较顺利。因为当前分支保持fast forward。\n用户二继续做开发，但是没再往远端推送代码。在此期间，用户一对远端代码进行了更新。用户二想再次推送代码，将会报错，提示当前提交不再fast forward。\n\u003c!DOCTYPE html\u003e Responsive Image 解决方法 git fetch远端分支 \u003c!DOCTYPE html\u003e Responsive Image git merge合并远端分支 \u003c!DOCTYPE html\u003e Responsive Image 因为两个用户修改的不同文件，所以合并不会产生冲突。\n","permalink":"https://lifeislife.cn/posts/git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/","summary":"\u003ch2 id=\"需求\"\u003e需求\u003c/h2\u003e\n\u003cp\u003e同一个项目，\u003cstrong\u003e不同的开发者修改了不同的文件\u003c/strong\u003e，如何解决同步冲突。\u003c/p\u003e\n\u003ch2 id=\"模拟\"\u003e模拟\u003c/h2\u003e\n\u003ch3 id=\"用户一修改\"\u003e用户一修改\u003c/h3\u003e\n\u003cp\u003e第一个用户新建一个分支，\n\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222312698.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222312698.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"Git 不同人修改了不同的文件该如何处理"},{"content":"安装 GitBook 时出现这个错误，将node版本降级即可\nMINGW64 ~/Desktop/dir1/dir11 $ gitbook init warn: no summary file in this book info: create SUMMARY.md TypeError [ERR_INVALID_ARG_TYPE]: The \u0026#34;data\u0026#34; argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3typeerror-err-invalid-arg-type-the-data-argument-must-be-of-type-string-or-an-instance-of-buffe/","summary":"\u003cp\u003e安装 GitBook 时出现这个错误，将\u003ccode\u003enode\u003c/code\u003e版本降级即可\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eMINGW64 ~/Desktop/dir1/dir11\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ gitbook init\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewarn: no summary file in this book\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003einfo: create SUMMARY.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eTypeError [ERR_INVALID_ARG_TYPE]: The \u0026#34;data\u0026#34; argument must be of type string\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e or an instance of Buffer, TypedArray, or DataView. Received an instance of\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ePromise\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"解决 TypeError [ERR_INVALID_ARG_TYPE]: The data argument must be of type string or an instance of Buffe"},{"content":"什么是预处理 C 语言通过预处理器提供了一些语言功能。从概念上讲，预处理器是编译过程中单独执行的第一个步骤。两个最常用的预处理器指令是：#include 指令 (用于在编译期间把指定文件的内容包含进当前文件中) 和 #define 指令 (用任意字符序列替代一个标记)。\n为啥要进行预先处理呢？如果要深入的了解的话可以参考《程序员的自我修养：链接、装载与库》这本书。这里举一个非常常见的例子，假如我们编写跨平台的程序时，我们就需要考虑不同平台的系统库是不同的，如果只包含了一个平台下的库文件，换个平台编译就可能出错。这时候就需要在编译前进行预处理。\n有重要的预处理器指令：\n指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else #if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器中 条件编译 #if #if 整型常量表达式1 程序段1 #elif 整型常量表达式2 程序段2 #elif 整型常量表达式3 程序段3 #else 程序段4 #endif 它的意思是：如常“表达式 1”的值为真（非 0），就对“程序段 1”进行编译，否则就计算“表达式 2”，结果为真的话就对“程序段 2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else 。这一点和 if else 非常类似。\n需要注意的是， #if 命令要求判断条件为整型常量表达式，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行。这是 #if 和 if 的一个重要区别。\n#include \u0026lt;stdio.h\u0026gt; //不同的平台下引入不同的头文件 #if _WIN32 //识别 Windows 平台 #include \u0026lt;windows.h\u0026gt; #elif __linux__ //识别 Linux 平台 #include \u0026lt;unistd.h\u0026gt; #endif int main() { //不同的平台下调用不同的函数 #if _WIN32 //识别 Windows 平台 Sleep(5000); #elif __linux__ //识别 Linux 平台 sleep(5); #endif puts(\u0026#34;http://c.biancheng.net/\u0026#34;); return 0; } #ifedf #ifdef 宏名 程序段1 #else 程序段2 #endif #ifndef #ifndef 宏名 程序段1 #else 程序段2 #endif 与#ifdef相比，仅仅是将 #ifdef 改为了 #ifndef。它的意思是，如果当前的宏未被定义，则对“程序段 1”进行编译，否则对“程序段 2”进行编译，这与#ifdef 的功能正好相反。\n文件包含#include #include 叫做文件包含命令，用来引入对应的头文件（.h 文件）。 #include 的处理过程很简单，就是将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。\n#include 的用法有两种，如下所示：\n#include \u0026lt;stdHeader.h\u0026gt; #include \u0026#34;myHeader.h\u0026#34; 使用尖括号 \u0026lt; \u0026gt; 和双引号 \u0026quot; \u0026quot; 的区别在于头文件的搜索路径不同：\n使用尖括号\u0026lt; \u0026gt;，编译器会到环境变量下查找头文件； 使用双引号\u0026quot; \u0026quot;，编译器首先在当前目录下查找头文件，如果没有找到，再到环境变量下查找。 注意事项：\n在头文件中尽量不要进行函数的定义，只对其进行声明。否则如果有多个源文件链接时会报错 某一个头文件的内容发生变化，所有包含该文件的源文件都需要重新编译 一个#include命令指定一个头文件，多个头文件需要多个#include 包含可以嵌套 文件 1 包含文件 2，文件 2 用到文件 3，则文件 3 的包含命令#include 应放在文件 1 的头部第一行； 被包含文件中的静态全局变量不用在包含文件中声明 宏定义 what #define 叫做宏定义命令，它也是 C 语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。\n#define 宏名 字符串 //基本格式 #define N 100 //将所有N都替换成整数100 #define forever for (;;) //该语句为无限循环定义了一个新名字forever #define max(A, B) ((A)\u0026gt; (B) ? (A) : (B) ) why 对于函数，其调用必须要将程序执行的顺序跳转到函数所在内存的某个地址，在将函数程序执行完成后，再跳转回去执行函数调用前的地方。这种跳转操作要求在函数执行前保存现场并记录当前执行地址，函数调用返回后要恢复现场，并按原来保存地址继续执行。因此，函数调用会有一定的时间和空间方面的开销，必将影响程序的运行效率。\n对于宏，它只是在预处理的地方把代码展开，而不需要额外的空间和时间方面的开销，因此调用宏比调用函数更有效率。\n但是，宏也有很多的问题和缺陷：\n在 C 语言中，宏容易出现一些边界性的问题，容易产生歧义。(优先级的问题，能加括号都加括号) 在 C++语言中，宏不可以调用 C++类中的私有或受保护的成员。 Tips 能用括号的地方都用括号，不要偷懒省略，以免歧义，特别是于带参宏定义不仅要在参数两侧加括号，还应该在整个字符串外加括号 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef命令 代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换 习惯上宏名用大写字母表示，以便于与变量区别 可用宏定义表示数据类型，使书写方便 带参数的宏和函数很相似，但有本质上的区别：宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。而函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。 内联函数 从上文可知，可以看到宏有一些难以避免的问题，对于不能访问 C++类中私有或者受保护的成员，我们应该如何解决呢？\nwhat 关键字 inline 告诉编译器，任何地方只要调用内联函数，就直接把该函数的机器码插入到调用它的地方。这样程序执行更有效率，就好像将内联函数中的语句直接插入到了源代码文件中需要调用该函数的地方一样。\nwhy 内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（过程化集成）被编译器优化。\n内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以像调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。\nHow 对于内联函数，其工作原理是：\n对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型）。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。\n这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。假如内联函数是成员函数，对象的地址（this）会被放在合适的地方，这也是预处理器办不到的。\nTips 当你定义一个内联函数时，在函数定义前加上 inline 关键字，并且将定义放入头文件。 内联函数必须是和函数体声明在一起才有效 内联函数不宜过大，比如循环体，递归体就不适合内联。如果过大，编译器会放弃内联，采用普通方式调用函数。 相关参考 C 预处理器 C 语言预处理命令是什么？ C 语言中宏与内联函数解析 C 语言内联函数 内联函数\n","permalink":"https://lifeislife.cn/posts/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/","summary":"\u003ch2 id=\"什么是预处理\"\u003e什么是预处理\u003c/h2\u003e\n\u003cp\u003eC 语言通过预处理器提供了一些语言功能。从概念上讲，预处理器是编译过程中单独执行的第一个步骤。两个最常用的预处理器指令是：\u003ccode\u003e#include\u003c/code\u003e 指令 (用于在编译期间把指定文件的内容包含进当前文件中) 和 \u003ccode\u003e#define\u003c/code\u003e 指令 (用任意字符序列替代一个标记)。\u003c/p\u003e","title":"C 语言预处理"},{"content":"在使用exec系列函数时，execle，execv，execvp三个函数，都可以使用char *arg[]传入启动参数。以下面的程序为例，\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(void) { int ret; char *argv[] = {\u0026#34;ls\u0026#34;,\u0026#34;-l\u0026#34;,NULL}; ret = execvp(\u0026#34;ls\u0026#34;,argv); if(ret == -1) perror(\u0026#34;execl error\u0026#34;); return 0; } 编译时就会出现一下，警告，\nexpected \u0026#39;char * const*\u0026#39; but argument is of type \u0026#39;const char **\u0026#39; 因为项目中不允许警告产生，所以编译选项是-Werror，所有警告都会被升级成错误。编译时就会产生如下提示，\nccl : all warnings being treated as errors 如果是平时练习，改一下编译选项，把这个警告忽略就行，但是现在只能解决。\n出现这个问题就是因为定义数组时char *argv[]类型是char **。但是execvp()函数签名是execvp(const char *file, char *const argv[]);第二个参数的类型是char * const *。\n本以为直接将变量定义更改成char * const argv[]就行了，但是它等价于const char **，所以仍然不能和函数签名匹配。\n实在没办法只能改成如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(void) { printf(\u0026#34;entering main process---\\n\u0026#34;); int ret; char str1[] = \u0026#34;ls\u0026#34;; char str2[] = \u0026#34;-l\u0026#34;; char * const argv[] = {str1, str2, NULL}; ret = execvp(\u0026#34;ls\u0026#34;,argv); if(ret == -1) perror(\u0026#34;execl error\u0026#34;); printf(\u0026#34;exiting main process ----\\n\u0026#34;); return 0; } 或者在将形参argv进行强制转换。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(void) { printf(\u0026#34;entering main process---\\n\u0026#34;); int ret; char const *argv[] = {\u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;, NULL}; ret = execvp(\u0026#34;ls\u0026#34;,(char * const *)argv); if(ret == -1) perror(\u0026#34;execl error\u0026#34;); printf(\u0026#34;exiting main process ----\\n\u0026#34;); return 0; } ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/","summary":"\u003cp\u003e在使用\u003ccode\u003eexec\u003c/code\u003e系列函数时，\u003ccode\u003eexecle\u003c/code\u003e，\u003ccode\u003eexecv\u003c/code\u003e，\u003ccode\u003eexecvp\u003c/code\u003e三个函数，都可以使用\u003ccode\u003echar *arg[]\u003c/code\u003e传入启动参数。以下面的程序为例，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eret\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eargv\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;ls\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;-l\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003eexecvp\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;ls\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eargv\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nf\"\u003eperror\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;execl error\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e编译时就会出现一下，警告，\u003c/p\u003e","title":"解决 expected 'char * const*' but argument is of type 'char **'"},{"content":"在调试 QEMU 时，自己需要修改源文件，但是每次修改都需要在命令行重新make编译一遍，比较麻烦，想到之前刚刚配置过tasks.json文件，可以把命令行任务配置到文件里，make命令不也一样可以加入吗？修改tasks.json文件如下：\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { //任务的名字方便执行 \u0026#34;label\u0026#34;: \u0026#34;make qemu\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;make\u0026#34;, \u0026#34;args\u0026#34;:[ //8 线程编译 \u0026#34;-j8\u0026#34;, ], \u0026#34;options\u0026#34;: { //切换到 build 文件夹下 \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}/build\u0026#34; }, }, { // 启动 qemu 供调试器连接 \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Run Qemu Server(RISCV)\u0026#34;, //在执行这个任务前，先执行 make qemu 任务、 //这样就可以在执行调试时，自动先编译一遍 \u0026#34;dependsOn\u0026#34;: \u0026#34;make qemu\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;qemu-system-riscv64\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${workspaceFolder}/debug/${fileBasenameNoExtension}\u0026#34; ], }, ] } ","permalink":"https://lifeislife.cn/posts/vscode%E4%B8%AD%E8%B0%83%E8%AF%95%E5%B8%A6makefile%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%B9%E7%9B%AE/","summary":"\u003cp\u003e在调试 QEMU 时，自己需要修改源文件，但是每次修改都需要在命令行重新\u003ccode\u003emake\u003c/code\u003e编译一遍，比较麻烦，想到之前刚刚配置过\u003ccode\u003etasks.json\u003c/code\u003e文件，可以把命令行任务配置到文件里，\u003ccode\u003emake\u003c/code\u003e命令不也一样可以加入吗？修改\u003ccode\u003etasks.json\u003c/code\u003e文件如下：\u003c/p\u003e","title":"VSCode 中调试带 Makefile 文件的项目"},{"content":"问题 这是一类问题，不仅限于安装 gcc，这类问题的根本原因在于，Ubuntu 已安装的软件包版本高，而所安装软件的依赖包版本低，这样在安装高版软件时，已有的软件包依赖你要安装的软件包，你把软件包升级了，可能就会破坏这个依赖关系，所以apt-get不让你安装。\n这时就要请到大杀器-aptitude，它与 apt-get一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。\n方法 $sudo apt-get install aptitude //安装aptitude包管理器 $sudo aptitude install gcc-multilib //用新的包管理器安装你要安装的软件 安装gcc-multilib时会把所有依赖包一并安装，此时会让你同意，选择n就行。\n接下来就会解决已经安装的包之间的依赖关系，他会降级或升级一些软件包来匹配当前安装的软件版本，此时选择y。\n完成以上操作，再次正常安装需要的软件包即可成功安装。\n如果无法正常安装，重复以上操作，每次都选择n。\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3gcc-multilib-%E4%BE%9D%E8%B5%96-gcc-4-8-multilib-4-8-2-5-%E4%BD%86%E6%98%AF%E5%AE%83%E5%B0%86%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%AE%89%E8%A3%85/","summary":"\u003ch2 id=\"问题\"\u003e问题\u003c/h2\u003e\n\u003cp\u003e这是一类问题，不仅限于安装 gcc，这类问题的根本原因在于，\u003cstrong\u003eUbuntu 已安装的软件包版本高，而所安装软件的依赖包版本低\u003c/strong\u003e，这样在安装高版软件时，已有的软件包依赖你要安装的软件包，你把软件包升级了，可能就会破坏这个依赖关系，所以\u003ccode\u003eapt-get\u003c/code\u003e不让你安装。\u003c/p\u003e","title":"解决 gcc-multilib : 依赖：gcc-4.8-multilib (\u003e= 4.8.2-5~) 但是它将不会被安装"},{"content":"保留现场 想要分别编译 32 位和 64 位的程序时，gcc 出现了错误，\nIn file included from func_call.c:1: /usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: 没有那个文件或目录 27 | #include \u0026lt;bits/libc-header-start.h\u0026gt; | ^~~~~~~~~~~~~~~~~~~~~~~~~~ compilation terminated. 问题解决 问题原因猜测是默认 gcc 只提供当前机器的版本，解决如下\napt install gcc-multilib ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3fatal-error-bits-libc-header-start-hno-such-file/","summary":"\u003ch2 id=\"保留现场\"\u003e保留现场\u003c/h2\u003e\n\u003cp\u003e想要分别编译 32 位和 64 位的程序时，gcc 出现了错误，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eIn file included from func_call.c:1:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: 没有那个文件或目录\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   27 | #include \u0026lt;bits/libc-header-start.h\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecompilation terminated.\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"问题解决\"\u003e问题解决\u003c/h2\u003e\n\u003cp\u003e问题原因猜测是默认 gcc 只提供当前机器的版本，解决如下\u003c/p\u003e","title":"解决 fatal error: bits/libc-header-start.h：no such file"},{"content":"流程图 先开个头吧，把创建流程稍微捋一下，找到创建虚拟 CPU 的模块。至于中间的流程还没有详细分析，万事开头难，先上手再说吧。\n\u003c!DOCTYPE html\u003e Responsive Image qemu_add_opts解析 qemu 的命令行 qemu_init函数中下面这一长串内容，就是在解析命令行的参数。\nqemu add opts (\u0026amp;qemu drive opts); qemu add drive opts(\u0026amp;qemu Legacy drive opts); qemu add drive opts (\u0026amp;qemu common drive opts); qemu add drive opts (\u0026amp;qemu drive opts); qemu add drive opts (sbdry runtime opts); qemu add opts (qemu chardev opts); qemu add opts (\u0026amp;qemu device opts); qemu add opts (\u0026amp;qemu netdev opts); qemu add opts (\u0026amp;qemu nic opts); qemu add opts (sqemu net opts qemu add opts (\u0026amp;qemu rtc opts) qemu add opts (\u0026amp;qemu global_opts); qemu add opts (\u0026amp;qemu mon opts); qemu add opts (sqemu trace opts); . . . 为什么有这么多的 opts呢？这是因为，实际运行中创建的kvm参数会复杂N倍。这里我们贴一个开源云平台软件 OpenStack 创建出来的KVM的参数，如下所示。\nqemu-system-x86_64 -enable-kvm -name instance-00000024 -machine pc-i440fx-trusty,accel=kvm,usb=off -cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme -m 2048 -smp 1,sockets=1,cores=1,threads=1 ...... -rtc base=utc,driftfix=slew -drive file=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if=none,id=drive-virtio-disk0,format=qcow2,cache=none -device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x4,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1 -netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37 -device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3 -chardev file,id=charserial0,path=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/console.log -vnc 0.0.0.0:12 -device cirrus-vga,id=video0,bus=pci.0,addr=0x2 -enable-kvm：表示启用硬件辅助虚拟化。\n-name instance-00000024：表示虚拟机的名称。\n-machine pc-i440fx-trusty,accel=kvm,usb=off：machine 是什么呢？其实就是计算机体系结构。不知道什么是体系结构的话，可以订阅极客时间的另一个专栏《深入浅出计算机组成原理》。 qemu 会模拟多种体系结构，常用的有普通 PC 机，也即 x86 的 32 位或者 64 位的体系结构、Mac 电脑 PowerPC 的体系结构、Sun 的体系结构、MIPS 的体系结构，精简指令集。如果使用 KVM hardware-assisted virtualization，也即 BIOS 中 VD-T 是打开的，则参数中 accel=kvm。如果不使用 hardware-assisted virtualization，用的是纯模拟，则有参数 accel = tcg，-no-kvm。\n-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme：表示设置 CPU，SandyBridge 是 Intel 处理器，后面的加号都是添加的 CPU 的参数，这些参数会显示在 /proc/cpuinfo 里面。\n-m 2048：表示内存。\n-smp 1,sockets=1,cores=1,threads=1：SMP 我们解析过，叫对称多处理器，和NUMA 对应。qemu 仿真了一个具有 1 个 vcpu，一个 socket，一个 core，一个 threads 的处理器。 socket、core、threads 是什么概念呢？socket 就是主板上插 CPU 的槽的数目，也即常说的“路”，core 就是我们平时说的“核”，即双核、4 核等。thread 就是每个 core 的硬件线程数，即超线程。举个具体的例子，某个服务器是：2 路 4 核超线程（一般默认为 2 个线程），通过 cat /proc/cpuinfo，我们看到的是 242=16 个processor，很多人也习惯成为 16 核了。\n-rtc base=utc,driftfix=slew：表示系统时间由参数 -rtc 指定。\n-device cirrus-vga,id=video0,bus=pci.0,addr=0x2：表示显示器用参数 -vga 设置，默认为 cirrus，它模拟了 CL-GD5446PCI VGA card。\n有关网卡，使用 -net 参数和 -device。\n从 HOST 角度：-netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37。\n从 GUEST 角度：-device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3。\n有关硬盘，使用 -hda -hdb，或者使用 -drive 和 -device。\n从 HOST 角度：-drive file=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if=none,id=drive-virtio-disk0,format=qcow2,cache=none\n从 GUEST 角度：-device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x4,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1\n-vnc 0.0.0.0:12：设置 VNC。\nmodule_call_init初始化所有模块 int main() --\u0026gt; qemu_init() --\u0026gt; qemu_init_subsystems() --\u0026gt; module_call_init() 当虚拟机真的要使用物理资源的时候，对下面的物理机上的资源要进行请求，所以它的工作模式有点儿类似操作系统对接驱动。驱动要符合一定的格式，才能算操作系统的一个模块。同理，qemu 为了模拟各种各样的设备，也需要管理各种各样的模块，这些模块也需要符合一定的格式。\n定义一个 qemu 模块会调用 type_init。例如，kvm 的模块要在 accel/kvm/kvm-all.c 文件里面实现。在这个文件里面，有一行下面的代码：\nstatic const TypeInfo kvm_accel_type = { .name = TYPE_KVM_ACCEL, .parent = TYPE_ACCEL, .instance_init = kvm_accel_instance_init, .class_init = kvm_accel_class_init, .instance_size = sizeof(KVMState), }; static void kvm_type_init(void) { type_register_static(\u0026amp;kvm_accel_type); } type_init(kvm_type_init); 找到type_init的定义\n#define type_init(function) module_init(function, MODULE_INIT_QOM) 从代码里面的定义我们可以看出来，type_init 后面的参数是一个函数，调用 type_init 就相当于调用 module_init，在这里函数就是 kvm_type_init，类型就是 MODULE_INIT_QOM。\n再查看一下module_init的定义\n//include/qemu/module.h #define module_init(function, type) \\ static void __attribute__((constructor)) do_qemu_init_ ## function(void) \\ { \\ register_module_init(function, type); \\ } module_init 最终要调用 register_module_init。属于 MODULE_INIT_QOM 这种类型的，有一个 Module 列表 ModuleTypeList，列表里面是一项一项的 ModuleEntry。KVM 就是其中一项，并且会初始化每一项的 init 函数为参数表示的函数 fn，也即 KVM 这个 module 的 init 函数就是 kvm_type_init。\n当然，MODULE_INIT_QOM 这种类型会有很多很多的 module，从后面的代码我们可以看到，所有调用 type_init 的地方都注册了一个 MODULE_INIT_QOM 类型的 Module。\n了解了 Module 的注册机制，我们继续回到 qemu_init_subsystems 函数中 module_call_init 的调用。\nvoid qemu_init_subsystems(void) { Error *err; os_set_line_buffering(); module_call_init(MODULE_INIT_TRACE); qemu_init_cpu_list(); qemu_init_cpu_loop(); qemu_mutex_lock_iothread(); atexit(qemu_run_exit_notifiers); module_call_init(MODULE_INIT_QOM); module_call_init(MODULE_INIT_MIGRATION); . . . } // utils/module.c void module_call_init(module_init_type type) { ModuleTypeList *l; ModuleEntry *e; l = find_type(type); QTAILQ_FOREACH(e, l, node) { e-\u0026gt;init(); } } 在 module_call_init 中，我们会找到 MODULE_INIT_QOM 这种类型对应的 ModuleTypeList，找出列表中所有的 ModuleEntry，然后调用每个 ModuleEntry 的 init 函数。这里需要注意的是，在 module_call_init 调用的这一步，所有 Module 的 init 函数都已经被调用过了。\n后面我们会看到很多的 Module，当我们后面再次遇到时，需要意识到，它的 init 函数在这里也被调用过了。这里我们还是以对于 kvm 这个 module 为例子，看看它的 init 函数都做了哪些事情。我们会发现，其实它调用的是 kvm_type_init。\nstatic void kvm_type_init(void) { type_register_static(\u0026amp;kvm_accel_type); } TypeImpl *type_register_static(const TypeInfo *info) { return type_register(info); } TypeImpl *type_register(const TypeInfo *info) { assert(info-\u0026gt;parent); return type_register_internal(info); } static TypeImpl *type_register_internal(const TypeInfo *info) { TypeImpl *ti; ti = type_new(info); type_table_add(ti); return ti; } static TypeImpl *type_new(const TypeInfo *info) { TypeImpl *ti = g_malloc0(sizeof(*ti)); int i; if (type_table_lookup(info-\u0026gt;name) != NULL) { } ti-\u0026gt;name = g_strdup(info-\u0026gt;name); ti-\u0026gt;parent = g_strdup(info-\u0026gt;parent); ti-\u0026gt;class_size = info-\u0026gt;class_size; ti-\u0026gt;instance_size = info-\u0026gt;instance_size; ti-\u0026gt;class_init = info-\u0026gt;class_init; ti-\u0026gt;class_base_init = info-\u0026gt;class_base_init; ti-\u0026gt;class_data = info-\u0026gt;class_data; ti-\u0026gt;instance_init = info-\u0026gt;instance_init; ti-\u0026gt;instance_post_init = info-\u0026gt;instance_post_init; ti-\u0026gt;instance_finalize = info-\u0026gt;instance_finalize; ti-\u0026gt;abstract = info-\u0026gt;abstract; for (i = 0; info-\u0026gt;interfaces \u0026amp;\u0026amp; info-\u0026gt;interfaces[i].type; i++) { ti-\u0026gt;interfaces[i].typename = g_strdup(info-\u0026gt;interfaces[i].type); } ti-\u0026gt;num_interfaces = i; return ti; } static void type_table_add(TypeImpl *ti) { assert(!enumerating_types); g_hash_table_insert(type_table_get(), (void *)ti-\u0026gt;name, ti); } static GHashTable *type_table_get(void) { static GHashTable *type_table; if (type_table == NULL) { type_table = g_hash_table_new(g_str_hash, g_str_equal); } return type_table; } static const TypeInfo kvm_accel_type = { .name = TYPE_KVM_ACCEL, .parent = TYPE_ACCEL, .class_init = kvm_accel_class_init, .instance_size = sizeof(KVMState), }; 调用流程如下：虚线表示返回\n\u003c!DOCTYPE html\u003e Responsive Image 每一个 Module 既然要模拟某种设备，那应该定义一种类型 TypeImpl 来表示这些设备，这其实是一种面向对象编程的思路，只不过这里用的是纯 C 语言的实现，所以需要变相实现一下类和对象。\nkvm_type_init 会注册 kvm_accel_type，定义上面的代码，我们可以认为这样动态定义了一个类。这个类的名字是 TYPE_KVM_ACCEL，这个类有父类 TYPE_ACCEL，这个类的初始化应该调用函数 kvm_accel_class_init。如果用这个类声明一个对象，对象的大小应该是 instance_size。\n在 type_register_internal 中，我们会根据 kvm_accel_type 这个 TypeInfo，创建一个TypeImpl 来表示这个新注册的类，也就是说，TypeImpl 才是我们想要声明的那个 class。在 qemu 里面，有一个全局的哈希表 type_table，用来存放所有定义的类。在 type_new 里面，我们先从全局表里面根据名字type_table_lookup查找找这个类。如果找到，说明这个类曾经被注册过，就报错；如果没有找到，说明这是一个新的类，则将 TypeInfo 里面信息填到 TypeImpl 里面。type_table_add 会将这个类注册到全局的表里面。到这里，我们注意，class_init 还没有被调用，也即这个类现在还处于纸面的状态。\n这点更加像 Java 的反射机制了。在 Java 里面，对于一个类，首先我们写代码的时候要写一个 class xxx 的定义，编译好就放在.class 文件中，这也是出于纸面的状态。然后，Java 会有一个 Class 对象，用于读取和表示这个纸面上的 class xxx，可以生成真正的对象。\n相同的过程在后面的代码中我们也可以看到，class_init 会生成XXXClass，就相当于 Java 里面的 Class对象，TypeImpl 还会有一个 instance_init 函数，相当于构造函数，用于根据 XXXClass 生成 Object，这就相当于 Java 反射里面最终创建的对象。和构造函数对应的还有 instance_finalize，相当于析构函数。\n这一套反射机制放在 qom 文件夹下面，全称 QEMU Object Model，也即用 C 实现了一套面向对象的反射机制。\n初始化 machine \u003c!DOCTYPE html\u003e Responsive Image //vl.c qemu_create_machine (select_machine()); 在创建 machine 之前，先要通过select_machine确定一个machine。select_machine又是怎么确定的呢，这就和我们命令行的输入有关，比如我们-m spike，那么这里就会选择spike作为machine。它的定义在hw/riscv/spike.c中。\n在源码最后有这么一句，会和我们上面解析的type_init 是一样的，在全局的表里面注册了一个全局的名字是spike的纸面上的 class，也即 TypeImpl。\ntype_init(spike_machine_init_reqister_types) 现在全局表中有这个纸面上的 class 了。我们回到 select_machine。\n在 select_machine 中，有两种方式可以生成 MachineClass。一种方式是 find_default_machine，找一个默认的；另一种方式是 machine_parse，通过解析参数生成 MachineClass。无论哪种方式，都会调用 object_class_get_list 获得一个 MachineClass 的列表，然后在里面找。\nstatic MachineClass *select_machine(void) { GSList *machines = object_class_get_list(TYPE_MACHINE, false); MachineClass *machine_class = find_default_machine(machines); const char *optarg; QemuOpts *opts; Location loc; loc_push_none(\u0026amp;loc); opts = qemu_get_machine_opts(); qemu_opts_loc_restore(opts); optarg = qemu_opt_get(opts, \u0026#34;type\u0026#34;); if (optarg) { machine_class = machine_parse(optarg, machines); } if (!machine_class) { error_report(\u0026#34;No machine specified, and there is no default\u0026#34;); error_printf(\u0026#34;Use -machine help to list supported machines\\n\u0026#34;); exit(1); } loc_pop(\u0026amp;loc); g_slist_free(machines); return machine_class; } static MachineClass *find_default_machine(GSList *machines) { GSList *el; MachineClass *default_machineclass = NULL; for (el = machines; el; el = el-\u0026gt;next) { MachineClass *mc = el-\u0026gt;data; if (mc-\u0026gt;is_default) { assert(default_machineclass == NULL \u0026amp;\u0026amp; \u0026#34;Multiple default machines\u0026#34;); default_machineclass = mc; } } return default_machineclass; } static MachineClass *machine_parse(const char *name, GSList *machines) { MachineClass *mc; GSList *el; if (is_help_option(name)) { printf(\u0026#34;Supported machines are:\\n\u0026#34;); machines = g_slist_sort(machines, machine_class_cmp); for (el = machines; el; el = el-\u0026gt;next) { MachineClass *mc = el-\u0026gt;data; if (mc-\u0026gt;alias) { printf(\u0026#34;%-20s %s (alias of %s)\\n\u0026#34;, mc-\u0026gt;alias, mc-\u0026gt;desc, mc-\u0026gt;name); } printf(\u0026#34;%-20s %s%s%s\\n\u0026#34;, mc-\u0026gt;name, mc-\u0026gt;desc, mc-\u0026gt;is_default ? \u0026#34; (default)\u0026#34; : \u0026#34;\u0026#34;, mc-\u0026gt;deprecation_reason ? \u0026#34; (deprecated)\u0026#34; : \u0026#34;\u0026#34;); } exit(0); } mc = find_machine(name, machines); if (!mc) { error_report(\u0026#34;unsupported machine type\u0026#34;); error_printf(\u0026#34;Use -machine help to list supported machines\\n\u0026#34;); exit(1); } return mc; } object_class_get_list 定义如下：\nGSList *object_class_get_list(const char *implements_type,bool include_abstract) { GSList *list = NULL; object_class_foreach(object_class_get_list_tramp, implements_type, include_abstract, \u0026amp;list); return list; } void object_class_foreach(void (*fn)(ObjectClass *klass, void *opaque), const char *implements_type, bool include_abstract, void *opaque) { OCFData data = { fn, implements_type, include_abstract, opaque }; enumerating_types = true; g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, \u0026amp;data); enumerating_types = false; } 在全局表 type_table_get() 中，对于每一项 TypeImpl，我们都执行 object_class_foreach_tramp。\nstatic void object_class_foreach_tramp(gpointer key, gpointer value, gpointer opaque) { OCFData *data = opaque; TypeImpl *type = value; ObjectClass *k; type_initialize(type); k = type-\u0026gt;class; if (!data-\u0026gt;include_abstract \u0026amp;\u0026amp; type-\u0026gt;abstract) { return; } if (data-\u0026gt;implements_type \u0026amp;\u0026amp; !object_class_dynamic_cast(k, data-\u0026gt;implements_type)) { return; } data-\u0026gt;fn(k, data-\u0026gt;opaque); } 在 object_class_foreach_tramp 中，会调用将 type_initialize，这里面会调用 class_init 将纸面上的 class 也即 TypeImpl 变为 ObjectClass，ObjectClass 是所有Class 类的祖先，MachineClass 是它的子类。\n因为在 machine 的命令行里面，我们指定了名字为spike，就肯定能够找到我们注册过了的 TypeImpl，并调用它的 class_init 函数。\n所以，当 select_machine 执行完毕后，就有一个 MachineClass 了。\n接着，我们回到 qemu_create_machine 中的object_new_with_class。这就很好理解了，MachineClass 是一个 Class 类，接下来应该通过它生成一个 Instance，也即对象，这就是 object_new_with_class 的作用。\nobject_new_with_class 中，TypeImpl 的 instance_init 会被调用，创建一个对象。current_machine 就是这个对象，它的类型是MachineState。\nObject *object_new_with_class(ObjectClass *klass) { return object_new_with_type(klass-\u0026gt;type); } static Object *object_new_with_type(Type type) { Object *obj; type_initialize(type); obj = g_malloc(type-\u0026gt;instance_size); object_initialize_with_type(obj, type-\u0026gt;instance_size, type); obj-\u0026gt;free = g_free; return obj; } 至此，绕了这么大一圈，有关体系结构的对象才创建完毕，接下来很多的设备的初始化，包括 CPU 和内存的初始化，都是围绕着体系结构的对象来的，后面我们会常常看到current_machine。\n\u003c!DOCTYPE html\u003e Responsive Image 参考 Qemu CPU 虚拟化 - 人生一世，草木一秋。 - 博客园 【原创】Linux 虚拟化 KVM-Qemu 分析（四）之 CPU 虚拟化（2） - LoyenWang - 博客园\n","permalink":"https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9Fcpu%E5%88%9B%E5%BB%BA/","summary":"\u003ch2 id=\"流程图\"\u003e流程图\u003c/h2\u003e\n\u003cp\u003e先开个头吧，把创建流程稍微捋一下，找到创建虚拟 CPU 的模块。至于中间的流程还没有详细分析，万事开头难，先上手再说吧。\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210901182329.svg\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210901182329.svg\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"QEMU 源码分析-虚拟 CPU 创建"},{"content":"Qt 通过QIODevice提供了对 I/O 设备的抽象，这些设备具有读写字节块的能力。下面是 I/O 设备的类图：\n\u003c!DOCTYPE html\u003e Responsive Image 图中所涉及的类及其用途简要说明如下：\nQIODevice：所有I/O设备类的父类，提供了字节块读写的通用操作以及基本接口； QFlie：访问本地文件或者嵌入资源； QTemporaryFile：创建和访问本地文件系统的临时文件； QBuffer：读写QByteArray； QProcess：运行外部程序，处理进程间通讯； QAbstractSocket：所有套接字类的父类； QTcpSocket：TCP协议网络数据传输； QUdpSocket：传输 UDP 报文； QSslSocket：使用 SSL/TLS 传输数据； QFileDevice：Qt5 新增加的类，提供了有关文件操作的通用实现。\nQFile 及其相关类 我们通常会将文件路径作为参数传给QFile的构造函数。不过也可以在创建好对象最后，使用setFileName()来修改。QFile需要使用/作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如C:/windows这样的路径在 Windows 平台下同样是可以的。\nQFile主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。我们可以使用QDataStream或QTextStream类来读写文件，也可以使用QIODevice类提供的read()、readLine()、readAll()以及write()这样的函数。值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过QFileInfo获取，而不是自己分析文件路径字符串。\n在这段代码中，我们首先使用QFile创建了一个文件对象。这个文件名字是 test.txt。只要将这个文件放在同执行路径一致的目录下即可。可以使用QDir::currentPath()来获得应用程序执行时的当前路径。只要将这个文件放在与当前路径一致的目录下即可。然后，我们使用open()函数打开这个文件，打开形式是只读方式，文本格式。这个类似于fopen()的 r 这样的参数。open()函数返回一个 bool 类型，如果打开失败，我们在控制台输出一段提示然后程序退出。否则，我们利用 while 循环，将每一行读到的内容输出。\n#include \u0026lt;QWidget\u0026gt; #include \u0026lt;QApplication\u0026gt; #include \u0026lt;QDebug\u0026gt; #include \u0026lt;QFile\u0026gt; #include \u0026lt;QFileInfo\u0026gt; #include \u0026lt;QMainWindow\u0026gt; int main(int argc, char *argv[]) { QApplication app(argc, argv); QFile file(\u0026#34;test.txt\u0026#34;); if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) { qDebug() \u0026lt;\u0026lt; \u0026#34;Open file failed.\u0026#34;; return -1; } else { while (!file.atEnd()) { qDebug() \u0026lt;\u0026lt; file.readLine(); } } QFileInfo info(file); qDebug() \u0026lt;\u0026lt; info.isDir(); //false qDebug() \u0026lt;\u0026lt; info.isExecutable(); //false qDebug() \u0026lt;\u0026lt; info.baseName(); //test qDebug() \u0026lt;\u0026lt; info.completeBaseName(); //test.txt qDebug() \u0026lt;\u0026lt; info.suffix(); //txt qDebug() \u0026lt;\u0026lt; info.completeSuffix(); //txt QFileInfo fi(\u0026#34;/tmp/archive.tar.gz\u0026#34;); QString base = fi.baseName(); // base = \u0026#34;archive\u0026#34; QString cbase = fi.completeBaseName(); // base = \u0026#34;archive.tar\u0026#34; QString ext = fi.suffix(); // ext = \u0026#34;gz\u0026#34; QString ext = fi.completeSuffix(); // ext = \u0026#34;tar.gz\u0026#34; return app.exec(); } 二进制文件读写 本节，我们将学习QDataStream的使用以及一些技巧。\nQDataStream提供了基于QIODevice的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、CPU 或者字节顺序（大端或小端）。例如，在安装了 Windows 平台的 PC 上面写入的一个数据流，可以不经过任何处理，直接拿到运行了 Solaris 的 SPARC 机器上读取。由于数据流就是二进制流，因此我们也可以直接读写没有编码的二进制数据，例如图像、视频、音频等。\nQDataStream既能够存取 C++ 基本类型，如 int、char、short 等，也可以存取复杂的数据类型，例如自定义的类。实际上，QDataStream对于类的存储，是将复杂的类分割为很多基本单元实现的。\n结合QIODevice，QDataStream可以很方便地对文件、网络套接字等进行读写操作。\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::WriteOnly); QDataStream out(\u0026amp;file); out \u0026lt;\u0026lt; QString(\u0026#34;the answer is\u0026#34;); out \u0026lt;\u0026lt; (qint32)42; 在这段代码中，我们首先打开一个名为 file.dat 的文件（注意，我们为简单起见，并没有检查文件打开是否成功，这在正式程序中是不允许的）。然后，我们将刚刚创建的file对象的指针传递给一个QDataStream实例out。类似于std::cout标准输出流，QDataStream也重载了输出重定向\u0026laquo;运算符。后面的代码就很简单了：将“the answer is”和数字42输出到数据流（如果你不明白这句话的意思，这可是宇宙终极问题的答案，请自行搜索《银河系漫游指南》）。由于我们的 out 对象建立在file之上，因此相当于将宇宙终极问题的答案写入file。\n需要指出一点：最好使用Qt整型来进行读写，比如程序中的qint32。这保证了在任意平台和任意编译器都能够有相同的行为。\n我们通过一个例子来看看 Qt 是如何存储数据的。例如char *字符串，在存储时，会首先存储该字符串包括\\0结束符的长度（32位整型），然后是字符串的内容以及结束符\\0。在读取时，先以32位整型读出整个的长度，然后按照这个长度取出整个字符串的内容。\n但是，如果你直接运行这段代码，你会得到一个空白的 file.dat，并没有写入任何数据。这是因为我们的file没有正常关闭。为性能起见，数据只有在文件关闭时才会真正写入。因此，我们必须在最后添加一行代码：\nfile.close(); // 如果不想关闭文件，可以使用 file.flush(); 重新运行一下程序，你就得到宇宙终极问题的答案了。\n我们已经获得宇宙终极问题的答案了，下面，我们要将这个答案读取出来：\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::ReadOnly); QDataStream in(\u0026amp;file); QString str; qint32 a; in \u0026gt;\u0026gt; str \u0026gt;\u0026gt; a; 这段代码没什么好说的。唯一需要注意的是，你必须按照写入的顺序，将数据读取出来。也就是说，程序数据写入的顺序必须预先定义好。在这个例子中，我们首先写入字符串，然后写入数字，那么就首先读出来的就是字符串，然后才是数字。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。\n由于二进制流是纯粹的字节数据，带来的问题是，如果程序不同版本之间按照不同的方式读取（前面说过，Qt 保证读写内容的一致，但是并不能保证不同 Qt 版本之间的一致），数据就会出现错误。因此，我们必须提供一种机制来确保不同版本之间的一致性。通常，我们会使用如下的代码写入：\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::WriteOnly); QDataStream out(\u0026amp;file); // 写入魔术数字和版本 out \u0026lt;\u0026lt; (quint32)0xA0B0C0D0; out \u0026lt;\u0026lt; (qint32)123; out.setVersion(QDataStream::Qt_4_0); // 写入数据 out \u0026lt;\u0026lt; lots_of_interesting_data; 所谓魔术数字，是二进制输出中经常使用的一种技术。二进制格式是人不可读的，并且通常具有相同的后缀名（比如 dat 之类），因此我们没有办法区分两个二进制文件哪个是合法的。所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性。在本例中，我们在文件最开始写入 0xA0B0C0D0，在读取的时候首先检查这个数字是不是 0xA0B0C0D0。如果不是的话，说明这个文件不是可识别格式，因此根本不需要去继续读取。一般二进制文件都会有这么一个魔术数字，例如 Java 的 class 文件的魔术数字就是 0xCAFEBABE，使用二进制查看器就可以查看。魔术数字是一个 32 位的无符号整型，因此我们使用quint32来得到一个平台无关的 32 位无符号整型。\nout \u0026lt;\u0026lt; (qint32)123是标识文件的版本。我们用魔术数字标识文件的类型，从而判断文件是不是合法的。但是，文件的不同版本之间也可能存在差异：我们可能在第一版保存整型，第二版可能保存字符串。为了标识不同的版本，我们只能将版本写入文件。比如，现在我们的版本是 123。\nout.setVersion(QDataStream::Qt_4_0)上面一句是文件的版本号，但是，Qt不同版本之间的读取方式可能也不一样。这样，我们就得指定Qt 按照哪个版本去读。这里，我们指定以Qt 4.0 格式去读取内容。\n当我们这样写入文件之后，我们在读取的时候就需要增加一系列的判断：\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::ReadOnly); QDataStream in(\u0026amp;file); // 检查魔术数字 quint32 magic; in \u0026gt;\u0026gt; magic; if (magic != 0xA0B0C0D0) { return BAD_FILE_FORMAT; } // 检查版本 qint32 version; in \u0026gt;\u0026gt; version; if (version \u0026lt; 100) { return BAD_FILE_TOO_OLD; } if (version \u0026gt; 123) { return BAD_FILE_TOO_NEW; } if (version \u0026lt;= 110) { in.setVersion(QDataStream::Qt_3_2); } else { in.setVersion(QDataStream::Qt_4_0); } // 读取数据 in \u0026gt;\u0026gt; lots_of_interesting_data; if (version \u0026gt;= 120) { in \u0026gt;\u0026gt; data_new_in_version_1_2; } in \u0026gt;\u0026gt; other_interesting_data; 我们通过下面一段代码看看什么是流的形式：\nQFile file(\u0026#34;file.dat\u0026#34;); file.open(QIODevice::ReadWrite); QDataStream stream(\u0026amp;file); QString str = \u0026#34;the answer is 42\u0026#34;; QString strout; stream \u0026lt;\u0026lt; str; file.flush(); stream \u0026gt;\u0026gt; strout; 在这段代码中，我们首先向文件中写入数据，紧接着把数据读出来。有什么问题吗？运行之后你会发现，strout实际是空的。为什么没有读取出来？我们不是已经添加了file.flush();语句吗？原因并不在于文件有没有写入，而是在于我们使用的是“流”。所谓流，就像水流一样，它的游标会随着输出向后移动。当使用\u0026lt;\u0026lt;操作符输出之后，流的游标已经到了最后，此时你再去读，当然什么也读不到了。所以你需要在输出之后重新把游标设置为0的位置才能够继续读取。具体代码片段如下：\nstream \u0026lt;\u0026lt; str; stream.device()-\u0026gt;seek(0); stream \u0026gt;\u0026gt; strout; 文本文件读写 ","permalink":"https://lifeislife.cn/posts/qt%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","summary":"\u003cp\u003eQt 通过\u003ccode\u003eQIODevice\u003c/code\u003e提供了对 \u003ccode\u003eI/O\u003c/code\u003e 设备的抽象，这些设备具有读写字节块的能力。下面是 \u003ccode\u003eI/O\u003c/code\u003e 设备的类图：\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210831200940.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210831200940.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"Qt 文件系统"},{"content":"虚拟化 虚拟机 QEMU 工作原理 \u003c!DOCTYPE html\u003e Responsive Image 单纯使用 qemu，采用的是完全虚拟化的模式。qemu 向 Guest OS 模拟 CPU，也模拟其他的硬件，GuestOS 认为自己和硬件直接打交道，其实是同 qemu 模拟出来的硬件打交道，qemu 会将这些指令转译给真正的硬件。由于所有的指令都要从 qemu 里面过一手，因而性能就会比较差。\n完全虚拟化是非常慢的，所以要使用硬件辅助虚拟化技术 Intel-VT，AMD-V，所以需要 CPU 硬件开启这个标志位，一般在 BIOS 里面设置。当确认开始了标志位之后，通过 KVM，GuestOS 的 CPU 指令不用经过 Qemu 转译，直接运行，大大提高了速度。所以，KVM 在内核里面需要有一个模块，来设置当前 CPU 是 Guest OS 在用，还是 Host OS 在用。\n可以通过如下命令查看内核模块中是否有 KVM\nlsmod | grep kvm KVM 内核模块通过 /dev/kvm 暴露接口，用户态程序可以通过 ioctl来访问这个接口。Qemu 将 KVM 整合进来，将有关 CPU 指令的部分交由内核模块来做，就是 qemu-kvm (qemu-system-XXX)。\nqemu 和 kvm 整合之后，CPU 的性能问题解决了。另外 Qemu 还会模拟其他的硬件，如网络和硬盘。同样，全虚拟化的方式也会影响这些设备的性能。\n于是，qemu 采取半虚拟化的方式，让 Guest OS 加载特殊的驱动来做这件事情。\n例如，网络需要加载 virtio_net，存储需要加载 virtio_blk，Guest 需要安装这些半虚拟化驱动，GuestOS 知道自己是虚拟机，所以数据会直接发送给半虚拟化设备，经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。\n计算虚拟化之 CPU 计算虚拟化之内存 ","permalink":"https://lifeislife.cn/posts/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%8C%96/","summary":"\u003ch2 id=\"虚拟化\"\u003e虚拟化\u003c/h2\u003e\n\u003ch3 id=\"虚拟机\"\u003e虚拟机\u003c/h3\u003e\n\u003ch4 id=\"qemu-工作原理\"\u003eQEMU 工作原理\u003c/h4\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721140349.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721140349.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e单纯使用 qemu，采用的是完全虚拟化的模式。qemu 向 Guest OS 模拟 CPU，也模拟其他的硬件，GuestOS 认为自己和硬件直接打交道，其实是同 qemu 模拟出来的硬件打交道，qemu 会将这些指令转译给真正的硬件。由于所有的指令都要从 qemu 里面过一手，因而性能就会比较差。\u003c/p\u003e","title":"Linux 操作系统-虚拟化"},{"content":"进程 源码 //process.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern int create_process (char* program, char** arg_list); int create_process (char* program, char** arg_list) { pid_t child_pid; child_pid = fork (); if (child_pid != 0) { return child_pid; } else { execvp (program, arg_list); abort (); } } 在这里，我们创建的子程序运行了一个最最简单的命令 ls。\n//createprocess.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern int create_process (char* program, char** arg_list); int main () { char* arg_list[] = { \u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;, \u0026#34;/etc/yum.repos.d/\u0026#34;, NULL }; create_process (\u0026#34;ls\u0026#34;, arg_list); return 0; } 编译 CPU 看不懂源码里的函数，命令，CPU 只认二进制数据，所以源码需要翻译成01二进制数据，这个过程就是**编译（Compile）**的过程。\n编译出的文件好比一个公司的项目执行计划书，你要把一个项目执行好，计划书得有章法，有一定格式。在 Linux 下，二进制程序也有这样的格式，叫ELF（Executeable and Linkable Format，可执行与可链接格式），这个格式可以根据编译的结果不同，分为不同的格式。\nELF-可重定位文件 下图展示了如何从源码到二进制文件的转化\n\u003c!DOCTYPE html\u003e Responsive Image gcc -c -fPIC process.c gcc -c -fPIC createprocess.c -fPIC作用于编译阶段，告诉编译器产生与位置无关代码 (Position-Independent Code)。产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。\n在编译的时候，先做预处理工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为.o文件，这就是ELF的第一种类型，可重定位文件（Relocatable File）。文件格式如下，\n\u003c!DOCTYPE html\u003e Responsive Image ELF 文件的头是用于描述整个文件的。这个文件格式在内核中有定义，分别为 struct elf32_hdr 和 struct elf64_hdr。\nsection 内容 .text 放编译好的二进制可执行代码 .data 已经初始化好的全局变量（临时变量放在栈里） .rodata 只读数据，例如字符串常量、const 的变量 .bss 未初始化全局变量，运行时会置 0 .symtab 符号表，记录的则是函数和变量 .strtab 字符串表、字符串常量和变量名 第一种 ELF 文件叫可重定位文件，为啥可重定位？我们可以想象一下，这个编译好的代码和变量，将来加载到内存里面的时候，都是要加载到一定位置的。比如说，调用一个函数，其实就是跳到这个函数所在的代码位置执行；再比如修改一个全局变量，也是要到变量的位置那里去修改。但是现在这个时候，还是.o文件，不是一个可以直接运行的程序，这里面只是部分代码片段。\n例如这里的 create_process函数，将来被谁调用，在哪里调用都不清楚，就更别提确定位置了。所以，.o里面的位置是不确定的，但是必须是可重新定位的，因为它将来是要做函数库的嘛，就是一块砖，哪里需要哪里搬，搬到哪里就重新定位这些代码、变量的位置。\nELF-可执行文件 要让create_process这个函数作为库文件重用，需要将其形成库文件，最简单的类型是静态链接库.a文件，它将一系列.o文件归档为一个文件。使用ar命令创建.a文件。使用方法看这里。\nar cr libstaticprocess.a process.o 虽然这里 libstaticprocess.a 里面只有一个.o，但是实际情况可以有多个.o。当有程序要使用这个静态连接库的时候，会将.o 文件提取出来，链接到程序中。\ngcc -o staticcreateprocess createprocess.o -L. -lstaticprocess -L表示在当前目录下找.a文件，-lstaticprocess 会自动补全文件名，比如加前缀 lib，后缀.a，变成 libstaticprocess.a，找到这个.a文件后，将里面的 process.o 取出来，和 createprocess.o 做一个链接，形成二进制执行文件 staticcreateprocess。\n在链接过程中，重定位就起作用了，在createprocess.o里调用了create_process函数，但是不能确定位置，现在将process.o合并进来，就知道位置了。\n\u003c!DOCTYPE html\u003e Responsive Image 这个格式和.o 文件大致相似，还是分成一个个的 section，并且被节头表描述。只不过这些section 是多个.o 文件合并过的。但是这个时候，这个文件已经是马上就可以加载到内存里面执行的文件了，因而这些 section 被分成了需要加载到内存里面的代码段、数据段和不需要加载到内存里面的部分，将小的 section 合成了大的段 segment，并且在最前面加一个段头表（Segment Header Table）。\n在代码里面的定义为 struct elf32_phdr和 struct elf64_phdr，这里面除了有对于段的描述之外，最重要的是 p_vaddr，这个是这个段加载到内存的虚拟地址。\n在 ELF 头里面，有一项 e_entry，也是个虚拟地址，是这个程序运行的入口。\nELF-共享对象文件 静态库一旦被链接，代码和变量的section会被合并，所以运行时不依赖静态库文件，但是缺点就是，相同代码段被多个程序使用，在内存里会有多份，而且静态库更新需要重新编译。\n因而就出现了另一种，动态链接库（Shared Libraries），不仅仅是一组对象文件的简单归档，而是多个对象文件的重新组合，可被多个程序共享。\ngcc -shared -fPIC -o libdynamicprocess.so process.o 当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。\ngcc -o dynamiccreateprocess createprocess.o -L. -ldynamicprocess 当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在 /lib 和/usr/lib 文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定 LD_LIBRARY_PATH环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。\n# export LD_LIBRARY_PATH=. # ./dynamiccreateprocess # total 40 -rw-r--r--. 1 root root 1572 Oct 24 18:38 CentOS-Base.repo ...... 动态链接库，就是ELF的第三种类型，共享对象文件（Shared Object）。\n文件格式和上两种文件稍有不同，首先，多了一个.interp的 Segment，这里面是 ld-linux.so，这是动态链接器，也就是说，运行时的链接动作都是它做的。\n另外，ELF文件中还多了两个section，一个是.plt，过程链接表（Procedure Linkage Table，PLT），一个是。got.plt，全局偏移量表（Global Offset Table，GOT）。\n运行 在内核中，有linux_binfmt elf_format数据结构定义了加载 ELF 的方法，使用load_elf_binary加载二进制文件，该函数由do_execve调用，学过系统调用知道exec调用了do_execve函数。所以流程为\nexec-\u0026gt;do_execve-\u0026gt;load_elf_binary 进程树 所有进程都是从父进程 fork 来的，祖宗进程就是init 进程。\n系统启动之后，init 进程会启动很多的daemon 进程，为系统运行提供服务，然后就是启动 getty，让用户登录，登录后运行 shell，用户启动的进程都是通过 shell运行的，从而形成了一棵进程树。\n我们可以通过 ps -ef命令查看当前系统启动的进程，我们会发现有三类进程。PID 1 的进程就是我们的init进程 systemd，PID 2 的进程是内核线程 kthreadd。\n内核态进程的PPID祖先进程都是 2 号进程，用户态进程祖先进程都是 1 号进程，tty列是问号的，说明是后台服务进程。\n\u003c!DOCTYPE html\u003e Responsive Image 进程数据结构 在 Linux 里面，无论是进程还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构task_struct进行管理。\n\u003c!DOCTYPE html\u003e Responsive Image 每个任务应该包含的字段：\n任务 ID pid_t pid; #process id pid_t tgid; #thread group ID struct task_struct *group_leader; 为何要有这么多 ID，一个不够吗？\n可以方便任务展示，比如在命令行中 ps 显示所有进程，只显示pid_t pid，而不会把所有内部线程摊开展示，这样太碍眼。 方便下达命令，当我 kill 一个进程时，我们是对整个进程发送信号，但是有时候一些命令只需要对某个线程发送信号。 信号处理 /* Signal handlers: */ struct signal_struct *signal; struct sighand_struct *sighand; sigset_t blocked; sigset_t real_blocked; sigset_t saved_sigmask; struct sigpending pending; unsigned long sas_ss_sp; size_t sas_ss_size; unsigned int sas_ss_flags; 这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。\n任务状态 volatile long state; /* -1 unrunnable, 0 runnable, \u0026gt;0 stopped */ int exit_state; unsigned int flags; state可取值定义如下\n/* Used in tsk-\u0026gt;state: */ #define TASK_RUNNING 0 #define TASK_INTERRUPTIBLE 1 #define TASK_UNINTERRUPTIBLE 2 #define __TASK_STOPPED 4 #define __TASK_TRACED 8 /* Used in tsk-\u0026gt;exit_state: */ #define EXIT_DEAD 16 #define EXIT_ZOMBIE 32 #define EXIT_TRACE (EXIT_ZOMBIE | EXIT_DEAD) /* Used in tsk-\u0026gt;state again: */ #define TASK_DEAD 64 #define TASK_WAKEKILL 128 #define TASK_WAKING 256 #define TASK_PARKED 512 #define TASK_NOLOAD 1024 #define TASK_NEW 2048 #define TASK_STATE_MAX 4096 可以发现 Linux 通过 bitset 方式设置状态，当前什么状态，哪一位就置 1。\n进程调度 进程的状态切换往往涉及调度，下面这些字段都是用于调度的。\n// 是否在运行队列上 int on_rq; // 优先级 int prio; int static_prio; int normal_prio; unsigned int rt_priority; // 调度器类 const struct sched_class *sched_class; // 调度实体 struct sched_entity se; struct sched_rt_entity rt; struct sched_dl_entity dl; // 调度策略 unsigned int policy; // 可以使用哪些 CPU int nr_cpus_allowed; cpumask_t cpus_allowed; struct sched_info sched_info; 运行统计信息 u64 utime;// 用户态消耗的 CPU 时间 u64 stime;// 内核态消耗的 CPU 时间 unsigned long nvcsw;// 自愿 (voluntary) 上下文切换计数 unsigned long nivcsw;// 非自愿 (involuntary) 上下文切换计数 u64 start_time;// 进程启动时间，不包含睡眠时间 u64 real_start_time;// 进程启动时间，包含睡眠时间 进程亲缘关系 进程有棵进程树，所以有亲缘关系。\nstruct task_struct __rcu *real_parent; /* real parent process */ struct task_struct __rcu *parent; /* recipient of SIGCHLD, wait4() reports */ struct list_head children; /* list of my children */ struct list_head sibling; /* linkage in my parent\u0026#39;s children list */ 通常情况下，real_parent 和 parent 是一样的，但是也会有另外的情况存在。例如，bash 创建一个进程，那进程的 parent 和 real_parent 就都是 bash。如果在 bash 上使用 GDB 来 debug 一个进程，这个时候 GDB 是 real_parent，bash 是这个进程的 parent。\n进程权限 /* Objective and real subjective task credentials (COW): */ const struct cred __rcu *real_cred; /* Effective (overridable) subjective task credentials (COW): */ const struct cred __rcu real_cred 就是说明谁能操作我这个进程，而 cred 就是说明我这个进程能够操作谁。\n总结到一起，task_struct结构图如下，\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","summary":"\u003ch2 id=\"进程\"\u003e进程\u003c/h2\u003e\n\u003ch3 id=\"源码\"\u003e源码\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//process.c\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;sys/types.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eextern\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ecreate_process\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eprogram\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e \u003cspan class=\"n\"\u003earg_list\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ecreate_process\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eprogram\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e \u003cspan class=\"n\"\u003earg_list\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003epid_t\u003c/span\u003e \u003cspan class=\"n\"\u003echild_pid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003echild_pid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efork\u003c/span\u003e \u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echild_pid\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003echild_pid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eexecvp\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eprogram\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003earg_list\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eabort\u003c/span\u003e \u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在这里，我们创建的子程序运行了一个最最简单的命令 \u003ccode\u003els\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//createprocess.c\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;sys/types.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eextern\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ecreate_process\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eprogram\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e \u003cspan class=\"n\"\u003earg_list\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e \u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003earg_list\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"s\"\u003e\u0026#34;ls\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"s\"\u003e\u0026#34;-l\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"s\"\u003e\u0026#34;/etc/yum.repos.d/\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ecreate_process\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;ls\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003earg_list\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"编译\"\u003e编译\u003c/h3\u003e\n\u003cp\u003eCPU 看不懂源码里的函数，命令，CPU 只认二进制数据，所以源码需要翻译成\u003ccode\u003e01\u003c/code\u003e二进制数据，这个过程就是**编译（Compile）**的过程。\u003c/p\u003e","title":"Linux 操作系统-进程管理"},{"content":"Tips 缩写注释 CSAPP：Computer Systems A Programmer’s Perspective（深入理解计算机操作系统）。CSAPP（C：P166，O：P278）表示书本的中文版第 166 页，英文原版第 278 页。\n寄存器信息 了解寄存器的基本用途，看到一个汇编代码，可以大概了解这个寄存器是在栈中使用的，还是保存参数的，是调用者保存，还是被调用者保存。 \u003c!DOCTYPE html\u003e Responsive Image GDB 调试过程用到的 GDB 命令可以先参考GDB 调试入门这篇文章。文中所用例子也是摘自与 BombLab 的源码，更容易理解如何使用。还有一定比较重要的是，如何使用 gdb 带参数调试。为了不用每次运行bomb程序都需要重新输入答案，bomb程序可以读取文本信息，在文本文件中写入答案即可免去手动输入。\nphase_1 拆弹专家已上线，开干！！！！！！！！！！！！！\n(gdb) b phase_1 (gdb) b explode_bomb (gdb) disas phase_1 Dump of assembler code for function phase_1:\u0026#39; 0x0000000000400ee0 \u0026lt;+0\u0026gt;: sub $0x8,%rsp 0x0000000000400ee4 \u0026lt;+4\u0026gt;: mov $0x402400,%esi 0x0000000000400ee9 \u0026lt;+9\u0026gt;: callq 0x401338 \u0026lt;strings_not_equal\u0026gt; 0x0000000000400eee \u0026lt;+14\u0026gt;: test %eax,%eax 0x0000000000400ef0 \u0026lt;+16\u0026gt;: je 0x400ef7 \u0026lt;phase_1+23\u0026gt; 0x0000000000400ef2 \u0026lt;+18\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400ef7 \u0026lt;+23\u0026gt;: add $0x8,%rsp 0x0000000000400efb \u0026lt;+27\u0026gt;: retq End of assembler dump. 3：将栈指针rsp减去 8 个字节，也就是申请 8 个字节的栈空间 4：将一个立即数存到寄存器esi中 5：调用函数strings_not_equal，该函数第一条语句的地址为0x401338。callq指令的执行过程可参考书本 CSAPP（C：P166，O：P278） 6：使用test命令（同and命令，不修改目标对象的值）来测试eax中的值是否为0，如果为0则跳过引爆炸弹的函数 7：这一句和上一句是一个整体，如果eax==0,就跳转到0x400ef7，这个地址也就是第 9 行的地址，成功跳过了引爆炸弹函数。意思就是我们输入的某个字符串成功匹配，也就是strings_not_equal函数返回值为 0。 8：调用函数explode_bomb，引爆炸弹 9：将栈指针rsp加上 8 个字节，也就是恢复 8 个字节的栈空间 (gdb) disas strings_not_equal Dump of assembler code for function strings_not_equal: =\u0026gt; 0x0000000000401338 \u0026lt;+0\u0026gt;: push %r12 0x000000000040133a \u0026lt;+2\u0026gt;: push %rbp 0x000000000040133b \u0026lt;+3\u0026gt;: push %rbx 0x000000000040133c \u0026lt;+4\u0026gt;: mov %rdi,%rbx 0x000000000040133f \u0026lt;+7\u0026gt;: mov %rsi,%rbp 0x0000000000401342 \u0026lt;+10\u0026gt;: callq 0x40131b \u0026lt;string_length\u0026gt; 0x0000000000401347 \u0026lt;+15\u0026gt;: mov %eax,%r12d 0x000000000040134a \u0026lt;+18\u0026gt;: mov %rbp,%rdi 0x000000000040134d \u0026lt;+21\u0026gt;: callq 0x40131b \u0026lt;string_length\u0026gt; 0x0000000000401352 \u0026lt;+26\u0026gt;: mov $0x1,%edx 0x0000000000401357 \u0026lt;+31\u0026gt;: cmp %eax,%r12d 0x000000000040135a \u0026lt;+34\u0026gt;: jne 0x40139b \u0026lt;strings_not_equal+99\u0026gt; 0x000000000040135c \u0026lt;+36\u0026gt;: movzbl (%rbx),%eax 0x000000000040135f \u0026lt;+39\u0026gt;: test %al,%al 0x0000000000401361 \u0026lt;+41\u0026gt;: je 0x401388 \u0026lt;strings_not_equal+80\u0026gt; 0x0000000000401363 \u0026lt;+43\u0026gt;: cmp 0x0(%rbp),%al 0x0000000000401366 \u0026lt;+46\u0026gt;: je 0x401372 \u0026lt;strings_not_equal+58\u0026gt; 0x0000000000401368 \u0026lt;+48\u0026gt;: jmp 0x40138f \u0026lt;strings_not_equal+87\u0026gt; 0x000000000040136a \u0026lt;+50\u0026gt;: cmp 0x0(%rbp),%al 0x000000000040136d \u0026lt;+53\u0026gt;: nopl (%rax) 0x0000000000401370 \u0026lt;+56\u0026gt;: jne 0x401396 \u0026lt;strings_not_equal+94\u0026gt; 0x0000000000401372 \u0026lt;+58\u0026gt;: add $0x1,%rbx 0x0000000000401376 \u0026lt;+62\u0026gt;: add $0x1,%rbp 0x000000000040137a \u0026lt;+66\u0026gt;: movzbl (%rbx),%eax 0x000000000040137d \u0026lt;+69\u0026gt;: test %al,%al 0x000000000040137f \u0026lt;+71\u0026gt;: jne 0x40136a \u0026lt;strings_not_equal+50\u0026gt; 0x0000000000401381 \u0026lt;+73\u0026gt;: mov $0x0,%edx 0x0000000000401386 \u0026lt;+78\u0026gt;: jmp 0x40139b \u0026lt;strings_not_equal+99\u0026gt; 0x0000000000401388 \u0026lt;+80\u0026gt;: mov $0x0,%edx 0x000000000040138d \u0026lt;+85\u0026gt;: jmp 0x40139b \u0026lt;strings_not_equal+99\u0026gt; 0x000000000040138f \u0026lt;+87\u0026gt;: mov $0x1,%edx 0x0000000000401394 \u0026lt;+92\u0026gt;: jmp 0x40139b \u0026lt;strings_not_equal+99\u0026gt; 0x0000000000401396 \u0026lt;+94\u0026gt;: mov $0x1,%edx 0x000000000040139b \u0026lt;+99\u0026gt;: mov %edx,%eax 0x000000000040139d \u0026lt;+101\u0026gt;: pop %rbx 0x000000000040139e \u0026lt;+102\u0026gt;: pop %rbp 0x000000000040139f \u0026lt;+103\u0026gt;: pop %r12 0x00000000004013a1 \u0026lt;+105\u0026gt;: retq End of assembler dump. 3-5：在函数调用时先保存相关寄存器值，rbp和rbx就是用来保存两个参数的寄存器 6：将寄存器rdi的值复制到寄存器rbp 7：将寄存器rsi的值复制到寄存器rbx 其实看到这里就一直能够猜到答案是什么了。我们通过之前的phase_1函数能够大概知道需要输入一个值进行比较，如果比较正确就能解除炸弹。现在我们又进入到了这个比较函数，比较函数有两个参数，分别保存在两个寄存器里。我们正常的思维如果写一个比较函数，肯定一个参数是我们输入的值，一个参数是正确的值。\n这里看到了rsi寄存器，我们还记得在phase_1函数中第 4 行的esi寄存器吗？这两个寄存器是同一个寄存器，只不过esi是寄存器的低 32 位，既然esi已经赋值了，那剩下的一个参数保存我们输入的内容。所以esi内存的内容就是我们需要的正确答案。我们只要把寄存器esi中的值打印出来，或者内存地址为0x402400的内容打印出来即可。可以通过以下三条命令查看。\n(gdb) p (char*)($esi) $5 = 0x402400 \u0026#34;Border relations with Canada have never been better.\u0026#34; (gdb) x/s 0x402400 0x402400: \u0026#34;Border relations with Canada have never been better.\u0026#34; (gdb) x/s $esi 0x402400: \u0026#34;Border relations with Canada have never been better.\u0026#34; 将答案复制，然后继续运行\nThe program being debugged has been started already. Start it from the beginning? (y or n) y Starting program: /home/dominic/learning-linux/bomb/bomb Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! Border relations with Canada have never been better. Breakpoint 2, 0x0000000000400ee0 in phase_1 () (gdb) s Single stepping until exit from function phase_1, which has no line number information. main (argc=\u0026lt;optimized out\u0026gt;, argv=\u0026lt;optimized out\u0026gt;) at bomb.c:75 75 phase_defused(); /* Drat! They figured it out! (gdb) s 77 printf(\u0026#34;Phase 1 defused. How about the next one?\\n\u0026#34;); 从 13 行phase_defused()可以知道我们已经解除了炸弹，从 15 行printf函数也可以看到，需要进行下一个炸弹的拆除。过来人的建议，在这里就开始分析phase_2，寻找答案，因为继续执行就要开始输入内容了，将无法调试。\nphase_2 继续分析第二个炸弹，\n(gdb) disas phase_2 Dump of assembler code for function phase_2: 0x0000000000400efc \u0026lt;+0\u0026gt;: push %rbp 0x0000000000400efd \u0026lt;+1\u0026gt;: push %rbx 0x0000000000400efe \u0026lt;+2\u0026gt;: sub $0x28,%rsp 0x0000000000400f02 \u0026lt;+6\u0026gt;: mov %rsp,%rsi 0x0000000000400f05 \u0026lt;+9\u0026gt;: callq 0x40145c \u0026lt;read_six_numbers\u0026gt; 0x0000000000400f0a \u0026lt;+14\u0026gt;: cmpl $0x1,(%rsp) 0x0000000000400f0e \u0026lt;+18\u0026gt;: je 0x400f30 \u0026lt;phase_2+52\u0026gt; 0x0000000000400f10 \u0026lt;+20\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400f15 \u0026lt;+25\u0026gt;: jmp 0x400f30 \u0026lt;phase_2+52\u0026gt; 0x0000000000400f17 \u0026lt;+27\u0026gt;: mov -0x4(%rbx),%eax 0x0000000000400f1a \u0026lt;+30\u0026gt;: add %eax,%eax 0x0000000000400f1c \u0026lt;+32\u0026gt;: cmp %eax,(%rbx) 0x0000000000400f1e \u0026lt;+34\u0026gt;: je 0x400f25 \u0026lt;phase_2+41\u0026gt; 0x0000000000400f20 \u0026lt;+36\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400f25 \u0026lt;+41\u0026gt;: add $0x4,%rbx 0x0000000000400f29 \u0026lt;+45\u0026gt;: cmp %rbp,%rbx 0x0000000000400f2c \u0026lt;+48\u0026gt;: jne 0x400f17 \u0026lt;phase_2+27\u0026gt; 0x0000000000400f2e \u0026lt;+50\u0026gt;: jmp 0x400f3c \u0026lt;phase_2+64\u0026gt; 0x0000000000400f30 \u0026lt;+52\u0026gt;: lea 0x4(%rsp),%rbx 0x0000000000400f35 \u0026lt;+57\u0026gt;: lea 0x18(%rsp),%rbp 0x0000000000400f3a \u0026lt;+62\u0026gt;: jmp 0x400f17 \u0026lt;phase_2+27\u0026gt; 0x0000000000400f3c \u0026lt;+64\u0026gt;: add $0x28,%rsp 0x0000000000400f40 \u0026lt;+68\u0026gt;: pop %rbx 0x0000000000400f41 \u0026lt;+69\u0026gt;: pop %rbp 0x0000000000400f42 \u0026lt;+70\u0026gt;: retq End of assembler dump. 3-6：保存程序入口地址，变量等内容，就不再赘述了 7: 调用read_six_numbers函数，根据函数名我们可以猜测这个函数需要读入六个数字 8-9：比较寄存器rsp存的第一个数字是否等于0x1，如果等于就跳转到phase_2+52处继续执行，如果不等于就执行explode_bomb。栈中保存了六个输入的数字，保存顺序是从右往左，假如输入1,2,3,4,5,6。那么入栈的顺序就是6,5,4,3,2,1，寄存器rsp指向栈顶，也就是数字1的地址。 21:假设第一个数字正确，我们跳转到\u0026lt;+52\u0026gt;位置，也就是第 21 行，将rsp+0x4写入寄存器rbx，栈指针向上移动四个字节，也就是取第二个输入的参数，将它赋给寄存器rbx 22：将rsp+0x18写入寄存器rbp，十六进制0x18=24，4 个字节一个数，刚好 6 个数，就是将输入参数的最后一个位置赋给寄存器rbp 23：跳到phase_2+27继续执行 12：rbx-0x4赋给寄存器eax。第 21 行我们知道，rbx此时已经到第二个参数了，这一句就是说把第一个参数的值写入寄存器eax 13：将eax翻一倍，第 8 行知道第一个参数值为1，所以此时eax值为2 14-15：比较eax是否等于rbx。rbx此时保存的是第二个参数，这里也就是比较第二个参数是否等于2。如果等于跳转到phase_2+41位置，如果不等于就调用爆炸函数 17-18：假设第二个参数就是 2，我们跳过了炸弹来到第 17 行，将rbx继续上移，然后比较rbp是否等于rbx，我们知道rbp保存了最后一个参数的地址，所以这里的意思就是看看参数有没有到最后一个参数。 19：如果rbx\u0026lt;rbp，意思就是还没到最后一个参数，就跳转到phase_2+27 12：再次回到第 12 行，这里就是相当于一个循环了，让rbx一直向上移动，分别存入第 2，3，4，5，6 个参数，在移动到下一个参数时先保存当前参数到寄存器eax让其翻一倍，然后rbx再移动到下一个参数，比较eax==rbx。直到rbx越过了rbp。程序跳转到phase_2+64，将栈空间恢复。 以上分析也可以得出答案了，我们只要输入一个以1为初值，公比为2，个数为6的等比数列就是答案，也就是1 2 4 8 16 32。\n(gdb) c Continuing. Phase 1 defused. How about the next one? 1 2 4 8 16 32 Breakpoint 6, 0x00000000004015c4 in phase_defused () (gdb) s Single stepping until exit from function phase_defused, which has no line number information. main (argc=\u0026lt;optimized out\u0026gt;, argv=\u0026lt;optimized out\u0026gt;) at bomb.c:84 84 printf(\u0026#34;That\u0026#39;s number 2. Keep going!\\n\u0026#34;); (gdb) s 这个炸弹的作者应该再心狠手辣一点，把函数名换成read_some_numbers，这样我们就不得不看这个函数的内容了，因为这个函数里还有一个坑，这个坑在函数名字上一句被填了。那就是这个函数会对参数个数做判断，如果小于 5 就爆炸。\n(gdb) disas read_six_numbers Dump of assembler code for function read_six_numbers: 0x000000000040145c \u0026lt;+0\u0026gt;: sub $0x18,%rsp 0x0000000000401460 \u0026lt;+4\u0026gt;: mov %rsi,%rdx 0x0000000000401463 \u0026lt;+7\u0026gt;: lea 0x4(%rsi),%rcx 0x0000000000401467 \u0026lt;+11\u0026gt;: lea 0x14(%rsi),%rax 0x000000000040146b \u0026lt;+15\u0026gt;: mov %rax,0x8(%rsp) 0x0000000000401470 \u0026lt;+20\u0026gt;: lea 0x10(%rsi),%rax 0x0000000000401474 \u0026lt;+24\u0026gt;: mov %rax,(%rsp) 0x0000000000401478 \u0026lt;+28\u0026gt;: lea 0xc(%rsi),%r9 0x000000000040147c \u0026lt;+32\u0026gt;: lea 0x8(%rsi),%r8 0x0000000000401480 \u0026lt;+36\u0026gt;: mov $0x4025c3,%esi 0x0000000000401485 \u0026lt;+41\u0026gt;: mov $0x0,%eax 0x000000000040148a \u0026lt;+46\u0026gt;: callq 0x400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 0x000000000040148f \u0026lt;+51\u0026gt;: cmp $0x5,%eax 0x0000000000401492 \u0026lt;+54\u0026gt;: jg 0x401499 \u0026lt;read_six_numbers+61\u0026gt; 0x0000000000401494 \u0026lt;+56\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000401499 \u0026lt;+61\u0026gt;: add $0x18,%rsp 0x000000000040149d \u0026lt;+65\u0026gt;: retq End of assembler dump. 3：申请 24 个字节栈空间 4：rdx=rsi，将输入参数的第一个参数放到寄存器rdx中，为啥是第一个参数，因为rsi现在保存的地址是栈顶位置，栈顶目前保存就是第一个参数。 5：rcx = rsi + 4，把第二个参数的地址传给寄存器rcx 6：rax = rsi + 20，把第六个参数的地址传给寄存器rax 7：rsp + 8 = rax第八个参数 8：rax = rsi + 16，把第五个参数传给 9：rsp = rax第七个参数 10：r9 = rsi + 12把第四个参数传给寄存器r9 11：r8 = rsi + 8把第三个参数传给寄存器r8 12： 13：eax = 0 14：调用输入函数sscanf 15-17：函数返回值个数与 5 比较，如果小于 5 就爆炸，否则返回 phase_3 0x0000000000400f43 \u0026lt;+0\u0026gt;: sub $0x18,%rsp 0x0000000000400f47 \u0026lt;+4\u0026gt;: lea 0xc(%rsp),%rcx 0x0000000000400f4c \u0026lt;+9\u0026gt;: lea 0x8(%rsp),%rdx 0x0000000000400f51 \u0026lt;+14\u0026gt;: mov $0x4025cf,%esi 0x0000000000400f56 \u0026lt;+19\u0026gt;: mov $0x0,%eax 0x0000000000400f5b \u0026lt;+24\u0026gt;: callq 0x400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 0x0000000000400f60 \u0026lt;+29\u0026gt;: cmp $0x1,%eax 0x0000000000400f63 \u0026lt;+32\u0026gt;: jg 0x400f6a \u0026lt;phase_3+39\u0026gt; 0x0000000000400f65 \u0026lt;+34\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400f6a \u0026lt;+39\u0026gt;: cmpl $0x7,0x8(%rsp) 0x0000000000400f6f \u0026lt;+44\u0026gt;: ja 0x400fad \u0026lt;phase_3+106\u0026gt; 0x0000000000400f71 \u0026lt;+46\u0026gt;: mov 0x8(%rsp),%eax 0x0000000000400f75 \u0026lt;+50\u0026gt;: jmpq *0x402470(,%rax,8) 0x0000000000400f7c \u0026lt;+57\u0026gt;: mov $0xcf,%eax 0x0000000000400f81 \u0026lt;+62\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400f83 \u0026lt;+64\u0026gt;: mov $0x2c3,%eax 0x0000000000400f88 \u0026lt;+69\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400f8a \u0026lt;+71\u0026gt;: mov $0x100,%eax 0x0000000000400f8f \u0026lt;+76\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400f91 \u0026lt;+78\u0026gt;: mov $0x185,%eax 0x0000000000400f96 \u0026lt;+83\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400f98 \u0026lt;+85\u0026gt;: mov $0xce,%eax 0x0000000000400f9d \u0026lt;+90\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400f9f \u0026lt;+92\u0026gt;: mov $0x2aa,%eax 0x0000000000400fa4 \u0026lt;+97\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400fa6 \u0026lt;+99\u0026gt;: mov $0x147,%eax 0x0000000000400fab \u0026lt;+104\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400fad \u0026lt;+106\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400fb2 \u0026lt;+111\u0026gt;: mov $0x0,%eax 0x0000000000400fb7 \u0026lt;+116\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400fb9 \u0026lt;+118\u0026gt;: mov $0x137,%eax 0x0000000000400fbe \u0026lt;+123\u0026gt;: cmp 0xc(%rsp),%eax 0x0000000000400fc2 \u0026lt;+127\u0026gt;: je 0x400fc9 \u0026lt;phase_3+134\u0026gt; 0x0000000000400fc4 \u0026lt;+129\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400fc9 \u0026lt;+134\u0026gt;: add $0x18,%rsp 0x0000000000400fcd \u0026lt;+138\u0026gt;: retq 1：开辟 24 字节的栈空间 2：rcx = rsp + 12第二个参数 3：rdx = rsp + 8第一个参数 4-8：和phase_2里read_six_numbers函数中的第 13 行开始一样，输入数据，判断一下输入参数的个数，只不过这里是返回值个数大于 1，如果参数个数正确就跳到phase_3+39也就是第 10 行，否则引爆炸弹。 10-11：如果7 \u0026lt; rsp + 8 等价于 7 \u0026lt; rdx 等价于 7 \u0026lt; 第一个参数就跳转到phase_3+106，爆炸。这里确定第一个数必须小于 7 12：eax = rsp + 8 等价于 eax = 第一个参数 13：跳转至0x402470 + 8 * rax处，具体跳转到哪里根据第一个值做判断 14：eax = 207 15：跳转至phase_3+123,即 32 行 16：eax = 707 17：跳转到 32 行 18：eax = 256 19：跳转到 32 行 20：eax = 389 21-27：以此类推 29：eax = 0 30： 31：eax = 311 32-34：比较eax和rsp + 12 等价于 比较 第二个参数和eax。如果相等就返回，如果不等就引爆。 分析至此，我们也就知道了程序的大概流程，输入两个值，第一个值必须小于等于 7，第二个值根据第一个值来确定，具体等于多少，根据跳转表确定，因为第一个值有八个数，也就对应着汇编中八段寄存器eax赋值的过程，我们只要输入第一个合法的数值，然后再打印出寄存器eax的值，即可确定答案。\n比如我们先测试一下第一个值为 0 时，对应的第二个值为多少，我们输入0 10，因为只是测试，第二个值任意。\nThat\u0026#39;s number 2. Keep going! //接上个炸弹后面 88 input = read_line(); (gdb) n 0 10 //输入测试答案 89 phase_3(input); (gdb) n Breakpoint 4, 0x0000000000400f43 in phase_3 () (gdb) n Single stepping until exit from function phase_3, which has no line number information. Breakpoint 2, 0x000000000040143a in explode_bomb () (gdb) p $eax $14 = 207 //207即是答案 输入真正答案测试，\n(gdb) n 0 207 //输入答案 89 phase_3(input); (gdb) n Breakpoint 4, 0x0000000000400f43 in phase_3 () (gdb) n Single stepping until exit from function phase_3, which has no line number information. main (argc=\u0026lt;optimized out\u0026gt;, argv=\u0026lt;optimized out\u0026gt;) at bomb.c:90 90 phase_defused(); //炸弹拆除 (gdb) 91 printf(\u0026#34;Halfway there!\\n\u0026#34;); 我们上面说过，第一个值有八种可能，所以这题答案也有八个，我们只要挨个测试0-7，分别打印出寄存器eax的值就可以得到所有答案。他们分别是\n0 207 1 311 2 707 3 256 4 389 5 206 6 682 7 327 phase_4 行百里者半九十，NO\n(gdb) disas phase_4 Dump of assembler code for function phase_4: 0x000000000040100c \u0026lt;+0\u0026gt;: sub $0x18,%rsp 0x0000000000401010 \u0026lt;+4\u0026gt;: lea 0xc(%rsp),%rcx 0x0000000000401015 \u0026lt;+9\u0026gt;: lea 0x8(%rsp),%rdx 0x000000000040101a \u0026lt;+14\u0026gt;: mov $0x4025cf,%esi 0x000000000040101f \u0026lt;+19\u0026gt;: mov $0x0,%eax 0x0000000000401024 \u0026lt;+24\u0026gt;: callq 0x400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 0x0000000000401029 \u0026lt;+29\u0026gt;: cmp $0x2,%eax 0x000000000040102c \u0026lt;+32\u0026gt;: jne 0x401035 \u0026lt;phase_4+41\u0026gt; 0x000000000040102e \u0026lt;+34\u0026gt;: cmpl $0xe,0x8(%rsp) 0x0000000000401033 \u0026lt;+39\u0026gt;: jbe 0x40103a \u0026lt;phase_4+46\u0026gt; 0x0000000000401035 \u0026lt;+41\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x000000000040103a \u0026lt;+46\u0026gt;: mov $0xe,%edx 0x000000000040103f \u0026lt;+51\u0026gt;: mov $0x0,%esi 0x0000000000401044 \u0026lt;+56\u0026gt;: mov 0x8(%rsp),%edi 0x0000000000401048 \u0026lt;+60\u0026gt;: callq 0x400fce \u0026lt;func4\u0026gt; 0x000000000040104d \u0026lt;+65\u0026gt;: test %eax,%eax 0x000000000040104f \u0026lt;+67\u0026gt;: jne 0x401058 \u0026lt;phase_4+76\u0026gt; 0x0000000000401051 \u0026lt;+69\u0026gt;: cmpl $0x0,0xc(%rsp) 0x0000000000401056 \u0026lt;+74\u0026gt;: je 0x40105d \u0026lt;phase_4+81\u0026gt; 0x0000000000401058 \u0026lt;+76\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x000000000040105d \u0026lt;+81\u0026gt;: add $0x18,%rsp 0x0000000000401061 \u0026lt;+85\u0026gt;: retq 1-8：开辟空间，保存参数信息，调用输入函数，和上面的分析重复，不再赘述。注意的是第 6 行，x/s 0x4025cf可知两个参数是整型数值。 9-10：参数个数必须等于 2，否则引爆 11-12：14与rsp + 8比较，等价于14与第一个参数比较。表示第一个参数必须小于等于 14，否则引爆。 14：edx = 14 15：esi = 0 16：edi = rsp + 8即edi = 第一个参数 17：调用函数fun4，参数分别为edi 0 14 18：测试返回值是否为 0，如果不为 0，引爆 20-22：比较0和rsp + 12，如果不等，引爆，否则返回 (gdb) disas func4 Dump of assembler code for function func4: 0x0000000000400fce \u0026lt;+0\u0026gt;: sub $0x8,%rsp 0x0000000000400fd2 \u0026lt;+4\u0026gt;: mov %edx,%eax 0x0000000000400fd4 \u0026lt;+6\u0026gt;: sub %esi,%eax 0x0000000000400fd6 \u0026lt;+8\u0026gt;: mov %eax,%ecx 0x0000000000400fd8 \u0026lt;+10\u0026gt;: shr $0x1f,%ecx 0x0000000000400fdb \u0026lt;+13\u0026gt;: add %ecx,%eax 0x0000000000400fdd \u0026lt;+15\u0026gt;: sar %eax 0x0000000000400fdf \u0026lt;+17\u0026gt;: lea (%rax,%rsi,1),%ecx 0x0000000000400fe2 \u0026lt;+20\u0026gt;: cmp %edi,%ecx 0x0000000000400fe4 \u0026lt;+22\u0026gt;: jle 0x400ff2 \u0026lt;func4+36\u0026gt; 0x0000000000400fe6 \u0026lt;+24\u0026gt;: lea -0x1(%rcx),%edx 0x0000000000400fe9 \u0026lt;+27\u0026gt;: callq 0x400fce \u0026lt;func4\u0026gt; 0x0000000000400fee \u0026lt;+32\u0026gt;: add %eax,%eax 0x0000000000400ff0 \u0026lt;+34\u0026gt;: jmp 0x401007 \u0026lt;func4+57\u0026gt; 0x0000000000400ff2 \u0026lt;+36\u0026gt;: mov $0x0,%eax 0x0000000000400ff7 \u0026lt;+41\u0026gt;: cmp %edi,%ecx 0x0000000000400ff9 \u0026lt;+43\u0026gt;: jge 0x401007 \u0026lt;func4+57\u0026gt; 0x0000000000400ffb \u0026lt;+45\u0026gt;: lea 0x1(%rcx),%esi 0x0000000000400ffe \u0026lt;+48\u0026gt;: callq 0x400fce \u0026lt;func4\u0026gt; 0x0000000000401003 \u0026lt;+53\u0026gt;: lea 0x1(%rax,%rax,1),%eax 0x0000000000401007 \u0026lt;+57\u0026gt;: add $0x8,%rsp 0x000000000040100b \u0026lt;+61\u0026gt;: retq func (edi, esi, edx) { // edi = 第一个参数, esi = 0, edx = 14 eax = edx // 4:mov %edx, %eax eax = eax -esi // 5:sub esi, %eax eax = edx -esi ecx = eax // 6:mov %eax, %ecx ecx = edx - esi eсx = ecx \u0026gt;\u0026gt; 31 // 7:shr $0x1f, %ecx ecx = (edx - esi) \u0026gt;\u0026gt; 31 eax = eax + ecx // 8:add %ecx, %eax eax = (edx - esi) + ((edx - esi) \u0026gt;\u0026gt; 31)//替换eax和ecx eax = eax \u0026gt; 1; // 9:sar %eax eax = ((edx - esi) +((edx -esi) \u0026gt;\u0026gt; 31)) / 2 ecx = eax + esi * 1 // 10:lea (rax,ersi,1), %ecx ecx = ((edx - esi) +((edx -esi) \u0026gt;\u0026gt; 31)) / 2 + esi * 1 ecx = ((14 - 0) + ((14 - 0) \u0026gt;\u0026gt; 31)) / 2 + 0 ecx = 7 // 11:cmp %edi, %ecx if (ecx \u0026lt;= edi) { // 12:jle 400ff2 eax = 0 // mov $0x0,%eax // 18:cmp %edi, %ecx if(ecx \u0026gt;= edi) { // 19:jge 0x401007 \u0026lt;func4+57\u0026gt; return; //由此可以得知道 edx == edi } } } phase_5 0x0000000000401062 \u0026lt;+0\u0026gt;: push %rbx 0x0000000000401063 \u0026lt;+1\u0026gt;: sub $0x20,%rsp 0x0000000000401067 \u0026lt;+5\u0026gt;: mov %rdi,%rbx 0x000000000040106a \u0026lt;+8\u0026gt;: mov %fs:0x28,%rax 0x0000000000401073 \u0026lt;+17\u0026gt;: mov %rax,0x18(%rsp) 0x0000000000401078 \u0026lt;+22\u0026gt;: xor %eax,%eax 0x000000000040107a \u0026lt;+24\u0026gt;: callq 0x40131b \u0026lt;string_length\u0026gt; 0x000000000040107f \u0026lt;+29\u0026gt;: cmp $0x6,%eax 0x0000000000401082 \u0026lt;+32\u0026gt;: je 0x4010d2 \u0026lt;phase_5+112\u0026gt; 0x0000000000401084 \u0026lt;+34\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000401089 \u0026lt;+39\u0026gt;: jmp 0x4010d2 \u0026lt;phase_5+112\u0026gt; 0x000000000040108b \u0026lt;+41\u0026gt;: movzbl (%rbx,%rax,1),%ecx 0x000000000040108f \u0026lt;+45\u0026gt;: mov %cl,(%rsp) 0x0000000000401092 \u0026lt;+48\u0026gt;: mov (%rsp),%rdx 0x0000000000401096 \u0026lt;+52\u0026gt;: and $0xf,%edx 0x0000000000401099 \u0026lt;+55\u0026gt;: movzbl 0x4024b0(%rdx),%edx 0x00000000004010a0 \u0026lt;+62\u0026gt;: mov %dl,0x10(%rsp,%rax,1) 0x00000000004010a4 \u0026lt;+66\u0026gt;: add $0x1,%rax 0x00000000004010a8 \u0026lt;+70\u0026gt;: cmp $0x6,%rax 0x00000000004010ac \u0026lt;+74\u0026gt;: jne 0x40108b \u0026lt;phase_5+41\u0026gt; 0x00000000004010ae \u0026lt;+76\u0026gt;: movb $0x0,0x16(%rsp) 0x00000000004010b3 \u0026lt;+81\u0026gt;: mov $0x40245e,%esi 0x00000000004010b8 \u0026lt;+86\u0026gt;: lea 0x10(%rsp),%rdi 0x00000000004010bd \u0026lt;+91\u0026gt;: callq 0x401338 \u0026lt;strings_not_equal\u0026gt; 0x00000000004010c2 \u0026lt;+96\u0026gt;: test %eax,%eax 0x00000000004010c4 \u0026lt;+98\u0026gt;: je 0x4010d9 \u0026lt;phase_5+119\u0026gt; 0x00000000004010c6 \u0026lt;+100\u0026gt;: callq 0x40143a \u0026lt;explode_bomb\u0026gt; 0x00000000004010cb \u0026lt;+105\u0026gt;: nopl 0x0(%rax,%rax,1) 0x00000000004010d0 \u0026lt;+110\u0026gt;: jmp 0x4010d9 \u0026lt;phase_5+119\u0026gt; 0x00000000004010d2 \u0026lt;+112\u0026gt;: mov $0x0,%eax 0x00000000004010d7 \u0026lt;+117\u0026gt;: jmp 0x40108b \u0026lt;phase_5+41\u0026gt; 0x00000000004010d9 \u0026lt;+119\u0026gt;: mov 0x18(%rsp),%rax 0x00000000004010de \u0026lt;+124\u0026gt;: xor %fs:0x28,%rax 0x00000000004010e7 \u0026lt;+133\u0026gt;: je 0x4010ee \u0026lt;phase_5+140\u0026gt; 0x00000000004010e9 \u0026lt;+135\u0026gt;: callq 0x400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x00000000004010ee \u0026lt;+140\u0026gt;: add $0x20,%rsp 0x00000000004010f2 \u0026lt;+144\u0026gt;: pop %rbx 0x00000000004010f3 \u0026lt;+145\u0026gt;: retq ","permalink":"https://lifeislife.cn/posts/csapp-lab-bomb-lab/","summary":"\u003ch2 id=\"tips\"\u003eTips\u003c/h2\u003e\n\u003ch3 id=\"缩写注释\"\u003e缩写注释\u003c/h3\u003e\n\u003cp\u003eCSAPP：Computer Systems A Programmer’s Perspective（深入理解计算机操作系统）。CSAPP（C：P166，O：P278）表示书本的中文版第 166 页，英文原版第 278 页。\u003c/p\u003e","title":"CSAPPLAB-Bomb Lab"},{"content":"file 加载程序 (gdb) file bomb Reading symbols from bomb... set args 带参数调试 有时候程序不是直接可以运行的，需要加上一些必要的参数。带上参数运行很容易，只要在程序名后加上相应参数即可，但是如何带上参数进行调试呢？这就需要set args命令。\n比如在BombLab实验中，我们不可能一次解决所有phase，但是每次重新调试，已经解决的phase还要重新输入一次答案，这就很麻烦，好在这个实验的作者也考虑到了，他支持读取文本。我们可以把答案预先写入一个文本文件中，程序读取已经保存的答案即可跳过相应的phase。\n假设我们把答案写入了solutions.txt文件中，首先，我们加载程序，然后通过set args solutions.txt设置运行参数。\n(gdb) file bomb Reading symbols from bomb... (gdb) set args solutions.txt (gdb) r Starting program: /home/dominic/learning-linux/bomb/bomb solutions.txt Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! Phase 1 defused. How about the next one? That\u0026#39;s number 2. Keep going! list 查看源码 查看 10 行源码 每条命令显示 10 行代码\n(gdb) l 23 #include \u0026lt;stdio.h\u0026gt; 24 #include \u0026lt;stdlib.h\u0026gt; 25 #include \u0026#34;support.h\u0026#34; 26 #include \u0026#34;phases.h\u0026#34; 27 28 /* 29 * Note to self: Remember to erase this file so my victims will have no 30 * idea what is going on, and so they will all blow up in a 31 * spectaculary fiendish explosion. -- Dr. Evil 32 */ (gdb) l 33 34 FILE *infile; 35 36 int main(int argc, char *argv[]) 37 { 38 char *input; 39 40 /* Note to self: remember to port this bomb to Windows and put a 41 * fantastic GUI on it. */ 42 set list num 设置默认显示代码行数 (gdb) set list 20 //默认显示20行代码 list linenumber 查看指定行代码 (gdb) l 10 (gdb) l main.h : 10 //指定main.c文件中的第十行 list function 查看指定函数的代码 break 打断点 break linenum 对指定行打断点 (gdb) b 36 Note: breakpoint 1 also set at pc 0x400da0. Breakpoint 2 at 0x400da0: file bomb.c, line 37. break function 对指定函数打断点 (gdb) b main Breakpoint 3 at 0x400da0: file bomb.c, line 37. (gdb) b phase_1 Breakpoint 4 at 0x400ee0 删除断点包括禁用断点 delete 删除所有断点 (gdb) delete Delete all breakpoints? (y or n) y disable breakpoint 禁用断点 (gdb) info b #先看有哪些断点 Num Type Disp Enb Address What 3 breakpoint keep y 0x0000000000400da0 in main at bomb.c:37 4 breakpoint keep y 0x0000000000400ee0 \u0026lt;phase_1\u0026gt; (gdb) d 3 #禁用第三号断点 (gdb) info b #再次查看断点信息发现已经没有第三号断点 Num Type Disp Enb Address What 4 breakpoint keep y 0x0000000000400ee0 \u0026lt;phase_1\u0026gt; clear function 删除一个函数中所有的断点 (gdb) info b Num Type Disp Enb Address What 4 breakpoint keep y 0x0000000000400ee0 \u0026lt;phase_1\u0026gt; (gdb) clear phase_1 (gdb) info b Deleted breakpoint 4 No breakpoints or watchpoints. 启动与退出 run 启动程序直到遇到断点 (gdb) run start 启动程序并在第一条代码处停下 (gdb) start x 配置 gdb 常用命令 gdb -q -x gdbinit //gdbinit display/z $xs display/z $x6 display/z $x7 set disassemble-next-line on b _start target remote: 34 有了配置文件，就不用每次启动 gdb 时都要重新输入一遍调试命令。\nquit 退出调试 (gdb) quit 调试命令 print 打印变量值 格式化字符 (/fmt) 说明 /x 以十六进制的形式打印出整数。 /d 以有符号、十进制的形式打印出整数。 /u 以无符号、十进制的形式打印出整数。 /o 以八进制的形式打印出整数。 /t 以二进制的形式打印出整数。 /f 以浮点数的形式打印变量或表达式的值。 /c 以字符形式打印变量或表达式的值。 (gdb) p i # 10进制 $5 = 3 (gdb) p/x i # 16进制 $6 = 0x3 (gdb) p/o i # 8进制 $7 = 03 打印地址值 表示从内存地址 0x54320 读取内容，h 表示以双字节为单位，3 表示输出 3 个单位，u 表示按照十六进制显示。\n(gdb) x/3uh 0x54320 查看当前程序栈的内容：x/10x $sp–\u0026gt;打印 stack 的前 10 个元素 查看当前程序栈的信息：info frame\u0026mdash;-list general info about the frame 查看当前程序栈的参数：info args—lists arguments to the function 查看当前程序栈的局部变量：info locals—list variables stored in the frame 查看当前寄存器的值：info registers(不包括浮点寄存器)\nptype 打印变量类型 (gdb) ptype i type = int (gdb) ptype array[i] type = int (gdb) ptype array type = int [12] display 跟踪显示变量 print命令可以打印出变量的值，但是只是一次性的。如果我们想要跟踪某个变量的变化，可以使用display命令，每当程序在断点处停下，都会打印出跟踪的变量值。\n(gdb) display info display查看已跟踪的变量，delete display取消跟踪显示变量。\nstep 执行一行代码 执行一行代码，如果改行代码是函数，将进入函数内部。\n(gdb) s finish 跳出函数 如果通过s单步调试进入到函数内部，想要跳出这个函数体，可以执行 finish命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。\nnext 执行一行代码 next 命令和 step 命令功能是相似的，只是在使用 next 调试程序的时候不会进入到函数体内部，next 可以缩写为 n。\nuntil 跳出循环体 通过 until 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要保证，要跳出的循环体内部不能有有效的断点，必须要在循环体的开始 / 结束行执行该命令。\nlayout 分割窗口，边调试边看源码 layout src \u003c!DOCTYPE html\u003e Responsive Image layout asm \u003c!DOCTYPE html\u003e Responsive Image layout split \u003c!DOCTYPE html\u003e Responsive Image 远程调试 -s -S -s启动gdb server，默认端口号为 1234 -S让程序在_start处停下。\n","permalink":"https://lifeislife.cn/posts/gdb%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/","summary":"\u003ch2 id=\"file-加载程序\"\u003efile 加载程序\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003egdb\u003cspan class=\"o\"\u003e)\u003c/span\u003e file bomb\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eReading symbols from bomb...\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"set-args-带参数调试\"\u003eset args 带参数调试\u003c/h2\u003e\n\u003cp\u003e有时候程序不是直接可以运行的，需要加上一些必要的参数。带上参数运行很容易，只要在程序名后加上相应参数即可，但是如何带上参数进行调试呢？这就需要\u003ccode\u003eset args\u003c/code\u003e命令。\u003c/p\u003e","title":"GDB 调试入门"},{"content":"效果 主题：evan\n\u003c!DOCTYPE html\u003e Responsive Image 主题：dallas\n\u003c!DOCTYPE html\u003e Responsive Image 主题：robbyrussell\n\u003c!DOCTYPE html\u003e Responsive Image 如果原先其他电脑安装过 把.oh-my-zsh整个文件夹，.zshrc，.zsh_history复制到/home/user/目录；\n安装zsh\nsudo apt install zsh 切换shell\nchsh -s /bin/zsh source ~/.zshrc 即可使用。所有配置都会和原先一样。\n如果是新安装 官方方法，curl和wget二选一即可\ncurl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh 应该也有人和我一样，可能会遇到连接 GitHub 失败的问题，要不就是 SSL 验证失败，要不就是连接无响应。可以更换下面的方法。\n# 先下载 git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh ## 再替换 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 重启终端即可成功。\n如果无法访问 GitHub，其实oh-my-zsh并不需要安装，完整的工程就是oh-my-zsh本体，只要想办法把整个工程下载下来，并重命名为oh-my-zsh即可。所以找找 gitee 有没有相关工程。这也是为什么从旧电脑里直接复制.oh-my-zsh就能用的原因。\n插件安装 自动补全命令 git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions plugins=( zsh-autosuggestions ) 彩色ls \u003c!DOCTYPE html\u003e Responsive Image sudo apt install lsd 如果没有软件包，说明系统版本老旧，可以直接前往https://github.com/lsd-rs/lsd/releases下载二进制包安装：\nsudo dpkg -i lsd-musl_1.1.5_amd64.deb 添加别名：\nalias ls=\u0026#39;lsd\u0026#39; alias l=\u0026#34;ls -l\u0026#34; alias ll=\u0026#39;ls -al\u0026#39; alias la=\u0026#39;ls -a\u0026#39; alias lt=\u0026#39;ls --tree\u0026#39; 命令行命令高亮 git clone https://github.com/zdharma-continuum/fast-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/fast-syntax-highlighting plugins=( fast-syntax-highlighting ) 别名提示纠正 如果命令有缩写别名，提示下次使用建议的别名。\ngit clone https://github.com/MichaelAquilina/zsh-you-should-use.git ~/.oh-my-zsh/custom/plugins/you-should-use plugins=( git extract sudo z thefuck zsh-autosuggestions you-should-use fast-syntax-highlighting ) 问题 oh-my-zsh.sh parse error near `\u0026laquo;\u0026lt;' 一般是在更新oh-my-zsh时出现，因为更新相当于就是从远程拉取了内容，可能本地的oh-my-zsh.sh脚本自己做了修改与远程冲突了。只要退回上个版本，重新拉取就可以了。\ncd $ZSH git reset --hard HEAD^ git pull --rebase 如果本地修改了一些内容需要保留，可以打开oh-my-zsh.sh看看冲突在哪，自己做个备份，保存一下。\n","permalink":"https://lifeislife.cn/posts/oh-my-zsh%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%BB%88%E7%AB%AF%E6%9B%B4%E5%8A%A0%E9%A1%BA%E6%89%8B%E7%9C%BC/","summary":"\u003ch2 id=\"效果\"\u003e效果\u003c/h2\u003e\n\u003cp\u003e主题：evan\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/12-36-00-26c3a41581cb4dc000d8c78d6ca8a8ce-20220911123600-4f3a26.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/12-36-00-26c3a41581cb4dc000d8c78d6ca8a8ce-20220911123600-4f3a26.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e主题：dallas\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/12-36-51-167fdec4a32cab8991e86880c5f8ca19-20220911123650-efd6fd.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/12-36-51-167fdec4a32cab8991e86880c5f8ca19-20220911123650-efd6fd.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"oh-my-zsh 让你的终端更加顺手（眼）"},{"content":"本篇文章所涉及代码可在此处查看。\n绘制系统简介 Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于QPainter,QPainterDevice和QPaintEngine三个类。\nQPainter用来执行绘制的操作；QPaintDevice是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；QPaintEngine提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。\n三个类的关系：QPainter-\u0026gt;QPaintEngine-\u0026gt;QPaintDevice。通过这个关系我们也可以知道，QPainter通过QPaintEngine翻译指令在QPaintDevice上绘制。\n通过一个实例来了解一下绘制系统的，\n//main.h #include \u0026lt;QPainter\u0026gt; #include \u0026lt;QWidget\u0026gt; #include \u0026lt;QPaintEvent\u0026gt; #include \u0026lt;QApplication\u0026gt; #include \u0026lt;QMainWindow\u0026gt; class PaintedWidget : public QWidget { Q_OBJECT public: PaintedWidget(QWidget *parent = 0); protected: void paintEvent(QPaintEvent *); }; //main.cpp #include \u0026#34;paintwidget.h\u0026#34; PaintedWidget::PaintedWidget(QWidget *parent) : QWidget(parent) { resize(800, 600); setWindowTitle(tr(\u0026#34;Paint Demo\u0026#34;)); } void PaintedWidget::paintEvent(QPaintEvent *) { QPainter painter(this); painter.drawLine(20, 20, 700, 20); painter.setPen(Qt::red); painter.drawRect(10, 10, 100, 400); painter.setPen(QPen(Qt::green, 5)); painter.setBrush(Qt::blue); painter.drawEllipse(0, 0, 300, 40); // painter.drawRect(120, 50, 50, 400); } int main(int argc, char *argv[]) { QApplication app(argc, argv); PaintedWidget paintMap; paintMap.show(); return app.exec(); } \u003c!DOCTYPE html\u003e Responsive Image 在构造函数中，我们仅仅设置了窗口的大小和标题。而paintEvent()函数则是绘制的代码。\n首先，我们在栈上创建了一个QPainter对象，也就是说，每次运行paintEvent()函数的时候，都会重建这个QPainter对象。注意，这一点可能会引发某些细节问题：由于我们每次重建QPainter，因此第一次运行时所设置的画笔颜色、状态等，第二次再进入这个函数时就会全部丢失。有时候我们希望保存画笔状态，就必须自己保存数据，否则的话则需要将QPainter作为类的成员变量。\npaintEvent()作为重绘函数，会在需要重绘时由 Qt 自动调用。“需要重绘”可能发生在很多地方，比如组件刚刚创建出来的时候就需要重绘；组件最大化、最小化的时候也需要重新绘制；组件由遮挡变成完全显示的时候也需要等等。\nQPainter接收一个QPaintDevice指针作为参数。QPaintDevice有很多子类，比如QImage，以及QWidget。注意回忆一下，QPaintDevice可以理解成要在哪里去绘制，而现在我们希望画在这个组件，因此传入的是 this 指针。\n我们还需要注意绘制的顺序，直线-矩形 - 椭圆，所以直线位于最下方，以此类推。\n如果了解 OpenGL，肯定听说过这么一句话：OpenGL 是一个状态机。所谓状态机，就是说，OpenGL 保存的只是各种状态。比如，将画笔颜色设置成红色，那么，除非你重新设置另外的颜色，它的颜色会一直是红色。QPainter也是这样，它的状态不会自己恢复，除非你使用了各种设置函数。因此，如果在上面的代码中，我们在椭圆绘制之后再画一个矩形，它的样式还会是绿色5像素的轮廓线以及蓝色的填充，除非你显式地调用了设置函数进行状态的更新。\n\u003c!DOCTYPE html\u003e Responsive Image 这是大多数绘图系统的实现方式，包括 OpenGL、QPainter以及 Java2D。正因为QPainter是一个状态机，才会引出我们前面曾经介绍过的一个细节问题：由于paintEvent()是需要重复进入的，因此，需要注意第二次进入时，QPainter的状态是不是和第一次一致，否则的话可能会造成闪烁的现象。这个闪烁并不是由于双缓冲的问题，而是由于绘制状态的快速切换。\n画刷和画笔 画刷和画笔。前者使用QBrush描述，大多用于填充；后者使用QPen描述，大多用于绘制轮廓线。\n//main.cpp void PaintedWidget::paintEvent(QPaintEvent *) { QPainter painter(this); painter.drawLine(20, 20, 700, 20); painter.setPen(Qt::red); painter.drawRect(10, 10, 100, 400); painter.setPen(QPen(Qt::green, 5)); painter.setBrush(Qt::blue); painter.drawEllipse(0, 0, 300, 40); painter.drawRect(120, 50, 50, 400); ///////////////////画笔与笔刷 QLinearGradient gradient(QPointF(180, 50), QPointF(230, 400)); gradient.setColorAt(0, Qt::black); gradient.setColorAt(1, Qt::red); gradient.setSpread(QGradient::PadSpread); QBrush brush(gradient); QPen pen(Qt::green, 3, Qt::DashDotLine, Qt::RoundCap, Qt::RoundJoin); // painter.setPen(pen); painter.setBrush(brush); painter.drawRect(180, 50, 50, 400); } \u003c!DOCTYPE html\u003e Responsive Image 画刷的style()定义了填充的样式，使用Qt::BrushStyle枚举，默认值是Qt::NoBrush，也就是不进行任何填充。我们可以从下面的图示中看到各种填充样式的区别：\n\u003c!DOCTYPE html\u003e Responsive Image 画刷的gradient()定义了渐变填充。这个属性只有在样式是Qt::LinearGradientPattern、Qt::RadialGradientPattern或者Qt::ConicalGradientPattern之一时才有效。渐变可以由QGradient对象表示。Qt 提供了三种渐变：QLinearGradient、QConicalGradient和QRadialGradient，它们都是QGradient的子类。\n本文以QLinearGradient为例，两个坐标分别为起点与重点坐标。setColorAt设置渐变颜色，0表示开始，1表示结束。意思就是从黑色渐变到红色。setSpread设置显示方式为平铺。\nQLinearGradient gradient(QPointF(180, 50), QPointF(230, 400)); gradient.setColorAt(0, Qt::black); gradient.setColorAt(1, Qt::red); gradient.setSpread(QGradient::PadSpread); 默认的画笔属性是纯黑色，0 像素，方形笔帽（Qt::SquareCap），斜面型连接（Qt::BevelJoin）。\n画笔样式有一下几种， \u003c!DOCTYPE html\u003e Responsive Image 你也可以使用setDashPattern()函数自定义样式，例如如下代码片段：\nQVector\u0026lt;qreal\u0026gt; dashes; qreal space = 4; dashes \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; space \u0026lt;\u0026lt; 3 \u0026lt;\u0026lt; space \u0026lt;\u0026lt; 9 \u0026lt;\u0026lt; space \u0026lt;\u0026lt; 27 \u0026lt;\u0026lt; space \u0026lt;\u0026lt; 9 \u0026lt;\u0026lt; space; pen.setColor(Qt::black); pen.setDashPattern(dashes); painter.setPen(pen); painter.drawLine(30, 300, 600, 30); \u003c!DOCTYPE html\u003e Responsive Image pen.setCapStyle(Qt::RoundCap)笔帽定义了画笔末端的样式，例如：\n\u003c!DOCTYPE html\u003e Responsive Image pen.setJoinStyle(Qt::RoundJoin)连接样式定义了两条线连接时的样式，例如：\n\u003c!DOCTYPE html\u003e Responsive Image 反走样 我们在光栅图形显示器上绘制非水平、非垂直的直线或多边形边界时，或多或少会呈现锯齿状外观。这是因为直线和多边形的边界是连续的，而光栅则是由离散的点组成。在光栅显示设备上表现直线、多边形等，必须在离散位置采样。由于采样不充分重建后造成的信息失真，就叫走样；用于减少或消除这种效果的技术，就称为反走样。也就是常说的防锯齿现象。因为性能方面的考虑，Qt 默认关闭反走样。\nvoid paintEvent(QPaintEvent *) { ///////////////////对比反走样效果 QPainter painter(this); painter.setPen(QPen(Qt::black, 5, Qt::DashDotLine, Qt::RoundCap)); painter.setBrush(Qt::yellow); painter.drawEllipse(550, 150, 200, 150); painter.setRenderHint(QPainter::Antialiasing, true); painter.setPen(QPen(Qt::black, 5, Qt::DashDotLine, Qt::RoundCap)); painter.setBrush(Qt::yellow); painter.drawEllipse(300, 150, 200, 150); } \u003c!DOCTYPE html\u003e Responsive Image 我们可以明显观察到右边的椭圆轮廓是有锯齿现象的，这两个椭圆除了位置位置不同，唯一的区别就是右边的开启了反锯齿。\npainter.setRenderHint(QPainter::Antialiasing, true); 虽然反走样比不反走样的图像质量高很多，但是，没有反走样的图形绘制还是有很大用处的。首先，就像前面说的一样，在一些对图像质量要求不高的环境下，或者说性能受限的环境下，比如嵌入式和手机环境，一般是不进行反走样的。另外，在一些必须精确操作像素的应用中，也是不能进行反走样的。\n坐标系统 在 Qt 的坐标系统中，每个像素占据 1x1 的空间。你可以把它想象成一张方格纸，每个小格都是 1 个像素。方格的焦点定义了坐标，也就是说，像素 (x, y) 的中心位置其实是在(x + 0.5, y + 0.5)的位置上。这个坐标系统实际上是一个“半像素坐标系”。我们可以通过下面的示意图来理解这种坐标系：\n\u003c!DOCTYPE html\u003e Responsive Image 我们使用一个像素的画笔进行绘制，可以看到，每一个绘制像素都是以坐标点为中心的矩形。注意，这是坐标的逻辑表示，实际绘制则与此不同。因为在实际设备上，像素是最小单位，我们不能像上面一样，在两个像素之间进行绘制。所以在实际绘制时，Qt 的定义是，绘制点所在像素是逻辑定义点的右下方的像素。\n接下来，我们探究 Qt 绘制图像的坐标情况， 对于画笔大小为一个像素的情况比较容易理解，当我们绘制矩形左上角 (1, 2) 时，实际绘制的像素是在右下方。\n\u003c!DOCTYPE html\u003e Responsive Image 当画笔大小超过 1 个像素时，就略显复杂了。如果绘制像素是偶数，则实际绘制会包裹住逻辑坐标值；如果是奇数，则是包裹住逻辑坐标值，再加上右下角一个像素的偏移。具体请看下面的图示：\n\u003c!DOCTYPE html\u003e Responsive Image 从上图可以看出，如果实际绘制是偶数像素，则会将逻辑坐标值夹在相等的两部分像素之间；如果是奇数，则会在右下方多出一个像素。\nQt 的这种处理，带来的一个问题是，我们可能获取不到真实的坐标值。由于历史原因，QRect::right()和QRect::bottom()的返回值并不是矩形右下角点的真实坐标值：QRect::right()返回的是left() + width() - 1；QRect::bottom()则返回 top() + height() - 1，上图的绿色点指出了这两个函数的返回点的坐标。\n为避免这个问题，我们建议是使用QRectF。QRectF使用浮点值，而不是整数值，来描述坐标。这个类的两个函数QRectF::right()和QRectF::bottom()是正确的。如果你不得不使用QRect，那么可以利用 x() + width() 和 y() + height()来替代 right()和bottom()函数。\n对于反走样，实际绘制会包裹住逻辑坐标值：\n\u003c!DOCTYPE html\u003e Responsive Image 前面说过，QPainter是一个状态机。那么，有时我想保存下当前的状态：当我临时绘制某些图像时，就可能想这么做。当然，我们有最原始的办法：将可能改变的状态，比如画笔颜色、粗细等，在临时绘制结束之后再全部恢复。对此，QPainter提供了内置的函数：save()和restore()。save()就是保存下当前状态；restore()则恢复上一次保存的结果。这两个函数必须成对出现：QPainter使用栈来保存数据，每一次save()，将当前状态压入栈顶，restore()则弹出栈顶进行恢复。\n在了解了这两个函数之后，我们就可以进行示例代码了：\n//绘制一个网格背景 void CoordinateWidget::paintGrid() { size_t win_width = this-\u0026gt;geometry().width(); size_t win_height = this-\u0026gt;geometry().height(); QPainter painter(this); for (size_t x = 0; x \u0026lt; win_width; x += 25) { painter.drawLine(QPoint(x, 1), QPoint(x, win_height)); } for (size_t y = 0; y \u0026lt; win_height; y += 25) { painter.drawLine(QPoint(1, y), QPoint(win_width, y)); } } void CoordinateWidget::paintEvent(QPaintEvent *) { paintGrid(); QPainter painter(this); painter.fillRect(10, 10, 50, 100, Qt::red); painter.save(); painter.translate(100, 0); // 向右平移 100px painter.fillRect(10, 10, 50, 100, Qt::yellow); painter.restore(); painter.save(); painter.translate(300, 0); // 向右平移 300px painter.rotate(30); // 顺时针旋转 30 度 painter.fillRect(10, 10, 50, 100, Qt::green); painter.restore(); painter.save(); painter.translate(400, 0); // 向右平移 400px painter.scale(2, 3); // 横坐标单位放大 2 倍，纵坐标放大 3 倍 painter.fillRect(10, 10, 50, 100, Qt::blue); painter.restore(); painter.save(); painter.translate(600, 0); // 向右平移 600px painter.shear(0, 1); // 横向不变，纵向扭曲 1 倍 painter.fillRect(10, 10, 50, 100, Qt::cyan); painter.restore(); } Qt 提供了四种坐标变换：平移 translate，旋转 rotate，缩放 scale 和扭曲 shear。在这段代码中，我们首先在 (10, 10) 点绘制一个红色的 50x100 矩形。保存当前状态，将坐标系平移到 (100, 0)，绘制一个黄色的矩形。注意，translate()操作平移的是坐标系，不是矩形。因此，我们还是在(10, 10) 点绘制一个 50x100 矩形，现在，它跑到了右侧的位置。然后恢复先前状态，也就是把坐标系重新设为默认坐标系（相当于进行translate(-100, 0)），再进行下面的操作。之后也是类似的。由于我们只是保存了默认坐标系的状态，因此我们之后的translate()横坐标值必须增加，否则就会覆盖掉前面的图形。所有这些操作都是针对坐标系的，因此在绘制时，我们提供的矩形的坐标参数都是不变的。\n为了更直观的查看绘制坐标，先在背景画了一个网格。\n运行结果如下：\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/qt%E7%BB%98%E5%88%B6%E7%B3%BB%E7%BB%9F/","summary":"\u003cp\u003e本篇文章所涉及代码可在\u003ca href=\"https://github.com/Dunky-Z/learning-qt/tree/main/QtRoad2\"\u003e此处查看\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"绘制系统简介\"\u003e绘制系统简介\u003c/h2\u003e\n\u003cp\u003eQt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于\u003ccode\u003eQPainter\u003c/code\u003e,\u003ccode\u003eQPainterDevice\u003c/code\u003e和\u003ccode\u003eQPaintEngine\u003c/code\u003e三个类。\u003c/p\u003e","title":"Qt 绘制系统"},{"content":"计算机基础 计算机硬件基础 两大硬件架构\n冯诺依曼架构\n一根总线，开销小，控制逻辑实现简单\n执行效率低\n\u003c!DOCTYPE html\u003e Responsive Image 哈佛架构\n与上一架构相反 \u003c!DOCTYPE html\u003e Responsive Image 程序的存储与执行 .c文件经过编译链接，生成.out文件。加载到内存中，到控制单元运行。进行取值，译码，执行。\n晶振发出脉冲。 \u003c!DOCTYPE html\u003e Responsive Image 语言的设计与进化 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 上图是冯诺依曼架构，特点就是指令与数据放在一起。黄色部分表示指令，绿色部分表示数据。我们来看看指令是如何执行的。 ProgramCounter指到右图内存的第一条指令，程序开始执行。将第一条 指令读入指令寄存器。然后将指令解码，根据之前的规定，我们可以知道这条指令是将0100(二进制即 5)位置的数据，00(load)到00(Register 0)中。下面的指令一次类推，每次取指，Program Counter移动一次。 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/","summary":"\u003ch2 id=\"计算机基础\"\u003e计算机基础\u003c/h2\u003e\n\u003ch3 id=\"计算机硬件基础\"\u003e计算机硬件基础\u003c/h3\u003e\n\u003cp\u003e两大硬件架构\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e冯诺依曼架构\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e一根总线，开销小，控制逻辑实现简单\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e执行效率低\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211529332.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211529332.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"RISC-V 入门 - 计算机基础"},{"content":"了解了如何在VSCode 中调试程序，接下来我们在 VSCode 中搭建调试 QEMU 的环境。\n配置 首先我们需要下载和编译 QEMU 源码\n./configure --enable-debug --target-list=riscv32-softmmu,riscv32-linux-user --enable-kvm 一定要加上--enable-debug，编译出的程序才带有调试信息，不用设置安装路径，编译时会自动在 qemu 文件夹下自动创建一个build文件夹，编译后的程序也在build文件夹下。\n用 VSCode 打开qemu-6.X.X文件夹，Ctrl+Shift+D打开调试配置。如果参考过VSCode 中调试程序这篇文章，接下来就很容易。我们只需要将launch.jason文件中的program属性改为${workspaceFolder}/build/qemu-system-riscv32即可。\n调试 打开qemu-6.X.X/softmmu/main.c文件，在main函数入口处打上断点，即可开始调试。\n\u003c!DOCTYPE html\u003e Responsive Image 现在只需要点击屏幕上的图标，就可以快速的进行单步调试。\n如果需要进行命令行操作，在屏幕下方打开DEBUG CONSOLE，输入-exec+正常命令行下的命令即可在命令行中进行更多的调试。如查看断点信息-exec info breakpoints\n\u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/vscode%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95qemu/","summary":"\u003cp\u003e了解了如何在\u003ca href=\"https://dunky-z.github.io/2021/08/23/VSCode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/\"\u003eVSCode 中调试程序\u003c/a\u003e，接下来我们在 VSCode 中搭建调试 QEMU 的环境。\u003c/p\u003e\n\u003ch2 id=\"配置\"\u003e配置\u003c/h2\u003e\n\u003cp\u003e首先我们需要\u003ca href=\"https://dunky-z.github.io/2021/07/23/QEMU%E5%88%9D%E8%AF%86/\"\u003e下载和编译 QEMU 源码\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./configure --enable-debug --target-list=riscv32-softmmu,riscv32-linux-user --enable-kvm\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e一定要加上\u003ccode\u003e--enable-debug\u003c/code\u003e，编译出的程序才带有调试信息，不用设置安装路径，编译时会自动在 qemu 文件夹下自动创建一个\u003ccode\u003ebuild\u003c/code\u003e文件夹，编译后的程序也在\u003ccode\u003ebuild\u003c/code\u003e文件夹下。\u003c/p\u003e","title":"VSCode 单步调试 QEMU"},{"content":"设置一个旋转效果，将登录界面旋转翻个面，设置一些网络参数。\n效果 \u003c!DOCTYPE html\u003e Responsive Image 网络参数设置界面布局 \u003c!DOCTYPE html\u003e Responsive Image 网络参数设置界面 //loginnetsetwindow.cpp //初始化标题 void LoginNetSetWindow::initMyTitle() { m_titleBar-\u0026gt;move(0, 0); m_titleBar-\u0026gt;raise(); m_titleBar-\u0026gt;setBackgroundColor(0, 0, 0, true); m_titleBar-\u0026gt;setButtonType(MIN_BUTTON); m_titleBar-\u0026gt;setTitleWidth(this-\u0026gt;width()); m_titleBar-\u0026gt;setMoveParentWindowFlag(false); } void LoginNetSetWindow::initWindow() { QLabel* pBack = new QLabel(this); QMovie *movie = new QMovie(); movie-\u0026gt;setFileName(\u0026#34;:/Resources/NetSetWindow/headBack.gif\u0026#34;); pBack-\u0026gt;setMovie(movie); movie-\u0026gt;start(); pBack-\u0026gt;move(0, 0); connect(ui.pButtonOk, SIGNAL(clicked()), this, SIGNAL(rotateWindow())); connect(ui.pButtonCancel, SIGNAL(clicked()), this, SIGNAL(rotateWindow())); ui.comboBoxNetType-\u0026gt;addItem(QStringLiteral(\u0026#34;不使用代理\u0026#34;)); ui.comboBoxServerType-\u0026gt;addItem(QStringLiteral(\u0026#34;不使用高级选项\u0026#34;)); } void LoginNetSetWindow::paintEvent(QPaintEvent *event) { // 绘制背景图; QPainter painter(this); QPainterPath pathBack; pathBack.setFillRule(Qt::WindingFill); pathBack.addRoundedRect(QRect(0, 0, this-\u0026gt;width(), this-\u0026gt;height()), 3, 3); painter.setRenderHint(QPainter::Antialiasing, true); painter.fillPath(pathBack, QBrush(QColor(235, 242, 249))); QPainterPath pathBottom; pathBottom.setFillRule(Qt::WindingFill); pathBottom.addRoundedRect(QRect(0, 300, this-\u0026gt;width(), this-\u0026gt;height() - 300), 3, 3); painter.setRenderHint(QPainter::Antialiasing, true); painter.fillPath(pathBottom, QBrush(QColor(205, 226, 242))); painter.setPen(QPen(QColor(160 , 175 , 189))); painter.drawRoundedRect(QRect(0, 0, this-\u0026gt;width(), this-\u0026gt;height()), 3, 3); } initMyTitle()就不多说了，和正面登录界面差不多。\nQPainterPath类 它是由一些图形如曲线、矩形、椭圆组成的对象。主要的用途是，能保存已经绘制好的图形。实现图形元素的构造和复用；图形状只需创建一次，然后调用QPainter::drawPath() 函数多次绘制。painterpath可以加入闭合或不闭合的图形 ( 如：矩形、椭圆和曲线) 。QPainterPath 可用于填充，描边，clipping。\nsetFillRule()设置填充模式 不是很理解 https://doc.qt.io/qt-5/qt.html#FillRule-enum\naddRoundedRect(QRect(0, 0, this-\u0026gt;width(), this-\u0026gt;height()), 3, 3)圆角矩形 QRect(0, 300, this-\u0026gt;width(), this-\u0026gt;height() - 300)设置了矩形的位置及大小 (3,3)表示倒圆角的大小 setRenderHint()开启反走样 QPainter::Antialiasing 告诉绘图引擎应该在可能的情况下进行边的反锯齿绘制 QPainter::TextAntialiasing 尽可能的情况下文字的反锯齿绘制 QPainter::SmoothPixmapTransform 使用平滑的 pixmap 变换算法 (双线性插值算法),而不是近邻插值算 初始化旋转窗口 // 初始化旋转的窗口; void RotateWidget::initRotateWindow() { m_loginWindow = new LoginWindow(this); // 这里定义了两个信号，需要自己去发送信号; connect(m_loginWindow, SIGNAL(rotateWindow()), this, SLOT(onRotateWindow())); connect(m_loginWindow, SIGNAL(closeWindow()), this, SLOT(close())); connect(m_loginWindow, SIGNAL(hideWindow()), this, SLOT(onHideWindow())); m_loginNetSetWindow = new LoginNetSetWindow(this); connect(m_loginNetSetWindow, SIGNAL(rotateWindow()), this, SLOT(onRotateWindow())); connect(m_loginNetSetWindow, SIGNAL(closeWindow()), this, SLOT(close())); connect(m_loginNetSetWindow, SIGNAL(hideWindow()), this, SLOT(onHideWindow())); this-\u0026gt;addWidget(m_loginWindow); this-\u0026gt;addWidget(m_loginNetSetWindow); // 这里宽和高都增加，是因为在旋转过程中窗口宽和高都会变化; this-\u0026gt;setFixedSize(QSize(m_loginWindow-\u0026gt;width() + 20, m_loginWindow-\u0026gt;height() + 100)); } 对正面和反面分别定义了信号槽，当对应的面接收到信号时，执行对应的动作。因为是旋转一百八十度，所以选择函数可以公用。\n旋转窗口 \u003c!DOCTYPE html\u003e Responsive Image // 开始旋转窗口; void RotateWidget::onRotateWindow() { // 如果窗口正在旋转，直接返回; if (m_isRoratingWindow) { return; } m_isRoratingWindow = true; m_nextPageIndex = (currentIndex() + 1) \u0026gt;= count() ? 0 : (currentIndex() + 1); QPropertyAnimation *rotateAnimation = new QPropertyAnimation(this, \u0026#34;rotateValue\u0026#34;); // 设置旋转持续时间; rotateAnimation-\u0026gt;setDuration(1500); // 设置旋转角度变化趋势; rotateAnimation-\u0026gt;setEasingCurve(QEasingCurve::InCubic); // 设置旋转角度范围; rotateAnimation-\u0026gt;setStartValue(0); rotateAnimation-\u0026gt;setEndValue(180); connect(rotateAnimation, SIGNAL(valueChanged(QVariant)), this, SLOT(repaint())); connect(rotateAnimation, SIGNAL(finished()), this, SLOT(onRotateFinished())); // 隐藏当前窗口，通过不同角度的绘制来达到旋转的效果; currentWidget()-\u0026gt;hide(); rotateAnimation-\u0026gt;start(); } // 旋转结束; void RotateWidget::onRotateFinished() { m_isRoratingWindow = false; setCurrentWidget(widget(m_nextPageIndex)); repaint(); } / 绘制旋转效果; void RotateWidget::paintEvent(QPaintEvent *event) { if (m_isRoratingWindow) { // 小于 90 度时; int rotateValue = this-\u0026gt;property(\u0026#34;rotateValue\u0026#34;).toInt(); if (rotateValue \u0026lt;= 90) { QPixmap rotatePixmap(currentWidget()-\u0026gt;size()); currentWidget()-\u0026gt;render(\u0026amp;rotatePixmap); QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing); QTransform transform; transform.translate(width() / 2, 0); transform.rotate(rotateValue, Qt::YAxis); painter.setTransform(transform); painter.drawPixmap(-1 * width() / 2, 0, rotatePixmap); } // 大于 90 度时 else { QPixmap rotatePixmap(widget(m_nextPageIndex)-\u0026gt;size()); widget(m_nextPageIndex)-\u0026gt;render(\u0026amp;rotatePixmap); QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing); QTransform transform; transform.translate(width() / 2, 0); transform.rotate(rotateValue + 180, Qt::YAxis); painter.setTransform(transform); painter.drawPixmap(-1 * width() / 2, 0, rotatePixmap); } } else { return QStackedWidget::paintEvent(event); } } QPropertyAnimation动画类 QPropertyAnimation *rotateAnimation = new QPropertyAnimation(this, \u0026quot;rotateValue\u0026quot;)\nrotateValue就是这个动画的属性，我们这个动画中变化的就是旋转值，也就是旋转角度。这个属性名完全自己起，也可以改成rotateAngle等等，或者说想做一个平移的动画，也可以取一个moveDist等名字。 下面这一串就是标准的一套动画流程\n// 设置旋转持续时间; rotateAnimation-\u0026gt;setDuration(1000); // 设置旋转角度变化趋势; rotateAnimation-\u0026gt;setEasingCurve(QEasingCurve::InCubic); // 设置旋转角度范围; rotateAnimation-\u0026gt;setStartValue(0); rotateAnimation-\u0026gt;setEndValue(180); //开始动画 rotateAnimation-\u0026gt;start(); paintEvent绘图事件 #include \u0026lt;QtWidgets/QApplication\u0026gt; #include \u0026#34;rotatewidget.h\u0026#34; int main(int argc, char *argv[]) { QApplication a(argc, argv); RotateWidget w; w.show(); return a.exec(); } 我们main函数得知，最开始显示的窗口就是RotateWidget。在实例化一个RotateWidget类后，进行了标题栏的初始化工作，然后开始执行w.show()显示，但是此时窗口是不显示的。这是因为我们在RotateWidget的构造函数中进行了设置不显示窗口。\nthis-\u0026gt;setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::WindowMinimizeButtonHint); 当运行到return a.exec()时，Qt 会自动调用void RotateWidget::paintEvent()。此时开始正式绘制窗口，但是因为我们还没哟点击登录页面的网络设置按钮，所以m_isRoratingWindow=0。会调用父类的绘图事件，QStackedWidget::paintEvent()，最后也就是BaseWindow::paintEvent()。会将登录页面先绘制出来。\n当我们点击网络设置按钮时，m_isRoratingWindow=1开始绘制旋转画面。\n","permalink":"https://lifeislife.cn/posts/qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E9%A1%B5%E9%9D%A2%E5%8F%8D%E8%BD%AC%E6%95%88%E6%9E%9C/","summary":"\u003cp\u003e设置一个旋转效果，将登录界面旋转翻个面，设置一些网络参数。\u003c/p\u003e\n\u003ch2 id=\"效果\"\u003e效果\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826100416.gif\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826100416.gif\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"Qt 模仿登录界面-页面反转效果"},{"content":"系统初始化 x86 架构概述 CPU（Central Processing Unit）：中央处理器，计算机所有设备都围绕它展开工作。\n运算单元：只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。 数据单元：运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了数据单元。数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。 控制单元：有了放数据的地方，也有了算的地方，还需要有个指挥到底做什么运算的地方，这就是控制单元。控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。 内存（Memory）：CPU 本身不能保存大量数据，许多复杂的计算需要将中间结果保存下来就必须用到内存。\n总线（Bus）：CPU 和其他设备连接，就靠总线，其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。\n地址总线：传输地址数据（我想拿内存中哪个位置的数据） 数据总线：传输真正的数据 总线就像 CPU 和内存之间的高速公路，总线多少位就类似高速公路多少个车道，但两种总线的位数意义不同。\n地址总线的位数决定了访问地址范围有多广，数据总线位数决定了一次能拿多少数据进来。那么 CPU 中总线的位数有没有标准呢？如果没有标准，那操作系统作为软件就很难办了，因为软件层没办法实现通用的运算逻辑。早期每家公司的 CPU 架构都不同，后来历史将 x86 平台推到了开放，统一，兼容的位置。\n8086 架构图 \u003c!DOCTYPE html\u003e Responsive Image 数据单元： 8086 处理器内部共有 8 个 16 位的通用寄存器，分别是 数据寄存器（AX、BX、CX、DX）、指针寄存器（SP、BP）、变址寄存器（SI、DI）。其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。\n控制单元： IP 寄存器（Instruction Pointer Register）就是指令指针寄存器，它指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。\n如果需要切换进程呢？每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS、DS、SS、ES。\n其中，CS 就是代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置；DS 是数据段的寄存器（Data Segment Register），通过它可以找到数据在内存中的位置。SS 是栈寄存器（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则。ES是扩展段寄存器（Extra Segment Register）顾名思义。\n如果 CPU 运算中需要加载内存中的数据，需要通过 DS 找到内存中的数据，加载到通用寄存器中，应该如何加载呢？对于一个段，有一个起始的地址，而段内的具体位置，我们称为偏移量（Offset）。在 CS 和 DS 中都存放着一个段的起始地址。代码段的偏移量在 IP 寄存器中，数据段的偏移量会放在通用寄存器中。因为段寄存器都是 16 位的，而地址总线是 20 位的，所以通过 *起始地址 16+ 偏移量 的方式，将寻址位数都变成 20 位，也就是将 CS 和 DS 的值左移 4 位。\n对于只有 20 位地址总线的 8086 来说，寻址空间最大也就是$2^{20}=1\\text{M}$，超过这个位置就访问不到了，一个段因为偏移量只有 16 位，所以一个段最大是$2^{16}=64\\text{k}$。\n32 位处理器 随着计算机发展，内存越来越大，总线也越来越宽。在 32 位处理器中，有 32 根地址总线，可以访问 $2^{32}=4\\text{G}$ 的内存。使用原来的模式肯定不行了，但是又不能完全抛弃原来的模式，因为这个架构是开放的。那么在开发架构的基础上如何保持兼容呢？\n首先，通用寄存器有扩展，可以将 8 个 16 位的扩展到 8 个 32 位的，但是依然可以保留 16 位的和 8 位的使用方式。其中，指向下一条指令的指令指针寄存器 IP，就会扩展成 32 位的，同样也兼容 16 位的。\n\u003c!DOCTYPE html\u003e Responsive Image 段寄存器改动较大，新的段寄存器都改成了 32 位的，每个寄存器又分为段描述符缓存器（Segment Descriptor），和段选择子寄存器（Selector） ,现在的段寄存器不在是段的起始地址，段的起始地址保存在表格一样的段描述符缓冲器中，段选择子寄存器保存地址在段描述符缓存器中的哪一项。这样，将一个从段寄存器直接拿到的段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。\n虽然现在的这种模式和之前的模式不兼容，但是后面这种模式灵活的非常高，可以保持一直兼容下去。在 32 位的系统架构下，将前一种模式称为实模式（Real Pattern），后一种模式称为保护模式（Protected Pattern） 。当系统刚刚启动的时候，CPU 是处于实模式的，这个时候和原来的模式是兼容的。也就是说，哪怕你买了 32 位的 CPU，也支持在原来的模式下运行。\n\u003c!DOCTYPE html\u003e Responsive Image 汇编命令学习 mov, call, jmp, int, ret, add, or, xor, shl, shr, push, pop, inc, dec, sub, cmp。\nBIOS 与 BootLoader BIOS：基本输入输出系统\nROM：只读存储器\nRAM：随机存取存储器\n在我们按下电脑电源键的那一刻，主板就加电了，CPU 就要开始执行指令了，但是刚开始操作系统都没，CPU 执行什么指令呢？这就有了BIOS，它相当于一个指导手册，告诉 CPU 接下来要干啥。\n刚开机时，系统初始化代码从 ROM 读取，将 CS 设置为 0xFFFF，将 IP 设置为 0x0000，所以第一条指令就会指向 0xFFFF0，初始化完成后确定访问指令位置。\n接下来 BIOS 会检查各个硬件是否正常，检测内容显卡等关键部件的存在于工作状态，设备初始化，执行系统 BIOS 进行系统检测，更新 CMOS 中的扩展系统配置数据 ESCD。这期间也会建立中断向量表和中断服务程序，因为要使用键盘鼠标都需要中断进行。\n下一步 BIOS 就得要找操作系统了，操作系统一般安装在硬盘上，但是 BIOS 得先找到启动盘，启动盘一般安装在第一个扇区，占 512 字节，会包含启动的相关代码。在 Linux 中，可以通过Grub2配置这些代码。\ngrub2-mkconfig -o /boot/grub2/grub.cfg grub2第一个要安装的就是boot.img。它由 boot.S编译而成，一共 512 字节，正式安装到启动盘的第一个扇区。这个扇区通常称为MBR（Master Boot Record，主引导记录 / 扇区）。\nBIOS 完成任务后，会将 boot.img 从硬盘加载到内存中的 0x7c00来运行。\n由于 512 个字节实在有限，boot.img 做不了太多的事情。它能做的最重要的一个事情就是加载grub2 的另一个镜像 core.img。\ncore.img 由lzma_decompress.img、diskboot.img、kernel.img 和一系列的模块组成，功能比较丰富，能做很多事情。\nboot.img 先加载的是 core.img 的第一个扇区。如果从硬盘启动的话，这个扇区里面是diskboot.img，对应的代码是 diskboot.S。\nboot.img 将控制权交给 diskboot.img 后，diskboot.img 的任务就是将core.img 的其他部分加载进来，先是解压缩程序 lzma_decompress.img，再往下是 kernel.img，最后是各个模块module对应的映像。这里需要注意，它不是 Linux 的内核，而是grub 的内核。\n在这之前，我们所有遇到过的程序都非常非常小，完全可以在实模式下运行，但是随着我们加载的东西越来越大，实模式这1M 的地址空间实在放不下了，所以在真正的解压缩之前，lzma_decompress.img 做了一个重要的决定，就是调用 real_to_prot，切换到保护模式，这样就能在更大的寻址空间里面，加载更多的东西。\nBIOS将加载程序从硬盘的引导扇区加载到指定位置，再跳转到指定位置，将控制权转交给加载程序。加载程序将操作系统代码读取到内存，并将控制权转到操作系统。\nQ：BIOS-操作系统，中间经过加载程序。为何不直接读取？ A：磁盘文件系统多种多样，硬盘出厂时不能限制只能用一种文件系统，而 BIOS 也不能加上识别所有文件系统的代码。所有为了灵活性只读取磁盘的一块，由加载程序来识别磁盘的文件系统。\n切换到保护模式后，将会做以下这些事，大多数都与内存访问方式有关。\n首先启动分段，就是在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。\n接着是启动分页。能够管理的内存变大了，就需要将内存分成相等大小的块。\n打开 Gate20，也就是第 21 根地址线的控制线。因为在实模式 8086 下，一共就 20 根地址线，最大访问1M的地址空间。切换保护模式的函数DATA32 call real_to_prot会打开Gate A20。\n现在好了，有的是空间了。接下来我们要对压缩过的 kernel.img 进行解压缩，然后跳转到 kernel.img 开始运行。\n内核初始化 start_kernel() INIT_TASK(init_task) trap_init() mm_init() sched_init() rest_init() kernel_thread(kernel_init, NULL,CLONE_FS) kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES) 内核的启动从入口函数start_kernel() 开始。在 init/main.c 文件中，start_kernel 相当于内核的 main 函数。打开这个函数，我们会发现，里面是各种各样初始化函数 XXXX_init。\n在操作系统里面，先要有个创始进程，有一行指令 set_task_stack_end_magic(\u0026amp;init_task)。这里面有一个参数 init_task，它的定义是 struct task_struct init_task = INIT_TASK(init_task)。它是系统创建的第一个进程，我们称为0号进程。这是唯一一个没有通过fork 或者kernel_thread 产生的进程，是进程列表的第一个。\ntrap_init()里设置了很多**中断门 (Interrupt Gate)**处理各种中断。\nmm_init()初始化内存管理模块，sched_init()初始化调度模块。\nvfs_caches_init() 会用来初始化基于内存的文件系统 rootfs。在这个函数里面，会调用 mnt_init()-\u0026gt;init_rootfs()。这里面有一行代码，register_filesystem(\u0026amp;rootfs_fs_type)。在 VFS 虚拟文件系统里面注册了一种类型，我们定义为 struct file_system_type rootfs_fs_type。为了兼容各种各样的文件系统，我们需要将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一的接口，这个抽象层就是 VFS（Virtual File System），虚拟文件系统。\n最后start_kernel()调用rest_init()来做其他方面的初始化，如初始化 1 号进程，内核态与用户态转化等。\nrest_init 的第一大工作是，用 kernel_thread(kernel_init, NULL, CLONE_FS)创建第二个进程，这个是1 号进程。这对操作系统意义非凡，因为他将运行第一个用户进程，一旦有了用户进程，运行模式也将发生改变，之前所有资源都是给一个进程用，现在有了用户进程，就会出现抢夺资源的现象。资源也分核心和非核心资源，具有不同权限的进程可以获取不同的资源。x86提供了分层的权限机制，分成四个Ring，越往里权限越高。\n\u003c!DOCTYPE html\u003e Responsive Image 操作系统很好地利用了这个机制，将能够访问关键资源的代码放在 Ring0，我们称为内核态（Kernel Mode）；将普通的程序代码放在 Ring3，我们称为用户态（User Mode）。\n继续探究kernel_thread()这个函数，它的一个参数有一个函数kernel_init，在这个函数里会调用kernel_init_freeable()，里面有这样一段代码\nif (!ramdisk_execute_command) ramdisk_execute_command = \u0026#34;/init\u0026#34;; 先不管ramdisk 是啥，我们回到 kernel_init 里面。这里面有这样的代码块：\nif (ramdisk_execute_command) { ret = run_init_process(ramdisk_execute_command); .... } .... if (!try_to_run_init_process(\u0026#34;/sbin/init\u0026#34;) || !try_to_run_init_process(\u0026#34;/etc/init\u0026#34;) || !try_to_run_init_process(\u0026#34;/bin/init\u0026#34;) || !try_to_run_init_process(\u0026#34;/bin/sh\u0026#34;)) return 0; 我们可以发现，1 号进程运行的是一个文件，如果我们打开run_init_process函数，会发现它调用的是do_execve。\n前面讲系统调用的时候，execve 是一个系统调用，它的作用是运行一个执行文件。加一个 do_ 的往往是内核系统调用的实现。没错，这就是一个系统调用，它会尝试运行 ramdisk 的“/init”，或者普通文件系统上的“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”。不同版本的 Linux 会选择不同的文件启动，但是只要有一个起来了就可以。\nstatic int run_init_process(const char *init_filename) { argv_init[0] = init_filename; return do_execve(getname_kernel(init_filename), (const char __user *const __user *)argv_init, (const char __user *const __user *)envp_init); } 如何利用执行 init 文件的机会，从内核态回到用户态呢？\n我们从系统调用的过程可以得到启发，“用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态”，然后接着运行。而咱们刚才运行init，是调用 do_execve，正是上面的过程的后半部分，从内核态执行系统调用开始。\ndo_execve-\u0026gt;do_execveat_common-\u0026gt;exec_binprm-\u0026gt;search_binary_handler，这里面会调用这段内容：\nint search_binary_handler(struct linux_binprm *bprm) { ...... struct linux_binfmt *fmt; ...... retval = fmt-\u0026gt;load_binary(bprm); ...... } 也就是说，我要运行一个程序，需要加载这个二进制文件，这就是我们常说的项目执行计划书。它是有一定格式的。Linux 下一个常用的格式是 ELF（Executable and Linkable Format，可执行与可链接格式）。于是我们就有了下面这个定义：\nstatic struct linux_binfmt elf_format = { .module = THIS_MODULE, .load_binary = load_elf_binary, .load_shlib = load_elf_library, .core_dump = elf_core_dump, .min_coredump = ELF_EXEC_PAGESIZE, }; 这其实就是先调用 load_elf_binary，最后调用 start_thread。\nvoid start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp) { set_user_gs(regs, 0); regs-\u0026gt;fs = 0; regs-\u0026gt;ds = __USER_DS; regs-\u0026gt;es = __USER_DS; regs-\u0026gt;ss = __USER_DS; regs-\u0026gt;cs = __USER_CS; regs-\u0026gt;ip = new_ip; regs-\u0026gt;sp = new_sp; regs-\u0026gt;flags = X86_EFLAGS_IF; force_iret(); } EXPORT_SYMBOL_GPL(start_thread); struct pt_regs，看名字里的 register，就是寄存器啊！这个结构就是在系统调用的时候，内核中保存用户态运行上下文的，里面将用户态的代码段 CS设置为 __USER_CS，将用户态的数据段 DS 设置为 __USER_DS，以及指令指针寄存器 IP、栈指针寄存器 SP。这里相当于补上了原来系统调用里，保存寄存器的一个步骤。\n最后的 iret 是干什么的呢？它是用于从系统调用中返回。这个时候会恢复寄存器。从哪里恢复呢？按说是从进入系统调用的时候，保存的寄存器里面拿出。好在上面的函数补上了寄存器。CS 和指令指针寄存器 IP 恢复了，指向用户态下一个要执行的语句。DS 和函数栈指针 SP 也被恢复了，指向用户态函数栈的栈顶。所以，下一条指令，就从用户态开始运行了。\ninit 终于从内核到用户态了。一开始到用户态的是 ramdisk 的 init，后来会启动真正根文件系统上的 init，成为所有用户态进程的祖先。\n为什么会有 ramdisk 这个东西呢？还记得上一节咱们内核启动的时候，配置过这个参数：\ninitrd16 /boot/initramfs-3.10.0-862.el7.x86_64.img 就是这个东西，这是一个基于内存的文件系统。为啥会有这个呢？\n是因为刚才那个 init 程序是在文件系统上的，文件系统一定是在一个存储设备上的，例如硬盘。Linux 访问存储设备，要有驱动才能访问。如果存储系统数目很有限，那驱动可以直接放到内核里面，反正前面我们加载过内核到内存里了，现在可以直接对存储系统进行访问。\n但是存储系统越来越多了，如果所有市面上的存储系统的驱动都默认放进内核，内核就太大了。这该怎么办呢？\n我们只好先弄一个基于内存的文件系统。内存访问是不需要驱动的，这个就是 ramdisk。这个时候，ramdisk 是根文件系统。\n然后，我们开始运行 ramdisk 上的 /init。等它运行完了就已经在用户态了。/init 这个程序会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。有了真正的根文件系统，ramdisk上的 /init 会启动文件系统上的 init。\n接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了。\n至此，用户态进程有了一个祖宗，那内核态的进程呢？这就是rest_init接下来要做的是，创建 2 号线程。\nkernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)又一次使用 kernel_thread 函数创建进程。这里的函数 kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。\n系统调用 Linux 提供了glibc这个库封装了系统调用，方便用户使用。那么在打开一个文件时，glibc是如何调用内核的open的呢？\n在 glibc 的源代码中，有个文件syscalls.list，里面列着所有 glibc 的函数对应的系统调用，就像下面这个样子：\n# File name Caller Syscall name Args Strong name Weak names open - open Ci:siv __libc_open __open open 另外，glibc 还有一个脚本 make-syscall.sh，可以根据上面的配置文件，对于每一个封装好的系统调用，生成一个文件。这个文件里面定义了一些宏，例如 #define SYSCALL_NAME open。\nglibc 还有一个文件 syscall-template.S，使用上面这个宏，定义了这个系统调用的调用方式。\n对于任何一个系统调用，会调用DO_CALL。这也是一个宏，这个宏 32 位和 64 位的定义是不一样的。\n32 位系统调用过程 i386 目录下的sysdep.h 文件\n/* Linux takes system call arguments in registers: syscall number %eax call-clobbered arg 1 %ebx call-saved arg 2 %ecx call-clobbered arg 3 %edx call-clobbered arg 4 %esi call-saved arg 5 %edi call-saved arg 6 %ebp call-saved ...... */ #define DO_CALL(syscall_name, args) PUSHARGS_##args DOARGS_##args movl $SYS_ify (syscall_name), %eax; ENTER_KERNEL POPARGS_##args 这里，我们将请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器 eax 里面，然后执行 ENTER_KERNEL。\n# define ENTER_KERNEL int $0x80 ENTER_KERNEL就是一个软中断，通过它可以陷入 (trap) 内核。\n在内核启动的时候，还记得有一个 trap_init()，这是一个软中断的陷入门。当接到一个系统调用时，trap_init()就会调用entry_INT80_32。\n通过 push 和 SAVE_ALL 将当前用户态的寄存器，保存在 pt_regs 结构里面，然后调用 do_syscall_32_irqs_on。\n\u003c!DOCTYPE html\u003e Responsive Image 64 位系统调用过程 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96/","summary":"\u003ch2 id=\"系统初始化\"\u003e系统初始化\u003c/h2\u003e\n\u003ch3 id=\"x86-架构概述\"\u003ex86 架构概述\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCPU（Central Processing Unit）\u003c/strong\u003e：中央处理器，计算机所有设备都围绕它展开工作。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e运算单元：只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。\u003c/li\u003e\n\u003cli\u003e数据单元：运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了数据单元。数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。\u003c/li\u003e\n\u003cli\u003e控制单元：有了放数据的地方，也有了算的地方，还需要有个指挥到底做什么运算的地方，这就是控制单元。控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e内存（Memory）\u003c/strong\u003e：CPU 本身不能保存大量数据，许多复杂的计算需要将中间结果保存下来就必须用到内存。\u003c/p\u003e","title":"Linux 操作系统-系统初始化"},{"content":"前提 本文主要涉及 VSCode 的相关配置，编译及调试工具需要提前安装好。\n已经安装好riscv-toolchain，包括riscv64-unknown-elf-gcc，riscv64-unknown-elf-gdb 已经安装好qemu，包括riscv32-softmmu,riscv32-linux-user,riscv64-softmmu,riscv64-linux-user 已经安装好g++,gdb 调试流程简介 对于我这样的新手，要调试一个项目源码最怕的就是开始，也就是怎么能把项目跑起来。\n我们以一个简单的test项目，看看在 VSCode 里怎么跑起来。\n拿到源码后，将其以文件夹形式，加入到 VSCode 中，文件 - 打开文件夹 - 选择 test 项目文件夹。项目就会在 VSCode 中打开，但是此时我们还无法编译运行，我们需要在 VSCode 上 构建出一个 C 语言的编译与调试环境。\n首先得安装一个插件C/C++，打开插件中心Ctrl+Shit+X，搜索，安装。\n然后输入F5，会弹出对话框，选择C++(GDB)，继续选择g++。VSCode 会自动创建.vscode文件夹，已经两个文件launch.json和tasks.json。 \u003c!DOCTYPE html\u003e Responsive Image launch.json用来配置调试环境，tasks.json主要用来配置编译环境，当然也可以配置其他任务。task.json里配置的每个任务其实就相当于多开一个控制台。\n配置tasks.json 因为我们先要编译源码，生成.out或者.exe文件，才能调试，所以先进行编译任务配置。\n自动生成的文件是个配置模板，我们可以根据自己的实际情况进行配置，也有一部分可以保持默认。\n// tasks.json { // https://code.visualstudio.com/docs/editor/tasks \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { // 任务的名字，注意是大小写区分的 //会在launch中调用这个名字 \u0026#34;label\u0026#34;: \u0026#34;C/C++: g++ build active file\u0026#34;, // 任务执行的是shell \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, // 命令是g++ \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, //g++ 后面带的参数 \u0026#34;args\u0026#34;: [ \u0026#34;\u0026#39;-Wall\u0026#39;\u0026#34;, \u0026#34;-g\u0026#34;, // 生成调试信息，否则无法进入断点 \u0026#34;\u0026#39;-std=c++17\u0026#39;\u0026#34;, //使用c++17标准编译 \u0026#34;\u0026#39;${file}\u0026#39;\u0026#34;, //当前文件名 \u0026#34;-o\u0026#34;, //对象名，不进行编译优化 \u0026#34;\u0026#39;${fileBasenameNoExtension}.exe\u0026#39;\u0026#34;, //当前文件名（去掉扩展名） ], } ] } 如果项目是通过 Makefile 编译的，那就更加简单，只需要配置一个任务即可。\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { //任务的名字方便执行 \u0026#34;label\u0026#34;: \u0026#34;Make Project\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;make\u0026#34;, \u0026#34;args\u0026#34;:[ //8线程编译 \u0026#34;-j8\u0026#34;, ], }, ] } 运行该任务时就会执行make命令进行编译。\n配置launch.json // launch.json { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { //调试任务的名字 \u0026#34;name\u0026#34;: \u0026#34;g++ - Build and debug active file\u0026#34;, //在launch之前运行的任务名，这个名字一定要跟tasks.json中的任务名字大小写一致 \u0026#34;preLaunchTask\u0026#34;: \u0026#34;C/C++: g++ build active file\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, //需要运行的是当前打开文件的目录中， //名字和当前文件相同，但扩展名为exe的程序 \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;args\u0026#34;: [], // 选为true则会在打开控制台后停滞，暂时不执行程序 \u0026#34;stopAtEntry\u0026#34;: false, // 当前工作路径：当前文件所在的工作空间 \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;environment\u0026#34;: [], // 是否使用外部控制台 \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ] }] } 运行 经过以上配置后，我们打开main.cpp文件，在cout处打一个断点，按F5，即可编译，运行，调试。一定要打开main.cpp文件，不能随便打开文件就开始哦。因为我们在配置时使用了一些预定义，比如${file}表示当前文件，所以只有打开需要调试的文件才能开始。\n\u003c!DOCTYPE html\u003e Responsive Image 程序将会在cout语句停下来。\n我们可以注意一下界面下方的控制台，可以更直观了解launch.jason和tasks.jason。\n\u003c!DOCTYPE html\u003e Responsive Image 右边的框，就是我们在tasks.jason中配置的任务，左边的框就是我们在tasks.jason中command以及args的内容，他就是帮我们提前写好编译的选项。然后在 shell 中运行。\n编译调试 RISC-V 程序 了解以上这些，就可以按需配置所需的环境了。我们还是从tasks.jason开始。因为开发用的电脑是x86的，所以先要编译出riscv的程序，再用模拟器模拟出rsicv的环境，然后在模拟的环境中运行程序，最后才能开始调试。\n假设已经安装好开头所提到的工具。首先配置tasks.jason：\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { // 编译当前代码 \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++(RISCV): Build active file\u0026#34;, // 编译器的位置 \u0026#34;command\u0026#34;: \u0026#34;/opt/riscv/bin/riscv64-unknown-elf-g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-Wall\u0026#34;, // 开启所有警告 \u0026#34;-g\u0026#34;, // 生成调试信息s \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${workspaceFolder}/debug/${fileBasenameNoExtension}\u0026#34; // 我选择将可执行文件放在debug目录下 ], // 当前工作路径：执行当前命令时所在的路径 \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ] }, { // 启动qemu供调试器连接 \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Run Qemu Server(RISCV)\u0026#34;, \u0026#34;dependsOn\u0026#34;: \u0026#34;C/C++(RISCV): Build active file\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;qemu-system-riscv64\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;65500\u0026#34;, // gdb端口，自己定义 \u0026#34;${workspaceFolder}/debug/${fileBasenameNoExtension}\u0026#34; ], }, { // 有时候qemu有可能没法退出，故编写一个任务用于强行结束qemu进程 \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Kill Qemu Server(RISCV)\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;ps -C qemu-riscv64 --no-headers | cut -d \\\\ -f 1 | xargs kill -9\u0026#34;, } ] } tasks.jason是可以配置多个任务的，第一个任务用来编译成riscv架构下的程序，第二个任务用来启动 qemu，让程序在 qemu 上运行起来。\n第一个任务中，command就是配置编译器riscv64-unkonown-elf-gcc的属性，第二个任务中，command是配置 qemu 模拟器qemu-system-riscv32的属性。第三个任务中，用来配置结束 qemu 模拟器的命令。\n接下来配置launch.jason：\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C/C++(RISCV) - Debug Active File\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/debug/${fileBasenameNoExtension}\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], // RISC-V工具链中的gdb \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/opt/riscv/bin/riscv64-unknown-elf-gdb\u0026#34;, // 这里需要与task.json中定义的端口一致 \u0026#34;miDebuggerServerAddress\u0026#34;: \u0026#34;localhost:65500\u0026#34; } ] } 我们在配置x86下的调试环境时，launch.jason中有个\u0026quot;preLaunchTask\u0026quot;: \u0026quot;C/C++: g++ build active file\u0026quot;，属性，这个属性的目的是在启动调试之前，先执行任务名字为\u0026quot;C/C++: g++ build active file\u0026quot;任务，也是就编译的任务。\n因为启动 qemu 会导致阻塞，所以这里没有加preLaunchTask，在启动调试之前，先把 qemu 运行起来。输入Ctrl+Shift+P，打开 VSCode 命令行。输入Run Task，\n\u003c!DOCTYPE html\u003e Responsive Image 点击第一个，选择任务，我们可以看到出现的三个任务就是我们在tasks.jason中配置的三个任务。选择第一个 Build，编译出程序，再重复操作，选择第三个执行 QEMU 任务。\n\u003c!DOCTYPE html\u003e Responsive Image 预定义变量 官网\n","permalink":"https://lifeislife.cn/posts/vscode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/","summary":"\u003ch2 id=\"前提\"\u003e前提\u003c/h2\u003e\n\u003cp\u003e本文主要涉及 VSCode 的相关配置，编译及调试工具需要提前安装好。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e已经安装好\u003ccode\u003eriscv-toolchain\u003c/code\u003e，包括\u003ccode\u003eriscv64-unknown-elf-gcc\u003c/code\u003e，\u003ccode\u003eriscv64-unknown-elf-gdb\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e已经安装好\u003ccode\u003eqemu\u003c/code\u003e，包括\u003ccode\u003eriscv32-softmmu,riscv32-linux-user,riscv64-softmmu,riscv64-linux-user\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e已经安装好\u003ccode\u003eg++\u003c/code\u003e,\u003ccode\u003egdb\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"调试流程简介\"\u003e调试流程简介\u003c/h2\u003e\n\u003cp\u003e对于我这样的新手，要调试一个项目源码最怕的就是开始，也就是怎么能把项目跑起来。\u003c/p\u003e","title":"VSCode 调试 RISC-V 程序"},{"content":"简介 为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。\n信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P) 和发送（即V) 信息操作。最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。\n由于信号量只能进行两种操作等待和发送信号，即 P(sv) 和 V(sv),他们的行为是这样的：\nP(sv)：如果sv的值大于零，就给它减 1；如果它的值为零，就挂起该进程的执行\nV(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加 1.\n举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减 1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为 0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。\n本文代码同步在这里。\n相关函数 Linux 提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件 sys/sem.h 中。\nsemget() 它的作用是创建一个新信号量或取得一个已有信号量，原型为：\nint semget(key_t key, int num_sems, int sem_flags); key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget()函数并提供一个键，再由系统生成一个相应的信号标识符（semget()函数的返回值），只有semget()函数才直接使用信号量键，所有其他的信号量函数使用由semget()函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。\nnum_sems指定需要的信号量数目，它的值几乎总是 1。\nsem_flags是一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而IPC_CREAT | IPC_EXCL则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。\nsemget()函数成功返回一个相应信号标识符（非零），失败返回-1.\nsemop() 它的作用是改变信号量的值，原型为：\nint semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops); sem_id是由semget()返回的信号量标识符，sembuf结构的定义如下：\nstruct sembuf{ short sem_num; // 除非使用一组信号量，否则它为0 short sem_op; // 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即 P（等待）操作， // 一个是+1，即V（发送信号）操作。 short sem_flg; // 通常为 SEM_UNDO，使操作系统跟踪信号， // 并在进程没有释放该信号量而终止时，操作系统释放信号量 }; num_sem_ops：操作sops中的操作个数，通常取值为 1\nsemctl() 该函数用来直接控制信号量信息，它的原型为：\nint semctl(int sem_id, int sem_num, int command, ...); 如果有第四个参数，它通常是一个union semum结构，定义如下：\nunion semun { int val; struct semid_ds *buf; unsigned short *arry; }; 前两个参数与前面一个函数中的一样，command通常是下面两个值中的其中一个\nSETVAL：用来把信号量初始化为一个已知的值。p 这个值通过 union semun 中的 val 成员设置，其作用是在信号量第一次使用前对它进行设置。\nIPC_RMID：用于删除一个已经无需继续使用的信号量标识符。\n","permalink":"https://lifeislife.cn/posts/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。\u003c/p\u003e","title":"进程间通信（IPC）之信号量（Semaphore）"},{"content":"简介 消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。\n每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。\n本文代码同步在这里。\n相关函数 msgget() 该函数用来创建和访问一个消息队列。它的原型为：\nint msgget(key_t, key, int msgflg); key：与其他的 IPC 机制一样，程序必须提供一个键来命名某个特定的消息队列。 msgflg是一个权限标志，表示消息队列的访问权限，它与文件的访问权限一样。msgflg可以与IPC_CREAT做或操作，表示当 key 所命名的消息队列不存在时创建一个消息队列，如果 key 所命名的消息队列存在时，IPC_CREAT标志会被忽略，而只返回一个标识符。 它返回一个以key命名的消息队列的标识符（非零整数），失败时返回-1.\nmsgsnd() 该函数用来把消息添加到消息队列中。它的原型为：\nint msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg); msgid是由msgget函数返回的消息队列标识符。\nmsg_ptr是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针msg_ptr所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型。所以消息结构要定义成这样：\nstruct my_message { long int message_type; /* The data you wish to transfer */ }; msg_sz 是msg_ptr指向的消息的长度\nmsgflg 用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情\n如果调用成功，消息数据的副本将被放到消息队列中，并返回0，失败时返回-1.\nmsgrcv() 该函数用来从一个消息队列获取消息，它的原型为\nint msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg); 前三个参数参照前面的解释 msgtype 可以实现一种简单的接收优先级。如果msgtype为0，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。如果它小于零，就获取类型等于或小于msgtype的绝对值的第一个消息。 msgflg 用于控制当队列中没有相应类型的消息可以接收时将发生的事情。 调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由msg_ptr指向的用户分配的缓存区中，然后删除消息队列中的对应消息。失败时返回-1。 msgctl() 该函数用来控制消息队列，它与共享内存的shmctl函数相似，它的原型为：\nint msgctl(int msgid, int command, struct msgid_ds *buf); msgid同上\ncommand是将要采取的动作，它可以取3个值:\nIPC_STAT：把msgid_ds结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖msgid_ds的值。 IPC_SET：如果进程有足够的权限，就把消息列队的当前关联值设置为msgid_ds结构中给出的值 IPC_RMID：删除消息队列 buf是指向msgid_ds结构的指针，它指向消息队列模式和访问权限的结构。msgid_ds结构至少包括以下成员：\nstruct msgid_ds { uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode; }; 成功时返回 0，失败时返回 -1.\nDemo //msgsnd #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/msg.h\u0026gt; #define MAX_TXT 512 struct msg_st { long int msg_type; char msg[MAX_TXT]; }; int main() { struct msg_st message; int msgid = 1; char buffer[BUFSIZ]; key_t msgKey = ftok(\u0026#34;./msgsnd.c\u0026#34;, 0); msgid = msgget(msgKey, 0666 | IPC_CREAT); if (msgid == -1) { fprintf(stderr, \u0026#34;masget failed error: %d\\n\u0026#34;, errno); exit(EXIT_FAILURE); } while (1) { printf(\u0026#34;Enter some text: \\n\u0026#34;); fgets(buffer, BUFSIZ, stdin); message.msg_type = 1; // 注意 2 strcpy(message.msg, buffer); // 向队列里发送数据 if (msgsnd(msgid, (void *)\u0026amp;message, MAX_TXT, 0) == -1) { fprintf(stderr, \u0026#34;msgsnd failed\\n\u0026#34;); exit(EXIT_FAILURE); } // 输入 end 结束输入 if (strncmp(buffer, \u0026#34;end\u0026#34;, 3) == 0) { break; } sleep(1); } exit(EXIT_SUCCESS); } //msgrcv #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/msg.h\u0026gt; #define MAX_TXT 512 struct msg_st { long int msg_type; char msg[MAX_TXT]; }; int main() { struct msg_st message; int msgid = 1; long int msgtype = 0; key_t msgKey = ftok(\u0026#34;./msgsnd.c\u0026#34;, 0); msgid = msgget(msgKey, 0666 | IPC_CREAT); if (msgid == -1) { fprintf(stderr, \u0026#34;masget failed error: %d\\n\u0026#34;, errno); exit(EXIT_FAILURE); } while (1) { if (msgrcv(msgid, (void *)\u0026amp;message, BUFSIZ, msgtype, 0) == -1) { fprintf(stderr, \u0026#34;msgsnd failed\\n\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;You wrote: %s\\n\u0026#34;, message.msg); if (strncmp(message.msg, \u0026#34;end\u0026#34;, 3) == 0) { break; } } exit(EXIT_SUCCESS); } 运行结果 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97messagequeue/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。\u003c/p\u003e\n\u003cp\u003e每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。\u003c/p\u003e","title":"进程间通信（IPC）之消息队列（MessageQueue）"},{"content":"本来不想写这一篇的，安装 VSCode 时随便搜一下就 OK 了，但是因为 APT 源中没有 VSCode，所以需要找下载网址，几次的安装经历下来，找下载网址也经历了一番折腾。今天又要安装一遍，就顺手记录一下吧。以后翻自己记录总比翻全网记录方便。\n官方文档 其实最完备安装教程在官方文档里。本文也算是对官方文档的一个翻译版吧。\n基于 Debian 和 Ubuntu 的发行版 如果下载了.deb 安装包，那么只需要一个命令就可以完成安装了。\nsudo apt install ./\u0026lt;file\u0026gt;.deb 无奈的是，我需要在开发机安装，无法下载安装包，但是我又不想用ftp传来传去，要是apt能完成，绝不单独下载安装包。\n可以使用以下脚本手动安装存储库和密钥\nwget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor \u0026gt; packages.microsoft.gpg sudo install -o root -g root -m 644 packages.microsoft.gpg /etc/apt/trusted.gpg.d/ sudo sh -c \u0026#39;echo \u0026#34;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main\u0026#34; \u0026gt; /etc/apt/sources.list.d/vscode.list\u0026#39; rm -f packages.microsoft.gpg 更新与安装\nsudo apt install apt-transport-https sudo apt update sudo apt install code # or code-insiders ","permalink":"https://lifeislife.cn/posts/linux-ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85vscode/","summary":"\u003cp\u003e本来不想写这一篇的，安装 VSCode 时随便搜一下就 OK 了，但是因为 APT 源中没有 VSCode，所以需要找下载网址，几次的安装经历下来，找下载网址也经历了一番折腾。今天又要安装一遍，就顺手记录一下吧。以后翻自己记录总比翻全网记录方便。\u003c/p\u003e","title":"Linux(Ubuntu) 环境下安装 VSCode"},{"content":"内存管理概述 计算机所谓的“计算”指的是：\n进程和线程对于 CPU 的使用 对内存的管理 独享内存空间的原理 每个进程都独享一段内存空间，并且真实物理内存地址对进程不可见，操作系统会给进程分配一个虚拟地址，每个进程看到的内存地址都是从 0 开始。操作系统会将不同进程的虚拟地址和不同内存的物理地址做映射。当程序访问虚拟地址时，由内核的数据结构进行转换，转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址。\n规划虚拟地址空间 通过以上的原理，我们可以看出，操作系统的内存管理，主要分为三个方面。\n物理内存的管理； 虚拟地址的管理； 虚拟地址和物理地址如何映射； 进程获取了一段独立的虚拟内存空间后，可以不用管其他进程，“任意”使用这片内存，但是也有一点规则。这篇内存需要存放内核态和用户态的内容。高地址存放内核态的内容，低地址存放用户态的内容。具体分界线 64 位与 32 位不同，暂不深究。\n我们从最低位开始排起，先是Text Segment、Data Segment 和 BSS Segment。Text Segment 是存放二进制可执行代码的位置，Data Segment 存放静态常量，BSS Segment 存放未初始化的静态变量。是不是觉得这几个名字很熟悉？没错，咱们前面讲 ELF 格式的时候提到过，在二进制执行文件里面，就有这三个部分。这里就是把二进制执行文件的三个部分加载到内存里面。\n\u003c!DOCTYPE html\u003e Responsive Image 接下来是堆（Heap）段。堆是往高地址增长的，是用来动态分配内存的区域，malloc 就是在这里面分配的。 接下来的区域是Memory Mapping Segment。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将 so 文件映射到了内存中。 再下面就是栈（Stack）地址段。主线程的函数调用的函数栈就是用这里的。\n普通进程不能访问内核空间，如果需要进行更高权限的工作，就需要系统调用进入内核。每一段进程的内存空间存放的内容各不相同，但是进入内核后看到的都是同一个内核空间，同一个进程列表。\n内核的代码访问内核的数据结构，大部分的情况下都是使用虚拟地址的，虽然内核代码权限很大，但是能够使用的虚拟地址范围也只能在内核空间，也即内核代码访问内核数据结构。\n接下来，我们需要知道，如何将其映射成为物理地址呢？\n咱们前面讲 x86 CPU 的时候，讲过分段机制，咱们规划虚拟空间的时候，也是将空间分成多个段进行保存。我们来看看分段机制的原理。\n\u003c!DOCTYPE html\u003e Responsive Image 分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。段选择子就保存在咱们前面讲过的段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。虚拟地址中的段内偏移量应该位于 0 和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。\n例如，我们将上面的虚拟空间分成以下 4 个段，用 0～3 来编号。每个段在段表中有一个项，在物理空间中，段的排列如下图的右边所示。如果要访问段 2 中偏移量 600 的虚拟地址，我们可以计算出物理地址为，段 2 基地址 2000 + 偏移量 600 = 2600。\n\u003c!DOCTYPE html\u003e Responsive Image 在 Linux 里面，段表全称段描述符表（segment descriptors），放在全局描述符表 GDT（Global Descriptor Table）里面，会有下面的宏来初始化段描述符表里面的表项。\n#define GDT_ENTRY_INIT(flags, base, limit) { { { \\ .a = ((limit) \u0026amp; 0xffff) | (((base) \u0026amp; 0xffff) \u0026lt;\u0026lt; 16), \\ .b = (((base) \u0026amp; 0xff0000) \u0026gt;\u0026gt; 16) | (((flags) \u0026amp; 0xf0ff) \u0026lt;\u0026lt; 8) | \\ ((limit) \u0026amp; 0xf0000) | ((base) \u0026amp; 0xff000000), \\ } } } 一个段表项由段基地址 base、段界限 limit，还有一些标识符组成。\nDEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = { .gdt = { #ifdef CONFIG_X86_64 [GDT_ENTRY_KERNEL32_CS] = GDT_ENTRY_INIT(0xc09b, 0, 0xfffff), [GDT_ENTRY_KERNEL_CS] = GDT_ENTRY_INIT(0xa09b, 0, 0xfffff), [GDT_ENTRY_KERNEL_DS] = GDT_ENTRY_INIT(0xc093, 0, 0xfffff), [GDT_ENTRY_DEFAULT_USER32_CS] = GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff), [GDT_ENTRY_DEFAULT_USER_DS] = GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff), [GDT_ENTRY_DEFAULT_USER_CS] = GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff), #else [GDT_ENTRY_KERNEL_CS] = GDT_ENTRY_INIT(0xc09a, 0, 0xfffff), [GDT_ENTRY_KERNEL_DS] = GDT_ENTRY_INIT(0xc092, 0, 0xfffff), [GDT_ENTRY_DEFAULT_USER_CS] = GDT_ENTRY_INIT(0xc0fa, 0, 0xfffff), [GDT_ENTRY_DEFAULT_USER_DS] = GDT_ENTRY_INIT(0xc0f2, 0, 0xfffff), ...... #endif } }; EXPORT_PER_CPU_SYMBOL_GPL(gdt_page); 这里面对于 64 位的和 32 位的，都定义了内核代码段、内核数据段、用户代码段和用户数据段。另外，还会定义下面四个段选择子，指向上面的段描述符表项。\n#define __KERNEL_CS (GDT_ENTRY_KERNEL_CS*8) #define __KERNEL_DS (GDT_ENTRY_KERNEL_DS*8) #define __USER_DS (GDT_ENTRY_DEFAULT_USER_DS*8 + 3) #define __USER_CS (GDT_ENTRY_DEFAULT_USER_CS*8 + 3) 通过分析，我们发现，所有的段的起始地址都是一样的，都是 0。所以，在 Linux 操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。 其实 Linux 倾向于另外一种从虚拟地址到物理地址的转换方式，称为分页（Paging）。对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为换出。一旦需要的时候，再加载进来，叫作换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率。\n这个换入和换出都是以页为单位的。页面的大小一般为 4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了。\n\u003c!DOCTYPE html\u003e Responsive Image 虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。\n32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了。\n页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。\n那怎么办呢？我们可以试着将页表再分页，4G 的空间需要 4M 的页表来存储映射。我们把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K。\n页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置。\n这样加起来正好 32 位，也就是用前 10 位定位到页目录表中的一项。将这一项对应的页表取出来共 1k 项，再用中间 10 位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后 12 位定位到页中的具体位置访问数据。\n\u003c!DOCTYPE html\u003e Responsive Image 你可能会问，如果这样的话，映射 4GB 地址空间就需要 4MB+4KB 的内存，这样不是更大了吗？当然如果页是满的，当时是更大了，但是，我们往往不会为一个进程分配那么多内存。\n比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省多了。\n当然对于 64 位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。\n进程空间管理 物理内存管理 用户态内存映射 #define GDT_ENTRY_INIT(flags, base, limit) { { { \\ .a = ((limit) \u0026amp; 0xffff) | (((base) \u0026amp; 0xffff) \u0026lt;\u0026lt; 16), \\ .b = (((base) \u0026amp; 0xff0000) \u0026gt;\u0026gt; 16) | (((flags) \u0026amp; 0xf0ff) \u0026lt;\u0026lt; 8) | \\ ((limit) \u0026amp; 0xf0000) | ((base) \u0026amp; 0xff000000), \\ } } } 通过分析，我们发现，所有的段的起始地址都是一样的，都是 0。这算哪门子分段嘛！所以，在 Linux 操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。\n其实 Linux 倾向于另外一种从虚拟地址到物理地址的转换方式，称为分页（Paging）。\n对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为换出。一旦需要的时候，再加载进来，叫作换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率。\n","permalink":"https://lifeislife.cn/posts/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","summary":"\u003ch2 id=\"内存管理概述\"\u003e内存管理概述\u003c/h2\u003e\n\u003cp\u003e计算机所谓的“计算”指的是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e进程和线程对于 CPU 的使用\u003c/li\u003e\n\u003cli\u003e对内存的管理\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"独享内存空间的原理\"\u003e独享内存空间的原理\u003c/h3\u003e\n\u003cp\u003e每个进程都独享一段内存空间，并且真实物理内存地址对进程不可见，操作系统会给进程分配一个虚拟地址，每个进程看到的内存地址都是从 0 开始。操作系统会将不同进程的虚拟地址和不同内存的物理地址做映射。当程序访问虚拟地址时，由内核的数据结构进行转换，转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址。\u003c/p\u003e","title":"Linux 操作系统-内存管理"},{"content":"效果预览 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 设置窗口拖动 因为这个项目中没有将登录界面直接继承MainWindow，而是继承的Dialog类，所以它是不能直接移动的，需要我们自己添加相应的方法。这里实现了三种方法，点击，拖动，释放。\n//mytitlebar.cpp // 以下通过 mousePressEvent、mouseMoveEvent、mouseReleaseEvent 三个事件实现了鼠标拖动标题栏移动窗口的效果; void MyTitleBar::mousePressEvent(QMouseEvent *event) { if (m_buttonType == MIN_MAX_BUTTON) { // 在窗口最大化时禁止拖动窗口; if (m_pButtonMax-\u0026gt;isVisible()) { m_isPressed = true; m_startMovePos = event-\u0026gt;globalPos(); } } else { m_isPressed = true; m_startMovePos = event-\u0026gt;globalPos(); } return QWidget::mousePressEvent(event); } void MyTitleBar::mouseMoveEvent(QMouseEvent *event) { if (m_isPressed \u0026amp;\u0026amp; m_isMoveParentWindow) { QPoint movePoint = event-\u0026gt;globalPos() - m_startMovePos; QPoint widgetPos = this-\u0026gt;parentWidget()-\u0026gt;pos() + movePoint; m_startMovePos = event-\u0026gt;globalPos(); this-\u0026gt;parentWidget()-\u0026gt;move(widgetPos.x(), widgetPos.y()); } return QWidget::mouseMoveEvent(event); } void MyTitleBar::mouseReleaseEvent(QMouseEvent *event) { m_isPressed = false; return QWidget::mouseReleaseEvent(event); } globalPos()获取全局的坐标 event-\u0026gt;globalPos()是获取全局的坐标，全局是相对于整个屏幕而言的。还有一个函数pos()获取的是局部坐标，相对于一个widget窗口而言。\nmove()移动窗口 void move(int x, int y); void move(const QPoint \u0026amp;); 其中move的原点是父窗口的左上角，如果没有父窗口，则桌面即为父窗口。x 往右递增，y 往下递增\nmouseMoveEvent()这个函数里有一点需要注意的是，m_startMovePos = event-\u0026gt;globalPos()这条语句。每次移动窗口之前，先把鼠标移动后的位置记录下来，作为下一次移动的起点。\n设置最小化，关闭 //mytitlebar.cpp // 信号槽的绑定; void MyTitleBar::initConnections() { connect(m_pButtonMin, SIGNAL(clicked()), this, SLOT(onButtonMinClicked())); connect(m_pButtonClose, SIGNAL(clicked()), this, SLOT(onButtonCloseClicked())); } void MyTitleBar::onButtonMinClicked() { emit signalButtonMinClicked(); } void MyTitleBar::onButtonCloseClicked() { emit signalButtonCloseClicked(); } 标题栏是在basewindow中 new 出来的，mytitlebar类只负责发送信号，真正处理信号的是在basewindow类中。\n//basewindow.cpp void BaseWindow::initTitleBar() { createMyTitle(this); m_titleBar-\u0026gt;move(0, 0); connect(m_titleBar, SIGNAL(signalButtonMinClicked()), this, SLOT(onButtonMinClicked())); connect(m_titleBar, SIGNAL(signalButtonCloseClicked()), this, SLOT(onButtonCloseClicked())); } void BaseWindow::onButtonMinClicked() { if (Qt::Tool == (windowFlags() \u0026amp; Qt::Tool)) { hide(); } else { showMinimized(); } } void BaseWindow::onButtonCloseClicked() { close(); } 在初始化标题栏时，就把点击信号与相关的槽函数绑定。当有最小化点击信号发生时，就会调用最小化操作。\n和窗口相关的几个函数 showMinimized() //最小化 showNormal() //从最小化或者最大化窗口恢复到正常窗口 showMaximized() //最大化 show() //显示窗口，可以显示模态窗口也可以显示非模态 hide() //隐藏窗口 isVisible() //判断是否可见 isMinimized() //判断是否处于最小化状态 close() //关闭窗口 切换用户及删除用户 //loginwindow.cpp // 初始化用户登录信息; void LoginWindow::initAccountList() { // 设置代理; m_Accountlist = new QListWidget(this); ui-\u0026gt;accountComboBox-\u0026gt;setModel(m_Accountlist-\u0026gt;model()); ui-\u0026gt;accountComboBox-\u0026gt;setView(m_Accountlist); for (int i = 0; i \u0026lt; 3; i++) { AccountItem *account_item = new AccountItem(); account_item-\u0026gt;setAccountInfo(i, QStringLiteral(\u0026#34;Dominic%1号\u0026#34;).arg(i), QString(\u0026#34;:/Resources/LoginWindow/headImage/head_%1.png\u0026#34;).arg(i)); connect(account_item, SIGNAL(signalShowAccountInfo(int, QString)), this, SLOT(onShowAccountInfo(int, QString))); connect(account_item, SIGNAL(signalRemoveAccount(int)), this, SLOT(onRemoveAccount(int))); QListWidgetItem *list_item = new QListWidgetItem(m_Accountlist); m_Accountlist-\u0026gt;setItemWidget(list_item, account_item); } } //将选项文本显示在 QComboBox 当中 void LoginWindow::onShowAccountInfo(int index, QString accountName) { ui-\u0026gt;accountComboBox-\u0026gt;setEditText(accountName); ui-\u0026gt;accountComboBox-\u0026gt;hidePopup(); // 更换用户头像; QString fileName = QString(\u0026#34;:/Resources/LoginWindow/headImage/head_%1.png\u0026#34;).arg(index); ui-\u0026gt;userHead-\u0026gt;setPixmap(QPixmap(fileName).scaled(ui-\u0026gt;userHead-\u0026gt;width(), ui-\u0026gt;userHead-\u0026gt;height())); } // 移除当前登录列表中某一项; void LoginWindow::onRemoveAccount(int index) { for (int row = 0; row \u0026lt; m_Accountlist-\u0026gt;count(); row++) { AccountItem* itemWidget = (AccountItem*)m_Accountlist-\u0026gt;itemWidget(m_Accountlist-\u0026gt;item(row)); if (itemWidget != NULL \u0026amp;\u0026amp; itemWidget-\u0026gt;getItemWidgetIndex() == index) { m_Accountlist-\u0026gt;takeItem(row); itemWidget-\u0026gt;deleteLater(); } } } 在initAccountList()中，初始化好了三个账户信息，当接收到显示用户信息的信号signalShowAccountInfo后，就会调用onShowAccountInfo槽函数显示用户信息。在这个函数中，将下拉框的内容设置成切换后的用户名，然后隐藏下拉框hidPopup。更改头像。\n当接收到删除信号时，调用onRemoveAccount槽函数，删除指定的用户信息。\nhidPopup()隐藏下拉框 文章开头的效果图是隐藏下拉框的效果，每次切换用户下拉框隐藏，我们再来看一下不隐藏什么效果就容易理解了。 \u003c!DOCTYPE html\u003e Responsive Image takeItem()删除部件 QListWidgetItem *QListWidget::takeItem(int row) 从下拉菜单中选择一行部件删除。\ndeleteLater()稍后删除对象 deletelater的原理是 QObject::deleteLater()并没有将对象立即销毁，而是向主消息循环发送了一个event，下一次主消息循环收到这个event之后才会销毁对象。\n切换登录状态 //loginwindow.cpp // 选择了新的用户登录状态; void LoginWindow::onLoginStateClicked() { m_loginStateMemu = new QMenu(); QAction *pActionOnline = m_loginStateMemu-\u0026gt;addAction(QIcon(\u0026#34;:/Resources/LoginWindow/LoginState/state_online.png\u0026#34;), QStringLiteral(\u0026#34;我在线上\u0026#34;)); QAction *pActionActive = m_loginStateMemu-\u0026gt;addAction(QIcon(\u0026#34;:/Resources/LoginWindow/LoginState/state_Qme.png\u0026#34;), QStringLiteral(\u0026#34;Q 我吧\u0026#34;)); m_loginStateMemu-\u0026gt;addSeparator(); QAction *pActionAway = m_loginStateMemu-\u0026gt;addAction(QIcon(\u0026#34;:/Resources/LoginWindow/LoginState/state_away.png\u0026#34;), QStringLiteral(\u0026#34;离开\u0026#34;)); QAction *pActionBusy = m_loginStateMemu-\u0026gt;addAction(QIcon(\u0026#34;:/Resources/LoginWindow/LoginState/state_busy.png\u0026#34;), QStringLiteral(\u0026#34;忙碌\u0026#34;)); QAction *pActionNoDisturb = m_loginStateMemu-\u0026gt;addAction(QIcon(\u0026#34;:/Resources/LoginWindow/LoginState/state_notdisturb.png\u0026#34;), QStringLiteral(\u0026#34;请勿打扰\u0026#34;)); m_loginStateMemu-\u0026gt;addSeparator(); QAction *pActionHide = m_loginStateMemu-\u0026gt;addAction(QIcon(\u0026#34;:/Resources/LoginWindow/LoginState/state_hide.png\u0026#34;), QStringLiteral(\u0026#34;隐身\u0026#34;)); // 设置状态值; pActionOnline-\u0026gt;setData(ONLINE); pActionActive-\u0026gt;setData(ACTIVE); pActionAway-\u0026gt;setData(AWAY); pActionBusy-\u0026gt;setData(BUSY); pActionNoDisturb-\u0026gt;setData(NOT_DISTURB); pActionHide-\u0026gt;setData(HIDE); connect(m_loginStateMemu, SIGNAL(triggered(QAction *)), this, SLOT(onMenuClicked(QAction*))); QPoint pos = ui-\u0026gt;loginState-\u0026gt;mapToGlobal(QPoint(0, 0)) + QPoint(0, 20); m_loginStateMemu-\u0026gt;exec(pos); } // 用户状态菜单点击; void LoginWindow::onMenuClicked(QAction * action) { ui-\u0026gt;loginState-\u0026gt;setIcon(action-\u0026gt;icon()); // 获取状态值; m_loginState = (LoginState)action-\u0026gt;data().toInt(); qDebug() \u0026lt;\u0026lt; \u0026#34;onMenuClicked\u0026#34; \u0026lt;\u0026lt; m_loginState; } 在接收到点击状态按钮信号时，调用onLoginStateClicked槽函数，改变用户登录状态。切换的下拉菜单用的是QMenu。\naddSeparator()添加分割线 Q 我吧和离开状态之间的分割线。 \u003c!DOCTYPE html\u003e Responsive Image mapToGlobal()映射成全局坐标 弹出登录状态菜单m_loginStateMemu是我们自己 new 出来的，默认显示是从左上角开始显示，这样当然不行。\n\u003c!DOCTYPE html\u003e Responsive Image mapToGlobal()的作用就是将控件的坐标映射成全局坐标。代码里的意思就是将loginState控件里面的坐标用全局坐标表示。然后再向下偏移20个单位。再把得到的全局坐标作为m_loginStateMemu显示起始坐标。\n下图是未偏移的结果， \u003c!DOCTYPE html\u003e Responsive Image 向下偏移20个单位的效果，因为我们mapToGlobal(QPoint(0, 0))的参数是(0,0)为起点。如果我们mapToGlobal(QPoint(0, 20))的参数是(0,20)，就不用再加上偏移了。 \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E4%BA%A4%E4%BA%92%E5%93%8D%E5%BA%94/","summary":"\u003ch2 id=\"效果预览\"\u003e效果预览\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820152215.gif\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820152215.gif\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820152316.gif\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820152316.gif\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"Qt 模仿登录界面-交互响应"},{"content":"框架类图 \u003c!DOCTYPE html\u003e Responsive Image 效果预览 \u003c!DOCTYPE html\u003e Responsive Image 完整项目及资源文件请在Github查看。\n页面布局 \u003c!DOCTYPE html\u003e Responsive Image 初始化标题栏 // 初始化标题栏; void LoginWindow::initMyTitle() { // 因为这里有控件层叠了，所以要注意控件 raise() 方法的调用顺序; m_titleBar-\u0026gt;move(0, 0); m_titleBar-\u0026gt;raise(); m_titleBar-\u0026gt;setBackgroundColor(100, 0, 0, true); m_titleBar-\u0026gt;setButtonType(MIN_BUTTON); m_titleBar-\u0026gt;setTitleWidth(this-\u0026gt;width()); // 这里需要设置成 false，不允许通过标题栏拖动来移动窗口位置，否则会造成窗口位置错误; m_titleBar-\u0026gt;setMoveParentWindowFlag(false); ui-\u0026gt;pButtonArrow-\u0026gt;raise(); } raise()将控件置于顶层 程序在打开后一般都在所有窗体的顶层，打开其他程序后之前的程序就会被放到下一层，在这里，当设置完my_titleBar后对其他控件操作就会把my_titleBar控件覆盖。所有要用raise()方法将其置于顶层。\n初始化窗口 // 初始化窗口; void LoginWindow::initWindow() { //背景 GIG 图; QLabel* pBack = new QLabel(this); QMovie *movie = new QMovie(); movie-\u0026gt;setFileName(\u0026#34;:/Resources/LoginWindow/back.gif\u0026#34;); pBack-\u0026gt;setMovie(movie); movie-\u0026gt;start(); pBack-\u0026gt;move(0, 0); //文本框内提示 ui-\u0026gt;accountComboBox-\u0026gt;setEditable(true); QLineEdit* lineEdit = ui-\u0026gt;accountComboBox-\u0026gt;lineEdit(); lineEdit-\u0026gt;setPlaceholderText(QStringLiteral(\u0026#34;QQ 号码/手机/邮箱\u0026#34;)); QRegExp regExp(\u0026#34;[A-Za-z0-9_]{6,30}\u0026#34;); //正则表达式限制用户名输入不能输入汉字 lineEdit-\u0026gt;setValidator(new QRegExpValidator(regExp,this)); ui-\u0026gt;passwordEdit-\u0026gt;setPlaceholderText(QStringLiteral(\u0026#34;密码\u0026#34;)); //密码框中的小键盘按钮; m_keyboardButton = new QPushButton(); m_keyboardButton-\u0026gt;setObjectName(\u0026#34;pButtonKeyboard\u0026#34;); m_keyboardButton-\u0026gt;setFixedSize(QSize(16, 16)); m_keyboardButton-\u0026gt;setCursor(QCursor(Qt::PointingHandCursor));//鼠标放上去变成手形 QHBoxLayout* passwordEditLayout = new QHBoxLayout(); passwordEditLayout-\u0026gt;addStretch(); passwordEditLayout-\u0026gt;addWidget(m_keyboardButton); passwordEditLayout-\u0026gt;setSpacing(0); passwordEditLayout-\u0026gt;setContentsMargins(0, 0, 8, 0); ui-\u0026gt;passwordEdit-\u0026gt;setLayout(passwordEditLayout); //设置密码达到最长时最后一个字符离小键盘图标的距离（12） ui-\u0026gt;passwordEdit-\u0026gt;setTextMargins(0, 0, m_keyboardButton-\u0026gt;width() + 12, 0); //设置头像以及状态图标 ui-\u0026gt;userHead-\u0026gt;setPixmap(QPixmap(\u0026#34;:/Resources/LoginWindow/HeadImage.png\u0026#34;)); ui-\u0026gt;loginState-\u0026gt;setIcon(QIcon(\u0026#34;:/Resources/LoginWindow/LoginState/state_online.png\u0026#34;)); ui-\u0026gt;loginState-\u0026gt;setIconSize(QSize(13, 13)); } lineEdit-\u0026gt;setPlaceholderText QStringLiteral:如果该 QString 不会修改的话，那使用 QStringLiteral\nsetPlaceholderText()设置文本提示 该方法可以设置文本框中的默认文字提示，如图片中的 QQ 号码/手机/邮箱。\nsetCursor()设置鼠标形态 共有以下 19 种鼠标形态：\n\u003c!DOCTYPE html\u003e Responsive Image 图片来自这里\naddStretch()布局加入弹簧 QHBoxLayout* passwordEditLayout = new QHBoxLayout(); passwordEditLayout-\u0026gt;addStretch(); passwordEditLayout-\u0026gt;addWidget(m_keyboardButton); addStretch()用来在布局中平分布局，他就是个弹簧的作用。如果不加参数，就是等于加个弹簧，会把小键盘图标挤到边上。如图：\n\u003c!DOCTYPE html\u003e Responsive Image 如果将代码改一下：\nQHBoxLayout* passwordEditLayout = new QHBoxLayout(); passwordEditLayout-\u0026gt;addStretch(1); passwordEditLayout-\u0026gt;addWidget(m_keyboardButton); passwordEditLayout-\u0026gt;addStretch(1); 意思就是将除了小键盘图标以外的空间分成两份，那么刚好小键盘图标就是在中间位置，就像两遍各防止了一个弹簧。效果如下：\n\u003c!DOCTYPE html\u003e Responsive Image setSpacing()设置空间之间上下距离，还有一个容易混淆的设置setMargin()表示设置空间与窗口边缘的左右距离。\nsetContentsMargins设置左侧、顶部、右侧和底部边距，以便在布局周围使用。\n\u003c!DOCTYPE html\u003e Responsive Image 现在我们设置的是setContentsMargins(0, 0, 8, 0)，现在我们设置大一点看看效果。\n\u003c!DOCTYPE html\u003e Responsive Image QLineEdit.setTextMargins(left=,top=,right=,bottom=)设置文本边距，这里主要为了设置密码输入过长时，最后一个字符距离小键盘图标有一定间隙。\n初始化用户登录信息 //accountitem.cpp void LoginWindow::initAccountList() { for (int i = 0; i \u0026lt; 3; i++) { AccountItem *account_item = new AccountItem(); account_item-\u0026gt;setAccountInfo(i, QStringLiteral(\u0026#34;Dominic_%1号\u0026#34;).arg(i), QString(\u0026#34;:/Resources/LoginWindow/headImage/head_%1.png\u0026#34;).arg(i)); QListWidgetItem *list_item = new QListWidgetItem(m_Accountlist); m_Accountlist-\u0026gt;setItemWidget(list_item, account_item); } } ","permalink":"https://lifeislife.cn/posts/qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80%E5%8F%8A%E6%A0%B7%E5%BC%8F/","summary":"\u003ch2 id=\"框架类图\"\u003e框架类图\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827120419.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827120419.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003ch2 id=\"效果预览\"\u003e效果预览\u003c/h2\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210818130510.gif\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210818130510.gif\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n完整项目及资源文件请在\u003ca href=\"https://github.com/Dunky-Z/learning-qt/tree/main/Demo/login\"\u003eGithub\u003c/a\u003e查看。\u003c/p\u003e","title":"Qt 模仿登录界面-窗口布局及样式"},{"content":"Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。\n进程间通信概述 管道 在学 Linux 命令时就有管道在这个概念，比如下面这个命令\nps -ef | -grep root | xargs kill -9 将上一个命令的输出作为下一个命令的输入，数据只能向一个方向流动；双方需要互相通信时，需要建立起两个管道。\n管道有两种类型：匿名管道和命名管道。上面提到的命令中|表示的管道即匿名管道 pipe。用完即销毁，自动创建，自动销毁。\n使用mkfifo显示创建的是命名管道 fifo，\nmkfifo hello hello即是管道名称，类型为p，就是pipe，接下来就可以在管道里写入东西，\n# echo \u0026#34;hello world\u0026#34; \u0026gt; hello 光写入还不行，只有有另一个进程读取了内容才完成一次信息交换，才完成一次通信，\n# cat \u0026lt; hello hello world 这种方式通信效率低，无法频繁通信。\n消息队列 类似于日常沟通使用的邮件，有一定格式，有个收件列表，列表上的用户都可以反复在原邮件基础上回复，达到频繁交流的目的。这种模型就是消息队列模型。\n共享内存 共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。\n每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存空间映射到不同的物理内存中去。这个进程访问 A 地址和另一个进程访问 A 地址，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。\n但是，咱们是不是可以变通一下，拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。\n使用shmget函数创建一个共享内存，\n//key_t key: 唯一定位一个共享内存对象 //size_t size: 共享内存大小 //int flag: 如果是 IPC_CREAT 表示创建新的共享内存空间 int shmget(key_t key, size_t size, int flag); 创建完毕之后，我们可以通过 ipcs 命令查看这个共享内存。\n#ipcs ­­--shmems ------ Shared Memory Segments ------ ­­­­­­­­ key shmid owner perms bytes nattch status 0x00000000 19398656 marc 600 1048576 2 dest 进程通过shmat，就是attach的意思，将内存加载到自己虚拟地址空间某个位置。\n//int shm_id: //const void *addr: 加载的地址，通常设为 NULL，让内核选一个合适地址 //int flag: void *shmat(int shm_id, const void *addr, int flag); 如果共享内存使用完毕，可以通过 shmdt 解除绑定，然后通过 shmctl，将 cmd 设置为 IPC_RMID，从而删除这个共享内存对象。\nint shmdt(void *addr); int shmctl(int shm_id, int cmd, struct shmid_ds *buf); 共享内存的最大不足之处在于，由于多个进程对同一块内存区具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。\n信号量 如果两个进程同时向一个共享内存读写数据，很可能就会导致冲突。所以需要有一种保护机制，使得同一个共享资源同时只能被一个进程访问。在进程间通信机制中，信号量（Semaphore）就是用来实现进程间互斥与同步的。它其实是个计数器，只不过不是用来记录进程间通信数据的。\n我们可以将信号量初始化为一个数值，来代表某种资源的总体数量。对于信号量来讲，会定义两种原子操作，一个是P 操作，我们称为申请资源操作。这个操作会申请将信号量的数值减去 N，表示这些数量被他申请使用了，其他人不能用了。另一个是V操作，我们称为归还资源操作，这个操作会申请将信号量加上 M，表示这些数量已经还给信号量了，其他人可以使用了。\n所谓原子操作（Atom Operation）就是不可被中断的一个或一系列操作。\n使用semget创建信号量，第一个参数表示唯一标识，第二个参数表示可以创建多少个信号量。\nint semget(key_t key, int num_sems, int sem_flags); 接下来，我们需要初始化信号量的总的资源数量。通过semctl 函数，第一个参数 semid是这个信号量组的id，第二个参数 semnum 才是在这个信号量组中某个信号量的id，第三个参数是命令，如果是初始化，则用 SETVAL，第四个参数是一个 union。如果初始化，应该用里面的val设置资源总量。\nint semctl(int semid, int semnum, int cmd, union semun args); union semun { int val; struct semid_ds *buf; unsigned short int *array; struct seminfo *__buf; }; 无论是 P 操作还是 V 操作，我们统一用 semop 函数。第一个参数还是信号量组的 id，一次可以操作多个信号量。第三个参数 numops 就是有多少个操作，第二个参数将这些操作放在一个数组中。\n数组的每一项是一个 struct sembuf，里面的第一个成员是这个操作的对象是哪个信号量。第二个成员就是要对这个信号量做多少改变。如果 sem_op \u0026lt; 0，就请求 sem_op 的绝对值的资源。如果相应的资源数可以满足请求，则将该信号量的值减去 sem_op 的绝对值，函数成功返回。\n当相应的资源数不能满足请求时，就要看sem_flg 了。如果把 sem_flg 设置为IPC_NOWAIT，也就是没有资源也不等待，则 semop 函数出错返回 EAGAIN。如果 sem_flg 没有指定IPC_NOWAIT，则进程挂起，直到当相应的资源数可以满足请求。若 sem_op \u0026gt; 0，表示进程归还相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则唤醒它们。\nint semop(int semid, struct sembuf semoparray[], size_t numops); struct sembuf { short sem_num; // 信号量组中对应的序号，0～sem_nums-1 short sem_op; // 信号量值在一次操作中的改变量 short sem_flg; // IPC_NOWAIT, SEM_UNDO } 信号 以上提到的通信方式，都是常规状态下的工作模式，而信号一般是由错误产生的。\n信号没有特别复杂的数据结构，就是用一个代号一样的数字。Linux 提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。\n","permalink":"https://lifeislife.cn/posts/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","summary":"\u003cp\u003eLinux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为\u003cstrong\u003e进程间通信（IPC，InterProcess Communication）\u003c/strong\u003e。\u003c/p\u003e","title":"Linux 操作系统-进程间通信"},{"content":"Commands rename [options] \u0026#34;s/oldname/newname/\u0026#34; file 格式就很容易看出来怎么用的，就是/不能丢。\n-v 将重命名的内容都打印到标准输出，v 可以看成 verbose -n 测试会重命名的内容，将结果都打印，但是并不真正执行重命名的过程 -f force 会覆盖本地已经存在的文件 -h -m -V 分别为帮助，帮助，版本 -e 比较复杂，可以通过该选项，写一些脚本来做一些复杂的事情 Examples 替换文件名中的特定字段 rename \u0026#34;s/AA/aa/\u0026#34; * # 把文件名中的AA替换成aa 修改文件后缀 rename \u0026#34;s/.html/.php/\u0026#34; * # 把.html 后缀的改成 .php后缀 rename \u0026#34;s/.png/.jpg/\u0026#34; * # 将 png 改为 jpg 添加后缀 rename \u0026#34;s/$/.txt/\u0026#34; * # 把所有的文件名都以txt结尾 $正则表达式中表示结尾。\n保留部分文件名 假如需要在批量修改的时候保留部分文件名，可以使用引用\\1 ，比如有下面格式的文件，只想保留日期部分。\nScreenshot from 2019-01-02 15-56-49.jpg rename -n \u0026#34;s/Screenshot from ([0-9\\\\- ]+).jpg/\\1.jpg/\u0026#34; * 将() 匹配的内容取出来放到替换部分。\n","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-rename%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/","summary":"\u003ch2 id=\"commands\"\u003eCommands\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erename [options] \u0026#34;s/oldname/newname/\u0026#34; file\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e格式就很容易看出来怎么用的，就是\u003ccode\u003e/\u003c/code\u003e不能丢。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-v 将重命名的内容都打印到标准输出，v 可以看成 verbose\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-n 测试会重命名的内容，将结果都打印，但是并不真正执行重命名的过程\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-f force 会覆盖本地已经存在的文件\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-h -m -V 分别为帮助，帮助，版本\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-e 比较复杂，可以通过该选项，写一些脚本来做一些复杂的事情\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"examples\"\u003eExamples\u003c/h2\u003e\n\u003ch3 id=\"替换文件名中的特定字段\"\u003e替换文件名中的特定字段\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erename \u0026#34;s/AA/aa/\u0026#34; *  # 把文件名中的AA替换成aa\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"修改文件后缀\"\u003e修改文件后缀\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erename \u0026#34;s/.html/.php/\u0026#34; *     # 把.html 后缀的改成 .php后缀\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erename \u0026#34;s/.png/.jpg/\u0026#34; *      # 将 png 改为 jpg\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"添加后缀\"\u003e添加后缀\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erename \u0026#34;s/$/.txt/\u0026#34; *     # 把所有的文件名都以txt结尾\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003e$\u003c/code\u003e正则表达式中表示结尾。\u003c/p\u003e","title":"每天学命令-rename 批量重命名"},{"content":"这个命令应该是我们平时用的最多的命令之一了，应该早就拿出来讲一下的。但是平时用的太多，总感觉自己都会用了，但是仔细看了所有命令，还是有一些比较实用但是没记住的命令。\napt的全称是Advanced Packaging Tool是 Linux 系统下的一款安装包管理工具。APT 可以自动下载、配置和安装二进制或源代码格式软件包，简化了 Unix 系统上管理软件的过程。\nAPT 主要由以下几个命令组成：\napt-get apt-cache apt-file Commands 搜索软件包 apt search python3 安装软件包 apt install python3 更新源 sudo apt install update 更新软件 执行完 update 命令后，就可以使用 apt upgrade 来升级软件包了。执行命令后系统会提示有几个软件需要升级。在得到你的同意后，系统即开始自动下载安装软件包。\nsudo apt install upgrade 卸载软件 apt remove python3 # 移除软件包，但是保留配置文件 apt purge python3 #移除软件包并移除配置 apt autoremove # 移除孤立的并不被依赖的软件包 列出软件清单 apt list ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-apt%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/","summary":"\u003cp\u003e这个命令应该是我们平时用的最多的命令之一了，应该早就拿出来讲一下的。但是平时用的太多，总感觉自己都会用了，但是仔细看了所有命令，还是有一些比较实用但是没记住的命令。\u003c/p\u003e","title":"每天学命令-apt 安装卸载软件"},{"content":"QtCreator➜新建文件或项目➜Qt➜Qt Resource File\n\u003c!DOCTYPE html\u003e Responsive Image 点击Choose，设置资源文件名和路径。资源文件是一系列文件的集合，比如我要建立一个图片的资源文件，我可以设置img为资源文件名，将来所有图片类资源，都放到这个资源文件里，加入还有音频类的文件，我可以新建一个audio的资源文件，以后所有音频类的文件都放到这个资源文件下。\n而不是我想要添加的文件名。\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 右侧编辑器下方有个Add Prefix(添加前缀)，我们首先要添加文件前缀，前缀就是存放文件的文件夹名，然后添加需要的文件。添加完以后看效果就知道啥意思了。\n\u003c!DOCTYPE html\u003e Responsive Image 这么做带来的一个问题是，如果以后我们要更改文件名，比如将 xbl.png 改成 xiabanle.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：\n这样，我们可以直接使用:/images/avatar用到这个资源，无需关心图片的真实文件名。\n","permalink":"https://lifeislife.cn/posts/qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6qtcreator/","summary":"\u003cp\u003eQtCreator➜新建文件或项目➜Qt➜Qt Resource File\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812102544.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812102544.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e\n\u003cp\u003e点击\u003ccode\u003eChoose\u003c/code\u003e，设置资源文件名和路径。资源文件是一系列文件的集合，比如我要建立一个图片的资源文件，我可以设置\u003ccode\u003eimg\u003c/code\u003e为资源文件名，将来所有图片类资源，都放到这个资源文件里，加入还有音频类的文件，我可以新建一个\u003ccode\u003eaudio\u003c/code\u003e的资源文件，以后所有音频类的文件都放到这个资源文件下。\u003c/p\u003e","title":"Qt 添加资源文件（QtCreator）"},{"content":"对于在前台运行的程序，我们可以用Ctrl+C来终止运行，但是在后台的程序就必须用kill命令来终止了。\nCommand -l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称 -a 当处理当前进程时，不限制命令名和进程号的对应关系 -p 指定 kill 命令只打印相关进程的进程号，而不发送任何信号 -s 指定发送信号 -u 指定用户 Examples 查看所有信号 ➜ kill -l HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS 常用信号\nHUP 1 终端断线 INT 2 中断（同 Ctrl + C） QUIT 3 退出（同 Ctrl + \\） TERM 15 终止 KILL 9 强制终止 CONT 18 继续（与 STOP 相反， fg/bg 命令） STOP 19 暂停（同 Ctrl + Z） 用 ps 查找进程，然后用 kill 杀掉 ps -ef | grep \u0026#39;program\u0026#39; kill PID 无条件彻底杀死进程 kill –9 PID 杀死指定用户所有进程 kill -9 $(ps -ef | grep username) kill -u username ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-kill%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B/","summary":"\u003cp\u003e对于在前台运行的程序，我们可以用\u003ccode\u003eCtrl+C\u003c/code\u003e来终止运行，但是在后台的程序就必须用\u003ccode\u003ekill\u003c/code\u003e命令来终止了。\u003c/p\u003e\n\u003ch2 id=\"command\"\u003eCommand\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-a  当处理当前进程时，不限制命令名和进程号的对应关系\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-p  指定 kill 命令只打印相关进程的进程号，而不发送任何信号\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-s  指定发送信号\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-u  指定用户\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"examples\"\u003eExamples\u003c/h2\u003e\n\u003ch3 id=\"查看所有信号\"\u003e查看所有信号\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e➜   kill -l\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eHUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eSEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eTSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e常用信号\u003c/p\u003e","title":"每天学命令-kill 这个进程"},{"content":"关于进程间通信的概述可以查看Linux 操作系统 - 进程间通信，代码同步在这里。\n本文通过实例介绍通过共享内存实现进程间通信。\n简介 信号就像实际生产过程中的应急预案，发生了某个异常就会启动特定的应急预案，为了响应各类异常情况，所以就定义了很多个信号，信号的名称是在头文件signal.h中定义的，信号都以SIG开头，常用的信号并不多，常用的信号如下：\nSIGALRM #时钟定时信号, 计算的是实际的时间或时钟时间 SIGHUP #终端的挂断或进程死亡 SIGINT #来自键盘的中断信号 SIGKILL #用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。 SIGPIPE #管道破裂 SIGTERM #程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理 SIGUSR1,SIGUSR2 #留给用户使用 实例 #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void signalHandler(int sig) { printf(\u0026#34;\\nOps! - I got signal %d\\n\u0026#34;, sig); // 恢复终端中断信号 SIGINT 的默认行为 (void)signal(SIGINT, SIG_DFL); } int main() { // 改变终端中断信号 SIGINT 的默认行为，使之执行 ouch 函数 // 而不是终止程序的执行 (void)signal(SIGINT, signalHandler); while (1) { printf(\u0026#34;Hello World!\\n\u0026#34;); sleep(1); } return 0; } 我们可以用signal()函数处理指定的信号，主要通过忽略和恢复其默认行为来工作。signal() 函数的原型如下：\nvoid (*signal(int sig, void (*func)(int)))(int); 这是一个相当复杂的声明，耐心点看可以知道 signal 是一个带有sig和func两个参数的函数，func是一个类型为void (*)(int)的函数指针。该函数返回一个与func相同类型的指针，指向先前指定信号处理函数的函数指针。准备捕获的信号的参数由sig给出，接收到的指定信号后要调用的函数由参数func给出。其实这个函数的使用是相当简单的，通过下面的例子就可以知道。注意信号处理函数的原型必须为void func（int），或者是下面的特殊值：\nSIG_IGN : 忽略信号 SIG_DFL : 恢复信号的默认行为 我们程序的目的是想要捕获键盘输入Ctrl+C，这个中断。通过表里可以查到，我们使用SIGINT这个信号，当我们的程序出现SIGINT信号时，让程序接下来干啥呢？正常情况下，我们的Ctrl+C会中断当前运行的程序，但是现在我们做了一些更改，更改的内容在我们自己编写的signalHandler中。我们让程序输出一行字符串加上信号值。然后再把信号的行为恢复原样。此时我们运行程序可以得到如下\n\u003c!DOCTYPE html\u003e Responsive Image 在我们第一输入Ctrl+C时，程序没有中断，而是调用了signalHanlder函数，因为我们更改了信号的行为。但是第二次输入Ctrl+C时，程序中断了。\n","permalink":"https://lifeislife.cn/posts/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc%E4%B9%8B%E4%BF%A1%E5%8F%B7signal/","summary":"\u003cp\u003e关于进程间通信的概述可以查看\u003ca href=\"https://dunky-z.github.io/2021/08/10/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/\"\u003eLinux 操作系统 - 进程间通信\u003c/a\u003e，\u003ca href=\"https://github.com/Dunky-Z/learning-linux/tree/main/IPC/SharedMemory\"\u003e代码同步在这里\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e本文通过实例介绍通过共享内存实现进程间通信。\u003c/p\u003e\n\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e信号就像实际生产过程中的应急预案，发生了某个异常就会启动特定的应急预案，为了响应各类异常情况，所以就定义了很多个信号，信号的名称是在头文件\u003ccode\u003esignal.h\u003c/code\u003e中定义的，信号都以\u003ccode\u003eSIG\u003c/code\u003e开头，常用的信号并不多，常用的信号如下：\u003c/p\u003e","title":"进程间通信（IPC）之信号（Signal）"},{"content":"关于进程间通信的概述可以查看Linux 操作系统 - 进程间通信，代码同步在这里。\n本文通过实例介绍通过共享内存实现进程间通信。\nshmget(得到一个共享内存标识符或创建一个共享内存对象) 我们可以通过shmget函数创建或打开共享内存，通过函数签名\n//key_t key: 唯一定位一个共享内存对象 //size_t size: 共享内存大小 //int flag: 如果是 IPC_CREAT 表示创建新的共享内存空间 int shmget(key_t key, size_t size, int flag); 第一个参数是共享内存的唯一标识，是需要我们指定的。那么如何指定key呢？如何保证唯一性呢？我们可以指定一个文件，ftok会根据这个文件的 inode，生成一个近乎唯一的 key。只要在这个消息队列的生命周期内，这个文件不要被删除就可以了。只要不删除，无论什么时刻，再调用 ftok，也会得到同样的key。 第二个参数是申请的空间大小，我们就申请 1024B。 第三个参数是权限标识，IPC_CREAT表示创建共享内存，0644表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。 shmat(把共享内存区对象映射到调用进程的地址空间) 第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。它的签名如下：\nvoid *shmat(int shm_id, const void *shm_addr, int shmflg); 第一个参数就是上文产生的唯一标识。 第二个参数，shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。 第三个参数，shm_flg是一组标志位，通常为 0。 调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1. (void *) - 1把-1转换为指针0xFFFFFFFF，有时也会用到(void*)0，表示一个空指针。\nshmdt(断开共享内存连接) 与 shmat 函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存\n函数签名如下：\nint shmdt(const void *shmaddr) 参数一shmaddr为连接共享内存的起始地址。 需要注意的是，本函数调用并不删除所指定的共享内存区，而只是将先前用 shmat 函数连接（attach）好的共享内存脱离（detach）目前的进程。删除共享内存就需要下面的这个函数。\nshmctl(共享内存管理) 完成对共享内存的控制，包括改变状态，删除共享内存等。\n函数签名如下：\nint shmctl(int shmid, int cmd, struct shmid_ds *buf) shmid共享内存唯一标识符 cmd执行的操作，包括如下 IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中 IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内 IPC_RMID：删除这片共享内存 buf共享内存管理结构体。具体说明参见共享内存内核结构定义部分 //server.c #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int shmid; key_t shmkey; char *shmptr; shmkey = ftok(\u0026#34;./client.c\u0026#34;, 0); // 创建或打开内存共享区域 shmid = shmget(shmkey, 1024, 0666 | IPC_CREAT); if (shmid == -1) { printf(\u0026#34;shmget error!\\n\u0026#34;); exit(1); } //将共享内存映射到当前进程的地址中， //之后直接对进程中的地址 addr 操作就是对共享内存操作 shmptr = (char *)shmat(shmid, NULL, 0); if (shmptr == (void *)-1) { printf(\u0026#34;shmat error!\\n\u0026#34;); exit(1); } while (1) { // 把用户的输入存到共享内存区域中 printf(\u0026#34;input:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, shmptr); } exit(0); } //client.c #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(void) { int shmid; char *shmptr; key_t shmkey; shmkey = ftok(\u0026#34;./client.c\u0026#34;, 0); // 创建或打开内存共享区域 shmid = shmget(shmkey, 1024, 0666 | IPC_CREAT); if (shmid == -1) { printf(\u0026#34;shmget error!\\n\u0026#34;); exit(1); } //将共享内存映射到当前进程的地址中， //之后直接对进程中的地址 addr 操作就是对共享内存操作 shmptr = (char *)shmat(shmid, NULL, 0); if (shmptr == (void *)-1) { fprintf(stderr, \u0026#34;shmat error!\\n\u0026#34;); exit(1); } while (1) { // 每隔 3 秒从共享内存中取一次数据并打印到控制台 printf(\u0026#34;string:%s\\n\u0026#34;, shmptr); sleep(3); } exit(0); } 在两个终端分别运行client和server，client会每三秒在终端打印出server输入的内容。 \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 如何手动删除共享内存？ 列出所有的共享内存段：\nipcs -m ------------ 共享内存段 -------------- 键 shmid 拥有者 权限 字节 连接数 状态 0x00000000 2 dominic 600 16384 1 目标 0x00000000 753668 dominic 606 10089696 2 目标 0x00000000 622597 dominic 600 4194304 2 目标 0x00000000 753670 dominic 606 10089696 2 目标 0x00000000 688135 dominic 600 899976 2 目标 0x00000000 8 dominic 600 524288 2 目标 0x00000000 9 dominic 600 524288 2 目标 0x00000000 753674 dominic 600 7127040 2 目标 0x0000006f 720918 dominic 666 1024 0 我们发现最后一个键值为0x0000006f = 111的共享内存段，就是我们创建的共享内存段。 删除指定共享内存段：\nipcrm -m 720918 或者 ipcrm -M 0x0000006f 信号量和消息队列的操作，命令类似，只是参数不同。 查看命令：\nipcs [-m|-q|-s] -m 输出有关共享内存 (shared memory) 的信息 -q 输出有关信息队列 (message queue) 的信息 -s 输出有关“信号量”(semaphore) 的信息 删除命令\nipcrm [ -M key | -m id | -Q key | -q id | -S key | -s id ] -M用 shmkey 删除共享内存 -m用 shmid 删除共享内存 -Q用 msgkey 删除消息队列 -q用 msgid 删除消息队列 -S用 semkey 删除信号量 -s用 semid 删除信号量 超过共享内存的大小限制 共享内存的总体大小是有限制的，这个大小通过 SHMMAX 参数来定义（以字节为单位），您可以通过执行以下命令来确定 SHMMAX 的值：\ncat /proc/sys/kernel/shmmax 如果机器上创建的共享内存的总共大小超出了这个限制，在程序中使用标准错误perror可能会出现以下的信息：\nunable to attach to shared memory 1、设置 SHMMAX\nSHMMAX 的默认值是 32MB 。一般使用下列方法之一种将 SHMMAX 参数设为 2GB ： 通过直接更改 /proc 文件系统，你不需重新启动机器就可以改变 SHMMAX 的默认设置。我使用的方法是将以下命令放入 /\u0026gt;etc/rc.local 启动文件中：\necho \u0026#34;2147483648\u0026#34; \u0026gt; /proc/sys/kernel/shmmax 您还可以使用 sysctl 命令来更改 SHMMAX 的值：\nsysctl -w kernel.shmmax=2147483648 最后，通过将该内核参数插入到/etc/sysctl.conf 启动文件中，您可以使这种更改永久有效：\necho \u0026#34;kernel.shmmax=2147483648\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf 2、设置 SHMMNI\n我们现在来看 SHMMNI 参数。这个内核参数用于设置系统范围内共享内存段的最大数量。该参数的默认值是 4096 。这一数值已经足够，通常不需要更改。您可以通过执行以下命令来确定 SHMMNI 的值：\ncat /proc/sys/kernel/shmmni 3、设置 SHMALL\n最后，我们来看 SHMALL 共享内存内核参数。该参数控制着系统一次可以使用的共享内存总量（以页为单位）。简言之，该参数的值始终应该至少为：ceil(SHMMAX/PAGE_SIZE)\nSHMALL 的默认大小为 2097152 ，可以使用以下命令进行查询：\ncat /proc/sys/kernel/shmall SHMALL 的默认设置对于我们来说应该足够使用。注意：在 i386 平台上 Red Hat Linux 的 页面大小 为 4096 字节。但是，您可以使用 bigpages ，它支持配置更大的内存页面尺寸。\n多次进行 shmat 操作会出现什么问题 一个进程是可以对同一个共享内存多次 shmat 进行挂载的，物理内存是指向同一块，如果 shmaddr 为 NULL，则每次返回的线性地址空间都不同。而且指向这块共享内存的引用计数会增加。也就是进程多块线性空间会指向同一块物理地址。这样，如果之前挂载过这块共享内存的进程的线性地址没有被shmdt掉，即申请的线性地址都没有释放，就会一直消耗进程的虚拟内存空间，很有可能会最后导致进程线性空间被使用完而导致下次 shmat 或者其他操作失败。\nshmget 创建共享内存，当 key 相同时，什么情况下会出错？ 当创建一个新的共享内存区时，size 的值必须大于 0；如果是访问一个已经存在的内存共享区，则置 size 为 0。\n已经创建的共享内存的大小是可以调整的，但是已经创建的共享内存的大小只能调小，不能调大\n当多个进程都能创建共享内存的时候，如果 key 出现相同的情况，并且一个进程需要创建的共享内存的大小要比另外一个进程要创建的共享内存小，共享内存大的进程先创建共享内存，共享内存小的进程后创建共享内存，小共享内存的进程就会获取到大的共享内存进程的共享内存，并修改其共享内存的大小和内容，从而可能导致大的共享内存进程崩溃。\nftok 是否一定会产生唯一的 key 值？ ftok 原型如下：\nkey_t ftok(char * pathname, int proj_id) pathname就时你指定的文件名，proj_id是子序号。在一般的 UNIX 实现中，是将文件的索引节点号取出，前面加上子序号得到key_t的返回值。如指定文件的索引节点号为 65538，换算成 16 进制为0×010002，而你指定的proj_id值为38，换算成 16 进制为0×26，则最后的key_t返回值为0×26010002。\n","permalink":"https://lifeislife.cn/posts/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98sharedmemory/","summary":"\u003cp\u003e关于进程间通信的概述可以查看\u003ca href=\"https://dunky-z.github.io/2021/08/10/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/\"\u003eLinux 操作系统 - 进程间通信\u003c/a\u003e，\u003ca href=\"https://github.com/Dunky-Z/learning-linux/tree/main/IPC/SharedMemory\"\u003e代码同步在这里\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e本文通过实例介绍通过共享内存实现进程间通信。\u003c/p\u003e\n\u003ch2 id=\"shmget得到一个共享内存标识符或创建一个共享内存对象\"\u003eshmget(得到一个共享内存标识符或创建一个共享内存对象)\u003c/h2\u003e\n\u003cp\u003e我们可以通过\u003ccode\u003eshmget\u003c/code\u003e函数创建或打开共享内存，通过函数签名\u003c/p\u003e","title":"进程间通信（IPC）之共享内存 (SharedMemory)"},{"content":"现在我们有solution.c,solution.h两个文件，他们实现了某一个功能，自成一个模块。在其他项目中也可复用。我们就可以把它做成库文件。ar命令就可以将锁哥文件整合成一个库文件，也可以从一个库中单独提取出某一个文件。\nCommands -d 删除备存文件中的成员文件。 -m 变更成员文件在备存文件中的次序。 -p 显示备存文件中的成员文件内容。 -q 将文件附加在备存文件末端。 -r 将文件插入备存文件中。 -t 显示备存文件中所包含的文件。 -x 自备存文件中取出成员文件。 Examples 打包文件 将solution.c solution.h两个文件打包成solution.bak，并显示详细信息\n➜ ar rv solution.bak solution.c solution.h ar: 正在创建 solution.bak a - solution.c a - solution.h 显示打包文件内容 ➜ ar t solution.bak solution.c solution.h ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ar%E5%A4%9A%E6%96%87%E4%BB%B6%E5%BD%92%E6%A1%A3%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/","summary":"\u003cp\u003e现在我们有\u003ccode\u003esolution.c\u003c/code\u003e,\u003ccode\u003esolution.h\u003c/code\u003e两个文件，他们实现了某一个功能，自成一个模块。在其他项目中也可复用。我们就可以把它做成库文件。\u003ccode\u003ear\u003c/code\u003e命令就可以将锁哥文件整合成一个库文件，也可以从一个库中单独提取出某一个文件。\u003c/p\u003e","title":"每天学命令-ar 多文件归档为一个文件"},{"content":"ps命令显示的信息类似于 Windows 的任务管理器。也是参数超级多的一个命令，所以就不列参数了，需要查看时直接搜索，这里列举一下实例。\n使用实例 显示当前执行的所有程序\n➜ ~ ps -a PID TTY TIME CMD 879 tty2 00:03:43 Xorg 990 tty2 00:00:00 gnome-session-b 2653 pts/0 00:00:00 zsh 12365 pts/0 00:00:00 ps 显示所有程序\n➜ ~ ps -A PID TTY TIME CMD 1 ? 00:00:01 systemd 2 ? 00:00:00 kthreadd 3 ? 00:00:00 rcu_gp 4 ? 00:00:00 rcu_par_gp 6 ? 00:00:00 kworker/0:0H-kblockd 9 ? 00:00:00 mm_percpu_wq 10 ? 00:00:00 ksoftirqd/0 11 ? 00:00:02 rcu_sched 12 ? 00:00:00 migration/0 13 ? 00:00:00 idle_inject/0 14 ? 00:00:00 cpuhp/0 15 ? 00:00:00 kdevtmpfs . . . 显示指定用户的信息\n➜ ~ ps -u root a显示现行终端机下的所有程序，包括其他用户的程序，u以用户为主的格式来显示程序状况，x显示所有程序，不以终端机来区分 USER－运行该流程的用户。\n%CPU－进程 CPU 利用率。\n%MEM－进程驻留集大小占计算机物理内存的百分比。\nVSZ－KiB 中进程的虚拟内存大小。\nRSS－进程正在使用的物理内存的大小。\nSTAT－进程状态代码，可以是 Z（zombie），S（休眠），R（运行）..等等。\nSTART－命令启动的时间。\n➜ ~ ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.2 102084 11540 ? Ss 09:09 0:01 /sbin/init splash root 2 0.0 0.0 0 0 ? S 09:09 0:00 [kthreadd] root 3 0.0 0.0 0 0 ? I\u0026lt; 09:09 0:00 [rcu_gp] 按 CPU 资源的使用量对进程进行排序：\n➜ ~ ps aux | sort -nk 3 avahi 492 0.0 0.0 8536 3260 ? Ss 09:09 0:00 avahi-daemon: running [hanhan.local] avahi 552 0.0 0.0 8352 332 ? S 09:09 0:00 avahi-daemon: chroot helper colord 1442 0.0 0.3 255144 14408 ? Ssl 09:09 0:00 /usr/libexec/colord dominic 1068 0.0 0.0 31244 364 ? S 09:09 0:00 /usr/bin/VBoxClient --clipboard dominic 1069 0.0 0.9 163512 39088 ? Sl 09:09 0:00 /usr/bin/VBoxClient --clipboard dominic 1080 0.0 0.0 31244 364 ? S 09:09 0:00 /usr/bin/VBoxClient --seamless # 其中`sort`命令中`-n`为按数值进行排序，`-k 3` 表示以输出结果的第三列来进行排序， # 从上一个实例中看到，第三列为CPU使用率`%CPU`。 # 同理ps aux | sort -rnk 4 即按内存使用降序排序 显示前 5 名最耗 CPU 的进程\n➜ ~ ps aux --sort=-pcpu | head -5 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 2.6 0.7 51396 7644 ? Ss 02:02 0:03 /usr/lib/systemd/systemd --switched-root --system --deserialize 23 root 1249 2.6 3.0 355800 30896 tty1 Rsl+ 02:02 0:02 /usr/bin/X -background none :0 vt01 -nolisten tcp root 508 2.4 1.6 248488 16776 ? Ss 02:02 0:03 /usr/bin/python /usr/sbin/firewalld --nofor 下面的命令会显示进程 id 为 3150 的进程的所有线程\n➜ ~ ps -p 3150 -L ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E6%97%A5%E5%AD%A6%E5%91%BD%E4%BB%A4-ps%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/","summary":"\u003cp\u003e\u003ccode\u003eps\u003c/code\u003e命令显示的信息类似于 Windows 的任务管理器。也是参数超级多的一个命令，所以就不列参数了，需要查看时直接搜索，这里列举一下实例。\u003c/p\u003e\n\u003ch2 id=\"使用实例\"\u003e使用实例\u003c/h2\u003e\n\u003cp\u003e显示当前执行的所有程序\u003c/p\u003e","title":"每日学命令-ps 显示进程状态"},{"content":"在向 GitHub 推送博客时，推送失败报了这个错。也不知道是改了什么设置突然报错。SSL 的错之前遇到一次，就是刚开始配置 Git 时用的https协议，每次push都需要重新输入一次密码。改成ssl协议就 OK 了。当时把 Linux 环境的 Git 改了，但是现在的 Windows 下没改，猜测可能和这也有关，于是就把 URL 改了一下，结果还真好了。 在本地仓库的.git文件里找到config文件，打开后将url改为ssl协议，git@github.com:XXX格式的。\n将 Hexo 的配置也改了，找到仓库下的_config.yml\ndeploy: type: git repository: 改成ssl协议地址 branch: master ","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3openssl-ssl-connect-connection-was-reset-in-connection-to-github-com-443/","summary":"\u003cp\u003e在向 GitHub 推送博客时，推送失败报了这个错。也不知道是改了什么设置突然报错。SSL 的错之前遇到一次，就是刚开始配置 Git 时用的\u003ccode\u003ehttps\u003c/code\u003e协议，每次\u003ccode\u003epush\u003c/code\u003e都需要重新输入一次密码。改成\u003ccode\u003essl\u003c/code\u003e协议就 OK 了。当时把 Linux 环境的 Git 改了，但是现在的 Windows 下没改，猜测可能和这也有关，于是就把 URL 改了一下，结果还真好了。\n在本地仓库的\u003ccode\u003e.git\u003c/code\u003e文件里找到\u003ccode\u003econfig\u003c/code\u003e文件，打开后将\u003ccode\u003eurl\u003c/code\u003e改为\u003ccode\u003essl\u003c/code\u003e协议，\u003ccode\u003egit@github.com:XXX\u003c/code\u003e格式的。\u003c/p\u003e","title":"解决 OpenSSL SSL_connect: Connection was reset in connection to github.com:443"},{"content":"本篇文章所涉及代码可在此处查看\n事件以及与信号的区别 事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。\n事件和信号槽的区别\n信号是由具体对象发出，然后马上交给connect函数连接的槽进行处理，如果处理过程中产生了新的信号，将会继续执行新的信号，一直这样递归进行下去。而事件使用一个事件队列对发出的所有事件进行维护，当新的事件产生时会被加到事件队列的尾部。 在运行过程中发现，刚启动时并不会显示任何内容，只有在点击一次后，平面才会显示信息。这是因为QWidget中有一个mouseTracking属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent()才会发出。如果mouseTracking是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出mouseMoveEvent()事件。如果mouseTracking为 true，则mouseMoveEvent()直接可以被发出。知道了这一点，我们就可以在main()函数中直接设置下：\nEventLabel *label = new EventLabel; label-\u0026gt;setWindowTitle(\u0026#34;MouseEvent Demo\u0026#34;); label-\u0026gt;resize(300, 200); label-\u0026gt;setMouseTracking(true); label-\u0026gt;show(); 显示效果 \u003c!DOCTYPE html\u003e Responsive Image 事件的接受与忽略 //custombutton.h #include \u0026lt;QDebug\u0026gt; #include \u0026lt;QMouseEvent\u0026gt; #include \u0026lt;QApplication\u0026gt; #include \u0026lt;QPushButton\u0026gt; class CustomButton : public QPushButton { Q_OBJECT private: void onButtonClicked(); public: CustomButton(QWidget *parent = 0); }; //custombutton.cpp #include \u0026#34;custombutton.h\u0026#34; CustomButton::CustomButton(QWidget *parent) : QPushButton(parent) { connect(this, \u0026amp;CustomButton::clicked, this, \u0026amp;CustomButton::onButtonClicked); } void CustomButton::onButtonClicked() { qDebug() \u0026lt;\u0026lt; \u0026#34;You clicked this!\u0026#34;; } //main02.cpp #include \u0026#34;custombutton.h\u0026#34; int main(int argc, char *argv[]) { QApplication a(argc, argv); CustomButton btn; btn.setText(\u0026#34;This is a Button!\u0026#34;); btn.show(); return a.exec(); } 以上代码运行结果就是点击按钮会在控制台输出：\u0026ldquo;You clicked this!\u0026quot;。\n现在，我们在CustomButton类中再添加一个事件函数：\n//custombutton.h protected: void mousePressEvent(QMouseEvent *event); //custombutton.cpp void CustomButton::mousePressEvent(QMouseEvent *event) { if (event-\u0026gt;button() == Qt::LeftButton) { qDebug() \u0026lt;\u0026lt; \u0026#34;Left\u0026#34;; } else { QPushButton::mousePressEvent(event); } } 这时运行结果为点击按键输出\u0026quot;Left\u0026rdquo;。而没有再输出\u0026quot;You clicked this!\u0026quot;。说明我们把父类的实现覆盖了。当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！。这一定程度上说，我们的组件忽略了父类的事件。\n通过调用父类的同名函数，我们可以把 Qt 的事件传递看成链状：如果子类没有处理这个事件，就会继续向其父类传递。Qt 的事件对象有两个函数：accept()和ignore()。正如它们的名字一样，前者用来告诉 Qt，这个类的事件处理函数想要处理这个事件；后者则告诉 Qt，这个类的事件处理函数不想要处理这个事件。在事件处理函数中，可以使用isAccepted()来查询这个事件是不是已经被接收了。具体来说：如果一个事件处理函数调用了一个事件对象的accept()函数，这个事件就不会被继续传播给其父组件；如果它调用了事件的ignore()函数，Qt 会从其父组件中寻找另外的接受者。\n//custombutton01.h #include \u0026lt;QDebug\u0026gt; #include \u0026lt;QVBoxLayout\u0026gt; #include \u0026lt;QMainWindow\u0026gt; #include \u0026lt;QMouseEvent\u0026gt; #include \u0026lt;QPushButton\u0026gt; #include \u0026lt;QApplication\u0026gt; class CustomButton : public QPushButton { Q_OBJECT public: CustomButton(QWidget *parent) : QPushButton(parent) { } protected: void mousePressEvent(QMouseEvent *event) { qDebug() \u0026lt;\u0026lt; \u0026#34;CustomButton\u0026#34;; } }; class CustomButtonEx : public CustomButton { Q_OBJECT public: CustomButtonEx(QWidget *parent) : CustomButton(parent) { } protected: void mousePressEvent(QMouseEvent *event) { qDebug() \u0026lt;\u0026lt; \u0026#34;CustomButtonEx\u0026#34;; } }; class CustomWidget : public QWidget { Q_OBJECT public: CustomWidget(QWidget *parent) : QWidget(parent) { } protected: void mousePressEvent(QMouseEvent *event) { qDebug() \u0026lt;\u0026lt; \u0026#34;CustomWidget\u0026#34;; } }; class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = 0) : QMainWindow(parent) { CustomWidget *widget = new CustomWidget(this); CustomButton *cbex = new CustomButton(widget); cbex-\u0026gt;setText(tr(\u0026#34;CustomButton\u0026#34;)); CustomButtonEx *cb = new CustomButtonEx(widget); cb-\u0026gt;setText(tr(\u0026#34;CustomButtonEx\u0026#34;)); QVBoxLayout *widgetLayout = new QVBoxLayout(widget); widgetLayout-\u0026gt;addWidget(cbex); widgetLayout-\u0026gt;addWidget(cb); this-\u0026gt;setCentralWidget(widget); } protected: void mousePressEvent(QMouseEvent *event) { qDebug() \u0026lt;\u0026lt; \u0026#34;MainWindow\u0026#34;; } }; //mai03.cpp #include \u0026#34;custombutton01.h\u0026#34; int main(int argc, char *argv[]) { QApplication app(argc, argv); MainWindow win; win.show(); return app.exec(); } 这段代码在一个MainWindow中添加了一个CustomWidget，里面有两个按钮对象：CustomButton和CustomButtonEx。每一个类都重写了mousePressEvent()函数。\n\u003c!DOCTYPE html\u003e Responsive Image 运行程序点击 CustomButtonEx，结果是\nCustomButtonEx 因为我们重写了mousePressEvent()，所以调用子类自己的函数，如果在CustomButtonEx的mousePressEvent()第一行增加一句event-\u0026gt;accept()，重新运行，发现结果不变。正如我们前面所说，QEvent 默认是accept的，调用这个函数并没有什么区别。然后我们将CustomButtonEx的event-\u0026gt;accept()改成event-\u0026gt;ignore()。这次运行结果是\nCustomButtonEx CustomWidget ignore()说明我们想让事件继续传播，于是CustomButtonEx的父组件CustomWidget也收到了这个事件，所以输出了自己的结果。\n同理，CustomWidget又没有调用父类函数或者显式设置accept()或ignore()，所以事件传播就此打住。\n这里值得注意的是，CustomButtonEx的事件传播给了父组件CustomWidget，而不是它的父类CustomButton。事件的传播是在组件层次上面的，而不是依靠类继承机制。\n在一个特殊的情形下，我们必须使用accept()和ignore()函数，那就是窗口关闭的事件。对于窗口关闭QCloseEvent事件，调用accept()意味着 Qt 会停止事件的传播，窗口关闭；调用ignore()则意味着事件继续传播，即阻止窗口关闭。回到我们前面写的简单的文本编辑器。\nevent() 函数 事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）。\n如上所述，event()函数主要用于事件的分发。所以，如果你希望在事件分发之前做一些操作，就可以重写这个event()函数了。例如，我们希望在一个 QWidget 组件中监听 tab 键的按下，那么就可以继承 QWidget，并重写它的event()函数，来达到这个目的：\nbool CustomWidget::event(QEvent *e) { if (e-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(e); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } } return QWidget::event(e); } CustomWidget是一个普通的QWidget子类。我们重写了它的event()函数，这个函数有一个QEvent对象作为参数，也就是需要转发的事件对象。函数返回值是 bool 类型。如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，并且，该事件对象设置了accept()，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。注意，在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播。\n我们可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的event()函数继续转发，否则这个组件就只能处理我们定义的事件了。为了测试这一种情况，我们可以尝试下面的代码：\nbool CustomTextEdit::event(QEvent *e) { if (e-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(e); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } } return false; } CustomTextEdit是QTextEdit的一个子类。我们重写了其event()函数，却没有调用父类的同名函数。这样，我们的组件就只能处理 Tab 键，再也无法输入任何文本，也不能响应其它事件，比如鼠标点击之后也不会有光标出现。这是因为我们只处理的KeyPress类型的事件，并且如果不是KeyPress事件，则直接返回 false，鼠标事件根本不会被转发，也就没有了鼠标事件。\n事件过滤器 有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。\n通过前面的章节，我们已经知道，Qt 创建了QEvent事件对象之后，会调用QObject的event()函数处理事件的分发。显然，我们可以在event()函数中实现拦截的操作。由于event()函数是 protected 的，因此，需要继承已有类。如果组件很多，就需要重写很多个event()函数。这当然相当麻烦，更不用说重写event()函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。\nQObject有一个eventFilter()函数，用于建立事件过滤器。这个函数的签名如下：\n这个函数正如其名字显示的那样，是一个“事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。想想做化学实验时用到的过滤器，可以将杂质留到滤纸上，让过滤后的液体溜走。事件过滤器也是如此：它会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，不想让它继续转发，就返回 true，否则返回 false。事件过滤器的调用时间是目标对象（也就是参数里面的watched对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched对象以及以后所有的事件过滤器根本不会知道这么一个事件。\nclass MainWindow : public QMainWindow { public: MainWindow(); protected: bool eventFilter(QObject *obj, QEvent *event); private: QTextEdit *textEdit; }; MainWindow::MainWindow() { textEdit = new QTextEdit; setCentralWidget(textEdit); textEdit-\u0026gt;installEventFilter(this); } bool MainWindow::eventFilter(QObject *obj, QEvent *event) { if (obj == textEdit) { if (event-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(event); qDebug() \u0026lt;\u0026lt; \u0026#34;Ate key press\u0026#34; \u0026lt;\u0026lt; keyEvent-\u0026gt;key(); return true; } else { return false; } } else { // pass the event on to the parent class return QMainWindow::eventFilter(obj, event); } } MainWindow是我们定义的一个类。我们重写了它的eventFilter()函数。为了过滤特定组件上的事件，首先需要判断这个对象是不是我们感兴趣的组件，然后判断这个事件的类型。在上面的代码中，我们不想让textEdit组件处理键盘按下的事件。所以，首先我们找到这个组件，如果这个事件是键盘事件，则直接返回 true，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回 false。对于其它的组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。\neventFilter()函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用QObject::installEventFilter()函数。这个函数的签名如下：\nvoid QObject::installEventFilter ( QObject * filterObj ) 这个函数接受一个QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是QObject的一个成员函数，因此，任意QObject都可以作为事件过滤器（问题在于，如果你没有重写eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。\n我们可以向一个对象上面安装多个事件处理器，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。\n还记得我们前面的那个例子吗？我们使用event()函数处理了 Tab 键：\nbool CustomWidget::event(QEvent *e) { if (e-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(e); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } } return QWidget::event(e); } bool FilterObject::eventFilter(QObject *object, QEvent *event) { if (object == target \u0026amp;\u0026amp; event-\u0026gt;type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast\u0026lt;QKeyEvent *\u0026gt;(event); if (keyEvent-\u0026gt;key() == Qt::Key_Tab) { qDebug() \u0026lt;\u0026lt; \u0026#34;You press tab.\u0026#34;; return true; } else { return false; } } return false; } 事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，installEventFilter()函数是QObject的函数，QApplication或者QCoreApplication对象都是QObject的子类，因此，我们可以向QApplication或者QCoreApplication添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。因此，除非是不得不使用的情况，否则的话我们不应该这么做。\n注意，如果你在事件过滤器中 delete 了某个接收组件，务必将函数返回值设为 true。否则，Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃。\n事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。\n事件过滤器和安装过滤器的组件必须在同一线程。Qt 里面，对象创建之后，可以使用 moveToThread() 函数将一个对象移动到另外的线程。在这种情形下（当然，事件过滤器必须在同一线程时才能被正确安装，这是第一句话说明的），在它们分属在不同线程时，事件过滤器也是不起作用的，只用当它们重新回到同一线程（使用 moveToThread() 或者是线程自然结束）时，过滤器才能重新工作\n","permalink":"https://lifeislife.cn/posts/qt%E4%BA%8B%E4%BB%B6/","summary":"\u003cp\u003e本篇文章所涉及代码可在\u003ca href=\"https://github.com/Dunky-Z/learning-qt/tree/main/Event\"\u003e此处查看\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"事件以及与信号的区别\"\u003e事件以及与信号的区别\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e事件\u003c/strong\u003e（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。\u003c/p\u003e","title":"Qt 事件"},{"content":"看到同事要安装自己编译一天的库，本想传授一下“踩坑经验”，结果他用scp命令直接从已经安装好的电脑里复制了一份。心里一万只 XXX 在奔腾。\n早知道先学学这个命令了。\n可选参数 参数 功能 -1 强制 scp 命令使用协议 ssh1 -2 强制 scp 命令使用协议 ssh2 -4 强制 scp 命令使用协议 ssh2 -6 强制 scp 命令只使用 IPv6 寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩 -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条 -r 递归复制整个目录 -v 详细方式显示输出 -P 注意是大写的 P, port 是指定数据传输用到的端口号 使用实例 复制文件\nscp local_file rmot_usr@rmot_ip:rmot_folder scp /opt/soft/ root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-scp%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/","summary":"\u003cp\u003e看到同事要安装自己编译一天的库，本想传授一下“踩坑经验”，结果他用\u003ccode\u003escp\u003c/code\u003e命令直接从已经安装好的电脑里复制了一份。心里一万只 XXX 在奔腾。\u003c/p\u003e\n\u003cp\u003e早知道先学学这个命令了。\u003c/p\u003e","title":"每天学命令-scp 远程拷贝文件"},{"content":"grep全称global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来。这名字就怪吓人，如果熟练掌握正则表达式，配上这命令 Linux 里可以横着走了。\n这个命令参数实在太多，加上正则表达式估计一张纸不够。那就直接上实例吧。\n使用实例 在当前目录中，查找后缀带有cpp字样的文中包含test字符串的文件，并打印所在行\ngrep test *cpp grep --colorauto test *cpp # 用颜色标记 通过\u0026quot;-v\u0026quot;参数可以打印出不符合条件行的内容。\ngrep -v test *cpp 系统报警显示了时间，但是日志文件太大无法直接 cat 查看。(查询含有特定文本的文件，并拿到这些文本所在的行)。-n 或 --line-number 可以显示符合样式的那一行之前，标示出该行的列数编号。\ngrep -n \u0026#39;2019-10-24 00:01:11\u0026#39; *.log grep 静默输出，不会输出任何信息，如果命令运行成功返回 0，失败则返回非 0 值。一般用于条件测试。\ngrep -q \u0026#34;test\u0026#34; filename 在多级目录中对文本进行递归搜索\ngrep \u0026#34;text\u0026#34; . -r -n 配合管道，查找指定的进程信息\nps -ef | grep svn 查找指定的进程个数，-c计数\nps -ef | grep svn -c 常用正则表达式通配符\n通配符 功能 c* 将匹配 0 个（即空白）或多个字符 c（c 为任一字符） . 将匹配任何一个字符，且只能是一个字符 [xyz] 匹配方括号中的任意一个字符 [^xyz] 匹配除方括号中字符外的所有字符 ^ 锁定行的开头 $ 锁定行的结尾 在id.txt中找到所有以 3207 开头的数据\ngrep ^3207 id.txt ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-grep%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/","summary":"\u003cp\u003e\u003ccode\u003egrep\u003c/code\u003e全称\u003ccode\u003eglobal search regular expression(RE) and print out the line\u003c/code\u003e，全面搜索正则表达式并把行打印出来。这名字就怪吓人，如果熟练掌握正则表达式，配上这命令 Linux 里可以横着走了。\u003c/p\u003e","title":"每天学命令-grep 文本搜索"},{"content":"本篇文章所涉及代码，可在此处查看\nQt 中使用 QDialog 类实现对话框。就像主窗口一样，我们通常会设计一个类继承 QDialog。QDialog（及其子类，以及所有 Qt::Dialog 类型的类）的对于其 parent 指针都有额外的解释：\n如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。\n顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。\n对话框分为模态对话框和非模态对话框。所谓模态对话框，就是会阻塞同一应用程序中其它窗口的输入。模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。\n与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。\nQt 支持模态对话框和非模态对话框。其中，Qt 有两种级别的模态对话框：应用程序级别的模态和窗口级别的模态，默认是应用程序级别的模态。应用程序级别的模态是指，当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。窗口级别的模态是指，该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。\n消息对话框 QMessageBox 文件对话框 QFileDialog \u0026lsquo;QTextEdit\u0026rsquo; Does not name a type 需要包含头文件\n#include \u0026lt;QTextEdit\u0026gt; Qt 需要包含的头文件实在太多了。\n可能添加了头文件仍然报同样的错，没有搜索到相关的解答。\n我的做法是：\n确保在.pro文件中加入QT += widgets和CONFIG += c++11 将包含库文件语句都放到头文件.h中 ","permalink":"https://lifeislife.cn/posts/qt%E5%AF%B9%E8%AF%9D%E6%A1%86/","summary":"\u003cp\u003e本篇文章所涉及代码，可在\u003ca href=\"https://github.com/Dunky-Z/learning-qt/tree/main/Dialog\"\u003e此处查看\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eQt 中使用 QDialog 类实现对话框。就像主窗口一样，我们通常会设计一个类继承 QDialog。QDialog（及其子类，以及所有 Qt::Dialog 类型的类）的对于其 parent 指针都有额外的解释：\u003c/p\u003e","title":"Qt 对话框"},{"content":"gitignore 的作用 在使用Git版本控制时，必须要用.gitignore这个文件来告诉Git那些文件或目录不需要添加到版本控制中。通俗点说，就是不需要git push到远程仓库。\n在平时开发过程中，开发目录下会有各种格式的文件，比如 C 语言除了.c源码，还会有.o目标文件，没有后缀的可执行程序等等，假如你要进行深度学习类的开发，如图像识别，需要训练大量数据，如果这些训练数据也到跟踪管理，那push一次就可以下班回家了。\n但是我们怎么让Git知道哪些文件需要跟踪，哪些文件不需要呢，这时候.gitignore文件就起作用了。\n常用规则 简单介绍一下常用的规则，虽然后面有现成的模板，但是我们还是了解一下常用规则，能看得懂.gitignore里写了啥。也方便自己编写一些规则适应自己的工作。\n/test/ # 过滤整个test文件夹 *.o # 过滤所有.o文件 /test/hello.o # 过滤test文件夹下hello.o这个文件 !src/ # 不过滤src这个文件夹 !*.c # 不过滤.c文件 通过 gitignore 文件更新远程仓库 上面说到我们在不同环境下需要制定不同的规则，但是每次都要重新写一遍，又或者不知道制定什么样的规则，还是挺麻烦的。\n首先推荐一个.gitignore模板仓库，在平时工作学习中遇到的各种语言环境下的模板都能找到。这是广大开发人员总结的一些规则。\n最近在学习Qt，在所有模板中搜索关键字，找到了Qt.gitignore这个模板打开并复制，在自己本地仓库里新建一个.gitignore文件，将复制的内容粘贴进去。\n现在就要解决如何更新远程仓库的内容，因为我在使用.gitignore文件之前已经向远程push过了，现在需要删除不需要的文件。\ngit rm -r --cached . rm就是Linux下常用的删除命令，-r表示递归删除，--cached表示需要在本地端（工作区）保留文件，.表示所有文件。\ngit add . # 重新添加所有文件到暂存区，然后提交，推送 git commit -m \u0026#34;update\u0026#34; git push ","permalink":"https://lifeislife.cn/posts/git%E4%B8%AD%E6%B7%BB%E5%8A%A0gitignore%E5%B9%B6%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","summary":"\u003ch2 id=\"gitignore-的作用\"\u003egitignore 的作用\u003c/h2\u003e\n\u003cp\u003e在使用\u003ccode\u003eGit\u003c/code\u003e版本控制时，必须要用\u003ccode\u003e.gitignore\u003c/code\u003e这个文件来告诉\u003ccode\u003eGit\u003c/code\u003e那些文件或目录不需要添加到版本控制中。通俗点说，就是不需要\u003ccode\u003egit push\u003c/code\u003e到远程仓库。\u003c/p\u003e","title":"Git 中添加 gitignore 并更新远程仓库"},{"content":" 本文是学习【Qt 学习之路】的学习笔记，源码非原创。Github同步本文更改的代码。\n在建立 Qt 学习代码仓时，推送到远程的代码比较乱，所以用gitignore文件屏蔽了一些。相关方法在这里。\n资源文件 Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。\n使用 QtCreator 的相关方法，讲得也很清楚了，就不赘述了。\n不使用 QtCreator 添加资源文件 在使用命令行编译运行时，并不能像在 QtCreator 中一样，可以自动的生成一个.qrc文件，这就需要我们自己去编写。从原文的讲解中我们也知道，它就是一个XML描述文件，里面定义了文件位置等信息。如原文中的.qrc文件：\n\u0026lt;RCC\u0026gt; \u0026lt;qresource prefix=\u0026#34;/images\u0026#34;\u0026gt; \u0026lt;file alias=\u0026#34;doc-open\u0026#34;\u0026gt;document-open.png\u0026lt;/file\u0026gt; \u0026lt;/qresource\u0026gt; \u0026lt;/RCC\u0026gt; 其中\n\u0026lt;RCC\u0026gt; \u0026lt;qresource\u0026gt; \u0026lt;/qresource\u0026gt; \u0026lt;/RCC\u0026gt; 是固定的标记，再往中间加东西。如果学过html语言就很容易理解。其中prefix=\u0026quot;/images\u0026quot;就是自动加上前缀/images，因为图片在images目录下，每次都加这个路径太麻烦，太长。\nalias=\u0026quot;doc-open\u0026quot;意思是将document-open.png这个文件起个别名，原来的太长了。下次再用document-open.png就只需要用doc-open就行了。\n我们知道了这些，就可以编写一个自己的.qrc文件了。我也自己下载了一个打开文件的图标open.png，文件比较少，就和代码放在同一个目录下了。我们将其命名为ico.qrc，这个文件中以后都存放有关图标的资源，我们开始编写：\n\u0026lt;RCC\u0026gt; \u0026lt;qresource\u0026gt; \u0026lt;file\u0026gt;open.png\u0026lt;/file\u0026gt; \u0026lt;/qresource\u0026gt; \u0026lt;/RCC\u0026gt; 因为添加资源后需要更新.pro文件才能正常编译，所以需要在.pro中加入RESOURCES 信息，就在.pro文件最后一行加入：\nRESOURCES += ico.qrc 然后输入命令\nqmake MainWindow.pro make clean #因为之前可能make过，先清理一遍 make ./MainWindow 如果一切顺利，将会得到下面的窗口： \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image Reference https://www.devbean.net/2012/08/qt-study-road-2-action/ ","permalink":"https://lifeislife.cn/posts/qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文是学习【\u003ca href=\"https://www.devbean.net/2012/08/qt-study-road-2-catelog/\"\u003eQt 学习之路\u003c/a\u003e】的学习笔记，源码非原创。\u003ca href=\"https://github.com/Dunky-Z/learning-qt/tree/main/MainWindow\"\u003eGithub\u003c/a\u003e同步本文更改的代码。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在建立 Qt 学习代码仓时，推送到远程的代码比较乱，所以用\u003ccode\u003egitignore\u003c/code\u003e文件屏蔽了一些。相关方法在\u003ca href=\"https://dunky-z.github.io/2021/08/04/Git%E4%B8%AD%E6%B7%BB%E5%8A%A0gitignore%E5%B9%B6%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/\"\u003e这里\u003c/a\u003e。\u003c/p\u003e","title":"Qt 添加资源文件"},{"content":"cat 可以将文件的内容方便地输出到屏幕上。但是它的全称concatenate意为“连接”，连接文件也是它的重要功能之一，很多人可能都不常用。只记得输出文件内容了。\n可选参数 -n 或 --number #由 1 开始对所有输出的行数编号。 -b 或 --number-nonblank #和 -n 相似，只不过对于空白行不编号。 -s 或 --squeeze-blank #当遇到有连续两行以上的空白行，就代换为一行的空白行。 -v 或 --show-nonprinting #使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。 -E 或 --show-ends # 在每行结束处显示 $。 -T 或 --show-tabs: #将 TAB 字符显示为 ^I。 -A, --show-all #等价于 -vET。 -e #等价于\u0026#34;-vE\u0026#34;选项； -t #等价于\u0026#34;-vT\u0026#34;选项； 使用实例 将文件内容输出到屏幕\n➜ ~ cat test.txt This is firt line! This is second line! This is third line! This is fourth line! 将test.txt的内容输入到test01.txt中\n➜ ~ cat test.txt \u0026gt; test01.txt ➜ ~ cat test01.txt This is firt line! This is second line! This is third line! This is fourth line! 带行号输出\n➜ ~ cat -n test.txt 1 This is firt line! 2 This is second line! 3 This is third line! 4 This is fourth line! 将两个文件内容合并，再写入到第三个文件中\n➜ ~ cat test.txt test01.txt \u0026gt;\u0026gt; test02.txt ➜ ~ cat test02.txt This is firt line! This is second line! This is third line! This is fourth line! This is firt line! This is second line! This is third line! This is fourth line! 清空文件中的内容\n➜ ~ cat /dev/null \u0026gt; test.txt ➜ ~ cat test.txt ➜ ~ 在类 Unix 系统中，/dev/null 称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个 EOF。\nReference https://www.runoob.com/linux/linux-comm-cat.html ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-cat%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%8C%AB%E5%92%AA/","summary":"\u003cp\u003e\u003ccode\u003ecat\u003c/code\u003e 可以将文件的内容方便地输出到屏幕上。但是它的全称\u003ccode\u003econcatenate\u003c/code\u003e意为“连接”，连接文件也是它的重要功能之一，很多人可能都不常用。只记得输出文件内容了。\u003c/p\u003e","title":"每天学命令-cat 可以查看文件的小猫咪"},{"content":"在执行的程序源码开头有这么一句!#/usr/bin/env python，!#这玩意叫shebang也叫hashbang。他用来指定脚本的解释器，也就是说这个程序指定python解释器。\n再看这个错误提示，罪魁祸首就是这句命令，就是说在环境变量找不到python，通俗点说，假如我要能直接用python来跑这个程序，我在命令行直接输入python应该是可以进入python环境的，但是此时肯定不能。我们可以试试\ndominic@hanhan:~$ python Commond not found xxxxxxxxxxx 解决方案一 系统里没有python还跑个锤子，先装上再说\napt-get install python3 这时候可能就解决问题了\n解决方案二 有的人可能python早就装了，但是仍然有这个问题，但是我们在命令输入python仍然没法用，但是输入python3就可以\n那python3可以，我直接将python改成python3不就完了。没错！\n打开文件将!#/usr/bin/env python改成!#/usr/bin/env python3\n解决方案三 如果了解软链接，那我们就可以不用去改源码了，源码最好还是保持原样。\n既然找不到python这玩意，那我们给他建一个不就完了。\n他要python就是用来解释程序的，我们本地装的python3就是他需要的东西\n先找找我们的python3在哪\ndominic@hanhan:~$ whereis python3 python3: /usr/bin/python3.8 /usr/bin/python3.8-config /usr/bin/python3 一般在/usr/bin目录下，然后我们在这个目录下给他创建一个软链接“快捷方式”，具体咋用的啥意思，可以参考这篇文章。\nsudo ln -s /usr/bin/python3 /usr/bin/python 这样程序再找python时就会链接到python3，然后用python3去当解释器。\n解决方案四 可能在root目录下使用过repo，将其删除\n","permalink":"https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3-usr-bin-env-python-no-such-file-or-directory/","summary":"\u003cp\u003e在执行的程序源码开头有这么一句\u003ccode\u003e!#/usr/bin/env python\u003c/code\u003e，\u003ccode\u003e!#\u003c/code\u003e这玩意叫\u003ccode\u003eshebang\u003c/code\u003e也叫\u003ccode\u003ehashbang\u003c/code\u003e。他用来指定脚本的解释器，也就是说这个程序指定\u003ccode\u003epython\u003c/code\u003e解释器。\u003c/p\u003e","title":"解决/usr/bin/env:python:No such file or directory"},{"content":"Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。这有点像 Windows 环境下的快捷方式。介绍命令前了解一下软链接，硬链接具体是什么。\n硬链接 Hard Link 在 Linux 系统中，每个文件对应一个 inode，文件的内容在存储在 inode 指向的 data block 中。要读取该文件的内容，需要通过文件所在的目录中记录的文件名找到文件的 inode 号，然后通过 inode 找到存储文件内容的 data block。当然多个文件名可以指向同一个inode。\n使用ll命令显示文件的详细信息，-i参数显示其结点信息，其中最前面的一串数字就是inode信息。我们以/opt/test.txt文件为例，查看其结点信息。\ndominic@hanhan:/opt$ ll -i test.txt 2498138 -rw-r--r-- 1 root root 4 8月 3 12:16 test.txt 使用 ln 命令在/opt/temp目录下创建一个 test.txt 文件的硬链接，然后观察其文件属性：\ndominic@hanhan:/opt/temp$ sudo ln ../test.txt . dominic@hanhan:/opt/temp$ ll -i ../test.txt test.txt 2498138 -rw-r--r-- 2 root root 4 8月 3 12:16 ../test.txt 2498138 -rw-r--r-- 2 root root 4 8月 3 12:16 test.txt 我们再用ll -i命令查看结点信息，发现这两个文件名的结点信息是一样的。说明这两个文件名指向的是同一个文件。其中第三个字段是链接数，数字2，表示有两个文件名链接到同一个inode。\n硬链接的特点 硬链接，以文件副本的形式存在。但不占用实际空间。 由于硬链接只是在目录中添加了一条包含文件名和 对应 inode 的记录，所以它几乎不会消耗额外的磁盘容量。 不允许给目录创建硬链接 硬链接只有在同一个文件系统中才能创建 只要还有一个文件名引用着文件，文件就不会被真正删除 删除硬链接所关联的文件时，其实只是删除了一条目录中的记录，真正的文件并不受影响。只有在删除最后一个硬链接时才会真正删除文件的内容数据。 软链接 Symbolic Link 软链接的实现方式与硬链接有本质上的不同。创建软链接时会创建一个新的文件 (分配一个inode 和对应的 data block)，新文件的 data block 中存储了目标文件的路径。\n我们以/opt/test.txt为例，在/opt/temp目录中，为其创建一个软链接，然后查看其inode结点信息。\ndominic@hanhan:/opt/temp$ sudo ln -s ../test.txt test2.txt dominic@hanhan:/opt/temp$ ll -i ../test.txt test2.txt 2498139 lrwxrwxrwx 1 root root 11 8月 3 14:01 test2.txt -\u0026gt; ../test.txt 2498138 -rw-r--r-- 2 root root 4 8月 3 12:16 ../test.txt 第一个字段不同，说明是两个文件了 第二个字段表示权限，第一个字母表示文件类型，l说明书软链接文件 第三个字段表示链接数，仍然是2，说明软链接不增加源文件链接数 第六个字段是文件大小，新建的软链接文件时 11 字节，这就是/opt/test.txt的长度。 软链接特点 软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式 软链接可以 跨文件系统，硬链接不可以 软链接可以对一个不存在的文件名进行链接 软链接可以对目录进行链接 使用实例 ln [参数][源文件或目录][目标文件或目录] 为文件test.txt创建一个硬链接\nsudo ln test.txt /etc/ 删除test.txt的硬链接，因为是以副本形式存在的，所以直接用rm命令将其删除即可。\nsudo rm /etc/test.txt 为文件test.txt创建一个软链接\nsudo ln -s test.txt /etc/test2.txt 删除软链接也一样，直接用rm命令删除软链接的名称即可。\nReference https://www.runoob.com/linux/linux-comm-ln.html https://www.cnblogs.com/lixuze/p/14248559.html ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/","summary":"\u003cp\u003eLinux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。这有点像 Windows 环境下的快捷方式。介绍命令前了解一下软链接，硬链接具体是什么。\u003c/p\u003e","title":"每天学命令-ln 软硬链接"},{"content":"ed命令是文本编辑器，用于文本编辑。\ned是 Linux 中功能最简单的文本编辑程序，一次仅能编辑一行而非全屏幕方式的操作。很多命令和vim相似，平时开发中并不常用，但是在编辑大文本时还是会用到。\n学学无妨毕竟这是 Unix 系统三大要件（编辑器，汇编器和 shell）之一。\ned编辑器有两种模式：命令模式和输入模式。命令模式下输入a,i,c,d可以进入对应的编辑模式，接下来可以输入任何想要输入的内容，输入完毕或者要切换命令时，可以输入.退出输入模式。\nCommands a #添加到行 i #添加到行首 c #改变行 d #删除行 Line Address . #buffer 中 当前行 $ #最后一行 n #第 n 行，行的范围是 [0,$] - or ^ #前一行 -n or ^n #前 n 行 + or +n #后一行及后n行 , or % #全部行，等同于 1,$ ; #当前行到最后一行 .,$ /re/ #下一个包含正则 re 的行 ?re? #上一个包含正则 re 的行 使用实例 dominic@hanhan:~$ ed # 进入编辑模式 This is a test text! # 输入文本 . # 结束输入命令 This is a test text! # 回显当前行 n # 显示行号命令 1 This is a test text! # 回显当前行并显示行号 c # 改变行命令 This is changed text! # 输入更改后的内容 . # 结束输入命令 n # 显示行号命令 1 This is changed text! # 回显当前行并显示行号 i # 在首行插入命令 This is first line! # 输入插入内容 . # 结束输入命令 + # 后一行命令 This is changed text! # 回显后一行 d # 删除当前行 . # 回显当前行命令 This is firt line! # 回显当前行 a This is second line! This is third line! This is fourth line! w test.txt # 写入并保存文件 q # 退出编辑器 dominic@hanhan:~$ cat test.txt # 查看内容 This is first line!s This is second line! This is third line! This is fourth line! ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ed%E8%A1%8C%E7%BC%96%E8%BE%91%E5%99%A8/","summary":"\u003cp\u003e\u003ccode\u003eed\u003c/code\u003e命令是文本编辑器，用于文本编辑。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eed\u003c/code\u003e是 Linux 中功能最简单的文本编辑程序，一次仅能编辑一行而非全屏幕方式的操作。很多命令和\u003ccode\u003evim\u003c/code\u003e相似，平时开发中并不常用，但是在编辑大文本时还是会用到。\u003c/p\u003e","title":"每天学命令-ed 行编辑器"},{"content":"想知道自己代码写了多少行，可以一个wc命令搞定。\n可选参数 -l：仅列出行； -w：仅列出多少字 (英文单字)； -m：多少字符 使用实例 统计hello.c文件夹下文件总共多少行\n$ wc -l hello.c 14 hello.c 统计文件夹下文件的个数\nls -l | grep \u0026#34;^-\u0026#34; | wc -l 统计当前目录下文件的个数（包括子目录）\nls -lR| grep \u0026#34;^-\u0026#34; | wc -l 查看目录下文件夹 (目录) 的个数（包括子目录）\nls -lR | grep \u0026#34;^d\u0026#34; | wc -l 过滤ls的输出信息，只保留一般文件，只保留目录是grep \u0026quot;^d\u0026quot;。 ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-wc%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AD%97%E5%A4%9A%E5%B0%91%E8%A1%8C/","summary":"\u003cp\u003e想知道自己代码写了多少行，可以一个\u003ccode\u003ewc\u003c/code\u003e命令搞定。\u003c/p\u003e\n\u003ch2 id=\"可选参数\"\u003e可选参数\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-l：仅列出行；\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-w：仅列出多少字 (英文单字)；\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-m：多少字符\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"使用实例\"\u003e使用实例\u003c/h2\u003e\n\u003cp\u003e统计\u003ccode\u003ehello.c\u003c/code\u003e文件夹下文件总共多少行\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Bash\" data-lang=\"Bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ wc -l  hello.c\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"m\"\u003e14\u003c/span\u003e hello.c\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e统计文件夹下文件的个数\u003c/p\u003e","title":"每天学命令-wc 统计文件有多少字多少行"},{"content":"Ubuntu 默认是国外的源，软件下载和更新都比较慢。两种方法将下载源换成国内的源。\n用\u0026quot;软件和更新\u0026quot;工具 从 Ubuntu 菜单中找到软件和更新这个应用并打开。\n\u003c!DOCTYPE html\u003e Responsive Image 找到下载自，选择其他 - 国内-aliyun，然后勾选前四个选项。关闭时会弹出对话框，点击更新。然后就能愉快的下载软件了。\n\u003c!DOCTYPE html\u003e Responsive Image 修改sourcelist 备份原文件 这也算是系统文件的一部分，还是保险一点，出错了再改回来。\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 打开并修改 sudo vi /etc/apt/sources.list vim用的不习惯的估计会和我一样找全选内容怎么操作。教给你了 在命令模式下，就是按一下esc键，然后输入ggvG。具体什么含义看VIM 笔记吧，选择后直接delete删除，再把阿里云源粘贴进去。保存退出。\n#阿里云 deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 更新 sudo apt-get update sudo apt-get dist-upgrade sudo apt-get upgrade ","permalink":"https://lifeislife.cn/posts/linux%E6%9B%B4%E6%8D%A2ubuntu%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/","summary":"\u003cp\u003eUbuntu 默认是国外的源，软件下载和更新都比较慢。两种方法将下载源换成国内的源。\u003c/p\u003e\n\u003ch2 id=\"用软件和更新工具\"\u003e用\u0026quot;软件和更新\u0026quot;工具\u003c/h2\u003e\n\u003cp\u003e从 Ubuntu 菜单中找到\u003cstrong\u003e软件和更新\u003c/strong\u003e这个应用并打开。\u003c/p\u003e\n\u003cp\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eResponsive Image\u003c/title\u003e\n    \u003cstyle\u003e\n        .post-img-view {\n            text-align: center;\n        }\n        .responsive-image {\n            display: block;\n            margin: 0 auto;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \n    \u003cdiv class=\"post-img-view\"\u003e\n        \u003ca data-fancybox=\"gallery\" href=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210730112638.png\"\u003e\n            \u003cimg class=\"responsive-image\" src=\"https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210730112638.png\" alt=\"\"  style=\"margin: 0 auto;\"/\u003e\n        \u003c/a\u003e\n    \u003c/div\u003e\n    \n\n    \u003cscript\u003e\n        document.addEventListener(\"DOMContentLoaded\", function() {\n            var images = document.querySelectorAll(\".responsive-image\");\n            var maxHeight = window.innerHeight / 3;\n            images.forEach(function(image) {\n                image.style.maxHeight = maxHeight + \"px\";\n            });\n        });\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\u003c/p\u003e","title":"更换 Ubuntu 软件更新源"},{"content":"命令格式 find [path] [expression] 在path下查找expression表示的文件\n常用命令 一般常见就是自己不知道写的某个文件或者文件夹放哪里了，又或者只记住部分文件名。以下几个命令就能帮到你。\n按文件名查找 find -name filename(查找结果显示路径)或者 find filename(查找结果不显示路径) find hello.cpp #当前目录下精确查找hello.cpp文件 find hello #当前目录下精确查找hello文件 find hello* #当前目录下模糊查找以hello为前缀的文件 按类型查找 这就是为查找文件夹用的。\nfind -type [fdlcb] name [fdlcb]都是类型，d就是目录，文件夹类型。\nfind / -type d -name \u0026#34;helloworld\u0026#34; #查找名为helloworld的文件夹 按文件名查找 以下就详细介绍一些参数\nfind -name \u0026#34;hello.cpp\u0026#34; # 搜索文件名，大小写敏感 find -iname \u0026#34;hello.cpp\u0026#34; #大小写不敏感 按文件大小查找 find [path] -size 50M find / -size 10M # 查找系统中大小等于10M的文件 find / -size +50M # 查找系统中大小大于50M的文件 find / -size -30M # 查找系统中大小小于30M的文件 按时间来查找文件 Linux 会存储下面的时间：\nAccess time 上一次文件读或者写的时间 Modifica time 上一次文件被修改的时间 Change time 上一次文件 inode meta 信息被修改的时间 在按照时间查找时，可以使用 -atime， -mtime 或者 -ctime，和之前 size参数一样可以使用 + 或者 -时间范围，下图表示find的时间轴。+表示超过多少天，-表示多少天以内。\n此外，也可以换成-amin， -mmin 或者 -cmin参数，单位是分钟。\n\u003c!DOCTYPE html\u003e Responsive Image find / -mtime 1 # 寻找修改时间超过一天的文件 find / -atime -1 # 寻找在一天时间内被访问的文件 find / -ctime +3 # 寻找 meta 信息被修改的时间超过 3 天的文件 Reference http://c.biancheng.net/view/779.html\nhttps://einverne.github.io/post/2018/02/find-command.html#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E6%97%B6%E9%97%B4%E8%B6%85%E8%BF%87-1-%E5%A4%A9%E7%9A%84%E6%96%87%E4%BB%B6\n","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-find%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/","summary":"\u003ch2 id=\"命令格式\"\u003e命令格式\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind [path] [expression]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在\u003ccode\u003epath\u003c/code\u003e下查找\u003ccode\u003eexpression\u003c/code\u003e表示的文件\u003c/p\u003e\n\u003ch2 id=\"常用命令\"\u003e常用命令\u003c/h2\u003e\n\u003cp\u003e一般常见就是自己不知道写的某个文件或者文件夹放哪里了，又或者只记住部分文件名。以下几个命令就能帮到你。\u003c/p\u003e","title":"每天学命令-find 查找文件"},{"content":"在git clone时候，如果遇到项目里有子模块通常会在下载时加上--recursive参数，一起下载。但是子模块较多，体积较大时大概率都会下载失败。\n好在可以通过一些小技巧，下载国内镜像，进行加速。但是下载项目时，只是主体是国内的镜像，子模块仍然下载很慢。首先解决获取国内镜像的问题。有三个方法：\n在码云 Gitee 上搜索下载\n在码云上搜索同样的项目，然后用码云git 的地址下载。\n加上.cnpmjs.org后缀\n在地址后面加上后缀，如git clone https://github.com.cnpmjs.org/riscv/riscv-binutils-gdb.git。\n使用油猴脚本获取镜像地址\n如果你有油猴插件可以去greasyfork搜索安装GitHub镜像访问，加速下载这个脚本，刷新GitHub仓库界面就会多出几个镜像地址，一般下载都会快好几倍。\n\u003c!DOCTYPE html\u003e Responsive Image 再来解决子模块下载速度慢的问题，下载项目时，先不加--recursive参数，只下载项目的本题。\n下载完后找到.gitmodules文件，这是一个隐藏文件，需要显示隐藏文件，Linux 下使用快捷键Ctrl+H。用vim打开后可以得到：\n\u003c!DOCTYPE html\u003e Responsive Image 这个文件里写入了子模块的下载信息，url就是下载地址。我们把所有子模块中的 URL 地址同样加上.cnpmjs.org后缀。或者使用上述三种方式得到的镜像地址。\n然后利用git submodule sync更新子项目对应的url\n最后再git submodule update --init --recursive，即可快速下载所有子项目。\n","permalink":"https://lifeislife.cn/posts/git-clone%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD%E5%AD%90%E6%A8%A1%E5%9D%97/","summary":"\u003cp\u003e在\u003ccode\u003egit clone\u003c/code\u003e时候，如果遇到项目里有子模块通常会在下载时加上\u003ccode\u003e--recursive\u003c/code\u003e参数，一起下载。但是子模块较多，体积较大时大概率都会下载失败。\u003c/p\u003e","title":"git clone 快速下载子模块"},{"content":"制作交叉工具链 riscv-gnu-toolchain 下载源码 这个仓库是我遇到的最难下载的一个仓库了，公司网慢和虚拟机性能差都脱不了干系。估计下载了五小时都不止，刚开始还指望一个命令所有子模块都下载完的，结果愣是等了半天中断了。试了两次后放弃了。如果各位看官能一次完成，那您是福大。\n国内的码云平台有个Gitee 极速下载项目，上面有 GitHub 的一些常用开源项目的镜像，可供加速下载。\n# riscv-gnu-toolchain https://gitee.com/mirrors/riscv-gnu-toolchain.git 下载时问题出现了，如果下载子模块仍然会卡住，如果不加--recursive就只能下载主体内容，子模块都没有。（以下内容为第一安装时的方法，后续又找到了git clone 快速下载子模块的方法）\n开始下载时不加--recursive参数，只下载riscv-gnu-toolchain的主体内容，然后进入到riscv-gnu-toolchain文件夹下，手动下载子模块的内容。\n当下完riscv-binutils继续下载riscv-gdb时发现这两个项目是同一个项目，只是不同的分支。但是码云上并没有区分，但是我也没找到在码云上的对应分支。只能用油猴脚本了。\n如果你有油猴插件可以去greasyfork搜索安装GitHub 镜像访问，加速下载这个脚本，刷新 GitHub 仓库界面就会多出几个镜像地址，一般下载都会快好几倍。如果不用油猴插件的可以用我复制好的链接。\n\u003c!DOCTYPE html\u003e Responsive Image # riscv-binutils git clone https://gitee.com/mirrors/riscv-binutils-gdb.git # riscv-gcc git clone https://gitee.com/mirrors/riscv-gcc.git # riscv-dejagnu git clone https://gitee.com/mirrors/riscv-dejagnu.git # riscv-glibc git clone https://gitee.com/mirrors/riscv-glibc.git # riscv-newlib git clone https://gitee.com/mirrors/riscv-newlib.git # riscv-gdb git clone --depth=1 https://hub.fastgit.org/riscv/riscv-binutils-gdb.git 编译 riscv-gnu-toolchain 提前安装如下软件：\nsudo apt-get install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev 不听老人言，吃亏在眼前呀，本以为这是可选项，很多库都安装了，就没有操作这一步，结果就是编译半天结果还错了。如果报make 错误 127，那就老老实实把前置的这些库都装上。\n建立riscv-gnu-toolchain安装目录/opt/riscv64。\n./configure --prefix=/opt/riscv64 sudo make linux -j8 导出安装路径 export PATH=\u0026#34;$PATH:/opt/riscv64/bin\u0026#34; 出现一下信息表示安装成功。\nUsing built-in specs. COLLECT_GCC=riscv64-unknown-linux-gnu-gcc COLLECT_LTO_WRAPPER=/opt/riscv64/libexec/gcc/riscv64-unknown-linux-gnu/10.2.0/lto-wrapper Target: riscv64-unknown-linux-gnu Configured with: /home/dominic/riscv64-linux/riscv-gnu-toolchain/riscv-gcc/configure --target=riscv64-unknown-linux-gnu --prefix=/opt/riscv64 --with-sysroot=/opt/riscv64/sysroot --with-system-zlib --enable-shared --enable-tls --enable-languages=c,c++,fortran --disable-libmudflap --disable-libssp --disable-libquadmath --disable-libsanitizer --disable-nls --disable-bootstrap --src=.././riscv-gcc --disable-multilib --with-abi=lp64d --with-arch=rv64imafdc --with-tune=rocket \u0026#39;CFLAGS_FOR_TARGET=-O2 -mcmodel=medlow\u0026#39; \u0026#39;CXXFLAGS_FOR_TARGET=-O2 -mcmodel=medlow\u0026#39; Thread model: posix Supported LTO compression algorithms: zlib gcc version 10.2.0 (GCC) 制作内核 下载 Linux 内核 makefile\n","permalink":"https://lifeislife.cn/posts/qemu%E4%B8%8A%E8%BF%90%E8%A1%8C64%E4%BD%8D%E5%92%8C32%E4%BD%8Drisc-v-linux/","summary":"\u003ch2 id=\"制作交叉工具链-riscv-gnu-toolchain\"\u003e制作交叉工具链 riscv-gnu-toolchain\u003c/h2\u003e\n\u003ch3 id=\"下载源码\"\u003e下载源码\u003c/h3\u003e\n\u003cp\u003e这个仓库是我遇到的最难下载的一个仓库了，公司网慢和虚拟机性能差都脱不了干系。估计下载了五小时都不止，刚开始还指望一个命令所有子模块都下载完的，结果愣是等了半天中断了。试了两次后放弃了。如果各位看官能一次完成，那您是福大。\u003c/p\u003e","title":"在 QEMU 上运行 64 位和 32 位 RISC-V-Linux"},{"content":"df全称disk filesystem ，以磁盘分区为单位查看文件系统，可以查看磁盘文件占用空间，磁盘剩余空间等信息。\n命令格式 df [] [] 可选参数 -a 全部文件系统列表 -h 方便阅读方式显示 -H 等于“-h”，但是计算式，1K=1000，而不是 1K=1024 -i 显示 inode 信息 -k 区块为 1024 字节 -l 只显示本地文件系统 -m 区块为 1048576 字节 --no-sync 忽略 sync 命令 -P 输出格式为 POSIX --sync 在取得磁盘信息前，先执行 sync 命令 -T 文件系统类型 使用实例 df -T显示包含文件系统，类型，可用大小，已用大小，挂载点等信息。\ndominic@hanhan:~$ df -T 文件系统 类型 1K-块 已用 可用 已用% 挂载点 udev devtmpfs 1985056 0 1985056 0% /dev tmpfs tmpfs 403036 1304 401732 1% /run /dev/sda5 ext4 50824704 20826256 27386992 44% / tmpfs tmpfs 2015172 0 2015172 0% /dev/shm tmpfs tmpfs 5120 4 5116 1% /run/lock tmpfs tmpfs 2015172 0 2015172 0% /sys/fs/cgroup /dev/loop0 squashfs 56832 56832 0 100% /snap/core18/1988 /dev/loop1 squashfs 56832 56832 0 100% /snap/core18/2074 du全称disk usage可以查看文件，文件夹占用情况。\n命令格式 du [opt] [filename] 可选参数 -a或-all #显示目录中个别文件的大小。 -b或-bytes #显示目录或文件大小时，以byte为单位。 -c或--total #除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 -D或--dereference-args #显示指定符号连接的源文件大小。 -h或--human-readable #以K，M，G为单位，提高信息的可读性。 -H或--si #与-h参数相同，但是K，M，G是以1000为换算单位。 -k或--kilobytes #以1024 bytes为单位。 -l或--count-links #重复计算硬件连接的文件。 -L\u0026lt;符号连接\u0026gt;或- -dereference\u0026lt;符号连接\u0026gt; #显示选项中所指定符号连接的源文件大小。 -m或--megabytes #以1MB为单位。 -s或--summarize #仅显示总计。 -S或--separate-dirs #显示个别目录的大小时，并不含其子目录的大小。 -x或--one-file-xystem #以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 -X\u0026lt;文件\u0026gt;或--exclude-from=\u0026lt;文件\u0026gt; #在\u0026lt;文件\u0026gt;指定目录或文件。 --exclude=\u0026lt;目录或文件\u0026gt; #略过指定的目录或文件。 --max-depth=\u0026lt;目录层数\u0026gt; #超过指定层数的目录后，予以忽略。 --help #显示帮助。 --version #显示版本信息 使用实例 查看当前目录使用情况\ndominic@hanhan:~/learning-linux$ du 56 ./.git/hooks 8 ./.git/logs/refs/heads 8 ./.git/logs/refs/remotes/origin 12 ./.git/logs/refs/remotes 24 ./.git/logs/refs 32 ./.git/logs 8 ./.git/info 以易读的方式查看使用情况\ndominic@hanhan:~/learning-linux$ du -h 56K ./.git/hooks 8.0K ./.git/logs/refs/heads 8.0K ./.git/logs/refs/remotes/origin 12K ./.git/logs/refs/remotes 24K ./.git/logs/refs 32K ./.git/logs 8.0K ./.git/info 只输出当前目录占用总空间，同上-h命令就是以人读的方式（加上了数据单位）\ndominic@hanhan:~/learning-linux$ du -hs 264K . 查看当前目录及其指定深度目录的大小\n不深入子目录，就是当前文件夹所占用大小 dominic@hanhan:~/learning-linux$ du -h --max-depth=0 264K . 深入一层 dominic@hanhan:~/learning-linux$ du -h --max-depth=2 56K ./.git/hooks 32K ./.git/logs 8.0K ./.git/info 28K ./.git/objects 4.0K ./.git/branches 28K ./.git/refs 180K ./.git 24K ./helloworld/c 44K ./helloworld/shell 72K ./helloworld 264K . 忽略helloworld这个文件夹\ndominic@hanhan:~/learning-linux$ du --exclude=helloworld 56 ./.git/hooks 8 ./.git/logs/refs/heads 8 ./.git/logs/refs/remotes/origin 12 ./.git/logs/refs/remotes 24 ./.git/logs/refs 32 ./.git/logs 8 ./.git/info 4 ./.git/objects/info 20 ./.git/objects/pack 28 ./.git/objects 4 ./.git/branches 8 ./.git/refs/heads 4 ./.git/refs/tags 8 ./.git/refs/remotes/origin 12 ./.git/refs/remotes 28 ./.git/refs 180 ./.git 192 . Refernece https://einverne.github.io/post/2018/03/du-find-out-which-fold-take-space.html https://www.runoob.com/linux/linux-comm-du.html ","permalink":"https://lifeislife.cn/posts/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-df-du%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4/","summary":"\u003cp\u003e\u003ccode\u003edf\u003c/code\u003e全称\u003ccode\u003edisk filesystem\u003c/code\u003e ，以磁盘分区为单位查看文件系统，可以查看磁盘文件占用空间，磁盘剩余空间等信息。\u003c/p\u003e\n\u003ch2 id=\"命令格式\"\u003e命令格式\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edf [] []\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"可选参数\"\u003e可选参数\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-a      全部文件系统列表\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-h      方便阅读方式显示\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-H      等于“-h”，但是计算式，1K=1000，而不是 1K=1024\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-i      显示 inode 信息\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-k      区块为 1024 字节\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-l      只显示本地文件系统\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-m      区块为 1048576 字节\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e--no-sync 忽略 sync 命令\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-P      输出格式为 POSIX\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e--sync  在取得磁盘信息前，先执行 sync 命令\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-T      文件系统类型\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"使用实例\"\u003e使用实例\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003edf -T\u003c/code\u003e显示包含文件系统，类型，可用大小，已用大小，挂载点等信息。\u003c/p\u003e","title":"每天学命令-df/du查看磁盘剩余空间"},{"content":"真蠢，之前费那么大劲，只要一句命令就完事了\n下载安装 sudo apt install qtcreator 但是在用命令行构建 project 时可能会报错\nqmake -project could not find a Qt installation of \u0026#39;\u0026#39; 这时候需要\nsudo apt-get install qt5-default 好了可以愉快玩耍了。\n瞎折腾\n下载 Qt 从 Qt5.15.0 起，对于开源用户，Qt 官方不再提供独立安装文件，且不再有 bug 修复版本（比如 Qt5.15.1），如果从官网下载，需要自己编译。虽然想试试编译，但是虚拟机刚开始开的空间太小了，还是另寻他法吧。以后有机会再来编译试试新功能。若读者有兴趣可以从官网下载源码并编译。或者参考官方的编译教程，从 GitHub 上下载。\n国内有一些镜像站，提供 qt 镜像下载： 清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/ 中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/ 北京理工大学：https://mirrors.cnnic.cn/qt/\n以清华大学的镜像为例，找到archive/qt/5.14/5.14.0/qt-opensource-linux-x64-5.14.0.run，点击即可开始下载。\nqt 5.15 已经不提供安装包，想要最新版本，只能下 5.14，但是 5.14.2 下载没资源，下不动，如果遇到下不动的情况换一个版本吧\n安装 Qt 下载的.run文件双击是无法安装的，因为它还没有可执行的权限，需要我们赋给它执行权限，打开终端进入安装包的目录。\nchmod +x filename.run chmod命令是控制用户对文件的权限修改的命令，x是可执行权限的参数。 执行以上命令后就可以直接双击安装了。\n网上一些教程可以跳过登录，我没找到跳过按钮，需要注册一个账号才能继续安装。 \u003c!DOCTYPE html\u003e Responsive Image 安装目录一般选择在/opt目录下 \u003c!DOCTYPE html\u003e Responsive Image 安装的附加组件最好都选择，以免后期使用再安装麻烦。Qt Creator 肯定要装的。 \u003c!DOCTYPE html\u003e Responsive Image 安装依赖库 apt-get install g++ apt-get install libgl1-mesa-dev apt-get install libqt4-dev apt-get install build-essential # Build Essential，它是一个元软件包，可让您在Ubuntu中安装和使用c ++工具。 sudo apt install qt5-default # 如果要将Qt 5用作默认的Qt Creator版本需要安装，否则会报 qmake: could not find a Qt installation of \u0026#39;\u0026#39;的错误 使用 Qt Creator 创建第一个程序 使用 Qt Creator 创建 首先我们先创建一个不带窗口的 HelloWorld 程序，测试安装是否成功，打开 Qt Creator-文件 - 新建文件或项目，选择 Non-Qt Project-Plain C++ Application。 \u003c!DOCTYPE html\u003e Responsive Image 接下来就设置项目名等，一直下一步。完成后就可以在编辑器看到如下 \u003c!DOCTYPE html\u003e Responsive Image 点击左下角运行按钮就可以得到如下： \u003c!DOCTYPE html\u003e Responsive Image 再创建一个带窗口的 HelloWorld，在选择模板时选择 Application-Qt Widgets Application。一路点下一步就可以完成创建，运行后就可得到一个灰白的 HelloWorld 窗口。\n命令行编译第一个 Qt 程序 首先创建工作目录HelloWorldQt\nmkdir HelloWorld 进入项目目录下，新建一个main.cpp文件\ncd HelloWorldQt vim main.cpp 编辑以下内容：\n#include \u0026lt;QApplication\u0026gt; #include \u0026lt;QLabel\u0026gt; #include \u0026lt;QWidget\u0026gt; int main(int argc, char *argv[ ]) { QApplication app(argc, argv); QLabel hello(\u0026#34;\u0026lt;center\u0026gt;Welcome to my first Qt program\u0026lt;/center\u0026gt;\u0026#34;); hello.setWindowTitle(\u0026#34;My First Qt Program\u0026#34;); hello.resize(400, 400); hello.show(); return app.exec(); } 建立 QtProject 文件\nqmake -project 用vim打开HelloWorldQt.pro文件，添加以下内容\nQT += gui widgets \u003c!DOCTYPE html\u003e Responsive Image 运行qmake，使项目 platform-specific，会得到一个Makefile文件\nqmake HelloWorldQt.pro 使用make命令将Makefile编译为可执行程序\n➜ HelloWorldQt make g++ -c -pipe -O2 -Wall -W -D_REENTRANT -fPIC -DQT_DEPRECATED_WARNINGS / -DQT_NO_DEBUG -DQT_WIDGETS_LIB / -DQT_GUI_LIB -DQT_CORE_LIB -I. / -I. -isystem / /usr/include/x86_64-linux-gnu/qt5 -isystem / /usr/include/x86_64-linux-gnu/qt5/QtWidgets / -isystem /usr/include/x86_64-linux-gnu/qt5/QtGui / -isystem /usr/include/x86_64-linux-gnu/qt5/QtCore -I. / -I/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++ -o main.o main.cpp g++ -Wl,-O1 -o HelloWorldQt main.o / /usr/lib/x86_64-linux-gnu/libQt5Widgets.so / /usr/lib/x86_64-linux-gnu/libQt5Gui.so / /usr/lib/x86_64-linux-gnu/libQt5Core.so / /usr/lib/x86_64-linux-gnu/libGL.so -lpthread 如果一切顺利，执行可以得到如下\n./HelloWorldQt \u003c!DOCTYPE html\u003e Responsive Image ","permalink":"https://lifeislife.cn/posts/linux-ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85qt/","summary":"\u003cp\u003e真蠢，之前费那么大劲，只要一句命令就完事了\u003c/p\u003e\n\u003ch2 id=\"下载安装\"\u003e下载安装\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install qtcreator\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但是在用命令行构建 project 时可能会报错\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eqmake -project\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecould not find a Qt installation of \u0026#39;\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这时候需要\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install qt5-default \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e好了可以愉快玩耍了。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e瞎折腾\u003c/p\u003e\n\u003ch2 id=\"下载-qt\"\u003e下载 Qt\u003c/h2\u003e\n\u003cp\u003e从 Qt5.15.0 起，对于开源用户，Qt 官方不再提供独立安装文件，且不再有 bug 修复版本（比如 Qt5.15.1），如果从官网下载，需要自己编译。虽然想试试编译，但是虚拟机刚开始开的空间太小了，还是另寻他法吧。以后有机会再来编译试试新功能。若读者有兴趣可以从\u003ca href=\"https://download.qt.io/archive/qt/\"\u003e官网\u003c/a\u003e下载源码并编译。或者参考\u003ca href=\"https://wiki.qt.io/Building_Qt_5_from_Git#Getting_the_source_code\"\u003e官方的编译教程\u003c/a\u003e，从 GitHub 上下载。\u003c/p\u003e","title":"Linux(Ubuntu) 环境下安装 Qt"},{"content":"调用文档 qemu-system-x86_64 [options] [disk_image] disk_image是 IDE 硬盘 0 的原始硬盘映像。某些目标不需要磁盘映像。\n标准参数 Standard options -h 功能 显示帮助信息并退出\n子参数\n调用实例\nqemu-system-riscv32 -h -version 功能 显示 qemu 版本信息并退出\n子参数\n调用实例\nqemu-system-riscv32 -version -machine [type=]name[,prop=value[,...]] 功能 通过名称选择模拟器。使用 -machine help 可以查看可用的模拟器。 对于支持跨版本实时迁移兼容性的架构，每个版本都会引入一个新的版本化模拟器类型。例如，2.8.0 版本为 x86_64/i686 架构引入了“pc-i440fx-2.8”和“pc-q35-2.8”。\n子参数 为了允许用户从 QEMU 2.8.0 版实时迁移到 QEMU 2.9.0 版，2.9.0 版也必须支持“pc-i440fx-2.8”和“pc-q35-2.8”机器。为了允许用户在升级时实时迁移 VMs 跳过多个中间版本，QEMU 的新版本将支持多个以前版本的机器类型。 支持的机器属性有：\naccel=accels1[:accels2[:...]] This is used to enable an accelerator. Depending on the target architecture, kvm, xen, hax, hvf, nvmm, whpx or tcg can be available. By default, tcg is used. If there is more than one accelerator specified, the next one is used if the previous one fails to initialize. vmport=on|off|auto Enables emulation of VMWare IO port, for vmmouse etc. auto says to select the value based on accel. For accel=xen the default is off otherwise the default is on. dump-guest-core=on|off Include guest memory in a core dump. The default is on. mem-merge=on|off Enables or disables memory merge support. This feature, when supported by the host, de-duplicates identical memory pages among VMs instances (enabled by default). aes-key-wrap=on|off Enables or disables AES key wrapping support on s390-ccw hosts. This feature controls whether AES wrapping keys will be created to allow execution of AES cryptographic functions. The default is on. dea-key-wrap=on|off Enables or disables DEA key wrapping support on s390-ccw hosts. This feature controls whether DEA wrapping keys will be created to allow execution of DEA cryptographic functions. The default is on. nvdimm=on|off Enables or disables NVDIMM support. The default is off. memory-encryption= Memory encryption object to use. The default is none. hmat=on|off Enables or disables ACPI Heterogeneous Memory Attribute Table (HMAT) support. The default is off. memory-backend='id' An alternative to legacy -mem-path and mem-prealloc options. Allows to use a memory backend as main RAM. For example: :: -object memory-backend-file,id=pc.ram,size=512M,mem-path=/hugetlbfs,prealloc=on,share=on -machine memory-backend=pc.ram -m 512M Migration compatibility note: a) as backend id one shall use value of ‘default-ram-id’, advertised by machine type (available via query-machines QMP command), if migration to/from old QEMU (\u0026lt;5.0) is expected. b) for machine types 4.0 and older, user shall use x-use-canonical-path-for-ramblock-id=off backend option if migration to/from old QEMU (\u0026lt;5.0) is expected. For example: :: -object memory-backend-ram,id=pc.ram,size=512M,x-use-canonical-path-for-ramblock-id=off -machine memory-backend=pc.ram -m 512M 调用实例：\nqemu-system-riscv32 -machine virt,mem-merge=on -cpu model 功能 选择 CPU 型号（-cpu help显示帮助列表和附加功能的选项） 默认情况会给客户机提供 qemu64 或 qemu32 的基本 CPU 模型。这样做可以对 CPU 特性提供一些高级的过滤功能，让客户机在同一组硬件平台上的动态迁移会更加平滑和安全。 在客户机中查看 CPU 信息 (cat /proc/cpuinfo)，model name 就是当前 CPU 模型的名称。\n调用实例\nqemu-system-riscv32 -cpu rv32 accel name[,prop=value[,...]] 功能 This is used to enable an accelerator. Depending on the target architecture, kvm, xen, hax, hvf, nvmm, whpx or tcg can be available. By default, tcg is used. If there is more than one accelerator specified, the next one is used if the previous one fails to initialize. 子参数 igd-passthru=on|off When Xen is in use, this option controls whether Intel integrated graphics devices can be passed through to the guest (default=off) kernel-irqchip=on|off|split Controls KVM in-kernel irqchip support. The default is full acceleration of the interrupt controllers. On x86, split irqchip reduces the kernel attack surface, at a performance cost for non-MSI interrupts. Disabling the in-kernel irqchip completely is not recommended except for debugging purposes. kvm-shadow-mem=size Defines the size of the KVM shadow MMU. split-wx=on|off Controls the use of split w^x mapping for the TCG code generation buffer. Some operating systems require this to be enabled, and in such a case this will default on. On other operating systems, this will default off, but one may enable this for testing or debugging. tb-size=n Controls the size (in MiB) of the TCG translation block cache. thread=single|multi Controls number of TCG threads. When the TCG is multi-threaded there will be one thread per vCPU therefore taking advantage of additional host cores. The default is to enable multi-threading where both the back-end and front-ends support it and no incompatible TCG features have been enabled (e.g. icount/replay). dirty-ring-size=n When the KVM accelerator is used, it controls the size of the per-vCPU dirty page ring buffer (number of entries for each vCPU). It should be a value that is power of two, and it should be 1024 or bigger (but still less than the maximum value that the kernel supports). 4096 could be a good initial value if you have no idea which is the best. Set this value to 0 to disable the feature. By default, this feature is disabled (dirty-ring-size=0). When enabled, KVM will instead record dirty pages in a bitmap. smp [[cpus=]n][,maxcpus=maxcpus][,sockets=sockets][,dies=dies][,cores=cores][,threads=threads] 功能 配置客户机的 SMP（Symmetric Multi-Processing），对称多处理机\n子参数\n[cpus=]n 设置客户机中使用逻辑的 CPU 数量（默认值是 1）。 [,maxcpus=cpus] 设置客户机最大可能被使用的 CPU 数量（可以用热插拔 hot-plug 添加 CPU，不能超过 maxcpus 上限）。 [,cores=cores] 设置每个 CPU socket 上的 core 数量（默认值是 1）。 [,threads=threads] 设置每个 CPU core 上的线程数（默认值是 1）。 [,sockets=sockets] 设置客户机中总的 CPU socket 数量。 调用实例\nqemu-system-x86_64 -smp 1,sockets=1,cores=2,threads=2 -numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator] -numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator] -numa dist,src=source,dst=destination,val=distance -numa cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z] -numa hmat-lb,initiator=node,target=node,hierarchy=hierarchy,data-type=tpye[,latency=lat][,bandwidth=bw] -numa hmat-cache,node-id=node,size=size,level=level[,associativity=str][,policy=str][,line=size] 功能 子参数 调用实例 -add-fd fd=fd,set=set[,opaque=opaque] 功能 子参数 调用实例 -set group.id.arg=value 功能 子参数 调用实例 -global driver.prop=value 功能 子参数 调用实例 -global driver=driver,property=property,value=value 功能 子参数 调用实例 -boot [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off] 功能 设置客户机启动顺序 在 qemu 模拟的 x86 平台中，用\u0026quot;a\u0026quot;、\u0026ldquo;b\u0026quot;分别表示第一和第二软驱，用\u0026quot;c\u0026quot;表示第一个硬盘，用\u0026quot;d\u0026quot;表示 CD-ROM 光驱，用\u0026quot;n\u0026quot;表示从网络启动。 默认从硬盘启动。\n子参数\n[order=drives] 设置启动顺序。 [,once=drives] 只设置下一次启动的顺序，再重启后无效。 [,menu=on|off] 只要固件/BIOS 支持，就可以启用交互式引导菜单/提示。默认为非交互式引导。 [,splash=sp_name] 如果固件/BIOS 支持选项 splash=sp_name 和 menu=on，则可以将启动画面传递给 bios，使用户能够将其显示为徽标。目前 Seabios for X86 系统支持它。限制：启动文件可以是 24 BPP 格式（真彩色）的 jpeg 文件或 BMP 文件。分辨率应该是 SVGA 模式支持的，推荐 320x240、640x480、800x640。 [,splash-time=sp_time] [,reboot-timeout=rb_timeout] 引导失败时，客户机将暂停 rb_timeout 毫秒，然后重新启动。如果 rb_timeout 为 \u0026lsquo;-1\u0026rsquo;，客户机不会重启，qemu 默认将 \u0026lsquo;-1\u0026rsquo; 传递给 bios。目前 Seabios for X86 系统支持它。 [,strict=on|off] 只要固件/BIOS 支持，就通过严格启动。这仅在 bootindex 选项更改引导优先级时有效。默认为非严格引导。 调用实例\n# 尝试先从网络启动，然后从硬盘启动 qemu-system-x86_64 -boot order=nc # 先从光驱启动，重启后切换回默认顺序 qemu-system-x86_64 -boot once=d # 5 秒钟的启动画面。 qemu-system-x86_64 -boot menu=on,splash=/root/boot.bmp,splash-time=5000 -m [size=]megs[,slots=n,maxmem=size] 功能 将客户机内存设置为 megs M字节。默认值为 128 MiB。或者，也可以使用“M”或“G”的后缀。齐。\n子参数\n[size=]megs 将客户机内存设置为 megs M字节 [,slots=n,maxmem=size] 可用于设置可热插拔内存插槽的数量和最大内存数量。maxmem 必须与页面大小对 调用实例 以下命令行将客户机启动 RAM 大小设置为 1GB，创建 3 个插槽以热插拔额外内存，并将客户机可以达到的最大内存设置为 4GB：\nqemu-system-x86_64 -m 1G,slots=3,maxmem=4G 如果未指定 slot 和 maxmem，则不会启用内存热插拔，并且客户机内存永远不会增加。\n-mem-path path 功能 使用huge page。对于内存访问密集型的应用，使用huge page是可以比较明显地提高客户机性能。 使用huge page的内存不能被换出（swap out），也不能使用ballooning方式自动增长。 子参数 调用实例 -mem-prealloc 功能 使宿主机在客户机启动时就全部分配好客户机的内存 子参数 调用实例 -k language 功能 设置键盘布局语言，默认为en-us\n子参数 可用布局：\nar de-ch es fo fr-ca hu ja mk no pt-br sv da en-gb et fr fr-ch is lt nl pl ru th de en-us fi fr-be hr it lv nl-be pt sl tr 调用实例\n块设备参数 Block device options fda file 功能 为客户机指定软盘设备，指定客户机的第一个软盘设备，在客户机中显示为/dev/fd0 子参数 调用实例 fdb file 功能 为客户机指定软盘设备，指定客户机的第一个软盘设备，在客户机中显示为/dev/fd1 子参数 调用实例 hda file hdb file hdc file hdd file 功能 为客户机指定块存储设备，指定客户机种的第一个 IDE 设备 子参数 若客户机使用PIIX_IDE驱动，显示为/dev/hda设备； 若客户机使用ata_piix驱动，显示为/dev/sda设备。 若没有使用-hdx的参数，则默认使用-hda参数； 可以将宿主机的一块硬盘作为-hda的参数使用； 若文件名包含逗号，应使用两个连续的逗号进行转义。 调用实例 -cdrom file 功能 为客户机指定光盘 CD-ROM。可以将宿主机的光驱/dev/cdrom设备作为-cdrom参数使用。-cdrom参数不能与-hdc参数同时使用，因为-cdrom就是客户机里的第三个 IDE 设备 子参数 调用实例 -blockdev option[,option[,option[,...]]] 功能\n子参数\n调用实例\n-drive option[,option[,option[,...]]] 功能 定义一个存储驱动器 子参数 [file=file] 加载file镜像文件到客户机的驱动器中。 [,if=type] 指定驱动器使用的接口类型：可用的类类型有：ide、scsi、virtio、sd、floopy、pflash等。 [,bus=n] 设置驱动器在客户机中的总线编号。 [,unit=m] 设置驱动器在客户机中的单元编号。 [,media=d] 设置驱动器中媒介的类型，值为 disk 或 cdrom。 [,index=i] 设置在通一种接口的驱动器中的索引编号。 [,snapshot=on|off] 当值为 on 时，qemu 不会将磁盘数据的更改写回到镜像文件中，而是写到临时文件中，可以在 qemu moinitor 中使用 commit 命令强制将磁盘数据保存回镜像文件中。 [,cache=writethrough|writeback|none|directsync|unsafe] 设置宿主机对块设备数据访问的 cache 模式。， writethrough（直写模式）：调用 write 写入数据的同时将数据写入磁盘缓存和后端块设备中。 writeback（回写模式）：调用 write 写入数据时只将数据写入到磁盘缓存中，当数据被换出缓存时才写入到后端存储中。优点写入数据块，缺点系统掉电数据无法恢复。 [,aio=threads|native] 选择异步 IO 的方式 threads 为 aio 参数的默认值，让一个线程池去处理异步 IO； native 只适用于 cache=none 的情况，使用的是 Linux 原生的 AIO。 [,format=f] 指定使用的磁盘格式，默认是 QEMU 自动检测磁盘格式的。 [,serial=s] 指定分配给设备的序列号。 [,addr=A] 分配给驱动器控制器的 PCI 地址，只在使用 virtio 接口时适用。 [,id=name] 设置驱动器的 ID，可以在 QEMU monitor 中用 info block 看到。 [,readonly=on|off] 设置驱动器是否只读。 调用实例 USB 参数 USB convenience options 显示参数 Display options 仅限 i386 架构的参数 i386 target only 网络参数 Network options 字符设备参数 Character device options TPM 设备 TPM device options 指定启动指引 Linux/Multiboot boot specific 当使用该调用参数时，你可以使用给定的 Linux 或者多重引导内核，而不需要安装内核到一个光盘中。这样可以更方便地测试不同内核。\n-kernel bzImage\n功能 用 bzImage 作为内核镜像，也可以使用其他启动格式。 -append cmdline\n功能 用cmd命令行，作为内核的命令行 -initrd file\n功能 用文件作为初始化 ram -initrd \u0026quot;file1 arg=foo,file2\u0026quot;\n功能 此语法仅适用于多重引导 使用 file1 和 file2 作为模块并将 arg=foo 作为参数传递给第一个模块 -dtb file\n功能 将文件用作设备树二进制 (dtb) 映像并在启动时将其传递给内核 ","permalink":"https://lifeislife.cn/posts/qemu%E6%96%87%E6%A1%A3/","summary":"\u003ch1 id=\"调用文档\"\u003e调用文档\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eqemu-system-x86_64 [options] [disk_image] \u003c/code\u003e\n\u003ccode\u003edisk_image\u003c/code\u003e是 IDE 硬盘 0 的原始硬盘映像。某些目标不需要磁盘映像。\u003c/p\u003e\n\u003ch2 id=\"标准参数-standard-options\"\u003e标准参数 Standard options\u003c/h2\u003e\n\u003ch3 id=\"-h\"\u003e\u003ccode\u003e-h\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e功能\n显示帮助信息并退出\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e子参数\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e调用实例\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eqemu-system-riscv32 -h\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"-version\"\u003e\u003ccode\u003e-version\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e功能\n显示 qemu 版本信息并退出\u003c/p\u003e","title":"QEMU 文档"},{"content":"创建仓库时没有加入 gitignore 文件，上传了不需要的文件，后添加了 gitignore 文件如何同步远程与本地的文件（自动删除不需要的文件） # 注意有个点“.” 取消版本控制 git rm -r --cached . 重新添加 git add -A 重新提交 git commit -m \u0026#34;update .gitignore\u0026#34; Git rm 和 rm \u0026ndash;cached 区别 rm ：当需要删除暂存区或分支上的文件，同时工作区不需要这个文件\nrm --cached：当需要删除暂存区或分支上的文件，同时工作区需要这个文件，但是不需要被版本控制。就是本地需要保留，但是远程不保留\n推送空文件夹到远程仓库 在需要推送的空文件下创建\u0026quot;.gitkeep\u0026quot;文件 在\u0026quot;.gitignore\u0026quot;文件中编写规则 !.gitkeep\n克隆指定分支代码 git clone -b master https://github.com/Dunky-Z/Dunky-Z.github.io.git master就是分支名\n","permalink":"https://lifeislife.cn/posts/git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","summary":"\u003ch2 id=\"创建仓库时没有加入-gitignore-文件上传了不需要的文件后添加了-gitignore-文件如何同步远程与本地的文件自动删除不需要的文件\"\u003e创建仓库时没有加入 gitignore 文件，上传了不需要的文件，后添加了 gitignore 文件如何同步远程与本地的文件（自动删除不需要的文件）\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 注意有个点“.”\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e取消版本控制\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit rm -r --cached .\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e重新添加\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit add -A\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e重新提交\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit commit -m \u003cspan class=\"s2\"\u003e\u0026#34;update .gitignore\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"git-rm-和-rm-cached-区别\"\u003eGit rm 和 rm \u0026ndash;cached 区别\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003erm\u003c/code\u003e ：当需要删除暂存区或分支上的文件，同时工作区不需要这个文件\u003c/p\u003e","title":"Git 踩坑记录"},{"content":"简介 QEMU 是一款开源的模拟器及虚拟机监管器 (Virtual Machine Monitor, VMM)。QEMU 主要提供两种功能给用户使用。一是作为用户态模拟器，利用动态代码翻译机制来执行不同于主机架构的代码。二是作为虚拟机监管器，模拟全系统，利用其他 VMM(Xen, KVM, etc) 来使用硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。\n安装 使用包管理安装 sudo apt-get install qemu 使用源码安装 wget wget https://download.qemu.org/qemu-6.1.0-rc3.tar.xz tar xvJf qemu-6.1.0-rc3.tar.xz cd qemu-6.1.0-rc3 安装相关库 apt-get install libglib2.0-dev apt-get install ninja-build apt install g++ apt install libpixman-1-dev apt install libsdl2-dev -y 配置 通过./configure --help 的查看编译时的选项，--target-list选项为可选的模拟器，默认全选。 --target-list 中的 xxx-soft 和 xxx-linux-user 分别指系统模拟器和应用程序模拟器，生成的二进制文件名字为qemu-system-xxx和 qemu-xxx 本文使用如下配置：\n./configure --prefix=XXX --enable-debug --target-list=riscv32-softmmu,riscv32-linux-user,riscv64-linux-user,riscv64-softmmu --enable-kvm # --prefix 选项设置qemu的安装位置绝对路径，之后若要卸载删除qemu只要删除该文件夹即可，--enable-kvm开启kvm # config完，可以在指定的qemu安装文件夹下面找到config-host.mak文件， # 该文件记录着qemu配置的选项，可以和自己设置的进行对比，确保配置和自己已知 接着进行编译\nmake -j8 直接make会很慢，第一次编译时默认安装说有模拟器，编译了三四个小时。加上-j8可以进行多线程编译\n创建与使用 创建虚拟镜像 使用虚拟镜像来模拟虚拟机的硬盘，在启动虚拟机之前需要创建一个镜像文件\nroot@hanhan:/home/dominic/qemu/# qemu-img create -f qcow2 qmtest.img 10G Formatting \u0026#39;qmtest.img\u0026#39;, fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off root@hanhan:/home/dominic/qemu/# ls qmtest.img -f选项用于指定镜像的格式，qcow2格式是 QEMU 最常用的镜像格式，采用写时复制技术来优化性能。qmtest.img是镜像文件的名字，10G是镜像文件大小。\n镜像文件创建完成后，可使用qemu-system-x86来启动x86架构的虚拟机：\nqemu-system-x86_64 qmtest.img qmtest.img 中还未安装操作系统，所以会提示“No bootable device”的错误。\n准备操作系统镜像 下载需要的 Linux 发行版镜像文件，https://launchpad.net/ubuntu/+cdmirrors，找到想要下载的镜像，这里以交通大学的镜像为例 右击链接复制地址：https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso\nroot@hanhan:/home/dominic/qemu/# wget https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso 检查 KVM 是否可用 QEMU 使用 KVM 来提升虚拟机性能，如果不启用 KVM 会导致性能损失。要使用 KVM，首先要检查硬件是否有虚拟化支持：\nroot@hanhan:/home/dominic/qemu/# grep -E \u0026#39;vmx|svm\u0026#39; /proc/cpuinfo 如果有输出则表示硬件有虚拟化支持。其次要检查 kvm 模块是否已经加载：\nroot@hanhan:/home/dominic/qemu/# lsmod | grep kvm kvm_intel 142999 0 kvm 444314 1 kvm_intel 如果kvm_intel/kvm_amd、kvm模块被显示出来，则kvm模块已经加载。最后要确保 qemu 在编译的时候使能了KVM，即在执行configure脚本的时候加入了–enable-kvm选项。\n启动虚拟机安装操作系统 root@hanhan:/home/dominic/qemu/# qemu-system-x86_64 -m 2048 -enable-kvm qmtest.img -cdrom ./Fedora-Live-Desktop-x86_64-20-1.iso -m指定虚拟机内存大小，默认单位是 MB，-enable-kvm使用 KVM 进行加速，-cdrom添加 fedora 的安装镜像。可在弹出的窗口中操作虚拟机，安装操作系统，安装完成后重起虚拟机便会从硬盘 (qmtest.img) 启动。之后再启动虚拟机只需要执行：\nroot@hanhan:/home/dominic/qemu/# qemu-system-x86_64 -m 2048 -enable-kvm qmtest.img 退出 qemu 在运行 qemu 后，关闭图形界面但是终端仍然是处于 qemu 环境中，可以直接关闭终端退出。如果不想关闭终端，可以另外打开一个终端 kill 进程\nkillall qemu-system-riscv32 如果记不清全称，可以输入大概名称回车后会列出相关的进程\n","permalink":"https://lifeislife.cn/posts/qemu%E5%88%9D%E8%AF%86/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003eQEMU 是一款开源的模拟器及虚拟机监管器 (Virtual Machine Monitor, VMM)。QEMU 主要提供两种功能给用户使用。一是作为用户态模拟器，利用动态代码翻译机制来执行不同于主机架构的代码。二是作为虚拟机监管器，模拟全系统，利用其他 VMM(Xen, KVM, etc) 来使用硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。\u003c/p\u003e","title":"QEMU 初识"},{"content":" 任何一个计算机系统的运行都是系统中软硬件协作的结果，没有硬件的软件是空中楼阁，而没有软件的硬件则只是一堆废铁。\u0026ndash;天朗 - 星空\n硬件是底层基础，所有软件代码的运行平台，相对固定不易改变，而软件是具体的应用，它灵活多变，可以应对用户的不同需求。\n为尽可能快速地完成设计，应用软件工程师不想也不必关心硬件，而硬件工程师也难有足够的闲暇和能力来顾忌软件。譬如，应用软件工程师在调用套接字发送和接收数据包的时候，不必关心网卡上的寄存器、存储空间、I/O 端口、片选以及其他任何硬件层面的操作调度；在使用printf()函数输出信息的时候，他不用知道底层究竟是怎样把相应的信息输出到屏幕或者串口的具体硬件过程，需要的只是出现相应的显示效果。\n也就是说，应用软件工程师需要看到一个没有硬件的纯粹的软件世界，硬件必须被透明地呈现给他们。谁来实现硬件对应用软件工程师的隐形？这个艰巨的任务就落在了驱动工程师的头上。\n对设备驱动最通俗的解释就是“驱使硬件设备行动” 。设备驱动与底层硬件直接打交道，按照硬件设备的具体工作方式读写设备寄存器，完成设备的轮询、中断处理、DMA 通信，进行物理内存向虚拟内存的映射，最终使通信设备能够收发数据，使显示设备能够显示文字和画面，使存储设备能够记录文件和数据。\n","permalink":"https://lifeislife.cn/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A9%B1%E5%8A%A8%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88/","summary":"\u003cblockquote\u003e\n\u003cp\u003e任何一个计算机系统的运行都是系统中软硬件协作的结果，没有硬件的软件是空中楼阁，而没有软件的硬件则只是一堆废铁。\u0026ndash;\u003ca href=\"https://blog.csdn.net/yunfenglw/article/details/39337343\"\u003e天朗 - 星空\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e硬件是底层基础，所有软件代码的运行平台，相对固定不易改变，而软件是具体的应用，它灵活多变，可以应对用户的不同需求。\u003c/p\u003e","title":"什么是驱动，驱动的作用又是什么？"},{"content":"刚开始搭建的时候并没有为仓库添加 Readme 文件，但是后期添加也不能直接在仓库里直接添加，因为每次部署都会被自动删除。 添加方法：\n在博客根目录的source文件夹下新建README.md文件 在根目录的_config.yml文件中搜索skip_render，并做如下更改 skip_render: README.md 因为在每次hexo g时候，README 文件都会被自动渲染为 HTML 文件，所以在配置文件中告诉渲染器跳过这个文件不要渲染它。\n","permalink":"https://lifeislife.cn/posts/hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0readme%E6%96%87%E4%BB%B6/","summary":"\u003cp\u003e刚开始搭建的时候并没有为仓库添加 Readme 文件，但是后期添加也不能直接在仓库里直接添加，因为每次部署都会被自动删除。\n添加方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在博客根目录的\u003ccode\u003esource\u003c/code\u003e文件夹下新建\u003ccode\u003eREADME.md\u003c/code\u003e文件\u003c/li\u003e\n\u003cli\u003e在根目录的\u003ccode\u003e_config.yml\u003c/code\u003e文件中搜索\u003ccode\u003eskip_render\u003c/code\u003e，并做如下更改\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yml\" data-lang=\"yml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eskip_render\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eREADME.md\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e因为在每次\u003ccode\u003ehexo g\u003c/code\u003e时候，README 文件都会被自动渲染为 HTML 文件，所以在配置文件中告诉渲染器跳过这个文件不要渲染它。\u003c/p\u003e","title":"Hexo 搭建 GitHub 博客如何添加 README 文件"},{"content":"QEMU 学习记录 什么是 KVM？ 基于内核的虚拟机 Kernel-based Virtual Machine（KVM）是一种内建于 Linux 中的开源虚拟化技术。具体而言，KVM 可帮助用户将 Linux 转变为虚拟机监控程序，使主机计算机能够运行多个隔离的虚拟环境，即虚拟客户机或虚拟机（VM）。\n什么是 QEMU？ Qemu 是一个完整的可以单独运行的软件，它可以用来模拟不同架构的机器，非常灵活和可移植。它主要通过一个特殊的\u0026rsquo;重编译器\u0026rsquo;将为特定处理器编写二进制代码转换为另一种。\nKVM 与 QEMU 的关系 KVM 是 Linux 的一个模块。可以用modprobe去加载 KVM 模块。加载了模块后，才能进一步通过其他工具创建虚拟机。但仅有 KVM 模块是 远远不够的，因为用户无法直接控制内核模块去作事情：还必须有一个用户空间的工具才行。这个用户空间的工具，开发者选择了已经成型的开源虚拟化软件 QEMU。KVM 使用了 QEMU 的一部分，并稍加改造，就成了可控制 KVM 的用户空间工具了。所以你会看到，官方提供的 KVM 下载有两 大部分三个文件，分别是 KVM 模块、QEMU 工具以及二者的合集。也就是说，你可以只升级 KVM 模块，也可以只升级 QEMU 工具。\nQEMU 用户模式与系统模式 QEMU 属于应用层的仿真程序，它支持两种操作模式：用户模式模拟和系统模式模拟。\n用户模式仿真 利用动态代码翻译机制，可以在当前 CPU 上执行被编译为支持其他 CPU 的程序，如可以在 x86 机器上执行一个 ARM 二进制可执行程序。（执行主机 CPU 指令的动态翻译并相应地转换 Linux 系统调用）。 系统模式仿真 利用其它 VMM(Xen, KVM) 来使用硬件提供的虚拟化支持，创建接近于主机性能的全功能虚拟机，包括处理器和配套的外围设备（磁盘，以太网等）。 用户模式 支持的 CPU：x86 (32 and 64 bit), PowerPC (32 and 64 bit), ARM, MIPS (32 bit only), Sparc (32 and 64 bit), Alpha, ColdFire(m68k), CRISv32 和 MicroBlaze 下列操作系统支持 QEMU 的用户模式模拟：\nLinux (referred as qemu-linux-user) BSD (referred as qemu-bsd-user) 调用（具体参数含义）\nqemu-i386 [-h] [-d] [-L path] [-s size] [-cpu model] [-g port] [-B offset] [-R size] program [arguments...] 用户模式模拟环境下运行速度要比系统模式模拟环境下快，但并不是完美模拟，比如程序读取/proc/cpuinfo内容时，由主机内核返回，因此返回的信息是描述主机 CPU 的，而不是模拟的 CPU。\n系统模式 首先创建虚拟镜像，模拟硬盘空间：\nroot@hanhan:/home/dominic/qemu/# qemu-img create -f qcow2 qmtest.img 10G Formatting \u0026#39;qmtest.img\u0026#39;, fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off root@hanhan:/home/dominic/qemu/# ls qmtest.img -f选项用于指定镜像的格式，qcow2格式是 QEMU 最常用的镜像格式，采用写时复制技术来优化性能。qmtest.img是镜像文件的名字，10G是镜像文件大小。\n镜像文件创建完成后，可使用qemu-system-x86来启动x86架构的虚拟机：\nqemu-system-x86_64 qmtest.img qmtest.img 中还未安装操作系统，所以会提示“No bootable device”的错误。\n其次，准备操作系统镜像 下载需要的 Linux 发行版镜像文件，https://launchpad.net/ubuntu/+cdmirrors，找到想要下载的镜像，这里以交通大学的镜像为例 右击链接复制地址：https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso\nroot@hanhan:/home/dominic/qemu/# wget https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso 最后，启动虚拟机安装操作系统\nroot@hanhan:/home/dominic/qemu/# qemu-system-x86_64 -m 2048 -enable-kvm qmtest.img -cdrom ./Fedora-Live-Desktop-x86_64-20-1.iso -m指定虚拟机内存大小，默认单位是 MB，-enable-kvm使用 KVM 进行加速，-cdrom添加 fedora 的安装镜像。\n该模式下，要比用户模式模拟慢得多，因为模拟了目标内核，以及设备输入/输出、中断等。\nQEMU 工作原理 \u003c!DOCTYPE html\u003e Responsive Image 单纯使用 qemu，采用的是完全虚拟化的模式。qemu 向 Guest OS 模拟 CPU，也模拟其他的硬件，GuestOS 认为自己和硬件直接打交道，其实是同 qemu 模拟出来的硬件打交道，qemu 会将这些指令转译给真正的硬件。由于所有的指令都要从 qemu 里面过一手，因而性能就会比较差。\n完全虚拟化是非常慢的，所以要使用硬件辅助虚拟化技术 Intel-VT，AMD-V，所以需要 CPU 硬件开启这个标志位，一般在 BIOS 里面设置。当确认开始了标志位之后，通过KVM，GuestOS 的 CPU 指令不用经过 Qemu 转译，直接运行，大大提高了速度。所以，KVM 在内核里面需要有一个模块，来设置当前 CPU 是 Guest OS 在用，还是 Host OS 在用。\n可以通过如下命令查看内核模块中是否有 KVM\nlsmod | grep kvm KVM 内核模块通过 /dev/kvm 暴露接口，用户态程序可以通过 ioctl来访问这个接口。Qemu 将 KVM 整合进来，将有关 CPU 指令的部分交由内核模块来做，就是 qemu-kvm (qemu-system-XXX)。\nqemu 和 kvm 整合之后，CPU 的性能问题解决了。另外 Qemu 还会模拟其他的硬件，如网络和硬盘。同样，全虚拟化的方式也会影响这些设备的性能。\n于是，qemu 采取半虚拟化的方式，让 Guest OS 加载特殊的驱动来做这件事情。\n例如，网络需要加载 virtio_net，存储需要加载 virtio_blk，Guest 需要安装这些半虚拟化驱动，GuestOS 知道自己是虚拟机，所以数据会直接发送给半虚拟化设备，经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。\nQ : 系统模式和用户模式的区别？ 系统模式 是 qemu 虚拟出一套完整的硬件环境，包含 CPU，内存，网卡，硬盘，对于虚拟机上运行的 OS 看到的和硬件和真实的是一样的。 用户模式是直接将可执行的文件进行指令翻译，只虚拟出 CPU。 假设有 KVM：host 是 x86，QEMU 虚拟出 x86 的系统模式 运行 Windows 系统。QEMU 会将 Windows 指令直接交给 host CPU 直接运行（这个功能是由 KVM 实现的，相当于直接调用 host CPU），性能损失小。内存，硬盘，网络等外设是由 qemu 虚拟出来的。 假设无 KVM：host 是 x86，QEMU 虚拟出 x86 的系统模式运行 Windows 系统。QEMU 会将 Windows 指令翻译成中间码，中间码再转成 host CPU 指令（这个功能是由 qemu TCG 实现的），性能损失大。内存，硬盘，网洛等外设是由 qemu 虚拟出来的。 假设有 KVM：host 是 x86，QEMU 虚拟出 RISC-V 的系统模式 运行 Linux 系统。QEMU 会将 Linux 指令翻译成中间码，中间码再转成 host CPU 指令（这个功能是由 qemu TCG 实现的），性能损失大。内存，硬盘，网洛等外设是由 qemu 虚拟出来的。 KVM 需要在虚拟机与宿主机架构相同时才生效。 此外，用户模式下调用 IO 硬件会报错。qemu 系统模式下会模拟出所有设备，但是模拟的 IO 设备效率低，所以后来有了半虚拟化。\n","permalink":"https://lifeislife.cn/posts/qemu%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","summary":"\u003ch1 id=\"qemu-学习记录\"\u003eQEMU 学习记录\u003c/h1\u003e\n\u003ch2 id=\"什么是-kvm\"\u003e什么是 KVM？\u003c/h2\u003e\n\u003cp\u003e基于内核的虚拟机 \u003ccode\u003eKernel-based Virtual Machine（KVM）\u003c/code\u003e是一种内建于 Linux 中的开源虚拟化技术。具体而言，\u003ccode\u003eKVM\u003c/code\u003e 可帮助用户将 Linux 转变为虚拟机监控程序，使主机计算机能够运行多个隔离的虚拟环境，即虚拟客户机或虚拟机（VM）。\u003c/p\u003e","title":"QEMU 学习记录"},{"content":"Unix 是什么，为什么重要？ Author：CHRIS HOFFMAN 译：What Is Unix, and Why Does It Matter?\n大多数操作系统都可以分为两大类。除了微软基于 Windows NT 的操作系统之外，几乎所有其他系统的祖宗都是 Unix。\nLinux、Mac OS X、Android、iOS、Chrome OS、PlayStation 4 上使用的 Orbis 操作系统，无论路由器上运行的是什么固件——所有这些操作系统通常都被称为“类 Unix”操作系统。\nUnix 的设计延续至今 19 世纪中后期 Unix 在贝尔实验室中被开发出来。最初版的 Unix 有许多重要的设计特性至今仍然在使用。\n“Unix 哲学”之一就是，创建小型、模块化的程序，一个程序只做一件事并把它做好。如果你经常使用 Linux 终端，那么你应该对此很熟悉——系统提供了许多实用程序，这些程序可以通过管道和其他功能以不同方式组合以执行更复杂的任务。甚至图形程序也可能在后台调用更简单的实用程序来完成复杂的工作。这也使得创建 shell 脚本变得容易，将简单的工具串在一起来完成复杂的事情。\nUnix 有一个程序之间通信用的单一文件系统。这就是为什么在 Linux 上“一切都是文件” ——包括硬件设备和提供系统信息或其他数据的特殊文件。这也是为什么只有 Windows 有驱动器号（C、D、E 盘）的原因，它是从 DOS 继承的——在其他操作系统上，系统上的每个文件都是单个目录层次结构的一部分。\n追寻 Unix 的后代 Unix 及其后代的历史错综复杂，简化起见，我们大致将 Unix 的后代分为两类。\n一类 Unix 后代是在学术界发展起来的。第一个是 BSD（BerkeleySoftwareDistribution），一个开源、类 Unix 操作系统。BSD 通过 FreeBSD、NetBSD 和 OpenBSD 延续至今。NeXTStep 也是基于最初的 BSD 开发的，Apple 的 Mac OS X 是基于 NeXTStep 开发出来的，而 iOS 则基于 Mac OS X。还有一些操作系统，包括 PlayStation 4 上使用的 Orbis OS，都是从 BSD 操作系统衍生而来的。\nRichard Stallman 的 GNU 项目也是为了应对 AT\u0026amp;T 日益严格的 Unix 软件许可条款而启动的。MINIX 是一个为教育目的而创建的类 Unix 操作系统，Linux 的灵感来自于 MINIX。我们今天所知道的 Linux 实际上是 GNU/Linux，因为它由 Linux 内核和许多 GNU 实用程序组成。GNU/Linux 并非直接继承自 BSD，但它继承了 Unix 的设计并植根于学术界。当今的许多操作系统，包括 Android、ChromeOS、SteamOS 以及大量设备的嵌入式操作系统，都基于 Linux。\n另一类就是商业 Unix 操作系统。AT\u0026amp;T UNIX、SCO UnixWare、Sun Microsystems Solaris、HP-UX、IBM AIX、SGI IRIX——许多大公司想要创建他们自己的 Unix 版本。这些在今天并不常见，但其中一些仍然存在。\nDOS 和 Windows NT 的崛起 许多人期望 Unix 成为行业标准操作系统，但 DOS 系统和“IBM PC 兼容”的计算机最终流行起来。Microsoft 的 DOS 成为其中最成功的 DOS 系统。DOS 系统完全不同于 Unix，这就是为什么 Windows 使用反斜杠作为文件路径，而其他一切都使用正斜杠。这个决定是在 DOS 系统早期做出的，后来的 Windows 版本继承了它，就像 BSD、Linux、Mac OS X 和其他类 Unix 操作系统继承了许多 Unix 的设计一样。\nWindows 3.1、Windows 95、Windows 98 和 Windows ME 都基于底层的 DOS。当时，微软正在开发一种更现代、更稳定的操作系统，他们将其命名为 Windows NT——即“Windows New Technology”。Windows NT 最终以 Windows XP 的形式出现在普通用户的计算机中，但在此之前，它以 Windows 2000 和 Windows NT 的形式供公司使用。\n今天，微软的所有操作系统都基于 Windows NT 内核。Windows 7、Windows 8、Windows RT、Windows Phone 8、Windows Server 和 Xbox One 的操作系统都使用 Windows NT 内核。与大多数其他操作系统不同，Windows NT 并不是作为类 Unix 操作系统开发的。\n当然，微软并不是完全重新开始。为了保持与 DOS 和旧的 Windows 软件的兼容性，Windows NT 继承了许多 DOS 约定，如驱动器号、文件路径的反斜杠和命令行的正斜杠。\n“在绝大多数地方，用的都是/（slash），包括 Mac/Linux，也包括 URL。你唯一需要记住的是，Microsoft 这个怪鸡在自己的操作系统里面偏要用\\（backslash），使得自己与众不同。 在 Windows 中，正斜杠/表示除法，用来进行整除运算；反斜杠\\用来表示目录。 在 Unix 系统中，/表示目录；\\表示跳脱字符将特殊字符变成一般字符 Windows由于使用斜杠/作为DOS命令提示符的参数标志了，为了不混淆，所以采用反斜杠\\作为路径分隔符。所以目前windows系统上的文件浏览器都是用反斜杠\\作为路径分隔符。\n为什么重要？ 你是否曾经看过 Mac OS X 终端或文件系统，并注意到它与 Linux 的相似之处，以及它们与 Windows 的不同之处？嗯，这就是为什么——Mac OSX 和 Linux 都是类 Unix 操作系统。\n了解这段历史有助于您了解什么是“类 Unix”操作系统，以及为什么这么多操作系统看起来彼此如此相似而 Windows 似乎如此不同。这解释了为什么 Linux 极客会觉得 Mac OS X 上的终端如此熟悉，而 Windows 上的命令提示符和 PowerShell 与其他命令行环境如此不同。\n这只是一个简短的历史，它将帮助您了解我们如何到达今天的位置，而不会陷入细节中。如果您想了解更多信息，可以找到有关 Unix 历史的整本书。\n","permalink":"https://lifeislife.cn/posts/zh-unix%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81/","summary":"\u003ch1 id=\"unix-是什么为什么重要\"\u003eUnix 是什么，为什么重要？\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAuthor：CHRIS HOFFMAN\n译：\u003ca href=\"https://www.howtogeek.com/182649/htg-explains-what-is-unix/\"\u003eWhat Is Unix, and Why Does It Matter?\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e大多数操作系统都可以分为两大类。除了微软基于 Windows NT 的操作系统之外，几乎所有其他系统的祖宗都是 Unix。\u003c/p\u003e","title":"ZH-Unix 是什么，为什么重要？"},{"content":"在项目目录下安装 hexo-browsersync 插件\nnpm install hexo-browsersync --save hexo s启动服务后，每次保存 Markdown 文件都会实时更新页面。\n","permalink":"https://lifeislife.cn/posts/hexo%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E9%A2%84%E8%A7%88/","summary":"\u003cp\u003e在项目目录下安装 \u003ccode\u003ehexo-browsersync\u003c/code\u003e 插件\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm install hexo-browsersync --save\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003ehexo s\u003c/code\u003e启动服务后，每次保存 Markdown 文件都会实时更新页面。\u003c/p\u003e","title":"Hexo 实时更新预览"},{"content":"只要有source文件夹下所有源文件就可以重新部署，按照正常的搭建 Hexo 环境开始搭建，搭建好以后将source文件夹替换即可，需要应用主题就下载主题然后替换。\n注意：\n主题更换需要更改_config_yml文件 _config_yml文件中的部署配置，branch:master就是每次hexo d操作推送的分支。而在命令行每次git push推送的分支是设置的默认分支hexo deploy: type: git repository: https://github.com/Dunky-Z/Dunky-Z.github.io.git branch: master 利用 Hexo 在多台电脑上提交和更新 GitHub pages 博客 ","permalink":"https://lifeislife.cn/posts/hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E5%8D%9A%E5%AE%A2/","summary":"\u003cp\u003e只要有\u003ccode\u003esource\u003c/code\u003e文件夹下所有源文件就可以重新部署，按照正常的搭建 Hexo 环境开始搭建，搭建好以后将\u003ccode\u003esource\u003c/code\u003e文件夹替换即可，需要应用主题就下载主题然后替换。\u003c/p\u003e","title":"Hexo 和 GitHub 搭建博客以及更换电脑同步博客"},{"content":"这是博客的第一篇文章\n","permalink":"https://lifeislife.cn/posts/helloworld/","summary":"\u003cp\u003e这是博客的第一篇文章\u003c/p\u003e","title":"HelloWorld"}]