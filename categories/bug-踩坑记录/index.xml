<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Bug 踩坑记录 on PaperMod</title>
    <link>http://localhost:8888/categories/bug-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</link>
    <description>Recent content in Bug 踩坑记录 on PaperMod</description>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Sat, 02 Mar 2024 22:21:23 +0000</lastBuildDate>
    <atom:link href="http://localhost:8888/categories/bug-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解决系统依赖错误GLIBCXX_3.4.29 not found</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3%E7%B3%BB%E7%BB%9F%E4%BE%9D%E8%B5%96%E9%94%99%E8%AF%AFglibcxx-3-4-29-not-found/</link>
      <pubDate>Sat, 02 Mar 2024 22:21:23 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3%E7%B3%BB%E7%BB%9F%E4%BE%9D%E8%B5%96%E9%94%99%E8%AF%AFglibcxx-3-4-29-not-found/</guid>
      <description>以前对软件包的构建不太了解，喜欢随意修改软件源列表，软件源和当前系统的版本不一致就会出现安装了一个依赖较多的软件包后会出现连锁反应，修改了所有依赖的软件包版本，导致系统故障。最常出现的就是修改了GCC版本，导致GLIBCXX版本不一致，导致系统软件无法运行。
如果你的系统还能正常安装软件，那么修改软件源和当前系统版本保存一致，然后更新软件，并重新安装GCC即可解决问题。具体步骤如下：
# 修改软件源 sudo vim /etc/apt/sources.list # 检查当前系统版本 lsb_release -a # 将软件源修改为当前系统版本的软件源，Ubuntu系统版本号对应的软件源列表可以在https://wiki.ubuntu.com/Releases查看 # 更新软件 sudo apt update # 安装GCC，build-essential包含了GCC sudo apt install build-essential 如果你和我一样倒霉，连 apt 都无法使用，那么可以使用 dpkg 命令手动安装 GCC。
因为误操作在 Ubuntu 20.04 上安装了 Ubuntu 18.04 的 GCC，导致系统软件无法运行，apt 也无法使用，所以只能手动安装 GCC。
apt: libx86_64-linux-gnu-libstdc++.so.6: version `GLIBCXX_3.4.29&amp;#39; not found (required by libx86_64-linux-gnulibapt-private.so.0.0) 既然libstdc++版本不一致，我们就去下载对应版本的GCC，访问https://packages.ubuntu.com/，在下方的搜索框中输入libstdc++6，选择对应的系统版本，然后下载对应的GCC。
点击搜索结果，点击系统的架构，一般为amd64，
具体下载地址比较隐蔽，直接点击红框的链接没有反应，你可以右键另存为到本地，我习惯复制链接后用wget下载。
下载完成后，使用dpkg命令安装GCC。
sudo dpkg -i libstdc++6_12.3.0-1ubuntu1\~22.04_amd64.deb 之后可以检查一下缺失的GLIBCXX版本已经安装。
$ strings /lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX GLIBCXX_3.4 GLIBCXX_3.4.1 GLIBCXX_3.4.2 GLIBCXX_3.4.3 GLIBCXX_3.4.4 GLIBCXX_3.4.5 GLIBCXX_3.</description>
    </item>
    <item>
      <title>VirtualBox Ubuntu 无法联网</title>
      <link>http://localhost:8888/posts/virtualbox-ubuntu%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/</link>
      <pubDate>Mon, 26 Jun 2023 22:38:02 +0000</pubDate>
      <guid>http://localhost:8888/posts/virtualbox-ubuntu%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/</guid>
      <description>解决方案 VirtualBox Ubuntu 无法联网，重启后可以联网但是几分钟后断开网络。笔者的情况是因为 NetworkManager 自动修改了网络配置导致无法联网，具体现象是开机后网卡信息如下：
user@allone:~$ ifconfig brq64ff9b38-fa: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt; mtu 1500 ether ce:29:de:12:35:06 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 enp0s3: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt; mtu 1500 inet 10.0.2.15 netmask 255.255.255.0 broadcast 10.0.2.255 inet6 fe80::2e8f:2be6:3752:dec4 prefixlen 64 scopeid 0x20&amp;lt;link&amp;gt; ether 08:00:27:18:31:21 txqueuelen 1000 (Ethernet) RX packets 947 bytes 584483 (584.</description>
    </item>
    <item>
      <title>解决 VSCode 远程登录失败 Error: WebSocket close with status code 1006</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3vscode%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5error-websocket-close-with-status-code-1006/</link>
      <pubDate>Sat, 15 Oct 2022 18:53:20 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3vscode%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5error-websocket-close-with-status-code-1006/</guid>
      <description>保留现场 使用 VSCode 远程登录失败，报错：Failed to connect to the remote extension host server (Error: WebSocket close with status code 1006)。
解决方法 vim /etc/ssh/sshd_config AllowTcpForwarding no AllowAgentForwarding no # 替换为 AllowTcpForwarding yes AllowAgentForwarding yes 保存后重启 sshd 服务：
systemctl restart sshd </description>
    </item>
    <item>
      <title>解决 Pandoc 将 MD 转换为 PDF 时报错 (error)\tightlist</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3pandoc%E5%B0%86md%E8%BD%AC%E6%8D%A2%E4%B8%BApdf%E6%97%B6%E6%8A%A5%E9%94%99-error-tightlist/</link>
      <pubDate>Sat, 24 Sep 2022 17:27:00 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3pandoc%E5%B0%86md%E8%BD%AC%E6%8D%A2%E4%B8%BApdf%E6%97%B6%E6%8A%A5%E9%94%99-error-tightlist/</guid>
      <description>使用 Pandoc 将test.md转换位 PDF 时，出现如下错误：
! Undefined control sequence. &amp;lt;recently read&amp;gt; \tightlist l.213 \end{frame} pandoc: Error producing PDF from TeX source make: *** [test.pdf] Error 43 这是因为在 Markdown 文件中使用-表示无序列表，被转化成了\tightlist但是 Pandoc 版本太老，不支持这个命令。（严格来说是 Pandoc 没有处理这个 LaTeX 命令，不是不支持，因为这是 LaTeX 命令和 Pandoc 没关系）。
有两种方式解决，一是升级 Pandoc 版本，二是将处理\tightlist的命令加到自己使用的模板中。
\providecommand{\tightlist}{% \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}} 或者
\def\tightlist{} </description>
    </item>
    <item>
      <title>解决 Linux 终端回车键变成字符 M</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E9%94%AE%E5%8F%98%E6%88%90%E5%AD%97%E7%AC%A6m/</link>
      <pubDate>Mon, 12 Sep 2022 14:52:12 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E9%94%AE%E5%8F%98%E6%88%90%E5%AD%97%E7%AC%A6m/</guid>
      <description>保留现场 解决方法 命令行执行
stty sane </description>
    </item>
    <item>
      <title>解决 Python No module named &#39;ConfigParser&#39;</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3python-no-module-named-configparser/</link>
      <pubDate>Sun, 11 Sep 2022 23:20:05 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3python-no-module-named-configparser/</guid>
      <description>保留现场 ImportError: No module named &amp;#39;ConfigParser&amp;#39; Command &amp;#34;python setup.py egg_info&amp;#34; failed with error code 1 in 解决方法 在 Python 3.x 版本后，ConfigParser.py 已经更名为 configparser.py 所以出错！
可以切换 Python2 执行。
也可以尝试将文件重命名为ConfigParser.py。
以下为参考，每个人安装路径可能不一样，可以全局搜索configparser.py。
cp /usr/lib/python3.7/configparser.py /usr/lib/python3.7/ConfigParser.py </description>
    </item>
    <item>
      <title>解决 LaTeX 编译 Missing character There is no (U&#43;00A0) in font</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3latex%E7%BC%96%E8%AF%91missing-character-there-is-no-u-00a0-u-00a0-in-font/</link>
      <pubDate>Sun, 11 Sep 2022 22:20:02 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3latex%E7%BC%96%E8%AF%91missing-character-there-is-no-u-00a0-u-00a0-in-font/</guid>
      <description>保留现场 在 LaTeX 编译中报错：Missing character: There is no (U+00A0) (U+00A0) in font JetBrains Mono。
探究原因 如果要搞清楚具体原因，就得从字符与字符编码说起了。解决办法直接跳到下一节吧。
字符，就是“a”，“A”，“你”等书写符号。
字符集，通常就是某种语言字符集合，比如英语就是ASCII 字符集，中文有GBK 字符集等
注意，不是每种语言只对应一种字符集（比如 GB2312，GBK，GB18030 都包含了常用汉字，后者是前者的超集），而且字符集也不是只对应一种语言，例如 Unicode 字符集就包含所有语言字符，字符集只是设计者为了给字符编码（Code Point/Numbering）设计编码时，为了收录到命名的字符集合，但是通常设计者都为字符集设计了对应的编码规范。
字符编码,给字符集里的字符编号。
编码页，在 unicode 发明之前，各个地区都用 2 字节编码自己的字符集，相同的编码对应不同的字符，为了本地化，Windows 发明了编码页，来对应不同的字符集。
字符编码，对给定的字符编码编码成字节表示。
早期，字符被编号后，存储时就按照编号的方式存储，没有 encoding 的过程，后来发明 Unicode 后，发现如果按照 Unicode 的编号直接存储的话，对于英文字符就有很大存储浪费，因为任意字符都需要 2 字节存储，后来人们发明 UTF-8 这种编码方式，这样 UTF-8 就可以一个字节表示英文字符，2 个以上字节表示汉字字符。
字体，定义了字符的图形表示，现在的软件展示字符时用 Unicode 表示，字体是 Unicode 编码和字符图形的映射，而以往比如 WindowsCMD 控制台，没有对应 Unicode，则用编码页来区分，所以字体就是字符编码金和代码页到字符图形的映射。
文本文件存储在磁盘上，都是一系列的字节流，如果不告诉文本编辑器该文件的编码方式，编辑器会尝试用默认的编码（依赖于操作系统设置）又或者自己探测（detect，比如文件开头有 FFEF 或者 EFFF 字节就表明 UTF-16 编码，有很多 10，110 开头的字节，很可能是 UTF-8 编码）并尝试解码，如果没有猜对，那就会显示乱码。
回到出错的问题，提示我们在字体 JetBrains Mono中没有U+00A0，我们搜索一下就知道这是一个 Unicode 字符NO-BREAK SPACE。我们通过上面的了解也知道了，字体就是字符编码到字符图像的映射，但是一个字体尤其是一些有专门用途的字体（比如 JetBrains Mono 设计初衷是为软件工程显示代码用的），它不会映射所有的字符，JetBrains Mono 这个字体里就没有映射 U+00A0。这就导致在 LaTeX 编译时无法在字体中找到对应的字符图像显示。</description>
    </item>
    <item>
      <title>解决 Unable to 加载 picture or PDF file</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3unable-to-load-picture-or-pdf-file/</link>
      <pubDate>Fri, 26 Aug 2022 19:22:24 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3unable-to-load-picture-or-pdf-file/</guid>
      <description>保留现场 Unable to load picture or PDF file &amp;#39;xxxxxx&amp;#39; &amp;lt;to be read again&amp;gt; xxxx 探究原因 图片链接错误，转换 PDF 过程中会先下载所有图片到AppData/Local/Temp/tex2pdf.****文件夹里，因为无法正常下载图片，所有报错。检查图片链接是否有效。
解决方法 检查图片链接是否有效。</description>
    </item>
    <item>
      <title>解决 cast from pointer to integer of different size</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3cast-from-pointer-to-integer-of-different-size/</link>
      <pubDate>Tue, 16 Aug 2022 11:42:24 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3cast-from-pointer-to-integer-of-different-size/</guid>
      <description>保留现场 void* foo(void *dst, ...) { // some code unsigned int offset = (unsigned int) dst % 8; // warning here! // some code continue... } 写驱动程序时经常会直接对地址进行修改，配置寄存器的值，也会将地址的值作为数据进行传递，这就会遇到一个问题，指针强转成整型，类型不匹配数据丢失的问题。
探究原因 出现这个警告的原因是，将void*类型强转成unsigned int是不可移植的。什么叫不可移植呢？
我们知道指针类型，在 32 位系统下是 4 字节，在 64 位系统下是 8 字节，而unsigned int不管在什么系统下都是是 4 字节，所以，如果将void*类型强转成unsigned int，在 64 位系统下就没有足够的空间保存真正的数据。
解决方法 粗暴地用double来接收 先接收，再截断：
void* foo(void *dst, ...) { // some code unsigned int offset = (unsigned int)(unsigned double) dst % 8; // warning here! // some code continue.</description>
    </item>
    <item>
      <title>解决提交 gerrit missing Change-Id</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BA%A4gerrit-missing-change-id/</link>
      <pubDate>Sat, 30 Jul 2022 15:05:48 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BA%A4gerrit-missing-change-id/</guid>
      <description>保留现场 remote: Resolving deltas: 100% (114/114) remote: Processing changes: refs: 1,done remote: ERROR: missing Change-Idincommit message footer remote: remote: Hint: To automatically insert Change-Id,installthe hook: remote: gitdir=$(git rev-parse --git-dir);scp-p -P XX XX@gerrit.xxxxx.com:hooks/commit-msg${gitdir}/hooks/ remote: And then amend the commit: remote: git commit --amend 探究原因 理解 change-id 代码审核是要对一个完整的变更进行审核，比如一次 Bug 修复，有多次提交 Commit，每次的 Commit Id 都不同，那么如何将多个不同的 Commit ID 关联到同一个 Chanege-Id 呢？我们需要将 Change-Id 添加到 Commit 的 footer（最后一行）中，这样就可以将多个 Commit 关联到同一个 Change-Id 了。
Change-Id 为避免与提交 Id 冲突，通常以大写字母 I 为前缀。此外，我们需要明确，Change-Id 是 Gerrit 的概念，不是 Git 的概念。你只有用 Gerrit 才会有 Change-Id，而 Git 只有提交 Id。</description>
    </item>
    <item>
      <title>解决 VS Code 终端使用 git bash 时中文乱码</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3vs-code%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8git-bash%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Sat, 16 Jul 2022 21:59:50 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3vs-code%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8git-bash%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</guid>
      <description>保留现场 Windows 环境下，使用 VSCode 的终端时，中文显示为乱码，如使用git status命令查看修改文件时，中文文件名就无法正常显示： 探究原因 因为终端被替换成了 git bash，它对所有非英文的字符进行了转义。
官方文档提到：
输出路径的命令（例如ls-files、diff）将通过将路径名括在双引号中并以与 C 转义控制字符相同的方式用反斜杠转义这些字符来引用路径名中的异常字符（例如\t用于 TAB, \n 表示LF，\\表示反斜杠）或值大于 0x80 的字节（例如，八进制 \302\265 表示 UTF-8 中的“micro”）。如果此变量设置为 false，则高于 0x80 的字节不再被视为异常。无论此变量的设置如何，双引号、反斜杠和控制字符总是被转义。一个简单的空格字符不被认为是异常的。许多命令可以使用 -z 选项完全逐字输出路径名。默认值是 true。
解决方法 命令行输入，取消转义：
git config --global core.quotepath false </description>
    </item>
    <item>
      <title>解决 OpenSSL SSL_read: Connection was reset, errno 10054</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3openssl-ssl-read-connection-was-reset-errno-10054/</link>
      <pubDate>Wed, 16 Feb 2022 11:12:31 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3openssl-ssl-read-connection-was-reset-errno-10054/</guid>
      <description>解决方法 方法一：
git config --global http.sslVerify &amp;#34;false&amp;#34; 方法二：
git config --global https.sslVerify &amp;#34;false&amp;#34; 方法三： 这可能是因为版本库的大小和 git 的默认缓冲区大小，所以通过下述操作（在 git bash 上），git 的缓冲区大小会增加。
//在仓库init后，添加以下配置git config http.postBuffer 524288000//如果仓库不是自己的，可以添加以下配置git config --global http.postBuffer 524288000 方法四： 网速太慢，换个网速快的环境。
Reference windows - git clone error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 - Stack Overflow 解决 OpenSSL SSL_read: Connection was reset, errno 10054 問題</description>
    </item>
    <item>
      <title>解决 ssh permission denied(publickey)</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3git-ssh-permission-deniedpublickey/</link>
      <pubDate>Thu, 13 Jan 2022 22:43:02 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3git-ssh-permission-deniedpublickey/</guid>
      <description>保留现场 linux&amp;gt; ssh -p 2221 xxx@gerrit.com xxx@gerrit.com: Permission denied(publickey) 探究原因 本次出错是在测试是否能连接 gerrit 时。连接 GitHub 也可能会出现。只要用到 ssh 功能的都有可能。
出错的原因：
网页（如 gerrit,github）没有设置公钥，一般为id_rsa.pub内容； 本地生成了多个公私钥，配对配错了； 本地没有配置好git，比如git config时用户名或者邮箱填错； 需要开启 ssh 代理； 解决方法 生成密钥cd ~/.ssh &amp;amp;&amp;amp; ssh-keygen 复制公钥内容，添加到网页中github或者gerrit的设置里。cat id_rsa.pub | xclip 配置git账户 git config --global user.name &amp;quot;bob&amp;quot; git config --global user.email bob@... 以上检查无误，仍然报错
开启ssh代理 eval $(ssh-agent -s) 将私钥加入代理 ssh-add ~/.ssh/id_rsa 登陆用户时启动 ssh-agent 如果不幸你的问题就是需要开启ssh-agent，那么每次重启电脑都需要开启一次。这也是相当麻烦的，可以通过将以下配置添加到~/.bashrc中，让 Linux 启动时自动开启ssh-agent。
# Add following code at the end of ~/.bashrc # Check if ~/.</description>
    </item>
    <item>
      <title>解决 unable to install libpng12.so.0</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3unable-to-install-libpng12-so-0/</link>
      <pubDate>Wed, 05 Jan 2022 13:01:47 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3unable-to-install-libpng12-so-0/</guid>
      <description>保留现场 apt工具损坏了，在修复时使用了sudo apt-get install -f命令，中途会提示需要安装libpng12-0，但是始终无法安装，会提示如下错误。
Unpacking libpng12-0:amd64 (1.2.50-2+deb8u3) ... dpkg: error processing archive libpng12-0_1.2.50-2+deb8u3_amd64.deb (--install): unable to install new version of &amp;#39;/usr/lib/ x86_64-linux-gnu/libpng12.so.0&amp;#39;: No such file or directory Errors were encountered while processing: libpng12-0_1.2.50-2 +deb8u3_amd64.deb 探究原因 具体原因未知，网上答案众说纷纭。
解决方法 这个问题遇到的人还挺多的，解决方法也各不相同，我先说我自己最终解决的方法。
方法一 将软件源更换成中科院的源，使用 Linux 自带的软件和更新工具，具体方法参考这篇文章。更换完之后可以重新尝试安装，有人换源后即可成功安装。
如果未能安装成功，可能曾经手动添加过软件源，将其删除。
# 将所有内容注释vim /etc/apt/sources.list 方法二 下载已安装的库文件libpng12.so.0，可以从该链接下载。
将该文件复制到它本该安装的位置。
sudo cp libpng12.so.0 /usr/lib/x86_64-linux-gnu/ 方法三 sudo add-apt-repository ppa:linuxuprising/libpng12sudo apt updatesudo apt install libpng12-0 </description>
    </item>
    <item>
      <title>解决 Qt-QObject::connect: Cannot queue arguments of type‘QTextCursor’错误</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt-qobject-connect-cannot-queue-arguments-of-type-qtextcursor%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sat, 04 Dec 2021 11:41:46 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt-qobject-connect-cannot-queue-arguments-of-type-qtextcursor%E9%94%99%E8%AF%AF/</guid>
      <description>保留现场 我在线程中直接调用了 QTextEdit 的 append 函数时，候就会出现下面的错误：
QObject::connect: Cannot queue arguments of type &amp;#39;QTextCursor&amp;#39; (Make sure &amp;#39;QTextCursor&amp;#39; is registered using qRegisterMetaType().) 探究原因 原因是我们不能通过线程来修改 UI，较为安全的修改用户界面的方式是向 UI 窗口发送信号 (signal)，较为简单的方式是使用 Qt threading 类。
解决方法 在窗口类中定义信号和槽，并声明和实现一个接口函数，这个接口函数由线程调用，在接口函数中 emit 一个信号，示例代码如下：
//mainwindow.h signals: void AppendText(const QString &amp;amp;text); private slots: void SlotAppendText(const QString &amp;amp;text); public: void Append(const QString &amp;amp;text); //mainwindow.cpp connect(this,SIGNAL(AppendText(QString)),this,SLOT(SlotAppendText(QString))); void ClassName::Append(const QString &amp;amp;text) { emit AppendText(&amp;#34;ok: string1&amp;#34;); } //thread.cpp void ThreadClassName::SlotAppendText(const QString &amp;amp;text) { mText.append(text); } </description>
    </item>
    <item>
      <title>解决 Linux 启动出现 fsck exited with status code 4</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3linux%E5%90%AF%E5%8A%A8%E5%87%BA%E7%8E%B0fsck-exited-with-status-code-4/</link>
      <pubDate>Sat, 04 Dec 2021 10:18:09 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3linux%E5%90%AF%E5%8A%A8%E5%87%BA%E7%8E%B0fsck-exited-with-status-code-4/</guid>
      <description>保留现场 探究原因 磁盘检测不能通过，可能是因为系统突然断电或其它未正常关闭系统导致。
解决方法 根据提示可以看到是dev/sda5这个扇区出现了异常，所以通过fsck命令修复文件系统。详细命令解释。
将sda5改为自己损坏的扇区即可，等待一段时间修复完成后，输入exit即可重启。
fsck -y /dev/sda5 </description>
    </item>
    <item>
      <title>解决 C 语言 undefined reference to pthread_join</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3c%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/</link>
      <pubDate>Wed, 17 Nov 2021 19:30:20 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3c%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/</guid>
      <description>保留现场 undefined reference to sleep同样的问题。 在使用 C 语言线程函数时，需要包含#include &amp;lt;pthread&amp;gt;，编译时就会报这种错误。
探究原因 pthread 库不是 Linux 系统默认的库，连接时需要使用静态库 libpthread.a，所以在使用pthread_create()创建线程，以及调用pthread_atfork()函数建立fork处理程序时，需要链接该库。
解决方法 gcc thread.c -o thread -lpthread 如果是Makefile配置的编译条件，在Makefile文件中加上如下：
CFLAGS += -lpthread </description>
    </item>
    <item>
      <title>解决 QT 点击按钮无响应</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%97%A0%E5%93%8D%E5%BA%94/</link>
      <pubDate>Tue, 16 Nov 2021 17:42:47 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%97%A0%E5%93%8D%E5%BA%94/</guid>
      <description>保留现场 在运行中的界面上点击按钮没有效果，像是按钮上层有其他遮盖层。
探究原因 widget的父控件上又添加了其他Widget，覆盖在了按钮上，因此无法点击。通过new得到的控件，默认显示在比它new的早的控件上面。
解决方法 // 将有按钮的那一层widget置于上层 widget-&amp;gt;raise(); </description>
    </item>
    <item>
      <title>解决 QT 在构造函数中写的控件不显示的问题</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%86%99%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 16 Nov 2021 16:15:26 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qt%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%86%99%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>保留现场 在新窗口中的构造函数中添加控件运行后却没有显示
探究原因 新建的工程师 MainWindow 子类工程，没有设置父窗口。
没有将控件的父窗口设置成自己定义的 widget。
#include&amp;lt;QMainWindow&amp;gt; QMainWindow::QMainWindow(QMainWindow*parent) : QMainWindow(parent), ui(new Ui::QMainWindow) { ui-&amp;gt;setupUi(this); QPushButton* button_1 = new QPushButton(&amp;#34;add&amp;#34;); QPushButton* button_1 = new QPushButton(&amp;#34;del&amp;#34;); } 解决方法 方法 1：给按钮控件设置父窗口：QWidget，并且把按钮添加到父窗口中。
#include&amp;lt;QMainWindow&amp;gt; #include&amp;lt;QPushButton&amp;gt; #include&amp;lt;QHBoxLayout&amp;gt; QMainWindow::QMainWindow(QMainWindow*parent) : QMainWindow(parent), ui(new Ui::QMainWindow) { ui-&amp;gt;setupUi(this); QWidget* w = new QWidget(); this-&amp;gt;setCentralWidget(w); QHBoxLayout* hLayout = new QHBoxLayout(); QPushButton* button_1 = new QPushButton(&amp;#34;add&amp;#34;); QPushButton* button_1 = new QPushButton(&amp;#34;del&amp;#34;); hLayout-&amp;gt;addWidget(button_1); hLayout-&amp;gt;addWidget(button_2); w-&amp;gt;setLayout(hLayout); } 方法 2：手动指定父窗口
#include&amp;lt;QMainWindow&amp;gt; #include&amp;lt;QPushButton&amp;gt; #include&amp;lt;QHBoxLayout&amp;gt; QMainWindow::QMainWindow(QMainWindow*parent) : QMainWindow(parent), ui(new Ui::QMainWindow) { ui-&amp;gt;setupUi(this); QPushButton* button_1 = new QPushButton(&amp;#34;add&amp;#34;); QPushButton* button_1 = new QPushButton(&amp;#34;del&amp;#34;); button_1-&amp;gt;setParent(this); button_2-&amp;gt;setParent(this); button_2-&amp;gt;move(300,100); } </description>
    </item>
    <item>
      <title>QWidget 中 update 不执行 paintEvent</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qwidget%E4%B8%ADupdate%E4%B8%8D%E6%89%A7%E8%A1%8Cpaintevent/</link>
      <pubDate>Mon, 15 Nov 2021 18:04:50 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3qwidget%E4%B8%ADupdate%E4%B8%8D%E6%89%A7%E8%A1%8Cpaintevent/</guid>
      <description>保留现场 手动执行update()或者repaint()都不能执行paintEvent函数。
探究原因 如果是代码new出来的控件，检查是否正确显示，比如有没有加入到layout中。或者有没有设置父窗口（可能被其他空间遮挡）。
检查控件width或者height大小是否不为 0。如果为 0，也不会出出发paintEvent。
解决方法 参考 QT 在构造函数中写的控件不显示</description>
    </item>
    <item>
      <title>解决 C&#43;&#43;中 vector 声明错误 expected parameter declarator</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3c-%E4%B8%ADvector%E5%A3%B0%E6%98%8E%E9%94%99%E8%AF%AFexpected-parameter-declarator/</link>
      <pubDate>Sat, 13 Nov 2021 19:00:29 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3c-%E4%B8%ADvector%E5%A3%B0%E6%98%8E%E9%94%99%E8%AF%AFexpected-parameter-declarator/</guid>
      <description>保留现场 QVector&amp;lt;uint32_t&amp;gt; buttonPins(3); 声明了一个长度为 3 的vector数组，编译是会报这个错误。
探究原因 编译器可能无法区分这是一个成员函数声明还是一个成员变量声明，也就是产生歧义。
解决方法 方法 1：
QVector&amp;lt;uint32_t&amp;gt; buttonPins = QVector&amp;lt;uint32_t&amp;gt;(3);//明确这是一个成员变量 方法 2：默认构造函数里面进行成员变量的初始化
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow),buttonPins(3){} 方法 3：列表初始化
QVector&amp;lt;uint32_t&amp;gt; buttonPins{0, 0, 0}; </description>
    </item>
    <item>
      <title>解决 expected identifier before‘(’token</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3expected-identifier-before---token/</link>
      <pubDate>Fri, 12 Nov 2021 19:34:54 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3expected-identifier-before---token/</guid>
      <description>保留现场 比如在一个枚举类型中，会告诉你某行有这种错误。又或者，在一个宏定义语句中出现这种错误。
探究原因 一般来说，出现这种情况，是语句中有些定义的名字发生了冲突。
解决方法 定位错误位置，搜索是否有同名的函数，变量等等。改个名字。</description>
    </item>
    <item>
      <title>解决 gcc 编译后 fflush 失效</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/</link>
      <pubDate>Thu, 21 Oct 2021 09:56:51 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/</guid>
      <description>保留现场 使用scanf()获取输入时，因为涉及键盘缓冲区的问题，每次输入后想要把缓冲清空，但是在 gcc 编译后，使用fflush无法清空缓冲区。
探究原因 C 标准 (ISO/IEC 9899:1999 standard) 规定fflush(stdin)操作是未定义的&amp;lt;参看《ISO/IEC 9899:1999 standard》p270&amp;gt;;。也就是说不一定能实现刷新功能，但有的编译器可能不遵循标准，对fflush(stdin)操作不予警告，并且有时可能产生正确的结果，但最好不要这样使用。
解决方法 通过 while 循环把输入流中的余留数据“吃”掉：
int c; while ((c=getchar()) != ‘\n’ &amp;amp;&amp;amp; c != EOF); </description>
    </item>
    <item>
      <title>解决 Segmentation fault (core dumped)</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3segmentation-fault-core-dumped/</link>
      <pubDate>Wed, 20 Oct 2021 14:23:02 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3segmentation-fault-core-dumped/</guid>
      <description>相关概念 Core 在使用半导体作为内存的材料前，人类是利用线圈当作内存的材料（发明者为王安），线圈就叫作 core ，用线圈做的内存就叫作 core memory。如今，半导体工业澎勃发展，已经没有人用core memory 了，不过，在许多情况下，人们还是把记忆体叫作 core 。
Core dump 我们在开发（或使用）一个程序时，最怕的就是程序莫明其妙地宕掉。虽然系统没事，但我们下次仍可能遇到相同的问题。于是这时操作系统就会把程序宕掉时的内存内容 dump 出来（现在通常是写在一个叫 core 的 file 里面），让我们做为参考。这个动作就叫作 core dump。
如何获取 Core 文件 1、在一些 Linux 版本下，默认是不产生core文件的，首先可以查看一下系统core文件的大小限制：
$:~/segfault$ ulimit -c0 2、可以看到默认设置情况下，本机 Linux 环境下发生段错误时不会自动生成core文件，下面设置下core文件的大小限制（单位为 KB）：
$:~/segfault$ ulimit -c 1024$:~/segfault$ ulimit -c1024 3、重新运行程序，如果发生段错误，就会生成core文件。
出现段错误的可能原因 访问不存在的内存地址 #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; void main() { int *ptr = NULL; *ptr = 0; } 访问系统保护的内存地址 #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; void main() { int *ptr = (int *)0; *ptr = 100; } 访问只读的内存地址 #include&amp;lt;stdio.</description>
    </item>
    <item>
      <title>解决 Undefined reference to 问题</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3undefined-reference-to%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 17 Sep 2021 11:14:30 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3undefined-reference-to%E9%97%AE%E9%A2%98/</guid>
      <description>链接时缺失了相关目标文件 这是最典型最常见的情况。比如新添加了一个模块fun.h fun.c两个文件，其他文件中使用了这个模块里的函数，如果编译时忘记加上这两个文件，调用fun模块函数的地方，就会报undefined reference错误。
这个问题在编辑器中一般不容易发现，因为头文件包含是正确的，编辑器能够找到相关的函数及其实现，所以在编写代码时不会报错。
链接时缺少相关的库文件 这个原因和上一条类似，我们在调用静态库中的函数时，编译时如果没有将静态库一起编译，就会报同样的错误。
链接的库文件中又使用了另一个库文件 在使用第三方库时，一定要在编译中加入第三方库的路径。
多个库文件链接顺序问题 在链接命令中给出所依赖的库时，需要注意库之间的依赖顺序，依赖其他库的库一定要放到被依赖库的前面，这样才能真正避免 undefined reference 的错误，完成编译链接。
声明与实现不一致 这个原因也比较典型，注意排查声明与实现的参数是否一致，返回值是否一致。
在 c++代码中链接 c 语言的库 在C++代码中，调用了C语言库的函数，因此链接的时候找不到，解决方法是在相关文件添加一个extern &amp;quot;C&amp;quot;的声明即可。
总结 顾名思义，这个错误就是未定义你使用的内容导致的。所以要排查使用的内容是否能够被正确“找到”。使用的时候有没有声明，有没有定义，声明与定义是否一致，编译时能否正确链接等等。
相关参考 &amp;ldquo;undefined reference to&amp;rdquo; 问题汇总及解决方法</description>
    </item>
    <item>
      <title>解决 TypeError [ERR_INVALID_ARG_TYPE]: The data argument must be of type string or an instance of Buffe</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3typeerror-err-invalid-arg-type-the-data-argument-must-be-of-type-string-or-an-instance-of-buffe/</link>
      <pubDate>Fri, 10 Sep 2021 15:59:34 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3typeerror-err-invalid-arg-type-the-data-argument-must-be-of-type-string-or-an-instance-of-buffe/</guid>
      <description>安装 GitBook 时出现这个错误，将node版本降级即可
MINGW64 ~/Desktop/dir1/dir11$ gitbook initwarn: no summary file in this bookinfo: create SUMMARY.mdTypeError [ERR_INVALID_ARG_TYPE]: The &amp;#34;data&amp;#34; argument must be of type stringor an instance of Buffer, TypedArray, or DataView. Received an instance ofPromise </description>
    </item>
    <item>
      <title>解决 expected &#39;char * const*&#39; but argument is of type &#39;char **&#39;</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/</link>
      <pubDate>Wed, 08 Sep 2021 19:07:27 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/</guid>
      <description>在使用exec系列函数时，execle，execv，execvp三个函数，都可以使用char *arg[]传入启动参数。以下面的程序为例，
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; int main(void) { int ret; char *argv[] = {&amp;#34;ls&amp;#34;,&amp;#34;-l&amp;#34;,NULL}; ret = execvp(&amp;#34;ls&amp;#34;,argv); if(ret == -1) perror(&amp;#34;execl error&amp;#34;); return 0; } 编译时就会出现一下，警告，
expected &amp;#39;char * const*&amp;#39; but argument is of type &amp;#39;const char **&amp;#39; 因为项目中不允许警告产生，所以编译选项是-Werror，所有警告都会被升级成错误。编译时就会产生如下提示，
ccl : all warnings being treated as errors 如果是平时练习，改一下编译选项，把这个警告忽略就行，但是现在只能解决。
出现这个问题就是因为定义数组时char *argv[]类型是char **。但是execvp()函数签名是execvp(const char *file, char *const argv[]);第二个参数的类型是char * const *。
本以为直接将变量定义更改成char * const argv[]就行了，但是它等价于const char **，所以仍然不能和函数签名匹配。
实在没办法只能改成如下：
#include &amp;lt;stdio.</description>
    </item>
    <item>
      <title>解决 gcc-multilib : 依赖：gcc-4.8-multilib (&gt;= 4.8.2-5~) 但是它将不会被安装</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3gcc-multilib-%E4%BE%9D%E8%B5%96-gcc-4-8-multilib-4-8-2-5-%E4%BD%86%E6%98%AF%E5%AE%83%E5%B0%86%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 03 Sep 2021 10:44:44 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3gcc-multilib-%E4%BE%9D%E8%B5%96-gcc-4-8-multilib-4-8-2-5-%E4%BD%86%E6%98%AF%E5%AE%83%E5%B0%86%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%AE%89%E8%A3%85/</guid>
      <description>问题 这是一类问题，不仅限于安装 gcc，这类问题的根本原因在于，Ubuntu 已安装的软件包版本高，而所安装软件的依赖包版本低，这样在安装高版软件时，已有的软件包依赖你要安装的软件包，你把软件包升级了，可能就会破坏这个依赖关系，所以apt-get不让你安装。
这时就要请到大杀器-aptitude，它与 apt-get一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。
方法 $sudo apt-get install aptitude //安装aptitude包管理器$sudo aptitude install gcc-multilib //用新的包管理器安装你要安装的软件 安装gcc-multilib时会把所有依赖包一并安装，此时会让你同意，选择n就行。
接下来就会解决已经安装的包之间的依赖关系，他会降级或升级一些软件包来匹配当前安装的软件版本，此时选择y。
完成以上操作，再次正常安装需要的软件包即可成功安装。
如果无法正常安装，重复以上操作，每次都选择n。</description>
    </item>
    <item>
      <title>解决 fatal error: bits/libc-header-start.h：no such file</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3fatal-error-bits-libc-header-start-hno-such-file/</link>
      <pubDate>Fri, 03 Sep 2021 09:26:34 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3fatal-error-bits-libc-header-start-hno-such-file/</guid>
      <description>保留现场 想要分别编译 32 位和 64 位的程序时，gcc 出现了错误，
In file included from func_call.c:1:/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: 没有那个文件或目录27 | #include &amp;lt;bits/libc-header-start.h&amp;gt;| ^~~~~~~~~~~~~~~~~~~~~~~~~~compilation terminated. 问题解决 问题原因猜测是默认 gcc 只提供当前机器的版本，解决如下
apt install gcc-multilib </description>
    </item>
    <item>
      <title>解决 OpenSSL SSL_connect: Connection was reset in connection to github.com:443</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3openssl-ssl-connect-connection-was-reset-in-connection-to-github-com-443/</link>
      <pubDate>Mon, 09 Aug 2021 18:20:51 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3openssl-ssl-connect-connection-was-reset-in-connection-to-github-com-443/</guid>
      <description>在向 GitHub 推送博客时，推送失败报了这个错。也不知道是改了什么设置突然报错。SSL 的错之前遇到一次，就是刚开始配置 Git 时用的https协议，每次push都需要重新输入一次密码。改成ssl协议就 OK 了。当时把 Linux 环境的 Git 改了，但是现在的 Windows 下没改，猜测可能和这也有关，于是就把 URL 改了一下，结果还真好了。 在本地仓库的.git文件里找到config文件，打开后将url改为ssl协议，git@github.com:XXX格式的。
将 Hexo 的配置也改了，找到仓库下的_config.yml
deploy:type: gitrepository: 改成ssl协议地址branch: master </description>
    </item>
    <item>
      <title>解决/usr/bin/env:python:No such file or directory</title>
      <link>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3-usr-bin-env-python-no-such-file-or-directory/</link>
      <pubDate>Tue, 03 Aug 2021 15:58:44 +0000</pubDate>
      <guid>http://localhost:8888/posts/%E8%A7%A3%E5%86%B3-usr-bin-env-python-no-such-file-or-directory/</guid>
      <description>在执行的程序源码开头有这么一句!#/usr/bin/env python，!#这玩意叫shebang也叫hashbang。他用来指定脚本的解释器，也就是说这个程序指定python解释器。
再看这个错误提示，罪魁祸首就是这句命令，就是说在环境变量找不到python，通俗点说，假如我要能直接用python来跑这个程序，我在命令行直接输入python应该是可以进入python环境的，但是此时肯定不能。我们可以试试
dominic@hanhan:~$ pythonCommond not found xxxxxxxxxxx 解决方案一 系统里没有python还跑个锤子，先装上再说
apt-get install python3 这时候可能就解决问题了
解决方案二 有的人可能python早就装了，但是仍然有这个问题，但是我们在命令输入python仍然没法用，但是输入python3就可以
那python3可以，我直接将python改成python3不就完了。没错！
打开文件将!#/usr/bin/env python改成!#/usr/bin/env python3
解决方案三 如果了解软链接，那我们就可以不用去改源码了，源码最好还是保持原样。
既然找不到python这玩意，那我们给他建一个不就完了。
他要python就是用来解释程序的，我们本地装的python3就是他需要的东西
先找找我们的python3在哪
dominic@hanhan:~$ whereis python3python3: /usr/bin/python3.8 /usr/bin/python3.8-config /usr/bin/python3 一般在/usr/bin目录下，然后我们在这个目录下给他创建一个软链接“快捷方式”，具体咋用的啥意思，可以参考这篇文章。
sudo ln -s /usr/bin/python3 /usr/bin/python 这样程序再找python时就会链接到python3，然后用python3去当解释器。
解决方案四 可能在root目录下使用过repo，将其删除</description>
    </item>
  </channel>
</rss>
