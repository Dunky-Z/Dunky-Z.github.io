<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>VSCode 插件 REST Client 使用文档</title>
    <link href="/2023/03/24/VSCode%20%E6%8F%92%E4%BB%B6%20REST%20Client%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <url>/2023/03/24/VSCode%20%E6%8F%92%E4%BB%B6%20REST%20Client%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>REST Client 是 VSCode 中一款非常好用的插件，能够帮助开发人员快速、方便地发送 HTTP 请求并查看响应。在本文中，我们将会详细介绍 REST Client 的使用方法。</p><h2 id="安装-REST-Client-插件"><a href="#安装-REST-Client-插件" class="headerlink" title="安装 REST Client 插件"></a>安装 REST Client 插件</h2><p>在 VSCode 中，你可以通过以下步骤安装 REST Client 插件：</p><ul><li>打开 VSCode；</li><li>点击左侧的插件图标（Ctrl+Shift+X）；</li><li>搜索“REST Client”插件；</li><li>点击“安装”按钮。</li><li>发送 HTTP 请求</li></ul><p>使用 REST Client 插件发送 HTTP 请求非常简单。你只需要创建一个新的<code>.rest</code>文本文件，将请求信息放入其中，然后使用快捷键<code>Ctrl + Alt + R</code> 或者右键菜单的 <code>Send Request</code> 选项发送请求。</p><p>下面是一个简单的 <code>GET</code> 请求的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">GET https://jsonplaceholder.typicode.com/posts/1 HTTP/1.1<br></code></pre></td></tr></table></figure><p>这个请求会获取 JSONPlaceholder API 中的一篇博客文章。</p><p>如果你想添加请求头或请求体，可以使用以下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">GET https://jsonplaceholder.typicode.com/posts/1 HTTP/1.1<br>Content-Type: application/json<br><br>&#123;<br>  &quot;title&quot;: &quot;foo&quot;,<br>  &quot;body&quot;: &quot;bar&quot;,<br>  &quot;userId&quot;: 1<br>&#125;<br></code></pre></td></tr></table></figure><p>这个请求会在请求头中添加 <code>Content-Type</code> 头，请求体中包含 JSON 数据。</p><h2 id="查看响应"><a href="#查看响应" class="headerlink" title="查看响应"></a>查看响应</h2><p>发送请求后，你可以在编辑器底部看到响应信息。如果你想查看响应头、响应体或状态码等详细信息，可以使用以下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">###<br>HTTP/1.1 200 OK<br>Content-Type: application/json; charset=utf-8<br>...<br><br>&#123;<br>  &quot;userId&quot;: 1,<br>  &quot;id&quot;: 1,<br>  &quot;title&quot;: &quot;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&quot;,<br>  &quot;body&quot;: &quot;quia et suscipit\nsuscipit...&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，###用来分隔请求和响应，这样你就可以很方便地查看请求和响应的详细信息了。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>REST Client 插件还支持变量的使用。你可以使用${variable}语法来定义变量，然后在请求中使用它们。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">@host = https://jsonplaceholder.typicode.com<br><br>GET $&#123;host&#125;/posts/1 HTTP/1.1<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为 <code>host</code> 的变量，并在请求中使用它来指定 API 的基础 URL。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>如果你需要发送多个请求，REST Client 插件支持循环语法。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">@host = https://jsonplaceholder.typicode.com<br><br>@for(i,1,10)&#123;<br>    GET $&#123;host&#125;/posts/$&#123;i&#125; HTTP/1.1<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用@for 语法来发送 10 个 GET 请求，每个请求 URL 中的 i 变量从 1 到 10 依次递增。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>如果你需要根据条件发送请求，REST Client 插件也支持条件语句。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">@host = https://jsonplaceholder.typicode.com<br><br>@if(isDebug)&#123;<br>    GET $&#123;host&#125;/posts/1 HTTP/1.1<br>&#125;else&#123;<br>    GET $&#123;host&#125;/posts/2 HTTP/1.1<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用@if 语法来判断是否为调试模式，如果是就发送一个请求，否则发送另一个请求。</p><h2 id="导入环境变量"><a href="#导入环境变量" class="headerlink" title="导入环境变量"></a>导入环境变量</h2><p>REST Client 插件支持从外部文件中导入环境变量。例如，你可以在<code>.env</code> 文件中定义变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">host=https://jsonplaceholder.typicode.com<br>isDebug=true<br></code></pre></td></tr></table></figure><p>然后在请求文件中使用<code>@environment</code> 语法来导入这些变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">@environment .env<br><br>@if(isDebug)&#123;<br>    GET $&#123;host&#125;/posts/1 HTTP/1.1<br>&#125;else&#123;<br>    GET $&#123;host&#125;/posts/2 HTTP/1.1<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>@environment</code> 语法从<code>.env</code> 文件中导入环境变量，然后在请求文件中使用这些变量。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>REST Client 插件是一个非常好用的工具，能够帮助开发人员快速、方便地发送 HTTP 请求并查看响应。在本文中，我们介绍了 REST Client 的基本使用方法，包括发送请求、查看响应、使用变量、循环、条件语句和导入环境变量等。希望这篇文章能够帮助你更好地使用 REST Client 插件。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事，必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL2 安装 Docker</title>
    <link href="/2023/03/16/WSL2%E5%AE%89%E8%A3%85Docker/"/>
    <url>/2023/03/16/WSL2%E5%AE%89%E8%A3%85Docker/</url>
    
    <content type="html"><![CDATA[<p>在 WSL2 中，你可能会遇到与 Docker 服务相关的问题，因为 WSL2 与传统 Linux 系统在某些方面有所不同。在这种情况下，你可以尝试以下步骤来解决问题：</p><ol><li>首先，确保你已经安装了 WSL2 的最新版本。你可以通过运行以下命令来更新 WSL2：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">wsl --update<br></code></pre></td></tr></table></figure><ol start="2"><li>确保 Docker Desktop for Windows 已安装并启用 WSL2 集成。你可以在 Docker Desktop 设置中找到这个选项。确保你的 WSL2 发行版已被添加到 Docker Desktop 的 WSL 集成列表中。点击链接下载安装<a href="https://dockerdocs.cn/docker-for-windows/install/">在 Windows 上安装 Docker 桌面</a>。</li><li>在 WSL2 中，尝试手动停止 Docker 服务：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo /etc/init.d/docker stop<br></code></pre></td></tr></table></figure><pre><code class="hljs">如果这个命令无法停止 Docker 服务，请尝试以下命令：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo killall dockerd<br></code></pre></td></tr></table></figure><ol start="4"><li>卸载 Docker：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get purge docker-ce<br></code></pre></td></tr></table></figure><ol start="5"><li>删除 Docker 相关的文件和目录：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo rm -rf /var/lib/docker<br></code></pre></td></tr></table></figure><ol start="6"><li>重新启动 WSL2：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">wsl --shutdown<br></code></pre></td></tr></table></figure><ol start="7"><li>然后重新打开 WSL2。</li><li>在 WSL2 中，不要直接安装 Docker CE。而是使用 Docker Desktop for Windows 提供的 Docker 服务。这意味着你不需要在 WSL2 中安装 Docker CE，因为 Docker Desktop 已经提供了 Docker 服务。</li><li>确保你的 WSL2 发行版可以访问 Docker Desktop 提供的 Docker 服务。你可以通过运行以下命令来检查：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker --version<br><br>docker info<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>WSL2</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一生一芯笔记</title>
    <link href="/2023/03/12/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/12/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一生一芯概述"><a href="#一生一芯概述" class="headerlink" title="一生一芯概述"></a>一生一芯概述</h1><p><a href="https://www.bilibili.com/video/BV12e4y1Y76i/?spm_id_from=333.788&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">“一生一芯”概述 _哔哩哔哩_bilibili</a></p><h1 id="程序的执行和模拟器"><a href="#程序的执行和模拟器" class="headerlink" title="程序的执行和模拟器"></a>程序的执行和模拟器</h1><h2 id="freestanding-运行时环境"><a href="#freestanding-运行时环境" class="headerlink" title="freestanding 运行时环境"></a>freestanding 运行时环境</h2><h3 id="程序如何结束运行"><a href="#程序如何结束运行" class="headerlink" title="程序如何结束运行"></a>程序如何结束运行</h3><p>在正常的环境中，写了一段代码<code>return</code>之后，实际上调用了一个系统调用<code>exit</code>。但是在 freestanding 环境中，没有操作系统支持，根据 C99 手册规定，在 freestanding 环境中结束运行是由用户实现决定的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">5.1.2.1 Freestanding environment<br><br>2 The effect of program termination in a freestanding environment is<br>implementation-defined.<br></code></pre></td></tr></table></figure><p>在 qemu-system-riscv64 中的 virt 机器模型中，往一个特殊的地址写入一个特殊的“暗号”即可结束 QEMU</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-keyword">void</span> _start() &#123;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">uint8_t</span> *p = (<span class="hljs-keyword">uint8_t</span> *)(<span class="hljs-keyword">uintptr_t</span>)<span class="hljs-number">0x10000000</span>;<br>  *p = <span class="hljs-string">&#x27;A&#x27;</span>;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">uint32_t</span> *<span class="hljs-built_in">exit</span> = (<span class="hljs-keyword">uint32_t</span> *)(<span class="hljs-keyword">uintptr_t</span>)<span class="hljs-number">0x100000</span>;<br>  *<span class="hljs-built_in">exit</span> = <span class="hljs-number">0x5555</span>;   <span class="hljs-comment">// magic number</span><br>  _start();         <span class="hljs-comment">// 递归调用，如果正常退出将不会再次打印A</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在自制-freestanding-运行时环境上运行-Hello-程序"><a href="#在自制-freestanding-运行时环境上运行-Hello-程序" class="headerlink" title="在自制 freestanding 运行时环境上运行 Hello 程序"></a>在自制 freestanding 运行时环境上运行 Hello 程序</h3><p>QEMU 虽然是个开源项目，但还挺复杂，不利于我们理解细节。让我们来设计一个面向 RISC-V 程序的简单 freestanding 运行时环境，我做以下约定。</p><ul><li>程序从地址 0 开始执行</li><li>只支持两条指令<ul><li>addi 指令</li><li>ebreak 指令<ul><li>寄存器 a0=0 时，输出寄存器 a1 低 8 位的字符</li><li>寄存器 a0=1 时，结束运行<ul><li>ABI Mnemonic（RISC-V 官方为每个寄存器起个名字）</li></ul></li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ebreak</span><span class="hljs-params">(<span class="hljs-keyword">long</span> arg0, <span class="hljs-keyword">long</span> arg1)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;addi a0, x0, %0;&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-string">&quot;addi a1, x0, %1;&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-string">&quot;ebreak&quot;</span> : : <span class="hljs-string">&quot;i&quot;</span>(arg0), <span class="hljs-string">&quot;i&quot;</span>(arg1))</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putch</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123; ebreak(<span class="hljs-number">0</span>, ch); &#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">halt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code)</span> </span>&#123; ebreak(<span class="hljs-number">1</span>, code); <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>); &#125;<br><br><span class="hljs-keyword">void</span> _start() &#123;<br>  putch(<span class="hljs-string">&#x27;A&#x27;</span>);<br>  halt(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 这段代码定义了三个函数：ebreak、putch 和 halt。</span><br><span class="hljs-comment"> * ebreak 函数是一个内联汇编函数，它执行 ebreak 指令。</span><br><span class="hljs-comment"> * 该指令是 RISC-V 架构中的一条调试指令，可以在调试器的控制下执行。</span><br><span class="hljs-comment"> * 该函数接受两个参数 arg0 和 arg1，它们将被存储在寄存器 a0 和 a1 中。</span><br><span class="hljs-comment"> * putch 函数调用了 ebreak 函数，并将第一个参数设为 0，</span><br><span class="hljs-comment"> * 第二个参数设为函数参数 ch。这样做的目的可能是为了在调试器的控制下输出一个字符。</span><br><span class="hljs-comment"> * halt 函数调用了 ebreak 函数，并将第一个参数设为 1，</span><br><span class="hljs-comment"> * 第二个参数设为函数参数 code。这样做的目的可能是为了通知调试器程序已经结束，</span><br><span class="hljs-comment"> * 并使用 code 作为结束状态。然后，halt 函数进入一个死循环，等待调试器的操作。</span><br><span class="hljs-comment"> * 最后，_start 函数调用了 putch 函数输出字符 &#x27;A&#x27;，然后调用 halt 函数结束程序 </span><br><span class="hljs-comment"> */</span> <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">riscv64-linux-gnu-gcc -march=rv64g -ffreestanding -nostdlib -static -Wl,-Ttext=0 \<br>  -O2 -o prog a.c<br></code></pre></td></tr></table></figure><ul><li><p>riscv64-linux-gnu-gcc: 这是 GCC 的可执行文件的名称，表示使用的是 GCC 编译器。riscv64-linux-gnu 是编译器的目标平台，表示生成的代码是针对 RISC-V 架构，运行在 Linux 系统上的二进制文件。</p></li><li><p>-march=rv64g: 这个参数指定了编译器使用的指令集。rv64g 表示使用 RISC-V 架构的 64 位指令集。</p></li><li><p>-ffreestanding: 这个参数指示编译器生成的代码将在 freestanding 运行环境中运行。在 freestanding 运行环境中，程序不会自动链接标准 C 库，也不会自动调用 main 函数。</p></li><li><p>-nostdlib: 这个参数表示编译器不需要链接标准 C 库。</p></li><li><p>-static: 这个参数表示生成的代码是静态链接的。</p></li><li><p>-Wl,-Ttext=0: 这个参数是传递给链接器的，表示设置代码段的起始地址为 0。</p></li><li><p>-O2: 这个参数指示编译器使用优化级别为 2 的优化选项。</p></li><li><p>-o prog: 这个参数指定生成的可执行文件的名称为 prog。</p></li><li><p>a.c: 这是要编译的 C 源文件的名称。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">llvm-objdump -d prog<br></code></pre></td></tr></table></figure><p>反汇编结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">prog:   file format elf64-littleriscv<br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;_start&gt;:<br>       0: 13 05 00 00   li      a0, 0<br>       4: 93 05 10 04   li      a1, 65<br>       8: 73 00 10 00   ebreak<br>       c: 13 05 10 00   li      a0, 1<br>      10: 93 05 00 00   li      a1, 0<br>      14: 73 00 10 00   ebreak<br>      18: 6f 00 00 00   j       0x18 &lt;_start+0x18&gt;<br></code></pre></td></tr></table></figure><p>我们约定中没有<code>li</code>指令，但是汇编中却出现了，这是因为<code>li</code>是一条伪指令，它的实际实现依然是<code>addi</code>。如果不使用伪指令可以使用以下命令反汇编：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">llvm-objdump -M no-aliases -d prog<br></code></pre></td></tr></table></figure><p>结果如下，没有伪指令，只有我们约定的几条指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">prog:   file format elf64-littleriscv<br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;_start&gt;:<br>       0: 13 05 00 00   addi    a0, zero, 0<br>       4: 93 05 10 04   addi    a1, zero, 65<br>       8: 73 00 10 00   ebreak<br>       c: 13 05 10 00   addi    a0, zero, 1<br>      10: 93 05 00 00   addi    a1, zero, 0<br>      14: 73 00 10 00   ebreak<br>      18: 6f 00 00 00   jal     zero, 0x18 &lt;_start+0x18&gt;<br></code></pre></td></tr></table></figure><h2 id="YEMU-指令如何执行"><a href="#YEMU-指令如何执行" class="headerlink" title="YEMU 指令如何执行"></a>YEMU 指令如何执行</h2><p>ISA 手册定义了一个状态机。</p><ul><li><p>状态集合 S = {&lt;R, M&gt;}</p><ul><li>R = {PC, x0, x1, x2, …}<ul><li>RISC-V 手册 -&gt; 2.1 Programmers’Model for Base Integer ISA</li><li>PC = 程序计数器 = 当前执行的指令位置</li></ul></li><li>M = 内存<ul><li>RISC-V 手册 -&gt; 1.4 Memory</li></ul></li></ul></li></ul><p>激励事件：执行 PC 指向的指令<br>状态转移规则：指令的语义 (semantics)<br>初始状态 S0 = &lt;R0, M0&gt;</p><p>我们只要把这个状态机实现出来，就可以用它来执行指令了！</p><h3 id="用变量实现内存"><a href="#用变量实现内存" class="headerlink" title="用变量实现内存"></a>用变量实现内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-keyword">uint64_t</span> R[<span class="hljs-number">32</span>], PC; <span class="hljs-comment">// according to the RISC-V manual</span><br><span class="hljs-keyword">uint8_t</span> M[<span class="hljs-number">64</span>];      <span class="hljs-comment">// 64-Byte memory</span><br></code></pre></td></tr></table></figure><p>Q: 为什么不使用 <code>int64_t</code> 和 <code>int8_t</code>?</p><p>A: C语言标准规定, 有符号数溢出是undefined behavior, 但无符号数不会溢出</p><blockquote><p>6.5 Expressions<br>5 If an exceptional condition occurs during the evaluation of an expression (that is,<br>if the result is not mathematically defined or not in the range of representable<br>values for its type), the behavior is undefined.<br>6.2.5 Types<br>9 A computation involving unsigned operands can never overflow, because a result that<br>cannot be represented by the resulting unsigned integer type is reduced modulo the<br>number that is one greater than the largest value that can be represented by the<br>resulting type.</p></blockquote><h3 id="用语句实现指令的语义"><a href="#用语句实现指令的语义" class="headerlink" title="用语句实现指令的语义"></a>用语句实现指令的语义</h3><p>指令周期 (instruction cycle): 执行一条指令的步骤</p><ul><li>取指 (fetch): 从 PC 所指示的内存位置读取一条指令</li><li>译码 (decode): 按照手册解析指令的操作码 (opcode) 和操作数 (operand)</li><li>执行 (execute): 按解析出的操作码，对操作数进行处理</li><li>更新 PC: 让 PC 指向下一条指令</li></ul><p>状态机不断执行指令，直到结束运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-keyword">bool</span> halt = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">while</span> (!halt) &#123;<br>  inst_cycle();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"> 31           20 19 15 14 12 11  7 6       0<br>+---------------+-----+-----+-----+---------+<br>|   imm[11:0]   | rs1 | 000 | rd  | 0010011 |    ADDI<br>+---------------+-----+-----+-----+---------+<br>+---------------+-----+-----+-----+---------+<br>| 000000000001  |00000| 000 |00000| 1110011 |   EBREAK<br>+---------------+-----+-----+-----+---------+<br></code></pre></td></tr></table></figure><p>一个简单的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inst_cycle</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">uint32_t</span> inst = *(<span class="hljs-keyword">uint32_t</span> *)&amp;M[PC];<br>  <span class="hljs-keyword">if</span> (((inst &amp; <span class="hljs-number">0x7f</span>) == <span class="hljs-number">0x13</span>) &amp;&amp; ((inst &gt;&gt; <span class="hljs-number">12</span>) &amp; <span class="hljs-number">0x7</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// addi</span><br>    <span class="hljs-keyword">if</span> (((inst &gt;&gt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">0x1f</span>) != <span class="hljs-number">0</span>) &#123;<br>      R[(inst &gt;&gt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">0x1f</span>] = R[(inst &gt;&gt; <span class="hljs-number">15</span>) &amp; <span class="hljs-number">0x1f</span>] +<br>        (((inst &gt;&gt; <span class="hljs-number">20</span>) &amp; <span class="hljs-number">0x7ff</span>) - ((inst &amp; <span class="hljs-number">0x80000000</span>) ? <span class="hljs-number">4096</span> : <span class="hljs-number">0</span>));<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inst == <span class="hljs-number">0x00100073</span>) &#123; <span class="hljs-comment">// ebreak</span><br>    <span class="hljs-keyword">if</span> (R[<span class="hljs-number">10</span>] == <span class="hljs-number">0</span>) &#123; <span class="hljs-built_in">putchar</span>(R[<span class="hljs-number">11</span>] &amp; <span class="hljs-number">0xff</span>); &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (R[<span class="hljs-number">10</span>] == <span class="hljs-number">1</span>) &#123; halt = <span class="hljs-literal">true</span>; &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unsupported ebreak command\n&quot;</span>); &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unsupported instuction\n&quot;</span>); &#125;<br>  PC += <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="NEMU-代码导读"><a href="#NEMU-代码导读" class="headerlink" title="NEMU 代码导读"></a>NEMU 代码导读</h1><h2 id="make-项目构"><a href="#make-项目构" class="headerlink" title="make 项目构"></a>make 项目构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示make踪迹</span><br>strace make<br><span class="hljs-comment"># 显示构建过程</span><br>make -d<br><span class="hljs-comment"># 显示更详细的构建构过程</span><br>make --debug=v<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs text">Reading makefiles...<br>Reading makefile `Makefile&#x27;...<br>Updating goal targets....<br> File `all&#x27; does not exist.<br>   File `all&#x27; does not exist.<br>   Looking for an implicit rule for `all&#x27;.<br>   Trying pattern rule with stem `all&#x27;.<br>   Trying implicit prerequisite `all.c&#x27;.<br>   Trying pattern rule with stem `all&#x27;.<br>   Trying implicit prerequisite `all.cc&#x27;.<br>   Trying pattern rule with stem `all&#x27;.<br>   Trying implicit prerequisite `all.C&#x27;.<br>   Trying pattern rule with stem `all&#x27;.<br>   Trying implicit prerequisite `all.cpp&#x27;.<br>   Trying pattern rule with stem `all&#x27;.<br>   Trying implicit prerequisite `all.CPP&#x27;.<br>   Trying pattern rule with stem `all&#x27;.<br>   Trying implicit prerequisite `all.cxx&#x27;.<br>   Trying pattern rule with stem `all&#x27;.<br>   Trying implicit prerequisite `all.CXX&#x27;.<br>   Trying pattern rule with stem `all&#x27;.<br>   Trying implicit prerequisite `all.c++&#x27;.<br>   Trying pattern rule with stem `all&#x27;.<br>   Trying implicit prerequisite `all.C++&#x27;.<br>   No implicit rule found for `all&#x27;.<br>   Finished prerequisites of target file `all&#x27;.<br> Must remake target `all&#x27;.<br>gcc -o all all.o<br>Finished prerequisites of target file `all&#x27;.<br>Must remake target `all&#x27;.<br>gcc -o all all.o<br>Successfully remade target file `all&#x27;.<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只打印命令不执行</span><br>make -n<br><span class="hljs-comment"># 输出目标被构建的原因和执行的命令</span><br>make --trace<br></code></pre></td></tr></table></figure><p>例如，如果您有一个 makefile，其目标 <code>all</code> 依赖于目标 <code>foo</code> 和 <code>bar</code>，并且您运行 <code>make --trace all</code>，您可能会看到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">make[1]: Entering directory <span class="hljs-string">&#x27;/path/to/project&#x27;</span><br>gcc -o foo foo.c<br>make[1]: Leaving directory <span class="hljs-string">&#x27;/path/to/project&#x27;</span><br>make[1]: Entering directory <span class="hljs-string">&#x27;/path/to/project&#x27;</span><br>gcc -o bar bar.c<br>make[1]: Leaving directory <span class="hljs-string">&#x27;/path/to/project&#x27;</span><br>make[1]: Entering directory <span class="hljs-string">&#x27;/path/to/project&#x27;</span><br>gcc -o all foo.o bar.o<br>make[1]: Leaving directory <span class="hljs-string">&#x27;/path/to/project&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -nB  <span class="hljs-comment"># -B 可以强制 make 构建所有目标，即使它们已经是最新的</span><br>make -nB | vim -<br></code></pre></td></tr></table></figure><p>在 vim 编辑器中进行二次处理，过滤不需要的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只保留 gcc 或 g++开头的行</span><br>:%!grep <span class="hljs-string">&quot;^\(gcc\|g++\)&quot;</span><br><br><span class="hljs-comment"># 将环境变量$NEMU_HOME 所指示字符串替换为$NEMU_HOME</span><br>:%!sed -e <span class="hljs-string">&quot;s+<span class="hljs-variable">$NEMU_HOME</span>+\$NEMU_HOME+g&quot;</span><br><br><span class="hljs-comment"># 将$NEMU_HOME/build/obj-riscv64-nemu-interpreter 替换为$OBJ_DIR</span><br>:%s+\<span class="hljs-variable">$NEMU_HOME</span>/build/obj-riscv64-nemu-interpreter+<span class="hljs-variable">$OBJ_DIR</span>+g<br><br><span class="hljs-comment"># 将-c 之前的内容替换为$CFLAGS</span><br>:%s/-O2.*=riscv64/<span class="hljs-variable">$CFLAGS</span>/g<br><br><span class="hljs-comment"># 将最后一行的空格替换成换行并缩进两格</span><br>:<span class="hljs-variable">$s</span>/  */\r  /g<br></code></pre></td></tr></table></figure><h1 id="调试技巧选将"><a href="#调试技巧选将" class="headerlink" title="调试技巧选将"></a>调试技巧选将</h1><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在 C 程序中使用断言（assert）不会增加额外的内存空间，也不会增加数据段空间。断言是一种在运行时检查程序假设是否为真的方法，当断言失败时，程序会终止执行并显示错误信息。</p><p>在 C 语言中，断言通常使用宏来实现。它在编译时被解释为一个简单的条件语句，因此它不会增加程序的内存空间或数据段空间。断言宏的定义通常类似于以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> assert(expression) ((void)0)</span><br></code></pre></td></tr></table></figure><p>这里的 expression 是要检查的条件。如果 <code>expression</code> 为假，则 <code>assert()</code> 函数会发出错误消息并终止程序的执行。如果 <code>expression</code> 为真，则 <code>assert()</code> 函数不会产生任何操作，并且被解释为 <code>((void)0)</code>。这个语句不会增加任何内存或数据段空间。</p><p>需要注意的是，当一个程序使用大量的断言时，它可能会对程序的性能产生一些影响，因为每个断言都需要在运行时进行检查。因此，在生产环境中，应该尽可能减少使用断言，并在测试和调试阶段使用它们来确保代码的正<br>确性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// nemu/src/isa/riscv64/local-include/reg.h</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">check_reg_idx</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>  IFDEF(CONFIG_RT_CHECK, assert(idx &gt;= <span class="hljs-number">0</span> &amp;&amp; idx &lt; <span class="hljs-number">32</span>));<br>  <span class="hljs-keyword">return</span> idx;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编译器工具-sanitizer"><a href="#编译器工具-sanitizer" class="headerlink" title="编译器工具 sanitizer"></a>编译器工具 sanitizer</h2><p>让编译器自动插入 assert, 拦截常见的非预期行为</p><ul><li>AddressSanitizer - 检查指针越界，use-after-free</li><li>ThreadSanitizer - 检查多线程数据竞争</li><li>LeakSanitizer - 检查内存泄漏</li><li>UndefinedBehaviorSanitizer - 检查 UB</li><li>还能检查指针的比较和相减</li></ul><p>打开后程序运行效率有所下降</p><ul><li>但调试的时候非常值得，躺着就能让工具帮你找 bug</li><li>man gcc 查看具体用法</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>GCC 提供了多种 Sanitizer 工具，可以帮助开发者在编译时检测和修复常见的编程错误，例如内存泄漏、缓冲区溢出、使用未初始化的变量等。以下是几个 Sanitizer 工具的示例用法：</p><ol><li><p>Address Sanitizer（ASAN）：检测内存错误，例如使用已经释放的内存、堆栈和全局缓冲区的溢出和下溢等。</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">gcc -fsanitize=address -g &lt;<span class="hljs-keyword">source</span> <span class="hljs-keyword">files</span>&gt; -<span class="hljs-keyword">o</span> &lt;output <span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>Undefined Behavior Sanitizer（UBSAN）：检测未定义行为，例如除以零、使用未初始化的变量、指针溢出等。</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">gcc -fsanitize=undefined -g &lt;<span class="hljs-keyword">source</span> <span class="hljs-keyword">files</span>&gt; -<span class="hljs-keyword">o</span> &lt;output <span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>Thread Sanitizer（TSAN）：检测并发问题，例如竞争条件、死锁等。</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">gcc -fsanitize=thread -g &lt;<span class="hljs-keyword">source</span> <span class="hljs-keyword">files</span>&gt; -<span class="hljs-keyword">o</span> &lt;output <span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>Memory Sanitizer（MSAN）：检测使用未初始化的内存，例如读取未初始化的内存、使用已释放的内存等。</p> <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">gcc -fsanitize=<span class="hljs-keyword">memory</span> -g &lt;<span class="hljs-keyword">source</span> files&gt; -o &lt;output <span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure></li></ol><p>需要注意的是，Sanitizer 工具可能会增加程序的执行时间和内存消耗，并且可能会产生误报，因此在生产环境中应该禁用 Sanitizer 工具。通常情况下，开发者可以在开发和测试阶段启用 Sanitizer 工具，以帮助他们发现和修复代码中的问题。</p><h2 id="自顶向下理解程序行为"><a href="#自顶向下理解程序行为" class="headerlink" title="自顶向下理解程序行为"></a>自顶向下理解程序行为</h2><pre><code class="hljs">ftrace - 函数调用层次，理解程序的大体行为itrace - 指令执行层次，理解指令级别的行为mtrace - 访存的踪迹dtrace - 设备访问的踪迹sdb - 灵活细致地检查客户程序的状态si - 细粒度的状态转移info r/x - 检查R/M监视点 - 捕捉某状态发生变化的时刻</code></pre><p>sdb 与 gdb 结合使用</p><pre><code class="hljs">先用 sdb 定位到出错点附近再用 gdb 观察 NEMU 的细节行为</code></pre><h2 id="程序的运行时间都花在了哪里"><a href="#程序的运行时间都花在了哪里" class="headerlink" title="程序的运行时间都花在了哪里"></a>程序的运行时间都花在了哪里</h2><p>Linux 的性能分析工具 perf 是一款功能强大的性能分析工具，它可以通过硬件计数器（Hardware counter）或者性能事件（Performance event）来对 Linux 系统的性能进行分析。以下是 perf 工具的安装和使用方法。</p><h3 id="安装-perf-工具"><a href="#安装-perf-工具" class="headerlink" title="安装 perf 工具"></a>安装 perf 工具</h3><p>在大部分 Linux 发行版中，perf 工具已经预先安装，如果没有预先安装，可以通过以下命令进行安装。</p><ul><li>Debian/Ubuntu 系统：<code>sudo apt-get install linux-tools-common linux-tools-generic</code></li><li>Fedora 系统：<code>sudo dnf install perf</code></li><li>CentOS/RHEL 系统：<code>sudo yum install perf</code></li></ul><p>安装完毕之后，可以通过 <code>perf version</code> 命令来检查 perf 版本信息。</p><h3 id="编写一个简单的-C-代码"><a href="#编写一个简单的-C-代码" class="headerlink" title="编写一个简单的 C 代码"></a>编写一个简单的 C 代码</h3><p>这里我们编写一个简单的 C 代码，用于测试 perf 工具的使用。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000000</span>; i++)<br>        sum += i;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>, sum);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码的作用是计算 1 到 1000000 的和。</p><h3 id="使用-perf-工具"><a href="#使用-perf-工具" class="headerlink" title="使用 perf 工具"></a>使用 perf 工具</h3><p>下面我们使用 perf 工具来对上述代码进行性能分析。假设代码保存在文件 test.c 中。</p><p>统计 CPU 周期数<br>以下命令用于统计程序的 CPU 周期数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf <span class="hljs-built_in">stat</span> ./<span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>输出结果类似于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">Performance counter stats <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;./test&#x27;</span>:<br><br>          19,23 msec task-clock:u              <span class="hljs-comment">#    0.988 CPUs utilized          </span><br>                0      context-switches:u        <span class="hljs-comment">#    0.000 K/sec                  </span><br>                0      cpu-migrations:u          <span class="hljs-comment">#    0.000 K/sec                  </span><br>              575      page-faults:u             <span class="hljs-comment">#    0.030 M/sec                  </span><br>   64,013,620,231      cycles:u                  <span class="hljs-comment">#    3.324 GHz                      (49.80%)</span><br>   40,010,335,480      instructions:u            <span class="hljs-comment">#    0.62  insn per cycle           (62.34%)</span><br>    9,998,469,566      branches:u                <span class="hljs-comment">#  518.693 M/sec                    (62.27%)</span><br>          763,176      branch-misses:u           <span class="hljs-comment">#    0.01% of all branches          (62.32%)</span><br><br>     0.019438122 seconds time elapsed<br><br>     0.019411000 seconds user<br>     0.000007000 seconds sys<br></code></pre></td></tr></table></figure><p>输出结果中的 cycles 表示 CPU 周期数，instructions 表示指令数，branches 表示分支指令数。其中，cycles 和 instructions 的比例代表了 CPU 的效率，即 IPC（Instructions Per Cycle）。</p><h3 id="统计函数调用次数"><a href="#统计函数调用次数" class="headerlink" title="统计函数调用次数"></a>统计函数调用次数</h3><p>以下命令用于统计程序中函数的调用次数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf record -e cycles -g ./<span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>这个命令将启动 perf 工具，并使用 -g 选项记录调用关系图。我们还需要使用 sudo 权限运行该命令，以便 perf 工具可以访问系统的硬件计数器。</p><h2 id="成为专业码农"><a href="#成为专业码农" class="headerlink" title="成为专业码农"></a>成为专业码农</h2><ul><li>要熟悉项目了 -&gt; STFW/RTFM/RTFSC, 尝试理解一切细节</li><li>要写代码了<ul><li>仔细 RTFM, 正确理解需求</li><li>编写可读，可维护，易验证的代码 (不言自明，不言自证)</li><li>用 lint 工具检查代码</li><li>进行充分的测试</li><li>添加充分的断言</li></ul></li><li>要调试了<ul><li>默念“机器永远是对的/未测试代码永远是错的”</li><li>sanitizer, trace, printf, gdb, …</li></ul></li><li>平时 -&gt; 用正确的工具/方法做事情</li><li>感到不爽了 -&gt; 找正确的工具/搭基础设施</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA 小白笔记</title>
    <link href="/2023/03/12/JAVA%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/12/JAVA%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h1><blockquote><p>本章记录一些配置笔记，不是 step by step 教程</p></blockquote><h2 id="安装-JAVA"><a href="#安装-JAVA" class="headerlink" title="安装 JAVA"></a>安装 JAVA</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 免登陆下载java</span><br>https://xiandan.io/posts/jdk-download.html<br><span class="hljs-comment"># 高速镜像</span><br>https://github.com/LilithBristol/javajdkforwinx64<br></code></pre></td></tr></table></figure><p>Linux 环境变量 PATH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">%JAVA_HOME%\bin<br>%JAVA_HOME%\jre\bin<br></code></pre></td></tr></table></figure><p>Windows 环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># JAVA_HOME</span><br>C:\Program Files\Java\jdk1.8.0_212<br><span class="hljs-comment"># CLASSPATH</span><br>.;%JAVA_HOME%\bin;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar<br></code></pre></td></tr></table></figure><h2 id="VSCode-开发环境"><a href="#VSCode-开发环境" class="headerlink" title="VSCode 开发环境"></a>VSCode 开发环境</h2><h3 id="基础插件"><a href="#基础插件" class="headerlink" title="基础插件"></a>基础插件</h3><p>安装 <code>Extension Pack for Java</code> 即可，会把用到的开发插件都安装。不需要安装 Java Language Support 会和 Extension Pack for Java 中的 Language Support for Java by Red Hat 冲突。目前使用过程中也没有遇到必须使用 Java Language Support 的情况。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>使用 CTRL+SHIFT+P 输入 Java: create Project，输入项目名，在 src 文件夹中，选择 Run 运行 Java 代码。</p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 导包</span><br> <span class="hljs-built_in">shift</span> + alt + o<br></code></pre></td></tr></table></figure><h2 id="IDEA-开发环境"><a href="#IDEA-开发环境" class="headerlink" title="IDEA 开发环境"></a>IDEA 开发环境</h2><h3 id="下载安装-IDEA"><a href="#下载安装-IDEA" class="headerlink" title="下载安装 IDEA"></a>下载安装 IDEA</h3><p><a href="https://www.ifengsoft.com/149.html">Java 集成开发环境 IntelliJ IDEA 2022.3 Ultimate 永久激活版 - 风软资源站</a></p><h3 id="配置-MAVEN-IDEA-中下载速度慢"><a href="#配置-MAVEN-IDEA-中下载速度慢" class="headerlink" title="配置 MAVEN,IDEA 中下载速度慢"></a>配置 MAVEN,IDEA 中下载速度慢</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># IDEA中编辑区右键--maven--create xml</span><br>&lt;mirrors&gt;  <br>    &lt;mirror&gt;<br>        &lt;id&gt;alimaven&lt;/id&gt;<br>        &lt;name&gt;aliyun maven&lt;/name&gt;<br>        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;<br>        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;<br>    &lt;/mirror&gt;<br><br>    &lt;mirror&gt;<br>        &lt;id&gt;uk&lt;/id&gt;<br>        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;<br>        &lt;name&gt;Human Readable Name <span class="hljs-keyword">for</span> this Mirror.&lt;/name&gt;<br>        &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt;<br>    &lt;/mirror&gt;<br><br>    &lt;mirror&gt;<br>        &lt;id&gt;CN&lt;/id&gt;<br>        &lt;name&gt;OSChina Central&lt;/name&gt;<br>        &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;<br>        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;<br>    &lt;/mirror&gt;<br><br>    &lt;mirror&gt;<br>        &lt;id&gt;nexus&lt;/id&gt;<br>        &lt;name&gt;internal nexus repository&lt;/name&gt;<br>        &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt;<br>        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;<br>    &lt;/mirror&gt;<br>&lt;/mirrors&gt;<br></code></pre></td></tr></table></figure><h2 id="安装-MYSQL"><a href="#安装-MYSQL" class="headerlink" title="安装 MYSQL"></a>安装 MYSQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install mysql<br>sudo mysql -u root -p<br><span class="hljs-built_in">source</span> /home/user/oa_system/VBlog/blogserver/src/main/resources/vueblog.sql<br></code></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建数据库</span><br>CREATE DATABASE ryvue;<br><span class="hljs-comment"># 切换当前数据库</span><br>use ryvue;<br><span class="hljs-built_in">set</span> character <span class="hljs-built_in">set</span> utf8;<br><span class="hljs-comment"># 执行sql脚本</span><br><span class="hljs-built_in">source</span> /home/user/oa_system/RuoYi-Vue/sql/ry_20220822.sql<br><span class="hljs-built_in">source</span> /home/user/oa_system/RuoYi-Vue/sql/quartz.sql<br><span class="hljs-comment"># 删除数据库</span><br>drop database 数据库名;<br><span class="hljs-comment"># 显示所有数据库</span><br>show databases;<br><span class="hljs-comment"># 创建数据库</span><br>create database 数据库名;<br><span class="hljs-comment"># 显示数据库编码格式</span><br> SHOW VARIABLES LIKE <span class="hljs-string">&#x27;character_set_%&#x27;</span>;<br><span class="hljs-comment"># 删除 mysql 密码</span><br>SET PASSWORD FOR root@localhost=PASSWORD(<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-comment"># 重建数据库</span><br>drop database ryvue;<br>create database ryvue;<br>use ryvue;<br></code></pre></td></tr></table></figure><h2 id="安装数据库可视化工具"><a href="#安装数据库可视化工具" class="headerlink" title="安装数据库可视化工具"></a>安装数据库可视化工具</h2><h3 id="mysql-workbench"><a href="#mysql-workbench" class="headerlink" title="mysql-workbench"></a>mysql-workbench</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://security.ubuntu.com/ubuntu focal-security main&quot;</span> | sudo tee /etc/apt/sources.list.d/focal-security.list<br>sudo apt-get update<br>sudo apt-get install libssl1.1<br><br>wget https://downloads.mysql.com/archives/get/p/8/file/mysql-workbench-community_8.0.12-1ubuntu18.04_amd64.deb<br>sudo dpkg -i mysql*.deb <br>sudo apt-get install -f <br>sudo dpkg -i mysql*.deb  <br></code></pre></td></tr></table></figure><h3 id="VSCode-插件-MySQL-by-weijan-Chen"><a href="#VSCode-插件-MySQL-by-weijan-Chen" class="headerlink" title="VSCode 插件-MySQL by weijan Chen"></a>VSCode 插件-MySQL by weijan Chen</h3><p><a href="https://github.com/cweijan/vscode-database-client/blob/HEAD/README_CN.md">vscode-database-client 官方文档</a></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/12/f35c4232ab20d9bd4f8dac306f617fdc.png"></p><h2 id="安装-NPM"><a href="#安装-NPM" class="headerlink" title="安装 NPM"></a>安装 NPM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install npm -y<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">npm <span class="hljs-built_in">set</span> progress=<span class="hljs-literal">false</span> <br><br>npm config <span class="hljs-built_in">set</span> registry http://registry.npmjs.org/<br><br>npm install --legacy-peer-deps<br><br>reify:abbrev: sill audit bulk request<br>删除 package-lock.json 文件<br></code></pre></td></tr></table></figure><h2 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h2><p>打开终端并输入以下命令以在 Ubuntu 上下载 nvm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash<br></code></pre></td></tr></table></figure><p>该命令将从 nvm GitHub 存储库下载安装脚本，并使用 bash 在您的 Ubuntu 系统上运行它。运行此命令后，nvm 将被安装在您的家目录中。</p><p>安装完成后，在终端中运行以下命令，以使 nvm 生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>确认 nvm 是否正确安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm --version<br></code></pre></td></tr></table></figure><p>如果一切顺利，您将看到 nvm 的版本号。</p><h2 id="安装-node-js-和-npm"><a href="#安装-node-js-和-npm" class="headerlink" title="安装 node.js 和 npm"></a>安装 node.js 和 npm</h2><p>使用 nvm 安装特定版本的 Node.js：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install &lt;node-version&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install 14.17.6<br></code></pre></td></tr></table></figure><p>这将安装 Node.js 版本 14.17.6。</p><p>安装完成后，使用以下命令将已安装的 Node.js 版本设置为默认版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm <span class="hljs-built_in">alias</span> default &lt;node-version&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm <span class="hljs-built_in">alias</span> default 14.17.6<br></code></pre></td></tr></table></figure><p>这将设置 Node.js 版本 14.17.6 为默认版本。</p><p>确认 Node.js 和 npm 是否正确安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure><p>如果一切顺利，您将看到 Node.js 和 npm 的版本号。</p><p>使用 nvm 切换 Node.js 版本：</p><p>使用以下命令查看可用的 Node.js 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm ls-remote<br></code></pre></td></tr></table></figure><p>该命令将显示可用的 Node.js 版本列表。</p><p>使用以下命令安装特定版本的 Node.js：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install &lt;node-version&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install 12.22.6<br></code></pre></td></tr></table></figure><p>这将安装 Node.js 版本 12.22.6。</p><p>使用以下命令切换到特定版本的 Node.js：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm use &lt;node-version&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm use 12.22.6<br></code></pre></td></tr></table></figure><p>这将切换到 Node.js 版本 12.22.6。</p><p>确认当前使用的 Node.js 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br></code></pre></td></tr></table></figure><p>如果一切顺利，您将看到当前使用的 Node.js 版本号。</p><h1 id="ERROR-合集"><a href="#ERROR-合集" class="headerlink" title="ERROR 合集"></a>ERROR 合集</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Error-Could-not-find-or-load-main-class-org-apache-maven-wrapper-MavenWrapperMain"><a href="#Error-Could-not-find-or-load-main-class-org-apache-maven-wrapper-MavenWrapperMain" class="headerlink" title="Error: Could not find or load main class org.apache.maven.wrapper.MavenWrapperMain"></a>Error: Could not find or load main class org.apache.maven.wrapper.MavenWrapperMain</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">maven 相关依赖还没下载完<br></code></pre></td></tr></table></figure><h3 id="JSON-parse-error-Cannot-construct-instance-of"><a href="#JSON-parse-error-Cannot-construct-instance-of" class="headerlink" title="JSON parse error: Cannot construct instance of"></a>JSON parse error: Cannot construct instance of</h3><p>确认请求方式是 get 还是 post，如果是 post 是不是前端发了一个空串。空串要用{}包裹</p><h3 id="Error-JAVA-HOME-is-not-defined-correctly"><a href="#Error-JAVA-HOME-is-not-defined-correctly" class="headerlink" title="Error: JAVA_HOME is not defined correctly"></a>Error: JAVA_HOME is not defined correctly</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 缺少.mavenrc 配置文件</span><br>vim ~/.mavenrc<br><span class="hljs-comment"># 将 JAVA 配置放进去</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/lib/jvm/jdk1dot8<br></code></pre></td></tr></table></figure><h3 id="配置数据表中不存在的字段"><a href="#配置数据表中不存在的字段" class="headerlink" title="配置数据表中不存在的字段"></a>配置数据表中不存在的字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@TableField(exist = false)</span><br></code></pre></td></tr></table></figure><h3 id="Error-creating-bean-with-name-‘minioController’-endpoint-must-not-be-null"><a href="#Error-creating-bean-with-name-‘minioController’-endpoint-must-not-be-null" class="headerlink" title="Error creating bean with name ‘minioController’  endpoint must not be null"></a>Error creating bean with name ‘minioController’  endpoint must not be null</h3><p>检查配置文件是否配置了 endpoint</p><h3 id="解决-MyBatis-报错-org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found"><a href="#解决-MyBatis-报错-org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found" class="headerlink" title="解决 MyBatis 报错 org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)"></a>解决 MyBatis 报错 org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</h3><p>1、检查 xml 文件的 namespace 是否对应接口，要是全路径。</p><p>2、xml 中的函数 id 和接口中的函数名是否对得上，参数类型、返回值类型是否对得上</p><p>3、去看输出目录中有没有 xml 映射文件，maven 项目默认把资源文件放在 src/main/resources 下，默认只识别 src/main/resources 下的资源文件。</p><h3 id="Unable-to-obtain-LocalDateTime-from-TemporalAccessor"><a href="#Unable-to-obtain-LocalDateTime-from-TemporalAccessor" class="headerlink" title="Unable to obtain LocalDateTime from TemporalAccessor"></a>Unable to obtain LocalDateTime from TemporalAccessor</h3><p>You can’t parse a date string into LocalDateTime without a time.</p><p>  LocalDateTime.parse(“2019-10-25”, DateTimeFormatter.ofPattern(“yyyy-MM-dd”))</p><p>You should parse the string into <code>LocalDate</code> and call <code>LocalDate.atStartOfDay()</code> to return <code>LocalDateTime</code> with time <code>00:00:00</code>.</p><p>  LocalDate.parse(“2019-10-25”, DateTimeFormatter.ofPattern(“yyyy-MM-dd”)).atStartOfDay()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 传入的时间格式要和解析的时间格式保持一致，如以下解析方式，传入参数  2023-03-08 11:11:11</span><br>LocalDateTime startDateTime = LocalDateTime.parse(startTime,<br>        DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br>LocalDateTime endDateTime = LocalDateTime.parse(endTime,<br>        DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br>        DateTimeFormatter localDateFmt = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>        <br>        <br> DateTimeFormatter localDateFmt = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;&quot;</span>.equals(startTime) &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(endTime)) &#123;<br>      LocalDate startDate = LocalDate.parse(startTime, localDateFmt);<br>      LocalDate endDate = LocalDate.parse(endTime, localDateFmt);<br>      LocalDateTime startDateTime = LocalDateTime.of(startDate, LocalTime.MIN);<br>      LocalDateTime endDateTime = LocalDateTime.of(endDate, LocalTime.MAX);<br>      log.debug(<span class="hljs-string">&quot;startDateTime: &quot;</span> + startDateTime);<br>      log.debug(<span class="hljs-string">&quot;endDateTime: &quot;</span> + endDateTime);<br>      queryWrapper.between(<span class="hljs-string">&quot;create_time&quot;</span>, startDateTime, endDateTime);<br>  &#125;<br><br></code></pre></td></tr></table></figure><h3 id="mybatisplus-提交数据后无法立即被查询到"><a href="#mybatisplus-提交数据后无法立即被查询到" class="headerlink" title="mybatisplus 提交数据后无法立即被查询到"></a>mybatisplus 提交数据后无法立即被查询到</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">提升事务隔离级别<br><span class="hljs-meta">@Transactional(isolation = Isolation.READ_UNCOMMITTED)</span><br><br></code></pre></td></tr></table></figure><h3 id="One-record-is-expected-but-the-query-result-is-multiple-records"><a href="#One-record-is-expected-but-the-query-result-is-multiple-records" class="headerlink" title="One record is expected, but the query result is multiple records"></a>One record is expected, but the query result is multiple records</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">解决方案：如果想取一条并不想报错时使用 getOne(queryWrapper,<span class="hljs-keyword">false</span>)<br><br></code></pre></td></tr></table></figure><h3 id="注意-mybatisplus-的-sql-返回值"><a href="#注意-mybatisplus-的-sql-返回值" class="headerlink" title="注意 mybatisplus 的 sql 返回值"></a>注意 mybatisplus 的 sql 返回值</h3><h3 id="java-lang-NumberFormatException-null"><a href="#java-lang-NumberFormatException-null" class="headerlink" title="java.lang.NumberFormatException: null"></a>java.lang.NumberFormatException: null</h3><p>检查使用 Integer.parseInt 转换时，是否转换的数可能为 null</p><h4 id="Unexpected-error-occurred-in-scheduled-taskjava-lang-NullPointerException-null"><a href="#Unexpected-error-occurred-in-scheduled-taskjava-lang-NullPointerException-null" class="headerlink" title="Unexpected error occurred in scheduled taskjava.lang.NullPointerException: null"></a>Unexpected error occurred in scheduled taskjava.lang.NullPointerException: null</h4><p>服务类没有正确注入，每一个需要注入类都需要添加 Autowire 注解</p><h3 id="Unhandled-exception-type"><a href="#Unhandled-exception-type" class="headerlink" title="Unhandled exception type"></a>Unhandled exception type</h3><p>原因：被强制异常处理的代码块，必须进行异常处理，否则编译器会提示“Unhandled exception type Exception”错误警告。</p><p>需要将代码写到 try catch 里！</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="数据库乱码，前端乱码"><a href="#数据库乱码，前端乱码" class="headerlink" title="数据库乱码，前端乱码"></a>数据库乱码，前端乱码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/mysql/my.cnf<br><span class="hljs-comment"># 填写如下配置</span><br>[client]<br>default-character-set=utf8mb4<br><br>[mysqld]<br>character-set-server = utf8mb4<br>collation-server = utf8mb4_unicode_ci<br>init_connect=<span class="hljs-string">&#x27;SET NAMES utf8mb4&#x27;</span><br>skip-character-set-client-handshake = <span class="hljs-literal">true</span><br><br>[mysql]<br>default-character-set = utf8mb4<br></code></pre></td></tr></table></figure><h3 id="nested-exception-is-java-lang-NullPointerException-with-root-cause"><a href="#nested-exception-is-java-lang-NullPointerException-with-root-cause" class="headerlink" title="nested exception is java.lang.NullPointerException] with root cause"></a>nested exception is java.lang.NullPointerException] with root cause</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/11-21-20-55f1e2de81e6858f99707dea6a5e0292-20230216112119-174d50.png"></p><h3 id="Error-attempting-to-get-column-‘motion-id’-from-result-set"><a href="#Error-attempting-to-get-column-‘motion-id’-from-result-set" class="headerlink" title="Error attempting to get column ‘motion_id’ from result set"></a>Error attempting to get column ‘motion_id’ from result set</h3><p>数据库字段类型与后端类型不一致</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="digital-envelope-routines-unsupported"><a href="#digital-envelope-routines-unsupported" class="headerlink" title="digital envelope routines::unsupported"></a>digital envelope routines::unsupported</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">export</span> NODE_OPTIONS=--openssl-legacy-provider<br></code></pre></td></tr></table></figure><h3 id="禁止跨域策略-CORS-policy"><a href="#禁止跨域策略-CORS-policy" class="headerlink" title="禁止跨域策略 (CORS policy)"></a>禁止跨域策略 (CORS policy)</h3><h3 id="node-–openssl-legacy-provider-is-not-allowed-in-NODE-OPTIONS"><a href="#node-–openssl-legacy-provider-is-not-allowed-in-NODE-OPTIONS" class="headerlink" title="node: –openssl-legacy-provider is not allowed in NODE_OPTIONS"></a>node: –openssl-legacy-provider is not allowed in NODE_OPTIONS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">unset NODE_OPTIONS<br><br></code></pre></td></tr></table></figure><h3 id="Unexpected-character-‘-’"><a href="#Unexpected-character-‘-’" class="headerlink" title="Unexpected character (‘}’"></a>Unexpected character (‘}’</h3><p>请求的时候最后一个字段后面不要加逗号</p><h3 id="The-value-of-the-‘Access-Control-Allow-Origin’-header-in-the-response-must-not-be-the-wildcard-‘-’-when-the-request’s-credentials-mode-is-‘include’-The-credentials-mode-of-requests-initiated-by-the-XMLHttpRequest-is-controlled-by-the-withCredentials-attribute"><a href="#The-value-of-the-‘Access-Control-Allow-Origin’-header-in-the-response-must-not-be-the-wildcard-‘-’-when-the-request’s-credentials-mode-is-‘include’-The-credentials-mode-of-requests-initiated-by-the-XMLHttpRequest-is-controlled-by-the-withCredentials-attribute" class="headerlink" title="The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’ when the request’s credentials mode is ‘include’. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute"></a>The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’ when the request’s credentials mode is ‘include’. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute</h3><p>这个错误通常是因为在使用 XMLHttpRequest 对象进行跨域请求时，服务器返回的响应头中的 Access-Control-Allow-Origin 的值为*，但请求的 withCredentials 属性被设置为 true，这两者之间是相互冲突的。</p><p>XMLHttpRequest 对象具有 withCredentials 属性，如果设置为 true，它将在请求中包括来自其他域的 cookie 等凭据信息。但是，如果服务器在响应头中将 Access-Control-Allow-Origin 设置为*，浏览器会禁止访问这些凭据信息。这是一项安全保护措施，防止敏感信息泄露。</p><p>解决这个问题的方法是，在服务器端，将 Access-Control-Allow-Origin 设置为请求来源的域名，而不是使用通配符*。这可以让浏览器安全地发送凭据信息。</p><p>在前端，需要将 withCredentials 属性设置为 true，以便在请求中包含凭据信息。同时，需要确保请求的来源域名与服务器端设置的 Access-Control-Allow-Origin 一致。</p><p>如果你无法更改服务器端的设置，可以考虑使用代理或者 JSONP 等跨域解决方案。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/02/22/3c3171236ca43b99771480eeea4a6f2f.png"></p><h3 id="VUE-项目端口不固定"><a href="#VUE-项目端口不固定" class="headerlink" title="VUE 项目端口不固定"></a>VUE 项目端口不固定</h3><h3 id="Application-run-failed-org-springframework-beans-factory-BeanCreationException-Error-creating-bean-with-name-‘communityInfoController’"><a href="#Application-run-failed-org-springframework-beans-factory-BeanCreationException-Error-creating-bean-with-name-‘communityInfoController’" class="headerlink" title="Application run failed org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘communityInfoController’"></a>Application run failed org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘communityInfoController’</h3><p>检查target/classes/mapper/DepartmentMapper.xml中的格式是否正确，检查引号是否多了，少了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">&lt;select id=<span class="hljs-string">&quot;findIdByOrgId&quot;</span> resultType=<span class="hljs-string">&quot;resultType=&quot;</span>java.lang.Integer<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string">SELECT CAST(id AS UNSIGNED) AS id FROM department WHERE organization_id = #&#123;orgId&#125;</span><br><span class="hljs-string">&lt;/select&gt;</span><br></code></pre></td></tr></table></figure><h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><ul><li>400-前后端参数对不上</li></ul><h3 id="POST-GET-there-is-already-xx-bean-method"><a href="#POST-GET-there-is-already-xx-bean-method" class="headerlink" title="{POST/GET} there is already xx bean method"></a>{POST/GET} there is already xx bean method</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/19-15-47-0a06b9a67f496f6ec023534fc4381876-20230217191545-f22ccc.png"></p><h3 id="NPM-启动-digital-envelope-routines-unsupported"><a href="#NPM-启动-digital-envelope-routines-unsupported" class="headerlink" title="NPM 启动:digital envelope routines::unsupported"></a>NPM 启动:digital envelope routines::unsupported</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">export</span> NODE_OPTIONS=--openssl-legacy-provider<br>npm run serve<br></code></pre></td></tr></table></figure><h3 id="The-field-file-exceeds-its-maximum-permitted-size-of-1048576-bytes"><a href="#The-field-file-exceeds-its-maximum-permitted-size-of-1048576-bytes" class="headerlink" title="The field file exceeds its maximum permitted size of 1048576 bytes"></a>The field file exceeds its maximum permitted size of 1048576 bytes</h3><p>spring boot 上传文件时接口报错 The field file exceeds its maximum permitted size of 1048576 bytes.经排查官方设置每个文件的配置最大为 1Mb，单次请求的文件的总数不能大于 10Mb，上传大于 1Mb 的文件需要修改配置文件（application.properties）<br>1.Spring Boot 1.3.x 或者之前</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">multipart.maxFileSize</span>=<span class="hljs-number">100</span>Mb<br><span class="hljs-attr">multipart.maxRequestSize</span>=<span class="hljs-number">1000</span>Mb<br></code></pre></td></tr></table></figure><p>2.Spring Boot 1.4.x 以后</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.http.multipart.maxFileSize</span>=<span class="hljs-number">100</span>Mb<br><span class="hljs-attr">spring.http.multipart.maxRequestSize</span>=<span class="hljs-number">1000</span>Mb<br></code></pre></td></tr></table></figure><p>3.Spring Boot 2.0 之后</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">spring</span>.servlet.multipart.<span class="hljs-keyword">max</span>-<span class="hljs-keyword">file</span>-<span class="hljs-keyword">size</span>=<span class="hljs-number">100</span>MB<br><span class="hljs-keyword">spring</span>.servlet.multipart.<span class="hljs-keyword">max</span>-request-<span class="hljs-keyword">size</span>=<span class="hljs-number">1000</span>MB<br></code></pre></td></tr></table></figure><h3 id="字段不存在"><a href="#字段不存在" class="headerlink" title="字段不存在"></a>字段不存在</h3><p>请求的时候字段名字和 java 中命名保持一直，而不是和数据库名字保持一样</p><h3 id="数据库-communications-link-failure"><a href="#数据库-communications-link-failure" class="headerlink" title="数据库 communications link failure"></a>数据库 communications link failure</h3><h3 id="配置请求超时时间"><a href="#配置请求超时时间" class="headerlink" title="配置请求超时时间"></a>配置请求超时时间</h3><p>src/utils/request.js</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-18-57-4ffa9b2c1ef5817aa81ba91b0257cddc-20230214141856-8b5215.png"></p><h3 id="Request-method-GET-not-supported"><a href="#Request-method-GET-not-supported" class="headerlink" title="Request method GET not supported"></a>Request method GET not supported</h3><p>前端请求事件没有设置请求方式  post 还是 get</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/10-27-11-20135e8d24b909084fc2d36e3ca3d469-20230208102710-382029.png"></p><h3 id="Invalid-cros-request"><a href="#Invalid-cros-request" class="headerlink" title="Invalid cros request"></a>Invalid cros request</h3><p>跨域</p><h3 id="处理未来数据"><a href="#处理未来数据" class="headerlink" title="处理未来数据"></a>处理未来数据</h3><p><a href="https://www.bilibili.com/video/BV1U44y1W77D?t=1655.5&p=23">https://www.bilibili.com/video/BV1U44y1W77D?t=1655.5&amp;p=23</a></p><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><h3 id="前端保存代码需要等待一段时间生效"><a href="#前端保存代码需要等待一段时间生效" class="headerlink" title="前端保存代码需要等待一段时间生效"></a>前端保存代码需要等待一段时间生效</h3><h3 id="获取用户-IP"><a href="#获取用户-IP" class="headerlink" title="获取用户 IP"></a>获取用户 IP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">String userIp =  request.getRemoteAddr();<br></code></pre></td></tr></table></figure><h3 id="解决方案：Java-实体类字段-不返回给前端"><a href="#解决方案：Java-实体类字段-不返回给前端" class="headerlink" title="解决方案：Java 实体类字段 不返回给前端"></a>解决方案：Java 实体类字段 不返回给前端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@JsonIgnore</span><br><span class="hljs-meta">@ApiModelProperty(value = &quot;不重要&quot;)</span><br><span class="hljs-meta">@TableField(exist = false)</span><br><span class="hljs-keyword">private</span> String unimportant;<br></code></pre></td></tr></table></figure><h3 id="Dateutil-包"><a href="#Dateutil-包" class="headerlink" title="Dateutil 包"></a>Dateutil 包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Calendar;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br></code></pre></td></tr></table></figure><h3 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>  <span class="hljs-comment">//获取请求参数</span><br>    String queryString = request.getQueryString();<br>    log.info(<span class="hljs-string">&quot;请求参数:&#123;&#125;&quot;</span>, queryString);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="后端设置-header-前端获取不到"><a href="#后端设置-header-前端获取不到" class="headerlink" title="后端设置 header 前端获取不到"></a>后端设置 header 前端获取不到</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"># 必须要加这条字段控制能够获取的 header<br>        response.addHeader(<span class="hljs-string">&quot;Access-Control-Expose-Headers&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>);<br>              response.addHeader(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;sdfdsfdsf&quot;</span>);<br><br></code></pre></td></tr></table></figure><h3 id="axios-请求"><a href="#axios-请求" class="headerlink" title="axios 请求"></a>axios 请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java">axios.get(<span class="hljs-string">&#x27;http://opm.eswincomputing.com:9090/user/page&#x27;</span>)<br>  .then(function (response) &#123;<br>    console.log(response.headers);<br>  &#125;)<br>  .<span class="hljs-keyword">catch</span>(function (error) &#123;<br>    console.log(error.headers);<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="查询端口占用"><a href="#查询端口占用" class="headerlink" title="查询端口占用"></a>查询端口占用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">lsof -i<br>lsof -i:<span class="hljs-number">8080</span>：查看 <span class="hljs-number">8080</span> 端口占用<br></code></pre></td></tr></table></figure><h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"># Application.yml<br>logging:<br>  level:<br>    com.eswincomputing.springboot: debug<br># 使用<br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/patch-record&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PatchRecordController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IPatchRecordService patchRecordServic<br>    log.info(version);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="校验字符串是否为空"><a href="#校验字符串是否为空" class="headerlink" title="校验字符串是否为空"></a>校验字符串是否为空</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">StrUtil.isBlank()<br></code></pre></td></tr></table></figure><h3 id="查询主键"><a href="#查询主键" class="headerlink" title="查询主键"></a>查询主键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">SELECT id FROM department WHERE organization_id = <span class="hljs-comment">#&#123;orgId&#125;</span><br><br></code></pre></td></tr></table></figure><h3 id="字符整型互转"><a href="#字符整型互转" class="headerlink" title="字符整型互转"></a>字符整型互转</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Integer.parseInt(user.getDelFlag())<br></code></pre></td></tr></table></figure><h3 id="解析-json-字符串"><a href="#解析-json-字符串" class="headerlink" title="解析 json 字符串"></a>解析 json 字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java">   <br>&lt;!-- json 解析 --&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>&lt;artifactId&gt;fastjson&lt;/artifactId&gt;<br>&lt;version&gt;<span class="hljs-number">2.0</span><span class="hljs-number">.21</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br><br>   JSONObject object = JSONObject.parseObject(patchRecord.getAttachmentList());<br>    String fileUID = object.getString(<span class="hljs-string">&quot;file_uid&quot;</span>);<br>    String fileName = object.getString(<span class="hljs-string">&quot;file_name&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="逗号分割字符串"><a href="#逗号分割字符串" class="headerlink" title="逗号分割字符串"></a>逗号分割字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java">String string = <span class="hljs-string">&quot;张三，李四，王五，马六，小气&quot;</span>;<br>       String substring = string.substring(<span class="hljs-number">0</span>, string.length() - <span class="hljs-number">1</span>);<br>       System.out.println(substring);<br>       String[] split = substring.split(<span class="hljs-string">&quot;,&quot;</span>);<span class="hljs-comment">//以逗号分割</span><br>       <span class="hljs-keyword">for</span> (String string2 : split) &#123;<br>           System.out.println(<span class="hljs-string">&quot;数据--&gt;&gt;&gt;&quot;</span> + string2);<br>       &#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>JAVA 开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用 Gitlab CI Pipeline</title>
    <link href="/2023/01/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Gitlab-CI-Pipeline/"/>
    <url>/2023/01/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Gitlab-CI-Pipeline/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 嵌入 Draw.io</title>
    <link href="/2023/01/07/Markdown%E5%B5%8C%E5%85%A5Draw-io/"/>
    <url>/2023/01/07/Markdown%E5%B5%8C%E5%85%A5Draw-io/</url>
    
    <content type="html"><![CDATA[<p>Markdown 是支持嵌入 HTML 的，大部分阅读器也都支持解析。Draw.io 可以导出为 HTML 格式。</p><p>文件—导出为 HTML—导出—新窗口打开—复制 HTML 代码—只保留<code>&lt;body&gt;</code>标签之间的内容，不包含<code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>。</p><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2023-01-07T02:39:36.940Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36\&quot; etag=\&quot;bw-obfhzFCRdb4Hl-GTj\&quot; version=\&quot;20.7.4\&quot; type=\&quot;device\&quot;&gt;&lt;diagram id=\&quot;qJU06MX9joVzOyRxsnLc\&quot; name=\&quot;第 1 页\&quot;&gt;7VvbcqM4EP0aHkMBErdH23F2pjapTW2m9vKUIiCDJhh5QTj2fP0KEGAQJk5iDNkdv9g0DUjnSEfdaiyBxXr3S+xsgjvioVDSFG8ngWtJ01TN0NhXZtkXFsO0CoMfY4871YYH/ANxo8KtKfZQ0nCkhIQUb5pGl0QRcmnD5sQxeWm6rUjYfOrG8ZFgeHCdULT+iT0aFFZLM2v7F4T9oHyyatjFmbVTOvOeJIHjkZcDE1hKYBETQotf690ChRl4JS7FdTdHzlYNi1FET7ng7jcPBNY/FHz7vt4u5ks0/3Z7pXI2tk6Y8h7z1tJ9CYEfk3QjgfmKRPSBm1V2nNCYPFeosP7MxSbxVm5RTNGuizDnqXxMjQkbTIisEY33zI9fZenFZXwYVePjpSbF0A1Z427BASfA4r4OHwt+dfcaLvaDI/YW9LTX0WPgRR7K7qIwhF4CTNHDxnGzsy9syjBbQNchh3SFw3BBQhKz44hE6J2o91Pd5kLEfFxQgQjq0pRsKM0saWlIliXNzcwys6X5TFrakm1KcygAzzpJm+gW0LXxFSF3QuxH7NBlgCJmn2eQYaYJM35ijT0ve0wnnU3Cx6CPzxGgd8wRpYPKoZiEpsDkgsHh4AjFV+JMSZ4RdQOOm5NsCjlf4V0G5iGPG4IjmjdWn0v6dRdjeJ3regF/saioWm2/xmufdSnET1nHEtdB7PuPu8dbHKU7Odn6IzHHz0KzpXaGyKTewSQ0hpqTApHXxH1mSGvK78jHSfYMMKtsX9KnybFbjbxH3mKMkg8wfWxhO8opMO0Gpx2UGrZsmiKrxlDzE4iiiTwW/fBDEtOA+CRywmVtbclb7XNLyIbj9x1Ruue8OCklXSp8iG5CnZjOsmCt1uDcdoOzDuUPQjtM/+J3yH7/ndllnR9d7w7crvcHB/coxgytbNjktqNMJiSNXdSDFp+SrF0+6pvufA5mSPaOixiFDsXbZpx5fo5FDX5KMQuCu5i/dZ5Y+N5g6/S1MEYJ/sHDOaVzHp+ol+Ww/HjQqMiqafFw4mS4+d3us+bXtypDPT57r6DevANZrRI2LNp0VW16P4P6Ee1lgQsSWCzZyZm8JwmmmGQsPRFKybpJbZtJmk1gkfBXoyaJRRDKfHmTT+XA2WRNWe/8LB+UnR9pjGQ3JKn3mKB4i12UPDIWV9hPYydr3GPeDz5cULzcomLUqJcSZk2FstFkV4OiOENT7giD9aG0uZKlC2vzgRK7oZMk2P0W4KhDkEUummy9W2fPrp/dE7pKYDjndovJQuf5RTWZDBxnf+DGVe64bhjNxwCeyN6c6G8rve6g3E7pdGc/ivaeVZCAGA1u0iRg99qk2dWTXVjOtxtxpciKbalN0fjYOjP8QgJHkpSPhHuKnMF8GPJBxb5g0GecGPTZg4jWW8VGK4OdSmz61aPtD/VX/IHV5z+M3EBxky1OownLDDynzECr7P++cafpyowh0JXv0emSvZCWusSGnHWT7ePZhmSZ0hJK87k0ZxfdfM2z9+nuG3yNmEpF7mW3DTQVyGUOV87qE3eDBotN/3fbem/f7LGsNmvQHHkPz+5hTYwMRmcNxzR1wjvHZekHoyfyyMvYE290CsuiV6s0MlOl2eJASVtUvq0CdQlsW8U8owNXQzcuqGiqmNL8iuIIidnM9MFUxgYTgs7gbNJ5hiorKmjkGcCEF8wzVL7n+WqiwRVp5ESjUsIyJOHFjWOJQ9sfwv5EA6qgz3+gRKPcd/40iUZZKT9LoqErrS3uyW9oqCJhP1ONswato6caQP+Ea4k0VolSPbVGWc6cqRQpxbfQJl+kLMty5yhS6mozhvvgHk/ZnOZNr9ppyYDC/LNmObRU222pnkDNEn4msY5Yj4sKg66apaGQbEWzSkOt2vnR/vCordsHuQRo5RIXXQROTSXgMLmEoEOGCmWoKdWnWTYDVh571p/WixVFf4U6rPAUnUUvZjOChYYlQxbCVB/YvPWZSrwGbCdDVm9L2/6vJUO6ZfT5D5QMidv4E0+GzrYg51UX1TjPGlzOxlKlW9o73Bpc/kNhUmLc/0rJxzXvP/LSCNBaivJKHbftf5G3QDRBID7JWyBl+eoMkTtgy0sD+RGrs+yw/jNR4V7/JQss/wU=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 18.04 安装Clang/LLVM 11</title>
    <link href="/2022/12/24/Ubuntu-18-04-%E5%AE%89%E8%A3%85Clang-LLVM-11/"/>
    <url>/2022/12/24/Ubuntu-18-04-%E5%AE%89%E8%A3%85Clang-LLVM-11/</url>
    
    <content type="html"><![CDATA[<h2 id="从-APT-安装"><a href="#从-APT-安装" class="headerlink" title="从 APT 安装"></a>从 APT 安装</h2><p>Install the GPG Key for <code>https://apt.llvm.org/</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -<br></code></pre></td></tr></table></figure><p>Add the repo for Clang 11 <code>stable-old</code> for Ubuntu 18.04 Bionic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-11 main&quot;</span> | sudo tee -a /etc/apt/sources.list<br>sudo apt-get update<br></code></pre></td></tr></table></figure><p>Install practically everything (except <code>python-clang-11</code> which for some reason doesn’t work)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get install libllvm-11-ocaml-dev libllvm11 llvm-11 llvm-11-dev llvm-11-doc llvm-11-examples llvm-11-runtime \<br>clang-11 clang-tools-11 clang-11-doc libclang-common-11-dev libclang-11-dev libclang1-11 clang-format-11 clangd-11 \<br>libfuzzer-11-dev lldb-11 lld-11 libc++-11-dev libc++abi-11-dev libomp-11-dev -y<br></code></pre></td></tr></table></figure><p>Make Clang 11 and everything related to it defaults</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo update-alternatives \<br>  --install /usr/lib/llvm              llvm             /usr/lib/llvm-11         50 \<br>  --slave   /usr/bin/llvm-config       llvm-config      /usr/bin/llvm-config-11  \<br>  --slave   /usr/bin/llvm-ar           llvm-ar          /usr/bin/llvm-ar-11 \<br>  --slave   /usr/bin/llvm-as           llvm-as          /usr/bin/llvm-as-11 \<br>  --slave   /usr/bin/llvm-bcanalyzer   llvm-bcanalyzer  /usr/bin/llvm-bcanalyzer-11 \<br>  --slave   /usr/bin/llvm-cov          llvm-cov         /usr/bin/llvm-cov-11 \<br>  --slave   /usr/bin/llvm-diff         llvm-diff        /usr/bin/llvm-diff-11 \<br>  --slave   /usr/bin/llvm-dis          llvm-dis         /usr/bin/llvm-dis-11 \<br>  --slave   /usr/bin/llvm-dwarfdump    llvm-dwarfdump   /usr/bin/llvm-dwarfdump-11 \<br>  --slave   /usr/bin/llvm-extract      llvm-extract     /usr/bin/llvm-extract-11 \<br>  --slave   /usr/bin/llvm-link         llvm-link        /usr/bin/llvm-link-11 \<br>  --slave   /usr/bin/llvm-mc           llvm-mc          /usr/bin/llvm-mc-11 \<br>  --slave   /usr/bin/llvm-mcmarkup     llvm-mcmarkup    /usr/bin/llvm-mcmarkup-11 \<br>  --slave   /usr/bin/llvm-nm           llvm-nm          /usr/bin/llvm-nm-11 \<br>  --slave   /usr/bin/llvm-objdump      llvm-objdump     /usr/bin/llvm-objdump-11 \<br>  --slave   /usr/bin/llvm-ranlib       llvm-ranlib      /usr/bin/llvm-ranlib-11 \<br>  --slave   /usr/bin/llvm-readobj      llvm-readobj     /usr/bin/llvm-readobj-11 \<br>  --slave   /usr/bin/llvm-rtdyld       llvm-rtdyld      /usr/bin/llvm-rtdyld-11 \<br>  --slave   /usr/bin/llvm-size         llvm-size        /usr/bin/llvm-size-11 \<br>  --slave   /usr/bin/llvm-stress       llvm-stress      /usr/bin/llvm-stress-11 \<br>  --slave   /usr/bin/llvm-symbolizer   llvm-symbolizer  /usr/bin/llvm-symbolizer-11 \<br>  --slave   /usr/bin/llvm-tblgen       llvm-tblgen      /usr/bin/llvm-tblgen-11<br><br>sudo update-alternatives \<br>  --install /usr/bin/clang                 clang                  /usr/bin/clang-11    50 \<br>  --slave   /usr/bin/clang++               clang++                /usr/bin/clang++-11 \<br>  --slave   /usr/bin/lld                   lld                    /usr/bin/lld-11 \<br>  --slave   /usr/bin/clang-format          clang-format           /usr/bin/clang-format-11  \<br>  --slave   /usr/bin/clang-tidy            clang-tidy             /usr/bin/clang-tidy-11  \<br>  --slave   /usr/bin/clang-tidy-diff.py    clang-tidy-diff.py     /usr/bin/clang-tidy-diff-11.py \<br>  --slave   /usr/bin/clang-include-fixer   clang-include-fixer    /usr/bin/clang-include-fixer-11 \<br>  --slave   /usr/bin/clang-offload-bundler clang-offload-bundler  /usr/bin/clang-offload-bundler-11 \<br>  --slave   /usr/bin/clangd                clangd                 /usr/bin/clangd-11 \<br>  --slave   /usr/bin/clang-check           clang-check            /usr/bin/clang-check-11 \<br>  --slave   /usr/bin/scan-view             scan-view              /usr/bin/scan-view-11 \<br>  --slave   /usr/bin/clang-apply-replacements clang-apply-replacements /usr/bin/clang-apply-replacements-11 \<br>  --slave   /usr/bin/clang-query           clang-query            /usr/bin/clang-query-11 \<br>  --slave   /usr/bin/modularize            modularize             /usr/bin/modularize-11 \<br>  --slave   /usr/bin/sancov                sancov                 /usr/bin/sancov-11 \<br>  --slave   /usr/bin/c-index-test          c-index-test           /usr/bin/c-index-test-11 \<br>  --slave   /usr/bin/clang-reorder-fields  clang-reorder-fields   /usr/bin/clang-reorder-fields-11 \<br>  --slave   /usr/bin/clang-change-namespace clang-change-namespace  /usr/bin/clang-change-namespace-11 \<br>  --slave   /usr/bin/clang-import-test     clang-import-test      /usr/bin/clang-import-test-11 \<br>  --slave   /usr/bin/scan-build            scan-build             /usr/bin/scan-build-11 \<br>  --slave   /usr/bin/scan-build-py         scan-build-py          /usr/bin/scan-build-py-11 \<br>  --slave   /usr/bin/clang-cl              clang-cl               /usr/bin/clang-cl-11 \<br>  --slave   /usr/bin/clang-rename          clang-rename           /usr/bin/clang-rename-11 \<br>  --slave   /usr/bin/find-all-symbols      find-all-symbols       /usr/bin/find-all-symbols-11 \<br>  --slave   /usr/bin/lldb                  lldb                   /usr/bin/lldb-11 \<br>  --slave   /usr/bin/lldb-server           lldb-server            /usr/bin/lldb-server-11<br></code></pre></td></tr></table></figure><h2 id="Installing-CMake"><a href="#Installing-CMake" class="headerlink" title="Installing CMake"></a>Installing CMake</h2><p>Install Kitware’s GPG Key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2&gt;/dev/null | gpg --dearmor - | sudo tee /etc/apt/trusted.gpg.d/kitware.gpg &gt;/dev/null<br></code></pre></td></tr></table></figure><p>Add repository</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb https://apt.kitware.com/ubuntu/ bionic main&quot;</span> | sudo tee -a /etc/apt/sources.list<br>sudo apt-get update<br></code></pre></td></tr></table></figure><p>Install this optional package so you don’t have to mess with GPG keys anymore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get install kitware-archive-keyring<br>sudo rm /etc/apt/trusted.gpg.d/kitware.gpg<br></code></pre></td></tr></table></figure><p>Now upgrade <code>cmake</code> if you already have it installed with <code>sudo apt-get upgrade -y</code> or just install it using <code>sudo apt-get install cmake -y</code> </p><h2 id="使用源码安装"><a href="#使用源码安装" class="headerlink" title="使用源码安装"></a>使用源码安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 更新软件包列表</span><br>sudo apt update<br><br><span class="hljs-comment"># 安装必要的依赖包</span><br>sudo apt install build-essential cmake python3-dev<br><br><span class="hljs-comment"># 下载 Clang/LLVM 11 的源代码</span><br>wget https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/llvm-11.0.0.src.tar.xz<br><br><span class="hljs-comment"># 解压源代码文件</span><br>tar xvf llvm-11.0.0.src.tar.xz<br><br><span class="hljs-comment"># 进入解压后的目录</span><br><span class="hljs-built_in">cd</span> llvm-11.0.0.src<br><br><span class="hljs-comment"># 创建一个新的目录，用于存放 Clang/LLVM 编译的结果</span><br>mkdir build<br><span class="hljs-built_in">cd</span> build<br><br><span class="hljs-comment"># 使用 cmake 编译 Clang/LLVM</span><br>cmake ..<br><br><span class="hljs-comment"># 编译 Clang/LLVM</span><br>make<br><br><span class="hljs-comment"># 安装 Clang/LLVM</span><br>sudo make install<br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>安装教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-chown 修改文件拥有者</title>
    <link href="/2022/12/04/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-chown%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8B%A5%E6%9C%89%E8%80%85/"/>
    <url>/2022/12/04/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-chown%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8B%A5%E6%9C%89%E8%80%85/</url>
    
    <content type="html"><![CDATA[<p>chown 命令用来变更文件或目录的拥有者或所属群组，通过 chown 改变文件的拥有者和群组。用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的文件列表，文件名也支持通配符。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash">chown [选项] [用户或组] [文件或目录]<br>-c或--changes           <span class="hljs-comment">#效果类似“-v”参数，但仅回报更改的部分；</span><br>-f或--quite或—-silent    <span class="hljs-comment">#不显示错误信息；</span><br>-h或--no-dereference    <span class="hljs-comment">#只对符号连接的文件作修改，而不更改其他任何相关文件；</span><br>-R或--recursive         <span class="hljs-comment">#递归处理，将指定目录下的所有文件及子目录一并处理；</span><br>-v或--version           <span class="hljs-comment">#显示指令执行过程；</span><br>--dereference          <span class="hljs-comment">#效果和“-h”参数相同；</span><br>--<span class="hljs-built_in">help</span>                 <span class="hljs-comment">#在线帮助</span><br>--reference=&lt;参考文件或目录&gt;   <span class="hljs-comment">#把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同；</span><br>--version    <span class="hljs-comment">#显示版本信息。</span><br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>将文件<code>test.md</code>拥有者改为<code>nic</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">chown nic test.md<br></code></pre></td></tr></table></figure><p>将目录<code>/home/nic/develop</code>及其下面的所有文件、子目录的文件拥有者改为<code>nic</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">chown -R nic /home/nic/develop<br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-tree 显示目录结构</title>
    <link href="/2022/12/04/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-tree%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <url>/2022/12/04/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-tree%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Bash">-a   <span class="hljs-comment">#显示所有文件</span><br>-d   <span class="hljs-comment">#只显示目录（名称）</span><br>-l   <span class="hljs-comment">#显示链接文件的原始文件</span><br>-f   <span class="hljs-comment">#显示所列出的文件或目录的完整目录路径</span><br>-i   <span class="hljs-comment">#不以阶梯的形式显示文件或目录名称</span><br>-q   <span class="hljs-comment">#将控制字符以?字符代替，显示文件和目录名称</span><br>-N   <span class="hljs-comment">#直接显示文件或目录的名称</span><br>-p   <span class="hljs-comment">#显示每个文件的权限信息</span><br>-u   <span class="hljs-comment">#显示文件所有者或者uid</span><br>-g   <span class="hljs-comment">#显示文件所属组或者gid</span><br>-s   <span class="hljs-comment">#显示每个文件的大小信息</span><br>-h   <span class="hljs-comment">#以可读的方式显示文件的大小信息</span><br>-D   <span class="hljs-comment">#显示最后修改日期</span><br>-v   <span class="hljs-comment">#按字母数字正序显示文件</span><br>-r   <span class="hljs-comment">#按字母数字倒序显示文件</span><br>-t   <span class="hljs-comment">#按最后时间排序显示文件</span><br>-C   <span class="hljs-comment">#在文件和目录列表上加上色彩，便于区分文件类型</span><br>-P pattern    <span class="hljs-comment">#只显示匹配正则表式的文件或目录名称</span><br>-I pattern    <span class="hljs-comment">#与上结果相反</span><br><br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>显示当前目录及其子目录下的文件及目录名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Bash">$ tree                 <br>.<br>├── CODE_OF_CONDUCT.md<br>├── CONTRIBUTING.md<br>├── Fedora-35<br>│   ├── Dockerfile<br>│   └── Readme.md<br>├── LICENSE<br>├── README.md<br>├── Ubuntu-20<br>│   ├── Dockerfile<br>│   ├── Readme.md<br>│   ├── init_edkrepo_conf.sh<br>│   └── ubuntu20_dev_entrypoint.sh<br>└── Windows-2022<br>    ├── Dockerfile<br>    └── Readme.md<br><br>3 directories, 12 files<br></code></pre></td></tr></table></figure><p>只显示一层目录结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash">$ tree -L 1              <br>.<br>├── CODE_OF_CONDUCT.md<br>├── CONTRIBUTING.md<br>├── Fedora-35<br>├── LICENSE<br>├── README.md<br>├── Ubuntu-20<br>└── Windows-2022<br><br>3 directories, 4 files<br></code></pre></td></tr></table></figure><p>只显示目录不显示文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">$ tree -d           <br>.<br>├── Fedora-35<br>├── Ubuntu-20<br>└── Windows-2022<br><br>3 directories<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeReview 中常见缩写</title>
    <link href="/2022/12/03/CodeReview%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%BC%A9%E5%86%99/"/>
    <url>/2022/12/03/CodeReview%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%BC%A9%E5%86%99/</url>
    
    <content type="html"><![CDATA[<ul><li>ASAP: As Soon As Possible. 请尽快完成</li><li>ACK: Acknowledgement. 承认，同意。表示接受代码的改动</li><li>CR: Code Review. 请求代码审查</li><li>CCN: Code Comments Needed.需要的代码注释：在这里有一些简短的注释在高层次上描述每个主要代码块的作用（例如，“处理 HTTP 请求中的标头”）会很有帮助</li><li>DOODOO: Documentation Out Of Date Or Obsolete.文档过时或过时：此文档似乎不正确：是否过时？</li><li>DNM: Do not merge. 不要合并</li><li>ditto: 多个重复的表述，下一次可以用 ditto 表示同上</li><li>IMO: In My Opinion 在我看来、依我看、依我所见</li><li>LGT1: Looks Good To 1. 如果有一个回复 LGTM 则可以添加为 LGT1，1 代表目前有 1 个赞</li><li>LGT2: Looks Good To 2. 如果有两个回复 LGTM 则可以添加为 LGT2，2 代表目前有 2 个赞</li><li>LGTM: Looks Good To Me. 代码已经过 review，可以合并</li><li>MCE: Must Check for Errors.必须检查错误：这里可能会发生错误或异常情况，但您没有任何代码来处理此类事件</li><li>MR：merge request. 合并请求</li><li>NACK/NAK: Negative acknowledgement. 不同意，不接受这次的改动</li><li>IMHO: In My Humble Opinion IMO 谦虚的说法</li><li>IMO: In My Opinion. 在我看来</li><li>IIRC: If I Recall Correctly. 如果我没有记错的话</li><li>PR：Pull Request. 拉取请求，给其他项目提交代码</li><li>PTAL: Please Take A Look. 提示项目 Owner/contributor review</li><li>RFC: Request For Comment. 请求进行讨论，表示认为某个想法很好，邀请大家一起讨论一下</li><li>RCP: Repeated Code Pattern.重复代码模式：与上面几行非常相似的代码在许多不同的地方重复出现。找到一种方法来简化它（例如，定义一个隐藏细节的更高级别的 API，或者找到一个更集中的地方来执行这些操作，这样这里就不需要这段代码了）。</li><li>SGTM: Sounds Good To Me. 和上面那句意思差不多，也是已经通过了 review 的意思</li><li>TBD: To Be Done. 未完成，待续</li><li>TL;DR: Too Long; Don’t Read. PR 内容太多，没办法看</li><li>TMLI: Too Many Levels of Indentation.Too Many Levels of Indentation：缩进太深的代码很难阅读。在大多数情况下，可以重构代码以减少嵌套级别。</li><li>WIP: Work In Progress. 告诉项目维护者这个功能还未完成，方便维护者 review 已提交的代码</li><li>TBR: To Be Reviewed. 提示维护者进行 review</li><li>TBD: To Be Done (or Defined/Discussed/Decided/Determined). 根据语境不同意义有所区别，但一般都是还没搞定的意思</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>CodeReview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OFFICE-解决 Word 编辑卡顿</title>
    <link href="/2022/12/03/OFFICE-%E8%A7%A3%E5%86%B3Word%E7%BC%96%E8%BE%91%E5%8D%A1%E9%A1%BF/"/>
    <url>/2022/12/03/OFFICE-%E8%A7%A3%E5%86%B3Word%E7%BC%96%E8%BE%91%E5%8D%A1%E9%A1%BF/</url>
    
    <content type="html"><![CDATA[<p>打开 Word 很快，但是一编辑就特别卡，尤其时拖动表格时几乎是逐帧移动。这是硬件图形加速问题。解决方式如下。</p><ol><li>打开 Word，点击左上角—&gt;文件—&gt;选项—&gt;高级，一直拉到“显示”；</li><li>勾选<strong>禁用硬件图形加速</strong>；</li><li>取消勾选<strong>子像素定位平滑屏幕上的字体</strong>。</li></ol><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/12/03/7215b5c4712d13d43182a8c610d64c37.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Office</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git clone下来的分支不完整</title>
    <link href="/2022/12/03/Git-clone%E4%B8%8B%E6%9D%A5%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8D%E5%AE%8C%E6%95%B4/"/>
    <url>/2022/12/03/Git-clone%E4%B8%8B%E6%9D%A5%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8D%E5%AE%8C%E6%95%B4/</url>
    
    <content type="html"><![CDATA[<p>将仓库<code>git clone</code>到本地后发现本地缺失了一些远程仓库的分支。一般发生在<code>git clone —depth 1</code>设置克隆深度时发生。因为有些大型项目一次性克隆容易出错，所以只克隆一层深度。</p><p>如远程有分支<code>branch_a</code>，克隆下来后使用<code>git branch -av</code>命令查看所有分支没有显示该分支，该如何解决？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git remote set-branches origin <span class="hljs-string">&#x27;branch_a&#x27;</span><br>git fetch -v<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手把手教你向开源社区提 Patch</title>
    <link href="/2022/11/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%90%91%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E6%8F%90Patch/"/>
    <url>/2022/11/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%90%91%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E6%8F%90Patch/</url>
    
    <content type="html"><![CDATA[<h1 id="提交补丁的最佳实践"><a href="#提交补丁的最佳实践" class="headerlink" title="提交补丁的最佳实践"></a>提交补丁的最佳实践</h1><blockquote><p>本文翻译自官方教程<a href="https://git-scm.com/docs/MyFirstContribution">Git - MyFirstContribution</a>，原文包含开发到提交的整个周期。但是想要提交的人应该都已经开发完代码了，所以本文用自己的实际例子重新写了一遍，省去了开发代码等流程，重点介绍如何使用 git send-email。</p></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="下载-OpenSBI-仓库"><a href="#下载-OpenSBI-仓库" class="headerlink" title="下载 OpenSBI 仓库"></a>下载 OpenSBI 仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/riscv-software-src/opensbi.git<br><span class="hljs-built_in">cd</span> opensbi<br></code></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>要从源代码构建 OpenSBI：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><blockquote><p>注：OpenSBI 的构建是可并行的。上面的命令可以添加<code>-j#</code>参数，如<code>-j12</code>。</p></blockquote><h3 id="确认要解决的问题"><a href="#确认要解决的问题" class="headerlink" title="确认要解决的问题"></a>确认要解决的问题</h3><p>在本文档中，我们将模拟提交一个简单的 Patch，<code>.gitignore</code>文件可以过滤不必要的文件，现在使用 VSCode 的用户越来越多，使用 VSCode 开发时常常会生成<code>.vscode</code>目录，但是这些文件不该被推送至远程，原仓库中的<code>.gitignore</code>文件中没有过滤该文件，我们给他加上。</p><p>为了能够模拟一次发送多个<code>commit</code>的场景，我们将再添加一个<code>.so</code>用来过滤编译过程中生成的<code>.so</code>文件。</p><h3 id="建立工作空间"><a href="#建立工作空间" class="headerlink" title="建立工作空间"></a>建立工作空间</h3><p>让我们先建立一个开发分支来进行我们的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b update_gitignore origin/master<br></code></pre></td></tr></table></figure><p>我们将在这里做一些提交，以演示如何将一个带有多个补丁的主题同时送审。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="过滤-vscode"><a href="#过滤-vscode" class="headerlink" title="过滤 .vscode"></a>过滤 .vscode</h3><p>打开文件<code>.gitignore</code>，为该文件添加<code>/.vscode/</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Object files</span><br>*.o<br>*.a<br>*.dep<br><br><span class="hljs-comment">#Build &amp; install directories</span><br>build/<br>install/<br><br><span class="hljs-comment"># Development friendly files</span><br>tags<br>cscope*<br><br>/.vscode/<br></code></pre></td></tr></table></figure><p>为以上修改做一次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br>On branch update_gitignore<br>Your branch is up to date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br><br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br><br>        modified:   .gitignore<br>$ git add .gitignore<br>$ git commit -s<br></code></pre></td></tr></table></figure><p>执行以上命令后将会弹出编辑框用来编写提交信息。主题行要少于 50 个字符，然后是一个空行（必须），然后是您的提交消息的正文。请记住要明确并提供更改的原因（理由），特别是如果无法从您的差异中轻松理解你的提交内容时。编辑提交消息时，不要删除上面 <code>Signed-off-by</code> 添加的 trailer。（由上面命令<code>-s</code>参数生成）。</p><p>其他规范请详细查阅目标社区的提交规范，如OpenSBI要求主题行需要以 <code>lib:</code>， <code>platform:</code>, <code>firmware:</code>, <code>docs:</code>, <code>utils:</code> 或者 <code>top:</code>为前缀，修改<code>.gitignore</code>属于<code>top</code>范畴，所以我们需要将其加在主题行上。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">top: filter .vscode folder<br><br>Filter the workspace&#x27;s &#x27;.vscode&#x27; directory by adding &#x27;/.vscode/&#x27; to the.gitignore file.<br><br>Signed-off-by: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br></code></pre></td></tr></table></figure><p>继续用 <code>git show</code> 检查您的新提交。尤其不要出现不需要在本次提交的内容。通常使用不同的 IDE 都可能会无意间生成一些配置文件等，请注意将其剔除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs text">commit 5dc340c29979d4c5d8c4d5a6e881348239714434 (HEAD -&gt; update_gitignore)<br>Author: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br>Date:   Fri Nov 18 16:06:21 2022 +0800<br><br>    top: filter .vscode folder<br>    <br>    Filter the workspace&#x27;s &#x27;.vscode&#x27; directory by adding &#x27;/.vscode/&#x27; to the.gitignore file.<br>    <br>    Signed-off-by: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br><br>diff --git a/.gitignore b/.gitignore<br>index 95692bb..90cf552 100644<br>--- a/.gitignore<br>+++ b/.gitignore<br>@@ -10,3 +10,5 @@ install/<br> # Development friendly files<br> tags<br> cscope*<br>+<br>+/.vscode/<br></code></pre></td></tr></table></figure><h3 id="过滤-cache"><a href="#过滤-cache" class="headerlink" title="过滤 .cache"></a>过滤 .cache</h3><p>与上一节步骤类似，我们在<code>.gitignore</code>文件中再添加一个<code>/.cache/</code>字段用来过滤<code>.cache</code>文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Object files</span><br>*.o<br>*.a<br>*.dep<br><br><span class="hljs-comment">#Build &amp; install directories</span><br>build/<br>install/<br><br><span class="hljs-comment"># Development friendly files</span><br>tags<br>cscope*<br><br>/.vscode/<br>/.cache/<br></code></pre></td></tr></table></figure><p>添加完我们就即使保存工作进度，新生成一个<code>commit</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .gitignore<br>git commit -s<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">top: filter .cache folder<br><br>Filter the workspace&#x27;s &#x27;.cache&#x27; directory by adding &#x27;/.cache/&#x27; to the.gitignore file.<br><br>Signed-off-by: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br></code></pre></td></tr></table></figure><p>以上我们就已经准备好所有的代码了，在大部分场景下可能修改的是<code>.c</code>或者<code>.h</code>等源文件，这就需要我们能够使代码编译、运行并且测试通过后再提交。</p><p>这里为了演示提交流程，就没有涉及这些步骤。接下来我们就要准备提交的补丁文件了。</p><h2 id="准备提交补丁"><a href="#准备提交补丁" class="headerlink" title="准备提交补丁"></a>准备提交补丁</h2><p>OpenSBI 项目是通过电子邮件发送补丁来进行代码审查的，当补丁准备好并得到社区认可后，维护者就会应用（Apply）这些补丁。OpenSBI 项目不接受来自 Pull Request 的贡献，而且通过电子邮件发送的补丁需要以指定的方式进行审核。</p><p>在研究如何将你的提交转化为电子邮件的补丁之前，让我们先分析一下最终的结果，即<strong>补丁系列</strong>（Patch Series）是什么样子。下面是 OpenSBI 邮件列表存档的网页界面上的补丁系列的摘要视图的一个例子。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/16-32-16-e3a06471e8dc4a8dc2d7c7ca641043e2-20221118163214-5afd66.png"></p><p>我们可以注意几点：</p><ul><li>每次提交都是以单独的邮件形式发送，提交信息的标题为主题，前缀为<code>[PATCH i/n]</code>，代表<code>n</code>个提交系列中的第 <code>i</code> 个提交。</li><li>每个补丁都是作为对<code>cover letter</code>的回复，<code>cover letter</code>的前缀为<code>[PATCH 0/n]</code>，序号为 0 的标题。</li><li>补丁系列的后续迭代被标记为 <code>PATCH v2</code>、<code>PATCH v3</code>，等等，以代替 <code>PATCH</code>。例如，<code>[PATCH v2 1/3]</code>将是第二次迭代中三个补丁的第一个补丁。每次迭代都有一个新的<code>cover letter</code>（如上面的<code>[PATCH v2 0/3]</code>），本身就是对前一次迭代的<code>cover letter</code>的回复（下面会有更多介绍）。</li></ul><blockquote><p>注：单一补丁的主题是以<code>[PATCH]</code>、<code>[PATCH v2]</code>等发送的，没有 <code>i/n</code> 编号。如上图中的第四个 Patch，就是一个单一补丁。</p></blockquote><h3 id="什么是-cover-letter"><a href="#什么是-cover-letter" class="headerlink" title="什么是 cover letter"></a>什么是 cover letter</h3><p>除了给每个补丁发一封邮件外，OpenSBI 社区还希望你的补丁能附带一封 cover letter。这是修改提交的一个重要组成部分，因为它概括了你想要做什么，以及为什么要这样做，比仅仅看你的补丁更明显。</p><p>你的 cover letter 的标题应该是能简洁地涵盖你整个主题分支的目的。就像我们的提交信息标题一样。下面是我们的系列标题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Update gitignore ---<br></code></pre></td></tr></table></figure><p>cover letter 的正文是用来给评审员提供额外的背景。一定要解释任何你的补丁自己没有说清楚的东西，但要记住，由于 cover letter 没有记录在提交历史中，任何可能对未来版本库历史的读者有用的东西也应该在你的提交信息中出现。</p><p>下文我们将介绍如何生成 cover letter 以及如何填写 cover letter。</p><h3 id="用-git-send-email-发送补丁"><a href="#用-git-send-email-发送补丁" class="headerlink" title="用 git send-email 发送补丁"></a>用 git send-email 发送补丁</h3><h4 id="前提条件-设置-git-send-email"><a href="#前提条件-设置-git-send-email" class="headerlink" title="前提条件 - 设置 git send-email"></a>前提条件 - 设置 git send-email</h4><p>对 <code>send-email</code> 的配置会根据你的操作系统和电子邮件供应商而有所不同，配置可以参考文档<a href="http://lifeislife.cn/2022/09/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git-send-mail%E7%BB%99%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E6%8F%90%E4%BA%A4Patch/">如何使用 git-send-mail 给开源社区提交 Patch - 如云泊</a>。</p><h4 id="准备初始补丁集"><a href="#准备初始补丁集" class="headerlink" title="准备初始补丁集"></a>准备初始补丁集</h4><p>在准备邮件本身之前，你需要准备补丁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git format-patch --cover-letter -o update_gitignore/ --base=auto  update_gitignore@&#123;u&#125;..update_gitignore<br></code></pre></td></tr></table></figure><ul><li><code>--cover-letter</code> 选项告诉 <code>format-patch</code> 为你创建一个 <code>cover letter</code> 模板。在你准备发送之前，你将需要填写该模板。</li><li><code>-o update_gitignore/</code> 选项告诉 <code>format-patch</code> 把补丁文件放到目录<code>update_gitignore</code>中。这样发送多个<code>commit</code>时就可以使用命令一次性发送，因为 <code>git send-email</code> 可以接收一个目录并从那里发送所有补丁。</li><li><code>--base=auto</code> 选项告诉命令记录”基本提交”，接收者将在此基础上应用补丁系列。自动值将使 <code>format-patch</code> 自动计算基本提交，即远程跟踪分支的最新提交和指定修订范围的合并基数。</li><li><code>update_gitignore@&#123;u&#125;..update_gitignore</code> 选项告诉 <code>format-patch</code> 为你在 <code>update_gitignore</code> 分支上创建的提交生成补丁，因为它是从上游分叉出来的。<code>@&#123;u&#125;</code>的意思就是从分叉开始到最新的提交。</li></ul><p>执行完该命令我们看看生成了哪些内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br>On branch update_gitignore<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/master&#x27;</span> by 2 commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br><br>        update_gitignore/<br><br>$ ls update_gitignore <br>0000-cover-letter.patch  0001-top-filter-.vscode-folder.patch  0002-top-filter-.cache-folder.patch<br></code></pre></td></tr></table></figure><p>该命令将为每次提交制作一个补丁文件。运行后，您可以用您喜欢的文本编辑器看一下每个补丁，确保一切正常。可以看到创建了一个<code>-o</code>参数中的<code>update_gitignore</code>文件夹，该文件夹下有三个文件，分别是 cover letter 和上文我们做的两次提交对应的补丁文件。</p><p>分别打开他们，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">From 30614e5469be4a2f930cca570836627a4e91f1d1 Mon Sep 17 00:00:00 2001<br>From: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br>Date: Fri, 18 Nov 2022 16:41:32 +0800<br>Subject: [PATCH 0/2] *** SUBJECT HERE ***<br><br>*** BLURB HERE ***<br><br>Dominic Zhang (2):<br>  top: filter .vscode folder<br>  top: filter .cache folder<br><br> .gitignore | 3 +++<br> 1 file changed, 3 insertions(+)<br><br><br>base-commit: 880685586dcee950d209088a461443449a1693ce<br>-- <br>2.17.1<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs text">From 5dc340c29979d4c5d8c4d5a6e881348239714434 Mon Sep 17 00:00:00 2001<br>From: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br>Date: Fri, 18 Nov 2022 16:06:21 +0800<br>Subject: [PATCH 1/2] top: filter .vscode folder<br><br>Filter the workspace&#x27;s &#x27;.vscode&#x27; directory by adding &#x27;/.vscode/&#x27; to the.gitignore file.<br><br>Signed-off-by: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br>---<br> .gitignore | 2 ++<br> 1 file changed, 2 insertions(+)<br><br>diff --git a/.gitignore b/.gitignore<br>index 95692bb..90cf552 100644<br>--- a/.gitignore<br>+++ b/.gitignore<br>@@ -10,3 +10,5 @@ install/<br> # Development friendly files<br> tags<br> cscope*<br>+<br>+/.vscode/<br>\ No newline at end of file<br>-- <br>2.17.1<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs text">From 30614e5469be4a2f930cca570836627a4e91f1d1 Mon Sep 17 00:00:00 2001<br>From: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br>Date: Fri, 18 Nov 2022 16:20:37 +0800<br>Subject: [PATCH 2/2] top: filter .cache folder<br><br>Filter the workspace&#x27;s &#x27;.cache&#x27; directory by adding &#x27;/.cache/&#x27; to the.gitignore file.<br><br>Signed-off-by: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br>---<br> .gitignore | 3 ++-<br> 1 file changed, 2 insertions(+), 1 deletion(-)<br><br>diff --git a/.gitignore b/.gitignore<br>index 90cf552..bf9d716 100644<br>--- a/.gitignore<br>+++ b/.gitignore<br>@@ -11,4 +11,5 @@ install/<br> tags<br> cscope*<br> <br>-/.vscode/<br>\ No newline at end of file<br>+/.vscode/<br>+/.cache/<br>\ No newline at end of file<br>-- <br>2.17.1<br></code></pre></td></tr></table></figure><blockquote><p>注：另外，你也可以使用 <code>--rfc</code> 参数，在你的补丁主题前加上<code>[RFC PATCH]</code>，而不是<code>[PATCH]</code>。RFC 是”请求评论”的意思，表示虽然你的代码还没有准备好提交，但你想开始代码审查过程。你也可能在列表中看到标有”WIP”的补丁，这意味着他们还没有完成，但希望审查者能看看他们目前的成果。你可以用<code>--subject-prefix=WIP</code>来添加这个标志。</p></blockquote><p>检查并确保你的补丁和 cover letter 模板存在于你指定的目录中，这就完成所有准备了。</p><h4 id="准备邮件"><a href="#准备邮件" class="headerlink" title="准备邮件"></a>准备邮件</h4><p>由于你在调用 <code>format-patch</code> 时使用了<code>--cover-letter</code>，你已经准备好了一个 cover letter 模板。在你喜欢的编辑器中打开它。</p><p>你应该看到已经有一些标题存在。检查你的<code>From:</code>标题是否正确。然后修改你的<code>Subject:</code>。</p><p>确保保留<code>[PATCH 0/X]</code>的部分；这是向 Git 社区表明这封邮件是一个补丁系列的开始，许多审查者会根据这种类型的标记过滤他们的邮件。</p><p>接下来，你必须填写你的 cover letter 的正文。同样，关于应包括哪些内容，见上文。</p><p>最后，信中会包括用于生成补丁的 Git 的版本。你可以不用管这个字符串。</p><p>完善后的 cover letter 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">From 30614e5469be4a2f930cca570836627a4e91f1d1 Mon Sep 17 00:00:00 2001<br>From: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br>Date: Fri, 18 Nov 2022 16:41:32 +0800<br>Subject: [PATCH 0/2] Update gitignore<br><br>vscode is a very popular IDE, and it often needs to generate a.vscode. cache directory to hold workspace configuration files that should not be committed to a remote repository, so we made some modifications to the gitignore file to filter such directories.<br><br>Dominic Zhang (2):<br>  top: filter .vscode folder<br>  top: filter .cache folder<br><br> .gitignore | 3 +++<br> 1 file changed, 3 insertions(+)<br><br><br>base-commit: 880685586dcee950d209088a461443449a1693ce<br>-- <br>2.17.1<br></code></pre></td></tr></table></figure><h4 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h4><p>到这里，你应该有一个目录 <code>update_gitignore/</code>，里面包含你的补丁和一封 cover letter。是时候把它发出去了！你可以像这样发送。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git send-email --to=target@example.com update_gitignore/*.patch<br></code></pre></td></tr></table></figure><blockquote><p>注：请查看 <code>git help send-email</code> 中的一些其他选项，你可能会发现这些选项很有价值，比如改变回复地址或添加更多的抄送地址或密送地址。</p></blockquote><blockquote><p>注：当你发送一个真正的补丁时，它将被发送到 <code>opensbi@lists.infradead.org</code> - 但请不要把你的补丁集从教程中发送到真正的邮件列表中！现在你可以把它发送给你自己，以确保你了解它的形式。</p></blockquote><p>在你运行上面的命令后，你会为每个即将发出的补丁看到一个交互提示。这给了你最后一次机会来编辑或放弃发送一些东西（但还是那句话，不要用这种方式编辑代码）。一旦你在这些提示下按下 <code>y</code> 或 <code>a</code>，你的邮件就会被发送出去！Congratulation!</p><h4 id="发送补丁的更新版本"><a href="#发送补丁的更新版本" class="headerlink" title="发送补丁的更新版本"></a>发送补丁的更新版本</h4><p>本节将重点介绍如何发送你的补丁集的 v2 版。我们将在 v2 版中重新使用我们的 <code>update_gitignore</code> 分支。在我们做任何改动之前，我们先新建一个名为<code>update_gitignore-v1</code>的分支，这个分支是我们没有做新的改动的分支。这样在后面我们就可以方便的进行对比差异。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout update_gitignore<br>git branch update_gitignore-v1<br></code></pre></td></tr></table></figure><p>在更新补丁时，我们可能会遇到两种情况，一种是社区的意见只让修改最新的一个提交，一种是修改历史记录中的 commit。我们分别来处理这两种情况。</p><h5 id="如何修改最新的提交"><a href="#如何修改最新的提交" class="headerlink" title="如何修改最新的提交"></a>如何修改最新的提交</h5><p>比如只需要修改<code>top: filter .cache folder</code>这个 commit。因为它在我们的修改中是最新的 commit，所以我们可以直接对代码修改。比如我们做一个简单的修改，给修改的内容<code>/.cache</code>加个注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text"># Object files<br>*.o<br>*.a<br>*.dep<br><br>#Build &amp; install directories<br>build/<br>install/<br><br># Development friendly files<br>tags<br>cscope*<br><br>/.vscode/<br><br># Cache file<br>/.cache/<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .gitignore<br>git commit --amend<br></code></pre></td></tr></table></figure><p><strong>注意</strong>！我们不需要生成新的<code>commit</code>，所以使用 <code>--amend</code>参数修改最新的<code>commit message</code>即可。执行这条命令会弹出编辑窗口，因为修改内容已经很明确，我们不需要在<code>commit message</code>里再做额外说明，直接保存退出即可。如果修改内容比较大，需要重新编写<code>commit message</code>。</p><p>以上我们就完成了一次更新。</p><h5 id="如何修改历史记录中的提交"><a href="#如何修改历史记录中的提交" class="headerlink" title="如何修改历史记录中的提交"></a>如何修改历史记录中的提交</h5><p>如果很不巧，社区要求修改的是<code>top: filter .vscode folder</code>这个提交的内容，那怎么办，因为它不是最新的提交，而是上一个提交，我们无法使用<code>git commit --amend</code>来直接对他修改，好在 Git 十分强大，不需要我们<code>reset</code>就可以完成这样的工作。</p><p>同样我们也做一个简单的修改，为<code>/.vscode/</code>也添加一个注释。首先我们需要使用到<code>git rebase</code>这个强大的命令。本文只介绍使用到的功能，其他功能需要大家自行摸索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase -i<br></code></pre></td></tr></table></figure><p>这条命令会弹出编辑窗口，<code>-i</code>参数表示以交互式方式进行变基（rebase）操作。弹出窗口内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">pick 7175772 top: filter .vscode folder<br>pick 52b63f3 top: filter .cache folder<br><br><span class="hljs-comment"># Rebase 8806855..52b63f3 onto 8806855 (2 commands)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Commands:</span><br><span class="hljs-comment"># p, pick = use commit</span><br><span class="hljs-comment"># r, reword = use commit, but edit the commit message</span><br><span class="hljs-comment"># e, edit = use commit, but stop for amending</span><br><span class="hljs-comment"># s, squash = use commit, but meld into previous commit</span><br><span class="hljs-comment"># f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="hljs-comment"># x, exec = run command (the rest of the line) using shell</span><br><span class="hljs-comment"># d, drop = remove commit</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However, if you remove everything, the rebase will be aborted.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that empty commits are commented out</span><br></code></pre></td></tr></table></figure><p>窗口会显示所有未提交到远程的 commit，下面的注释也告诉了我们该如何使用。我们找到<code>edit</code>的行，可以看到解释为使用当前的 commit，但是在变基过程中会停下来让我们修改。这正是我们想要的。我们编辑当前的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">edit 7175772 top: filter .vscode folder<br>pick 52b63f3 top: filter .cache folder<br></code></pre></td></tr></table></figure><p>表示我们需要编辑历史记录中的<code>top: filter .vscode folder</code>提交，但是另一个 commit 我们不做改变。保存并退出当前窗口后，会有如下提示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Stopped at 7175772...  top: filter .vscode folder<br>You can amend the commit now, with<br><br>  git commit --amend <br><br>Once you are satisfied with your changes, run<br><br>  git rebase --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><p>根据提示，我们可以进行一系列修改了，修改完使用<code>git commit --amend</code>保存，如果一切符合自己要求了，再使用<code>git rebase --continue</code>完成变基操作。</p><p>我们先修改代码，可以看到代码已经回到了没有<code>/.cache/</code>的状态，我们添加一行注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text"># Object files<br>*.o<br>*.a<br>*.dep<br><br>#Build &amp; install directories<br>build/<br>install/<br><br># Development friendly files<br>tags<br>cscope*<br><br># VSCode config file<br>/.vscode/<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .gitignore<br>git commit --amend<br></code></pre></td></tr></table></figure><p>同样弹出窗口后我们直接保存退出，如果修改幅度较大，可以进一步补充说明。然后使用以下命令继续完成变基。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><p>此时我们可以看到我们不仅修改了历史记录中的 commit，还保证了最新的 commit 没有丢失或者更改。</p><h5 id="准备更新版本的补丁集"><a href="#准备更新版本的补丁集" class="headerlink" title="准备更新版本的补丁集"></a>准备更新版本的补丁集</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"> $ git format-patch -v2 --cover-letter -o update_gitignore/   master..update_gitignore-v1<br>update_gitignore/v2-0000-cover-letter.patch<br>update_gitignore/v2-0001-top-filter-.vscode-folder.patch<br>update_gitignore/v2-0002-top-filter-.cache-folder.patch<br></code></pre></td></tr></table></figure><p><code>--range-diff  master..update_gitignore-v1</code> 参数告诉 <code>format-patch</code> 在 cover letter 中包括 <code>update_gitignore-v1</code> 和 <code>update_gitignore</code> 两个分支之间的差异。这有助于告诉评审人你的 v1 和 v2 补丁之间的差异。</p><p><code>-v2</code> 参数告诉 <code>format-patch</code> 将你的补丁输出为 <code>v2</code> 版本。例如，你可能注意到你的 v2 版补丁都被命名为 <code>v2-000n-my-commit-subject.patch</code>。<code>-v2</code> 也会将你的补丁格式化，在前面加上<code>[PATCH v2]</code>，而不是<code>[PATCH]</code>。</p><p>运行此命令后，<code>format-patch</code> 会将补丁输出到 <code>update_gitignore/</code> 目录，与 v1 版的补丁一起。使用一个目录可以方便在校对 v2 补丁时参考旧的 v1 补丁，但你需要注意只发送 v2 补丁。我们将使用 <code>update_gitignore/v2-.patch</code>这样的模式（而不是 <code>update_gitignore/.patch</code>，这将匹配 v1 和 v2 补丁）。</p><p>再次编辑你的 cover letter。现在是一个很好的时间来提及你的上一个版本和现在有什么不同，如果它是重要的东西。你不需要在你的第二封 cover letter 中使用完全相同的内容；重点是向审查人员解释你所做的可能不那么明显的变化。</p><p>我们就简单的写一下添加了注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">From 30614e5469be4a2f930cca570836627a4e91f1d1 Mon Sep 17 00:00:00 2001<br>From: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br>Date: Fri, 18 Nov 2022 19:35:06 +0800<br>Subject: [PATCH v2 0/2] Update gitignore<br><br>Add a comment for the folder name.<br><br>Dominic Zhang (2):<br>  top: filter .vscode folder<br>  top: filter .cache folder<br><br> .gitignore | 3 +++<br> 1 file changed, 3 insertions(+)<br><br>-- <br>2.17.1<br></code></pre></td></tr></table></figure><p>发送更新版本时你需要将新版本抄送给提出建议的人，你可以在你的 cover letter 中直接添加这些抄送行，在 Subject 行上面写上这样一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">CC: Name &lt;name@example.com&gt;<br></code></pre></td></tr></table></figure><p>例如，把更新的邮件抄送给我自己：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">From 30614e5469be4a2f930cca570836627a4e91f1d1 Mon Sep 17 00:00:00 2001<br>From: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br>CC: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;<br>Date: Fri, 18 Nov 2022 19:35:06 +0800<br>Subject: [PATCH v2 0/2] Update gitignore<br><br>Add a comment for the folder name.<br><br>Dominic Zhang (2):<br>  top: filter .vscode folder<br>  top: filter .cache folder<br><br> .gitignore | 3 +++<br> 1 file changed, 3 insertions(+)<br><br>-- <br>2.17.1<br></code></pre></td></tr></table></figure><p>现在再次发送电子邮件，注意你传入的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git send-email --to target@example.com update_gitignore/v2-*.patch<br></code></pre></td></tr></table></figure><p>恭喜你完成了一次补丁版本更新。</p><hr><p>对于一些社区，要求更新的版本需要在同一个 thread 上进行。如下示例这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">[PATCH 0/2] Here is what I did...<br>  [PATCH 1/2] Clean up and tests<br>  [PATCH 2/2] Implementation<br>  [PATCH v2 0/3] Here is a reroll<br>    [PATCH v2 1/3] Clean up<br>    [PATCH v2 2/3] New tests<br>    [PATCH v2 3/3] Implementation<br></code></pre></td></tr></table></figure><p>就是更新的版本需要关联到之前的版本，而不能作为单独的一个列表。</p><p>你还需要去找到你之前的 cover letter 的 Message-Id。你可以在发送第一个补丁系列时，从 <code>git send-email</code> 的输出中记下它。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git send-email --to Dominic Zhang@gmail.com update_gitignore/v2-*.patch <br><br>update_gitignore/v2-0000-cover-letter.patch<br>update_gitignore/v2-0001-top-filter-.vscode-folder.patch<br>update_gitignore/v2-0002-top-filter-.cache-folder.patch<br>(mbox) Adding cc: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt; from line <span class="hljs-string">&#x27;From: Dominic Zhang &lt;Dominic Zhang@gmail.com&gt;&#x27;</span><br>(mbox) Adding cc: Dominic Zhang &lt;254758318@qq.com&gt; from line <span class="hljs-string">&#x27;CC: Dominic Zhang &lt;254758318@qq.com&gt;&#x27;</span><br><br>From: Dominic Zhang@gmail.com<br>To: Dominic Zhang@gmail.com<br>Cc: Dominic Zhang &lt;254758318@qq.com&gt;<br>Subject: [PATCH v2 0/2] Update gitignore<br>Date: Fri, 18 Nov 2022 19:54:54 +0800<br>Message-Id: &lt;20221118115456.2242-1-Dominic Zhang@gmail.com&gt;<br>X-Mailer: git-send-email 2.17.1<br></code></pre></td></tr></table></figure><p>你也可以从社区的邮箱列表中找到 Message ID，因为 OpenSBI 不要求在同一个 thread 回复，所以没有相关信息，这里以<a href="https://lore.kernel.org/git/cover-00.12-00000000000-20221118T112205Z-avarab@gmail.com/T/#t">Git 社区</a>的邮箱列表为例。随便点击一个补丁主题，在页面中找到<code>permalink</code>或者<code>raw</code>，点击打开即可找到 Message ID 信息。</p><p>它的格式一般如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Message-Id: &lt;foo.12345.author@example.com&gt;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20-11-53-e32c2da586e2b273cd1647e391c5c814-20221118201152-50efbe.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20-12-36-60538da64fc2af130b05eceb7c38cc52-20221118201235-5e5ace.png"></p><p>如果要发送更新版本，那么我们就需要找到上一版本的 Message ID。如发送的是 V3 版本，那么我们需要找到 V2 版本的 Message ID。并且在发送邮件时添加如下参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git send-email --to Dominic Zhang@gmail.com <br>                 --in-reply-to=<span class="hljs-string">&quot;&lt;foo.12345.author@example.com&gt;&quot;</span> <br>                 update_gitignore/v2-*.patch <br></code></pre></td></tr></table></figure><h4 id="只有一个-Patch-的更改"><a href="#只有一个-Patch-的更改" class="headerlink" title="只有一个 Patch 的更改"></a>只有一个 Patch 的更改</h4><p>在某些情况下，你的非常小的变化可能只包括一个补丁。这时，你只需要发送一封邮件。你的提交信息应该已经很有意义了，你只需要生成补丁文件就可以发送了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git format-patch -o update_gitignore/  HEAD^<br></code></pre></td></tr></table></figure><ul><li><code>HEAD^</code>参数表示生成与上一个提交之间的差异。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>OpenSBI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更换 Debian 软件更新源</title>
    <link href="/2022/11/05/Linux%E6%9B%B4%E6%8D%A2Debian%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/"/>
    <url>/2022/11/05/Linux%E6%9B%B4%E6%8D%A2Debian%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="确认-Debian-版本"><a href="#确认-Debian-版本" class="headerlink" title="确认 Debian 版本"></a>确认 Debian 版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat /etc/os-release               <br>PRETTY_NAME=<span class="hljs-string">&quot;Debian GNU/Linux 10 (buster)&quot;</span><br>NAME=<span class="hljs-string">&quot;Debian GNU/Linux&quot;</span><br>VERSION_ID=<span class="hljs-string">&quot;10&quot;</span><br>VERSION=<span class="hljs-string">&quot;10 (buster)&quot;</span><br>VERSION_CODENAME=buster<br>ID=debian<br>HOME_URL=<span class="hljs-string">&quot;https://www.debian.org/&quot;</span><br>SUPPORT_URL=<span class="hljs-string">&quot;https://www.debian.org/support&quot;</span><br>BUG_REPORT_URL=<span class="hljs-string">&quot;https://bugs.debian.org/&quot;</span><br></code></pre></td></tr></table></figure><p>括号里的<code>buster</code>就是版本信息。</p><h2 id="获取镜像地址"><a href="#获取镜像地址" class="headerlink" title="获取镜像地址"></a>获取镜像地址</h2><p>打开<a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">debian | 清华大学开源软件镜像站</a>，选择<code>buster</code>版本，复制所有镜像地址。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/11/05/54a39f7d33cf13259607144e03747e5a.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free</span><br><br>deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free</span><br><br>deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free</span><br></code></pre></td></tr></table></figure><h2 id="备份原文件"><a href="#备份原文件" class="headerlink" title="备份原文件"></a>备份原文件</h2><p>这也算是系统文件的一部分，还是保险一点，出错了再改回来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup<br></code></pre></td></tr></table></figure><h2 id="打开并修改"><a href="#打开并修改" class="headerlink" title="打开并修改"></a>打开并修改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p><code>vim</code>用的不习惯的估计会和我一样找全选内容怎么操作。教给你了<br>在命令模式下，就是按一下<code>esc</code>键，然后输入<code>ggvG</code>。具体什么含义看<code>VIM 笔记</code>吧，选择后直接<code>delete</code>删除，镜像地址粘贴进去。保存退出。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get dist-upgrade<br>sudo apt-get upgrade<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Debian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU&#39;s instance_init() vs. realize()</title>
    <link href="/2022/11/01/QEMU-s-instance-init-vs-realize/"/>
    <url>/2022/11/01/QEMU-s-instance-init-vs-realize/</url>
    
    <content type="html"><![CDATA[<p>转载自<a href="https://github.com/huth">huth (Thomas Huth)</a>的一篇文章，原文已经 404，从网页快照中找回的文章。</p><p>Note that this is a blog post for (new) QEMU developers. If you are just interested in using QEMU, you can certainly skip this text. Otherwise, in case you have ever been in touch with the QEMU device model (“qdev”), you are likely aware of the basic qdev code boilerplate already:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mydev_realize</span><span class="hljs-params">(DeviceState *dev, Error **errp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mydev_instance_init</span><span class="hljs-params">(Object *obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">static</span> Property mydev_properties[] = &#123;<br>    DEFINE_PROP_xxx(<span class="hljs-string">&quot;myprop&quot;</span>, MyDevState, field, ...),<br>    <br>    DEFINE_PROP_END_OF_LIST(),<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mydev_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-keyword">void</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br><br>    dc-&gt;realize = mydev_realize;<br>    dc-&gt;desc = <span class="hljs-string">&quot;My cool device&quot;</span>;<br>    dc-&gt;props = mydev_properties;<br>    <br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo mydev_info = &#123;<br>    .name          = TYPE_MYDEV,<br>    .parent        = TYPE_SYS_BUS_DEVICE,  <br>    .instance_size = <span class="hljs-keyword">sizeof</span>(mydev_state),<br>    .instance_init = mydev_instance_init,<br>    .class_init    = mydev_class_init,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mydev_register_types</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    type_register_static(&amp;mydev_info);<br>&#125;<br><br>type_init(mydev_register_types)<br></code></pre></td></tr></table></figure><p>There are three different initialization functions involved here, the <strong>class_init</strong>, the <strong>instance_init</strong> and the <strong>realize</strong> function. While it is quite obvious to distinguish the <em>class_init</em> function from the two others (it is used for initializing the class data, not the data that is used for an instance … this is similar to the object model with classes and instances in C++), I initially always wondered about the difference between the <em>instance_init()</em> and the <em>realize()</em> functions. Having fixed quite a lot of related bugs in the past months in the QEMU code base, I now know that a lot of other people are also not properly aware of the difference here, so I think it is now time to write down some information that I’m now aware of, to make sure that I don’t forget about this again, and maybe help others to avoid related bugs in the future ;-)</p><p>First it is of course always a good idea to have a look at the documentation. While the <a href="https://translate.google.com/website?sl=en&tl=zh-CN&hl=zh-CN&prev=search&u=https://git.qemu.org/?p=qemu.git;a=blob;f=include/qom/object.h;hb=v3.0.0%23l427">documentation of </a><a href="https://translate.google.com/website?sl=en&tl=zh-CN&hl=zh-CN&prev=search&u=https://git.qemu.org/?p=qemu.git;a=blob;f=include/qom/object.h;hb=v3.0.0%23l427"><em>TypeInfo</em></a> (where <a href="https://translate.google.com/website?sl=en&tl=zh-CN&hl=zh-CN&prev=search&u=https://git.qemu.org/?p=qemu.git;a=blob;f=include/qom/object.h;hb=v3.0.0%23l434"><em>instance_init()</em></a> is defined) is not very helpful to understand the differences, the <a href="https://translate.google.com/website?sl=en&tl=zh-CN&hl=zh-CN&prev=search&u=https://git.qemu.org/?p=qemu.git;a=blob;f=include/hw/qdev-core.h;hb=v3.0.0%23l40">documentation of </a><a href="https://translate.google.com/website?sl=en&tl=zh-CN&hl=zh-CN&prev=search&u=https://git.qemu.org/?p=qemu.git;a=blob;f=include/hw/qdev-core.h;hb=v3.0.0%23l40"><em>DeviceClass</em></a> (where <a href="https://translate.google.com/website?sl=en&tl=zh-CN&hl=zh-CN&prev=search&u=https://git.qemu.org/?p=qemu.git;a=blob;f=include/hw/qdev-core.h;hb=v3.0.0%23l43"><em>realize()</em></a> is defined) has some more useful information: You can learn here that the object instantiation is done first, before the device is realized, i.e. the <em>instance_init()</em> function is called first, and the <em>realize()</em> function is called afterwards. The former must not fail, while the latter can return an error to its caller via a pointer to an <em>“Error”</em> object pointer.</p><p>So the basic idea here is that device objects are first instantiated, then these objects can be inspected for their interfaces and their creators can set up their properties to configure their settings and wire them up with other devices, before the device finally becomes “active” by being <em>realized</em>. It is important here to notice that <strong>devices can be instantiated (and also finalized) <em><strong><strong>without</strong></strong></em> being realized</strong>! This happens for example if the device is introspected: If you enter for example <code>device_add xyz,help</code> at the HMP monitor, or if you send the <code>device-list-properties</code> QOM command to QEMU to retrieve the device’s properties, QEMU creates a temporary instance of the device to query the properties of the object, without realizing it. The object gets destroyed (“finalized”) immediately afterwards.</p><p>Knowing this, you can avoid a set of bugs which could be found with a couple of devices in the past:</p><ul><li>If you want your device to provide properties for other parts of the QEMU code or for the users, and you want to add those properties via one of the many object_property_add*() functions of QEMU (instead of using the <em>“props”</em> field of the <em>DeviceClass</em>), then you should do this in the <em>instance_init()</em> and not in the <em>realize()</em> function. Otherwise the properties won’t show up when the user runs <code>--device xyz,help</code> or the <code>device-list-properties</code> QOM command to get some information about your device.</li><li><em>instance_init()</em> functions must really never fail, i.e. also not call <em>abort()</em> or <em>exit()</em>. Otherwise QEMU can terminate unexpectedly when a user simply wanted to have a look at the list of device properties with <code>device_add xyz,help</code> or the <code>device-list-properties</code> QOM command. If your device cannot work in certain circumstances, check for the error condition in the <em>realize()</em> function instead and return with an appropriate error there.</li><li>Never assume that your device is always instantiated only with the machine that it was designed for. It’s of course a good idea to set the <em>“user_creatable = false”</em> flag in the <em>DeviceClass</em> of your device if your device cannot be plugged in arbitrary machines. But device introspection can still happen at any time, with any machine. So if you wrote a device called “mydev-a” that only works with <code>--machine A</code>, the user still can start QEMU with the option <code>--machine B</code> instead and then run <code>device_add mydev-a,help</code> or the <code>device-list-properties</code> QOM command. The <em>instance_init()</em> function of your device will be called to create a temporary instance of your device, even though the base machine is B and not A here. So you especially should take care to not depend on the availability of certain buses or other devices in the <em>instance_init()</em> function, nor use things like <em>serial_hd()</em> or <em>nd_table[]</em> in your <em>instance_init()</em> function, since these might (and should) have been used by the machine init function already. If your device needs to be wired up, provide properties as interfaces to the outside and let the creator of your device (e.g. the machine init code) wire your device between the device instantiation and the realize phase instead.</li><li>Make sure that your device leaves a clean state after a temporary instance is destroyed again, i.e. don’t assume that there will be only one instance of your device which is created at the beginning right after QEMU has been started and is destroyed at the very end before QEMU terminates. Thus do not assume that the things that you do in your <em>instance_init()</em> don’t need explicit clean-up since the device instance will only be destroyed when QEMU terminates. Device instances can be created and destroyed at any time, so when the device is finalized, you must not leave any dangling pointers or references to your device behind you, e.g. in the QOM tree. When you create other objects in your <em>instance_init()</em> function, make sure to set proper parents of these objects or use an <em>instance_finalize()</em> function, so that the created objects get cleaned up correctly again when your device is destroyed.</li></ul><p>All in all, if you write code for a new QEMU device, it is likely a good idea to use the <em>instance_init()</em> function only for e.g. creating properties and other things that are required before device realization, and then do the main work in the <em>realize()</em> function instead.</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU 源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZH-UEFI 规范 -1-引言</title>
    <link href="/2022/10/18/ZH-UEFI%E8%A7%84%E8%8C%83-1-%E5%BC%95%E8%A8%80/"/>
    <url>/2022/10/18/ZH-UEFI%E8%A7%84%E8%8C%83-1-%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>统一可扩展固件接口 (UEFI) 规范描述了操作系统和平台固件之间的接口。UEFI 之前是可扩展固件接口规范 1.10 (EFI)。因此，一些代码和某些协议名称保留了 EFI 名称。除非另有说明，本规范中的 EFI 名称可假定为 UEFI 的一部分。</p><p>该接口采用数据表的形式，其中包含与平台相关的信息，以及可供 OS 加载程序和 OS 使用的引导和运行时服务调用。它们共同提供了一个引导操作系统的标准环境。本规范是作为一个纯粹的接口规范设计的。因此，<strong>该规范定义了平台固件必须实现的接口和结构集</strong>。类似地，该规范定义了操作系统在引导时可能使用的一组接口和结构。无论是固件开发者选择如何实现所需的元素，还是操作系统开发者选择如何利用这些接口和结构，都由开发者自己决定。</p><p>该规范的目的是定义一种方法，使操作系统和平台固件仅通信支持操作系统引导过程所必需的信息。这是通过平台和固件提供给操作系统的软件可见接口的正式和完整的抽象规范来实现的。</p><p>本规范的目的是为操作系统和平台固件定义一种方式，以仅传递支持操作系统启动过程所需的信息。这是通过平台和固件呈现给操作系统的软件可见接口的抽象规范来实现的。</p><p>使用这一正式定义，旨在运行在与受支持的处理器规范兼容的平台上的收缩包装操作系统将能够在各种系统设计上启动，而无需进一步的平台或操作系统定制。该定义还允许平台创新引入新特性和功能，以增强平台的能力，而不需要按照操作系统的引导顺序编写新代码。</p><p>此外，抽象规范开辟了一条替代遗留设备和固件代码的路径。新的设备类型和相关代码可以通过相同定义的抽象接口提供同等的功能，同样不会影响 OS 引导支持代码。</p><p>该规范适用于从移动系统到服务器的所有硬件平台。该规范提供了一组核心服务以及一组协议接口。协议接口的选择可以随着时间的推移而发展，并针对不同的平台市场细分进行优化。与此同时，该规范允许 oem 提供最大限度的可扩展性和定制能力，以实现差异化。在这方面，UEFI 的目的是定义一个从传统的“PC-AT”风格的引导世界到一个没有遗留 API 的环境的进化路径。</p><h2 id="UEFI-驱动模型扩展"><a href="#UEFI-驱动模型扩展" class="headerlink" title="UEFI 驱动模型扩展"></a>UEFI 驱动模型扩展</h2><p>对启动设备的访问是通过一系列的协议接口提供的。UEFI 驱动模型的一个目的是为 “PC-AT”式的 Option ROM（TODO）提供一个替代品。需要指出的是，写在 UEFI 驱动模型上的驱动，被设计为在预启动环境中访问启动设备。它们并不是为了取代高性能的、针对操作系统的驱动程序。</p><p>UEFI 驱动模型被设计为支持执行模块化的代码，也被称为驱动，在预启动环境中运行。这些驱动程序可以管理或控制平台上的硬件总线和设备，也可以提供一些软件衍生的、平台特定的服务。</p><p>UEFI 驱动模型还包含了 UEFI 驱动编写者所需的信息，以设计和实现平台启动 UEFI 兼容的操作系统可能需要的任何总线驱动和设备驱动的组合。</p><p>UEFI 驱动模型被设计为通用的，可以适应任何类型的总线或设备。UEFI 规范描述了如何编写 PCI 总线驱动程序、PCI 设备驱动程序、USB 总线驱动程序、USB 设备驱动程序和 SCSI 驱动程序。提供了允许将 UEFI 驱动程序存储在 PCI Option ROM 中的其他详细信息，同时保持了与旧 Option ROM 镜像的兼容性。</p><p>UEFI 规范的一个设计目标是使驱动镜像尽可能的小。然而，如果一个驱动程序需要支持多个处理器架构，那么也需要为每个支持的处理器架构提供一个驱动程序对象文件。为了解决这个空间问题，本规范还定义了 EFI 字节代码虚拟机（EFI Byte Code Virtual Machine）。一个 UEFI 驱动可以被编译成一个 EFI 字节代码对象文件。UEFI Specification-complaint（TODO）的固件必须包含一个 EFI 字节代码解释器。这使得支持多种处理器架构的单一 EFI 字节代码对象文件可以被运出。另一种节省空间的技术是使用压缩。该规范定义了压缩和解压算法，可用于减少 UEFI 驱动程序的大小，从而减少 UEFI 驱动程序存储在 ROM 设备中时的开销。</p><p>OSV、IHV、OEM 和固件供应商可以使用 UEFI 规范中包含的信息来设计和实现符合本规范的固件、生成标准协议接口的驱动程序以及可用于引导 UEFI 兼容的操作系统加载程序操作系统。</p><h2 id="章节安排"><a href="#章节安排" class="headerlink" title="章节安排"></a>章节安排</h2><p>本规范的章节组织如下：</p><table><thead><tr><th align="left">章节名</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">引言/概述</td><td align="left">介绍 UEFI 规范，并描述 UEFI 的主要组件。</td></tr><tr><td align="left">启动管理器</td><td align="left">管理器用于加载写入此规范的驱动程序和应用程序。</td></tr><tr><td align="left">EFI 系统表和分区</td><td align="left">描述了一个 EFI 系统表，它被传递给每个兼容的驱动程序和应用程序，并定义了一个基于 GUID 的分区方案。</td></tr><tr><td align="left">块转换表</td><td align="left">用于执行块 I/O 的布局和规则集，可提供单个块的断电写入原子性。</td></tr><tr><td align="left">引导服务</td><td align="left">包含在引导操作系统之前存在于 UEFI 兼容系统中的基本服务的定义。</td></tr><tr><td align="left">运行时服务</td><td align="left">包含在操作系统启动之前和之后存在于兼容系统中的基本服务的定义。</td></tr><tr><td align="left">协议</td><td align="left">EFI 加载图像协议描述已加载到内存的 UEFI 镜像。</td></tr><tr><td align="left"></td><td align="left">设备路径协议提供了在 UEFI 环境中构建和管理设备路径所需的信息。</td></tr><tr><td align="left"></td><td align="left">UEFI 驱动模型描述了一组服务和协议，适用于每个总线和设备类型。</td></tr><tr><td align="left"></td><td align="left">控制台支持协议定义了I/O协议，处理系统用户在启动服务环境中执行的基于文本的信息的输入和输出。</td></tr><tr><td align="left"></td><td align="left">媒介访问协议定义了加载文件协议，文件系统格式和媒介格式处理可移动媒介。</td></tr><tr><td align="left"></td><td align="left">PCI 总线支持协议定义 PCI 总线驱动程序，PCI 设备驱动程序和 PCI Option ROM 布局。所描述的协议包括 PCI 根桥 I/O 协议和 PCI I/O协议。</td></tr><tr><td align="left"></td><td align="left">SCSI 驱动程序模型和总线支持定义了 SCSI I/O协议和扩展SCSI Pass Thru 协议，用于抽象访问由 SCSI 主机控制器产生的 SCSI 通道。</td></tr><tr><td align="left"></td><td align="left">iSCSI协议定义了通过TCP/IP传输SCSI数据。</td></tr><tr><td align="left"></td><td align="left">USB 支持协议定义了 USB 总线驱动程序和 USB 设备驱动程序。</td></tr><tr><td align="left"></td><td align="left">调试器支持协议描述了一组可选的协议，提供所需的服务，以实现一个源级调试器的 UEFI 环境。</td></tr><tr><td align="left"></td><td align="left">压缩算法规范详细描述了压缩/解压缩算法，外加一个标准的EFI解压缩接口，用于启动时使用。</td></tr><tr><td align="left"></td><td align="left">ACPI 协议可用于从平台上安装或删除 ACPI 表。</td></tr><tr><td align="left"></td><td align="left">字符串服务：Unicode 排序协议允许在启动服务环境中运行的代码对给定语言的 Unicode 字符串执行词法比较函数;正则表达式协议用于根据正则表达式模式匹配 Unicode 字符串。</td></tr><tr><td align="left">EFI 字节码虚拟机</td><td align="left">定义 EFI 字节码虚拟处理器及其指令集。它还定义了如何将 EBC 对象文件加载到内存中，以及从本机代码到 EBC 代码再转换到本机代码的机制。</td></tr><tr><td align="left">固件更新和报告</td><td align="left">为设备提供一个抽象，以提供固件管理支持。</td></tr><tr><td align="left">网络协议</td><td align="left">SNP、PXE、BIS 和 HTTP 启动协议定义了在 UEFI 启动服务环境中执行时提供对网络设备访问的协议。</td></tr><tr><td align="left"></td><td align="left">受管网络协议定义了 EFI 受管网络协议，它提供原始 (未格式化) 异步网络数据包 I/O 服务和托管网络服务绑定协议，用于定位 MNP 驱动支持的通信设备。</td></tr><tr><td align="left"></td><td align="left">VLAN、EAP、Wi-Fi 和 Supplicant 协议定义了一个协议，为 VLAN 配置提供可管理性接口。</td></tr><tr><td align="left"></td><td align="left">蓝牙协议定义。</td></tr><tr><td align="left"></td><td align="left">TCP、IP、PIPsec、FTP、GTLS 和 Configurations 协议定义了 EFI TCPv4 (Transmission Control Protocol version 4) 协议和 EFI IPv4 (Internet Protocol version 4) 协议。</td></tr><tr><td align="left"></td><td align="left">ARP、DHCP、DNS、HTTP 和 REST 协议定义了 ARP (Address Resolution Protocol) 协议接口和 EFI DHCPv4 协议。</td></tr><tr><td align="left"></td><td align="left">UDP 和 MTFTP 协议定义了 EFI UDPv4 (User Datagram Protocol version 4) 协议，该协议在 EFI IPv4 协议上接口，并定义了 EFI MTFTPv4 协议接口，该接口建立在 EFI UDPv4 协议之上。</td></tr><tr><td align="left">安全引导和驱动程序签名</td><td align="left">介绍 Secure Boot 和生成 UEFI 数字签名的方法。</td></tr><tr><td align="left">人机界面基础设施 (HII)</td><td align="left">定义实现人机接口基础设施 (HII) 所需的核心代码和服务，包括管理用户输入和相关协议的代码定义的基本机制。</td></tr><tr><td align="left"></td><td align="left">描述用于管理系统配置的数据和 api:描述旋钮和设置的实际数据。</td></tr><tr><td align="left">用户标识</td><td align="left">描述描述平台当前用户的服务。</td></tr><tr><td align="left">安全技术</td><td align="left">描述用于利用安全技术的协议，包括加密散列和密钥管理。</td></tr><tr><td align="left">杂项协议</td><td align="left">Timestamp 协议提供了一个独立于平台的接口来检索高分辨率的时间戳计数器。当调用 ResetSystem 时，重置通知协议提供注册通知的服务。</td></tr><tr><td align="left">附录</td><td align="left">GUID 和时间格式。</td></tr><tr><td align="left"></td><td align="left">基于基本文本的控制台要求，符合 efi 系统需要提供通信能力。</td></tr><tr><td align="left"></td><td align="left">设备路径使用数据结构的例子，定义各种硬件设备的引导服务。</td></tr><tr><td align="left"></td><td align="left">状态代码列出了 UEFI 接口返回的成功、错误和警告代码。</td></tr><tr><td align="left"></td><td align="left">通用网络驱动程序接口定义了32/64位硬件和软件通用网络驱动程序接口(UNDIs)。</td></tr><tr><td align="left"></td><td align="left">使用简单指针协议。</td></tr><tr><td align="left"></td><td align="left">使用 EFI 扩展 SCISI 直通协议。</td></tr><tr><td align="left"></td><td align="left">压缩源代码的一个压缩算法的实现。</td></tr><tr><td align="left"></td><td align="left">一个 EFI 解压缩算法的实现的解压源代码。</td></tr><tr><td align="left"></td><td align="left">EFI 字节码虚拟机操作码列表提供了相应指令集的摘要。</td></tr><tr><td align="left"></td><td align="left">字母功能列表按字母顺序标识所有 UEFI 接口功能。</td></tr><tr><td align="left"></td><td align="left">EFI 1.10 协议变更和折旧清单标识了协议、GUID、修订标识符名称变更以及与 EFI 1.10 规范相比已弃用的协议。</td></tr><tr><td align="left"></td><td align="left">平台错误记录描述了用于表示平台硬件错误的常见平台错误记录格式。</td></tr><tr><td align="left"></td><td align="left">UEFI ACPI Data Table 定义了 UEFI ACPI 表格式。</td></tr><tr><td align="left"></td><td align="left">硬件错误记录持久性使用。</td></tr><tr><td align="left"></td><td align="left">引用</td></tr><tr><td align="left"></td><td align="left">术语表</td></tr><tr><td align="left">索引</td><td align="left">提供规范中关键术语和概念的索引。</td></tr></tbody></table><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>“PC-AT”启动环境对行业内的创新提出了重大挑战。每一个新的平台功能或硬件创新都要求固件开发人员设计越来越复杂的解决方案，并且通常要求操作系统开发人员修改引导代码，然后客户才能从创新中受益。这可能是一个耗时的过程，需要大量的资源投资。</p><p>UEFI 规范的主要目标是定义一个替代引导环境，可以减轻这些考虑。在这个目标中，该规范类似于其他现有的引导规范。本规范的主要属性可以概括为以下属性：</p><ul><li><p><strong>一致的、可扩展的平台环境</strong>。该规范为固件定义了一个完整的解决方案，以描述所有平台特性和 OS 的 surface platform(TODO) 功能在引导过程中。这些定义非常丰富，足以涵盖一系列当代处理器设计。</p></li><li><p><strong>从固件中抽象操作系统</strong>。该规范定义了平台功能的接口。通过使用抽象接口，该规范允许在构建 OS 加载器时，而无需了解作为这些接口基础的平台和固件。这些接口代表了底层平台和固件实现与操作系统加载程序之间定义良好的稳定边界。这样的边界允许底层固件和操作系统加载程序更改，前提是两者都将交互限制在定义的接口上。</p></li><li><p><strong>合理的设备抽象，不需要遗留接口</strong>。“PC-AT”BIOS 接口要求操作系统加载程序对某些硬件设备的工作有特定的了解。该规范为 OS 加载器开发人员提供了一些不同的东西：抽象接口使得可以构建在一系列底层硬件设备上工作的代码，而无需明确了解该范围内每个设备的细节。</p></li><li><p><strong>从固件中提取 Option ROM</strong>。该规范定义了平台功能的接口，包括 PCI、USB 和 SCSI 等标准总线类型。支持的总线类型可能会随着时间的推移而增加，因此包括了一种扩展到未来总线类型的机制。这些定义的接口以及扩展到未来总线类型的能力是 UEFI 驱动程序模型的组件。UEFI 驱动模型的一个目的是解决现有“PC-AT”Option ROM 中存在的广泛问题。与 OS 加载程序一样，驱动程序使用抽象接口，因此可以构建设备驱动程序和总线驱动程序，而无需了解作为这些接口基础的平台和固件。</p></li><li><p><strong>架构上可共享的系统分区</strong>。扩展平台功能和添加新设备的计划通常需要软件支持。在许多情况下，当这些平台创新（TODO）在操作系统控制平台之前被激活时，它们必须由特定于平台而不是客户选择的操作系统的代码支持。解决这个问题的传统方法是在制造过程中将代码嵌入平台中（例如，在闪存设备中）。对这种持久存储的需求正在快速增长。该规范定义了大型海量存储媒介类型上的持久存储，以供平台支持代码扩展使用，以补充传统方法。规范中明确了其工作原理的定义，以确保固件开发商、OEM、操作系统供应商甚至第三方可以安全地共享空间，同时增加平台功能。</p></li></ul><p>可以通过多种方式定义提供这些属性的引导环境。实际上，在编写本规范时，已经存在几种替代方案，从学术角度来看可能是可行的。然而，考虑到当前围绕支持的处理器平台的基础设施能力，这些替代方案通常会带来很高的门槛。本规范旨在提供上面列出的属性，同时也认识到行业的独特需求，该行业在兼容性方面进行了大量投资，并且拥有大量无法立即放弃的系统安装基础。这些需求推动了对本规范中体现的附加属性的要求：</p><ul><li><strong>进化性的，而不是革命性的</strong>。规范中的接口和结构旨在尽可能地减少初始实现的负担。虽然已经小注意保在接口本身中维护适当的抽象，但该设计还确保可以重用 BIOS 代码来实现接口，而只需要最少的额外编码工作。换句话说，在 PC-AT 平台上，规范最初可以作为基于现有代码的底层实现之上的薄接口（thin Interface TODO）层来实现。同时，抽象接口的引入提供了将来从遗留代码的迁移。一旦抽象被确立为固件和操作系统加载程序在引导期间交互的手段，开发人员就可以随意替换抽象接口下的遗留代码。类似的硬件遗留迁移也是可能的。由于抽象隐藏了设备的细节，因此可以移除底层硬件，并用提供改进功能、降低成本或两者兼而有之的新硬件替换它。显然，这需要编写新的平台固件来支持设备并通过抽象接口将其呈现给 OS 加载器。但是，如果没有接口抽象，则可能根本无法移除旧设备。</li><li><strong>设计上的兼容性</strong>。系统分区结构的设计还保留了当前在“PC-AT”引导环境中使用的所有结构。因此，构建一个能够从同一磁盘引导传统操作系统或 EFI-aware 操作系统的单一系统是一件简单的事情。</li><li><strong>简化了操作系统中立的平台增值的添加</strong>。该规范定义了一个开放的、可扩展的接口，它有助于创建平台“驱动程序”。这些可能类似于操作系统驱动程序，在引导过程中为新设备类型提供支持，或者它们可能用于实现增强的平台功能，例如容错或安全性。此外，这种扩展平台能力的能力从一开始就被设计到规范中。这旨在帮助开发人员避免在尝试将新代码挤入传统 BIOS 环境时所固有的许多挫败感。由于包含用于添加新协议的接口，OEM 或固件开发人员拥有以模块化方式向平台添加功能的基础设施。由于规范中定义的调用约定和环境，此类驱动程序可能会使用高级编码语言来实现。这反过来可能有助于降低创新的难度和成本。系统分区选项为此类扩展提供了非易失性存储器存储的替代方案。</li><li><strong>建立在现有投入的基础上</strong>。在可能的情况下，规范避免在现有行业规范提供足够覆盖的领域重新定义接口和结构。例如，ACPI 规范为操作系统提供了发现和配置平台资源所需的所有信息。同样，规范设计的这种哲学选择旨在尽可能降低采用该规范的障碍。</li></ul><h2 id="目标受众"><a href="#目标受众" class="headerlink" title="目标受众"></a>目标受众</h2><p>本文档主要适用于以下读者：</p><ul><li>将实现 UEFI 驱动程序的 IHV 和 OEM。</li><li>将创建支持的处理器平台的 OEM 厂商，旨在启动 shrink-wrap（TODO）的操作系统。</li><li>BIOS 开发人员，无论是创建通用 BIOS 和其他固件产品的人员，还是修改这些产品的支持人员。</li><li>操作系统开发人员将调整他们的 shrink-wrap（TODO）操作系统产品，用来在支持的基于处理器的平台上运行。</li></ul><h2 id="UEFI-设计概述"><a href="#UEFI-设计概述" class="headerlink" title="UEFI 设计概述"></a>UEFI 设计概述</h2><p>UEFI 的设计基于以下基本要素：</p><ul><li><strong>重用现有的基于表格的接口</strong>。为了保持对现有基础支持代码（包括操作系统和固件）的投资，必须在希望符合 UEFI 规范的平台上，实现通常在与支持的处理器规范兼容的平台上，实现的许多现有规范。 （有关更多信息，请参阅附录 Q：参考资料。）</li><li><strong>系统分区</strong>。系统分区定义了一个分区和文件系统，可允许多个供应商之间安全共享，并用于不同目的。包含单独的、可共享的系统分区的能力提供了增加平台附加值的机会，而不会显著增加对非易失性平台存储器的需求。</li><li><strong>引导服务</strong>。引导服务为可在引导期间使用的设备和系统功能提供接口。设备访问是通过“句柄”（handles）和“协议”(protocols) 抽象出来的。这有利于重用现有 BIOS 代码，将基本实现要求保持在规范之外，而不会给访问设备的消费者带来负担。</li><li><strong>运行时服务</strong>。提供了一组最小的运行时服务，以确保对基础平台的硬件资源进行适当的抽象，这些资源可能是操作系统在正常运行时需要的。</li></ul><hr><p><img src="../pic/1-1.jpg" alt="UEFI 概念概述"></p><hr><p>图 1-1 描述了用于完成平台和操作系统引导的符合 UEFI 规范的系统的各种组件的交互。</p><p>平台固件能够从系统分区中检索操作系统加载器镜像。该规范提供了各种大容量存储设备类型，包括磁盘、CD-ROM 和 DVD，以及通过网络的远程启动。通过可扩展的协议接口，有可能增加其他的引导媒介类型，尽管如果这些媒介需要使用本文件中定义的协议以外的协议，可能需要修改操作系统加载器。</p><p>一旦启动，操作系统加载程序将继续引导整个操作系统。为此，它可以使用本规范或其他所需规范定义的 EFI 引导服务和接口来探测、解析和初始化各种平台组件和管理它们的操作系统软件。在引导阶段，EFI 运行时服务也可供 OS 加载器使用。</p><h2 id="UEFI-驱动模型"><a href="#UEFI-驱动模型" class="headerlink" title="UEFI 驱动模型"></a>UEFI 驱动模型</h2><p>本节描述了符合本规范的固件的驱动模型的目标。目标是让这个驱动模型为所有类型的总线和设备提供一个实现总线驱动和设备驱动的机制。在撰写本文时，支持的总线类型包括 PCI、USB 等。</p><p>随着硬件架构的不断发展，平台中存在的总线数量和类型也在不断增加。这种趋势在高端服务器中尤为明显。然而，更多样化的总线类型被设计到桌面和移动系统，甚至一些嵌入式系统中。这种日益增长的复杂性，意味着在预启动环境中，需要一种简单的方法来描述和管理平台中的所有总线和设备。UEFI 驱动模型以协议、服务和启动服务的形式提供了这种简单的方法。</p><h3 id="UEFI-驱动程序模型目标"><a href="#UEFI-驱动程序模型目标" class="headerlink" title="UEFI 驱动程序模型目标"></a>UEFI 驱动程序模型目标</h3><p>UEFI 驱动模型有以下目标：</p><ul><li><strong>兼容</strong> – 符合此规范的驱动程序必须保持与 EFI 1.10 规范和 UEFI 规范的兼容性。这意味着 UEFI 驱动程序模型利用 UEFI 2. 0 规范中的可扩展性机制来添加所需的功能。</li><li><strong>简单</strong> - 符合本规范的驱动程序必须易于实现，易于维护。UEFI 驱动模型必须允许驱动编写者专注于正在开发的特定设备的驱动。驱动程序不应关注平台策略或平台管理问题。这些考虑应该留给系统固件。</li><li><strong>可扩展性</strong> - UEFI 驱动模型必须能够适应所有类型的平台。这些平台包括嵌入式系统、移动和桌面系统，以及工作站和服务器。</li><li><strong>灵活</strong> - UEFI 驱动模型必须支持枚举所有设备的能力，或者只枚举启动所需操作系统的那些设备。最小的设备枚举提供了对更快速的启动能力的支持，而完整的设备媒体提供了在系统中存在的任何启动设备上执行操作系统安装、系统维护或系统诊断的能力。</li><li><strong>可扩展性</strong> - UEFI 驱动模型必须能够扩展到未来定义的总线类型。</li><li><strong>可移植性</strong> - 根据 UEFI 驱动模型编写的驱动，必须在不同平台和支持的处理器架构之间可移植。</li><li><strong>可互操作性</strong> - 驱动程序必须与其他驱动程序和系统固件共存，并且必须在不产生资源冲突的情况下进行操作。</li><li><strong>描述复杂的总线层次结构</strong> - UEFI 驱动模型必须能够描述各种总线拓扑结构，从非常简单的单总线平台到包含许多不同类型总线的非常复杂的平台。</li><li><strong>驱动占用空间小</strong> - 由 UEFI 驱动程序模型产生的可执行文件的大小必须最小化，以减少整体平台成本。虽然灵活性和可扩展性是目标，但支持这些所需的额外开销必须保持在最低水平，以防止固件组件的大小变得无法管理。</li><li><strong>解决遗留 Option ROM 的问题</strong> - UEFI 驱动模型必须直接解决遗留 Option ROM 的约束和限制。具体来说，必须能够建立同时支持 UEFI 驱动和传统 Option ROM 的插件卡，这种卡可以在传统 BIOS 系统和符合 UEFI 的平台上执行，而无需修改卡上的代码。该解决方案必须提供一个从传统 Option ROM 驱动程序迁移到 UEFI 驱动程序的进化路径。</li></ul><h3 id="遗留-Option-ROM-问题"><a href="#遗留-Option-ROM-问题" class="headerlink" title="遗留 Option ROM 问题"></a>遗留 Option ROM 问题</h3><p>这个支持驱动模型的想法来自于对 UEFI 规范的反馈，它提供了一个明确的、由市场驱动的对传统选项 ROM（有时也被称为扩展 ROM）的替代要求。人们认为，UEFI 规范的出现代表了一个机会，通过用一种在 UEFI 规范框架内工作的替代机制来取代传统选项 ROM 镜像的构建和操作，从而摆脱隐含的限制。</p><h2 id="迁移要求"><a href="#迁移要求" class="headerlink" title="迁移要求"></a>迁移要求</h2><p>迁移要求涵盖了从最初实施本规范到未来所有平台和操作系统都实施本规范的过渡时期。在这一时期，有两个主要的兼容性考虑是很重要的。</p><ul><li>能够继续启动传统的操作系统；</li><li>能够在现有的平台上实现 UEFI，尽可能多地复用现有的固件代码，将开发资源和时间要求降到最低。</li></ul><h3 id="旧版操作系统支持"><a href="#旧版操作系统支持" class="headerlink" title="旧版操作系统支持"></a>旧版操作系统支持</h3><p>UEFI 规范代表了收缩式操作系统和固件在启动过程中进行通信的首选方式。然而，选择制作一个符合该规范的平台，并不排除该平台，也支持不了解 UEFI 规范的，现有传统操作系统二进制文件。</p><p>UEFI 规范并不限制平台设计者，选择同时支持 UEFI 规范和更传统的 “PC-AT “启动基础架构。如果要实现这样的传统基础架构，应该按照现有的行业惯例来开发，这些惯例是在本规范范围之外定义的。在任何给定的平台上，支持的传统操作系统的选项是由该平台的制造商决定的。</p><h3 id="在旧平台上支持-UEFI-规范"><a href="#在旧平台上支持-UEFI-规范" class="headerlink" title="在旧平台上支持 UEFI 规范"></a>在旧平台上支持 UEFI 规范</h3><p>UEFI 规范经过精心设计，允许以最少的开发工作扩展现有系统以支持它。特别是 UEFI 规范中定义的抽象结构和服务，都可以在遗留平台上得到支持</p><p>例如，要在现有且受支持的基于 32 位的平台上实现此类支持，该平台使用传统 BIOS 来支持操作系统启动，需要提供额外的固件代码层。需要这些额外的代码来将服务和设备的现有接口转换为对本规范中定义的抽象的支持。</p><h2 id="本文档中使用的约定"><a href="#本文档中使用的约定" class="headerlink" title="本文档中使用的约定"></a>本文档中使用的约定</h2><h3 id="数据结构描述"><a href="#数据结构描述" class="headerlink" title="数据结构描述"></a>数据结构描述</h3><p><strong>支持的处理器是“小端”机器</strong>。这种区别意味着内存中多字节数据项的低位字节位于最低地址，而高位字节位于最高地址。一些受支持的 64 位处理器可以配置为“小端”和“大端”操作。所有旨在符合本规范的实现都使用“小端”操作。</p><p>在某些内存布局描述中，某些字段被标记为保留。软件必须将这些字段初始化为零并在读取时忽略它们。在更新操作中，软件必须保留任何保留字段。</p><h3 id="协议描述"><a href="#协议描述" class="headerlink" title="协议描述"></a>协议描述</h3><p>协议描述一般有以下格式：</p><ul><li><strong>协议名称</strong>：协议接口的正式名称。</li><li><strong>摘要</strong>：协议接口的简要描述。</li><li><strong>GUID</strong>：协议接口的 128 位 GUID (Globally Unique Identifier)。</li><li><strong>协议接口结构</strong>：一种“c 风格”的数据结构定义，包含由该协议接口产生的过程和数据字段。</li><li><strong>参数</strong>：协议接口结构中各字段的简要说明。</li><li><strong>描述</strong>：对接口提供的功能的描述，包括调用者应该知道的任何限制和警告。</li><li><strong>相关定义</strong>：协议接口结构或其任何过程中使用的类型声明和常量。</li></ul><h3 id="过程描述"><a href="#过程描述" class="headerlink" title="过程描述"></a>过程描述</h3><p>过程描述通常具有以下格式：</p><ul><li><strong>过程名称</strong>：过程的正式名称。</li><li><strong>摘要</strong>：过程的简要说明。</li><li><strong>原型</strong>：定义调用序列的“C 风格”过程标头。</li><li><strong>参数</strong>：对程序原型中每个字段的简要描述。</li><li><strong>描述</strong>：对接口所提供的功能的描述，包括调用者应该注意的任何限制和注意事项。</li><li><strong>相关定义</strong>：仅由该过程使用的类型声明和常量。</li><li><strong>返回的状态代码</strong>：对接口所返回的任何代码的描述。该过程需要实现本表中列出的任何状态代码。可以返回更多的错误代码，但是它们不会被标准的符合性测试所测试，而且任何使用该程序的软件，都不能依赖于实现可能提供的任何扩展错误代码。</li></ul><h3 id="指令描述"><a href="#指令描述" class="headerlink" title="指令描述"></a>指令描述</h3><p>EBC 指令的指令描述一般有以下格式：</p><ul><li><strong>指令名称</strong>：指令的正式名称。</li><li><strong>语法</strong>：指令的简要描述。</li><li><strong>描述</strong>：对指令所提供的功能的描述，并附有指令编码的详细表格。</li><li><strong>操作</strong>：详细说明对操作数进行的操作。</li><li><strong>行为和限制</strong>：逐项描述指令中涉及的每个操作数的行为，以及适用于操作数或指令的任何限制。</li></ul><h3 id="伪代码约定"><a href="#伪代码约定" class="headerlink" title="伪代码约定"></a>伪代码约定</h3><p>提出伪代码是为了以更简洁的形式描述算法。本文件中的所有算法都不打算直接进行编译。代码是在与周围文本相对应的水平上呈现的。</p><p>在描述变量时，列表是一个无序的同质对象的集合。一个队列是一个同质对象的有序列表。除非另有说明，否则假设排序为先进先出。</p><p>伪代码以类似于 C 的格式呈现，在适当的地方使用 C 约定。编码风格，特别是缩进风格，是为了可读性，不一定符合 UEFI 规范的实现。</p><h3 id="排版约定"><a href="#排版约定" class="headerlink" title="排版约定"></a>排版约定</h3><p>本文件采用了以下描述的排版和说明性惯例。</p><ul><li>纯文本：规范中的绝大部分描述性文本都使用普通文本字体。</li><li>纯文本（蓝色）：任何有下划线和蓝色的纯文本都表示与交叉参考资料的活动链接。点击该词，就可以跟踪超链接。</li><li>加粗：在文本中，粗体字标识了一个处理器寄存器的名称。在其他情况下，黑体字可以作为段落中的标题。</li><li>斜体：在文本中，斜体字可以用作强调，以引入一个新的术语或表示手册或规范的名称。</li><li>加粗等宽（暗红色）：计算机代码、示例代码段和所有原型代码段使用 BOLD Monospace 字体，颜色为暗红色。这些代码列表通常出现在一个或多个独立的段落中，尽管单词或片段也可以嵌入到一个正常的文本段落中。</li><li>加粗等宽（蓝色）：用粗体单色字体的字，下划线和蓝色的字，表示该功能或类型定义的代码定义的活动超链接。点击该词，即可进入超链接。</li></ul><p><strong>注意</strong>：出于管理和文件大小的考虑，每一页上只有第一次出现的参考文献是一个主动链接。同一页上的后续参考文献不会被主动链接到定义上，而是使用标准的、无下划线的 BOLD Monospace 字体。在页面上找到该名称的第一个实例（使用下划线的 BOLD Monospace 字体），点击该词即可跳转到该功能或类型的定义。</p><ul><li>斜体等宽：在代码或文本中，斜体字表示必须提供的变量信息的占位符名称（即参数）。</li></ul><h3 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h3><p>在本标准中，二进制数字是由仅由西方阿拉伯数字 0 和 1 组成的任何数字序列表示的，后面紧跟一个小写的 b（例如，0101b）。在二进制数字表示中的字符之间可以包含下划线或空格，以增加可读性或划分领域边界（例如，0 0101 1010b 或 0_0101_1010b）。</p><h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>十六进制数字在本标准中用 0x 表示，前面是仅由西阿拉伯数字 0 至 9 和/或大写英文字母 A 至 F 组成的任何数字序列（例如，0xFA23）。十六进制数字表示中的字符之间可以包含下划线或空格，以增加可读性或划定字段边界（例如，0xB FD8C FA23 或 0xB_FD8C_FA23）。</p><h4 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h4><p>在本标准中，小数是由仅由阿拉伯数字 0 到 9 组成的任何数字序列来表示的，后面不紧跟小写的 b 或小写的 h（例如，25）。本标准使用以下惯例来表示小数：</p><ul><li>小数点分隔符（即分隔数字的整数部分和小数部分）是一个句号；</li><li>千位数分隔符（即分隔数字部分的三位数组）是一个逗号；</li><li>千位数分隔符用于数字的整数部分，不用于数字的小数部分。</li></ul><h3 id="二进制前缀"><a href="#二进制前缀" class="headerlink" title="二进制前缀"></a>二进制前缀</h3><p>本标准使用国际单位制（SI）中定义的前缀来表示 10 的幂值。见 “SI 二进制前缀 “标题下的 “UEFI 相关文件链接”（<a href="http://uefi.org/uefi">http://uefi.org/uefi</a>）。</p><p><img src="../pic/table1-1.jpg"></p><p>本标准使用ISO/IEC 80000-13《数量和单位–第 13 部分：信息科学和技术》和 IEEE 1514《二进制倍数前缀标准》中定义的二进制前缀，用于表示 2 的幂值。</p><p><img src="../pic/table1-2.jpg"></p><p>例如，4 KB 意味着 4000 个字节，4 KiB 意味着 4096 个字节。</p><h3 id="修订号"><a href="#修订号" class="headerlink" title="修订号"></a>修订号</h3><p>对 UEFI 规范的更新被认为是新的修订或勘误表，如下所述：</p><ul><li>当有实质性的新内容或可能修改现有行为的变化时，就会产生一个新的修订。新的修订版由一个主要的。次要的版本号来指定（例如：xx.yy）。在变化特别小的情况下，我们可能有一个 major.minor.minor 的命名惯例（例如 xx.yy.zz）。</li><li>当批准的规范更新不包括任何重要的新材料或修改现有行为时，就会产生勘误的版本。勘误的指定方法是在版本号后面加上一个大写字母，如 xx.yy 勘误 A。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决 VSCode 远程登录失败 Error: WebSocket close with status code 1006</title>
    <link href="/2022/10/15/%E8%A7%A3%E5%86%B3VSCode%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5Error-WebSocket-close-with-status-code-1006/"/>
    <url>/2022/10/15/%E8%A7%A3%E5%86%B3VSCode%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5Error-WebSocket-close-with-status-code-1006/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>使用 VSCode 远程登录失败，报错：Failed to connect to the remote extension host server (Error: WebSocket close with status code 1006)。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/ssh/sshd_config<br><br>AllowTcpForwarding no<br><br>AllowAgentForwarding no<br><br><span class="hljs-comment"># 替换为</span><br><br>AllowTcpForwarding yes<br><br>AllowAgentForwarding yes<br></code></pre></td></tr></table></figure><p>保存后重启 <code>sshd</code> 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart sshd<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用 GitHub Actions</title>
    <link href="/2022/10/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GitHub-Actions/"/>
    <url>/2022/10/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GitHub-Actions/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>GitHub Actions 是 GitHub 在 2018 年推出的<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成服务</a>。它可以自动完成一些开发周期内的任务，如 Push 代码时自动编译，Pull 代码时自动执行测试脚本等等。</p><p>我了解 GitHub Actions 的契机是，我在 GitHub 上保存了一些 Markdown 文档，我希望每次更新文档后自动使用 Pandoc 转换成 PDF 文档。接下来我们一起学习如何通过 GitHub Actions 实现这样的需求。</p><p>首先我们先直观的了解一下它在 GitHub 的位置，如果打开一个仓库，它有图中绿色对号√，或者红色叉号×，说明这个项目配置了 GitHub Actions，绿色表示自动化的流程运行成功了，红色表示失败了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/10/15/a3a273415c7250d26bb50e293378bf5e.png"></p><p>我们点开<code>Actions</code>按钮就可以查看具体的任务详情。下面我们先学习如何配置一个简单的 GitHub Actions。</p><h1 id="配置-GitHub-Actions"><a href="#配置-GitHub-Actions" class="headerlink" title="配置 GitHub Actions"></a>配置 GitHub Actions</h1><p>GitHub Actions 可以简单理解为一些自动化脚本，工具，目的就是为了减少重复工作，所以这些工具都可以做成普适性的工具。而 GitHub 官方就开放了一个这类工具的<a href="https://github.com/marketplace">市场</a>，我们可以在上面搜索自己想要的工具。因为初学 GitHub Actions 所以也不知道怎么写配置文件，我们可以直接搜索一个并应用它，看看别人是怎么写的。</p><p>我们进入一个自己的仓库，点击<code>Actions</code>，搜索框中搜索<code>PDF</code>，在搜索结果中找到<a href="https://github.com/marketplace/actions/create-pdf">Create PDF · Actions</a>这个工具。如果搜索到点击<code>Configure</code>。如果显示未找到，则点击<code>set up a workflow yourself</code>，同样搜索<code>PDF</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/10/15/f6baead7ab50e1db5ce3611a0525f833.png"></p><p>打开<a href="https://github.com/marketplace/actions/create-pdf">详情页面</a>，拉到底，将<code>Example usage</code>。里的内容复制到编辑框中。点击右上角<code>Start commit</code>将会把我们新建的<code>main.yml</code>提交到仓库中。这就相当于创建了一个生成 PDF 的 GitHub Actions。当然每个 Actions 都有一些使用要求，比如这里还要根据介绍，创建几个文件夹，比如从哪个文件夹获取源文件，生成后的 PDF 又会放到哪个文件夹等。这里就不再介绍，我们先了解如何创建一个 Actions。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/10/16/0a24d8bcecc9d210b4e6b75b2fccae0b.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/10/16/69370e917f9c35963a2343176ecf0eea.png"></p><h1 id="Workflow-配置"><a href="#Workflow-配置" class="headerlink" title="Workflow 配置"></a>Workflow 配置</h1><p>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows 目录。</p><p>workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml or .yaml，比如 foo.yml or foo.yaml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows 目录里面有.yml or .yaml 文件，就会自动运行该文件（并行）。</p><p>接下来我们逐个参数来解释都有哪些功能。</p><h2 id="on"><a href="#on" class="headerlink" title="on"></a>on</h2><p>触发 workflow 的 GitHub 事件的名称。比如<code>push</code>代码时触发，其他人<code>fork</code>代码仓时触发等等。</p><p>可以只有一个事件触发，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span> <span class="hljs-string">push</span><br></code></pre></td></tr></table></figure><p>也可有多个事件触发，使用列表列举，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span> [<span class="hljs-string">push</span>, <span class="hljs-string">fork</span>]<br></code></pre></td></tr></table></figure><p>所有支持的事件列表，请查看<a href="https://docs.github.com/cn/actions/using-workflows/events-that-trigger-workflows">官方文档</a>。</p><h3 id="on-push-fork-tags-branches"><a href="#on-push-fork-tags-branches" class="headerlink" title="on.[push|fork].[tags|branches]"></a>on.[push|fork].[tags|branches]</h3><p><strong>注意</strong>：从这里开始就会出现一个字段下有子字段，每个点号<code>.</code>分割一个子字段。如<code>push</code>或者<code>fork</code>可以作为<code>on</code>的子字段，<code>tags</code>或者<code>branches</code>可以作为<code>push</code>或者<code>fork</code>的子字段。在<code>yaml</code>文件中，缩进很重要，每个缩进都表示是从属关系，表示是该字段的子字段。千万要注意缩进关系，如果缩进出错，那么将无法解析<code>yaml</code>文件。</p><p>指定触发事件时，可以限定分支或标签。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>上面代码指定，只有 master 分支发生 push 事件时，才会触发 workflow。</p><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>工作流程的名称。GitHub 在仓库的操作页面上显示工作流程的名称。如果省略 name，GitHub 将其设置为相对于仓库根目录的工作流程文件路径。</p><h2 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h2><p>workflow 运行包括一项或多项 jobs。jobs 默认是并行运行。要按顺序运行作业，可以使用 <code>[job_id].needs</code> 关键词在其他 job 上定义依赖项。</p><p>每个作业在 <code>runs-on</code> 指定的运行器环境中运行。</p><h3 id="jobs-job-id"><a href="#jobs-job-id" class="headerlink" title="jobs.[job_id]"></a>jobs.[job_id]</h3><p>jobs 中的每个任务都有一个<code>[job_id]</code> ，且其必须为 jobs 对象中<strong>唯一的字符串键值</strong>。<code>[job_id]</code>必须以字母或<code>_</code>开头，并且只能包含字母数字字符、<code>-</code>或<code>_</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">first_job:</span>  <span class="hljs-comment"># [job_id]，任务 id</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">My</span> <span class="hljs-string">first</span> <span class="hljs-string">job</span><br>  <span class="hljs-attr">second_job:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">My</span> <span class="hljs-string">second</span> <span class="hljs-string">job</span><br></code></pre></td></tr></table></figure><h3 id="jobs-job-id-runs-on"><a href="#jobs-job-id-runs-on" class="headerlink" title="jobs.[job_id].[runs-on]"></a>jobs.[job_id].[runs-on]</h3><p><code>runs-on</code> 字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">ubuntu-latest，ubuntu-18.04或ubuntu-16.04</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">windows-latest，windows-2019或windows-2016</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">macOS-latest或macOS-10.14</span><br></code></pre></td></tr></table></figure><p>下面代码指定虚拟机环境为 ubuntu-18.04。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-18.04</span><br></code></pre></td></tr></table></figure><h3 id="jobs-job-id-name"><a href="#jobs-job-id-name" class="headerlink" title="jobs.[job_id].name"></a>jobs.[job_id].name</h3><p>workflow 文件的主体是 jobs 字段，表示要执行的一项或多项任务。</p><p><code>job_id</code> 里面的 <code>name</code> 字段是任务的说明。它可以在网页端的 UI 上显示。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">first_job:</span>  <br>    <span class="hljs-attr">name:</span> <span class="hljs-string">My</span> <span class="hljs-string">first</span> <span class="hljs-string">job</span>  <span class="hljs-comment"># [job_name]，任务名称</span><br>  <span class="hljs-attr">second_job:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">My</span> <span class="hljs-string">second</span> <span class="hljs-string">job</span><br></code></pre></td></tr></table></figure><h3 id="jobs-job-id-needs"><a href="#jobs-job-id-needs" class="headerlink" title="jobs.[job_id].needs"></a>jobs.[job_id].needs</h3><p>needs 字段指定当前任务的依赖关系，即运行顺序。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">job1:</span><br>  <span class="hljs-attr">job2:</span><br>    <span class="hljs-attr">needs:</span> <span class="hljs-string">job1</span><br>  <span class="hljs-attr">job3:</span><br>    <span class="hljs-attr">needs:</span> [<span class="hljs-string">job1</span>, <span class="hljs-string">job2</span>]<br></code></pre></td></tr></table></figure><p>上面代码中，job1 必须先于 job2 完成，而 job3 等待 job1 和 job2 的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。</p><h3 id="jobs-job-id-steps"><a href="#jobs-job-id-steps" class="headerlink" title="jobs.[job_id].steps"></a>jobs.[job_id].steps</h3><p><code>steps</code> 字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">jobs.[job_id].steps.name：步骤名称。</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">jobs.[job_id].steps.run：该步骤运行的命令或者</span> <span class="hljs-string">action。</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">jobs.[job_id].steps.env：该步骤所需的环境变量。</span><br></code></pre></td></tr></table></figure><p>下面是一个完整的 workflow 文件的范例。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Greeting</span> <span class="hljs-string">from</span> <span class="hljs-string">Mona</span><br><span class="hljs-attr">on:</span> <span class="hljs-string">push</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">my-job:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">My</span> <span class="hljs-string">Job</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Print</span> <span class="hljs-string">a</span> <span class="hljs-string">greeting</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">MY_VAR:</span> <span class="hljs-string">Hi</span> <span class="hljs-string">there!</span> <span class="hljs-string">My</span> <span class="hljs-string">name</span> <span class="hljs-string">is</span><br>          <span class="hljs-attr">FIRST_NAME:</span> <span class="hljs-string">Mona</span><br>          <span class="hljs-attr">MIDDLE_NAME:</span> <span class="hljs-string">The</span><br>          <span class="hljs-attr">LAST_NAME:</span> <span class="hljs-string">Octocat</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>          <span class="hljs-string">echo</span> <span class="hljs-string">$MY_VAR</span> <span class="hljs-string">$FIRST_NAME</span> <span class="hljs-string">$MIDDLE_NAME</span> <span class="hljs-string">$LAST_NAME.</span><br></code></pre></td></tr></table></figure><p>上面代码中，steps 字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。</p><h3 id="jobs-job-id-steps-uses"><a href="#jobs-job-id-steps-uses" class="headerlink" title="jobs.[job_id].steps[*].uses"></a>jobs.[job_id].steps[*].uses</h3><p>选择一个 action，可以理解为若干 steps.run，有利于代码复用。这也是 github action 最主要的功能。</p><p>比如最常用的，下载本仓库的代码到工作区，就是使用的一个 action 完成的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Check</span> <span class="hljs-string">out</span> <span class="hljs-string">Git</span> <span class="hljs-string">repository</span><br>    <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br></code></pre></td></tr></table></figure><blockquote><p>注：<code>@v2</code> 什么意思？<br>表示 Action 的版本。我们如果不带版本号的话，就是默认使用最新版本。Github 官方强烈要求我们带上版本号。这样子的话，我们就不会出现：写好一个 Workflow，但是由于某个 Action 的作者一更新，我们的 Workflow 就崩了的问题</p></blockquote><h3 id="jobs-job-id-steps-run"><a href="#jobs-job-id-steps-run" class="headerlink" title="jobs.[job_id].steps.run"></a>jobs.[job_id].steps.run</h3><p>在 shell 中执行的命令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">create</span> <span class="hljs-string">dir</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-string">dir</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>            <span class="hljs-string">mkdir</span> <span class="hljs-string">output</span>  <span class="hljs-comment"># create output dir</span><br></code></pre></td></tr></table></figure><p>以上配置是在下载完本仓库的代码后，在仓库根目录新建一个<code>output</code>文件夹。注意<code>run:</code>后的<code>|</code>表示可以多行命令。如果没有<code>|</code>表示只能执行一条命令。</p><h3 id="jobs-job-id-steps-working-directory"><a href="#jobs-job-id-steps-working-directory" class="headerlink" title="jobs.[job_id].steps.working-directory"></a>jobs.[job_id].steps.working-directory</h3><p>用来指定在<code>run</code>命令在哪执行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Create</span> <span class="hljs-string">dir</span><br>  <span class="hljs-attr">run:</span> <span class="hljs-string">mkdir</span> <span class="hljs-string">output</span><br>  <span class="hljs-attr">working-directory:</span> <span class="hljs-string">./build</span><br></code></pre></td></tr></table></figure><h3 id="jobs-job-id-steps-shell"><a href="#jobs-job-id-steps-shell" class="headerlink" title="jobs.[job_id].steps.shell"></a>jobs.[job_id].steps.shell</h3><p>用来指定 shell 类型，如 Python，bash，powershell 等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Display</span> <span class="hljs-string">the</span> <span class="hljs-string">path</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">$PATH</span><br>    <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span><br></code></pre></td></tr></table></figure><p>所有支持的类型请查看<a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsshell">官方文档</a>。</p><h3 id="如何跳过-GitHub-Actions"><a href="#如何跳过-GitHub-Actions" class="headerlink" title="如何跳过 GitHub Actions"></a>如何跳过 GitHub Actions</h3><p>在 commit message 中只要包含了下面几个关键词就会跳过 Github Actions。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">skip</span> <span class="hljs-string">ci</span>]<br>[<span class="hljs-string">ci</span> <span class="hljs-string">skip</span>]<br>[<span class="hljs-literal">no</span> <span class="hljs-string">ci</span>]<br>[<span class="hljs-string">skip</span> <span class="hljs-string">actions</span>]<br>[<span class="hljs-string">actions</span> <span class="hljs-string">skip</span>]<br></code></pre></td></tr></table></figure><h1 id="实例：自动使用-Pandoc-将-Markdown-文件转换为-PDF"><a href="#实例：自动使用-Pandoc-将-Markdown-文件转换为-PDF" class="headerlink" title="实例：自动使用 Pandoc 将 Markdown 文件转换为 PDF"></a>实例：自动使用 Pandoc 将 Markdown 文件转换为 PDF</h1><p>以<a href="https://github.com/Dunky-Z/uefi-spec-zh">Dunky-Z/uefi-spec-zh</a>项目中使用的 GitHub Actions 为例，解释如何实现将 Markdown 文件转换为 PDF。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># CI 名为 MPPL</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">MPPL</span><br><br><span class="hljs-comment"># 在 Push 代码时触发 CI</span><br><span class="hljs-attr">on:</span> <span class="hljs-string">push</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-comment"># 任务名称为 convert_via_pandoc</span><br>  <span class="hljs-attr">convert_via_pandoc:</span><br>    <span class="hljs-comment"># 在 ubuntu-latest 系统上运行</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-comment"># 步骤一：下载最新代码</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-comment"># 步骤二：在项目根目录建立 output 文件夹放生成的 PDF 文件</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">create</span> <span class="hljs-string">file</span> <span class="hljs-string">list</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-string">files_list</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir output  # create output dir</span><br><span class="hljs-string"></span>      <span class="hljs-comment"># 步骤三：更新项目的子模块</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Git</span> <span class="hljs-string">Sumbodule</span> <span class="hljs-string">Update</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          git submodule update --init --remote --recursive</span><br><span class="hljs-string"></span>      <span class="hljs-comment"># 步骤四：为运行的系统中安装需要的字体，因为原系统没有需要的中文字体</span><br>      <span class="hljs-comment"># 字体来源为项目目录的MPPL/fonts</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">add</span> <span class="hljs-string">fonts</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          sudo apt-get install ttf-mscorefonts-installer</span><br><span class="hljs-string">          sudo apt-get install fontconfig</span><br><span class="hljs-string">          fc-list :lang=zh</span><br><span class="hljs-string">          ls -lh /usr/share/fonts/</span><br><span class="hljs-string">          cp -rf ./MPPL/fonts/* /usr/share/fonts/</span><br><span class="hljs-string">          mkfontscale</span><br><span class="hljs-string">          mkfontdir</span><br><span class="hljs-string">          fc-cache</span><br><span class="hljs-string">          fc-list</span><br><span class="hljs-string"></span>      <span class="hljs-comment"># 步骤五：安装 pandoc 和 texlive</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">pandoc</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          sudo apt-get update</span><br><span class="hljs-string">          sudo apt-get install texlive-full</span><br><span class="hljs-string">          sudo apt-get install pandoc</span><br><span class="hljs-string">          sudo apt-get clean</span><br><span class="hljs-string"></span>      <span class="hljs-comment"># 步骤六：使用 pandoc 命令生成 pdf</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">build</span> <span class="hljs-string">pdf</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          cd src</span><br><span class="hljs-string">          pandoc -f  markdown-auto_identifiers  --listings --pdf-engine=xelatex --template=../MPPL/templates/mppl.tex  --output=../output/UEFI规范-中文.pdf *.md</span><br><span class="hljs-string"></span>      <span class="hljs-comment"># 步骤七：将生成的结果上传到 GitHub</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/upload-artifact@master</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">output</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">output</span><br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>every step must define a <code>uses</code> or <code>run</code> key<br><a href="https://github.com/einaregilsson/beanstalk-deploy/issues/2">every step must define a uses or run key · Issue #2 · einaregilsson/beanstalk-deploy</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/fhem/mod-Buienradar/issues/318">GH actions: a step cannot have both the </a><a href="https://github.com/fhem/mod-Buienradar/issues/318"><code>uses</code></a><a href="https://github.com/fhem/mod-Buienradar/issues/318"> and </a><a href="https://github.com/fhem/mod-Buienradar/issues/318"><code>run</code></a><a href="https://github.com/fhem/mod-Buienradar/issues/318"> keys · Issue #318 · fhem/mod-Buienradar</a></p><p><a href="https://github.com/einaregilsson/beanstalk-deploy/issues/2">every step must define a uses or run key · Issue #2 · einaregilsson/beanstalk-deploy</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Efficiency</tag>
      
      <tag>Github</tag>
      
      <tag>CI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密算法总结</title>
    <link href="/2022/10/10/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/10/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="明文与密文"><a href="#明文与密文" class="headerlink" title="明文与密文"></a>明文与密文</h2><ul><li>Plaintext，明文，未经加密的消息，任何人都可以读</li><li>Ciphertext，密文，加密后的消息，不可读</li><li>Key，密钥，用于加密和解密（核心是算法）</li></ul><h2 id="加密与解密概念"><a href="#加密与解密概念" class="headerlink" title="加密与解密概念"></a>加密与解密概念</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>数据加密 的基本过程，就是对原来为 明文 的文件或数据按 某种算法 进行处理，使其成为 不可读 的一段代码，通常称为“密文”。通过这样的途径，来达到 保护数据 不被 非法人窃取、阅读的目的。</p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>加密 的 逆过程 为 解密，即将该 编码信息 转化为其 原来数据 的过程。</p><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p>加密算法分 <strong>对称加密</strong> 和 <strong>非对称加密</strong>，其中对称加密算法的加密与解密 <strong>密钥相同</strong>，非对称加密算法的加密密钥与解密 <strong>密钥不同</strong>，此外，还有一类 <strong>不需要密钥</strong> 的 <strong>散列算法</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-00-40-c536814468b9400500824199c2105b28-20221010140039-a6b9ec.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-10-59-06393c9fde719e436d8f09dc143e5d73-20221010141058-d38144.png"></p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密算法 是应用较早的加密算法，又称为 <strong>共享密钥加密算法</strong>。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。</p><ul><li><p>数据加密过程：在对称加密算法中，数据发送方 将 明文 (原始数据) 和 加密密钥 一起经过特殊 加密处理，生成复杂的 加密密文 进行发送。</p></li><li><p>数据解密过程：数据接收方 收到密文后，若想读取原数据，则需要使用 加密使用的密钥 及相同算法的 逆算法 对加密的密文进行解密，才能使其恢复成 可读明文。</p></li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密算法，又称为 <strong>公开密钥加密算法</strong>。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。<br>因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。</p><ul><li><p>如果使用 公钥 对数据 进行加密，只有用对应的 私钥 才能 进行解密。</p></li><li><p>如果使用 私钥 对数据 进行加密，只有用对应的 公钥 才能 进行解密。</p></li></ul><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名，顾名思义，就是用来证明自己身份的一种方式。在使用非对称加密算法通信时，<strong>如何验证发送者是真实的发送者，发送的信息没有篡改</strong>，就需要数字签名。一套 数字签名 通常定义两种 互补 的运算，一个用于 签名，另一个用于 验证。分别由 发送者 持有能够 代表自己身份 的 私钥（私钥不可泄露），由 接受者 持有与私钥对应的 公钥，能够在 接受 到来自发送者信息时用于 验证 其身份。</p><h1 id="加密算法详解"><a href="#加密算法详解" class="headerlink" title="加密算法详解"></a>加密算法详解</h1><p>通过以上简介可以了解到，加密算法分为需要秘钥的和不需要秘钥的，需要秘钥的有可以分为对称加密与非对称加密两大类。接来来我们就详细探究一下各个加密算法。</p><h2 id="哈希算法（不可逆）"><a href="#哈希算法（不可逆）" class="headerlink" title="哈希算法（不可逆）"></a>哈希算法（不可逆）</h2><p>哈希算法可以将任意长度的输入数据，生成固定长度的输出（哈希值）。</p><p>常见的哈希算法有如下：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-40-43-24c6e7e9577cf8f77efcc6c418aad103-20221010144042-761be3.png"></p><p>目前比较常用的是 MD5 和 SHA 系列（比如比特币用的 SHA256 算法，Git 中的 commit hash 用的 SHA1）。</p><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>MD5（Message-Digest）典型应用是对一段信息产生 <strong>信息摘要</strong>，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 <strong>摘要算法</strong>。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。</p><h3 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h3><p>SHA1(Secure Hash Algorithm) 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 $2 ^{64}$ 位的消息，SHA1 会产生一个 160 位的 消息摘要。</p><h2 id="对称加密（可逆）"><a href="#对称加密（可逆）" class="headerlink" title="对称加密（可逆）"></a>对称加密（可逆）</h2><p>对称加密算法是应用比较早的算法，在数据加密和解密的时用的都是同一个密钥，这就造成了密钥管理困难的问题。常见的对称加密算法有 DES、3DES、AES128、AES192、AES256。</p><h3 id="A5-1、A5-2及RC4"><a href="#A5-1、A5-2及RC4" class="headerlink" title="A5/1、A5/2及RC4"></a>A5/1、A5/2及RC4</h3><p>A5/1、A5/2及RC4他们都属于对称加密算法，并都属于流加密。先了解什么是流加密。</p><p>在密码学中，<strong>流加密</strong>（英语：Stream cipher），是一种对称加密算法，加密和解密双方使用相同伪随机加密数据流（pseudo-random stream）作为密钥，明文数据每次与密钥数据流顺次对应加密，得到密文数据流。实践中通常<strong>把信息中的每一位跟密钥流的每一位进行异或 (xor) 运算来获得密文</strong>。</p><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>DES(Data Encryption Standard) 是对称加密算法领域中的典型算法，是一种<strong>块加密算法</strong>(Block cipher)，其密钥默认长度为 56 位。块加密或者叫分组加密，这种加密方法是把明文分成几个固定大小的 block 块，然后分别对其进行加密。</p><p>DES 加密算法是对 <strong>密钥进行保密</strong>，而 <strong>公开算法</strong>，包括加密和解密算法。这样，只有掌握了和发送方 相同密钥 的人才能解读由 DES 加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是 <strong>搜索密钥的编码</strong>。对于 56 位长度的 密钥 来说，如果用 穷举法 来进行搜索的话，其运算次数为 $2 ^{56}$ 次。</p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>AES 是美国国家标准技术研究所 NIST 旨在取代 DES 的 21 世纪的加密标准。AES 是块加密算法，也就是说，每次处理的数据是一块（16 字节），当数据不是 16 字节的倍数时填充，这就是所谓的<strong>分组密码</strong>（区别于基于比特位的流密码），16 字节是分组长度。AES 共有 ECB、CBC 等多种模式。</p><h3 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h3><p>SM4 算法于 2012 年被国家密码管理局确定为国家密码行业标准，最初主要用于 WAPI (WLAN Authentication and Privacy Infrastructure) 无线网络中。SM4 算法的出现为将我国商用产品上的密码算法由国际标准替换为国家标准提供了强有力的支撑。随后，SM4 算法被广泛应用于政府办公、公安、银行、税务、电力等信息系统中，其在我国密码行业中占据着极其重要的位置。类似于 DES、AES 算法，SM4 算法也是一种分组密码算法。</p><h2 id="非对称加密（可逆）"><a href="#非对称加密（可逆）" class="headerlink" title="非对称加密（可逆）"></a>非对称加密（可逆）</h2><p>学习非对称加密之前，我们得了解如何进行安全高效地秘钥交换。我们不可能说通信双方在通信之前，先见个面协商一下秘钥 key，这样非常不方便，但是又不能直接把 key 秘钥通过一个不安全的信道发出去，这样就会被攻击者截获。</p><p>所以我们需要有一种方法，<strong>可以让双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥</strong>。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容，这就是秘钥交换的概念（key exchange）。</p><h3 id="Diffie–Hellman-key-exchange"><a href="#Diffie–Hellman-key-exchange" class="headerlink" title="Diffie–Hellman key exchange"></a>Diffie–Hellman key exchange</h3><p>迪菲-赫尔曼密钥交换（英语：Diffie–Hellman key exchange，缩写为 D-H）是一种安全协议。可以完成上述秘钥交换。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/16-12-34-6c10e628d0058564969403b4f278deee-20221010161233-308a13.png"></p><ol><li><p>通信双方 Alice 和 Bob 个准备一个大的质数，Alice 准备的质数是<code>n=11</code>, Bob 准备的质数是<code>g=7</code>，<code>n</code>和<code>g</code>是公开的，任何第三方都可以获取到这个信息。</p></li><li><p>Alice 准备一个随机自然数<code>x=3</code>, 除了 Alice 没有人知道<code>x</code>是多少，Alice 通过计算<code>g</code>的<code>x</code>次方并且对 <code>n</code> 取模，得到结果大 <code>A</code></p></li><li><p>Alice 把计算得到的结果 <code>A=2</code> 发送给 Bob，这个信息是公开的，任何人可以获取到 <code>A</code></p></li><li><p>Bob 同样准备一个随机自然数 <code>y=6</code>，除了 Bob 没有人知道 <code>y</code> 是多少，Bob 通过计算 <code>g</code> 的 <code>y</code> 次方并且对 <code>n</code> 取模，得到结果大 <code>B</code></p></li><li><p>Bob 把计算结果 <code>B=4</code>，发送给 Alice，，这个信息是公开的，任何人可以获取到 <code>B</code></p></li><li><p>Alice 拿到 <code>B</code> 以后，对 <code>B</code> 求 <code>x</code> 次方并对 <code>n</code> 取模，得到 <code>K1=9</code></p></li><li><p>Bob 拿到 <code>A</code> 以后，对 <code>A</code> 对 <code>y</code> 次方并对 <code>n</code> 取模，得到 <code>K2=9</code></p></li></ol><p><code>K1 == K2</code>，Alice 和 Bob 可以使用 <code>K1</code>，<code>K2</code> 作为 Key 进行通信加密。</p><p>在整个通信过程中，攻击者是无法知道 <code>x</code>，<code>y</code> 以及 <code>K1</code>，<code>K2</code> 的，或者说计算的困难很大，感兴趣的同学可以在网上找到具体的数学问题，离散对数问题的求解。</p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>Diffie–Hellman key exchange 发明后不久出现了 RSA，另一个进行公钥交换的算法。它使用了非对称加密算法。</p><p>RSA 加密算法是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。</p><p>RSA 所用到的数学原理可以参考阮一峰老师的文章<a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA 算法原理（一）</a>，文章介绍了 RSA 用到的一些数学定理，不涉及证明，这对于了解 RSA 也就足够了。</p><p>简单介绍一下秘钥是生成过程（摘自<a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA 算法原理（二）</a>）：</p><ol><li><p>随机选择两个不相等的质数 $p$ 和 $q$。爱丽丝选择了$61$和$53$。（实际应用中，这两个质数越大，就越难破解。）</p></li><li><p>计算$p$和$q$的乘积$n$。爱丽丝就把 $61$ 和 $53$ 相乘。<br> $$n = 61×53 = 3233$$</p><p> $n$ 的长度就是密钥长度。$3233$ 写成二进制是 $110010100001$，一共有 $12$ 位，所以这个密钥就是 $12$ 位。实际应用中，RSA 密钥一般是 $1024$ 位，重要场合则为 $2048$ 位。</p></li><li><p>计算 $n$ 的欧拉函数$\varphi(n)$。根据公式：<br> $$\varphi(n) = (p-1)(q-1)$$</p><p> 爱丽丝算出$\varphi(3233)$ 等于 $60×52$，即 $3120$。</p></li><li><p>随机选择一个整数 $e$，条件是 $1&lt; e &lt; \varphi(n)$，且 $e$ 与$\varphi(n)$ 互质。<br> 爱丽丝就在 $1$ 到 $3120$ 之间，随机选择了 $17$。（实际应用中，常常选择 $65537$。）</p></li><li><p>计算 $e$ 对于$\varphi(n)$ 的模反元素 $d$。</p><p> 所谓”模反元素”就是指有一个整数 $d$，可以使得 $ed$ 被$\varphi(n)$ 除的余数为 $1$。</p><p> $$ed ≡ 1 (mod \varphi(n))$$<br> 这个式子等价于</p><p> $$ed - 1 = k\varphi(n)$$</p><p> 于是，找到模反元素 $d$，实质上就是对下面这个二元一次方程求解。</p><p> $$ex + \varphi(n)y = 1$$</p><p> 已知 $e=17$, $\varphi(n)=3120$，</p><p> $$17x + 3120y = 1$$</p><p> 这个方程可以用<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">扩展欧几里得算法</a>求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 $(x,y)=(2753,-15)$，即 $d=2753$。</p><p> 至此所有计算完成。</p></li><li><p>将 $n$ 和 $e$ 封装成公钥，$n$ 和 $d$ 封装成私钥。</p><p> 在爱丽丝的例子中，$n=3233$，$e=17$，$d=2753$，所以公钥就是 $(3233,17)$，私钥就是$3233, 2753）$。</p><p> 实际应用中，公钥和私钥的数据都采用 <code>ASN.1</code> 格式表达。</p></li></ol><p>RSA 算法为何是可靠的呢？因为该算法基于一个十分简单的数论事实：<strong>将两个大素数相乘十分容易，但想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥</strong>。</p><p>回顾上面的密钥生成步骤，一共出现六个数字：</p><p>$$p,q,n,\varphi(n),e,d$$</p><p>这六个数字之中，公钥用到了两个（$n$和$e$），其余四个数字都是不公开的。其中最关键的是$d$，因为$n$和$d$组成了私钥，一旦$d$泄漏，就等于私钥泄漏。</p><p>那么，有无可能在已知$n$和$e$的情况下，推导出$d$？</p><ul><li>$ed≡1 (mod φ(n))$。只有知道$e$和$φ(n)$，才能算出$d$。</li><li>$φ(n)=(p-1)(q-1)$。只有知道$p$和$q$，才能算出$φ(n)$。</li><li>$n=pq$。只有将$n$因数分解，才能算出 $p$ 和 $q$。</li></ul><p>结论：如果 $n$ 可以被因数分解，$d$ 就可以算出，也就意味着私钥被破解。</p><p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。</p><p>举例来说，你可以对 3233 进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">12301866845301177551304949<br>58384962720772853569595334<br>79219732245215172640050726<br>36575187452021997864693899<br>56474942774063845925192557<br>32630345373154826850791702<br>61221429134616704292143116<br>02221240479274737794080665<br>351419597459856902143413<br></code></pre></td></tr></table></figure><p>它等于这样两个质数的乘积：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">33478071698956898786044169<br>84821269081770479498371376<br>85689124313889828837938780<br>02287614711652531743087737<br>814467999489<br>　　×<br>36746043666799590428244633<br>79962795263227915816434308<br>76426760322838157396665112<br>79233373417143396810270092<br>798736308917<br></code></pre></td></tr></table></figure><p>事实上，这大概是人类已经分解的最大整数（232 个十进制位，768 个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长 RSA 密钥就是 768 位。</p><h1 id="签名与证书"><a href="#签名与证书" class="headerlink" title="签名与证书"></a>签名与证书</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://learn-cryptography.readthedocs.io/zh/latest/basic/">Learn Cryptography</a></li><li><a href="https://juejin.cn/post/6844903638117122056">浅谈常见的七种加密算法及实现 - 掘金</a></li><li><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA 算法原理（一） - 阮一峰的网络日志</a></li><li><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA 算法原理（二） - 阮一峰的网络日志</a></li><li><a href="https://segmentfault.com/a/1190000023445325">加密解密 - 面试官：说一下你常用的加密算法_个人文章 - SegmentFault 思否</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>加密算法</tag>
      
      <tag>Cryptography</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用 git-send-mail 给开源社区提交 Patch</title>
    <link href="/2022/09/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git-send-mail%E7%BB%99%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E6%8F%90%E4%BA%A4Patch/"/>
    <url>/2022/09/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git-send-mail%E7%BB%99%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E6%8F%90%E4%BA%A4Patch/</url>
    
    <content type="html"><![CDATA[<h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>如果参与 Linux、QEMU 或者 OpenSBI 等开源项目，不能通过在 GitHub 或者 Gitlab 平台提交<code>pull request</code>。而是需要将修改的代码，通过 Patch 形式提交到对应的<code>listserv</code>供 Maintainer 审核。那么如何创建 Patch 并发送呢？</p><p>这里以向 <a href="https://github.com/riscv-software-src/opensbi">OpenSBI</a> 提交一个 Patch 为例。</p><h1 id="创建-Patch"><a href="#创建-Patch" class="headerlink" title="创建 Patch"></a>创建 Patch</h1><p>首先将官方 Repository，Fork 到自己的 GitHub：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/28/5570d8a6420346a4a30463dfb9724f09.png"></p><p>回到自己的主页，找到刚刚 Fork 的 Repository，将其 Clone 到本地：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/28/e45a6f8a447f62c7613909672550029c.png"></p><p>修改代码与正常开发流程一直，修改完在<code>git commit</code>时需要加上<code>Signed-off-by</code>字段，因为 Merge 代码的人通常不是提交代码的人，有该字段才能证明是你修改了对应的代码。</p><p><code>-s</code>参数会自动加上<code>Signed-off-by</code>字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -s<br><br>doc:fix some typos<br><br>Signed-off-by: dominic &lt;dominic@gmail.com&gt;<br><br><span class="hljs-comment"># Please enter the commit message for your changes. Lines starting</span><br><span class="hljs-comment"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Date:      Tue Sep 27 21:11:41 2022 +0800</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># On branch master</span><br><span class="hljs-comment"># Your branch is up to date with &#x27;origin/master&#x27;.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Changes to be committed:</span><br><span class="hljs-comment">#       modified:   docs/domain_support.md</span><br><span class="hljs-comment">#       modified:   docs/library_usage.md</span><br><span class="hljs-comment">#       modified:   docs/platform_requirements.md</span><br><span class="hljs-comment">#       modified:   docs/pmu_support.md</span><br></code></pre></td></tr></table></figure><p>生成<code>.patch</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git format-patch HEAD^<br>0001-doc-fix-some-typos.patch<br></code></pre></td></tr></table></figure><p>在当前目录下会生成一个<code>0001-doc-fix-some-typos.patch</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status <br>On branch master<br>Your branch is up to date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        0001-doc-fix-some-typos.patch<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br></code></pre></td></tr></table></figure><p>这个文件就是我们要发送的文件，文件内容就是我们的代码修改，以及作者等信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat 0001-doc-fix-some-typos.patch <br>From d404cb82f4c4aca15dcd35855d0bc96c5b4431d5 Mon Sep 17 00:00:00 2001<br>From: Dunky-Z &lt;xxxxxxxxx@qq.com&gt;<br>Date: Tue, 27 Sep 2022 21:11:41 +0800<br>Subject: [PATCH] doc:fix some typos<br><br>Signed-off-by: dominic &lt;dominic@gmail.com&gt;<br>---<br> docs/domain_support.md        |  6 +++---<br> docs/library_usage.md         |  2 +-<br> docs/platform_requirements.md |  2 +-<br> docs/pmu_support.md           | 10 +++++-----<br> 4 files changed, 10 insertions(+), 10 deletions(-)<br><br>diff --git a/docs/domain_support.md b/docs/domain_support.md<br>index 73931f1..8963b57 100644<br>--- a/docs/domain_support.md<br>+++ b/docs/domain_support.md<br>@@ -2,7 +2,7 @@ OpenSBI Domain Support<br> ======================<br>...<br></code></pre></td></tr></table></figure><h1 id="配置-send-email"><a href="#配置-send-email" class="headerlink" title="配置 send-email"></a>配置 send-email</h1><h2 id="安装-git-email"><a href="#安装-git-email" class="headerlink" title="安装 git-email"></a>安装 git-email</h2><p>通过<code>git</code>直接发送 Patch 需要使用<code>git-email</code>工具，得手动安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install git-email<br></code></pre></td></tr></table></figure><blockquote><p>Windows 平台在安装 Git 时默认已安装</p></blockquote><h2 id="生成-smtp-授权码"><a href="#生成-smtp-授权码" class="headerlink" title="生成 smtp 授权码"></a>生成 smtp 授权码</h2><p>登录<a href="https://mail.qq.com/">QQ 邮箱 - 帐户</a>：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/12-33-23-5d80803932cf57943288c95cbe54695f-20220928123322-170195.png"></p><p>开启 IMAP/SMTP 服务，并生成授权码：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/12-35-33-82f717633b6d7e09e447beef355a8d33-20220928123532-a208fc.png"></p><p>根据提示发送短信：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/12-36-22-173ddcbec9548211275c43b5dc546042-20220928123621-a01c07.png"></p><p>记录下生成的授权码：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/12-37-37-97677e266332c45fc640a09659d0ae3f-20220928123736-4d0f30.png"></p><h2 id="配置-gitconfig"><a href="#配置-gitconfig" class="headerlink" title="配置.gitconfig"></a>配置.gitconfig</h2><p>Ubuntu 平台：<code>~/.gitconfig</code><br>Windows 平台：<code>C:\Users\用户名\.gitconfig</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">sendemail</span>]<br> <span class="hljs-string">smtpencryption</span> <span class="hljs-string">=</span> <span class="hljs-string">tls</span><br>    <span class="hljs-string">smtpserver</span> <span class="hljs-string">=</span> <span class="hljs-string">smtp.qq.com</span><br>    <span class="hljs-string">smtpuser</span> <span class="hljs-string">=</span> <span class="hljs-string">dominic_riscx@qq.com</span><br> <span class="hljs-string">smtpserverport</span> <span class="hljs-string">=</span> <span class="hljs-number">587</span><br>    <span class="hljs-string">from</span> <span class="hljs-string">=</span> <span class="hljs-string">dominic_riscx@qq.com</span><br> <span class="hljs-string">smtppass</span> <span class="hljs-string">=</span> <span class="hljs-string">xxxxxx</span><br> <span class="hljs-string">cc</span> <span class="hljs-string">=</span> <span class="hljs-string">dominic@gmail.com</span><br> <span class="hljs-comment">#to = opensbi@lists.infradead.org</span><br></code></pre></td></tr></table></figure><p>为了方便复制，单独注释：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">sendemail</span>]<br> <span class="hljs-string">smtpencryption</span> <span class="hljs-string">=</span> <span class="hljs-comment"># 加密方式，保持默认</span><br>    <span class="hljs-string">smtpserver</span> <span class="hljs-string">=</span>     <span class="hljs-comment"># smtp 服务器地址，保持默认</span><br>    <span class="hljs-string">smtpuser</span> <span class="hljs-string">=</span>       <span class="hljs-comment"># 邮箱地址，改为 QQ 邮箱地址，也就是用哪个邮箱发送，就填哪个</span><br> <span class="hljs-string">smtpserverport</span> <span class="hljs-string">=</span> <span class="hljs-comment"># 端口号，保持默认</span><br>    <span class="hljs-string">from</span> <span class="hljs-string">=</span>           <span class="hljs-comment"># 同 smtpuser</span><br> <span class="hljs-string">smtppass</span> <span class="hljs-string">=</span>       <span class="hljs-comment"># 上文生成的 smtp 授权码</span><br> <span class="hljs-string">cc</span> <span class="hljs-string">=</span>             <span class="hljs-comment"># 抄送的邮箱地址</span><br> <span class="hljs-comment">#to = opensbi@lists.infradead.org </span><br>    <span class="hljs-comment"># 要发送的地址，这个字段我注释了，因为怕以后发邮件默认发到这个地址，这个字段可以在发送时单独填写</span><br></code></pre></td></tr></table></figure><h1 id="发送-Patch"><a href="#发送-Patch" class="headerlink" title="发送 Patch"></a>发送 Patch</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#$ git send-email patch文件名</span><br>$ git send-email  0001-doc-fix-some-typos.patch<br>0001-doc-fix-some-typos.patch<br><span class="hljs-comment"># 提示往哪里发送，填写要接收的邮箱即可，我这里填写的是OpenSBI接收Patch的地址</span><br>To whom should the emails be sent (<span class="hljs-keyword">if</span> anyone)? opensbi@lists.infradead.org<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Message-ID to be used as In-Reply-To <span class="hljs-keyword">for</span> the first email (<span class="hljs-keyword">if</span> any)? <br><span class="hljs-comment"># 回车，保存默认（我还不清楚这里的作用）</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">(mbox) Adding cc: Dunky-Z &lt;xxxxxxxxx@qq.com&gt; from line <span class="hljs-string">&#x27;From: Dunky-Z &lt;xxxxxxxxx@qq.com&gt;&#x27;</span><br>(body) Adding cc: dominic &lt;dominic@gmail.com&gt; from line <span class="hljs-string">&#x27;Signed-off-by: dominic &lt;dominic@gmail.com&gt;&#x27;</span>   <br><br>From: dominic_riscx@qq.com<br>To: opensbi@lists.infradead.org<br>Cc: dominic@gmail.com,<br>        Dunky-Z &lt;xxxxxxxxx@qq.com&gt;<br>Subject: [PATCH] doc:fix some typos<br>Date: Wed, 28 Sep 2022 10:35:30 +0800<br>Message-Id: &lt;20220928023530.2344-1-dominic_riscx@qq.com&gt;<br>X-Mailer: git-send-email 2.34.1.windows.1<br>MIME-Version: 1.0<br>Content-Transfer-Encoding: 8bit<br><br>    The Cc list above has been expanded by additional<br>    addresses found <span class="hljs-keyword">in</span> the patch commit message. By default<br>    send-email prompts before sending whenever this occurs.<br>    This behavior is controlled by the sendemail.confirm<br>    configuration setting.<br><br>    For additional information, run <span class="hljs-string">&#x27;git send-email --help&#x27;</span>.<br>    To retain the current behavior, but squelch this message,<br>    run <span class="hljs-string">&#x27;git config --global sendemail.confirm auto&#x27;</span>.<br><br>Send this email? ([y]es|[n]o|[e]dit|[q]uit|[a]ll): y<br><br><span class="hljs-comment"># y 确认发送</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">OK. Log says:<br>Server: smtp.qq.com<br>MAIL FROM:&lt;dominic_riscx@qq.com&gt;<br>RCPT TO:&lt;opensbi@lists.infradead.org&gt;<br>RCPT TO:&lt;dominic@gmail.com&gt;<br>RCPT TO:&lt;xxxxxxxxx@qq.com&gt;<br>From: dominic_riscx@qq.com<br>To: opensbi@lists.infradead.org<br>Cc: dominic@gmail.com,<br>        Dunky-Z &lt;xxxxxxxxx@qq.com&gt;<br>Subject: [PATCH] doc:fix some typos<br>Date: Wed, 28 Sep 2022 10:35:30 +0800<br>Message-Id: &lt;20220928023530.2344-1-dominic_riscx@qq.com&gt;<br>X-Mailer: git-send-email 2.34.1.windows.1<br>MIME-Version: 1.0<br>Content-Transfer-Encoding: 8bit<br><br>Result: 250<br><br><span class="hljs-comment"># 发送成功</span><br></code></pre></td></tr></table></figure><p>前往<a href="http://lists.infradead.org/pipermail/opensbi/">The opensbi Archives</a>，找到对应的月份，点击<code>Theread</code>，即可找到自己发送的 Patch，每个开源社区一般都会在如何提交 PR 的文档里公开 Patch Archive 网址，这里是以 OpenSBI 的网址。</p><p>前往邮箱发送记录中也可以找到对应的 Patch 信息：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/28/52837340ba2d7223cd0eb990f8a5288b.png"></p><p>以上就是完整的提交 Patch 过程。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile 基础</title>
    <link href="/2022/09/26/Makefile%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/26/Makefile%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="目标、依赖、命令"><a href="#目标、依赖、命令" class="headerlink" title="目标、依赖、命令"></a>目标、依赖、命令</h2><ul><li>目标就是我们要去 make xxx 的那个 xxx，就是我们最终要生成的东西。</li><li>依赖是用来生成目录的原材料</li><li>命令就是加工方法，所以 make xxx 的过程其实就是使用命令将依赖加工成目标的过程。</li></ul><h2 id="通配符-和-Makefile-自动推导"><a href="#通配符-和-Makefile-自动推导" class="headerlink" title="通配符 % 和 Makefile 自动推导"></a>通配符 <code>%</code> 和 Makefile 自动推导</h2><ul><li><code>%</code> 是 Makefile 中的通配符，代表一个或几个字母。也就是说<code>%.o</code>就代表所有以<code>.o</code>为结尾的文件。</li><li>所谓自动推导其实就是 Makefile 的规则。当 Makefile 需要某一个目标时，他会把这个目标去套规则说明，一旦套上了某个规则说明，则 Makefile 会试图寻找这个规则中的依赖，如果能找到则会执行这个规则用依赖生成目标。</li></ul><h2 id="Makefile-中定义和使用变量"><a href="#Makefile-中定义和使用变量" class="headerlink" title="Makefile 中定义和使用变量"></a>Makefile 中定义和使用变量</h2><ul><li>Makefile 中定义和使用变量，和 shell 脚本中非常相似。相似的是都没有变量类型，直接定义使用，引用变量时用<code>$var</code>。</li></ul><h2 id="伪目标（-PHONY）"><a href="#伪目标（-PHONY）" class="headerlink" title="伪目标（.PHONY）"></a>伪目标（<code>.PHONY</code>）</h2><ul><li>伪目标意思是这个目标本身不代表一个文件，执行这个目标不是为了得到某个文件或东西，而是单纯为了执行这个目标下面的命令。</li><li>伪目标一般都没有依赖，因为执行伪目标就是为了执行目标下面的命令。既然一定要执行命令了那就不必加依赖，因为不加依赖意思就是无条件执行。</li><li>伪目标可以直接写，不影响使用；但是有时候为了明确声明这个目标是伪目标会在伪目标的前面用<code>.PHONY</code>来明确声明它是伪目标。</li></ul><h2 id="Makfile-中引用其他-Makefile"><a href="#Makfile-中引用其他-Makefile" class="headerlink" title="Makfile 中引用其他 Makefile"></a>Makfile 中引用其他 Makefile</h2><ul><li>有时候 Makefile 总体比较复杂，因此分成好几个 Makefile 来写。然后在主 Makefile 中引用其他的，用 <code>include</code> 指令来引用。引用的效果也是原地展开，和 C 语言中的头文件包含非常相似。</li></ul><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><ul><li><code>=</code>最简单的赋值</li><li><code>:=</code>一般也是赋值</li></ul><p>以上这两个大部分情况下效果是一样的，但是有时候不一样。用<code>=</code>赋值的变量，在被解析时他的值取决于最后一次赋值时的值，所以你看变量引用的值时不能只往前面看，还要往后面看。用<code>:=</code>来赋值的，则是就地直接解析，只用往前看即可。</p><ul><li><code>?=</code>如果变量前面并没有赋值过则执行这条赋值，如果前面已经赋值过了则本行被忽略。（实验可以看出：所谓的没有赋值过其实就是这个变量没有被定义过）</li><li><code>+=</code>用来给一个已经赋值的变量接续赋值，意思就是把这次的值加到原来的值的后面，有点类似于 <code>strcat</code>。（注意一个细节，<code>+=</code>续接的内容和原来的内容之间会自动加一个空格隔开）</li></ul><p>注意：Makefile 中并不要求赋值运算符两边一定要有空格或者无空格，这一点比 shell 的格式要求要松一些。</p><h2 id="Makefile-的环境变量"><a href="#Makefile-的环境变量" class="headerlink" title="Makefile 的环境变量"></a>Makefile 的环境变量</h2><ul><li>makefile 中用 <code>export</code> 导出的就是环境变量。一般情况下要求环境变量名用大写，普通变量名用小写。</li><li>环境变量和普通变量不同，可以这样理解：环境变量类似于整个工程中所有 Makefile 之间可以共享的全局变量，而普通变量只是当前本 Makefile 中使用的局部变量。所以要注意：定义了一个环境变量会影响到工程中别的 Makefile 文件，因此要小心。</li><li>Makefile 中可能有一些环境变量可能是 makefile 本身自己定义的内部的环境变量或者是当前的执行环境提供的环境变量（譬如我们在 <code>make</code> 执行时给 makefile 传参。<code>make CC=arm-linux-gcc</code>，其实就是给当前 Makefile 传了一个环境变量 <code>CC</code>，值是 <code>arm-linux-gcc</code>。我们在 <code>make</code> 时给 <code>makefile</code> 传的环境变量值优先级最高的，可以覆盖 makefile 中的赋值）。这就好像 C 语言中编译器预定义的宏<code>__LINE__</code> <code>__FUNCTION__</code>等一样。</li></ul><h2 id="Makefile-中使用通配符"><a href="#Makefile-中使用通配符" class="headerlink" title="Makefile 中使用通配符"></a>Makefile 中使用通配符</h2><ul><li><code>*</code>：若干个任意字符</li><li><code>?</code>：1 个任意字符</li><li><code>[]</code>：将 <code>[]</code> 中的字符依次去和外面的结合匹配</li></ul><p>还有个<code>%</code>，也是通配符，表示任意多个字符，和<code>*</code>很相似，但是<code>%</code>一般只用于规则描述中，又叫做规则通配符。</p><h2 id="Makefile-的自动变量"><a href="#Makefile-的自动变量" class="headerlink" title="Makefile 的自动变量"></a>Makefile 的自动变量</h2><ul><li>为什么使用自动变量。在有些情况下文件集合中文件非常多，描述的时候很麻烦，所以我们 Makefile 就用一些特殊的符号来替代符合某种条件的文件集，这就形成了自动变量。</li><li>自动变量的含义：预定义的特殊意义的符号。就类似于 C 语言编译器中预制的那些宏<code>__FILE__</code>一样。</li><li>常见自动变量：<ul><li><code>$@</code>：规则的目标文件名</li><li><code>$&lt;</code>：规则的依赖文件名</li><li><code>$^</code>：依赖的文件集合</li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>Makefile 中的注释用<code>#</code></li><li>在 makefile 的命令行中前面的<code>@</code>表示静默执行</li><li>Makefile 中默认情况下在执行一行命令前会先把这行命令给打印出来，然后再执行这行命令</li><li>如果你不想看到命令本身，只想看到命令执行就静默执行即可</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式 Shell 基础</title>
    <link href="/2022/09/25/%E5%B5%8C%E5%85%A5%E5%BC%8FShell%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/25/%E5%B5%8C%E5%85%A5%E5%BC%8FShell%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><ul><li>常用的脚本语言有 sh、bash、csh、ksh、perl、python；</li><li>在 Linux 下常用的脚本语言其实就是 bash、sh；</li><li>脚本语言一般在嵌入式中应用，主要是用来做配置。（一个复杂的嵌入式程序都是可配置的，配置过程就是用脚本语言来实现的）自然不会使用过于复杂的脚本语言特性，因此只需要针对性的学习即可。</li></ul><h2 id="shell-脚本的运行机制"><a href="#shell-脚本的运行机制" class="headerlink" title="shell 脚本的运行机制"></a>shell 脚本的运行机制</h2><ul><li>C/C++ 语言这种编写过程是：编写出源代码（源代码是不能直接运行的）然后编译链接形成可执行二进制程序，然后才能运行；而脚本程序不同，脚本程序编写好后源代码即可直接运行（没有编译链接过程）；</li><li>shell 程序是解释运行的，所谓解释运行就是说当我们执行一个 shell 程序时，shell 解析器会逐行的解释 shell 程序代码，然后一行一行的去运行。（顺序结构）</li><li>CPU 实际只认识二进制代码，根本不认识源代码。脚本程序源代码其实也不是二进制代码，CPU 也不认识，也不能直接执行。只不过脚本程序的编译链接过程不是以脚本程序源代码为单位进行的，而是在脚本运行过程中逐行的解释执行时才去完成脚本程序源代码转成二进制的过程（不一定是编译链接，因为这行脚本程序可能早就编译连接好了，这里我们只是调用它）。</li></ul><h2 id="动手写第一个-shell"><a href="#动手写第一个-shell" class="headerlink" title="动手写第一个 shell"></a>动手写第一个 shell</h2><h3 id="编辑器与编译器"><a href="#编辑器与编译器" class="headerlink" title="编辑器与编译器"></a>编辑器与编译器</h3><ul><li>shell 程序是文本格式的，只要是文本编辑器都可以。但是因为我们的 shell 是要在 Linux 系统下运行的，所以换行符必须是<code>\n</code>，而 Windows 下的换行符是<code>\r\n</code>，因此 Windows 中的编辑器写的 shell 不能在 Linux 下运行。</li><li>编译器不涉及，因为 shell 是解释性语言，直接编辑完就可以运行。</li></ul><h3 id="shell-程序运行的运行的三种方法"><a href="#shell-程序运行的运行的三种方法" class="headerlink" title="shell 程序运行的运行的三种方法"></a>shell 程序运行的运行的三种方法</h3><ul><li><code>./xx.sh</code>，和运行二进制可执行程序方法一样。这样运行 shell 要求 shell 程序必须具有可执行权限。<code>chmod a+x xx.sh</code> 来添加可执行权限。</li><li><code>source xx.sh</code>，<code>source</code> 是 Linux 的一个命令，这个命令就是用来执行脚本程序的。这样运行不需要脚本具有可执行权限。</li><li><code>bash xx.sh</code>，<code>bash</code> 是一个脚本程序解释器，本质上是一个可执行程序。这样执行相当于我们执行了 <code>bash</code> 程序，然后把 <code>xx.sh</code> 作为 <code>argv[1]</code> 传给他运行。</li></ul><h3 id="hello-world-程序和解释"><a href="#hello-world-程序和解释" class="headerlink" title="hello world 程序和解释"></a>hello world 程序和解释</h3><ul><li>shell 程序的第一行一般都是以<code>#!/bin/sh</code>开始，这行话的意思就是指定 shell 程序执行时被哪个解释器解释执行。所以我们这里写上<code>/bin/sh</code>意思就是这个<code>shell</code>将来被当前机器中<code>/bin</code>目录下的<code>sh</code>可执行程序执行。可以将第一行写为<code>#!/bin/bash</code>来指定使用<code>bash</code>执行该脚本。</li><li>脚本中的注释使用<code>#</code>，<code>#</code>开头的行是注释行。如果有多行需要注释，每行前面都要加<code>#</code>。（<code>#</code>就相当于是 C 语言中的<code>//</code>）;</li><li>shell 程序的正文，由很多行 shell 语句构成。</li></ul><h2 id="shell-语法"><a href="#shell-语法" class="headerlink" title="shell 语法"></a>shell 语法</h2><p>shell 就是把以前命令行中键入执行的命令写成了程序。shell 其实就是为了避免反复的在命令行下手工输入而发明的一种把手工输入步骤记录下来，然后通过执行 shell 脚本程序就能再次复述原来记录的手工输入过程的一种技术。</p><h3 id="shell-中的变量定义和引用"><a href="#shell-中的变量定义和引用" class="headerlink" title="shell 中的变量定义和引用"></a>shell 中的变量定义和引用</h3><ul><li>变量定义和初始化。shell 是弱类型语言（语言中的变量如果有明确的类型则属于强类型语言；变量没有明确类型就是弱类型语言），和 C 语言不同。在 shell 编程中定义变量不需要制定类型，也没有类型这个概念。</li><li>变量定义时可以初始化，使用<code>=</code>进行初始化赋值。在 shell 中赋值的=两边是不能有空格的。<br>注意：shell 对语法非常在意，非常严格。很多地方空格都是必须没有或者必须有，而且不能随意有没有空格。</li><li>变量赋值，变量定义后可以再次赋值，新的赋值会覆盖老的赋值。shell 中并不刻意区分变量的定义和赋值，反正每个变量就是一个符号，这个符号的值就是最后一个给他赋值时的值。</li><li>变量引用。shell 中引用一个变量必须使用<code>$</code>符号，<code>$</code>符号就是变量解引用符号。</li></ul><p>注意：<code>$</code>符号后面跟一个字符串，这个字符串就会被当作变量去解析。如果这个字符串本身没有定义，执行时并不会报错，而是把这个变量解析为空。也就是说在 shell 中没有被定义的变量其实就相当于是一个定义并赋值为空的变量。</p><p>注意：变量引用的时候可以<code>$var</code>，也可以<code>$&#123;var&#125;</code>。这两种的区别是在某些情况下只能用<code>$&#123;var&#125;</code>而不能简单的<code>$var</code>。</p><h3 id="shell-中无引用、单引号和双引号的区别"><a href="#shell-中无引用、单引号和双引号的区别" class="headerlink" title="shell 中无引用、单引号和双引号的区别"></a>shell 中无引用、单引号和双引号的区别</h3><ul><li>shell 中使用字符串可以不加双引号，直接使用。而且有空格时也可以，但是缺陷是不能输出<code>&quot;</code>或者其他转义字符。</li><li>shell 中也可以使用单引号来表示字符串，也是直接使用的，不能输出转义字符。</li><li>单引号中：完全字面替换（不可包含单引号本身）</li><li>双引号中：<ul><li><code>$</code>加变量名可以取变量的值</li><li>反引号仍表示命令替换</li><li><code>\$</code>表示<code>$</code>的字面值（输出$符号）</li><li>`表示`的字面值</li><li><code>\&quot;</code>表示<code>&quot;</code>的字面值</li><li><code>\\</code>表示<code>\</code>的字面值</li></ul></li></ul><p>除以上情况之外，在其它字符前面的\无特殊含义，只表示字面值。</p><p>单引号会原样输出，双引号可以调用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">PATH_A=<span class="hljs-string">&quot;`pwd`/include&quot;</span><br>PATH_B=<span class="hljs-string">&#x27;`pwd`/include&#x27;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH_A</span><br><span class="hljs-comment"># /home/a/b/include</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH_B</span><br><span class="hljs-comment"># `pwd`/include</span><br></code></pre></td></tr></table></figure><h3 id="shell-中调用-Linux-命令"><a href="#shell-中调用-Linux-命令" class="headerlink" title="shell 中调用 Linux 命令"></a>shell 中调用 Linux 命令</h3><ul><li>直接执行</li><li>反引号括起来执行。有时候我们在 shell 中调用 Linux 命令是为了得到这个命令的返回值（结果值），这时候就适合用一对反引号 (键盘上 ESC 按键下面的那个按键，和<code>~</code>在一个按键上) 来调用执行命令。</li></ul><h3 id="shell-中的选择分支结构"><a href="#shell-中的选择分支结构" class="headerlink" title="shell 中的选择分支结构"></a>shell 中的选择分支结构</h3><ul><li>shell 的 <code>if</code> 语言用法很多，在此只介绍常用的，其他感兴趣可以自己去学</li></ul><p>典型<code>if</code>语言格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-keyword">if</span> [ 表达式 ]; <span class="hljs-keyword">then</span><br>  xxx<br>  yyy<br>  zzz<br><span class="hljs-keyword">else</span><br>  xxx<br>  ddd<br>  uuu<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h4 id="if-的典型应用"><a href="#if-的典型应用" class="headerlink" title="if 的典型应用"></a>if 的典型应用</h4><ul><li><p><code>-f</code>判断文件是否存在，注意<code>[]</code>里面<strong>前后都有空格</strong>，不能省略</p></li><li><p><code>-d</code>判断目录是否存在</p></li><li><p><code>&quot;str1&quot; = &quot;str2&quot;</code>判断字符串是否相等，注意<strong>用一个等号而不是两个</strong></p></li><li><p>判断数字是否相等</p><ul><li><code>-eq</code>等于</li><li><code>-gt</code>大于</li><li><code>-lt</code>小于</li><li><code>-ge</code>大于等于</li><li><code>-le</code>小于等于</li></ul></li><li><p><code>-z</code>判断字符串是否为空，注意<code>-z</code>判断时如果变量本身没定义也是不成立（也就是说-z 认为没定义不等于为空）</p></li><li><p><code>-o</code>表示逻辑或，连接两个表达式</p><ul><li><code>if [ 10 -eq 10 -o  ]; then</code></li></ul></li><li><p><code>&amp;&amp;</code> <code>||</code>表示逻辑与和逻辑或</p></li></ul><h3 id="shell-中的循环结构"><a href="#shell-中的循环结构" class="headerlink" title="shell 中的循环结构"></a>shell 中的循环结构</h3><p><code>for</code> 循环，要求能看懂、能改即可。不要求能够完全不参考写出来。因为毕竟嵌入式并不需要完全重新手写。</p><p><code>while</code> 循环，和 C 语言的循环在逻辑上无差别，要注意很多格式要求，譬如：<code>while</code> 后面的 <code>[]</code> 两边都有空格，<code>[]</code> 后面有分号（如果 do 放在一行的话），<code>i++</code>的写法中有两层括号。</p><h3 id="echo-的创建和追加输入文件"><a href="#echo-的创建和追加输入文件" class="headerlink" title="echo 的创建和追加输入文件"></a>echo 的创建和追加输入文件</h3><ul><li>在 shell 中可以直接使用 <code>echo</code> 指令新建一个文件，并且将一些内容传入这个文件中。创建文件并输入内容的关键就是<code>&gt;</code>。</li><li>还可以使用 <code>echo</code> 指令配合追加符号<code>&gt;&gt;</code> 向一个已经存在的文件末尾追加输入内容。</li></ul><h3 id="shell-中其他值得关注的知识点"><a href="#shell-中其他值得关注的知识点" class="headerlink" title="shell 中其他值得关注的知识点"></a>shell 中其他值得关注的知识点</h3><h4 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h4><ul><li>shell 中的 case 语句和 C 语言中的 switch case 语句作用一样，格式有差异</li><li>shell 中的 case 语句天生没有 <code>break</code>，也不需要<code>break</code>，和 C 语言中的 switch case 不同。shell 中的 case 默认就是匹配上哪个执行哪个，不会说执行完了还去执行后面的其他 case</li></ul><h4 id="调用-shell-程序的传参"><a href="#调用-shell-程序的传参" class="headerlink" title="调用 shell 程序的传参"></a>调用 shell 程序的传参</h4><ul><li>C 语言中可以通过 <code>main</code> 函数的 <code>argc</code> 和 <code>argv</code> 给程序传参</li><li>shell 程序本身也可以在调用时传参给他。在 shell 程序内部使用传参也是使用的一些特定符号来表示的，包括：<ul><li><code>$#</code>表示调用该 shell 时传参的个数。（<code>$#</code>计数时只考虑真正的参数个数）</li><li><code>$0、$1、$2·····</code>则依次表示传参的各个参数</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">./a.out aa bb cc     <br><br><span class="hljs-comment"># argc = 4</span><br><span class="hljs-comment"># argv[0] = ./a.out</span><br><span class="hljs-comment"># argv[1] 是第一个有效参数····</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> a.sh aa bb cc  <br><span class="hljs-comment"># $# = 3</span><br><span class="hljs-comment"># $0是执行这个 shell 程序的解析程序的名字</span><br><span class="hljs-comment"># $1是第一个有效参数的值</span><br><span class="hljs-comment"># $2是第 2 个有效参数的值·····</span><br></code></pre></td></tr></table></figure><h4 id="while-循环和-case-语言和传参结合"><a href="#while-循环和-case-语言和传参结合" class="headerlink" title="while 循环和 case 语言和传参结合"></a>while 循环和 case 语言和传参结合</h4><ul><li>shell 中的 <code>break</code> 关键字和 <code>C</code> 语言中意义相同（都是跳出）但是用法不同。因为 shell 中 <code>case</code> 语句默认不用 <code>break</code> 的，因此在 <code>shell</code> 中 <code>break</code> 只用于循环跳出。所以当 <code>while</code> 中内嵌 <code>case</code> 语句时，<code>case</code> 中的 <code>break</code> 是跳出外层的 <code>while</code> 循环的，不是用来跳出 <code>case</code> 语句的。</li><li>shell 中的<code>$# $1</code>等内置变量的值是可以被改变，被 <code>shift</code> 指令改变。<code>shift</code> 指令有点像左移运算符，把我们给 shell 程序的传参左移了一个移出去了，原来的<code>$2</code>变成了新的<code>$1</code>，原来的<code>$#</code>少了 1 个。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>嵌入式开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-chattr 修改文件与目录属性防止误删除</title>
    <link href="/2022/09/25/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-chattr%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7%E9%98%B2%E6%AD%A2%E8%AF%AF%E5%88%A0%E9%99%A4/"/>
    <url>/2022/09/25/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-chattr%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7%E9%98%B2%E6%AD%A2%E8%AF%AF%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p><code>chattr</code>命令可以修改 Linux 的文件属性，在类 Unix 等发行版中，该命令能够有效防止文件和目录被意外的删除或修改。文件在 Linux 中被描述为一个数据结构，<code>chattr</code> 命令在大多数现代 Linux 操作系统中是可用的，可以修改文件属性，一旦定义文件的隐藏属性，那么<strong>该文件的拥有者和 root 用户也无权操作该文件</strong>，只能解除文件的隐藏属性。这就可以有效的避免被误删除。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>一个完整的命令一般由命令 (chattr)，可选项 (option)，操作符 (operator) 与属性 (attribute) 组成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chattr [option] [operator] [attribute]  file<br></code></pre></td></tr></table></figure><p>[option] 可选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">-R， 递归更改目录及其内容的属性。<br>-V， 详细说明chattr的输出并打印程序版本。<br>-f， 隐藏大多数错误消息。<br></code></pre></td></tr></table></figure><p>[operator] 操作符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">+，追加指定属性到文件已存在属性中<br>-， 删除指定属性<br>=，直接设置文件属性为指定属性<br></code></pre></td></tr></table></figure><p>[attribute] 属性如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">a， 只能向文件中添加数据<br>A，不更新文件或目录的最后访问时间<br>i， 文件或目录不可改变<br></code></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="lsattr-命令检查文件已有属性"><a href="#lsattr-命令检查文件已有属性" class="headerlink" title="lsattr 命令检查文件已有属性"></a>lsattr 命令检查文件已有属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-d：如果目标是目录，只会列出目录本身的隐藏属性，而不会列出所含文件或子目录的隐藏属性信息<br>-R：作用于目录时，会显示所有的子目录和文件的隐藏信息<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ lsattr clash<br>--------------e------- clash/glados.yaml<br>--------------e------- clash/clash-linux-386-v1.10.0<br>--------------e------- clash/Country.mmdb<br>--------------e------- clash/cache.db<br>--------------e------- clash/clash-linux-amd64-v1.10.0<br>--------------e------- clash/dashboard<br>$ lsattr -d clash<br>--------------e------- clash<br><br>$ lsattr -R clash<br>--------------e------- clash/glados.yaml<br>--------------e------- clash/clash-linux-386-v1.10.0<br>--------------e------- clash/Country.mmdb<br>--------------e------- clash/cache.db<br>--------------e------- clash/clash-linux-amd64-v1.10.0<br>--------------e------- clash/dashboard<br><br>clash/dashboard:<br>--------------e------- clash/dashboard/manifest.webmanifest<br>--------------e------- clash/dashboard/assets<br><br>clash/dashboard/assets:<br>--------------e------- clash/dashboard/assets/logo.b453e72f.png<br>--------------e------- clash/dashboard/assets/index.408383.js<br>--------------e------- clash/dashboard/assets/index.966f8a.css<br>--------------e------- clash/dashboard/assets/vendor.ca5569.js<br><br>--------------e------- clash/dashboard/sw.js<br>--------------e------- clash/dashboard/workbox-7ce28d.js<br>--------------e------- clash/dashboard/index.html<br></code></pre></td></tr></table></figure><h3 id="禁止对文件test-md重命名，移动或删除，也不能修改其内容"><a href="#禁止对文件test-md重命名，移动或删除，也不能修改其内容" class="headerlink" title="禁止对文件test.md重命名，移动或删除，也不能修改其内容"></a>禁止对文件<code>test.md</code>重命名，移动或删除，也不能修改其内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo chattr +i test.md<br></code></pre></td></tr></table></figure><p>尝试修改该文件，将会被拒绝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rm -f ./test.md<br>rm: cannot remove <span class="hljs-string">&#x27;./test.md&#x27;</span>: Operation not permitted<br><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Hello World!&#x27;</span> &gt; test.md<br>bash: ./test.md: Operation not permitted<br><br>$ mv ./test.md ./fileDir<br>mv: cannot move <span class="hljs-string">&#x27;./test.md&#x27;</span> to <span class="hljs-string">&#x27;./fileDir/test.md&#x27;</span>: Operation not permitted<br></code></pre></td></tr></table></figure><h3 id="禁止修改文件夹fileDir及文件夹中的数据"><a href="#禁止修改文件夹fileDir及文件夹中的数据" class="headerlink" title="禁止修改文件夹fileDir及文件夹中的数据"></a>禁止修改文件夹<code>fileDir</code>及文件夹中的数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir ./fileDir &amp;&amp; touch ./fileDir/test.md<br>sudo chattr +i -R ./fileDir<br></code></pre></td></tr></table></figure><p>尝试修改文件夹中的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rm -rf ./fileDir<br>rm: cannot remove <span class="hljs-string">&#x27;./fileDir/test.md&#x27;</span>: Operation not permitted<br></code></pre></td></tr></table></figure><h3 id="允许向文件添加内容，禁止修改或删除内容，禁止移动文件"><a href="#允许向文件添加内容，禁止修改或删除内容，禁止移动文件" class="headerlink" title="允许向文件添加内容，禁止修改或删除内容，禁止移动文件"></a>允许向文件添加内容，禁止修改或删除内容，禁止移动文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo chattr +a ./test.md<br>$ lsattr ./test.md<br>-----a--------e--- ./test.md<br><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World!&quot;</span> &gt;&gt; ./test.md   <span class="hljs-comment"># 追加内容 OK</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span>&gt; ./test.md            <span class="hljs-comment"># 修改内容 NO</span><br>bash: ./test.md: Operation not permitted<br></code></pre></td></tr></table></figure><h3 id="只允许在目录fileDir中建立和修改文件，但是禁止删除、移动文件"><a href="#只允许在目录fileDir中建立和修改文件，但是禁止删除、移动文件" class="headerlink" title="只允许在目录fileDir中建立和修改文件，但是禁止删除、移动文件"></a>只允许在目录<code>fileDir</code>中建立和修改文件，但是禁止删除、移动文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo chattr +a ./fileDir<br></code></pre></td></tr></table></figure><h3 id="取消某个属性"><a href="#取消某个属性" class="headerlink" title="取消某个属性"></a>取消某个属性</h3><p>使用<code>-</code>操作符即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先给文件添加属性a</span><br>$ sudo chattr +a ./test.md<br>$ lsattr ./test.md<br>-----a--------e--- ./test.md<br><br><span class="hljs-comment"># 取消属性a</span><br>$ sudo chattr -a ./test.md<br>$ lsattr ./test.md<br>--------------e--- ./test.md<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Pandoc 将 MD 转换为 PDF 时报错 (error)\tightlist</title>
    <link href="/2022/09/24/%E8%A7%A3%E5%86%B3Pandoc%E5%B0%86MD%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E6%97%B6%E6%8A%A5%E9%94%99-error-tightlist/"/>
    <url>/2022/09/24/%E8%A7%A3%E5%86%B3Pandoc%E5%B0%86MD%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E6%97%B6%E6%8A%A5%E9%94%99-error-tightlist/</url>
    
    <content type="html"><![CDATA[<p>使用 Pandoc 将<code>test.md</code>转换位 PDF 时，出现如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">! Undefined control sequence.<br>&lt;recently <span class="hljs-built_in">read</span>&gt; \tightlist <br><br>l.213 \end&#123;frame&#125;<br><br>pandoc: Error producing PDF from TeX <span class="hljs-built_in">source</span><br>make: *** [test.pdf] Error 43<br></code></pre></td></tr></table></figure><p>这是因为在 Markdown 文件中使用<code>-</code>表示无序列表，被转化成了<code>\tightlist</code>但是 Pandoc 版本太老，不支持这个命令。（严格来说是 Pandoc 没有处理这个 LaTeX 命令，不是不支持，因为这是 LaTeX 命令和 Pandoc 没关系）。</p><p>有两种方式解决，一是升级 Pandoc 版本，二是将处理<code>\tightlist</code>的命令加到自己使用的模板中。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TeX"><span class="hljs-keyword">\providecommand</span>&#123;<span class="hljs-keyword">\tightlist</span>&#125;&#123;<span class="hljs-comment">%</span><br>  <span class="hljs-keyword">\setlength</span>&#123;<span class="hljs-keyword">\itemsep</span>&#125;&#123;0pt&#125;<span class="hljs-keyword">\setlength</span>&#123;<span class="hljs-keyword">\parskip</span>&#125;&#123;0pt&#125;&#125;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TeX"><span class="hljs-keyword">\def</span><span class="hljs-keyword">\tightlist</span>&#123;&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
      <tag>Markdown</tag>
      
      <tag>Pandoc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 语法简明教程</title>
    <link href="/2022/09/24/Markdown%E8%AF%AD%E6%B3%95%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <url>/2022/09/24/Markdown%E8%AF%AD%E6%B3%95%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown-简介"><a href="#Markdown-简介" class="headerlink" title="Markdown 简介"></a>Markdown 简介</h1><h2 id="Markdown-是什么？"><a href="#Markdown-是什么？" class="headerlink" title="Markdown 是什么？"></a>Markdown 是什么？</h2><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式 (<em>易读、易写、易更改</em>) 编写文档，并最终以 HTML 格式发布。</p><p><strong>Markdown</strong>也可以理解为将以 Markdown 语法编写的语言转换成 HTML 内容的工具。</p><h2 id="谁创造了它？"><a href="#谁创造了它？" class="headerlink" title="谁创造了它？"></a>谁创造了它？</h2><p>它由<a href="http://www.aaronsw.com/"><strong>Aaron Swartz</strong></a>和<strong>John</strong>共同设计，<strong>Aaron Swartz</strong>就是那位于去年（<em>2013 年 1 月 11 日</em>）自杀，有着<strong>开挂</strong>一般人生经历的程序员。维基百科对他的<a href="http://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8">介绍</a>是：<strong>软件工程师、作家、政治组织者、互联网活动家、维基百科人</strong>。</p><ul><li><strong>14 岁</strong>参与 RSS 1.0 规格标准的制订。</li><li><strong>2004</strong>年入读<strong>斯坦福</strong>，之后退学。</li><li><strong>2005</strong>年创建<a href="http://infogami.org/">Infogami</a>，之后与<a href="http://www.reddit.com/">Reddit</a>合并成为其合伙人。</li><li><strong>2010</strong>年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。</li><li><strong>2011</strong>年 7 月 19 日，因被控从 MIT 和 JSTOR 下载 480 万篇学术论文并以免费形式上传于网络被捕。</li><li><strong>2013</strong>年 1 月自杀身亡。</li></ul><h2 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a>为什么要使用它？</h2><ul><li>它是易读（看起来舒服）、易写（语法简单）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li><li>兼容 HTML，可以转换为 HTML 格式发布。</li><li>跨平台使用。</li><li>越来越多的网站支持 Markdown。</li><li>更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）</li><li>摆脱 Word</li></ul><h2 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h2><p>如果不算<strong>扩展</strong>，Markdown 的语法绝对<strong>简单</strong>到让你爱不释手。</p><p>Markdown 语法主要分为如下几大部分：</p><p><strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，**反斜杠 <code>\</code><strong>，</strong>符号’`’**。</p><h2 id="谁在用？"><a href="#谁在用？" class="headerlink" title="谁在用？"></a>谁在用？</h2><p>Markdown 的使用者：</p><ul><li>GitHub</li><li>简书</li><li>Stack Overflow</li><li>Apollo</li><li>Moodle</li><li>Reddit</li><li>等等</li></ul><h1 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>两种形式：  </p><ol><li><p>使用<code>=</code>和<code>-</code>标记一级和二级标题。</p><blockquote><p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p></blockquote></li><li><p>使用<code>#</code>，可表示 1-6 级标题。</p><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题</p></blockquote></li></ol><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>区块引用需要在被引用的文本前加上 <code>&gt;</code> 符号。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 这是一个区块引用实例，</span><br><br><span class="hljs-quote">&gt; Markdown.</span><br></code></pre></td></tr></table></figure><blockquote><p>这是一个区块引用实例，</p></blockquote><blockquote><p>Markdown.</p></blockquote><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> :</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 平生不会相思，</span><br>才会相思，<br>便害相思。<br><br><span class="hljs-quote">&gt; 空一缕余香在此，</span><br>盼千金游子何之。<br></code></pre></td></tr></table></figure><blockquote><p>平生不会相思，<br>才会相思，<br>便害相思。</p></blockquote><blockquote><p>空一缕余香在此，<br>盼千金游子何之。</p></blockquote><h3 id="引用的多层嵌套"><a href="#引用的多层嵌套" class="headerlink" title="引用的多层嵌套"></a>引用的多层嵌套</h3><p>区块引用可以嵌套（例如：引用内的引用）, 只要根据层次加上不同数量的 <code>&gt;</code> :</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;&gt;&gt; 锄禾日当午，汗滴禾下土。 - 李绅<br><br>&gt;&gt; 山有木兮木有枝，心悦君兮君不知。 - 越人歌<br><br><span class="hljs-quote">&gt; 去年今日此门中，人面桃花相映红。 - 崔护</span><br></code></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>锄禾日当午，汗滴禾下土。 - 李绅</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>山有木兮木有枝，心悦君兮君不知。 - 越人歌</p></blockquote></blockquote><blockquote><p>去年今日此门中，人面桃花相映红。 - 题都城南庄</p></blockquote><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击跳转到指定章节。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">点击跳转至区块引用</span>](<span class="hljs-link">#区块引用</span>)<br></code></pre></td></tr></table></figure><p><a href="#%E5%8C%BA%E5%9D%97%E5%BC%95%E7%94%A8">点击跳转至区块引用</a></p><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>代码区块的建立是在每行加上 4 个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p><p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}</p><p>代码区块：</p><pre><code class="hljs">void main()&#123;    printf(&quot;Hello, Markdown.&quot;);&#125;</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>Markdown 使用星号<code>*</code>和底线<code>_</code>作为标记强调字词的符号。</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*花自飘零水自流*</span><br></code></pre></td></tr></table></figure><blockquote><p><em>花自飘零水自流</em></p></blockquote><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**花自飘零水自流**</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>花自飘零水自流</strong></p></blockquote><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">~~花自飘零水自流~~<br></code></pre></td></tr></table></figure><blockquote><p><del>花自飘零水自流</del></p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p><blockquote><p>-（+*）第一项<br>-（+*）第二项<br>- （+*）第三项</p></blockquote><p><strong>注意</strong>：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>有序列表的标记方式是将上述的符号换成数字，并辅以<code>.</code>，如：</p><blockquote><p>1 . 第一项<br>2 . 第二项<br>3 . 第三项</p></blockquote><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>Markdown 支持两种形式的链接语法：行内式和参考式两种形式，行内式一般使用较多。</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p><code>[]</code>里写链接文字，<code>()</code>里写链接地址，<code>()</code>中的 <code>&quot;&quot;</code> 中可以为链接指定 title 属性，title 属性可加可不加。title 属性的效果是鼠标悬停在链接上会出现指定的 title 文字。<code>[链接文字](链接地址 &quot;链接标题&quot;)</code> 这样的形式。链接地址与链接标题前有一个空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">MPPL: Markdown to PDF with Pandoc via Latex</span>](<span class="hljs-link">https://github.com/Dunky-Z/MPPL</span>)<br>[<span class="hljs-string">MPPL: Markdown to PDF with Pandoc via Latex</span>](<span class="hljs-link">https://github.com/Dunky-Z/MPPL &quot;MPPL&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/Dunky-Z/MPPL">MPPL: Markdown to PDF with Pandoc via Latex</a></p><p><a href="https://github.com/Dunky-Z/MPPL" title="MPPL">MPPL: Markdown to PDF with Pandoc via Latex</a></p></blockquote><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><p>参考式链接分为两部分，文中的写法 <code>[链接文字][链接标记]</code>，在文本的任意位置添加 <code>[链接标记]:链接地址 &quot;链接标题&quot;</code>, 链接地址与链接标题前有一个空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">全球最大的搜索引擎网站是 [<span class="hljs-string">Google</span>][<span class="hljs-symbol">1</span>]。<br><br>[<span class="hljs-symbol">1</span>]:<span class="hljs-link">http://www.google.com &quot;Google&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>全球最大的搜索引擎网站是 <a href="http://www.google.com/" title="Google">Google</a>。<br><br /></p></blockquote><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p><p>语法中图片 Alt 的意思是如果图片因为某些原因不能显示，就用定义的图片 Alt 文字来代替图片。图片 Title 则和链接中的 Title 一样，表示鼠标悬停与图片上时出现的文字。Alt 和 Title 都不是必须的，可以省略，但建议写上。</p><h3 id="图片行内式"><a href="#图片行内式" class="headerlink" title="图片行内式"></a>图片行内式</h3><p><code>![图片 Alt](图片地址 &quot;图片Title&quot;)</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Markdown-mark.svg/2880px-Markdown-mark.svg.png)<br></code></pre></td></tr></table></figure><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Markdown-mark.svg/2880px-Markdown-mark.svg.png"></p><h3 id="图片参考式"><a href="#图片参考式" class="headerlink" title="图片参考式"></a>图片参考式</h3><p>在文档要插入图片的地方写 <code>![图片 Alt][标记]</code>。</p><p>在文档的最后写上 <code>[标记]:图片地址 &quot;Title&quot;</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">MarkdownLogo</span>][<span class="hljs-symbol">MarkdownLogo</span>]<br><br>[<span class="hljs-symbol">MarkdownLogo</span>]:<span class="hljs-link">../img/Markdown-mark.png &quot;MarkdownLogo&quot;</span><br></code></pre></td></tr></table></figure><h2 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠\"></a>反斜杠<code>\</code></h2><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进 (Tab), 另一种是利用 “`” 符号 (一般在 ESC 键下方) 包裹代码。</p><ul><li>插入行内代码，即插入一个单词或者一句代码的情况，使用 `code` 这样的形式插入。</li><li>插入多行代码，可以使用缩进或者 ``` code ```, 具体看示例。</li></ul><h3 id="代码行内式"><a href="#代码行内式" class="headerlink" title="代码行内式"></a>代码行内式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">PHP 打印堆栈信息 <span class="hljs-code">`debug_backtrace()`</span>。<br></code></pre></td></tr></table></figure><blockquote><p>PHP 打印堆栈信息 <code>debug_backtrace()</code>。</p></blockquote><h3 id="缩进式多行代码"><a href="#缩进式多行代码" class="headerlink" title="缩进式多行代码"></a>缩进式多行代码</h3><p>缩进 4 个空格或是 1 个制表符。</p><p>一个代码区块会一直持续到没有缩进的那一行 (或是文件结尾)。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$closure = function () use($name) &#123;<br>  return $name;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">$closure = function () use($name) &#123;  return $name;&#125;</code></pre><h3 id="用六个-包裹多行代码"><a href="#用六个-包裹多行代码" class="headerlink" title="用六个 ` 包裹多行代码"></a>用六个 ` 包裹多行代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; ```c # 为了能够在 Markdown 里演示，所以加了&gt;符号</span><br><span class="hljs-section">#include <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">stdio.h</span>&gt;</span></span></span><br>int main()<br>&#123;<br><span class="hljs-code">    printf(&quot;Hello, World!\n&quot;);</span><br><span class="hljs-code">    return 0;</span><br><span class="hljs-code">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>```c<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ol><li>不管是哪种方式, 第一行为表头, 第二行分隔表头和主体部分, 第三行开始每一行为一个表格行。</li><li>列于列之间用管道符<code>|</code>隔开。原生方式的表格每一行的两边也要有管道符。</li><li>第二行还可以为不同的列指定对齐方向。默认为左对齐, 在<code>-</code>右边加上<code>:</code>就右对齐。</li></ol><p>简单方式:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">诗名|作者|朝代<br>-|-|-<br>白头吟|卓文君|两汉<br>锦瑟|李商隐|唐代<br>登科后|孟郊|唐代<br></code></pre></td></tr></table></figure><table><thead><tr><th>诗名</th><th>作者</th><th>朝代</th></tr></thead><tbody><tr><td>白头吟</td><td>卓文君</td><td>两汉</td></tr><tr><td>锦瑟</td><td>李商隐</td><td>唐代</td></tr><tr><td>登科后</td><td>孟郊</td><td>唐代</td></tr></tbody></table><p>原生方式:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|诗名|作者|朝代|<br>|-|-|-|<br>|白头吟|卓文君|两汉|<br>|锦瑟|李商隐|唐代|<br>|登科后|孟郊|唐代|<br></code></pre></td></tr></table></figure><table><thead><tr><th>诗名</th><th>作者</th><th>朝代</th></tr></thead><tbody><tr><td>白头吟</td><td>卓文君</td><td>两汉</td></tr><tr><td>锦瑟</td><td>李商隐</td><td>唐代</td></tr><tr><td>登科后</td><td>孟郊</td><td>唐代</td></tr></tbody></table><p>为表格第二列指定方向:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">诗名|名句<br>-|-:<br>梦微之|君埋泉下泥销骨。<br>上邪|上邪，我欲与君相知，长命无绝衰。<br></code></pre></td></tr></table></figure><table><thead><tr><th>诗名</th><th align="right">名句</th></tr></thead><tbody><tr><td>梦微之</td><td align="right">君埋泉下泥销骨。</td></tr><tr><td>上邪</td><td align="right">上邪，我欲与君相知，长命无绝衰。</td></tr></tbody></table><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p>在需要添加注脚的文字后加上脚注名字<code>[^注脚名字]</code>, 称为加注。 然后在文本的任意位置(一般在最后)添加脚注, 脚注前必须有对应的脚注名字。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">使用 Markdown[^1] 可以效率的书写文档，直接转换成 HTML[^2]。<br><br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">Markdown 是一种纯文本标记语言</span><br><br>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">HyperText Markup Language 超文本标记语言</span><br></code></pre></td></tr></table></figure><h2 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h2><h3 id="表示行内公式"><a href="#表示行内公式" class="headerlink" title="$ 表示行内公式"></a>$ 表示行内公式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。<br></code></pre></td></tr></table></figure><p>质能守恒方程可以用一个很简洁的方程式$E=mc^2$来表达。</p><h3 id="表示整行公式"><a href="#表示整行公式" class="headerlink" title="$$ 表示整行公式"></a>$$ 表示整行公式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$\sum<span class="hljs-emphasis">_&#123;i=1&#125;^n a_</span>i=0$$<br>$$f(x<span class="hljs-emphasis">_1,x_</span>x,\ldots,x<span class="hljs-emphasis">_n) = x_</span>1^2 + x<span class="hljs-emphasis">_2^2 + \cdots + x_</span>n^2 $$<br>$$\sum^&#123;j-1&#125;<span class="hljs-emphasis">_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_</span>&#123;kj&#125; z<span class="hljs-emphasis">_k&#125;$$</span><br></code></pre></td></tr></table></figure><p>$$\sum_{i=1}^n a_i=0$$</p><h1 id="尝试一下"><a href="#尝试一下" class="headerlink" title="尝试一下"></a>尝试一下</h1><ul><li><strong>Chrome</strong>下的插件诸如<code>stackedit</code>与<code>markdown-here</code>等非常方便，也不用担心平台受限。</li><li><strong>在线</strong>的<a href="https://www.zybuluo.com/mdeditor">Cmd Markdown 编辑阅读器 - 作业部落出品</a>。</li><li><strong>Windowns</strong>下的<a href="https://typora.io/">Typora — a markdown editor, markdown reader</a>。</li><li><strong>Mac</strong>下的 Mou 是国人贡献的，口碑很好。</li><li><strong>Linux</strong>下的 ReText 不错。</li></ul><p><strong>当然，最终境界永远都是笔下是语法，心中格式化。</strong></p><hr><p><strong>注意</strong>：不同的 Markdown 解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。<br>虽然有人想出面搞一个所谓的标准化的 Markdown，<a href="http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/">没想到还惹怒了健在的创始人 John Gruber</a>。</p><hr><p>以上基本是所有 traditonal Markdown 的语法。</p><p>关于其它扩展语法可参见具体工具的使用说明。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://github.com/younghz/Markdown">Markdown 基本语法。</a></li><li><a href="https://github.com/cdoco/markdown-syntax">cdoco/markdown-syntax: Markdown 语法详解。</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 表格竖线自动对齐</title>
    <link href="/2022/09/24/Markdown%E8%A1%A8%E6%A0%BC%E7%AB%96%E7%BA%BF%E8%87%AA%E5%8A%A8%E5%AF%B9%E9%BD%90/"/>
    <url>/2022/09/24/Markdown%E8%A1%A8%E6%A0%BC%E7%AB%96%E7%BA%BF%E8%87%AA%E5%8A%A8%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>Markdown 中的表格，只要符合语法就能够正常渲染显示，但是符合语法但是 Markdown 源码却不一定易读。就如以下的这个表格，可以正常显示，但是源码在源文件中竖线不对齐，就阅读困难。</p><p>源码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|诗名|作者|朝代|<br>|-|-|-|<br>|白头吟|卓文君|两汉|<br>|锦瑟|李商隐|唐代|<br>|登科后|孟郊|唐代|<br></code></pre></td></tr></table></figure><p>显示效果：</p><table><thead><tr><th>诗名</th><th>作者</th><th>朝代</th></tr></thead><tbody><tr><td>白头吟</td><td>卓文君</td><td>两汉</td></tr><tr><td>锦瑟</td><td>李商隐</td><td>唐代</td></tr><tr><td>登科后</td><td>孟郊</td><td>唐代</td></tr></tbody></table><p>我们可以手动将其竖线对齐，如下这样就易读许多：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 诗名   | 作者   | 朝代 |<br>| ------ | ------ | ---- |<br>| 白头吟 | 卓文君 | 两汉 |<br>| 锦瑟   | 李商隐 | 唐代 |<br>| 登科后 | 孟郊   | 唐代 |<br></code></pre></td></tr></table></figure><p>显示效果保持一致。但是如果一个字符一个字符去手动对齐效率太低，也不符合 Markdown 设计初衷。这就用到了额外的插件，能够辅助我们完成这个工作。</p><h2 id="Markdown-All-in-One"><a href="#Markdown-All-in-One" class="headerlink" title="Markdown All in One"></a>Markdown All in One</h2><p>VSCode 插件中心搜索<code>Markdown All in One</code>安装。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/24/fe35a13933da93bba8f234be209bb212.png"></p><p>安装完成后，使用时右击窗口选择<code>Format Document with</code>：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/24/285b770adf0f3b3faff57ee14caca45b.png"></p><p>选择<code>Markdown All in One</code>即可自动对齐所有表格竖线：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/24/313d3b85a4e98be59acc85fc7337d30f.png"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="格式化文档后仍未对齐"><a href="#格式化文档后仍未对齐" class="headerlink" title="格式化文档后仍未对齐"></a>格式化文档后仍未对齐</h3><p>这是由于表格中同时有中英文，而中英文字体不等宽导致的。如果对阅读要求不高，可以不用管，实际上已经格式化完成了。如果需要对齐，那么可以查看<a href="http://lifeislife.cn/2022/08/27/%E7%BC%96%E7%A0%81%E5%AD%97%E4%BD%93%E4%B8%8E%E9%98%85%E8%AF%BB%E5%AD%97%E4%BD%93%E6%8E%A8%E8%8D%90/">编码字体与阅读字体推荐</a>这篇文章的<strong>中文等宽字体</strong>下载并安装，即可正常对齐。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Efficiency</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZH-The RISC-V Instruction Set Manual Volume 2-特权级架构</title>
    <link href="/2022/09/22/ZH-The-RISC-V-Instruction-Set-Manual-Volume-2-%E7%89%B9%E6%9D%83%E7%BA%A7%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/09/22/ZH-The-RISC-V-Instruction-Set-Manual-Volume-2-%E7%89%B9%E6%9D%83%E7%BA%A7%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><blockquote><p>Document Version 20211203</p></blockquote><h1 id="Control-and-Status-Registers-CSRs"><a href="#Control-and-Status-Registers-CSRs" class="headerlink" title="Control and Status Registers (CSRs)"></a>Control and Status Registers (CSRs)</h1><h1 id="Machine-Level-ISA-Version-1-12"><a href="#Machine-Level-ISA-Version-1-12" class="headerlink" title="Machine-Level ISA, Version 1.12"></a>Machine-Level ISA, Version 1.12</h1><p>本章介绍了机器模式（M-mode）中可用的机器级操作，这是 RISC-V 系统中最高权限的模式。M 模式用于对硬件平台的低级访问，是复位时进入的第一个模式。M 模式也可以用来实现那些在硬件中直接实现过于困难或成本高昂的功能。RISC-V 的机器级 ISA 包含一个共同的核心，根据支持的其他权限级别和硬件实现的其他细节来扩展。</p><h2 id="Machine-Level-CSRs"><a href="#Machine-Level-CSRs" class="headerlink" title="Machine-Level CSRs"></a>Machine-Level CSRs</h2><p>除了本节中描述的机器级 CSRs 外，M-mode 代码还可以访问较低特权级别的所有 CSRs。</p><h3 id="Machine-ISA-Register-misa"><a href="#Machine-ISA-Register-misa" class="headerlink" title="Machine ISA Register misa"></a>Machine ISA Register <code>misa</code></h3><p>misa CSR 是 WARL 读写寄存器，报告硬件 (hart) 支持的 ISA。该寄存器在任何实现中都必须是可读的，但是可以返回零值以指示未实现 misa 寄存器，这就需要通过一个单独的非标准机制确定 CPU 功能。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/09-46-18-3adcf70efcc54d501feadc1f1c65d4a7-20220922094617-4dbb38.png" alt="Machine ISA register (misa)" title="Machine ISA register (misa)"></p><p>MXL（机器 XLEN）字段编码本机基本整数 ISA 宽度，如表 3.1 所示。MXL 字段在支持多个基本 ISA 宽度的实现中可能是可写的。M-mode 下的有效 XLEN, MXLEN，由 MXL 的设置给出，如果 misa 为零，则有一个固定的值。重置时，MXL 字段始终设置为最广泛支持的 ISA 变种。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/09-48-01-ae585489a7ae71c6ce5af6303f695dee-20220922094800-db8fc2.png"></p><p>misa CSR 为 MXLEN 位宽。如果从 misa 读取的值不为零，该值的 MXL 字段总是表示当前的 MXLEN。如果对 misa 的写操作导致 MXLEN 发生更改，则 MXL 的位置将以新的宽度移动到 misa 的最高有效两位。</p><blockquote><p>可以使用返回的 misa 值的符号上的分支，以及可能在符号上左移一个分支和第二个分支，来快速确定基本宽度。这些检查可以用汇编代码编写，而无需知道机器的寄存器宽度（XLEN）。基本宽度由 XLEN = 2^(MXL + 4) 给出。如果 misa 为零，则可以通过将立即数 4 放置在一个寄存器中，然后一次将寄存器左移 31 位来找到基本宽度。如果在一次移位后为零，则该机器为 RV32。如果两次移位后为零，则机器为 RV64，否则为 RV128。</p></blockquote><p>Extensions 字段编码了目前存有的标准扩展，其每个 bit 都对应了字母表中的一个字母（bit 0 编码扩展“A”是否存在，bit 1 编码扩展“B”是否存在… 直至 bit 25 编码“Z”）。如果基础 ISA 是 RV32I、RV64I 或 RV128I，则置位“I”bit，否则如果基础 ISA 是 RV32E，则置位“E”bit。</p><p>Extensions 字段是一个能包含可写位的 WARL 字段（如果实现允许修改所支持的 ISA）。</p><p>复位（reset）时，Extensions 应包含所支持扩展的最大集，如果 E 和 I 都可用，则优先选择 I。</p><p>在通过清除 misa 中相应 bit 来禁止一个标准扩展时，由该扩展所定义或修改的指令和 CSR 将恢复为该扩展未实现时的定义，或者保留行为（revert to their defined or reserved behaviors as if the extension is not implemented）。</p><p>RV128 base ISA 的设计尚未完工，尽管预计本 specification 中大部分的剩余部分都将适用于 RV128，但本版本的文档仅关注 RV32 和 RV64。</p><p>如果支持用户模式（user mode），则将“U”bit 置位；如果支持主管模式（supervisor mode），则将“S”bit 置位。</p><p>如果存在任何非标准扩展（non-standard extensions），则将“X”bit 置位。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/09-53-13-08dc73aa464b15f2ff11a17cbb97bf1b-20220922095312-f997d1.png"></p><p>“E”位是只读的。除非将 misa 硬连线为零，否则“E”位始终读取为“I”位的补码（补集？）。同时支持 RV32E 和 RV32I 的实现可以通过清除“I”位来选择 RV32E。</p><p>如果 ISA 功能 x 依赖 ISA 功能 y，则尝试启用功能 x 但禁用功能 y 会导致两个功能都被禁用。例如，设置“F” = 0 和“D” = 1 会导致同时清除“F”和“D”。</p><p>具体实现可能会在 2 或多个 misa 字段的集体设置上施加额外约束，此时将它们的集体看作是一个 WARL 字段。试图向其中写入一个不支持的组合会导致这些 bits 被置为某个支持的组合。</p><p>写 misa 可能会增加 IALIGN，例如，通过禁用 C 扩展。如果要写入 misa 的指令增加了 IALIGN，而后一条指令的地址未按 IALIGN 位对齐，则将抑制对 misa 的写入，从而使 misa 保持不变。</p><p>在软件启用一个之前被禁用的扩展时，除该扩展另有规定（specified），否则所有单独与该扩展有关的状态都将是未指定的（unspecified）。</p><h3 id="Machine-Vendor-ID-Register-mvendorid"><a href="#Machine-Vendor-ID-Register-mvendorid" class="headerlink" title="Machine Vendor ID Register mvendorid"></a>Machine Vendor ID Register <code>mvendorid</code></h3><p><code>mvendorid</code> CSR 是一个 32 位只读寄存器，提供内核供应商的 JEDEC 制造商 ID。此寄存器在任何实现中都必须是可读的，但可以返回 0，表示该字段未实现或这是非商业实现。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-57-22-3e72021562b198d643d3f62e08cb528c-20220923155721-b7ba3c.png" alt="厂商 ID 寄存器 mvendorid" title="厂商ID寄存器 mvendorid"></p><p>JEDEC 制造商 ID 通常编码为单字节连续的 <code>0x7f</code> 代码的序列，以不等于 <code>0x7f</code> 的单字节 ID 终止，并且在每个字节的最高有效位中带有奇校验位。<code>mvendorid</code> 在 Bank 字段中编码单字节的连续代码，并在 <code>Offset</code> 字段中编码最后一个字节，丢弃奇偶校验位。例如，JEDEC 制造商 ID <code>0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x8a</code>（十二个连续代码，后跟 0x8a）将在 mvendorid 字段中编码为 <code>0x60a</code>。</p><blockquote><p>译者注：JEDEC 固态技术协会（JEDEC Solid State Technology Association）是固态及半导体工业界的一个标准化组织，它由约 300 家公司成员组成，约 3300 名技术人员通过 50 个不同的委员会运作，制定固态电子方面的工业标准。JEDEC 曾经是电子工业联盟（EIA）的一部分：联合电子设备工程委员会（Joint Electron Device Engineering Council，JEDEC）。该协会制定了一个制造商标识码的标准：<a href="http://www.softnology.biz/pdf/JEP106AV.pdf">Standard Manufacturer’s Identification Code</a>，通过读取<code>mvendorid</code>寄存器值，查阅该标准即可确定制造商。</p></blockquote><blockquote><p>注：用 JEDEC 的话来说，Bank 编号比 Continuation 的数量大 1；因此，mvendorid Bank 字段编码的值比 JEDEC Bank 编号小一。</p></blockquote><blockquote><p>注：以前，供应商 ID 是 RISC-V 基金会分配的编号，但这与 JEDEC 在维护制造商 ID 标准方面的工作重复。在撰写本文时，向 JEDEC 注册制造商 ID 的一次性费用为 500 美元。</p></blockquote><h2 id="Machine-Mode-Privileged-Instructions"><a href="#Machine-Mode-Privileged-Instructions" class="headerlink" title="Machine-Mode Privileged Instructions"></a>Machine-Mode Privileged Instructions</h2><h3 id="Environment-Call-and-Breakpoint"><a href="#Environment-Call-and-Breakpoint" class="headerlink" title="Environment Call and Breakpoint"></a>Environment Call and Breakpoint</h3><h3 id="Trap-Return-Instructions"><a href="#Trap-Return-Instructions" class="headerlink" title="Trap-Return Instructions"></a>Trap-Return Instructions</h3><h3 id="Wait-for-Interrupt"><a href="#Wait-for-Interrupt" class="headerlink" title="Wait for Interrupt"></a>Wait for Interrupt</h3><p>等待中断指令 (WFI) 为实现提供了一个提示，即当前的 hart 可以停止，直到需要服务中断。WFI 指令的执行也可以用来通知硬件平台合适的中断应该优先路由到这个 hart。WFI 在所有特权模式下都可用，并且可用于 U 模式 (可选地)。当 mstatus 中的 TW = 1 时，该指令可能会引发非法指令异常，如第 3.1.6.5 节所述。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/14-14-09-54056c2dced29063e3b293c127d49fe0-20220922141408-cb2444.png"></p><p>如果在 hart 停止时存在或稍后出现启用的中断，则中断 trap 将在以下指令上执行，即在 trap 处理程序中恢复执行并且 <code>mepc = pc + 4</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>Translation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Markdownlint 对 Markdown 文本格式检查</title>
    <link href="/2022/09/17/%E4%BD%BF%E7%94%A8Markdownlint%E5%AF%B9Markdown%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5/"/>
    <url>/2022/09/17/%E4%BD%BF%E7%94%A8Markdownlint%E5%AF%B9Markdown%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdownlint-简介"><a href="#Markdownlint-简介" class="headerlink" title="Markdownlint 简介"></a>Markdownlint 简介</h1><p>Markdown 标记语言旨在易于阅读、编写和理解。它的灵活性既是优点也是缺点。语法众多，因此格式可能不一致。某些构造在所有解析器中都不能很好地工作，应该避免。CommonMark 规范标准化解析器。</p><p>Markdownlint 是一个用于 Node.js 的静态分析工具，有一个标准规范，用于强制执行 Markdown 文件的标准和一致性。</p><h1 id="Markdownlint-插件使用"><a href="#Markdownlint-插件使用" class="headerlink" title="Markdownlint 插件使用"></a>Markdownlint 插件使用</h1><p><a href="https://github.com/DavidAnson/markdownlint">markdownlint</a>提供了多种使用场景下的解决方案，如命令行，编辑器甚至 GitHub Action。因为我平时写 Markdown 文档都是使用 VSCode，所以介绍一下 VSCode 下的使用。其他编辑器包括 VIM，Sublime 也都支持，可以前往官网查阅方法。</p><p>VSCode 需要下载插件，<code>Ctrl+Shift+X</code>打开插件中心，搜索<strong>Markdownlint</strong>安装即可。</p><p>安装插件后打开 Markdown 文档，如果有不符合规范的语法将会警告标识。如，标题前后没有空行，将会标识：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/17/fbd7a1e70279b69efdfb5cd6d8120b7a.png"></p><p>提示违反了第 22 条规范，第 22 条规范的就是标题前后需要有空行隔开。</p><p>目前有 53 条规范，可以在<a href="https://github.com/DavidAnson/markdownlint/blob/main/doc/Rules.md#md001">markdownlint/Rules.md</a>查看所有规范的内容。</p><p>当然这些规范也都可以自定义是否检查，比如第 24 条规定，文档内不可以有重复的标题，但是我就有重复标题的需求，那该如何关闭这个检查呢，Markdownlint 提供了配置的方式。</p><p><code>Ctrl+Shift+P</code>打开运行窗口，输入 Markdownlint，找到<code>Creat or open the markdownlint configuration file</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/17/acc1dc59b5cb82261007e9fe72fccdc9.png"></p><p>创建一个配置文件，并输入以下内容，表示关闭第 24 条规范的检查：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;MD024&quot;</span>: <span class="hljs-literal">false</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>这样文档中将不会有第 24 条规范的检查警告，其他检查同理。</p><h1 id="Markdownlint-自定义规则"><a href="#Markdownlint-自定义规则" class="headerlink" title="Markdownlint 自定义规则"></a>Markdownlint 自定义规则</h1><h2 id="MD001-Heading-levels-should-only-increment-by-one-level-at-a-time"><a href="#MD001-Heading-levels-should-only-increment-by-one-level-at-a-time" class="headerlink" title="MD001 - Heading levels should only increment by one level at a time"></a>MD001 - Heading levels should only increment by one level at a time</h2><p>标题等级一次只能增加一级，不能跨级。</p><p>原理：标题代表文档的结构，跳过时可能会造成混淆 - 特别是对于可访问性场景。</p><h2 id="MD002-First-heading-should-be-a-top-level-heading"><a href="#MD002-First-heading-should-be-a-top-level-heading" class="headerlink" title="MD002 - First heading should be a top-level heading"></a><del>MD002 - First heading should be a top-level heading</del></h2><p>文档的第一个标题必须是最高级的标题（标题等级 1 级到 6 级逐渐降低）</p><h2 id="MD003-Heading-style"><a href="#MD003-Heading-style" class="headerlink" title="MD003 - Heading style"></a>MD003 - Heading style</h2><p>整篇文档需要采用一致的标题格式。</p><h2 id="MD004-Unordered-list-style"><a href="#MD004-Unordered-list-style" class="headerlink" title="MD004 - Unordered list style"></a>MD004 - Unordered list style</h2><p>无序列表格式需要一致。</p><h2 id="MD005-Inconsistent-indentation-for-list-items-at-the-same-level"><a href="#MD005-Inconsistent-indentation-for-list-items-at-the-same-level" class="headerlink" title="MD005 - Inconsistent indentation for list items at the same level"></a>MD005 - Inconsistent indentation for list items at the same level</h2><ul><li>同一级的列表缩进必须一致</li><li>在有序列表中，前面的数字序号可以左对齐，也可以右对齐</li></ul><h2 id="MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line"><a href="#MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line" class="headerlink" title="MD006 - Consider starting bulleted lists at the beginning of the line"></a><del>MD006 - Consider starting bulleted lists at the beginning of the line</del></h2><p>一级列表不能缩进。</p><p>如下为报错：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Some text<br><br><span class="hljs-bullet">  *</span> List item<br><span class="hljs-bullet">  *</span> List item<br></code></pre></td></tr></table></figure><h2 id="MD007-Unordered-list-indentation"><a href="#MD007-Unordered-list-indentation" class="headerlink" title="MD007 - Unordered list indentation"></a>MD007 - Unordered list indentation</h2><p>无序列表嵌套缩进时默认采用两个空格。</p><h2 id="MD009-Trailing-spaces"><a href="#MD009-Trailing-spaces" class="headerlink" title="MD009 - Trailing spaces"></a>MD009 - Trailing spaces</h2><p>行尾最多可以添加两个空格，超过会给出警告，两个空格正好可以用于换行。</p><h2 id="MD010-Hard-tabs"><a href="#MD010-Hard-tabs" class="headerlink" title="MD010 - Hard tabs"></a>MD010 - Hard tabs</h2><p>不能使用 tab 键缩进，要使用空格。</p><p>原理：硬制表符通常由不同的编辑器以不一致的方式呈现，并且比空格更难处理。</p><h2 id="MD011-Reversed-link-syntax"><a href="#MD011-Reversed-link-syntax" class="headerlink" title="MD011 - Reversed link syntax"></a>MD011 - Reversed link syntax</h2><p>当遇到看似链接的文本，但语法似乎已反转（[] 和 () 反转）时，将触发此规则。</p><h2 id="MD012-Multiple-consecutive-blank-lines"><a href="#MD012-Multiple-consecutive-blank-lines" class="headerlink" title="MD012 - Multiple consecutive blank lines"></a>MD012 - Multiple consecutive blank lines</h2><p>文档中不能有连续的空行，在代码块中此规则不会生效。</p><h2 id="MD013-Line-length"><a href="#MD013-Line-length" class="headerlink" title="MD013 - Line length"></a>MD013 - Line length</h2><p>默认行的最大长度是 80，此规则对代码块、表格、标题也生效。</p><h2 id="MD014-Dollar-signs-used-before-commands-without-showing-output"><a href="#MD014-Dollar-signs-used-before-commands-without-showing-output" class="headerlink" title="MD014 - Dollar signs used before commands without showing output"></a>MD014 - Dollar signs used before commands without showing output</h2><p>在代码块中，终端命令前不需要有美元符号 ($)<br>如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号 ($)。</p><h2 id="MD018-No-space-after-hash-on-atx-style-heading"><a href="#MD018-No-space-after-hash-on-atx-style-heading" class="headerlink" title="MD018 - No space after hash on atx style heading"></a>MD018 - No space after hash on atx style heading</h2><p>在”atx”格式的标题中，<code>#</code>号和文字间需用一个空格隔开。</p><h2 id="MD019-Multiple-spaces-after-hash-on-atx-style-heading"><a href="#MD019-Multiple-spaces-after-hash-on-atx-style-heading" class="headerlink" title="MD019 - Multiple spaces after hash on atx style heading"></a>MD019 - Multiple spaces after hash on atx style heading</h2><p>在”atx”格式的标题中，#号和文字间只能用一个空格隔开，不能有多余的空格。</p><h2 id="MD020-No-space-inside-hashes-on-closed-atx-style-heading"><a href="#MD020-No-space-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD020 - No space inside hashes on closed atx style heading"></a>MD020 - No space inside hashes on closed atx style heading</h2><p>在”closed_atx”格式的标题中，文字和前后的#号之间需用一个空格隔开。</p><h2 id="MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading"><a href="#MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD021 - Multiple spaces inside hashes on closed atx style heading"></a>MD021 - Multiple spaces inside hashes on closed atx style heading</h2><p>在”closed_atx”格式的标题中，文字和前后的#号之间只能用一个空格隔开，不能有多余的空格。</p><h2 id="MD022-Headings-should-be-surrounded-by-blank-lines"><a href="#MD022-Headings-should-be-surrounded-by-blank-lines" class="headerlink" title="MD022 - Headings should be surrounded by blank lines"></a>MD022 - Headings should be surrounded by blank lines</h2><p>标题行的上下行必须都是空行。</p><h2 id="MD023-Headings-must-start-at-the-beginning-of-the-line"><a href="#MD023-Headings-must-start-at-the-beginning-of-the-line" class="headerlink" title="MD023 - Headings must start at the beginning of the line"></a>MD023 - Headings must start at the beginning of the line</h2><p>标题行不能缩进。</p><h2 id="MD024-Multiple-headings-with-the-same-content"><a href="#MD024-Multiple-headings-with-the-same-content" class="headerlink" title="MD024 - Multiple headings with the same content"></a>MD024 - Multiple headings with the same content</h2><p>文档不能有内容重复的标题。</p><h2 id="MD025-Multiple-top-level-headings-in-the-same-document"><a href="#MD025-Multiple-top-level-headings-in-the-same-document" class="headerlink" title="MD025 - Multiple top-level headings in the same document"></a>MD025 - Multiple top-level headings in the same document</h2><p>同一文档只能有一个最高级的标题，默认是只能有一个 1 级标题。</p><h2 id="MD026-Trailing-punctuation-in-heading"><a href="#MD026-Trailing-punctuation-in-heading" class="headerlink" title="MD026 - Trailing punctuation in heading"></a>MD026 - Trailing punctuation in heading</h2><p>标题行末尾不能有以下标点符号。</p><h2 id="MD027-Multiple-spaces-after-blockquote-symbol"><a href="#MD027-Multiple-spaces-after-blockquote-symbol" class="headerlink" title="MD027 - Multiple spaces after blockquote symbol"></a>MD027 - Multiple spaces after blockquote symbol</h2><p>创建引用区块时，右尖括号 ( &gt; ) 和文字之间有且只能有一个空格。</p><h2 id="MD028-Blank-line-inside-blockquote"><a href="#MD028-Blank-line-inside-blockquote" class="headerlink" title="MD028 - Blank line inside blockquote"></a>MD028 - Blank line inside blockquote</h2><p>两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用&gt;开头。</p><h2 id="MD029-Ordered-list-item-prefix"><a href="#MD029-Ordered-list-item-prefix" class="headerlink" title="MD029 - Ordered list item prefix"></a>MD029 - Ordered list item prefix</h2><p>有序列表的前缀序号格式必须只用 1 或者从 1 开始的加 1 递增数字。</p><h2 id="MD030-Spaces-after-list-markers"><a href="#MD030-Spaces-after-list-markers" class="headerlink" title="MD030 - Spaces after list markers"></a>MD030 - Spaces after list markers</h2><p>列表（有序、无序）的前缀符号和文字之间用 1 个空格隔开<br>在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进 3 个空格。</p><h2 id="MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines"><a href="#MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines" class="headerlink" title="MD031 - Fenced code blocks should be surrounded by blank lines"></a>MD031 - Fenced code blocks should be surrounded by blank lines</h2><p>单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块</p><h2 id="MD032-Lists-should-be-surrounded-by-blank-lines"><a href="#MD032-Lists-should-be-surrounded-by-blank-lines" class="headerlink" title="MD032 - Lists should be surrounded by blank lines"></a>MD032 - Lists should be surrounded by blank lines</h2><p>列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表。</p><p>列表的缩进必须一致。</p><h2 id="MD033-Inline-HTML"><a href="#MD033-Inline-HTML" class="headerlink" title="MD033 - Inline HTML"></a>MD033 - Inline HTML</h2><p>文档中不允许使用 HTML 语句。</p><h2 id="MD034-Bare-URL-used"><a href="#MD034-Bare-URL-used" class="headerlink" title="MD034 - Bare URL used"></a>MD034 - Bare URL used</h2><p>单纯的链接地址需要用尖括号 (&lt;&gt;) 包裹，否则有些解释器不会解释为链接。</p><h2 id="MD035-Horizontal-rule-style"><a href="#MD035-Horizontal-rule-style" class="headerlink" title="MD035 - Horizontal rule style"></a>MD035 - Horizontal rule style</h2><p>创建水平线时整篇文档要统一 (consistent)，要和文档中第一次创建水平线使用的符号一致。</p><h2 id="MD036-Emphasis-used-instead-of-a-heading"><a href="#MD036-Emphasis-used-instead-of-a-heading" class="headerlink" title="MD036 - Emphasis used instead of a heading"></a>MD036 - Emphasis used instead of a heading</h2><p>不能用加粗代替标题。</p><h2 id="MD037-Spaces-inside-emphasis-markers"><a href="#MD037-Spaces-inside-emphasis-markers" class="headerlink" title="MD037 - Spaces inside emphasis markers"></a>MD037 - Spaces inside emphasis markers</h2><p>用于创建强调的符号和强调的的文字之间不能有空格。</p><h2 id="MD038-Spaces-inside-code-span-elements"><a href="#MD038-Spaces-inside-code-span-elements" class="headerlink" title="MD038 - Spaces inside code span elements"></a>MD038 - Spaces inside code span elements</h2><p>当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格<br>如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开。</p><h2 id="MD039-Spaces-inside-link-text"><a href="#MD039-Spaces-inside-link-text" class="headerlink" title="MD039 - Spaces inside link text"></a>MD039 - Spaces inside link text</h2><p>链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格。</p><h2 id="MD040-Fenced-code-blocks-should-have-a-language-specified"><a href="#MD040-Fenced-code-blocks-should-have-a-language-specified" class="headerlink" title="MD040 - Fenced code blocks should have a language specified"></a>MD040 - Fenced code blocks should have a language specified</h2><p>单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮。</p><h2 id="MD041-First-line-in-a-file-should-be-a-top-level-heading"><a href="#MD041-First-line-in-a-file-should-be-a-top-level-heading" class="headerlink" title="MD041 - First line in a file should be a top-level heading"></a>MD041 - First line in a file should be a top-level heading</h2><p>文档的第一个非空行应该是文档最高级的标题，默认是 1 级标题。</p><h2 id="MD042-No-empty-links"><a href="#MD042-No-empty-links" class="headerlink" title="MD042 - No empty links"></a>MD042 - No empty links</h2><p>链接的地址不能为空。</p><h2 id="MD043-Required-heading-structure"><a href="#MD043-Required-heading-structure" class="headerlink" title="MD043 - Required heading structure"></a>MD043 - Required heading structure</h2><p>要求标题遵循一定的结构，默认是没有规定的结构。</p><h2 id="MD044-Proper-names-should-have-the-correct-capitalization"><a href="#MD044-Proper-names-should-have-the-correct-capitalization" class="headerlink" title="MD044 - Proper names should have the correct capitalization"></a>MD044 - Proper names should have the correct capitalization</h2><p>指定一些名称，会检查它是否有正确的大写。</p><h2 id="MD045-Images-should-have-alternate-text-alt-text"><a href="#MD045-Images-should-have-alternate-text-alt-text" class="headerlink" title="MD045 - Images should have alternate text (alt text)"></a>MD045 - Images should have alternate text (alt text)</h2><p>图片链接必须包含描述文本（alt text）。</p><h2 id="MD046-Code-block-style"><a href="#MD046-Code-block-style" class="headerlink" title="MD046 - Code block style"></a>MD046 - Code block style</h2><p>整篇文档采用一致的代码格式。</p><h2 id="MD047-Files-should-end-with-a-single-newline-character"><a href="#MD047-Files-should-end-with-a-single-newline-character" class="headerlink" title="MD047 - Files should end with a single newline character"></a>MD047 - Files should end with a single newline character</h2><p>文档需用一个空行结尾。</p><h2 id="MD048-Code-fence-style"><a href="#MD048-Code-fence-style" class="headerlink" title="MD048 - Code fence style"></a>MD048 - Code fence style</h2><p>表示代码块的标记需要一直，可以是波浪号，也可以是点号。但是需要保持一致。</p><h2 id="MD049-Emphasis-style-should-be-consistent"><a href="#MD049-Emphasis-style-should-be-consistent" class="headerlink" title="MD049 - Emphasis style should be consistent"></a>MD049 - Emphasis style should be consistent</h2><p>强调符号需要一直，如斜体。</p><h2 id="MD050-Strong-style-should-be-consistent"><a href="#MD050-Strong-style-should-be-consistent" class="headerlink" title="MD050 - Strong style should be consistent"></a>MD050 - Strong style should be consistent</h2><p>加粗符号需要保持一致。</p><h2 id="MD051-Link-fragments-should-be-valid"><a href="#MD051-Link-fragments-should-be-valid" class="headerlink" title="MD051 - Link fragments should be valid"></a>MD051 - Link fragments should be valid</h2><p>锚点需要表示正确。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Efficiency</tag>
      
      <tag>Markdown</tag>
      
      <tag>插件</tag>
      
      <tag>推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 字体快速切换</title>
    <link href="/2022/09/12/VSCode%E5%AD%97%E4%BD%93%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2/"/>
    <url>/2022/09/12/VSCode%E5%AD%97%E4%BD%93%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>在写 MD 文档时为了追求美观，表格通常都是对齐的，这就需要字体必须等宽，但是写代码时等宽字体的因为很瘦小，不容易阅读，所以想要一个插件能够在多个字体直接快速切换。万能 VSCode 啥都有，插件中心就有一款专门切换字体的插件<code>Font Switcher</code>。直接搜索安装。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/15-09-47-3c903030ae9986896c2e4c2537c77f57-20220912150947-77eec8.png"></p><h2 id="配置与使用"><a href="#配置与使用" class="headerlink" title="配置与使用"></a>配置与使用</h2><p>打开配置脚本<code>settings.json</code>，如果以前修改过字体，找到<code>&quot;editor.fontFamily&quot;</code>配置项，如果没有就直接添加。</p><p>这是我的字体，添加你们机器上安装的字体，每个逗号间隔都是不同的字体，可以使用<code>Font Switcher</code>切换，需要注意的是，<strong>字体名没有空格不需要加单引号，加了也无妨，如果有空格，一定要加引号</strong>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;editor.fontFamily&quot;</span>: <span class="hljs-string">&quot;&#x27;Sarasa Mono SC&#x27;, 微软雅黑，&#x27;Noto Sans Mono CJK SC&#x27;, &#x27;JetBrains Mono&#x27;, Consolas, monospace&quot;</span>,<br></code></pre></td></tr></table></figure><p><code>Ctrl+Shift+P</code>打开运行窗口，输入<code>Switch Font</code>，选择切换的字体。如图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/dd742307432154f630585e05a1f57956.gif"></p><p>![](<a href="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/15-17-44-dd742307432154f630585e05a1f57956-GIF">https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/15-17-44-dd742307432154f630585e05a1f57956-GIF</a> 2022-9-12 15-17-27-836285.gif)</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Efficiency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Linux 终端回车键变成字符 M</title>
    <link href="/2022/09/12/%E8%A7%A3%E5%86%B3Linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E9%94%AE%E5%8F%98%E6%88%90%E5%AD%97%E7%AC%A6M/"/>
    <url>/2022/09/12/%E8%A7%A3%E5%86%B3Linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E9%94%AE%E5%8F%98%E6%88%90%E5%AD%97%E7%AC%A6M/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/14-49-58-a6e2e264bfab205e0838ad8e49adec81-20220912144956-12eead.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>命令行执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">stty sane<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下切换 Python 版本</title>
    <link href="/2022/09/12/%E8%A7%A3%E5%86%B3Linux%E4%B8%8B%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC/"/>
    <url>/2022/09/12/%E8%A7%A3%E5%86%B3Linux%E4%B8%8B%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>用过 Python 的都知道，Python 是不向后兼容的，也就是 Python3.X 开发的程序，使用 Python2.X 环境就无法正常运行。因为很多语法都改变了。现在接触到的大部分 Python 程序都是 Python3.X 开发的，但是偶尔也会遇到使用 Python2.X 的时候。这就需要灵活切换版本。</p><p>一般 Linux 的各个发行版都预装了 Python2.X。我使用的 Debian 就预装了 Python2.7。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python -V<br>Python 2.7.16<br></code></pre></td></tr></table></figure><p>但是我同时也安装了 Python3.7</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls /usr/bin | grep <span class="hljs-string">&quot;python*&quot;</span><br>dh_python2<br>python<br>python2<br>python2.7<br>python3<br>python3.7<br>python3.7m<br>python3m<br></code></pre></td></tr></table></figure><h2 id="alias-修改别名"><a href="#alias-修改别名" class="headerlink" title="alias 修改别名"></a>alias 修改别名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">alias</span> python=/usr/bin/python3<br>$ python -V<br>Python 3.7.3  <br></code></pre></td></tr></table></figure><p>上面的别名修改只对当前终端有效。如果要使每个窗口都使用这个别名，将别名加入<code>~/.bashrc</code>，如 zsh 是则是<code>~/.zshrc</code>。</p><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>和修改别名类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s python /usr/bin/python3<br></code></pre></td></tr></table></figure><h2 id="update-alternatives"><a href="#update-alternatives" class="headerlink" title="update-alternatives"></a>update-alternatives</h2><p><code>update-alternatives</code>是 Debian 系统提供的一个工具，Ubuntu 是基于 Debian 的，所以 Ubuntu 也可以使用，其他发行版没有该工具。它可以用来方便快捷地切换应用版本，不仅仅用来切换 Python，其他应用程序有多个版本的也可以使用该工具。</p><p><code>update-alternatives</code>本质也是建立软链接，只不过有了统一的管理，首先我们需要使用<code>--install</code>参数，添加一些候选项，也就是执行<code>python</code>这个命令时，它可以有哪些选择，在这里就是<code>python3.7.3</code>和<code>python2.7.16</code>两个选择。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># --install &lt;链接&gt; &lt;名称&gt; &lt;路径&gt; &lt;优先级&gt;</span><br>sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2<br>sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.7 1<br></code></pre></td></tr></table></figure><p><strong>注意</strong>，这里的<code>/usr/bin/python</code>链接文件，两个可选项必须是一样的，这样这个链接文件才可以选择两个不同的可选项去链接。</p><p><code>python</code>是在命令行执行的命令。<code>/usr/bin/python2.7</code>是执行<code>python</code>命令后调用具体哪个版本。最后的数字<code>2</code>是优先级，也就是<code>python2.7</code>比<code>python3.7</code>优先级高，如果不指定版本，那么默认就是使用<code>python2</code>。</p><p>我们再查看一下版本信息，发现是<code>python2.7.16</code>。说明是默认版本。并且<code>python</code>已被链接到我们管理的软链接上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python -V<br>Python 2.7.16<br><br>$ ll /usr/bin  | grep <span class="hljs-string">&quot;python&quot;</span><br>lrwxrwxrwx 1 root   python -&gt; /etc/alternatives/python<br></code></pre></td></tr></table></figure><p>查看<code>python</code>的可选配置，可以看到有两个可选配置，默认是<code>python2</code>，第一列是序号，如果我们想切换到<code>python3</code>，对应的数字<code>2</code>即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">root at RISCX <span class="hljs-keyword">in</span> ~<br>$ update-alternatives --config python<br>There are 2 choices <span class="hljs-keyword">for</span> the alternative python (providing /usr/bin/python).<br><br>  Selection    Path                Priority   Status<br>------------------------------------------------------------<br>* 0            /usr/bin/python2.7   2         auto mode<br>  1            /usr/bin/python2.7   2         manual mode<br>  2            /usr/bin/python3.7   1         manual mode<br><br>Press &lt;enter&gt; to keep the current choice[*], or <span class="hljs-built_in">type</span> selection number:2<br>update-alternatives: using /usr/bin/python3.7 to provide /usr/bin/python (python) <span class="hljs-keyword">in</span> manual mode<br></code></pre></td></tr></table></figure><p>再次查看版本信息，发现已经切换成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python -V<br>Python 3.7.3<br></code></pre></td></tr></table></figure><blockquote><p>执行<code>update-alternatives</code>经常会导致我的终端<strong>回车失效</strong>，可以参考<a href="https://dunky-z.github.io/2022/09/12/%E8%A7%A3%E5%86%B3Linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E9%94%AE%E5%8F%98%E6%88%90%E5%AD%97%E7%AC%A6M/">解决 Linux 终端回车键变成字符 M</a></p></blockquote><p><code>--remove</code>，删除可选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-alternatives --remove python /usr/bin/python2.7<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Python</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Python No module named &#39;ConfigParser&#39;</title>
    <link href="/2022/09/11/%E8%A7%A3%E5%86%B3Python-No-module-named-ConfigParser/"/>
    <url>/2022/09/11/%E8%A7%A3%E5%86%B3Python-No-module-named-ConfigParser/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ImportError: No module named <span class="hljs-string">&#x27;ConfigParser&#x27;</span><br><br>Command <span class="hljs-string">&quot;python setup.py egg_info&quot;</span> failed with error code 1 <span class="hljs-keyword">in</span><br></code></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在 Python 3.x 版本后，<code>ConfigParser.py</code> 已经更名为 <code>configparser.py</code> 所以出错！</p><p>可以切换 Python2 执行。</p><p>也可以尝试将文件重命名为<code>ConfigParser.py</code>。</p><p>以下为参考，每个人安装路径可能不一样，可以全局搜索<code>configparser.py</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp /usr/lib/python3.7/configparser.py /usr/lib/python3.7/ConfigParser.py<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 LaTeX 编译 Missing character There is no (U+00A0) in font</title>
    <link href="/2022/09/11/%E8%A7%A3%E5%86%B3LaTex%E7%BC%96%E8%AF%91Missing-character-There-is-no-U-00A0-U-00A0-in-font/"/>
    <url>/2022/09/11/%E8%A7%A3%E5%86%B3LaTex%E7%BC%96%E8%AF%91Missing-character-There-is-no-U-00A0-U-00A0-in-font/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>在 LaTeX 编译中报错：Missing character: There is no   (U+00A0) (U+00A0) in font JetBrains Mono。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>如果要搞清楚具体原因，就得从字符与字符编码说起了。解决办法直接跳到下一节吧。</p><p><strong>字符</strong>，就是“a”，“A”，“你”等书写符号。</p><p><strong>字符集</strong>，通常就是某种语言字符集合，比如英语就是<strong>ASCII 字符集</strong>，中文有<strong>GBK 字符集</strong>等</p><blockquote><p>注意，不是每种语言只对应一种字符集（比如 GB2312，GBK，GB18030 都包含了常用汉字，后者是前者的超集），而且字符集也不是只对应一种语言，例如 Unicode 字符集就包含所有语言字符，字符集只是设计者为了给字符编码（Code Point/Numbering）设计编码时，为了收录到命名的字符集合，但是通常设计者都为字符集设计了对应的编码规范。</p></blockquote><p><strong>字符编码</strong>,给字符集里的字符编号。</p><p><strong>编码页</strong>，在 unicode 发明之前，各个地区都用 2 字节编码自己的字符集，相同的编码对应不同的字符，为了本地化，Windows 发明了编码页，来对应不同的字符集。</p><p><strong>字符编码</strong>，对给定的字符编码编码成字节表示。</p><blockquote><p>早期，字符被编号后，存储时就按照编号的方式存储，没有 encoding 的过程，后来发明 Unicode 后，发现如果按照 Unicode 的编号直接存储的话，对于英文字符就有很大存储浪费，因为任意字符都需要 2 字节存储，后来人们发明 UTF-8 这种编码方式，这样 UTF-8 就可以一个字节表示英文字符，2 个以上字节表示汉字字符。</p></blockquote><p><strong>字体</strong>，定义了字符的图形表示，现在的软件展示字符时用 Unicode 表示，字体是 Unicode 编码和字符图形的映射，而以往比如 WindowsCMD 控制台，没有对应 Unicode，则用编码页来区分，所以字体就是字符编码金和代码页到字符图形的映射。</p><p>文本文件存储在磁盘上，都是一系列的字节流，如果不告诉文本编辑器该文件的编码方式，编辑器会尝试用默认的编码（依赖于操作系统设置）又或者自己探测（detect，比如文件开头有 FFEF 或者 EFFF 字节就表明 UTF-16 编码，有很多 10，110 开头的字节，很可能是 UTF-8 编码）并尝试解码，<strong>如果没有猜对，那就会显示乱码</strong>。</p><p>回到出错的问题，提示我们在<strong>字体 JetBrains Mono</strong>中没有<strong>U+00A0</strong>，我们搜索一下就知道这是一个 Unicode 字符<strong>NO-BREAK SPACE</strong>。我们通过上面的了解也知道了，字体就是字符编码到字符图像的映射，但是一个字体尤其是一些有专门用途的字体（比如 JetBrains Mono 设计初衷是为软件工程显示代码用的），它不会映射所有的字符，JetBrains Mono 这个字体里就没有映射 U+00A0。<strong>这就导致在 LaTeX 编译时无法在字体中找到对应的字符图像显示</strong>。</p><p>所有解决办法就是要不替换掉这个字符，要不换个字体。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>VSCode 正则搜索<code>\U00A0</code>即可搜索到相关字符，将其替换成空格。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/d7edb679cd3d">字符，字符集，字符编码，编码页，字体 - 简书</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
      <tag>字体</tag>
      
      <tag>LaTex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-nohup 后台运行</title>
    <link href="/2022/09/10/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-nohup%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    <url>/2022/09/10/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-nohup%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>使用 MobaXertm 连接服务器后，想要在运行一个下载任务，使用<code>&amp;</code>挂在后台后，退出 MobaXterm，后台的任务也随之中断，于是搜到这个<code>nohup</code>命令，可以完成我的需求。</p><p><code>nohup</code>意思是 No Hang Up，不要挂起的意思，即使退出终端也不会中断任务。</p><p>为了方便以后查阅，这里总结一下关于后台运行相关的命令。首先是最常用的<code>&amp;</code>符号。</p><h2 id="amp-后台运行"><a href="#amp-后台运行" class="headerlink" title="&amp; 后台运行"></a>&amp; 后台运行</h2><p>比如执行编译任务时通常会占用终端前台，这时候无法再执行其他命令，除非再开一个终端，对于有 GUI 界面时，再开一个终端很方便，但是如果是服务器就只能再想办法了。 <code>&amp;</code>可以将命令执行过程放在后台运行，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make  &gt;  make.log  2&gt;&amp;1  &amp; <br>[1] 16586<br></code></pre></td></tr></table></figure><blockquote><p><code>2&gt;&amp;1</code> 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了<code>make.log</code>文件，即将标准出错也输出到<code>make.log</code>文件中。最后一个<code>&amp;</code>，是让该命令在后台执行。<br>试想<code>2&gt;1</code>代表什么，<code>2</code>与<code>&gt;</code>结合代表错误重定向，而<code>1</code>则代表错误重定向到一个文件<code>1</code>，而不代表标准输出；换成<code>2&gt;&amp;1</code>，<code>&amp;</code>与<code>1</code>结合就代表标准输出了，就变成错误重定向到标准输出。</p></blockquote><p>在后台运行<code>make</code>进行编译，并将输出结果（错误和正常输出）都保存到<code>make.log</code>文件中，提交任务成功后，会显示进程 ID，编译的进程 ID 为 <code>16586</code>。</p><p>有了进程 ID 我们可以监控，也可以中断进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看进程状态</span><br>ps -ef | grep 16586<br><span class="hljs-comment"># 中断进程</span><br><span class="hljs-built_in">kill</span> -9 16586<br></code></pre></td></tr></table></figure><p>但是使用 <code>&amp;</code>时关闭终端后，进程也会随之关闭。如果想要在后台持续运行程序，就需要<code>nohup</code>命令。</p><h2 id="nohup-使用"><a href="#nohup-使用" class="headerlink" title="nohup 使用"></a>nohup 使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">$ nohup make  &gt;  make.log  2&gt;&amp;1  &amp; <br>[1] 112233<br></code></pre></td></tr></table></figure><p>命令功能同上，但是终端关闭，后台程序也会继续执行。</p><p><strong>NOTE</strong>：终端关闭，是指带 GUI 的界面里终端，如果使用 SSH 等登陆，比如使用 MobaXterm，一个 session 相当于一个登陆账户，如果异常退出了这个账户，那么后台执行的程序也会中断。如果需要继续执行，需要正常退出账户，执行<code>exit</code>命令。</p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">fg</span>        <span class="hljs-comment"># 将后台中的命令调至前台继续运行</span><br><span class="hljs-built_in">bg</span>        <span class="hljs-comment"># 将一个在后台暂停的命令，变成继续执行 (在后台执行)</span><br><span class="hljs-built_in">jobs</span>      <span class="hljs-comment"># 查看当前有多少在后台运行的命令</span><br><span class="hljs-built_in">kill</span> %num <span class="hljs-comment"># 终止进程num</span><br>&amp;         <span class="hljs-comment"># 加在命令后可以将其置于后台运行</span><br>ctrl + z  <span class="hljs-comment"># 置于后台，并且暂停不可执行</span><br>ctrl + c  <span class="hljs-comment"># 终止前台进程</span><br>ctrl + \  <span class="hljs-comment"># 退出</span><br>ctrl + d  <span class="hljs-comment"># 结束当前输入(即用户不再给当前程序发出指令)，那么Linux通常将结束当前程序</span><br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始搭建一台 NAS 存储服务器</title>
    <link href="/2022/09/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E5%8F%B0NAS%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/09/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E5%8F%B0NAS%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>技术没学多少，教程下满了硬盘，一直想专门部署 NAS 来存文件，但是一来要花钱，二来搭建 NAS 没有经验怕部署不好，没有现在硬盘直连舒适，所以将就用吧。</p><p>自从有天忘了忘了休眠电脑，一个自动备份任务开启，在 40 度的高温天，满速跑了一天，下班回来硬盘直接报废。这就加速我折腾部署 NAS 的进程。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>威联通的几款中意的 NAS 放购物车很久了，如果硬盘没有这么早坏掉，可能在双十一就买整机了，现在离双十一还早，硬件价格都不便宜，想来想去还是买二手硬件攒一台更划算。如果买整机，硬盘加 NAS 主机就得五千大洋，只是用来存文件，部署个 Jellyfin 看电影用，属实奢侈了。</p><p>￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥</p><p>买二手就得从零开始学。生命不休，折腾不止。经过一次完整的 NAS 攒机过程发现，其实 NAS 就是安装了专用系统的一台电脑而已。这个专用系统就是面向网络存储开发的，如群晖，威联通，开源的 OMV，FreeNAS 等等。</p><p>既然是一台电脑，其实攒 NAS 就和攒电脑一样，选配好以下几大件即可。</p><ul><li>CPU</li><li>主板</li><li>散热器</li><li>机箱</li><li>内存</li><li>电源</li><li>机箱风扇</li></ul><p>下面分别介绍在攒机过程中遇到的一些概念，参数到底是什么意思。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h4 id="CPU-型号字母数字都是什么意思"><a href="#CPU-型号字母数字都是什么意思" class="headerlink" title="CPU 型号字母数字都是什么意思"></a>CPU 型号字母数字都是什么意思</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/19-03-26-07978c9e6aae76e3d1a4ac48df0521f1-20220910190326-c46d16.png"></p><ul><li><strong>Intel</strong> 是英特尔的英文名称，也是目前热门的 CPU 品牌；</li><li>“酷睿”代表英特尔品牌下面向普通消费者的一个 CPU 系列，一般划分为 Core（酷睿）、Pentium（奔腾）、Celeron（赛扬）、Xeon（至强）、Atom（凌动）等；</li><li><strong>i5</strong> 代表这款 CPU 定位中端，在其下面还有 i3，在其上面还有 i7 和 i9，同一代中，数字越大，性能越强；但是不同代 - 数之间，性能不能直接相比，比如 12 代的 i5 在理论性能上是强于 10 代 i7 的。</li><li><strong>12</strong> 代表这款 CPU 的代数，说明其已经发展到第十二代了，数字越大越新；</li><li><strong>600</strong> 这三位数字代表 Intel SKU 型号划分，一般来说 Core i7 有固定几个 SKU，比方说 700；Core i5有600/500/400；Core i3有300/100等等，一般来说数字越大说明隶属的Core系列越高级，同级别下比较，数字越大频率越高，换句话说性能就越强，比方说Core i5-8600 默认 3.1GHz，睿频 4.3GHz，比 Core i5-8500 默认 3.0GHz，睿频 4.1GHz 要强。</li><li><strong>K</strong> 带 K 的表示不锁频，可以配合 Z 系列主板进行超频操作，适合会超频玩家使用，比方说 i7-12700K，i5-12600K 等</li><li><strong>F</strong> 带 F 的表示不带集成显卡，<strong>你必须配合独立显卡使用</strong>；</li></ul><p>当然，除了例子中的这种情况，我们还会遇到其它 CPU 型号的后缀：</p><ul><li><strong>K</strong>：表示支持超频且内置核显的 CPU 型号，例如型号：i5-12600K、i7-12700K；</li><li><strong>F</strong>：表示无内置核显，例如型号：i5-12400F、i7-12700F；</li><li><strong>KF</strong>：表示支持超频且无内置核显的 CPU 型号，例如型号：i5-12600KF，i7-12700KF。</li><li><strong>T</strong>：表示低功耗版，相同型号下功耗更低，性能也差一些，例如型号：i7-10700T；</li><li><strong>X/XE</strong>：表示至尊旗舰级，例如型号：i9-10980XE。</li><li><strong>KS</strong>：可以理解为官方超频版，提升了主频的版本，例如 i9-9900K 和 i9-9900KS，i9-9900KS 出厂的主频要高于 K，例如型号：i9-9900KS。</li><li><strong>U</strong>：低电压，性能弱些但功耗低，通常出现在轻薄本中，举例型号：i7 10510U；</li><li><strong>H</strong>：标压，性能强，通常出现在游戏本中，举例型号：i5-11300H</li><li><strong>Y</strong>：超低电压，性能很弱功耗非常低，通常出现在轻薄本中，举例型号：i3-10110Y；</li><li><strong>HK</strong>：一般使用在 Intel 高端发烧级 CPU 上，可超频，举例型号：i9-11980HK；</li><li><strong>G</strong>：G1、G4 以及 G7 等，G 后面的数字表示核显性能强弱，数字越大代表核显性能越强，通常数字小于 4 的是集成的普通超高清 (UHD) 核显，大于等于 4 的是集成的高性能锐炬 (Iris) 核显。Intel 移动版 CPU 后缀，举例型号：i5-1155G7、i3-1115G4、i3-1005G1；</li><li><strong>HQ</strong>：标准电压，Q 板载四核，早期的老后缀，举例型号：i7-7700HQ；</li><li><strong>MQ</strong>：标准电压，Q 插拔四核，早期的老后缀，举例型号：i7-4810MQ；</li><li><strong>M</strong>：早期后缀 M 就是移动端 CPU，只是为了与台式机区别开，举例型号：i7-2620M。</li></ul><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><h4 id="ATX，Micro-ATX，Mini-ITX-区别"><a href="#ATX，Micro-ATX，Mini-ITX-区别" class="headerlink" title="ATX，Micro-ATX，Mini-ITX 区别"></a>ATX，Micro-ATX，Mini-ITX 区别</h4><p>在了解买啥主板时，不免会看到各种 TX，比如我买的这块七彩虹 B460iTX 主板，简称就是七彩虹 B460i，还有不带最后字母<code>i</code>的。他们有啥区别呢？其实这就是表示了主板的尺寸。主板尺寸常见的有三种尺寸：</p><ul><li><p>标准-ATX：30.5 厘米 x 24.4 厘米</p></li><li><p>Micro-ATX：24.4 cm x 24.4 cm</p></li><li><p>Mini-ITX：17 厘米 x 17 厘米</p></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/17-03-20-6cc06a3d6fbf9247c002ff2aacbb89bd-20220910170319-1e2047.png"></p><p>一般攒机会用标准 ATX，或者 MATX 也很常用，而 ITX 就常被用来搭建低功耗的服务器，如我们要搭建的 NAS。因为它是 7*24 小时不间断工作的，功耗是需要多考虑的。</p><h3 id="散热器"><a href="#散热器" class="headerlink" title="散热器"></a>散热器</h3><h4 id="风冷与水冷"><a href="#风冷与水冷" class="headerlink" title="风冷与水冷"></a>风冷与水冷</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-02-33-f393351f39da51508625fc8283335b1c-20220911100231-f4fd24.png"></p><p>风冷就是散热鳍片加风扇。散热鳍片会穿入铜管，铜管与下方底座相连，底座与 CPU 直接接触。CPU 热量铜管底座传导给铜管，铜管传导给散热鳍片，散热鳍片铜管风扇散热。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-04-38-a5cb1d964c6f3dd6fc71c2bca88d4369-20220911100437-034a9d.png"></p><p>水冷就是水冷头加风扇。简单理解就是风冷的铜管换成了液体。液体流动传导比铜管更快。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-05-10-47f4e854323ea9e8d86896342153705a-20220911100509-80682d.png"></p><p>各有优缺点，风冷更安全，比较简单，性能上限比较低，而水冷在外观、性能方面有很大的优势，缺点就是相对比较贵，还有漏液风险，不过现在的水冷漏液概率很小。细分的话风冷还有下压式，下压式比较适合 itx 小机箱，而塔式就适合普通机箱，水冷也分一体式水冷和分体式水冷，常见的都是一体式水冷。</p><h3 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h3><h4 id="塔式，机架与刀片区别"><a href="#塔式，机架与刀片区别" class="headerlink" title="塔式，机架与刀片区别"></a>塔式，机架与刀片区别</h4><p>塔式服务器外形和普通家用服务器相差不多，塔式主机在主板扩展上有优势，一般预留接口较多，方便扩展。适用于入门和工作站。</p><p>机架服务器的外观安装工业标准统一设计，需要配合机柜统一使用，主要用于企业服务器密集部署。机架服务器因为需要密集紧凑，所以在设计时会非常紧凑，充分利用有限的空间。机架服务器宽度 19 英寸，高度以 U 为单位 (1U=1.75 英寸 =44.45 毫米）.</p><p>刀片服务器的主体结构是主体机箱中可以有许多热拔插的主板，每一块主板都可以独立运行自己的系统，这些主板可以集合成一个服务器集群，在集群模式下可以连接起来提供更好的网络以及共享资源。</p><h4 id="全塔，中塔与小塔区别"><a href="#全塔，中塔与小塔区别" class="headerlink" title="全塔，中塔与小塔区别"></a>全塔，中塔与小塔区别</h4><p>形容的是机箱的大小。</p><p>普通机箱，只能放 mATX 主板和一个标准电源，仅有 1-2 个光驱位；</p><p>中塔机箱 AT，X 主板甚至是 EATX 主板和一个标准电源，拥有 3-4 个光驱位；</p><p>全塔机箱，可以在主板上下的位置都安放一个电源，一共放两个电源拥有 4 个以上的光驱位。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/22-48-02-b90a4e4404769b82bc4d601d082bdf72-20220910224802-d6b6f5.png"></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h3 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h3><h4 id="全模组，半模组与非模组区别"><a href="#全模组，半模组与非模组区别" class="headerlink" title="全模组，半模组与非模组区别"></a>全模组，半模组与非模组区别</h4><p>总结一句话就是能不能拔掉不需要的供电线，能拔多少。</p><h5 id="非模组"><a href="#非模组" class="headerlink" title="非模组"></a>非模组</h5><p>一个都不能拔，电源线直接从电源内部引出，输出线缆固定，无法进行扩展。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/22-23-12-6d2af37077c958056be73653cfffd322-20220910222311-675160.png"></p><h5 id="半模组"><a href="#半模组" class="headerlink" title="半模组"></a>半模组</h5><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/22-32-37-16daab986b991e007eeff650353e0479-20220910223236-f0ab87.png"></p><p>能拔一部分，输出设计上既有非模组电源的直出线，又有全模组电源的扩展接口。</p><h5 id="全模组"><a href="#全模组" class="headerlink" title="全模组"></a>全模组</h5><p>能全拔，所有线缆都能按需插上。因为一般一块主板不会把所有电源线都用上，这样只需要插上自己需要的线缆即可，可以保证走线清楚，机箱清爽。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/22-20-52-266a816bdbffa27b7d2ad02eabb07a52-20220910222051-61c37f.png"></p><h4 id="金牌，银牌和铜牌啥区别"><a href="#金牌，银牌和铜牌啥区别" class="headerlink" title="金牌，银牌和铜牌啥区别"></a>金牌，银牌和铜牌啥区别</h4><p>金牌，银牌，铜牌指的是电源的转换效率。有钛金、白金、金牌、银牌、铜牌、白牌等档次，档次越高，转换效率也越高，但成本也越高，功率越小，相对成本也越高。每个“牌”对应的攻略转换或者参数也是不同的。</p><p>白牌：最低要求是 20-100% 负载下，转换效率必须达到 80%；</p><p>铜牌：与上同条件大于等于 82%，85%@50% 负载；</p><p>银牌：大于等于 85%，88%@50% 负载；</p><p>金牌：大于等于 87%，90%@50% 负载；</p><p>白金牌：90%@20% 负载、92%@50% 负载、89%@100% 负载。</p><p>钛金牌：要求 10%、20%、50%、100% 负载下的效率分别为 90%、94%、96%、92%。</p><blockquote><p>举个例子：<br>500w 金牌和 500w 铜牌，都能带动 500w 功耗的电脑。金牌电源在 100% 负载时，转换率超过 87%，可以算一下，500/0.87=575w 耗电。<br>铜牌 100% 负载转换率超过 82% 500/0.82=610w耗电，简单说就是好电源省电。</p></blockquote><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><h4 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h4><h4 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h4><h5 id="垂直盘-PMR-与叠瓦盘-SMR-区别"><a href="#垂直盘-PMR-与叠瓦盘-SMR-区别" class="headerlink" title="垂直盘 PMR 与叠瓦盘 SMR 区别"></a>垂直盘 PMR 与叠瓦盘 SMR 区别</h5><blockquote><p>作者：一起学点什么<br>链接：<a href="https://www.zhihu.com/question/369882964/answer/2227127605">https://www.zhihu.com/question/369882964/answer/2227127605</a></p></blockquote><p>垂直磁记录（Perpendicular magnetic recording，PMR），也称为传统磁性记录 (conventional magnetic recording，CMR)，由于 SMR 其实也是垂直式磁记录的一种，只是相较于垂直磁记录方式磁盘优化了写入密度，因此为了避免被认为所有垂直磁记录的硬盘都是 SMR 硬盘，大家也习惯把非 SMR 的垂直机械盘称为 CMR。</p><p>最开始由于硬盘容量提升的需求，磁性记录颗粒的尺寸需要不断下降，导致出现了电磁学上的超顺磁效应（超顺磁性：当某些具有磁性的颗粒小于某个尺寸时，外场产生的磁取向力太小而无法抵抗热扰动的干扰，而导致其磁化性质与顺磁体（通俗来说就是指材料对磁场响应很弱的磁）相似。），这就限制了硬盘容量提升的潜力。</p><p>之前硬盘厂商使用纵向（平行，Longitudinal Magnetic Recording，LMR）读写技术，磁性记录颗粒的易磁化方向相对于碟片是平行的，颗粒沿着碟片圆周以端对端排列，所以便有机会出现 SS（南）和 NN（北）的互斥排列。当颗粒的尺寸不断下降而密度不断提升，在室温的情况下颗粒便会对随机的热运动异常敏感，失去稳定性，导致出现比特（0 和 1）翻转的现象，记录的数据因此被破坏。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-37-25-bcc8863e8c481995128e5057ef677657-v2-0c0c8d0fa144f9492a3f4599bcff3fa2_720w-d47981.jpeg" alt="平行读写方式和垂直读写方式" title="平行读写方式和垂直读写方式"></p><p>而为了解决以上问题，后来就开发出了垂直磁记录技术（Perpendicular Recording）的硬盘，这种硬盘中的磁性记录颗粒的易磁化方向相对于碟片是垂直的，允许使用单极磁头配合磁记录介质下的软磁层将信息写入磁记录介质中，这样采用具有相同饱和磁化强度的材料所制备的垂直写入磁头，能产生远多于传统写入磁头所能产生的磁场。更大的写入磁场允许我们使用具有更高磁各向异性的材料来制备磁记录介质，而磁各向异性越强，出现超顺磁性效应的临界体积就越小，因此，碟片中的存储密度可以在一定程度内得到进一步的提高。</p><p>但是这样虽然提高了硬盘的存储密度，但是很快也就达到了瓶颈，工程师又开始想新的方法来提高硬盘的存储密度，这就诞生了大家都知道的 SMR 叠瓦盘。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-37-44-9854e0b7be55864a3c8d88d85706ae3e-v2-70621980e9aa04789beee8ac77360de4_720w-bdb6ea.jpeg" alt="传统垂直读写硬盘的写入磁头和读写磁头的宽度" title="传统垂直读写硬盘的写入磁头和读写磁头的宽度"></p><p>叠瓦式机械硬盘（Shingled magnetic recording，SMR，直译为分层磁记录）：也是一种用于硬盘驱动器的磁存储数据记录技术，可提高存储密度和每个驱动器的整体存储容量。常规的硬盘驱动器通过写入彼此平行而不重叠的磁道来记录数据，例如 PMR。而叠瓦磁记录技术的硬盘写入的新磁道则与先前写入的磁道部分重叠，从而使先前的磁道更窄，因此能拥有更高的磁道密度，进而提高磁盘容量。使用叠瓦磁技术的磁道相互重叠，与用作屋顶的瓦片堆叠方式类似。之所以能这样做是因为磁盘写入磁头由于物理上的原因比读取磁头宽上许多，因而由正常方式写入的磁道宽度远比读取磁头所需的磁道宽度来得宽，此外为了避免磁道间相互干扰，磁道和磁道之间其实还有一部分空隙，因此读取信息的磁道仅占所有磁道的很小一部分，很大的磁盘空间都被浪费了，只是因为技术原因我们不能将写入磁头制作的和读取磁头一样小。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-38-47-933fcaeee57c194da4f9583cf2298ab8-v2-d64bf87cc1454f8ec91a398abfbbedc6_720w-d978c7.jpeg" alt="CMR 硬盘原理" title="CMR硬盘原理"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/10-38-58-83f62c2d4e2e8cbcdec45f6befd1be96-v2-6f1171496af614dea6c148afe5953a43_720w-c5eb05.jpeg"></p><p>由于磁道存在重叠，叠瓦式磁盘的写入过程较为复杂。如果我们随机写入一个磁道，由于写入磁头的宽度比磁道宽，因此写入会影响到临近磁道，如果这个临近磁道有数据，这些数据就也需要依次重写以免数据被破坏，依此类推。因此，SMR 磁盘一般分成很多块只能追加数据（顺序写入）的区域（Zone），这和固态硬盘的闪存页管理类似。使用“设备管理”（device-managed）方式的 SMR 磁盘通过内部固件处理了 SMR 磁盘复杂的写入问题，从而对用户封装了 SMR 磁盘的复杂性，令用户可以像使用 PMR 硬盘一样随机写入 SMR 硬盘。其他 SMR 磁盘则使用“主机管理”（host-managed）方式，需要操作系统识别 SMR 磁盘并拥有能对 SMR 磁盘进行正确顺序写入的驱动程序才能被正常使用。</p><p>叠瓦盘相较于垂直盘性能也有一定下降，因为传统的 CMR 硬盘磁道之间不会互相干扰，写入数据时可以任意进行写入，而叠瓦盘由于在一个磁道写入数据时不可避免会影响相邻的磁道，需要将下一磁道的数据先拿出（暂时放入硬盘 CMR 缓冲区）再进行写入，而恢复下一磁道的数据则又会对下下磁道的数据进行影响，则又需要先取出下下磁道的数据，因此完成传统垂直硬盘一次的写入操作，叠瓦式硬盘则需要多次的写入，同样的数据量需要更多的写入操作，也会增大损坏的概率。</p><h2 id="配件选购"><a href="#配件选购" class="headerlink" title="配件选购"></a>配件选购</h2><table><thead><tr><th align="center">配件</th><th align="center">型号</th><th align="center">价格</th></tr></thead><tbody><tr><td align="center">主板</td><td align="center">七彩虹 B460-ITX</td><td align="center">300^1^</td></tr><tr><td align="center">CPU</td><td align="center">I3-10100</td><td align="center">600^1^</td></tr><tr><td align="center">机箱</td><td align="center">Invasion X5</td><td align="center">330^1^</td></tr><tr><td align="center">电源</td><td align="center">振华冰山金蝶 550W</td><td align="center">300^1^</td></tr><tr><td align="center">硬盘</td><td align="center">西数 HC550</td><td align="center">1390</td></tr><tr><td align="center">SSD</td><td align="center">xxxxx</td><td align="center">旧电脑拆的</td></tr><tr><td align="center">散热器</td><td align="center">利民 AX120 RSE</td><td align="center">74</td></tr><tr><td align="center">内存条</td><td align="center">酷兽 DDR4 16G</td><td align="center">245</td></tr><tr><td align="center"><strong>合计</strong></td><td align="center"></td><td align="center"><strong>3239</strong></td></tr></tbody></table><blockquote><p>1.表示二手价格</p></blockquote><h3 id="主板-1"><a href="#主板-1" class="headerlink" title="主板"></a>主板</h3><p>刚入门其实最头疼的就是到底买什么型号，因为各个配件之间又有兼容问题，比如相中了一款 ITX 的机箱，但是主板却是 ATX 的，主板都放不进机箱里，这就很麻烦。所以我们首先要确定一个配件，其余配件都安装这个配件的规格去买，并且都要适配这个配件。那么这个配件最好的选择就是主板。</p><p>我们先确定自己要买一个什么样的主板，让所有其他的配件都适配这个主板。选择主板的好处是，主板上各个接口就能体现出这台 NAS 的性能。不至于配件买的太离谱。</p><h3 id="机箱-1"><a href="#机箱-1" class="headerlink" title="机箱"></a>机箱</h3><p>微型机箱买 ITX 板，MINI 机箱买 M-ATX 板和 ITX 板，中塔机箱买 ATX 板。因为 NAS 是个服务器，可能会永远被放在墙角，所以颜值不重要，实用才是王道，买一个盘位多实用性强的就行。</p><p>在前期准备时看到很多推荐迎广的机箱，本来决定要买它，但是了解到 NAS 的本质就是一台电脑主机时，意识到为何不买个电脑机箱？为何要选择成品的机箱？虽然成品的 NAS 机箱有硬盘位，可热插拔。但是我为啥要去插拔服务器上的硬盘？</p><p>当我有这个意识后，我的选择一下子多了起来，我最终选了逛淘宝偶然看的 Invasion 机箱。十分简约的外形，甚至还有玻璃侧罩，四格金属硬盘架专为 NAS 打造。只要不到三百块。于是立马转头打开小黄鱼，一搜还真有转卖的，升级版的 8 格硬盘架只要 330。收到货后也很满意，几乎是全新的，玻璃膜都没有撕，还送了俩风扇。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/10/22/4d93dc601559f515fbe2a0e261eb2776.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/10/22/0264f7b051cac66705feee6e3441dd52.png"></p><h3 id="CPU-1"><a href="#CPU-1" class="headerlink" title="CPU"></a>CPU</h3><p>选择 CPU 对于小白来说最重要的就是要选择带核显的 CPU，因为 NAS 上显卡其实没必要，CPU 的核显就绰绰有余了，如果既没有显卡也没有核显就会无法亮机。所以选择 CPU 时要选择带核显的，也就是 Intel 的 CPU 型号不带<code>F</code>的，比如我最终选择的 I3-10100。AMD 的 CPU 型号标识我也没弄清楚，可以自己搜索一下自己想要的 CPU 是否有核显。</p><p>其次就是功耗，因为 NAS 要 7*24 小时运行，所以选择性能低一点的 CPU 就好了，另外就是需要关注 CPU 是否有音视频解码的能力。因为平时爱折腾，想着以后指不定在 NAS 上折腾些啥，所以选择了性能不算低的 I3-10100。两个月体验下来，性能还是过剩了，日常基本上都处于待机状态，只有周末看电影会用一下，CPU 利用率很低，好在日常功耗只有 30W。-</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/10/22/6e6ec183f0c08fc29eb6b01410090dce.png"></p><h2 id="安装-OVM-OpenMediaVaultt"><a href="#安装-OVM-OpenMediaVaultt" class="headerlink" title="安装 OVM (OpenMediaVaultt)"></a>安装 OVM (OpenMediaVaultt)</h2><p>参考视频：<a href="https://www.bilibili.com/video/BV1FJ411s7xR?spm_id_from=333.999.0.0&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">蜗牛星际安装开源 NAS 系统 Openmediavault 及初始化配置（司波图）——OMV 系列教程 01</a></p><h3 id="为什么选择它"><a href="#为什么选择它" class="headerlink" title="为什么选择它"></a>为什么选择它</h3><p>OpenMediaVault（以下均简称 OMV）是除 FreeNAS 外目前使用最广泛的开源 NAS 系统。</p><h3 id="预备软件下载"><a href="#预备软件下载" class="headerlink" title="预备软件下载"></a>预备软件下载</h3><p><a href="https://www.openmediavault.org/download.html">下载 OpenMediaVaultt 系统</a>，我选择的是 ISO 格式 Old Stable 版本，虽然想用最新的版本，但是第一次安装没有成功，选择了旧版本安装成功了。</p><p><a href="https://www.wepe.com.cn/">下载 微 PE 工具箱</a>，用来格式化系统盘，如果是新买的系统盘就不需要下载。</p><p><a href="https://rufus.ie/zh/">下载 Rufus 轻松创建 USB 启动盘</a>，这个必须要用的。</p><h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>需要一个容量大于 4G 的 U 盘，用 Rufus 将 OMV 写入 U 盘即可。安装时会从 U 盘启动，然后将系统安装到插在主板上的系统盘内。</p><p>启动盘制作就不详细说了，都是一键式操作。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/14-36-53-d083a346dc428783efefcddcb2a46001-20220911143652-19d632.png"></p><p><strong>制作完后进入 U 盘内查看是否写入成功</strong>，U 盘内是否有文件，或者查看一下 U 盘使用大小，如果比系统 ISO 大小还小，那肯定没有写成功。我就制作了三遍才发现没有写成功，虽然能看到启动选项，但是进入安装就黑屏，因为根本没有可以安装的文件。</p><p>如果没有制作成功，尝试<strong>格式化</strong>U 盘后重新制作。</p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>参考视频即可，很详细。</p><h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git</span><br>sudo apt install git<br><span class="hljs-comment"># python</span><br>sudo apt install python<br><span class="hljs-comment"># vim</span><br>sudo apt install vim<br></code></pre></td></tr></table></figure><h2 id="Docker-配置"><a href="#Docker-配置" class="headerlink" title="Docker 配置"></a>Docker 配置</h2><h3 id="安装-Portainer-管理容器"><a href="#安装-Portainer-管理容器" class="headerlink" title="安装 Portainer 管理容器"></a>安装 Portainer 管理容器</h3><h3 id="更换国内镜像源"><a href="#更换国内镜像源" class="headerlink" title="更换国内镜像源"></a>更换国内镜像源</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/18-55-03-a846141c4a3997752a278ef1c604c554-20220910185502-99a3e2.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/18-58-15-eefc8207a6905d28a7b76e0a142f18d5-20220910185815-3b0c01.png"></p><ul><li>网易 <code>http://hub-mirror.c.163.com</code></li><li>ustc <code>http://docker.mirrors.ustc.edu.cn</code></li><li>阿里云 <code>http://&lt;你的 ID&gt;.mirror.aliyuncs.com</code></li><li>或者使用一位网友提供的    <code>http://1nj0zren.mirror.aliyuncs.com</code></li></ul><p>因为可能有朋友看了比较老的教程（比如我，:( ），可能会用到一些停止服务的进行，如：</p><ul><li><code>https://dockerhub.azk8s.cn</code></li><li><code>https://reg-mirror.qiniu.com</code></li><li><code>https://registry.docker-cn.com</code></li></ul><p>如果无法拉取镜像，检查是否用了这几个，如果用了请换镜像源。</p><h3 id="安装-Jellyfin-部署影音服务器"><a href="#安装-Jellyfin-部署影音服务器" class="headerlink" title="安装 Jellyfin 部署影音服务器"></a>安装 Jellyfin 部署影音服务器</h3><h3 id="安装-Transmission-下载"><a href="#安装-Transmission-下载" class="headerlink" title="安装 Transmission 下载"></a>安装 Transmission 下载</h3><h3 id="安装-qBittorrent-下载"><a href="#安装-qBittorrent-下载" class="headerlink" title="安装 qBittorrent 下载"></a>安装 qBittorrent 下载</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/16-06-33-65041d0b29059db114c6bd10b20ab2f2-20220911160632-a3bdd5.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/16-07-40-0ace26a48fbe6b421fdc1ad168d752f9-20220911160739-66337b.png"></p><h4 id="添加-tracker-list"><a href="#添加-tracker-list" class="headerlink" title="添加 tracker list"></a>添加 tracker list</h4><p><a href="https://github.com/ngosang/trackerslist">ngosang/trackerslist: Updated list of public BitTorrent trackers</a></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/19-58-26-68faa5378bc8e252b13251e864575545-20220910195825-1f3492.png"></p><h3 id="安装-Jackett-搜索种子"><a href="#安装-Jackett-搜索种子" class="headerlink" title="安装 Jackett 搜索种子"></a>安装 Jackett 搜索种子</h3><p>Docker 中安装，选择网易的镜像，阿里的镜像太旧了。</p><p>配置端口号<code>9117</code>，映射两个路径即可。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/15-24-34-0d1575f2892b0426b6885e28d550337e-20220911152433-8a2a1d.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/15-27-11-008863a6cee878d735268752cf4b7ffa-20220911152710-5366dc.png"></p><p>安装过程参考<a href="https://github.com/qbittorrent/search-plugins/wiki/How-to-configure-Jackett-plugin">How to configure Jackett plugin</a>。</p><p>点击<a href="https://raw.githubusercontent.com/qbittorrent/search-plugins/master/nova3/engines/jackett.py">这里下载源码</a>，复制全文并保存为<code>jackett.py</code>文件。</p><p>如果按照以上安装 qBittorrent 那么保存路径为共享文件夹下<code>appdata/qBittorrent/nova3/engines/</code>。</p><p>如果没找到，找找是否有以下路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">~/.<span class="hljs-built_in">local</span>/share/data/qBittorrent/nova3/engines/<br><span class="hljs-comment"># 或者</span><br>~/.<span class="hljs-built_in">local</span>/share/qBittorrent/nova3/engines/<br></code></pre></td></tr></table></figure><p>再在相同路径下，新建一个配置文件<code>jackett.json</code>，写入以下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;api_key&quot;</span>: <span class="hljs-string">&quot;YOUR_API_KEY_HERE&quot;</span>, <br>    <span class="hljs-attr">&quot;tracker_first&quot;</span>: <span class="hljs-literal">false</span>, <br>    <span class="hljs-comment">// 如果你登录 OMV 的地址是 192.168.0.1</span><br>    <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://192.168.0.1:9117&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="安装-Hlink-硬链接持续做种"><a href="#安装-Hlink-硬链接持续做种" class="headerlink" title="安装 Hlink 硬链接持续做种"></a>安装 Hlink 硬链接持续做种</h3><p>下载的文件名太过杂乱，可以用 TMM 等刮削工具刮削，重命名，建立影音库。但是重命名后就无法做种。想起了 Linux 有硬链接功能，在<a href="https://dunky-z.github.io/2021/08/03/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/">每天学命令-ln 软硬链接</a>这篇文章中有详细说明。简言之就是创建的硬链接可以任意<strong>修改文件名</strong>，看上去是一份拷贝，但是<strong>实际不占用硬盘空间</strong>。</p><p>下载的文件太多，又是文件夹嵌套，手动创建比较麻烦，有人专门为这个需求开源了一个项目<a href="https://hlink.likun.me/">hlink</a>，可以批量创建硬链接。这里还是以使用 Docker 为例。</p><h4 id="配置-Docker"><a href="#配置-Docker" class="headerlink" title="配置 Docker"></a>配置 Docker</h4><p>镜像名：likun7981/hlink<br>端口号：9090<br>目录映射：/media :  /root/sharedfolder<br>环境变量：HLINK_HOME：/root/sharedfolder/appdata/hlink  选择自己放配置文件的目录即可</p><blockquote><p>/root/sharedfolder 是我挂载的硬盘的根目录，建议映射根目录，不要创建多个目录，比如映射/root/sharedfolder/movie 和/root/sharedfolder/music。因为硬链接不支持跨盘符创建，虽然我们本地 music 和 movie 是在一个盘符，但是这样<strong>映射在容器中就是两个盘</strong>，就会无法创建硬链接，所以只映射一个根目录。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/10-23-24-4ece9b26e4043a836b1fa2a2781600b9-20220912102324-27d38f.png"></p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/09-41-48-1cd8143da0c9ffaca54a212f2ffd670e-20220912094147-3cc75f.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/09-41-15-50e436e132411b5528505e58911d636b-20220912094115-081991.png"></p><h4 id="配置-Hlink"><a href="#配置-Hlink" class="headerlink" title="配置 Hlink"></a>配置 Hlink</h4><p>浏览器输入 IP:9090，打开配置界面。</p><p>添加一个新配置，注释十分详细，就不赘述了，但是路径一定要写对，可以新建两个测试目录，测试一下是否能够创建成功。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/12/10-32-40-510edbcdcf05ffe8054b5581ed7c9057-20220912103239-8b23ae.png"></p><p>两个重要配置解释：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * /media 是容器里的目录，因为我只映射了一个目录，所以这就是容器的根目录</span><br><span class="hljs-comment"> * 对应到我主机，就是/root/sharedfolder 这个目录</span><br><span class="hljs-comment"> * 所以/media/downloads/qbittorrent/qbcomplete/movie</span><br><span class="hljs-comment"> * 就是/root/sharedfolder/downloads/qbittorrent/qbcomplete/movie</span><br><span class="hljs-comment"> * 后一个路径/media/media/movie同理</span><br><span class="hljs-comment"> * 等价于/root/sharedfolder/media/movie</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 前一个路径是下载的路径，这里的文件都是不能重命名整理的</span><br><span class="hljs-comment">  * 后一个路径是影音库的路径，hlink 执行完会在这里创建相同的文件链接</span><br><span class="hljs-comment">  * 这个链接可以任意修改，移动，删除</span><br><span class="hljs-comment">  */</span><br>  pathsMapping: &#123;<br>      &#x27;/media/downloads/qbittorrent/qbcomplete/movie&#x27;: &#x27;/media/media/movie&#x27;,<br>  &#125;,<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 true 打开缓存，这样即使影音库里的文件被删除，移动</span><br><span class="hljs-comment"> * 也不会创建新的硬链接</span><br><span class="hljs-comment"> */</span><br>openCache: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><p>缓存的文件信息在右上角<strong>编辑缓存</strong>可以查看，如果已经执行过创建硬链接但是没有显示，<code>Shfit+F5</code>刷新界面重试。</p><h2 id="踩坑记录-1"><a href="#踩坑记录-1" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="主板无法识别固态硬盘"><a href="#主板无法识别固态硬盘" class="headerlink" title="主板无法识别固态硬盘"></a>主板无法识别固态硬盘</h3><p>因为想利用上三年前从笔记本上拆下来的固态，但没注意接口的协议。主板现在大多默认支持 NEVe 协议，但是我的硬盘是很久之前的 SATA 协议。这块 B460i 主板默认支持 NVMe 协议的，但是也支持 SATA 协议，需要更改跳帽。</p><p>找了半天图片没有找到一样的，官网的图片是和说明书上的一样是拨动开关形式的，但是我买的二手的是跳帽（哭），不会是买到假的了吧。开关全部拨到左边才支持 SATA 协议。用跳帽也是一样，必须都连接的是左边两个引脚。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/16-11-07-355ce9f2442639e47b0e24f9773b2e84-20220910161106-f6986f.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/10/16-09-53-5ceae123a355652ef1f45bb0e9b72dd9-20220910160952-9c6773.png"></p><h3 id="无法识别-U-盘启动盘"><a href="#无法识别-U-盘启动盘" class="headerlink" title="无法识别 U 盘启动盘"></a>无法识别 U 盘启动盘</h3><p>引导模式有两种 UEFI 和 Legacy，这个在做启动盘时就确定了。如果主板使用的 UEFI 模式，而启动盘制作的是 Legacy 模式，就无法识别，需要在 Bios 里找到启动模式选择的相关选项，配置可以使用 Legacy 模式或者 UEFI。（记录这些时已经不想再进 Bios 了所以也没有图片，总之要配置引导方式，避免过滤了一些引导方式导致 U 盘无法识别）</p><h3 id="不同网段设备无法互通"><a href="#不同网段设备无法互通" class="headerlink" title="不同网段设备无法互通"></a>不同网段设备无法互通</h3><h3 id="OVM-无法挂载移动硬盘"><a href="#OVM-无法挂载移动硬盘" class="headerlink" title="OVM 无法挂载移动硬盘"></a>OVM 无法挂载移动硬盘</h3><p>报错：The filesystem label contains blanks. Please remove them by renaming the filesystem to be able to mount it.</p><p>移动硬盘名里有空格，插到 Windows 上重命名一下即可。</p><h3 id="ifconfig-not-found"><a href="#ifconfig-not-found" class="headerlink" title="ifconfig not found"></a>ifconfig not found</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ifconfig</span><br>sudo apt install net-tools<br></code></pre></td></tr></table></figure><h3 id="ll-not-found"><a href="#ll-not-found" class="headerlink" title="ll not found"></a>ll not found</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br><span class="hljs-comment"># 找到 #alias ll=’ls -l’，去掉前面的#就可以了。</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/498113584">CPU 型号解读：教你 CPU 型号后缀怎么看？CPU 型号后面的字母和数字区别是什么？ - 知乎</a></li><li><a href="https://einverne.github.io/post/2018/12/build-nas-from-scratch.html">从零开始搭建 NAS: 硬件篇 | Verne in GitHub</a></li><li><a href="https://einverne.github.io/post/2020/02/build-nas-from-scratch-software.html">从零搭建一台 NAS：软件篇 | Verne in GitHub</a></li><li><a href="https://blog.csdn.net/mahoon411/article/details/106963398">Intel CPU 型号解读以及如何粗略判断 Intel CPU 的性能 (i3、i5、i7 以及 CPU 的代数)_吮指原味张的博客-CSDN 博客_cpu 代数</a></li><li><a href="https://blog.zuiyu1818.cn/posts/NAS_qBittorrent.html">NAS | 群晖安装 qBittorrent 套件并优化设置、替换 UI（非 docker 安装） | 醉渔小站</a></li><li><a href="https://www.jianshu.com/p/405fe33b9032">Docker 中国源 - 简书</a></li><li><a href="http://www.antec.com.cn/index.php?m=content&c=index&a=show&catid=41&id=57">金牌 铜牌 什么区别呀？ - 电源 - Antec 网站</a></li><li><a href="https://www.tspweb.com/key/%E9%93%9C%E7%89%8C%E7%94%B5%E6%BA%90%E5%92%8C%E9%87%91%E7%89%8C%E7%94%B5%E6%BA%90%E7%9A%84%E5%8C%BA%E5%88%AB.html">机·科普贴：电脑电源金、银、铜牌到底是什么意思？_铜牌电源和金牌电源的区别 - 调色盘网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/50797978">【非模组电源，半模组电源，全模组电源有什么区别？】 - 知乎</a></li><li><a href="https://post.smzdm.com/p/awx49n72/">电源全模组和非模组究竟有什么区别？_电脑电源_什么值得买</a></li><li><a href="https://zhuanlan.zhihu.com/p/25592446">浅谈组装机机箱的选择（篇一：大小） - 知乎</a></li><li><a href="https://howthere.org/zh-hant/%E5%93%AA%E7%A8%AE-pc-%E6%A9%9F%E7%AE%B1%E5%B0%BA%E5%AF%B8%E6%9C%80%E9%81%A9%E5%90%88%E6%82%A8%E7%9A%84%E4%B8%8B%E4%B8%80%E5%80%8B%E7%89%88%E6%9C%AC%EF%BC%9F">哪種 PC 機箱尺寸最適合您的下一個版本？ - HowThere</a></li><li><a href="https://www.expreview.com/49306-all.html">199 元风冷/水冷散热器简单对比：谁才是你的爱 - 超能网</a></li><li><a href="https://www.bilibili.com/video/BV1FJ411s7xR?spm_id_from=333.999.0.0&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">【教程】蜗牛星际安装开源 NAS 系统 Openmediavault 及初始化配置（司波图）——OMV 系列教程 01_哔哩哔哩_bilibili</a></li><li><a href="https://github.com/qbittorrent/search-plugins/wiki/How-to-configure-Jackett-plugin">How to configure Jackett plugin · qbittorrent/search-plugins Wiki</a></li><li><a href="https://www.bilibili.com/video/BV1aa411R7hn?spm_id_from=333.337.search-card.all.click&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">安装 NAS Tools，打造自动化观影、追剧系统，NAS 媒体库整理工具，威联通 Docker 版 NAS Tools 安装教程~feat.威联通 HS 264_哔哩哔哩_bilibili</a></li><li><a href="https://hlink.likun.me/">Home | hlink</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NAS</tag>
      
      <tag>Linux，攒机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下使用 Clash 作代理并配置开机启动</title>
    <link href="/2022/09/10/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8Clash%E4%BD%9C%E4%BB%A3%E7%90%86%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
    <url>/2022/09/10/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8Clash%E4%BD%9C%E4%BB%A3%E7%90%86%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>前往<a href="https://github.com/Dreamacro/clash/releases">下载页面</a>，选择合适的版本下载，Linux 一般下载<code>linux-amd64</code>版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gunzip clash-linux-amd64-v1.11.8.gz<br>sudo mv clash-linux-amd64-v1.11.8 /usr/<span class="hljs-built_in">local</span>/bin/clash<br>sudo chmod +x /usr/<span class="hljs-built_in">local</span>/bin/clash<br></code></pre></td></tr></table></figure><h2 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">clash-linux-amd64-v1.11.8 -f 从订阅商那获取的配置文件.ymal -d .<br>git <span class="hljs-built_in">clone</span> https://github.com/twbs/bootstrap.git --config <span class="hljs-string">&quot;http.proxy=127.0.0.1:7890&quot;</span>  <br><span class="hljs-comment"># 即可正常下载</span><br></code></pre></td></tr></table></figure><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> ~<br>sudo cp /usr/<span class="hljs-built_in">local</span>/bin/clash /etc/<br>sudo vim /etc/systemd/system/clash.service<br></code></pre></td></tr></table></figure><p>添加如下内容，并保存：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs YAML">[<span class="hljs-string">Unit</span>]<br><span class="hljs-string">Description=Clash</span> <span class="hljs-string">Daemon</span><br><br>[<span class="hljs-string">Service</span>]<br><span class="hljs-string">ExecStart=/usr/local/bin/clash</span> <span class="hljs-string">-f</span> <span class="hljs-string">/etc/clash/订阅的配置文件.yaml</span> <span class="hljs-string">-d</span> <span class="hljs-string">/etc/clash/</span><br><span class="hljs-string">Restart=on-failure</span><br><br>[<span class="hljs-string">Install</span>]<br><span class="hljs-string">WantedBy=multi-user.target</span><br></code></pre></td></tr></table></figure><p>启用 clash 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl <span class="hljs-built_in">enable</span> clash.service<br><br></code></pre></td></tr></table></figure><p>启动 clash 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl start clash.service<br><br></code></pre></td></tr></table></figure><p>此外也可以停止或者禁用 clash 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl stop clash.service<br>sudo systemctl <span class="hljs-built_in">disable</span> clash.service<br><br></code></pre></td></tr></table></figure><p>查看运行状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo systemctl status clash<br></code></pre></td></tr></table></figure><p>查看 clash 服务日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">journalctl -e -u clash.service<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Clash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 No module named &#39;ConfigParser&#39;</title>
    <link href="/2022/09/05/%E8%A7%A3%E5%86%B3No-module-named-ConfigParser/"/>
    <url>/2022/09/05/%E8%A7%A3%E5%86%B3No-module-named-ConfigParser/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 终端回车变成^M</title>
    <link href="/2022/09/05/Linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E5%8F%98%E6%88%90-M/"/>
    <url>/2022/09/05/Linux%E7%BB%88%E7%AB%AF%E5%9B%9E%E8%BD%A6%E5%8F%98%E6%88%90-M/</url>
    
    <content type="html"><![CDATA[<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>终端执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">stty sane<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://askubuntu.com/questions/441744/pressing-enter-produces-m-instead-of-a-newline#comment578102_441744">command line - Pressing enter produces ^M instead of a newline - Ask Ubuntu</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 切换不同 Python 版本</title>
    <link href="/2022/09/05/Linux%E5%88%87%E6%8D%A2%E4%B8%8D%E5%90%8CPython%E7%89%88%E6%9C%AC/"/>
    <url>/2022/09/05/Linux%E5%88%87%E6%8D%A2%E4%B8%8D%E5%90%8CPython%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO 博客嵌入 PDF</title>
    <link href="/2022/09/03/HEXO%E5%8D%9A%E5%AE%A2%E5%B5%8C%E5%85%A5PDF/"/>
    <url>/2022/09/03/HEXO%E5%8D%9A%E5%AE%A2%E5%B5%8C%E5%85%A5PDF/</url>
    
    <content type="html"><![CDATA[<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><iframe src="/myjs/pdfjs/web/viewer.html?file=/misc/Markdown书写PDF输出优雅的解决方案.pdf" style="width:100%;height:600px"></iframe><h1 id="下载-pdf-js"><a href="#下载-pdf-js" class="headerlink" title="下载 pdf.js"></a>下载 pdf.js</h1><p>前往<a href="https://mozilla.github.io/pdf.js">官网</a>下载<code>pdf.js</code>。</p><p>为了保证兼容性，建议下载旧版：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/03/18-02-32-6b30daefccbd074fc4a35844850845ea-20220903180230-1223af.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/03/18-02-57-878391ebdd45d2771db4af95418070bf-20220903180256-c4617f.png"></p><h1 id="添加-pdfjs-到主题中"><a href="#添加-pdfjs-到主题中" class="headerlink" title="添加 pdfjs 到主题中"></a>添加 pdfjs 到主题中</h1><p>将下载文件夹命名为 <code>pdfjs</code>，拷贝到 <code>themes/fluid/source/myjs</code> 中。<code>myjs</code>目录为自己新建目录。并将该目录<code>skip_render</code>。</p><p>打开 HEXO 的配置文件（不是主题的配置文件）<code>_config.yml</code>，搜索<code>skip_render</code>，配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">skip_render:</span> [<span class="hljs-string">myjs/**</span>]<br></code></pre></td></tr></table></figure><p>如果不配置该选项，嵌入的 PDF 将会带有博客主题边框。如图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/03/18-19-02-472a12f30ba4cce15617de591e302e71-20220903181901-b9ca63.png"></p><h1 id="修改-viewer-js"><a href="#修改-viewer-js" class="headerlink" title="修改 viewer.js"></a>修改 viewer.js</h1><p>直接使用下载的文件会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error: file origin does not match viewer<span class="hljs-string">&#x27;s</span><br></code></pre></td></tr></table></figure><p>注释<code>web/viewer.js</code>文件中的相应内容：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/03/18-06-10-4b25b5f59c41c12783fedd145161003d-20220903180609-33dea8.png"></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>在 Markdown 文档中使用 <code>&lt;iframe&gt;</code> 控件配合<code>pdf.js</code> 库完成 pdf 显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;/myjs/pdfjs/web/viewer.html?file=&lt;src-to-pdf&gt;&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;width:100%;height:100%&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;src-to-pdf&gt;</code>：需要显示的 pdf 文件的链接</li><li><code>/myjs/pdfjs/web/viewer.html</code>：改为自己的 pdfjs 目录</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-pdf/fluid-pdf/">Fluid -3- pdf.js PC，移动端查看 PDF - 又见苍岚</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>HEXO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 入门 - 系统调用</title>
    <link href="/2022/08/29/RISC-V%E5%85%A5%E9%97%A8-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2022/08/29/RISC-V%E5%85%A5%E9%97%A8-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><p>目前为止的学习过程中，所有的程序都是运行在 Machine 模式下，但是在哪决定程序运行在什么模式下的呢？</p><p>在学习抢占式多任务时，我们有了创建任务的概念，在汇编代码中有这么一段，使用到了<code>mstatus</code>寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm"># Notice: default mstatus is 0<br># Set mstatus.MPP to 3, so we still run in Machine mode after MRET.<br># Set mstatus.MPIE to 1, so MRET will enable the interrupt.<br>li t0, 3 &lt;&lt; 11 | 1 &lt;&lt; 7<br>csrr a1, mstatus     # a1 = mstatus<br>or t0, t0, a1          # t0 = t0 | a1<br>csrw mstatus, t0     # mstatus = t0<br><br>j start_kernel  # hart 0 jump to c<br></code></pre></td></tr></table></figure><p><code>mret</code>返回后，是根据寄存器<code>mstatus</code>的<code>MPP</code>来决定接来来是处于什么模式，我们在上面将<code>MPP</code>配置为<code>3</code>， <code>MPP</code>的功能是 <strong>记录 Machine 模式下，前一个，特权级</strong>。这里解实现了在<code>mret</code>之后将模式设置为 Machine 模式（3）。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-00-30-55f75636e01aeb7bd76220a1a3ff47b9-20220830150029-154a85.png"></p><p>因为<code>mstatus</code>上电后默认为全 0，所以如果不对其设置，那么在<code>mret</code>之后，就是运行在用户态（0）。</p><p>如果想让程序跑在用户态，只要不对齐设置，保持默认即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm"># Notice: default mstatus is 0<br># Set mstatus.MPP to 3, so we still run in Machine mode after MRET.<br># Set mstatus.MPIE to 1, so MRET will enable the interrupt.<br>li t0, 1 &lt;&lt; 7<br>csrr a1, mstatus     # a1 = mstatus<br>or t0, t0, a1          # t0 = t0 | a1<br>csrw mstatus, t0     # mstatus = t0<br><br>j start_kernel  # hart 0 jump to c<br></code></pre></td></tr></table></figure><p>为什么需要系统调用？因为在用户态一些资源（寄存器）的访问是受限的，所以需要封装一些函数，这些函数里会进行模式切换，然后访问需要的资源。</p><p>那么如何进行模式的切换呢？这就需要<code>ecall</code>指令。它本质上是触发了异常，就会进入到 Machine 模式处理异常，在 Machine 模式下就相当于在内核态了，就没有访问资源的限制了。</p><h2 id="系统模式的切换"><a href="#系统模式的切换" class="headerlink" title="系统模式的切换"></a>系统模式的切换</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-27-34-3c336196c43c6f6ccbefca72d74ae3c7-20220830152733-8bbc12.png"></p><p><code>ECALL</code>指令实际就是主动触发异常，根据<code>ECALL</code>的权限级别产生不同的异常码，如下图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-29-47-4836183d7fc588d43a989f57e39e3dbd-20220830152946-759ff3.png"></p><p>从 User 模式调用<code>ECALL</code>异常码等于 8，从 Supervisor 模式调用异常码等于 9，从 Machine 模式调用异常码等于 11。</p><p>异常产生时<code>epc</code>寄存器的值存放的是<code>ECALL</code>指令本身的地址。</p><blockquote><p>如果想触发完异常接着往下执行，需要在异常处理逻辑里把 epc 寄存器值改为下一条指令地址，否则会进入死循环。</p></blockquote><h2 id="系统调用的执行流程"><a href="#系统调用的执行流程" class="headerlink" title="系统调用的执行流程"></a>系统调用的执行流程</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-33-19-a180df2c96fd165b60b1455fa75521bd-20220830153318-348272.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-45-13-4425120671c06b5cf849f87c25ef7ded-20220830154512-70af22.png"></p><h2 id="系统调用的传参"><a href="#系统调用的传参" class="headerlink" title="系统调用的传参"></a>系统调用的传参</h2><p>系统调用作为操作系统的对外接口，由操作系统的实现负责定义。参考 Linux 的系统调用，RVOS 定义系统调用的传参规则如下：</p><ul><li>系统调用号放在<code>a7</code>中</li><li>系统调用参数使用<code>a0-a5</code></li><li>返回值使用<code>a0</code></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-49-21-6db764f87f585532caa83f56319e642a-20220830154920-a8bcc3.png"></p><h2 id="系统调用的封装"><a href="#系统调用的封装" class="headerlink" title="系统调用的封装"></a>系统调用的封装</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-54-13-7949945c24c3873b0d2360a1b4ee6edd-20220830155412-895328.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器任务栏多窗口命名</title>
    <link href="/2022/08/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%91%BD%E5%90%8D/"/>
    <url>/2022/08/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%91%BD%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>工作时需要开启多个标签页，在同一个窗口里打开又查找不变，于是分为多个窗口，每个窗口里的标签页工作内容一致。如所有文档放在一个窗口，需要百度，Google 搜索时用单独的一个问题搜索窗口。这样就避免每次打开窗口都要挨个点一遍。</p><h2 id="Edge-设置"><a href="#Edge-设置" class="headerlink" title="Edge 设置"></a>Edge 设置</h2><p>打开设置-更多工具 - 为窗口命名。即可重命名窗口</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220525102824.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220525102435.png"></p><h2 id="Chrome-设置"><a href="#Chrome-设置" class="headerlink" title="Chrome 设置"></a>Chrome 设置</h2><p>同上，路径基本一致都是在<strong>设置</strong>-<strong>更多工具</strong>中。</p><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/09-17-17-bbceed32bc17a5ca1eb37c46ecf7b650-116a3e41478ffc331c722340b21bbf7b-018594.gif"></p><p>在使用过程中发现窗口太多任务栏太挤了，Chrome 自身有标签分组的功能，其实完全可以替代窗口。也可以满足我的需求。<a href="https://sspai.com/post/65936">少数派</a>有介绍，就不造轮子了。体验一段时间确实很好用。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>效率</tag>
      
      <tag>推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 任务栏多窗口命名</title>
    <link href="/2022/08/28/VSCode%E4%BB%BB%E5%8A%A1%E6%A0%8F%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%91%BD%E5%90%8D/"/>
    <url>/2022/08/28/VSCode%E4%BB%BB%E5%8A%A1%E6%A0%8F%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%91%BD%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="调教背景"><a href="#调教背景" class="headerlink" title="调教背景"></a>调教背景</h2><p>当有多个项目同时打开时，VSCode 窗口开得太多就找不到自己想要打开的窗口，因为窗口命名默认按照当前打开的文件命名的，不是很清楚。就需要挨个打开才能确定自己想要打开的窗口。</p><p>如果能按照项目名命名窗口就会便捷许多，好在 VSCode 提供重命名的方式。同样的需求可能在浏览器中也会遇到，可以参考<a href="https://dunky-z.github.io/2022/08/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%91%BD%E5%90%8D/">浏览器任务栏多窗口命名 - 如云泊</a>。</p><h2 id="修改方式"><a href="#修改方式" class="headerlink" title="修改方式"></a>修改方式</h2><p><code>File -&gt; Preferences -&gt; Setting</code> 搜索 <code>Window: Title</code> 改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$&#123;dirty&#125;$&#123;rootName&#125;$&#123;separator&#125;$&#123;activeEditorMedium&#125;$&#123;separator&#125;$&#123;appName&#125;<br></code></pre></td></tr></table></figure><p>其他可用配置说明：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;$&#123;activeEditorShort&#125;&quot;</span>: 文件名 (例如 myFile.txt)。<br><span class="hljs-string">&quot;$&#123;activeEditorMedium&#125;&quot;</span>: 相对于工作区文件夹的文件路径 (例如, myFolder<span class="hljs-regexp">/myFileFolder/my</span>File.txt)。<br><span class="hljs-string">&quot;$&#123;activeEditorLong&#125;&quot;</span>: 文件的完整路径 (例如 <span class="hljs-regexp">/Users/</span>Development<span class="hljs-regexp">/myFolder/my</span>FileFolder/myFile.txt)。<br><span class="hljs-string">&quot;$&#123;activeFolderShort&#125;&quot;</span>: 文件所在的文件夹名称 (例如, myFileFolder)。<br><span class="hljs-string">&quot;$&#123;activeFolderMedium&#125;&quot;</span>: 相对于工作区文件夹的、包含文件的文件夹的路径, (例如 myFolder/myFileFolder)。<br><span class="hljs-string">&quot;$&#123;activeFolderLong&#125;&quot;</span>: 文件所在文件夹的完整路径 (例如 <span class="hljs-regexp">/Users/</span>Development<span class="hljs-regexp">/myFolder/my</span>FileFolder)。<br><span class="hljs-string">&quot;$&#123;folderName&#125;&quot;</span>: 文件所在工作区文件夹的名称 (例如 myFolder)。<br><span class="hljs-string">&quot;$&#123;folderpath&#125;&quot;</span>: 文件所在工作区文件夹的路径 (例如 <span class="hljs-regexp">/Users/</span>Development/myFolder)。<br><span class="hljs-string">&quot;$&#123;rootName&#125;&quot;</span>: 打开的工作区或文件夹的名称 (例如 myFolder 或 myWorkspace)。<br><span class="hljs-string">&quot;$&#123;rootPath&#125;&quot;</span>: 打开的工作区或文件夹的文件路径 (例如 <span class="hljs-regexp">/Users/</span>Development/myWorkspace)。<br><span class="hljs-string">&quot;$&#123;appName&#125;&quot;</span>: 例如 VS Code。<br>“<span class="hljs-variable">$&#123;remoteName&#125;</span>”: 例如 SSH<br><span class="hljs-variable">$&#123;dirty&#125;</span>: 表明活动编辑器具有未保存更改的时间的指示器。<br><span class="hljs-string">&quot;$&#123;separator&#125;&quot;</span>: 一种条件分隔符 (<span class="hljs-string">&quot;-&quot;</span>), 仅在被包含值或静态文本的变量包围时显示<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 ERROR Could not install packages due to an EnvironmentError 拒绝访问</title>
    <link href="/2022/08/27/%E8%A7%A3%E5%86%B3ERROR-Could-not-install-packages-due-to-an-EnvironmentError-%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/"/>
    <url>/2022/08/27/%E8%A7%A3%E5%86%B3ERROR-Could-not-install-packages-due-to-an-EnvironmentError-%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>升级<code>pip</code>时出现报错：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/21-59-14-303384c2d30eca141422d200bd35470c-20220827215913-0ec1da.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>加上<code>--user</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m pip install --upgrade pip  --user<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编码字体与阅读字体推荐</title>
    <link href="/2022/08/27/%E7%BC%96%E7%A0%81%E5%AD%97%E4%BD%93%E4%B8%8E%E9%98%85%E8%AF%BB%E5%AD%97%E4%BD%93%E6%8E%A8%E8%8D%90/"/>
    <url>/2022/08/27/%E7%BC%96%E7%A0%81%E5%AD%97%E4%BD%93%E4%B8%8E%E9%98%85%E8%AF%BB%E5%AD%97%E4%BD%93%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h1 id="编码字体"><a href="#编码字体" class="headerlink" title="编码字体"></a>编码字体</h1><p>编码字体首要原则：等宽，等宽，还是 TMD 等宽！</p><h2 id="JetBrains-Mono"><a href="#JetBrains-Mono" class="headerlink" title="JetBrains Mono"></a><a href="https://www.jetbrains.com/lp/mono/">JetBrains Mono</a></h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/20-50-54-1fe539cd3cb0a6bc28936cb76fd28644-20220827205054-dccd39.png"></p><h2 id="Hack"><a href="#Hack" class="headerlink" title="Hack"></a><a href="https://github.com/source-foundry/Hack">Hack</a></h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/20-53-57-e5174c7461a1d5b578a44d71f4a201c9-20220827205356-b71842.png"></p><h2 id="Source-Code-Pro"><a href="#Source-Code-Pro" class="headerlink" title="Source Code Pro"></a><a href="https://github.com/adobe-fonts/source-code-pro">Source Code Pro</a></h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/20-56-21-f7612e14d8fb5807c91fe60f58f8fe9a-20220827205620-929922.png"></p><h2 id="Fira-Mono"><a href="#Fira-Mono" class="headerlink" title="Fira Mono"></a><a href="https://www.fontsquirrel.com/fonts/fira-mono">Fira Mono</a></h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/20-59-31-38634f74a936c0f1f7dc300197f7d11e-20220827205931-947b4e.png"></p><h2 id="Consolas"><a href="#Consolas" class="headerlink" title="Consolas"></a>Consolas</h2><p>保底字体，基本上 Windows 电脑都有预装。</p><h1 id="阅读字体"><a href="#阅读字体" class="headerlink" title="阅读字体"></a>阅读字体</h1><p>看多了黑体，其实有衬线的宋体才能体现中文文字之美。</p><h2 id="思源宋体"><a href="#思源宋体" class="headerlink" title="思源宋体"></a><a href="https://source.typekit.com/source-han-serif/cn/">思源宋体</a></h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/21-26-41-695d3a7666fbd2ed815e7c967d96365d-20220827212640-9611e9.png"></p><h2 id="华文中宋"><a href="#华文中宋" class="headerlink" title="华文中宋"></a><a href="https://freefonts.top/font/60a7867598e5f44356ad7ee1">华文中宋</a></h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/21-31-18-d36a343840db1e78db06989d4f3db6b5-20220827213118-3bcd07.png"></p><h1 id="中文等宽字体"><a href="#中文等宽字体" class="headerlink" title="中文等宽字体"></a>中文等宽字体</h1><p>对于既想要满足编程字体又想要中文书写的，有几款等宽中文字体也不错。</p><h2 id="Sarasa-Gothic-更纱黑体"><a href="#Sarasa-Gothic-更纱黑体" class="headerlink" title="Sarasa Gothic / 更纱黑体"></a><a href="https://github.com/be5invis/Sarasa-Gothic">Sarasa Gothic / 更纱黑体</a></h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/21-28-37-15a7fa4c37074eb4fa50ef88561894ae-20220827212836-43865f.png"></p><h2 id="思源黑体-Source-Han-Sans"><a href="#思源黑体-Source-Han-Sans" class="headerlink" title="思源黑体/Source Han Sans"></a><a href="https://github.com/adobe-fonts/source-han-sans/tree/release">思源黑体/Source Han Sans</a></h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/21-29-56-e35563edf446e892ac4ed5c1e2478108-20220827212956-fbc90d.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>推荐</tag>
      
      <tag>字体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多版本 Python 使用 pip 安装 package 问题</title>
    <link href="/2022/08/27/%E5%A4%9A%E7%89%88%E6%9C%ACPython%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85package%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/27/%E5%A4%9A%E7%89%88%E6%9C%ACPython%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85package%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="最简单的方式"><a href="#最简单的方式" class="headerlink" title="最简单的方式"></a>最简单的方式</h2><p>使用参数指定安装路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -t D:\python3.5(32bit)\Lib\site-packages numpy<br></code></pre></td></tr></table></figure><h2 id="叨叨叨"><a href="#叨叨叨" class="headerlink" title="叨叨叨"></a>叨叨叨</h2><p>如果电脑上安装了多个版本的<code>Python</code>的话，在需要使用<code>pip</code>安装新<code>package</code>时，就会遇到这个问题：我把<code>package</code>安装到哪了？</p><p>因为每个版本的 Python 是有自己独立的<code>pip</code>，也有独立的<code>lib</code>目录的，管理的包也各不同。一般来说，使用默认的<code>pip</code>命令安装的位置，就是默认的<code>python</code>位置。</p><p>比如我在终端敲下<code>python</code>，使用的是<code>python3.6</code>那么安装的<code>package</code>就会在<code>C:\Python36\Lib\site-packages</code>（根据自己安装 Python 的路径稍有区别）。</p><h2 id="情景一：安装的都是-Python3-x-版本"><a href="#情景一：安装的都是-Python3-x-版本" class="headerlink" title="情景一：安装的都是 Python3.x 版本"></a>情景一：安装的都是 Python3.x 版本</h2><p>有时候会遇到这样的需求，我准备跑的项目只能用<code>python3.8</code>，我得把<code>package</code>安装到<code>python38</code>里，怎么办？</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><p>把其中一个<code>python</code>环境变量删掉，留下（如果没有需要添加）<code>python38</code>的路径和<code>script</code>添加到环境变量。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/27/19-54-23-815dcfa312c91b1a3d139d9c14835473-20220827195423-3636bf.png"></p><p>使用以下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m pip install xxxxx<br></code></pre></td></tr></table></figure><p>因为默认<code>Python</code>已经被修改为<code>python38</code>。</p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><p>使用文章开头的方式，最方便，直接指定 python 全局路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -t D:\python3.5(32bit)\Lib\site-packages numpy<br></code></pre></td></tr></table></figure><h2 id="情景二：安装-Python2-x-与-Python3-x"><a href="#情景二：安装-Python2-x-与-Python3-x" class="headerlink" title="情景二：安装 Python2.x 与 Python3.x"></a>情景二：安装 Python2.x 与 Python3.x</h2><p>Python3.x 使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">py -3 -m pip install numpy<br></code></pre></td></tr></table></figure><p>Python2.x 使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">py -2 -m pip install numpy<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>pip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Unable to 加载 picture or PDF file</title>
    <link href="/2022/08/26/%E8%A7%A3%E5%86%B3Unable-to-load-picture-or-PDF-file/"/>
    <url>/2022/08/26/%E8%A7%A3%E5%86%B3Unable-to-load-picture-or-PDF-file/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/19-25-10-0001dfd98f5655f4cb7f8c57dbb72723-20220826192508-b7c23b.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Unable to load picture or PDF file <span class="hljs-string">&#x27;xxxxxx&#x27;</span> &lt;to be <span class="hljs-built_in">read</span> again&gt; xxxx<br></code></pre></td></tr></table></figure><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>图片链接错误，转换 PDF 过程中会先下载所有图片到<code>AppData/Local/Temp/tex2pdf.****</code>文件夹里，因为无法正常下载图片，所有报错。检查图片链接是否有效。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>检查图片链接是否有效。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
      <tag>Markdown</tag>
      
      <tag>Pandoc</tag>
      
      <tag>PDF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode搜索结果/匹配高亮</title>
    <link href="/2022/08/26/VSCode%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C-%E5%8C%B9%E9%85%8D%E9%AB%98%E4%BA%AE/"/>
    <url>/2022/08/26/VSCode%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C-%E5%8C%B9%E9%85%8D%E9%AB%98%E4%BA%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="调教背景"><a href="#调教背景" class="headerlink" title="调教背景"></a>调教背景</h1><p>在VSCode使用搜索/替换时，匹配的字符会“高亮”（高亮个屁），知道自己当前搜到到什么位置，如果匹配字符较少还好，如果匹配太多，默认的高亮就很难发现当前已经搜索到什么位置了。比如我当前在搜索“搜索”这两个字：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220826172833.png"></p><p>大家还能看到我当前搜索到哪了吗？</p><p>但是如果设置成这样呢？</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220826173732.png"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="搜索匹配时高亮颜色"><a href="#搜索匹配时高亮颜色" class="headerlink" title="搜索匹配时高亮颜色"></a>搜索匹配时高亮颜色</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/17-40-49-b7f234e14ff670f8c4292f17edb9929b-20220826174048-2a64ac.png"></p><p>添加如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;workbench.colorCustomizations&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;editor.findMatchBackground&quot;</span>: <span class="hljs-string">&quot;#ff0000&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>表示搜索匹配时高亮，高亮颜色为红色。自己可以选择合适的颜色。</p><h2 id="搜索结果高亮"><a href="#搜索结果高亮" class="headerlink" title="搜索结果高亮"></a>搜索结果高亮</h2><p>与上面不同的是，搜索时会高亮所有的结果，但是点击箭头匹配到当前结果时就是上面的高亮，其余未匹配的状态就是下面的高亮：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/19-13-57-74e56317c2055ae8172b1d5e1b25491d-20220826191356-2d1dc8.png"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;workbench.colorCustomizations&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;editor.findMatchHighlightBackground&quot;</span>: <span class="hljs-string">&quot;#ff00ff&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择时颜色"><a href="#选择时颜色" class="headerlink" title="选择时颜色"></a>选择时颜色</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/19-06-58-45781dd55134fcc6a88b0b1a0c222b06-20220826190657-1dd776.png"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;workbench.colorCustomizations&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;editor.selectionBackground&quot;</span>: <span class="hljs-string">&quot;#2f00ff&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="范围搜索时背景颜色"><a href="#范围搜索时背景颜色" class="headerlink" title="范围搜索时背景颜色"></a>范围搜索时背景颜色</h2><p>有时候搜索不是全局搜索，是在自己选中的范围内搜索，那这个范围也是可以高亮的，开启范围搜索需要点击搜索框的按钮，如图所示：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/19-08-48-65f21c17444a9ebe51ce7f0f2edd4880-20220826190846-94ad92.png"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;workbench.colorCustomizations&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;editor.findMatchHighlightBackground&quot;</span>: <span class="hljs-string">&quot;#ff00ff&quot;</span>,<br>    <span class="hljs-attr">&quot;editor.findRangeHighlightBackground&quot;</span>: <span class="hljs-string">&quot;#ff9900&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 入门 - 任务切换与锁</title>
    <link href="/2022/08/26/RISC-V%E5%85%A5%E9%97%A8-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E4%B8%8E%E9%94%81/"/>
    <url>/2022/08/26/RISC-V%E5%85%A5%E9%97%A8-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E4%B8%8E%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h1><h2 id="任务简介"><a href="#任务简介" class="headerlink" title="任务简介"></a>任务简介</h2><h3 id="多任务与上下文"><a href="#多任务与上下文" class="headerlink" title="多任务与上下文"></a>多任务与上下文</h3><p>任务就是一个指令执行流。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220826151826.png"></p><p>如果有多个 HART，那就可以同时执行多个指令执行流。</p><p>协作式多任务</p><p>协作式环境下，下一个任务被调度的前提是当前任务主动放弃处理器。</p><p>抢占式多任务</p><p>抢占式环境下，操作系统完全决定任务调度方案，操作系统可以剥夺当前任务对处理器的使用，将处理器提供给其它任务。</p><h2 id="协作式多任务"><a href="#协作式多任务" class="headerlink" title="协作式多任务"></a>协作式多任务</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-09-51-b76ed5f4ea873bd1530963a096aaa8e3-20220828140950-e37c6b.png"></p><p>切换过程需要完成：</p><ul><li>保存上文（保存上一个任务的寄存器信息）</li><li>恢复下文（恢复下一个任务的寄存器信息）</li></ul><p>CPU 中有 32 个寄存器，保存各种状态，在切换过程中我们主要关注两个寄存器：<code>ra(x1) 存放返回地址</code>，<code>mscratch 一个特权寄存器，指向当前处理的任务</code>。</p><h3 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h3><p>初始化寄存器，<code>ra</code>都初始化为任务的第一条指令地址。<code>mscratch</code>开始指向 Task A。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-18-23-20b781289e8722e343e09f63910e5991-20220828141822-f0be20.png"></p><p>Task A 稳定执行，当他想要放弃 CPU 时，就会执行 <code>call swithc_to</code>指令。执行<code>call</code>的过程中，就会把当前指令的下一条指令的地址放到 CPU 的<code>ra</code>寄存器。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-21-23-1c9725267e1afd49dcc75e21da78c2e4-20220828142122-246130.png"></p><p>接下里跳转到<code>swithc_to</code>函数执行，该函数是切换上下文的核心函数。首先<strong>保存上文</strong>，将 CPU 中的寄存器信息全部保存：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-23-39-71d991190cae709f0135d994f9ccd7e2-20220828142338-67c814.png"></p><p><strong>切换</strong><code>mscratch</code>指针到下一个任务 Task B：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-24-41-47c1a159644584da7b435cbc5d7a2e56-20220828142440-398b0f.png"></p><p><strong>恢复下文</strong>：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-25-21-b5c57f4cd4d127e11679113987238f06-20220828142520-570733.png"></p><p>当<code>swithc_to</code>函数执行到<code>return</code>时，接下来执行的指令就是 CPU 中<code>ra</code>保存的那条指令，也就是地址为<code>j</code>指令，这就是 Task B 的第一条指令，这样就完成了任务的切换。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/14-28-34-62e744963f90c6a45930b7ec91c4960a-20220828142833-60e64d.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="切换核心函数-switch-to"><a href="#切换核心函数-switch-to" class="headerlink" title="切换核心函数 switch_to"></a>切换核心函数 switch_to</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs asm">switch_to:<br> csrrw t6, mscratch, t6 # swap t6 and mscratch<br> beqz t6, 1f   # Notice: previous task may be NULL<br> reg_save t6   # save context of prev task<br>                        # 把CPU的信息保存到内存<br><br> # Save the actual t6 register, which we swapped into<br> # mscratch<br> mv t5, t6  # t5 points to the context of current task<br> csrr t6, mscratch # read t6 back from mscratch<br> sw t6, 120(t5) # save t6 with t5 as base<br><br>1:<br> # switch mscratch to point to the context of the next task<br> csrw mscratch, a0<br><br> # Restore all GP registers<br> # Use t6 to point to the context of the new task<br> mv t6, a0<br> reg_restore t6      # 把内存里的信息恢复到CPU<br><br> # Do actual context switching.<br> ret<br></code></pre></td></tr></table></figure><h4 id="创建和初始化第一号任务"><a href="#创建和初始化第一号任务" class="headerlink" title="创建和初始化第一号任务"></a>创建和初始化第一号任务</h4><p>使用结构体<code>context</code>保存上下文中寄存器的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span><br> <span class="hljs-comment">/* ignore x0 */</span><br> <span class="hljs-keyword">reg_t</span> ra;<br> <span class="hljs-keyword">reg_t</span> sp;<br> <span class="hljs-keyword">reg_t</span> gp;<br> <span class="hljs-keyword">reg_t</span> tp;<br> <span class="hljs-keyword">reg_t</span> t0;<br> <span class="hljs-keyword">reg_t</span> t1;<br> <span class="hljs-keyword">reg_t</span> t2;<br> <span class="hljs-keyword">reg_t</span> s0;<br> <span class="hljs-keyword">reg_t</span> s1;<br> <span class="hljs-keyword">reg_t</span> a0;<br> <span class="hljs-keyword">reg_t</span> a1;<br> <span class="hljs-keyword">reg_t</span> a2;<br> <span class="hljs-keyword">reg_t</span> a3;<br> <span class="hljs-keyword">reg_t</span> a4;<br> <span class="hljs-keyword">reg_t</span> a5;<br> <span class="hljs-keyword">reg_t</span> a6;<br> <span class="hljs-keyword">reg_t</span> a7;<br> <span class="hljs-keyword">reg_t</span> s2;<br> <span class="hljs-keyword">reg_t</span> s3;<br> <span class="hljs-keyword">reg_t</span> s4;<br> <span class="hljs-keyword">reg_t</span> s5;<br> <span class="hljs-keyword">reg_t</span> s6;<br> <span class="hljs-keyword">reg_t</span> s7;<br> <span class="hljs-keyword">reg_t</span> s8;<br> <span class="hljs-keyword">reg_t</span> s9;<br> <span class="hljs-keyword">reg_t</span> s10;<br> <span class="hljs-keyword">reg_t</span> s11;<br> <span class="hljs-keyword">reg_t</span> t3;<br> <span class="hljs-keyword">reg_t</span> t4;<br> <span class="hljs-keyword">reg_t</span> t5;<br> <span class="hljs-keyword">reg_t</span> t6;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACK_SIZE 1024</span><br><span class="hljs-keyword">uint8_t</span> task_stack[STACK_SIZE];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">ctx_task</span>;</span><br></code></pre></td></tr></table></figure><p>写一个任务函数，功能就是每隔<code>1000</code> 滴答打印一句话。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">user_task0</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br> uart_puts(<span class="hljs-string">&quot;Task 0: Created!\n&quot;</span>);<br> <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>  uart_puts(<span class="hljs-string">&quot;Task 0: Running...\n&quot;</span>);<br>  task_delay(<span class="hljs-number">1000</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化任务，需要初始化栈，并把任务的首地址保存到<code>context</code>的<code>ra</code>寄存器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sched_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> w_mscratch(<span class="hljs-number">0</span>);<br><br> ctx_task.sp = (<span class="hljs-keyword">reg_t</span>) &amp;task_stack[STACK_SIZE - <span class="hljs-number">1</span>];<br> ctx_task.ra = (<span class="hljs-keyword">reg_t</span>) user_task0;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="切换到第一个用户任务"><a href="#切换到第一个用户任务" class="headerlink" title="切换到第一个用户任务"></a>切换到第一个用户任务</h4><p><code>switch_to</code>函数的参数就是上下文，当执行到<code>ret</code>时也就切换到了<code>user_task0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> *<span class="hljs-title">next</span> =</span> &amp;ctx_task;<br> switch_to(next);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是单任务的情况，如果是多任务时，就用数组保存多个<code>context</code>，最大支持 10 个任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TASKS 10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACK_SIZE 1024</span><br><span class="hljs-keyword">uint8_t</span> task_stack[MAX_TASKS][STACK_SIZE];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">ctx_tasks</span>[<span class="hljs-title">MAX_TASKS</span>];</span><br></code></pre></td></tr></table></figure><p>使用简单的求模取余的方式确定下一个任务是哪一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * _top is used to mark the max available position of ctx_tasks</span><br><span class="hljs-comment"> * _current is used to point to the context of current task</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _top = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _current = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * implment a simple cycle FIFO schedular</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (_top &lt;= <span class="hljs-number">0</span>) &#123;<br>  panic(<span class="hljs-string">&quot;Num of task should be greater than zero!&quot;</span>);<br>  <span class="hljs-keyword">return</span>;<br> &#125;<br><br> _current = (_current + <span class="hljs-number">1</span>) % _top;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> *<span class="hljs-title">next</span> =</span> &amp;(ctx_tasks[_current]);<br> switch_to(next);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为多个任务协作，需要一个函数来表示主动放弃 CPU：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * DESCRIPTION</span><br><span class="hljs-comment"> *  task_yield()  causes the calling task to relinquish the CPU and a new </span><br><span class="hljs-comment"> *  task gets to run.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">task_yield</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> schedule();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调用关系"><a href="#调用关系" class="headerlink" title="调用关系"></a>调用关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/16-43-26-148e18481402d4cbebda0b8cf437ea9a-20220828164325-f03e61.png"></p><h2 id="抢占式多任务"><a href="#抢占式多任务" class="headerlink" title="抢占式多任务"></a>抢占式多任务</h2><p>抢占式多任务：抢占式环境下，操作系统完全决定任务调度方案，操作系统可以剥夺当前任务对处理器的使用，将处理器提供给其他任务。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/18-26-19-d09627e0016250e4dd00e93a6d816ccc-20220828182618-7b140d.png"></p><p>对 MSIP 写入 1 时触发 软中断，写入 0 时表示对中断进行应答，也就是处理完了软中断。</p><h1 id="任务同步与锁"><a href="#任务同步与锁" class="headerlink" title="任务同步与锁"></a>任务同步与锁</h1><h2 id="并发与同步"><a href="#并发与同步" class="headerlink" title="并发与同步"></a>并发与同步</h2><p>并发：多个控制流同时执行</p><ul><li>多处理器多任务</li><li>单处理器多任务</li><li>单处理器任务 + 中断</li></ul><p>同步：为了保证在并发执行的环境中各个控制流可以有效执行而采用的一种编程技术</p><h2 id="临界区、锁与死锁"><a href="#临界区、锁与死锁" class="headerlink" title="临界区、锁与死锁"></a>临界区、锁与死锁</h2><p>临界区：在并发的程序执行环境中，所谓临界区指的是一个会访问<strong>共享资源</strong>的<strong>指令片段</strong>，而且当这样的多个指令片段同时访问某个共享资源时可能会引发问题。</p><p>在并发环境下为了有效控制临界区的执行（同步），我们要做的是当有一个控制流进入临界区时，其他相关控制流必须等待。</p><p>锁：一种常见的用来实现同步的技术</p><ul><li>不可睡眠锁</li><li>可睡眠锁</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/20-20-57-50e42984517b60ca08ec0dff17bc634f-20220828202056-fdd4f5.png"></p><p>当发生中断时，右边的任务获取 CPU 资源，开始执行，但是获取锁时发现当前已经处于锁定状态，所以就处于等待状态。</p><p>当下一个中断发生，左侧任务回去 CPU 后会继续执行，实际上左侧任务也不必等待，他可以一直执行，因为右侧任务一直无法获取锁。</p><p>当然，右侧任务也可以一直触发中断，让左侧任务让出 CPU。也就是左侧任务逻辑上可以一直运行，但是实际还是会被打断。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/20-22-25-783fb565f517c52bef12807070e8c0df-20220828202224-b7ec1e.png"></p><p>当左侧任务执行完释放锁，右侧任务就可以获取锁，并正常执行下去。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/20-28-29-39d640fb2c0f9ea420f9d8ceca38c8e2-20220828202828-bb9696.png"></p><p>死锁：当控制流执行路径中会涉及多个锁，并且这些控制流执行路径获取的顺序不同时就可能发送死锁。</p><p>解决死锁：</p><ul><li>调整获取锁的顺序，比如保持一致</li><li>尽可能防止任务在持有一把锁同时申请其他锁</li></ul><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/21-27-17-2a3d0048acc7b4a3d63b46b7fd67aa59-20220828212715-480a91.png"></p><p>不能从 C 语言的层面去理解锁，应该要从指令级别去理解。上面的这种上锁方式是有问题的。</p><p>如果两个控制流同时加锁，就可能同时获取了锁，因为在汇编指令级别，每条指令执行也是需要时间的：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/21-33-11-e1ad7600b03b294097a9fe9b52ac2cd6-20220828213310-65b79a.png"></p><p>AMOSWAP</p><pre><code class="asm">loop:    lw a4, -20(s0)  # 参数1    li a5, 1        # 参数 2    amoswap.w.aq a5, a5, (a4)   # 将a5与a4指向的内存的值进行交换                                # 将 1 与 a4 交换，表示如果原来上锁（1）那就什么都没做                                # 如果原来没上锁（0）那就立即上锁     mv a3, a5    bnez a3,loop![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/21-38-57-b7cece2166dba14bd128970cefdd2702-20220828213857-b116cd.png)</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 入门 - 内存管理</title>
    <link href="/2022/08/23/RISC-V%E5%85%A5%E9%97%A8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2022/08/23/RISC-V%E5%85%A5%E9%97%A8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>如何计算堆的大小，只有算出可用空间才能对其管理。</p><p>ENTRY</p><p>功能：用于设置入口点，即程序中执行的第一条指令<br>symbol 参数是一个符号的名称</p><p>OUTPUT_ARCH</p><p>功能：指定输出文件所适用的计算机体系架构</p><blockquote><p>为什么用 riscv64-unknown-elf-gcc，但是编译出来的文件是 32 位程序？<br>riscv64 是 host 是 64 位系统，编译 target 是由 gcc 的参数决定</p></blockquote><p>MEMORY</p><p>功能：用于描述目标机器上内存区域的位置，大小和相关</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">MEMORY<br>&#123;<br>    <span class="hljs-comment">/* 内存类型为ROM，起始地址0，长度256K */</span><br>    rom(rx):<span class="hljs-attr">ORIGIN</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">LENGTH</span> = <span class="hljs-number">256</span>K<br>    <span class="hljs-comment">/* 内存类型为RAM，起始地址0x40000000，长度4M */</span><br>    ram(!rx):<span class="hljs-attr">org</span> = <span class="hljs-number">0</span>x40000000, <span class="hljs-attr">l</span> = <span class="hljs-number">4</span>M<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TODO：括号里的 rx 含义是？</p></blockquote><p>SECTION</p><p>功能：告诉链接器如何将 input sections 映射到 output sections，以及如何将 output sections 放置到内存中。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">SECTION<br>&#123;<br>    <span class="hljs-string">.=0x0000</span>;<br>    <span class="hljs-string">.text</span>:&#123;*<span class="hljs-params">(.text)</span>&#125;<br>    <span class="hljs-string">.=0x8000000</span>;<br>    <span class="hljs-string">.data</span>:&#123;*<span class="hljs-params">(.data)</span>&#125;<br>    <span class="hljs-string">.bss</span>:&#123;*<span class="hljs-params">(.bss)</span>&#125;<br>&#125;&gt;ram<br></code></pre></td></tr></table></figure><p>PROVIDE</p><p>功能：</p><ul><li>可以在 Linker Script 中定义符号（Symbols）</li><li>每个符号包括一个名字（name) 和一个对应的地址值（address）</li><li>在代码中可以访问这些符号，等同于访问一个地址。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">.bss :&#123;<br> PROVIDE(_bss_start = .);    /* 当前地址赋值给符号_bss_start */<br> *(.sbss .sbss.*)<br> *(.bss .bss.*)<br> *(COMMON)<br> PROVIDE(_bss_end = .);<br>&#125; &gt;ram<br>   PROVIDE(_memory_start = ORIGIN(ram));<br>PROVIDE(_memory_end = ORIGIN(ram) + LENGTH(ram));<br><br>PROVIDE(_heap_start = _bss_end); /* 堆空间就是接在了bss段之后，所以堆开始地址就是bss结束地址 */ <br>PROVIDE(_heap_size = _memory_end - _heap_start); /* 计算堆大小 */ <br></code></pre></td></tr></table></figure><p><code>.global</code>表示全局变量，<code>.word</code>表示定义变量，下面的代码就是定义一些全局变量，方便在 C 代码中使用。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">/* mem.S */</span> <br><span class="hljs-meta">.section</span> .rodata<br><span class="hljs-meta">.global</span> HEAP_START<br><span class="hljs-symbol">HEAP_START:</span> <span class="hljs-meta">.word</span> _heap_start<br><br><span class="hljs-meta">.global</span> HEAP_SIZE<br><span class="hljs-symbol">HEAP_SIZE:</span> <span class="hljs-meta">.word</span> _heap_size<br><br><span class="hljs-meta">.global</span> TEXT_START<br><span class="hljs-symbol">TEXT_START:</span> <span class="hljs-meta">.word</span> _text_start<br><br><span class="hljs-meta">.global</span> TEXT_END<br><span class="hljs-symbol">TEXT_END:</span> <span class="hljs-meta">.word</span> _text_end<br><br><span class="hljs-meta">.global</span> DATA_START<br><span class="hljs-symbol">DATA_START:</span> <span class="hljs-meta">.word</span> _data_start<br><br><span class="hljs-meta">.global</span> DATA_END<br><span class="hljs-symbol">DATA_END:</span> <span class="hljs-meta">.word</span> _data_end<br><br><span class="hljs-meta">.global</span> RODATA_START<br><span class="hljs-symbol">RODATA_START:</span> <span class="hljs-meta">.word</span> _rodata_start<br><br><span class="hljs-meta">.global</span> RODATA_END<br><span class="hljs-symbol">RODATA_END:</span> <span class="hljs-meta">.word</span> _rodata_end<br><br><span class="hljs-meta">.global</span> <span class="hljs-keyword">BSS_START</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BSS_START: </span><span class="hljs-meta">.word</span> _bss_start<br><br><span class="hljs-meta">.global</span> <span class="hljs-keyword">BSS_END</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BSS_END: </span><span class="hljs-meta">.word</span> _bss_end<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Following global vars are defined in mem.S</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> TEXT_START;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> TEXT_END;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> DATA_START;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> DATA_END;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> RODATA_START;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> RODATA_END;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> BSS_START;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> BSS_END;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> HEAP_START;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uint32_t</span> HEAP_SIZE;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint32_t</span> _num_pages = _num_pages = (HEAP_SIZE / PAGE_SIZE) - <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p>实现 Page 级别的内存分配与释放</p><p>日常使用的操作系统，都是以字节为单位分配空间，但是为了教学方便，RVOS 是以 Page 为单位分配内存。</p><p>数据结构设计</p><h3 id="数组方式管理"><a href="#数组方式管理" class="headerlink" title="数组方式管理"></a>数组方式管理</h3><p>将内存模拟为一个连续的数组，数组的前部预留 8 个 Page 来管理其余的内存。目前考虑管理的状态有：</p><ul><li>这 Page 是否被使用了</li><li>这个 Page 是不是最后一块分配的内存，方便我们释放内存时找到最后一块分配的内存</li></ul><p>我们可以使用一个 8 bit 的<code>flag</code>来记录这些信息，<code>flag bit[0]</code>表示是否已使用，<code>flag bit[1]</code>表示是否是最后一个分配的页面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Page Descriptor </span><br><span class="hljs-comment"> * flags:</span><br><span class="hljs-comment"> * - bit 0: flag if this page is taken(allocated)</span><br><span class="hljs-comment"> * - bit 1: flag if this page is the last page of the memory block allocated</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br> <span class="hljs-keyword">uint8_t</span> flags;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也就是每一个 Page 都由一个 8 bit 的结构体<code>struct Page</code>管理，我们总共分配了 8 个 Page 用来管理，一个 Page 占 4K，那么我们可以一个管理$8 \times 4096 = 32768$个 Page。那就刚好可以管理$32768 \times 4096 = 134217728 \text{bit}$内存=128M。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/2022/08/25/19-31-49-8eed060ecd2399b0c7b8bc8dba19ca01-20220825193148-7df975.png"></p><p>Page 分配与释放接口设计</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配连续n个可用物理页</span><br><span class="hljs-comment"> * - npages: 需要分配的页的个数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">page_alloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> npages)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">/* Note we are searching the page descriptor bitmaps. */</span><br> <span class="hljs-keyword">int</span> found = <span class="hljs-number">0</span>;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page_i</span> =</span> (struct Page *)HEAP_START;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (_num_pages - npages); i++) &#123;<br>  <span class="hljs-keyword">if</span> (_is_free(page_i)) &#123;<br>   found = <span class="hljs-number">1</span>;<br>   <span class="hljs-comment">/* </span><br><span class="hljs-comment">    * 找到第一个可用Page，继续判断是否有N个连续可用page</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page_j</span> =</span> page_i;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; (i + npages); j++) &#123;<br>    <span class="hljs-keyword">if</span> (!_is_free(page_j)) &#123;<br>     found = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">break</span>;<br>    &#125;<br>    page_j++;<br>   &#125;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 找到了连续的N个可用page，将N个page设置为已分配状态</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">if</span> (found) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page_k</span> =</span> page_i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; (i + npages); k++) &#123;<br>     _set_flag(page_k, PAGE_TAKEN);<br>     page_k++;<br>    &#125;<br>    page_k--;<br>    _set_flag(page_k, PAGE_LAST);<br>                <span class="hljs-comment">// 返回可用page首地址</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)(_alloc_start + i * PAGE_SIZE);<br>   &#125;<br>  &#125;<br>  page_i++;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 释放已分配的物理页</span><br><span class="hljs-comment"> * - p: 待释放的首地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">page_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * 判断非法输入，p不能为空或者超出最大可分配大小</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">if</span> (!p || (<span class="hljs-keyword">uint32_t</span>)p &gt;= _alloc_end) &#123;<br>  <span class="hljs-keyword">return</span>;<br> &#125;<br> <span class="hljs-comment">/* 计算出这个首地址p所在的page的描述符，也就是找到第几个描述符在管理这块内存 */</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">page</span> =</span> (struct Page *)HEAP_START;<br> page += ((<span class="hljs-keyword">uint32_t</span>)p - _alloc_start)/ PAGE_SIZE;<br> <span class="hljs-comment">/* 循环清空标识 */</span><br> <span class="hljs-keyword">while</span> (!_is_free(page)) &#123;<br>  <span class="hljs-keyword">if</span> (_is_last(page)) &#123;<br>   _clear(page);<br>   <span class="hljs-keyword">break</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>   _clear(page);<br>   page++;;<br>  &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex-listing 环境设置</title>
    <link href="/2022/08/21/LaTex-listing%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
    <url>/2022/08/21/LaTex-listing%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">% 代码块listing设置<br>\lstdefinestyle&#123;mppl-listing-style&#125;&#123;<br>    language         = java,                   % 语言类型<br>    backgroundcolor  = \color&#123;&#123;HTML&#125;&#123;F7F7F7&#125;&#125;, % 背景色<br>    numbers          = left,              % 行号显示位置<br>    xleftmargin      = 5em,               % 左边距<br>    xrightmargin     = 0em,               % 右边距<br>    aboveskip        = 2em,               % 上方留白<br>    belowskip        = 0em,               % 下方留白<br>    frame            = single,            % 代码块边框是单线条<br>    rulecolor        = \color&#123;black&#125;,    % 边框颜色<br>    frameround       = tttt,              % 边框圆角<br>    framesep         = 0.19em,            % 边框与代码间距<br>    rulesepcolor     = \color&#123;black&#125;,    % 阴影颜色<br>    framexleftmargin    = -2em,           % 左边框与代码距离<br>    framexrightmargin   = -5em,           % 右边框与代码距离<br>    framexbottommargin  = 2em,            % 下边框与代码距离<br>    framextopmargin     = 2em,            % 上边框与代码距离<br>    breaklines          = true,           % 代码超出边界换行<br>    tabsize             = 4,              % tab缩进<br>    numberstyle         = \color&#123;red&#125;,    % 行号颜色<br>    keywordstyle        = \color&#123;red&#125;,    % 关键字颜色<br>    identifierstyle     = \color&#123;listing-identifier&#125;,   % 变量颜色<br>    commentstyle        = \color&#123;listing-comment&#125;,      % 注释颜色<br><br>  basicstyle       = \color&#123;listing-text-color&#125;\small\ttfamily&#123;&#125;\linespread&#123;1.15&#125;, % print whole listing small<br>  abovecaptionskip = 0em,               % 上标题边距<br>  belowcaptionskip = 1.0em,             % 下标颜边距<br>  classoffset      = 0,                 % 类名偏移量<br>  sensitive        = true,              % 是否区分大小写<br>  morecomment      = [s][\color&#123;listing-javadoc-comment&#125;]&#123;/**&#125;&#123;*/&#125;,     <br>  stringstyle      = \color&#123;listing-string&#125;,<br>  showstringspaces = false,             % 是否显示字符串空格<br>  escapeinside     = &#123;/*@&#125;&#123;@*/&#125;, % Allow LaTeX inside these special comments<br>  literate         =<br>  &#123;á&#125;&#123;&#123;\&#x27;a&#125;&#125;1 &#123;é&#125;&#123;&#123;\&#x27;e&#125;&#125;1 &#123;í&#125;&#123;&#123;\&#x27;i&#125;&#125;1 &#123;ó&#125;&#123;&#123;\&#x27;o&#125;&#125;1 &#123;ú&#125;&#123;&#123;\&#x27;u&#125;&#125;1<br>  &#123;Á&#125;&#123;&#123;\&#x27;A&#125;&#125;1 &#123;É&#125;&#123;&#123;\&#x27;E&#125;&#125;1 &#123;Í&#125;&#123;&#123;\&#x27;I&#125;&#125;1 &#123;Ó&#125;&#123;&#123;\&#x27;O&#125;&#125;1 &#123;Ú&#125;&#123;&#123;\&#x27;U&#125;&#125;1<br>  &#123;à&#125;&#123;&#123;\`a&#125;&#125;1 &#123;è&#125;&#123;&#123;\&#x27;e&#125;&#125;1 &#123;ì&#125;&#123;&#123;\`i&#125;&#125;1 &#123;ò&#125;&#123;&#123;\`o&#125;&#125;1 &#123;ù&#125;&#123;&#123;\`u&#125;&#125;1<br>  &#123;À&#125;&#123;&#123;\`A&#125;&#125;1 &#123;È&#125;&#123;&#123;\&#x27;E&#125;&#125;1 &#123;Ì&#125;&#123;&#123;\`I&#125;&#125;1 &#123;Ò&#125;&#123;&#123;\`O&#125;&#125;1 &#123;Ù&#125;&#123;&#123;\`U&#125;&#125;1<br>  &#123;ä&#125;&#123;&#123;\&quot;a&#125;&#125;1 &#123;ë&#125;&#123;&#123;\&quot;e&#125;&#125;1 &#123;ï&#125;&#123;&#123;\&quot;i&#125;&#125;1 &#123;ö&#125;&#123;&#123;\&quot;o&#125;&#125;1 &#123;ü&#125;&#123;&#123;\&quot;u&#125;&#125;1<br>  &#123;Ä&#125;&#123;&#123;\&quot;A&#125;&#125;1 &#123;Ë&#125;&#123;&#123;\&quot;E&#125;&#125;1 &#123;Ï&#125;&#123;&#123;\&quot;I&#125;&#125;1 &#123;Ö&#125;&#123;&#123;\&quot;O&#125;&#125;1 &#123;Ü&#125;&#123;&#123;\&quot;U&#125;&#125;1<br>  &#123;â&#125;&#123;&#123;\^a&#125;&#125;1 &#123;ê&#125;&#123;&#123;\^e&#125;&#125;1 &#123;î&#125;&#123;&#123;\^i&#125;&#125;1 &#123;ô&#125;&#123;&#123;\^o&#125;&#125;1 &#123;û&#125;&#123;&#123;\^u&#125;&#125;1<br>  &#123;Â&#125;&#123;&#123;\^A&#125;&#125;1 &#123;Ê&#125;&#123;&#123;\^E&#125;&#125;1 &#123;Î&#125;&#123;&#123;\^I&#125;&#125;1 &#123;Ô&#125;&#123;&#123;\^O&#125;&#125;1 &#123;Û&#125;&#123;&#123;\^U&#125;&#125;1<br>  &#123;œ&#125;&#123;&#123;\oe&#125;&#125;1 &#123;Œ&#125;&#123;&#123;\OE&#125;&#125;1 &#123;æ&#125;&#123;&#123;\ae&#125;&#125;1 &#123;Æ&#125;&#123;&#123;\AE&#125;&#125;1 &#123;ß&#125;&#123;&#123;\ss&#125;&#125;1<br>  &#123;ç&#125;&#123;&#123;\c c&#125;&#125;1 &#123;Ç&#125;&#123;&#123;\c C&#125;&#125;1 &#123;ø&#125;&#123;&#123;\o&#125;&#125;1 &#123;å&#125;&#123;&#123;\r a&#125;&#125;1 &#123;Å&#125;&#123;&#123;\r A&#125;&#125;1<br>  &#123;€&#125;&#123;&#123;\EUR&#125;&#125;1 &#123;£&#125;&#123;&#123;\pounds&#125;&#125;1 &#123;«&#125;&#123;&#123;\guillemotleft&#125;&#125;1<br>  &#123;»&#125;&#123;&#123;\guillemotright&#125;&#125;1 &#123;ñ&#125;&#123;&#123;\~n&#125;&#125;1 &#123;Ñ&#125;&#123;&#123;\~N&#125;&#125;1 &#123;¿&#125;&#123;&#123;?`&#125;&#125;1<br>  &#123;…&#125;&#123;&#123;\ldots&#125;&#125;1 &#123;≥&#125;&#123;&#123;&gt;=&#125;&#125;1 &#123;≤&#125;&#123;&#123;&lt;=&#125;&#125;1 &#123;„&#125;&#123;&#123;\glqq&#125;&#125;1 &#123;“&#125;&#123;&#123;\grqq&#125;&#125;1<br>  &#123;”&#125;&#123;&#123;&#x27;&#x27;&#125;&#125;1    <br>&#125;       <br></code></pre></td></tr></table></figure><h1 id="backgroundcolor-背景颜色"><a href="#backgroundcolor-背景颜色" class="headerlink" title="backgroundcolor 背景颜色"></a>backgroundcolor 背景颜色</h1><h1 id="numbers-代码行号"><a href="#numbers-代码行号" class="headerlink" title="numbers 代码行号"></a>numbers 代码行号</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    numbers             = left,             % 行号靠左<br>    basicstyle          = \ttfamily,        % 基本代码风格<br>    keywordstyle        = \bfseries,        % 关键字风格<br>    commentstyle        = \ttfamily,        % 注释的风格<br>    frame       = single,                   % 阴影效果<br>    escapeinside=``,                        % 英文分号中可写入中文<br>    xleftmargin=2em,xrightmargin=2em, aboveskip=1em,<br>    breaklines          =   true,<br>    language            = C,                % 语言选C<br>&#125; <br><br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211022328.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    numbers             = right,            % 行号靠左<br>    basicstyle          = \ttfamily,        % 基本代码风格<br>    keywordstyle        = \bfseries,        % 关键字风格<br>    commentstyle        = \ttfamily,        % 注释的风格<br>    frame       = single,                   % 阴影效果<br>    escapeinside=``,                        % 英文分号中可写入中文<br>    xleftmargin=2em,xrightmargin=2em, aboveskip=1em,<br>    breaklines          =   true,<br>    language            = C,                % 语言选C<br>&#125; <br><br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211015076.png"></p><h2 id="stepnumber-间隔显示行号"><a href="#stepnumber-间隔显示行号" class="headerlink" title="stepnumber 间隔显示行号"></a>stepnumber 间隔显示行号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    numbers             = right,            % 行号靠左<br>    stepnumber          = 2,                % 每两行显示一次行号<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="firstnumber-开始行号"><a href="#firstnumber-开始行号" class="headerlink" title="firstnumber 开始行号"></a>firstnumber 开始行号</h2><ul><li>firstnumber = 10 开始行号为 10</li><li>firstnumber = last 开始行号为上一段 listing 的结束行号</li></ul><h1 id="xleftmargin-xrightmargin-aboveskip-below-距离外部元素距离"><a href="#xleftmargin-xrightmargin-aboveskip-below-距离外部元素距离" class="headerlink" title="xleftmargin/xrightmargin/aboveskip/below 距离外部元素距离"></a>xleftmargin/xrightmargin/aboveskip/below 距离外部元素距离</h1><p>设置代码块上下左右的距离，与外部元素的距离，而不是代码与边框的距离。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    basicstyle          = \ttfamily,        % 基本代码风格<br>    numbers             = left,            % 行号靠左<br>    keywordstyle        = \bfseries,        % 关键字风格<br>    commentstyle        = \ttfamily,        % 注释的风格<br>    frame       = single,                   % 阴影效果<br>    escapeinside=``,                        % 英文分号中可写入中文<br>    xleftmargin=0em,xrightmargin=0em, aboveskip=0em,belowskip=0em,<br>    breaklines          =   true,<br>    language            = C,                % 语言选C<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211031682.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Bash">\lstset&#123;<br>    basicstyle          = \ttfamily,        % 基本代码风格<br>    numbers             = left,            % 行号靠左<br>    keywordstyle        = \bfseries,        % 关键字风格<br>    commentstyle        = \ttfamily,        % 注释的风格<br>    frame               = single,                   % 线框<br>    escapeinside        =``,                        % 英文分号中可写入中文<br>    xleftmargin         =5em,<br>    xrightmargin        =0em, <br>    aboveskip           =2em,<br>    belowskip           =0em,<br>    breaklines          =   <span class="hljs-literal">true</span>,<br>    language            = C,                % 语言选C<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211030490.png"></p><h1 id="frame-边框样式"><a href="#frame-边框样式" class="headerlink" title="frame 边框样式"></a>frame 边框样式</h1><p>设置边框样式：</p><ul><li>none:无框</li><li>single:单线框</li><li>leftline,topline,rightline,bottomline:上下左右的线</li><li>ltrb:上面参数的缩写，frame=lr 表示左右有线</li><li>LTRB:大写表示双线</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>  frame               = single,        % 线框<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211022328.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>  frame               = shadowbox,        % 阴影<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://secure2.wostatic.cn/static/3tyNfsqexLHfHPpcdEmPzT/image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>  frame               = LR,        % 左右边框双线<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211413702.png"></p><h1 id="rulesepcolor-阴影颜色"><a href="#rulesepcolor-阴影颜色" class="headerlink" title="rulesepcolor 阴影颜色"></a>rulesepcolor 阴影颜色</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>  frame               = shadowbox,        % 阴影<br>  rulesepcolor= \color&#123; red!20!green!20!blue!20&#125; , % 阴影颜色<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211415065.png"></p><h1 id="rulecolor-边框颜色"><a href="#rulecolor-边框颜色" class="headerlink" title="rulecolor 边框颜色"></a>rulecolor 边框颜色</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    rulecolor           = \color&#123;red&#125;,      % 边框颜色<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211422584.png"></p><h1 id="frameround-边框倒角"><a href="#frameround-边框倒角" class="headerlink" title="frameround 边框倒角"></a>frameround 边框倒角</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>  frameround          = fftt,        % 边框倒角，f表示尖角，t表示倒角，顺序是第一个字母表示右上角，顺时针<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211419962.png"></p><h1 id="framesep-边框与代码的距离"><a href="#framesep-边框与代码的距离" class="headerlink" title="framesep 边框与代码的距离"></a>framesep 边框与代码的距离</h1><p>代码不会移动，动的是边框。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    framesep           = 6em,              % 边框与代码的距离<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211435956.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    framesep           = 6em,              % 边框与代码的距离<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211436155.png"></p><h1 id="framexleftmargin-framexrightmargin-frameytopmargin-frameybottommargin-边框与代码距离"><a href="#framexleftmargin-framexrightmargin-frameytopmargin-frameybottommargin-边框与代码距离" class="headerlink" title="framexleftmargin/framexrightmargin/frameytopmargin/frameybottommargin 边框与代码距离"></a>framexleftmargin/framexrightmargin/frameytopmargin/frameybottommargin 边框与代码距离</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    framexleftmargin    = -2em,           % 左边框与代码距离<br>    framexrightmargin   = -5em,           % 右边框与代码距离<br>    framexbottommargin  = 2em,            % 下边框与代码距离<br>    framextopmargin     = 2em,            % 上边框与代码距离<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211442407.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    framexleftmargin    = 1em,           % 左边框与代码距离<br>    framexrightmargin   = 1em,           % 右边框与代码距离<br>    framexbottommargin  = 0em,            % 下边框与代码距离<br>    framextopmargin     = 0em,            % 上边框与代码距离<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211444676.png"></p><h1 id="breaklines-强制换行"><a href="#breaklines-强制换行" class="headerlink" title="breaklines 强制换行"></a>breaklines 强制换行</h1><p>设置代码超长时自动换行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    breaklines         = false,           % 不换行<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211448116.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\lstset&#123;<br>    breaklines         = true,           % 不换行<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211447939.png"></p><h2 id="numberstyle-keywordstyle-identifierstyle-commentstyle-commentstyle-行号、关键字、标识符、注释的样式"><a href="#numberstyle-keywordstyle-identifierstyle-commentstyle-commentstyle-行号、关键字、标识符、注释的样式" class="headerlink" title="numberstyle/keywordstyle/identifierstyle/commentstyle/commentstyle 行号、关键字、标识符、注释的样式"></a>numberstyle/keywordstyle/identifierstyle/commentstyle/commentstyle 行号、关键字、标识符、注释的样式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">\definecolor&#123;listing-background&#125;&#123;HTML&#125;&#123;F7F7F7&#125;<br>\definecolor&#123;listing-rule&#125;&#123;HTML&#125;&#123;B3B2B3&#125;<br>\definecolor&#123;listing-numbers&#125;&#123;HTML&#125;&#123;B3B2B3&#125;<br>\definecolor&#123;listing-text-color&#125;&#123;HTML&#125;&#123;000000&#125;<br>\definecolor&#123;listing-keyword&#125;&#123;HTML&#125;&#123;435489&#125;<br>\definecolor&#123;listing-identifier&#125;&#123;HTML&#125;&#123;435489&#125;<br>\definecolor&#123;listing-string&#125;&#123;HTML&#125;&#123;00999A&#125;<br>\definecolor&#123;listing-comment&#125;&#123;HTML&#125;&#123;8E8E8E&#125;<br>\definecolor&#123;listing-javadoc-comment&#125;&#123;HTML&#125;&#123;006CA9&#125;<br><br>\lstset&#123;<br>    numberstyle         = \color&#123;listing-numbers&#125;,      % 行号颜色<br>    keywordstyle        = \color&#123;listing-keyword&#125;,      % 关键字颜色<br>    identifierstyle     = \color&#123;listing-identifier&#125;,   % 变量颜色<br>    commentstyle        = \color&#123;listing-comment&#125;,      % 注释颜色<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208211618598.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
      <tag>listing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 书写 PDF 输出优雅的解决方案</title>
    <link href="/2022/08/20/Markdown%E4%B9%A6%E5%86%99PDF%E8%BE%93%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2022/08/20/Markdown%E4%B9%A6%E5%86%99PDF%E8%BE%93%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="折腾背景"><a href="#折腾背景" class="headerlink" title="折腾背景"></a>折腾背景</h1><p>Markdown 的简便性是 LaTeX 无法替代的，LaTeX 对排版的精准控制能力又是 Markdown 无法比拟的。一直在寻找一种能够将 Markdown 优雅地转换成 PDF 的解决方案，虽然早就听说也使用过 Pandoc 这把瑞士军刀，但是它太过强大，以致于一直都没用明白。只会简单的转换命令，但是实际效果并不好，最近学会了使用 LaTeX 模板的功能，这才让我眼前一亮，这才是我想要的结果。</p><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><iframe src="/myjs/pdfjs/web/viewer.html?file=/misc/Markdown书写PDF输出优雅的解决方案.pdf" style="width:100%;height:600px"></iframe><h1 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h1><p>Markdown 生成 PDF 主要需要使用 Pandoc 和 LaTeX 两个工具，具体安装方式如下：</p><h2 id="Pandoc-的安装"><a href="#Pandoc-的安装" class="headerlink" title="Pandoc 的安装"></a>Pandoc 的安装</h2><p>Pandoc 是由 John MacFarlane 开发的标记语言转换工具，可实现不同标记语言间的格式转换。</p><ul><li><p>Windows 下的安装：</p><ul><li>下载<a href="https://github.com/jgm/pandoc/releases">安装包</a>直接安装即可</li><li>如果安装了 Chocolate：<code>choco install pandoc</code></li><li>如果安装了 winget：<code>winget install pandoc</code></li></ul></li><li><p>Linux/FreeBSD下的安装：</p><ul><li>Pandoc 已经包含在大部分 Linux 发行版的官方仓库中，直接使用诸如<code>apt/dnf/yum/pacman</code>之类的安装工具直接安装即可</li></ul></li><li><p>macOS 下的安装：</p><ul><li><code>brew install pandoc</code></li></ul></li></ul><blockquote><p>详细的安装说明参见：<a href="https://pandoc.org/installing.html">官方安装文档</a></p></blockquote><h2 id="LaTeX-的安装"><a href="#LaTeX-的安装" class="headerlink" title="LaTeX 的安装"></a>LaTeX 的安装</h2><p>LaTeX 工具，建议安装 texlive。</p><ul><li>Windows 下的安装：<ul><li><a href="https://zhuanlan.zhihu.com/p/41855480">参考该文章</a>下载完整 texlive，注意安装后需要再安装 cjk，cjk-fonts 等相关 package</li></ul></li><li>Linux/FreeBSD下的安装：<ul><li>使用 <code>apt/dnf/yum/pacman/pkg</code> 等安装工具安装 texlive、texlive-latex 等相关软件包</li></ul></li><li>macOS 下的安装：<ul><li>使用 HomeBrew 安装 texlive 即可</li></ul></li></ul><h1 id="模板配置"><a href="#模板配置" class="headerlink" title="模板配置"></a>模板配置</h1><h2 id="配置-Pandoc-模板"><a href="#配置-Pandoc-模板" class="headerlink" title="配置 Pandoc 模板"></a>配置 Pandoc 模板</h2><p>为保证生成的 pdf 格式（自动插入封面、目录页、页眉页脚等信息），在本地环境中安装模板，具体步骤是：</p><ul><li>下载<a href="https://github.com/Dunky-Z/MPPL">MPPL: Markdown to PDF with Pandoc via Latex</a>仓库</li><li>将<code>template/mppl.latex</code>拷贝到<code>*/pandoc/templates</code>目录下<ul><li>Window 下：<code>C:/Users/USERNAME/AppData/Roaming/pandoc/templates</code>，如果<code>Roaming</code>没有<code>pandoc</code>目录，请手动创建！</li><li>Linux/FreeBSD/MacOS：<code>~/.pandoc/templates/</code></li></ul></li></ul><h2 id="配置-LaTeX-模板"><a href="#配置-LaTeX-模板" class="headerlink" title="配置 LaTeX 模板"></a>配置 LaTeX 模板</h2><p>模板定制主要修改模板最前面的<strong>模板基础配置</strong>相关内容，主要可修改的包括：</p><ul><li>公司和组织，目前默认是”MPPL”</li><li>正文缩进，目前默认是 2em（2 个中文字符，4 个英文字符）</li><li>主要中文字体和英文字体：目前都是微软雅黑</li><li>页眉、页脚展示内容，目前是：<ul><li>左页眉：title</li><li>右页眉：”企业机密 - 禁止外传”</li><li>左页脚：company</li><li>右页脚：页码</li></ul></li></ul><h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h2><p>目前页面默认的字体是微软雅黑，对于非 Windows 系统，可能不存在该字体，则有以下两种解决方案：</p><ol><li>手工安装微软雅黑字体（需要 msyh,msyhbd 两个文件）</li><li>修改为其他字体，如苹方、文泉驿等</li></ol><p>若需要多个团队共同使用，建议采用方案一。</p><h1 id="如何生成-PDF"><a href="#如何生成-PDF" class="headerlink" title="如何生成 PDF"></a>如何生成 PDF</h1><h2 id="PDF-文件指定-metadata-信息"><a href="#PDF-文件指定-metadata-信息" class="headerlink" title="PDF 文件指定 metadata 信息"></a>PDF 文件指定 metadata 信息</h2><p>在每个 Markdown 最前面增加以下主要 metadata 信息，metadata 内容开始行内容为三个“-”，结束行为三个“.”，示例如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">title:</span> <span class="hljs-string">&quot;MPPL&quot;</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;0.1&quot;</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&quot;Markdown to PDF with Pandoc via LaTeX&quot;</span><br><span class="hljs-attr">date:</span> <span class="hljs-string">&quot;2022-08&quot;</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">&quot;Dominic&quot;</span><br><span class="hljs-attr">company:</span> <span class="hljs-string">COMPANYNAME</span><br><span class="hljs-attr">file-code:</span> <span class="hljs-string">COMPANY-DEPARTMENT-00000000</span><br><span class="hljs-attr">logo:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">logo-url:</span> <span class="hljs-string">./img/logo.png</span><br><span class="hljs-attr">history:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">version:</span> <span class="hljs-string">V0.1</span><br>    <span class="hljs-attr">author:</span> <span class="hljs-string">Dominic</span><br>    <span class="hljs-attr">date:</span> <span class="hljs-number">2022-08-19</span><br>    <span class="hljs-attr">desc:</span> <span class="hljs-string">创建文档</span><br></code></pre></td></tr></table></figure><p>其他可选配置项目如下：</p><ul><li>header-left: 左页眉</li><li>header-right: 右页眉</li><li>footer-left: 左页脚</li><li>footer-right: 右页脚</li><li>CJKmainfont: 主要中文字体</li><li>mainfont: 主要字体</li><li>lot: 是否创建表格目录</li><li>lof: 是否创建图片目录</li></ul><blockquote><p>可选配置项中，建议除了 subtitle 外，全部在模板中定制，不在 Markdown 文件中定制</p></blockquote><h2 id="Markdown-其他编写要求"><a href="#Markdown-其他编写要求" class="headerlink" title="Markdown 其他编写要求"></a>Markdown 其他编写要求</h2><p>Pandoc 默认使用的 pandoc_markdown 格式，为避免 Markdown 转 pdf 格式异常，在编写 Markdown 的时候有几个原则要求：</p><ul><li>每个标题前后都必须有空行</li><li>每个表格前后都必须有空行</li><li>每个代码块前后收必须有空行</li><li>每个列表前后必须有空行</li></ul><p><strong>总之，不同文本类型之间都要有空行</strong>。</p><h2 id="生成-PDF-文件"><a href="#生成-PDF-文件" class="headerlink" title="生成 PDF 文件"></a>生成 PDF 文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc --listings --pdf-engine=xelatex --template=mppl.latex README.md -o README.pdf<br></code></pre></td></tr></table></figure><h1 id="摆脱命令行，优雅的-VSCode-书写转换方案"><a href="#摆脱命令行，优雅的-VSCode-书写转换方案" class="headerlink" title="摆脱命令行，优雅的 VSCode 书写转换方案"></a>摆脱命令行，优雅的 VSCode 书写转换方案</h1><h2 id="VSCode-与插件安装"><a href="#VSCode-与插件安装" class="headerlink" title="VSCode 与插件安装"></a>VSCode 与插件安装</h2><p>打开 VSCode 编辑器，在插件页搜索 <code>markdown-preview-enhanced</code>，接着点击 <code>Install</code> 按钮。详情参考<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/vscode-installation">VS Code 安装 MPE</a>。</p><blockquote><p>Markdown Preview Enhanced 以下简称 MPE</p></blockquote><h2 id="使用-VSCode-书写-Markdown"><a href="#使用-VSCode-书写-Markdown" class="headerlink" title="使用 VSCode 书写 Markdown"></a>使用 VSCode 书写 Markdown</h2><p>新建文件以<code>.md</code>为后缀即可开始编辑 Markdown 文件，使用 MPE 实时预览与导出。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208201459472.png"></p><h2 id="配置-MPE-使用-Pandoc-导出"><a href="#配置-MPE-使用-Pandoc-导出" class="headerlink" title="配置 MPE 使用 Pandoc 导出"></a>配置 MPE 使用 Pandoc 导出</h2><p>右击 MPE 的预览区域，可以看到 MPE 提供多种导出 PDF 的方案，如使用 Chrome 的 Puppeteer 导出，Prince 导出，Pandoc 导出等等。</p><p>在未使用 Pandoc 前，我也一直使用 MPE 提供的 Chrome 方式导出，但是导出的 PDF 排版总是不尽如意。现在介绍如何使用 Pandoc 方式导出。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208201500627.png"></p><p>创建 PDF 文档，你需要在 <code>markdown</code> 文件中的 <code>front-matter</code> 里声明 <code>pdf_document</code> 的输出类型：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-meta">---</span><br><span class="hljs-attr">output:</span><br>  <span class="hljs-attr">pdf_document:</span><br>    <span class="hljs-attr">latex_engine:</span> <span class="hljs-string">xelatex</span><br>    <span class="hljs-attr">pandoc_args:</span> [<span class="hljs-string">--template=mppl.latex</span>,<span class="hljs-string">--listings</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ul><li><p><code>front-matter</code>：文章的最开头，也就是上文元数据放的地方。和元数据放在一起即可，如图所示：</p><p>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208201526775.png"></p></li><li><p><code>latex_engine</code>：默认情况下 PDF 文档由 <code>pdflatex</code> 生成。你可以用 <code>latex_engine</code> 选项来定义你想用的引擎。支持的引擎有 <code>pdflatex</code>，<code>xelatex</code>，以及 <code>lualatex</code>。这里需要使用<code>xelatex</code>。</p></li><li><p><code>pandoc_args</code>：配置 Pandoc 接受的一些参数，这里我们使用 <code>--template=mppl.latex</code> 和 <code>--listings</code> 来指定模板和使用 <code>listings</code>。这里配置的参数就是执行 Pandoc 时使用的参数，以后就不需要命令行输入了。这里使用上文的<code>mppl.latex</code>模板。</p></li></ul><p>配置完之后，右击预览界面，选择 Pandoc 导出，稍等片刻，即可生成 PDF 文件。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208201537508.png"></p><h1 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h1><h2 id="LaTeX-相关错误"><a href="#LaTeX-相关错误" class="headerlink" title="LaTeX 相关错误"></a>LaTeX 相关错误</h2><p>VSCode 导出出错时报错信息较短，并且常常不知道具体报错原因及位置，因为是 LaTeX 转换成 PDF 的过程中出现的错误。报错位置是 LaTeX 中间源码的位置，而不是 VSCode 中的位置。这时候我常用的方法是先将 Markdown 转为 LaTeX，然后再转为 PDF，在 LaTeX 编辑器里就可以看到错误位置了。</p><p>比如下面这个错误，我们能看到一些报错信息<code>cant use \spacefactor in math mode</code>，但是并不知道具体哪里的错误。从信息里可以看出和<code>\LaTex</code>有关，大概能推测出是使用了这个命令，因为文章里使用了这个命令的地方只有一处。但是如果有其他的错误，就很难确定了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208201655326.png"></p><h3 id="Markdown-转换-LaTeX"><a href="#Markdown-转换-LaTeX" class="headerlink" title="Markdown 转换 LaTeX"></a>Markdown 转换 LaTeX</h3><p>这里还是以模板仓库的<code>README.md</code>为例，当然这个文件是可以正常转换 PDF 的，不会报错。这里只是拿<code>README.md</code>做一个如何使用命令的演示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc --listings --template=mppl.latex -s README.md -o README.tex<br></code></pre></td></tr></table></figure><h3 id="LaTeX-编辑器打开，以-TexStudio-为例"><a href="#LaTeX-编辑器打开，以-TexStudio-为例" class="headerlink" title="LaTeX 编辑器打开，以 TexStudio 为例"></a>LaTeX 编辑器打开，以 TexStudio 为例</h3><p>打开<code>README.tex</code>文件，编译：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208201708811.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208201717673.png"></p><p>我们可以快速的定位到问题出现的位置，只要搜索相关问题即可。</p><blockquote><p>\LaTeX{} 这个宏不能用在数学模式下。但是因为我在 Markdown 里必须使用美元符号<code>$$</code>才能表示 LaTeX 环境，才能正确输出 LaTeX 符号，而 Markdown 转换成 LaTeX 源码时，这个宏就会被包裹在数学环境里，就会报错。如果我想在 PDF 里显示这个符号，那就在 Markdown 里不使用美元符号<code>$$</code>，而是直接输入<code>\LaTeX&#123;&#125;</code>即可，再导出 PDF 时就不会报错。</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
      <tag>Markdown</tag>
      
      <tag>Pandoc</tag>
      
      <tag>PDF</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译错误以英文输出</title>
    <link href="/2022/08/16/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E4%BB%A5%E8%8B%B1%E6%96%87%E8%BE%93%E5%87%BA/"/>
    <url>/2022/08/16/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E4%BB%A5%E8%8B%B1%E6%96%87%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>因为终端配置的原因，编译的结果输出是中文，这样搜索问题不如英文的表述精确。配置终端的语言为英文，就可以输出英文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LANG=en_US<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 cast from pointer to integer of different size</title>
    <link href="/2022/08/16/%E8%A7%A3%E5%86%B3cast-from-pointer-to-integer-of-different-size/"/>
    <url>/2022/08/16/%E8%A7%A3%E5%86%B3cast-from-pointer-to-integer-of-different-size/</url>
    
    <content type="html"><![CDATA[<h1 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dst, ...)</span> </span>&#123;<br>    <span class="hljs-comment">// some code</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> offset = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) dst % <span class="hljs-number">8</span>; <span class="hljs-comment">// warning here!</span><br>    <span class="hljs-comment">// some code continue...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>写驱动程序时经常会直接对地址进行修改，配置寄存器的值，也会将地址的值作为数据进行传递，这就会遇到一个问题，指针强转成整型，类型不匹配数据丢失的问题。</p><h1 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h1><p>出现这个警告的原因是，将<code>void*</code>类型强转成<code>unsigned int</code>是不可移植的。什么叫<strong>不可移植</strong>呢？</p><p>我们知道指针类型，在 32 位系统下是 4 字节，在 64 位系统下是 8 字节，而<code>unsigned int</code>不管在什么系统下都是是 4 字节，所以，如果将<code>void*</code>类型强转成<code>unsigned int</code>，在 64 位系统下就没有足够的空间保存真正的数据。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="粗暴地用double来接收"><a href="#粗暴地用double来接收" class="headerlink" title="粗暴地用double来接收"></a>粗暴地用<code>double</code>来接收</h2><p>先接收，再截断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dst, ...)</span> </span>&#123;<br>    <span class="hljs-comment">// some code</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> offset = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">double</span>) dst % <span class="hljs-number">8</span>; <span class="hljs-comment">// warning here!</span><br>    <span class="hljs-comment">// some code continue...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="uintptr-t"><a href="#uintptr-t" class="headerlink" title="uintptr_t"></a>uintptr_t</h2><p><code>uintptr_t</code> 保证足够宽，以便将 <code>void*</code> 转换为 <code>uintptr_t</code> 并再次返回将产生原始指针值。还有一个类型 <code>intptr_t</code>，它是有符号的；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-comment">// 或者 &lt;inttypes.h&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dst, ...)</span> </span>&#123;<br>    <span class="hljs-comment">// some code</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> offset = (<span class="hljs-keyword">uintptr_t</span>) dst % <span class="hljs-number">8</span>; <span class="hljs-comment">// warning here!</span><br>    <span class="hljs-comment">// some code continue...</span><br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DEBUG 原理</title>
    <link href="/2022/08/14/DEBUG%E5%8E%9F%E7%90%86/"/>
    <url>/2022/08/14/DEBUG%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>了解调试原理时看到了一个质量比较高的视频，<a href="https://www.bilibili.com/video/BV1iN411Z7jk?spm_id_from=333.999.0.0&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">【蛋饼嵌入式】一起探究调试原理</a>。UP 通俗，形象地讲解了 DEBUG 的一些原理，值得反复观看，但是视频不如文字查阅效率高，遂记录了以下文稿内容。</p><h2 id="什么是-JTAG"><a href="#什么是-JTAG" class="headerlink" title="什么是 JTAG"></a>什么是 JTAG</h2><p>1985 年，几家半导体厂商为了解决板级测试的问题，成立了 Joint Test Action Group（JTAG）联合测试行动小组，他们希望将测试点和测试电路集成在芯片内部引脚处。同时，留出一个统一协议的接口，大家都能通过这个接口来访问芯片的输入与输出状态。这样就省去了板级测试是的物理接触，同时还能进行逻辑性调试。后来 IEEE 组织，将这个方案制定成了标准 IEEE 1149.1，这就是现在我们常听到的 JTAG 调试。</p><h2 id="边界扫描技术"><a href="#边界扫描技术" class="headerlink" title="边界扫描技术"></a>边界扫描技术</h2><p>实现 JTAG 调试最重要的一个技术就是边界扫描技术，核心思想是<strong>给芯片的每一个输入输出引脚，添加一个移位寄存器单元，也称为边界扫描单元</strong>（Boundary Scan Cell，BSC）。通过它一边可以实现对芯片输出数据的截取，另一边可以完成对输入数据的替代。正常运行状态下，这些寄存器又是透明般的存在。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208141648874.gif"></p><p>这些位于引脚边界的移位寄存器，还可以串在一起，形成一条边界扫描链，以串行的方式从外部更新扫描单元上的数据，以及对外输出边界扫描单元捕获的数据。如果板上有多个这样的芯片，他们还能以菊花链的形式串联在一起，这样就大大方便了测试的过程。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208141654770.gif"></p><p>要实现对内部移位寄存器单元或者说对整个扫描链的访问和操作，便依赖于 JTAG 调试协议和相应的物理接口。JTAG 标准接口包括以下几个部分：</p><ul><li>TDI(Test Data In)</li><li>TDO(Test Data Out)</li><li>TCLK(Test Clock)</li><li>TMS(Test Mode Select)</li><li>TRST(Test Reset)：可选，用于复位</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208141655524.png"></p><p>调试逻辑的实现，是通过芯片内部的 TAP（Test Access Port）来完成的。模式状态信号 TMS 配合测试时钟信号 TCLK，以一定的时序进入到 TAP 控制器后，由 TAP 控制器内部的状态机转化为相应的控制动作。从而完成数据的移位，引脚状态的捕获和更新。</p><p>设备 ID 寄存器构成的扫描链，板卡一连上调试器，通过对这条扫描链的访问，就能够识别到被调试芯片的信号。存放调试机制相关配置的数据寄存器，所构成的扫描链，后面断点和单步调试时就会用到。以及移位的 BYPASS 寄存器，当调试链路上有多个芯片连接时，来减少总调试链路的长度。</p><p>以上都属于数据寄存器构成扫描链，因为想要在他们之间进行切换，需要引入另外的指令寄存器，以及对应的扫描链，这样调试主机将不同的调试命令写到指令寄存器中，就可以选通需要调试的数据链路。数据与指令寄存器两种链路的切换，就通过 TAP 控制器完成。</p><blockquote><p>补充：<br>如果芯片支持 JTAG 调试，那么芯片上就必须有上述的四个接口，TDI，TDO，TCLK，TMS。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208141725205.png"><br>芯片外有个 Adapter 与之 Pin to Pin 连接，负责协议转换，把 USB 的 JTAG 控制信息按 JTAG 协议转换输出，满足协议定义的电气特性。<br>Adapter 与 Host 连接，Host 可以是我们的 PC，也可以是另一个嵌入式调试器。<br>Host 上通常需要运行一些软件，如 OpenOCD，负责把 GDB 的高级别命令转换成 JTAG 命令，并通过特定 Adapter 的要求进行打包，调用 OS 提供的 USB/ETH/PCI 驱动发送出去。<br>GDB 与 OpenOCD 通过一些远程协议，如 TCP/IP，进行通信。这样就能够调试 Chip。</p></blockquote><h2 id="断点是如何实现的？"><a href="#断点是如何实现的？" class="headerlink" title="断点是如何实现的？"></a>断点是如何实现的？</h2><p>通过以上 JTAG 调试接口，我们已经能够测试引脚的输入输出了，同时也获得了观察和改变芯片内部数据的机会，那么接下来我们如何进行调试呢？比如打个断点？</p><p>断点作为一种干预性调试，根据调试行为的不同，分为监控模式和中止模式。</p><ul><li>监控模式（软件断点）：会触发异常，交由相应的软件程序来处理，处理器仍然处于运行状态。</li><li>中止模式（硬件断点），使处理器进入非正常运行的调试状态。</li></ul><p>以 ARM 架构来说，最初工程师想到的办法是插入一条指令集中没有定义的无效指令，来<strong>替换掉希望打断指令处的源指令</strong>。这样内核运行到这条指令时，就会进入到无效指令的服务程序，在这个异常的服务程序中，我们再去做想要的调试操作，操作完成后，还原当时被替换的指令。并继续执行。</p><p>后来 ARMv5 开始引入专门用于调试的<code>BKPT</code>指令，类似与 X86 指令集的<code>INT3</code>指令，但不管是不是专用指令，他们都属于软件中断。这意味着我想要实时地添加这种断点，就要求能够随时地更改程序，插入断点指令，而一般只有程序运行在 RAM 上，才方便这样操作。那如果直接从 FLASH 上取址运行的程序，因为 FLASH 先擦后写的物理特性，是无法通过随意插入指令来实现断点的。更不要说从只读存储器上运行的程序，比如说固化在 BIOS 中上电自检 POST 程序，面对这种情况，需要的就是硬件断点。</p><p>硬件断点顾名思义，需要额外的硬件逻辑支持，主要起的作用就是<strong>暂存和比较</strong>，我们把这种实现特定逻辑的组合电路，称为<strong>宏单元</strong>（Macro Cell）。</p><p>还记得我们前面说过 JTAG 协议，支持自定义扩展扫描链吗？硬件断点宏单元的控制和比较两种数据寄存器，就可以作为两条拓展扫描链，加入到 JTAG 调试框架中。</p><p>你在调试软件中按下一个按钮，对应的那行代码地址，就会通过上述扫描链，被记录到断点宏单元相应的寄存器中，当然，调试器能够知道某行代码的地址，是依赖于编译时生成的 ELF 文件中的符号表信息。而当程序正常运行取址时，如果宏单元的寄存器，发现了总线上出现了记录过的地址，比较器就会发出调试状态信号，CPU 接收到这个信号后暂停运行，进入调试模式或者异常。</p><p>因为每打一个断点，都需要宏单元相应的寄存器来保存地址信息。而寄存器数量是有限的，所以调试软件一旦和芯片建立起了连接，就会通过上述的另外一条控制寄存器获得该硬件断点宏单元所支持的最大断点数，这样你在调试过程中如果断点打多了，调试器就会报错。</p><h2 id="为什么调试器能够烧录程序呢？"><a href="#为什么调试器能够烧录程序呢？" class="headerlink" title="为什么调试器能够烧录程序呢？"></a>为什么调试器能够烧录程序呢？</h2><p>正常情况下，CPU 内核通过内部的系统总线，从 FLASH 或者 RAM 中获取运行的指令，交换数据，并在一定的驱动程序下，实现对 FLASH 的擦除和写入操作。为了把指令和数据直接给 CPU 内核，我们还需要定义一条扫描链，这条扫描链直接在系统总线上开了一个口子，通过上位机的调试信号，把相关的操作指令直接传到总线上，供 CPU 内核取用。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208141752418.gif"></p><p>那么整个调试器的下载过程是这样的：</p><ul><li>第一，通过调试器使得 CPU 进入调试模式；</li><li>第二，通过总线扫描链将 FLASH 编程算法与即将被下载的用户程序放到 RAM 中；</li><li>第三，将 CPU 的 PC 指针指向刚刚搬运完成的 RAM 地址起始处，并退出调试状态；</li><li>第四，CPU 将在正常状态下运行 RAM 中的 FLASH 编程算法。将用户代码烧录到确定位置上，执行完成后回到调试状态。</li></ul><p>如果 RAM 空间不够大，以上操作还需要重复多次执行。</p><p>需要注意的是，在第二步操作 RAM 时，是处于调试状态下，而调试时钟的速率是无法满足 RAM 或者 FLASH 的访问速率要求的，所以在这一过程中，CPU 会频繁的在系统时钟与调试时钟之间切换</p><p>调试时钟下，总线扫描链先传递来要写入的数据和 RAM 地址，CPU 先分别暂存在内部通用寄存器中，接着扫描链传递写入指令，并切换为系统时钟。CPU 在正常状态下执行搬运指令，往 RAM 里写入数据，执行完成后回到调试状态，继续通过扫描链传递后面要写入的值，</p><h2 id="OpenOCD-Open-On-Chip-Debugger"><a href="#OpenOCD-Open-On-Chip-Debugger" class="headerlink" title="OpenOCD (Open On-Chip Debugger)"></a>OpenOCD (Open On-Chip Debugger)</h2><p>OpenOCD（Open On-Chip Debugger）开源片上调试器，是一款开源软件，最初是由 Dominic Rath 同学还在大学期间发起的（2005 年）项目。OpenOCD 旨在提供针对嵌入式设备的调试、系统编程和边界扫描功能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1iN411Z7jk?spm_id_from=333.999.0.0&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">【蛋饼嵌入式】饮茶先？DEBUG 先！一起探究调试原理_哔哩哔哩_bilibili</a><br><a href="https://zhuanlan.zhihu.com/p/125145986">浅谈 RISC-V 的 DEBUG 系统及其仿真 - 知乎</a><br><a href="https://www.bilibili.com/video/BV1s54y1Z7Zj/?spm_id_from=333.788&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">ESP32 JTAG Debug 01: JTAG 接口简介_哔哩哔哩_bilibili</a>+</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>GDB</tag>
      
      <tag>嵌入式</tag>
      
      <tag>芯片开发</tag>
      
      <tag>硬件</tag>
      
      <tag>JTAG</tag>
      
      <tag>OpenOCD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保持 SSH 连接</title>
    <link href="/2022/08/13/%E4%BF%9D%E6%8C%81SSH%E8%BF%9E%E6%8E%A5/"/>
    <url>/2022/08/13/%E4%BF%9D%E6%8C%81SSH%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>SSH 总是被强行中断，尤其是用 VSCode 代码写的好好的，突然刷新窗口，不仅效率低，更惹人恼火。</p><p>可以通过配置服务端或客户端的 SSH 来保持 SSH 链接：</p><h2 id="方法一：配置服务端"><a href="#方法一：配置服务端" class="headerlink" title="方法一：配置服务端"></a>方法一：配置服务端</h2><p>可以在服务端配置，让 server 每隔 30 秒向 client 发送一个 keep-alive 包来保持连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ClientAliveInterval 30<br>ClientAliveCountMax 60<br></code></pre></td></tr></table></figure><p>第二行配置表示如果发送 keep-alive 包数量达到 60 次，客户端依然没有反应，则服务端 sshd 断开连接。如果什么都不操作，该配置可以让连接保持 30s*60，30 min</p><p>重启本地 ssh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo service ssh restart<br></code></pre></td></tr></table></figure><p>如果找不到 ssh,”Failed to restart ssh.service: Unit ssh.service not found.” ，需要安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure><h2 id="方法二：配置客户端"><a href="#方法二：配置客户端" class="headerlink" title="方法二：配置客户端"></a>方法二：配置客户端</h2><p>如果服务端没有权限配置，或者无法配置，可以配置客户端 ssh，使客户端发起的所有会话都保持连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/ssh/ssh_config<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ServerAliveInterval 30<br>ServerAliveCountMax 60<br></code></pre></td></tr></table></figure><p>本地 ssh 每隔 30s 向 server 端 sshd 发送 keep-alive 包，如果发送 60 次，server 无回应断开连接。</p><p>在 VSCode 里可以直接添加配置，效果一样：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208132040474.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host 11.22.33.44<br>  HostName 11.22.33.44<br>  User user<br>  Port 112343<br>  ServerAliveInterval 30<br>  ServerAliveCountMax 60<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Efficiency</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 隐藏编辑页面右上角的按钮</title>
    <link href="/2022/08/02/VSCode%E9%9A%90%E8%97%8F%E7%BC%96%E8%BE%91%E9%A1%B5%E9%9D%A2%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E6%8C%89%E9%92%AE/"/>
    <url>/2022/08/02/VSCode%E9%9A%90%E8%97%8F%E7%BC%96%E8%BE%91%E9%A1%B5%E9%9D%A2%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E6%8C%89%E9%92%AE/</url>
    
    <content type="html"><![CDATA[<p>随着插件越装越多，标签栏右侧的按钮也越来越多，严重缩小了标题栏显示范围。这片按钮区域又有最大长度的限制，当按钮太多，就会隐藏到下拉菜单里（最右侧的三个点）。这样就会导致一些常用的按钮被隐藏，而不常用的按钮又占地方。那么怎样才能隐藏不需要的按钮呢？</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220802131549.png"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;gitlens.menus&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;editorGroup&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;blame&quot;</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">&quot;compare&quot;</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jellyfin 打造本地影音库</title>
    <link href="/2022/08/01/Jellyfin%E6%89%93%E9%80%A0%E6%9C%AC%E5%9C%B0%E5%BD%B1%E9%9F%B3%E5%BA%93/"/>
    <url>/2022/08/01/Jellyfin%E6%89%93%E9%80%A0%E6%9C%AC%E5%9C%B0%E5%BD%B1%E9%9F%B3%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>周末花了一整天，是在没精力了。占坑。得空慢慢补！</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NAS</tag>
      
      <tag>Jellyfin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Syncthing 多端丝滑同步与备份</title>
    <link href="/2022/08/01/%E4%BD%BF%E7%94%A8Syncthing%E5%A4%9A%E7%AB%AF%E4%B8%9D%E6%BB%91%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A4%87%E4%BB%BD/"/>
    <url>/2022/08/01/%E4%BD%BF%E7%94%A8Syncthing%E5%A4%9A%E7%AB%AF%E4%B8%9D%E6%BB%91%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="折腾背景"><a href="#折腾背景" class="headerlink" title="折腾背景"></a>折腾背景</h2><p>一直想找一个能够快速同步手机与电脑数据的工具，因为手机云服务的空间少的可怜，所以习惯隔一段时间将手机里的照片、视频还有一些文件导出到电脑上。但是每次备份文件都得连接数据线，并且没法增量备份，得手动挑选，也还挺麻烦的。</p><p>逛 GitHub 时，无意间发现了 Syncthing，几乎符合了我所有的预期。</p><ul><li>开源，免费，自己电脑就可以当服务器，以后入了 NAS，可以自己搭建本地服务器。</li><li>同步速度快，取决 WIFI 的速度，目前使用 30M/s，基本满速。</li><li>多端支持，除了 IOS（反正我也没有 iOS 设备，嘿嘿），几乎全平台支持，包括 NAS 及路由器。</li><li>增量同步，再也不用挑文件备份了。</li></ul><p>话不多说，开整。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>直接进入<a href="https://syncthing.net/">Syncthing</a>官网，下载安装。在 Ubuntu 下安装<a href="https://apt.syncthing.net/">参考这里</a>。Android 版本下载<a href="https://f-droid.org/packages/com.nutomic.syncthingandroid/">Syncthing</a>。</p><p>接下来以 Windows 与 Android 手机同步为例，下载安装后，打开<code>syncthing.exe</code>，即可打开管理界面，或者浏览器输入<code>http://127.0.0.1:8384</code>也可进入管理界面。</p><p>Windows 界面：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131917716.png"></p><p>Android 界面：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131920202.png"></p><h2 id="设备配对"><a href="#设备配对" class="headerlink" title="设备配对"></a>设备配对</h2><p>Windows 管理页面-&gt;操作-&gt;显示 ID，会显示本机的二维码：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131922624.png"></p><p>Android 手机打开应用，切换到<strong>设备</strong>界面，点击右上角<strong>加号</strong>，点击二维码标识，即可扫描二维码，完成设备添加。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131927893.png"></p><p>如果正确添加，Windows 管理界面会显示 Android 设备：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131928172.png"></p><h2 id="Android-同步至-Windows"><a href="#Android-同步至-Windows" class="headerlink" title="Android 同步至 Windows"></a>Android 同步至 Windows</h2><p>打开 Android 应用，切换到<strong>文件夹</strong>界面，点击右上角<strong>加号</strong>，配置同步的文件夹：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131931912.png"></p><p>根据下图提示，配置应用，记得保存：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131934895.png"><br>目录列表显示刚刚的配置：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131937682.png"></p><p>点击打开，开启与远程设备 Windows 同步：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131938899.png"></p><p>当返回时，Windows 端将会弹出通知，提示有 Android 设备的文件要分享到电脑，点击<strong>添加</strong>：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131939273.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131941549.png"></p><p>至此，Android 同步至 Windows 完成。此时在 Android 设备的文件夹中添加任意文件，都会同步到 Windows。</p><h2 id="Windows-同步至-Android"><a href="#Windows-同步至-Android" class="headerlink" title="Windows 同步至 Android"></a>Windows 同步至 Android</h2><p>Windows 管理界面，添加文件夹：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131945074.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131947601.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131948844.png"></p><p>点击保存后，与之前类似，Android 会提示有 Windows 设备的文件要分享到 Android，点击<strong>添加</strong>：</p><blockquote><p>如果 Android 设备没有弹出提示添加共享文件夹，那么打开应用侧边栏-&gt;网页管理页面，将会有弹窗，如下图</p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208132019765.png"></p><p>点击添加，配置文件夹目录等与之前类似。</p><p>至此，Windows 同步至 Android 完成。此时在 Windows 设备的文件夹中添加任意文件，都会同步到 Android。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="Syncthing-支持三种工作模式"><a href="#Syncthing-支持三种工作模式" class="headerlink" title="Syncthing 支持三种工作模式"></a>Syncthing 支持三种工作模式</h3><ul><li>发送和接收，Send &amp; Receive Folder，这是文件夹的默认模式，对文件夹的修改会发送，其他设备的修改也会同步回来。</li><li>仅发送 Send Only，这种模式表示仅仅将当前设备上的文件夹的改动发送到其他设备，用来隐式地表示其他同步设备上的文件不会被修改，或者其他设备上的修改可以被忽略。这种模式非常适合，将当前设备设定为工作设备，然后设定一台设备作为此设备的备份。<ul><li>在 Send Only 模式下，集群中其他设备的修改都会被忽略，修改依然会接收，文件夹可能会出现 「out of sync」，但是没有修改会被应用到本地。</li><li>当 Send Only 文件夹出现 out of sync，那么一个红色的 Override Changes 会出现在文件夹详情中，点击该按钮会强制将当前主机的状态同步到其他剩余节点。任何对文件的修改，都会被当前主机上的版本所覆盖，任何不存在于当前主机节点的文件都会被删除，其他类似。</li></ul></li><li>仅接收 Receive Only，这种模式下所有的修改都会被接收并应用，然后重新分发给其他使用 send-receive 模式的设备。但是本地的修改不会被分发给其他设备。这种模式适合于建立备份镜像（replication mirrors），或者备份目的主机的场景，这些情况下不期望有本地修改或者本地的修改是不允许的<ul><li>当本地文件被删除时，Syncthing 会显示一个 Revert Local Changes 按钮。使用这个按钮会将本地的修改回撤，所有添加的文件会被删除，修改或删除的文件会重新从其他节点同步，比较容易理解，但是假如 A 设备设置仅发送，B 设备设置发送和接收，A 是不会同步 B 的更改的！</li></ul></li></ul><h3 id="忽略特定文件、目录"><a href="#忽略特定文件、目录" class="headerlink" title="忽略特定文件、目录"></a>忽略特定文件、目录</h3><p>忽略列表，和 gitignore 类似。每一台设备上的 <code>.stignore</code> 都是分别设置的，不会进行同步。</p><p>如果 A 的<code>.stignore</code>忽略了 <code>test</code> ，而 B 没有这样做，实际上会发生这样的事情：</p><ul><li>A 不会扫描和通知 B（广播）关于 test 的变动；</li><li>B 对关于 test 的变动持开放的姿态，但不会收到任何关于 A 上面 test 的变动信息（可能接收到其它同步设备的）；</li><li>B 会扫描 test 以及推送其关于 test 变动的信息，但会被 A 忽略，A 也会忽略其它同步设备关于 test 的信息；</li><li>B 会接收来自其它同步设备推送的关于 test 的信息；</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.einverne.info/post/2019/10/syncthing.html">Syncthing 又一款同步工具 | Verne in GitHub</a></p><p><a href="https://docs.syncthing.net/users/foldertypes.html">Folder Types — Syncthing documentation</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Efficiency</tag>
      
      <tag>工具</tag>
      
      <tag>同步</tag>
      
      <tag>备份</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决提交 gerrit missing Change-Id</title>
    <link href="/2022/07/30/%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BA%A4gerrit-missing-Change-Id/"/>
    <url>/2022/07/30/%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BA%A4gerrit-missing-Change-Id/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">remote: Resolving deltas: 100% (114/114)<br>remote: Processing changes: refs: 1,<span class="hljs-keyword">done</span>   <br>remote: ERROR: missing Change-Idincommit message footer<br>remote:<br>remote: Hint: To automatically insert Change-Id,installthe hook:<br>remote:   gitdir=$(git rev-parse --git-dir);scp-p -P XX XX@gerrit.xxxxx.com:hooks/commit-msg<span class="hljs-variable">$&#123;gitdir&#125;</span>/hooks/<br>remote: And <span class="hljs-keyword">then</span> amend the commit:<br>remote:   git commit --amend<br></code></pre></td></tr></table></figure><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><h3 id="理解-change-id"><a href="#理解-change-id" class="headerlink" title="理解 change-id"></a>理解 change-id</h3><p>代码审核是要对一个完整的变更进行审核，比如一次 Bug 修复，有多次提交 Commit，每次的 Commit Id 都不同，那么如何将多个不同的 Commit ID 关联到同一个 Chanege-Id 呢？我们需要将 Change-Id 添加到 Commit 的 footer（最后一行）中，这样就可以将多个 Commit 关联到同一个 Change-Id 了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207301909075.png"><br>Change-Id 为避免与提交 Id 冲突，通常以大写字母 I 为前缀。此外，我们需要明确，Change-Id 是 Gerrit 的概念，不是 Git 的概念。你只有用 Gerrit 才会有 Change-Id，而 Git 只有提交 Id。</p><p>那么这个 Change-Id 是怎么生成的呢？</p><h3 id="理解-git-hooks"><a href="#理解-git-hooks" class="headerlink" title="理解 git hooks"></a>理解 git hooks</h3><p>我在<a href="https://dunky-z.github.io/2022/05/30/Git-hooks%E9%92%A9%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/">Git hooks 钩子的使用</a>中有详细解释。在这里简单的介绍一下，钩子 (hooks) 是一些在<code>.git/hooks</code>目录的脚本，在被特定的事件触发后被调用。比如执行<code>git commit</code>，<code>git push</code>，<code>git pull</code>等命令时，脚本会被调用。</p><p>Gerrit 也提供了一个标准的<code>commit-msg</code>钩子，当我们在执行<code>git commit</code>时，会被调用。会自动生成<code>Change-Id</code>，并将其添加到<code>commit</code>的 footer 中。</p><p>通常我们从远程下载代码后，会自动下载<code>commit-msg</code>钩子，并将其添加到<code>.git/hooks</code>目录中。正常来说<code>hooks</code>是不会加入代码仓库的，这应该取决于 Gerrit 的配置。</p><p>这次错误应该是我在测试钩子的时候，将 Gerrit 标准钩子删除了，导致无法正确生成 Change-Id。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>报错时其实已经提供了解决方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 提示让我们安装远程的钩子</span><br>remote: Hint: To automatically insert Change-Id,installthe hook:<br><br><span class="hljs-comment"># 在命令行输入以下两条命令：</span><br><span class="hljs-comment"># 这条命令将找到该项目的 git 目录,并将其赋值给 gitdir 这个变量</span><br>gitdir=$(git rev-parse --git-dir)<br><span class="hljs-comment"># 执行 scp 命令,从 gerrit 代码服务器将钩子脚本文件 commit-msg 下载到项目的钩子目录下 (一般是 .git/hooks/)</span><br>scp-p -P XX XX@gerrit.xxxxx.com:hooks/commit-msg<span class="hljs-variable">$&#123;gitdir&#125;</span>/hooks/<br></code></pre></td></tr></table></figure><p>安装完之后重新<code>git commit --amend</code>，就可以正常生成 Change-Id 了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gerrit 批量添加抄送提醒</title>
    <link href="/2022/07/29/Gerrit%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%8A%84%E9%80%81%E6%8F%90%E9%86%92/"/>
    <url>/2022/07/29/Gerrit%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%8A%84%E9%80%81%E6%8F%90%E9%86%92/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司使用 Gerrit 作为 Review 平台，但是每次提交代码都需要手动添加 Reviewer，还要抄送组内成员，这种重复性劳动，程序员是绝不能容忍的。gerrit 提供了发送邮件的功能。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>官方示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git push ssh:<span class="hljs-regexp">//</span>john.doe@git.example.com:<span class="hljs-number">29418</span><span class="hljs-regexp">/kernel/</span>common HEAD:refs<span class="hljs-regexp">/for/</span>experimental%r=a@a.com,cc=b@o.com<br></code></pre></td></tr></table></figure><p>最后的<code>%</code>是个分隔符，<code>r=&#39;a@a.com</code>表示 Reviewer 是<code>a@a.com</code>，<code>cc=b@o.com</code>表示抄送组内成员是<code>b@o.com</code>。</p><blockquote><p>注意！邮箱之间不能有空格！</p></blockquote><p>以一个仓库为例：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git push origin HEAD:refs/for/branch_dev_name<span class="hljs-variable">%cc</span><span class="hljs-operator">=</span>zhangsan<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>lisi<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>wangerma<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>chenwu<span class="hljs-title">@qq.com</span><br></code></pre></td></tr></table></figure><p>但是要这么写，岂不是把操作搞更复杂了。</p><p>终极办法，打开项目路径下的<code>.git</code>目录。编辑<code>config</code>文件：</p><p>原文件里有如下字段：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[core]</span><br> <span class="hljs-attr">repositoryformatversion</span> = <span class="hljs-number">0</span><br> <span class="hljs-attr">filemode</span> = <span class="hljs-literal">false</span><br> <span class="hljs-attr">bare</span> = <span class="hljs-literal">false</span><br> <span class="hljs-attr">logallrefupdates</span> = <span class="hljs-literal">true</span><br> <span class="hljs-attr">ignorecase</span> = <span class="hljs-literal">true</span><br><span class="hljs-section">[remote &quot;origin&quot;]</span><br> <span class="hljs-attr">url</span> = git@github.com:Dunky-Z/Dunky-Z.github.io.git<br> <span class="hljs-attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*<br></code></pre></td></tr></table></figure><p>我们可以将远程仓库名换成容易区分的名字，自己随意：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[core]</span><br> <span class="hljs-attr">repositoryformatversion</span> = <span class="hljs-number">0</span><br> <span class="hljs-attr">filemode</span> = <span class="hljs-literal">false</span><br> <span class="hljs-attr">bare</span> = <span class="hljs-literal">false</span><br> <span class="hljs-attr">logallrefupdates</span> = <span class="hljs-literal">true</span><br> <span class="hljs-attr">ignorecase</span> = <span class="hljs-literal">true</span><br><span class="hljs-section">[remote &quot;origin&quot;]</span><br> <span class="hljs-attr">url</span> = git@github.com:Dunky-Z/Dunky-Z.github.io.git<br> <span class="hljs-attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*<br><span class="hljs-comment"># 以下为新增内容</span><br><span class="hljs-section">[remote &quot;review&quot;]</span><br> <span class="hljs-attr">url</span> = git@github.com:Dunky-Z/Dunky-Z.github.io.git<br> <span class="hljs-attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*<br> <span class="hljs-attr">push</span> =  HEAD:refs/for/%cc=zhangsan@qq.com,<br> <span class="hljs-attr">cc</span>=lisi@qq.com,<br> <span class="hljs-attr">cc</span>=wangerma@qq.com,<br> <span class="hljs-attr">cc</span>=chenwu@qq.com<br></code></pre></td></tr></table></figure><p>下次想要推送需要 review 的代码，就直接执行<code>git push review</code>，其中<code>push</code>就相当于：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">push HEAD:refs/for/<span class="hljs-variable">%cc</span><span class="hljs-operator">=</span>zhangsan<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>lisi<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>wangerma<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>chenwu<span class="hljs-title">@qq.com</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://gerrit-review.googlesource.com/Documentation/user-upload.html#push_create,">Gerrit Code Review - Uploading Changes</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Efficiency</tag>
      
      <tag>Gerrit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile 确定宏定义</title>
    <link href="/2022/07/27/Makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <url>/2022/07/27/Makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>有时需要通过<code>make</code>编译命令时确定代码中的宏定义，如编译不同的版本只需要使用不同的编译命令即可，而不需要修改内部代码。</p><p>当前的需求是代码中有一部分代码通过宏定义来确定编译的是 DIE0 版本还是 DIE1 版本，如果定义了<code>DIE_ORDINAL_0</code> 就使用 DIE0 的基地址，如果未定义就使用 DIE1 的基地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DIE_ORDINAL_0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DIE_ORDINAL_0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PERIPH_BASE (SYS_BASE_ADDR_DIE0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PERIPH_BASE (SYS_BASE_ADDR_DIE1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>gcc 命令支持<code>-D</code>宏定义，相当于 C 中的全局<code>#define</code>，在 Makefile 中我们可以通过宏定义来控制源程序的编译。只要在 Makefile 中的 CFLAGS 中通过选项-D 来指定你于定义的宏即可。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">CFLAGS += -D DIE_ORDINAL_0<br><span class="hljs-comment"># 在编译的时候加上此选项就可以了</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>这样的话，相当于设置了<code>DIE_ORDINAL_0</code>这个宏定义。但是我们想通过命令行的参数来决定是否使用这个宏定义，可以通过一些简单的方法获取：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(DIE0)</span>, y)<br>  CFLAGS +=-DDIE_ORDINAL_0<br><span class="hljs-keyword">else</span><br>  CFLAGS +=-DDIE_ORDINAL_1<br><span class="hljs-keyword">endif</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>从命令行找到<code>DIE0</code>这个参数，如果它等于<code>y</code>表示使用<code>DIE_ORDINAL_0</code>。如果不等于<code>y</code>则使用<code>DIE_ORDINAL_1</code>，因为我们代码里没有<code>DIE_ORDINAL_1</code>，所以就相当于没有定义<code>DIE_ORDINAL_0</code>。</p><p>命令行示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 编译DIE0</span><br>make DIE0=<span class="hljs-string">&quot;y&quot;</span><br><span class="hljs-comment"># 编译DIE1</span><br>make DIE0=<span class="hljs-string">&quot;n&quot;</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-生成指定大小文件</title>
    <link href="/2022/07/23/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6/"/>
    <url>/2022/07/23/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>在测试下载速度，或者测试加解密文件，亦或者制作文件系统时都需要一些指定大小的文件。Linux 有一些命令可以快速完成这样的任务。接下来介绍几个好用的命令。</p><h3 id="空洞文件"><a href="#空洞文件" class="headerlink" title="空洞文件"></a>空洞文件</h3><p>在 Unix 文件操作中，操作文件的位移量可以大于文件的当前长度，在下一次写操作时，就会把文件撑大（Extend），在文件里创建空洞（Hole），没有被实际写入的部分都是 0。空洞文件是否占用实际磁盘空间由文件系统觉得，<strong>Linux 中空洞文件不占用实际磁盘空间</strong>。</p><h2 id="fallocate"><a href="#fallocate" class="headerlink" title="fallocate"></a>fallocate</h2><p><code>fallocate</code>用于将块预分配给文件。对于支持<code>fallocate</code>系统调用的文件系统，这可以通过分配块并将其标记为未初始化来快速完成，因此不需要对数据块进行 I/O 操作。这是创建文件而不是用零填充的更快的方法。大文件几乎可以立即创建，而不必等待任何 I/O 操作完成。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate [-n] [-o offset] -l length filename<br></code></pre></td></tr></table></figure><ul><li><code>d</code>: 检测零并替换为空洞。</li><li><code>-n</code>：指定文件的大小，单位为字节。</li><li><code>-o</code>：指定文件的偏移量，可以跟二进制$2^{N}$后缀<code>KiB</code>，<code>MiB</code>，<code>GiB</code>，<code>TiB</code>，<code>PiB</code>和<code>EiB</code>（<code>iB</code>为可选，例如，<code>K</code>的含义与<code>KiB</code>的含义相同或后缀<code>KB</code>，<code>MB</code>，<code>GB</code>，<code>PB</code>和<code>EB</code>的十进制（$10^{N}$）。</li><li><code>-l</code>：指定文件的大小，单位同上。</li><li><code>-p, --punch-hole</code>: 将某个范围替换为空洞 (连带打开 -n)。</li><li><code>filename</code>：指定文件名。</li></ul><p>示例：<br>分配一个大小为<code>512MB</code>的文件，文件名为<code>efi.img</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate -l 512M efi.img<br></code></pre></td></tr></table></figure><p>将<code>efi.img</code>文件中的<code>0</code>替换为空洞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate -d efi.img<br></code></pre></td></tr></table></figure><p>从偏移 128M 的位置挖一个 10M 大小的洞</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate -p -o 128M  -l 10M  efi.img<br></code></pre></td></tr></table></figure><h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>Linux <code>dd</code> 命令用于读取、转换并输出数据。<code>dd</code> 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出</p><blockquote><p>dd 的原意为 data duplicator，但由于 dd 属于较低阶的资料处理工具，通常都会以管理者（root）权限来执行，如果稍有不慎，也很容易造成严重的后果（例如整颗硬碟的资料不见等等），所以有些人也把 dd 取名为 data destroyer。<a href="https://blog.gtwang.org/linux/dd-command-examples/">dd 指令教学与实用范例，备份与回复资料的小工具 - GT Wang</a></p></blockquote><ul><li><code>if=FILE</code>     : 指定输入文件，若不指定则从标注输入读取。这里指定为/dev/zero 是 Linux 的一个伪文件，它可以产生连续不断的 null 流（二进制的 0）。</li><li><code>of=FILE</code>      : 指定输出文件，若不指定则输出到标准输出。</li><li><code>bs=BYTES</code>     : 每次读写的字节数，可以使用单位 K、M、G 等等。另外输入输出可以分别用 ibs、obs 指定，若使用 bs，则表示是 ibs 和 obs 都是用该参数。</li><li><code>count=BLOCKS</code> : 读取的 block 数，block 的大小由 ibs 指定。</li></ul><p>示例：<br>生成一个<code>1g</code>大小的文件，内容全为<code>0</code>，块大小为<code>1M</code>，文件名为<code>efi.img</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dd <span class="hljs-keyword">if</span>=/dev/zero of=efi.img bs=1M count=1024<br></code></pre></td></tr></table></figure><p>生成一个<code>1g</code>大小的文件，内容为随机数，块大小为<code>10M</code>，文件名为<code>efi.img</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dd <span class="hljs-keyword">if</span>=/dev/urandom of=efi.img bs=10M count=1024<br></code></pre></td></tr></table></figure><h2 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h2><ul><li><code>-s</code>：指定文件的大小，可以跟二进制$2^{N}$后缀<code>KiB</code>，<code>MiB</code>，<code>GiB</code>，<code>TiB</code>，<code>PiB</code>和<code>EiB</code>（<code>iB</code>为可选，例如，<code>K</code>的含义与<code>KiB</code>的含义相同或后缀<code>KB</code>，<code>MB</code>，<code>GB</code>，<code>PB</code>和<code>EB</code>的十进制（$10^{N}$）。</li></ul><p>示例：<br>生成一个 100M 大小的文件，文件名为<code>efi.img</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">truncate -s 100M efi.img<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://lrita.github.io/images/posts/filesystem/Linux_File_Hole_And_Sparse_Files.pdf">Linux 文件空洞与稀疏文件</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux，每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解虚拟内存</title>
    <link href="/2022/07/17/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2022/07/17/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要虚拟内存？"><a href="#为什么需要虚拟内存？" class="headerlink" title="为什么需要虚拟内存？"></a>为什么需要虚拟内存？</h2><p>CPU 访问内存的最自然的方式就是使用物理地址，这种方式称为<strong>物理寻址</strong>。1，计算机中并不是只有一个程序在运行，如果它们都是用物理寻址的方式，那么所有程序必须在链接之前确定好自己所用到的内存范围，否则两个程序就可能会发生冲突。2，程序大于内存的问题早在上世纪六十年代就出现，后来出现了<strong>覆盖技术</strong>（Overlay），把程序分割成许多片段。程序开始执行时，将覆盖管理模块装入内存，该管理模块立即装入并运行覆盖 0。执行完成后，覆盖 0 通知管理模块装入覆盖 1，或者占用覆盖 0 的上方位置（如果有空间），或者占用覆盖 0（如果没有空间）。把一个大程序分割成小的、模块化的片段是非常费时和枯燥的，并且易于出错。很少程序员擅长使用覆盖技术。</p><p>为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟内存</strong>(VM)。主要有三个功能：</p><ul><li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它<strong>高效地使用了主存</strong>。</li><li>它为每个进程提供了一致的地址空间，从而<strong>简化了内存管理</strong>。</li><li>它<strong>保护了每个进程</strong>的地址空间不被其他进程破坏。</li></ul><h2 id="什么是虚拟寻址？"><a href="#什么是虚拟寻址？" class="headerlink" title="什么是虚拟寻址？"></a>什么是虚拟寻址？</h2><p>如果主存被分为长度为$M$的单字节大小的数组，每个字节都对应一个物理地址，CPU 通过这个唯一的地址访问主存，这样的方式就是<strong>物理寻址</strong>。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207212125636.png"><br>现代处理器使用<strong>虚拟寻址</strong>的方式。CPU 通过生成的<strong>虚拟地址</strong>来访问内存，这个地址在送到内存之前会被转换成<strong>物理地址</strong>。这个过程称为<strong>地址翻译</strong>。CPU 芯片上叫做<strong>内存管理单元</strong>（Memory Management Unit, MMU）的专用硬件，利用存放在主存中的<strong>查询表</strong>来动态翻译虚拟地址，该表的内容由操作系统管理。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207212128486.png"></p><h2 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h2><p>概念上而言，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是<strong>字节数组</strong>。每个字节都有一个唯一的虚拟地址作为数组的索引。磁盘上活动的数组内容被缓存在主存中。在存储器结构中，较低层次上的磁盘的数据被分割成块，这些块作为和较高层次的主存之间的传输单元。<strong>主存作为虚拟内存的缓存</strong>。</p><p>虚拟内存被分割为大小固定的块，这些块叫<strong>虚拟页</strong>（Virtual Page，VP），类似的物理内存也有<strong>物理页</strong>(Physical Page, PP)。虚拟页有三种不同的状态：</p><ul><li>未分配：VM 系统还未分配 (或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就<strong>不占用任何磁盘空间</strong>。</li><li>已缓存：当前已缓存在物理内存中的已分配页。</li><li>未缓存：未缓存在物理内存中的已分配页。</li></ul><p>为了有助于清晰理解存储层次结构中不同的缓存概念，我们将使用术语<strong>SRAM</strong>缓存来表示位于 CPU 和主存之间的 Ll、L2 和 L3 <strong>高速缓存</strong>，并且用术语 <strong>DRAM</strong> 缓存来表示<strong>虚拟内存系统的缓存</strong>，它在主存中缓存虚拟页。</p><p>在存储层次结构中，DRAM 缓存的位置对它的组织结构有很大的影响。回想一下，DRAM 比 SRAM 要慢大约 10 倍，而磁盘要比 DRAM 慢大约 100000 多倍。因此，<strong>DRAM 缓存中的不命中比起 SRAM 缓存中的不命中要昂贵得多</strong>。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。（这些替换算法超出了我们的讨论范围）。最后，因为对磁盘的访问时间很长，<strong>DRAM 缓存总是使用写回，而不是直写</strong>。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟内存系统可以完成以下这些功能，</p><ul><li>判定一个虚拟页是否缓存在 DRAM 中的某个地方；</li><li>可以确定这个虚拟页存放在哪个物理页中；</li><li>如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。</li></ul><p>这些功能是由<strong>软硬件联合提供的</strong>，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和一个<strong>存放在物理内存中叫做页表</strong>（page table）的数据结构。页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p><p>图 9-4 展示了一个页表的基本组织结构。页表就是一个页表条目（Page Table Entry，PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p><p>PTE 由两部分组成：</p><ul><li>有效位：表明了该虚拟页当前是否被缓存在 DRAM 中；</li><li>地址：表示 DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208122157633.png"></p><h3 id="页命中与缺页"><a href="#页命中与缺页" class="headerlink" title="页命中与缺页"></a>页命中与缺页</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208130940717.png">l</p><p>当 CPU 访问已被缓存的地址时，就叫做<strong>页命中</strong>。如访问上图 VP2，虚拟地址索引到 PTE2，此时有效位为 1，地址翻译硬件就知道该地址被缓存了。</p><p>当 CPU 访问未被缓存的地址时，会导致<strong>缺页</strong>。如访问上图的 VP3，虚拟地址索引到 PTE3，此时有效位为 0，地址翻译硬件就知道该地址未被缓存，需要从磁盘中读取。</p><p>这时会触发一个<strong>缺页异常</strong>。<strong>缺页异常调用内核中的缺页异常处理程序</strong>，该程序会选择一个牺牲页，在此例中就是存放在 PP 3 中的 VP 4。如果 VP 4 已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改 VP 4 的页表条目，反映出 VP 4 不再缓存在主存中这一事实。</p><p>接下来，内核从磁盘复制 VP 3 到内存中的 PP 3，更新 PTE 3，随后返回。当异常处理程序返回时，它会<strong>重新启动导致缺页的指令</strong>，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP 3 已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图 9-7 展示了在缺页之后我们的示例页表的状态。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131434643.png"></p><p>在虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做<strong>交换</strong>（swapping）或者<strong>页面调度</strong>（paging）。页从磁盘换入（或者页面调入）DRAM 和从 DRAM 换出（或者页面调出）磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度（demand paging）。</p><h2 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h2><p>之前我们只讨论了一个页表的情况，但是实际上操作系统为<strong>每个进程都分配了一个独立的页表</strong>。多个虚拟页面可以映射到同一个共享物理页面上。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131441255.png"></p><p>按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。特别地，VM 简化了链接和加载、代码和数据共享，以及应用程序的内存分配。</p><ul><li><strong>简化链接</strong>。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而<strong>不管代码和数据实际存放在物理内存的何处</strong>。例如，一个给定的 Linux 系统上的每个进程都使用类似的内存格式。对于 64 位地址空间，代码段总是从虚拟地址 0x400000 开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，<strong>允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的</strong>。</li><li><strong>简化加载</strong>。虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中 .text 和 .data 节加载到一个新创建的进程中，Linux 加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。有趣的是，加载器从不从磁盘到内存实际复制任何数据。在每个页初次被引用时，要么是 CPU 取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作内存映射（memory mapping）。Linux 提供一个称为 mmap 的系统调用，允许应用程序自己做内存映射。</li><li><strong>简化共享</strong>。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。</li><li><strong>简化内存分配</strong>。虚拟内存为向用户进程提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如调用 malloc 的结果），<strong>操作系统分配一个适当数字（例如 k）个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的 k 个任意的物理页面</strong>。由于页表工作的方式，操作系统没有必要分配 k 个连续的物理内存页面。<strong>页面可以随机地分散在物理内存中</strong>。</li></ul><h2 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h2><p>操作系统中的用户程序不应该修改只读的代码段，也不应该读取或者修改内核中的代码和数据结构或者访问私有的以及其他的进程的内存，如果无法对用户进程的内存访问进行限制，攻击者就可以访问和修改其他进程的内存影响系统的安全。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131522719.png"></p><p>通过在页表中添加页面的保护属性，可以让操作系统在页面被访问时进行检查，如果页面被保护为只读，则操作系统会报错。</p><p>在图 9-10 这个示例中，每个 PTE 中已经添加了三个许可位。SUP 位表示进程是否必须运行在内核（超级用户）模式下才能访问该页。运行在内核模式中的进程可以访问任何页面，但是运行在用户模式中的进程只允许访问那些 SUP 为 0 的页面。READ 位和 WRITE 位控制对页面的读和写访问。例如，如果进程 i 运行在用户模式下，那么它有读 VP 0 和读写 VP 1 的权限。然而，不允许它访问 VP 2。</p><p>如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell 一般将这种异常报告为<strong>段错误</strong>（segmentation fault）。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>基本参数</p><table><thead><tr><th align="left">符号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$$\small N=2^n$$</td><td align="left">虚拟地址空间中的地址数量</td></tr><tr><td align="left">$$\small M=2^m$$</td><td align="left">物理地址空间中的地址数量</td></tr><tr><td align="left">$$\small P=2^p$$</td><td align="left">页的大小（字节）</td></tr></tbody></table><p>虚拟地址（VA）的组成部分</p><table><thead><tr><th align="left">符号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">VPO</td><td align="left">虚拟页面偏移量（字节）</td></tr><tr><td align="left">VPN</td><td align="left">虚拟页号</td></tr><tr><td align="left">TLBI</td><td align="left">TLB 索引</td></tr><tr><td align="left">TLBT</td><td align="left">TLB 标记</td></tr></tbody></table><p>物理地址（PA）的组成部分</p><table><thead><tr><th align="left">符号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">PPO</td><td align="left">物理页面偏移量（字节）</td></tr><tr><td align="left">PPN</td><td align="left">物理页号</td></tr><tr><td align="left">CO</td><td align="left">缓冲块内的字节偏移量</td></tr><tr><td align="left">CI</td><td align="left">高速缓存索引</td></tr><tr><td align="left">CT</td><td align="left">高速缓存标记</td></tr></tbody></table><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131527131.png"></p><p>图 9-12 展示了 MMU 如何利用页表来实现地址翻译。CPU 中的一个控制寄存器，<strong>页表基址寄存器</strong>（Page Table Base Register，PTBR）指向当前页表。$n$ 位的虚拟地址包含两个部分：一个 $p$ 位的<strong>虚拟页面偏移</strong>（Virtual Page Offset，VPO）和一个$\small (n-p)$位的<strong>虚拟页号</strong>（Virtual Page Number，VPN）。MMU 利用 VPN 来选择适当的 PTE。例如，VPN 0 选择 PTE 0，VPN 1 选择 PTE 1，以此类推。将页表条目中<strong>物理页号</strong>（Physical Page Number，PPN）和虚拟地址中的 VP。串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是 P 字节的，所以<strong>物理页面偏移（Physical Page Offset，PPO）和 VPO 是相同的</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131527491.png"></p><p>图 9-13a 展示了当页面命中时，CPU 硬件执行的步骤。</p><ul><li>第 1 步：处理器生成一个<br>虚拟地址，并把它传送给 MMU。</li><li>第 2 步：MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。</li><li>第 3 步：高速缓存/主存向 MMU 返回 PTE。</li><li>第 4 步：MMU 构造物理地址，并把它传送给高速缓存/主存。</li><li>第 5 步：高速缓存/主存返回所请求的数据字给处理器。</li></ul><p>页面命中完全是由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成，如图 9-13b 所示。</p><ul><li>第 1 - 3 步：和图 9-13a 中的第 1 步到第 3 步相同。</li><li>第 4 步：PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。</li><li>第 5 步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>第 6 步：缺页处理程序页面调入新的页面，并更新内存中的 PTE。</li><li>第 7 步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给 MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，在 MMU 执行了图 9-13b 中的步骤之后，主存就会将所请求字返回给处理器。</li></ul><h3 id="利用-TLB-加速地址翻译"><a href="#利用-TLB-加速地址翻译" class="headerlink" title="利用 TLB 加速地址翻译"></a>利用 TLB 加速地址翻译</h3><p>每次 CPU 访问一个虚拟地址，MMU 就必须查找 PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。如果 PTE 碰巧缓存在 L1 中，那么开销就下降到 1 个或 2 个周期。为了消除这样的开销，在 MMU 中包括了一个关于 PTE 的小的缓存，称为<strong>翻译后备缓冲器</strong>（Translation Lookaside Buffer，TLB）。</p><p>TLB 是一个小的、虚拟寻址的缓存，其中<strong>每一行都保存着一个由单个 PTE 组成的块</strong>。TLB 通常有高度的相联度。如图 9-15 所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果 TLB 有$\small T = 2^t$个组，那么 <strong>TLB 索引</strong>（TLBI）是由 VPN 的 $t$ 个最低位组成的，而 <strong>TLB 标记</strong>（TLBT）是由 VPN 中剩余的位组成的。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131546427.png"></p><p>图 9-16a 展示了当 TLB 命中时（通常情况）所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的 MMU 中执行的，因此非常快。</p><ul><li>第 1 步：CPU 产生一个虚拟地址。</li><li>第 2 - 3 步：MMU 从 TLB 中取出相应的 PTE。</li><li>第 4 步：MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</li><li>第 5 步：高速缓存/主存将所请求的数据字返回给 CPU。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131547576.png"></p><p>当 TLB 不命中时，MMU 必须从 L1 缓存中取出相应的 PTE，如图 9-16b 所示。新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了。</p><p>页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。</p><p>那怎么办呢？我们可以试着将页表再分页，4G 的空间需要 4M 的页表来存储映射。我们把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K。</p><p>页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置。</p><p>这样加起来正好 32 位，也就是用前 10 位定位到页目录表中的一项。将这一项对应的页表取出来共 1k 项，再用中间 10 位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后 12 位定位到页中的具体位置访问数据。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129192245.png"></p><p>你可能会问，如果这样的话，映射 4GB 地址空间就需要 4MB+4KB 的内存，这样不是更大 了吗？当然如果页是满的，当时是更大了，但是，我们往往不会为一个进程分配那么多内 存。<br>比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完 整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省多了</p><p>当然对于 64 位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间<br>页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。也就是一级页表，二级页表，三级页表，四级页表。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131820091.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Virtual Memory</tag>
      
      <tag>TLB</tag>
      
      <tag>内存管理</tag>
      
      <tag>页表</tag>
      
      <tag>多级页表</tag>
      
      <tag>MMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言 getopt() 函数的用法</title>
    <link href="/2022/07/16/C%E8%AF%AD%E8%A8%80getopt-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2022/07/16/C%E8%AF%AD%E8%A8%80getopt-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在做<a href="https://dunky-z.github.io/2022/07/11/CSAPP-LAB-Cache-Lab/">CSAPP_LAB-Cache Lab</a>时，实验要求对输入参数进行处理，如程序<code>csim</code>执行需要 4 个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim -s 4 -E 6 -b 4 -t &lt;tracefile&gt;<br></code></pre></td></tr></table></figure><p>原先想通过字符串解析，一个个处理，但是看到了其他参考代码后发现了一个更简单的方法，可以通过<code>getopt()</code>函数来解析参数。</p><p>函数的功能：解析命令行参数。<br>头文件 <code>#include &lt;unistd.h&gt;</code></p><p>在学习函数前需要了解与该函数相关的四个变量：</p><ul><li><p><code>int opterr</code>：控制是否输出错误；<br>如果此变量的值非零，则 <code>getopt</code> 在遇到未知选项字符或缺少必需参数的选项时将错误消息打印到标准错误流 (终端)。该值默认为非零。如果将此变量设置为零，<code>getopt</code> 不会打印任何消息，但仍会返回问号<code>?</code>提示错误。</p></li><li><p><code>int optopt</code>：保存未知的选项；<br>当 <code>getopt</code> 遇到未知选项字符或缺少必需参数的选项时，它将该选项字符存储在此变量中。</p></li><li><p><code>int optind</code>：指向下一个要处理的参数；<br>此变量由 <code>getopt</code> 设置为要处理的 <code>argv</code> 数组的下一个元素的索引。一旦 <code>getopt</code> 找到所有选项参数，就可以使用此变量来确定其余非选项参数的开始位置。该变量的初始值为 1。</p></li><li><p><code>char * optarg</code>：保存选项参数；<br>对于那些接受参数的选项，此变量由 <code>getopt</code> 设置为指向选项参数的值。</p></li></ul><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * options)</span></span>;<br></code></pre></td></tr></table></figure><p>参数解析：</p><ul><li>参数<code>argc</code> 和<code>argv</code> 是由<code>main()</code>传递的参数个数和内容。</li><li><code>options</code> 参数是一个字符串，它指定对该程序有效的选项字符。此字符串中的选项字符后面可以跟一个冒号（<code>:</code>），表示它需要一个<strong>必需的参数</strong>，这个参数可以与选项连写也可以空格分开，如<code>-a13 or  -a 13</code>。如果选项字符后跟两个冒号（<code>::</code>），则其参数是<strong>可选的</strong>，如果有参数，那么参数不能与选项分割，如只能写成<code>-a13</code>而不能写成<code>-a 13</code>；这是一个 GNU 扩展。</li></ul><p>实例：</p><p>下面是一个示例，展示了通常如何使用 <code>getopt</code>。需要注意的关键点是：</p><ul><li>通常，<code>getopt</code> 在循环中被调用。当 <code>getopt</code> 返回 <code>-1</code> 表示没有更多选项存在时，循环终止。</li><li><code>switch</code> 语句用于调度 <code>getopt</code> 的返回值。在典型使用中，每种情况只设置一个稍后在程序中使用的变量。</li><li>第二个循环用于处理剩余的非选项参数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> aflag = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> bflag = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">char</span> *cvalue = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">int</span> index;<br>  <span class="hljs-keyword">int</span> c;<br><br>  opterr = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> ((c = getopt (argc, argv, <span class="hljs-string">&quot;abc:&quot;</span>)) != <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">switch</span> (c)<br>      &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>        aflag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>        bflag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>        cvalue = optarg;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (optopt == <span class="hljs-string">&#x27;c&#x27;</span>)<br>          <span class="hljs-built_in">fprintf</span> (<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Option -%c requires an argument.\n&quot;</span>, optopt);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isprint</span> (optopt))<br>          <span class="hljs-built_in">fprintf</span> (<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unknown option `-%c&#x27;.\n&quot;</span>, optopt);<br>        <span class="hljs-keyword">else</span><br>          <span class="hljs-built_in">fprintf</span> (<span class="hljs-built_in">stderr</span>,<br>                   <span class="hljs-string">&quot;Unknown option character `\\x%x&#x27;.\n&quot;</span>,<br>                   optopt);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">abort</span> ();<br>      &#125;<br><br>  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;aflag = %d, bflag = %d, cvalue = %s\n&quot;</span>,<br>          aflag, bflag, cvalue);<br><br>  <span class="hljs-keyword">for</span> (index = optind; index &lt; argc; index++)<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Non-option argument %s\n&quot;</span>, argv[index]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是一些示例，展示了该程序使用不同的参数组合打印的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C">% testopt<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br><br><span class="hljs-comment">// 选项可以用空格分割</span><br>% testopt -a -b<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">1</span>, cvalue = (null)<br><br><span class="hljs-comment">// 也可以连写</span><br>% testopt -ab<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">1</span>, cvalue = (null)<br><br><span class="hljs-comment">// 必选参数，可以用空格分割</span><br>% testopt -c foo<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = foo<br><br><span class="hljs-comment">// 必选参数，可以连写</span><br>% testopt -cfoo<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = foo<br><br><span class="hljs-comment">// 没有对应的选项</span><br>% testopt arg1<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument arg1<br><br><span class="hljs-comment">// -a选项没有需要处理的参数，所以arg1无法处理</span><br>% testopt -a arg1<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument arg1<br><br>% testopt -c foo arg1<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = foo<br>Non-option argument arg1<br><br>% testopt -a -- -b<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument -b<br><br>% testopt -a -<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument -<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/huangxiaohu_coder/article/details/7475156">原来命令行参数处理可以这么写-getopt？_huangxiaohu_coder 的博客-CSDN 博客</a><br><a href="https://www.cnblogs.com/qingergege/p/5914218.html">Linux 下 getopt() 函数的简单使用 - 青儿哥哥 - 博客园</a><br><a href="http://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html">Using Getopt (The GNU C Library)</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 VS Code 终端使用 git bash 时中文乱码</title>
    <link href="/2022/07/16/%E8%A7%A3%E5%86%B3VS-Code%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8git-bash%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <url>/2022/07/16/%E8%A7%A3%E5%86%B3VS-Code%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8git-bash%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>Windows 环境下，使用 VSCode 的终端时，中文显示为乱码，如使用<code>git status</code>命令查看修改文件时，中文文件名就无法正常显示：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207162158602.png"></p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>因为终端被替换成了 <code>git bash</code>，它对所有非英文的字符进行了转义。</p><p><a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-corequotePath">官方文档提到</a>：</p><p>输出路径的命令（例如<code>ls-files</code>、<code>diff</code>）将通过将路径名括在双引号中并以与 C 转义控制字符相同的方式用反斜杠转义这些字符来引用路径名中的异常字符（例如<code>\t</code>用于 <code>TAB</code>, <code>\n</code> 表示<code>LF</code>，<code>\\</code>表示反斜杠）或值大于 <code>0x80</code> 的字节（例如，八进制 <code>\302\265</code> 表示 UTF-8 中的“micro”）。如果此变量设置为 <code>false</code>，则高于 <code>0x80</code> 的字节不再被视为异常。无论此变量的设置如何，双引号、反斜杠和控制字符总是被转义。一个简单的空格字符不被认为是异常的。许多命令可以使用 <code>-z</code> 选项完全逐字输出路径名。默认值是 true。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>命令行输入，取消转义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOC(net-on-chip) 总线互联构架</title>
    <link href="/2022/07/12/NOC-net-on-chip-%E6%80%BB%E7%BA%BF%E4%BA%92%E8%81%94%E6%9E%84%E6%9E%B6/"/>
    <url>/2022/07/12/NOC-net-on-chip-%E6%80%BB%E7%BA%BF%E4%BA%92%E8%81%94%E6%9E%84%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><blockquote><p>转载自^[<a href="https://blog.csdn.net/pieces_thinking/article/details/77938041">片上网络（NoC）技术的背景、意义以及发展_碎碎思的博客-CSDN 博客</a>]</p></blockquote><p>在过去的几十年里，集成电路制造工艺技术、封装与测试技术、设计方法学和 EDA 工具等微电子相关技术始终保持着快速的发展。根据<a href="https://zh.wikipedia.org/zh-sg/%E5%9B%BD%E9%99%85%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE">国际半导体技术发展路线图</a>（International Technology Roadmap for Semiconductors, ITRS）预测，到 2024 年 IC 制造技术将达到 2 nm。但是，全局互连线的性能提升程度明显低于晶体管性能提升程度。受到亚阈值漏电流功耗、动态功耗、器件可靠性以及全局互连线等影响，<strong>通过提升单个处理器核的性能来提升系统整体性能已变得非常难以实现</strong>，同时芯片设计的难度和复杂度也在进一步增加。片上系统（System on Chip, SoC）具有集成度高、功耗低、成本低、体积小等优点，已经成为超大规模集成电路系统设计的主流方向。随着片上系统 SoC 的应用需求越来越丰富、越来越复杂，片上多核 MPSoC (MultiprocessorSystem on Chip, MPSoC) 已经成为发展的必然趋势，同时 MPSoC 上集成的 IP 核数量也将会按照摩尔定律继续发展。目前，MPSoC 已经逐渐应用于网络通信、多媒体等嵌入式电子设备中。半导体工艺技术的快速发展为集成电路设计提供了很大的发展空间，同时也带来了一系列新的问题和挑战，如芯片的性能、功耗、可靠性、可扩展性等等。  </p><p>随着系统性能需求越来越高，处理器核之间的互连架构必须能够提供具有较低延迟和高吞吐率的服务，并且具有良好的可扩展性。传统的基于总线的集中式互连架构已经难以满足现今系统的性能需求，而基于报文交换的<strong>片上网络（Network on Chip, NoC）</strong>逐渐成为片上多核间通讯的首选互连架构。在 NoC 中，路由节点之间通过局部互连线相连接，每一个路由节点通过网络接口 NI 与一个本地 IP 核相连接，源路由节点和目的路由节点之间的数据通讯需要经过多个跳步来实现。因此，NoC 技术的出现使得片上系统 SoC 的设计也将从以计算为中心逐渐过渡到以通讯为中心。  </p><p>传统的 SoC 系统采用总线互连结构，如 所示。虽然人们已经提出了很多改进的总线结构，例如将共享总线改进为桥接多总线结构、层次化总线结构等更复杂的结构。但是当进入 MPSoC 时代，单芯片上集成的处理器核数越来越多时，总线结构在通讯性能、功耗、全局时钟同步、信号完整性以及信号可靠性等方面面临着巨大的挑战，这些复杂的改进型总线结构仍无法解决片上多核间通信所面临的问题。因此，<strong>MPSoC 上多核间的通讯问题</strong>已经成为制约系统性能提升的<strong>主要瓶颈</strong>。  </p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713101328.png"></p><p>NoC 的概念是由 Agarwal（1999 年）、Guerrier 和 Greiner（2000 年）、Dally 和 Towles（2001 年）、Benini 和 Micheli（2002 年）、Jantsch 和 Tenhunen（2003 年）等人逐步提出的。目前，对于 NoC 还没有一个统一的定义，大多数 NoC 研究者认为 NoC 是 SoC 系统的通讯子集，并且应该引入互联网络技术来解决片上多核的通讯问题。  </p><h2 id="NoC-的意义"><a href="#NoC-的意义" class="headerlink" title="NoC 的意义"></a>NoC 的意义</h2><blockquote><p>转载自^[<a href="https://blog.csdn.net/pieces_thinking/article/details/77938041">片上网络（NoC）技术的背景、意义以及发展_碎碎思的博客-CSDN 博客</a>]</p></blockquote><p>随着单芯片上集成的处理器核数越来越多，片上互连架构经历了从专用互连线，Bus，Crossbar 到 NoC。NoC 借鉴了分布式计算系统的通讯方式，采用数据路由和分组交换技术替代传统的总线结构，从体系结构上解决了 SoC 总线结构由于地址空间有限导致的可扩展性差，分时通讯引起的通讯效率低下，以及全局时钟同步引起的功耗和面积等问题。与传统的总线互连技术相比，片上网络具有如下优点：  </p><p>第一，<strong>网络带宽</strong>。总线结构互连多个 IP 核，共享一条数据总线，其缺点是同一时间只能有一对 IP 进行通信。随着系统规模的逐渐增大，总线结构的通信效率必然成为限制系统性能提升的瓶颈。片上网络具有非常丰富的信道资源，为系统提供了一个网络化的通信平台。网络中的多个节点可以同时利用网络中的不同物理链路进行信息交换，支持多个 IP 核并发地进行数据通信。随着网络规模的增大，网络上的信道资源也相应增多。因此，<strong>NoC 技术相对于 Bus 互连技术具有较高的带宽</strong>，以及更高的通信效率。当并发进行数据通信时网络会产生竞争，即会存在请求同一条物理链路的节点对。NoC 的路由节点通过分时复用物理链路来解决竞争，<strong>与 Bus 结构相比，NoC 能够降低竞争发生的概率</strong>。  </p><p>第二，<strong>可扩展性和设计成本</strong>。总线结构需要针对不同的系统需求单独进行设计，当系统功能扩展时，需要对现有的设计方案重新设计，从而严重影响设计的周期和资本投入。<strong>NoC 中每个路由节点和本地 IP 核通过网络接口（NetworkInterface, NI）相连，当系统需要升级扩展新功能时，只需要将新增加的处理器核通过网络接口 NI 接入到网络中的路由节点即可，无需重新设计网络。</strong>因此，片上网络具有良好的可扩展性。片上网络作为一个独立的片上互连结构，能够满足不同系统的应用需求，当网络中节点数量增加时，仅需要按照相应的拓扑结构规则继续增大网络的规模即可，缩短了产品的设计周期，节约了设计成本。  </p><p>第三，<strong>功耗</strong>。随着 SoC 规模的不断增大，总线上每次信息交互都需要驱动全局互连线，因此总线结构所消耗的功耗将显著增加，并且随着集成电路工艺的不断发展，想要保证全局时钟同步也将变得难以实现。而在 NoC 中，信息交互消耗的功耗与进行通讯的路由节点之间的距离密切相关，距离较近的两个节点进行通讯时消耗的功耗就比较低。  </p><p>第四，<strong>信号完整性和信号延迟</strong>。随着集成电路特征尺寸的不断减小，电路规模的不断增大，互连线的宽度和间距也在不断地减小，线间耦合电容相应增大，长的全局并行总线会引起较大的串扰噪声，从而影响信号的完整性以及信号传输的正确性。同时，互连线上的延迟将成为影响信号延迟的主要因素，总线结构全局互连线上的延迟将大于一个时钟周期，从而使得时钟的偏移很难管理。  </p><p>第五，<strong>全局同步</strong>。总线结构采用全局同步时钟，随着芯片集成度的提高，芯片的工作频率也在不断提高，在芯片内会形成很庞大的时钟树，因此很难实现片上各个模块的全局同步时钟。采用时钟树（Clock Tree）优化的方法可以改善由时钟翻转引起的时钟偏差和时钟抖动，但同步时钟网络所产生的动态功耗甚至可达总功耗的 40% 以上。为了提高系统的时钟频率，只能对全局互连线采用分布式流水线结构，或者采用全局异步局部同步（Global Asynchronous Local Synchronous,GALS）的时钟策略。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>NOC</tag>
      
      <tag>SoC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建和测试 RISC-V 架构下启用 ACPI 的内核</title>
    <link href="/2022/07/12/%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E5%90%AF%E7%94%A8ACPI%E7%9A%84%E5%86%85%E6%A0%B8/"/>
    <url>/2022/07/12/%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E5%90%AF%E7%94%A8ACPI%E7%9A%84%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考自<a href="https://github.com/riscv-non-isa/riscv-acpi/wiki/PoC-:-How-to-build-and-test-ACPI-enabled-kernel">PoC : How to build and test ACPI enabled kernel · riscv-non-isa/riscv-acpi Wiki</a></p></blockquote><h2 id="准备环境及工具链"><a href="#准备环境及工具链" class="headerlink" title="准备环境及工具链"></a>准备环境及工具链</h2><ol><li><p>安装 RISC-V 工具链，需下载原发行版。好在 apt 可以安装。</p><blockquote><p>如果报错：riscv64-linux-gnu-gcc: error: unrecognized command line option ‘-mno-relax’; did you mean ‘-Wno-vla’?，多半是工具链原因，请按照以下方法安装！！！</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt remove gcc-riscv64-linux-gnu<br>sudo apt install gcc-8-riscv64-linux-gnu<br></code></pre></td></tr></table></figure></li><li><p>安装必要的三方库，以下为Ubuntu下的命令，其他平台可以参考<a href="https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html#prerequisites">这个文档</a>。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \<br>                gawk build-essential bison flex texinfo gperf libtool patchutils bc \<br>                zlib1g-dev libexpat-dev git<br></code></pre></td></tr></table></figure></li></ol><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>可能无法一次搭建成功，一些环境变量会经常用到，所以干脆把所有环境变量放到<code>.bashrc</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vim ~/.bashrc<br><span class="hljs-comment"># 添加以下内容</span><br><span class="hljs-built_in">export</span> WORK_DIR=~/riscv64-acpi<br><span class="hljs-built_in">export</span> GCC5_RISCV64_PREFIX=riscv64-unknown-elf-<br><span class="hljs-built_in">export</span> MAINSPACE=~/riscv64-acpi/tianocore<br><span class="hljs-built_in">export</span> PACKAGES_PATH=<span class="hljs-variable">$MAINSPACE</span>/edk2:<span class="hljs-variable">$MAINSPACE</span>/edk2-platforms<br><span class="hljs-built_in">export</span> EDK_TOOLS_PATH=<span class="hljs-variable">$MAINSPACE</span>/edk2/BaseTools<br><br></code></pre></td></tr></table></figure><p>首先，创建一个工作目录，我们将在其中下载并构建所有源代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">source</span> ~/.bashrc<br>WORK_DIR=<span class="hljs-variable">$PWD</span>/riscv64-acpi<br>mkdir -p <span class="hljs-variable">$WORK_DIR</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span><br></code></pre></td></tr></table></figure><p>然后下载所有需要的源，它们是：<a href="https://github.com/ventanamicro/qemu/tree/dev-upstream">qemu</a>、<a href="https://github.com/ventanamicro/opensbi/tree/dev-upstream">opensbi</a>、<a href="https://github.com/ventanamicro/edk2/tree/dev-upstream">edk2</a>、<a href="https://github.com/ventanamicro/edk2-platforms/tree/dev-upstream">edk2-platforms</a>、<a href="https://github.com/ventanamicro/linux/tree/dev-upstream">linux</a>。</p><p>下载地址更换成了加速镜像源，原来地址下载太慢，容易中断。下载地址更换成了加速镜像源，原来地址下载太慢，容易中断。有两个项目包含子模块，下载容易出错，所以<code>--depth=1</code>舍弃了多余的提交记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">clone</span> --branch dev-upstream  https://hub.fastgit.xyz/ventanamicro/qemu.git qemu<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream  https://hub.fastgit.xyz/ventanamicro/opensbi.git opensbi<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream --recurse-submodules --depth=1  https://hub.fastgit.xyz/ventanamicro/edk2.git tianocore/edk2<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream --recurse-submodules --depth=1  https://hub.fastgit.xyz/ventanamicro/edk2-platforms.git  tianocore/edk2-platforms<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream  https://hub.fastgit.xyz/ventanamicro/linux.git linux<br></code></pre></td></tr></table></figure><h2 id="编译构建"><a href="#编译构建" class="headerlink" title="编译构建"></a>编译构建</h2><h3 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/qemu<br>./configure --target-list=riscv64-softmmu<br>make -j $(nproc)<br></code></pre></td></tr></table></figure><h3 id="OPENSBI"><a href="#OPENSBI" class="headerlink" title="OPENSBI"></a>OPENSBI</h3><blockquote><p>此处我们使用以<code>riscv64-unknown-elf-</code>为前缀的版本，则表示该版本GCC工具链会使用newlib作为C运行库。原文使用<code>riscv64-linux-gnu-</code>，表示GCC工具链会使用Linux的Glibc作为C运行库。但是本人未编译成功。故后面编译工具均使用<code>riscv64-unknown-elf-</code>，与原文不同。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/opensbi<br>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- make PLATFORM=generic<br></code></pre></td></tr></table></figure><h3 id="EDK2-固件"><a href="#EDK2-固件" class="headerlink" title="EDK2 固件"></a>EDK2 固件</h3><blockquote><p>此处原文里设置了一些环境变量在开头我们设置了，请不要重新设置，尤其不能<code>export WORKSPACE=pwd</code>，因为与源码脚本的WORKSPACE冲突。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/tianocore<br><span class="hljs-built_in">source</span> edk2/edksetup.sh<br>make -C edk2/BaseTools clean<br>make -C edk2/BaseTools<br>make -C edk2/BaseTools/Source/C<br><span class="hljs-built_in">source</span> edk2/edksetup.sh BaseTools<br><span class="hljs-comment"># 原文使用 -buildtarget RELEASE。但是提示 Not supported target RELEASE</span><br>build -a RISCV64 -b DEBUG -D FW_BASE_ADDRESS=0x80200000 -D EDK2_PAYLOAD_OFFSET -p Platform/Qemu/RiscvVirt/RiscvVirt.dsc -t GCC5<br></code></pre></td></tr></table></figure><h4 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h4><ol><li><p><strong>StoreCurrentConfiguration:7: no such file or directory: /home/user/riscv64-acpi/tianocore/Conf/BuildEnv.sh</strong></p><p> 不要设置<code>export WORKSPACE=pwd</code>！！！如果所有方法都不可行，直接把路径写死<code>export CONF_PATH=$WORK_DIR/tianocore/edk2/Conf</code></p></li><li><p><strong>uuid/uuid.h: No such file or directory</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install uuid-dev<br></code></pre></td></tr></table></figure></li><li><p><strong>Not supported target RELEASE</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 将build命令改为如下，使用DEBUG版本。</span><br>build -a RISCV64 -b DEBUG -D FW_BASE_ADDRESS=0x80200000 -D EDK2_PAYLOAD_OFFSET -p Platform/Qemu/RiscvVirt/RiscvVirt.dsc -t GCC5<br></code></pre></td></tr></table></figure></li></ol><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/linux<br>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- defconfig<br>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- -j $(nproc)<br></code></pre></td></tr></table></figure><h3 id="Rootfs"><a href="#Rootfs" class="headerlink" title="Rootfs"></a>Rootfs</h3><p>您可以使用您选择的任何 rootfs。此示例使用 buildroot。</p><blockquote><p>此步耗时较久，与网络环境有关，如果网络不好可能按小时算。容易中断，需要重新下载。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/<br>git <span class="hljs-built_in">clone</span> https://hub.fastgit.xyz/buildroot/buildroot.git<br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/buildroot<br>make qemu_riscv64_virt_defconfig<br>make rootfs-cpio<br></code></pre></td></tr></table></figure><h2 id="创建-EFI-分区并复制文件"><a href="#创建-EFI-分区并复制文件" class="headerlink" title="创建 EFI 分区并复制文件"></a>创建 EFI 分区并复制文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash">fallocate -l 512M efi.img<br>sgdisk -n 1:34: -t 1:EF00 <span class="hljs-variable">$WORK_DIR</span>/efi.img<br>sudo losetup -fP <span class="hljs-variable">$WORK_DIR</span>/efi.img<br>loopdev=`losetup -j <span class="hljs-variable">$WORK_DIR</span>/efi.img | awk -F: <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`<br>efi_part=<span class="hljs-string">&quot;<span class="hljs-variable">$loopdev</span>&quot;</span>p1<br>sudo mkfs.msdos <span class="hljs-variable">$efi_part</span><br>mkdir -p /tmp/mnt<br>sudo mount <span class="hljs-variable">$efi_part</span> /tmp/mnt/<br>sudo cp <span class="hljs-variable">$WORK_DIR</span>/linux/arch/riscv/boot/Image /tmp/mnt/<br>sudo umount /tmp/mnt<br>sudo losetup -D <span class="hljs-variable">$loopdev</span><br></code></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="使用-virtio-blk-磁盘"><a href="#使用-virtio-blk-磁盘" class="headerlink" title="使用 virtio-blk 磁盘"></a>使用 virtio-blk 磁盘</h3><blockquote><p>原文参数<code>-drive file=$WORK_DIR/buildroot/output/images/rootfs.ext2,format=raw,id=hd0</code>需要更改如下。因为在编译 Rootfs 时的命令是<code>make rootfs-cpio</code>所以生成的是<code>rootfs.cpio</code>。无法找到<code>rootfs.ext2</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-variable">$WORK_DIR</span>/qemu/build/qemu-system-riscv64 -nographic \<br>-machine virt,aclint=on,aia=aplic-imsic,acpi=on -cpu rv64,sscofpmf=<span class="hljs-literal">true</span> -smp 8  -m 2G  \<br>-bios <span class="hljs-variable">$WORK_DIR</span>/opensbi/build/platform/generic/firmware/fw_jump.elf \<br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd  \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.cpio,format=raw,id=hd0 \<br>-device virtio-blk-device,drive=hd0 \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/efi.img,format=raw,id=hd1 \<br>-device virtio-blk-device,drive=hd1 \<br>-device virtio-net-device,netdev=usernet \<br>-netdev user,id=usernet,hostfwd=tcp::9990-:22<br></code></pre></td></tr></table></figure><h4 id="ERROR-1"><a href="#ERROR-1" class="headerlink" title="ERROR"></a>ERROR</h4><ol><li><p>无法找到<code>rootfs.ext2</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 因为在编译 Rootfs 时的命令是 make rootfs-cpio 所以生成的是 rootfs.cpio</span><br><span class="hljs-comment"># 原文参数</span><br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.ext2,format=raw,id=hd0 \<br><span class="hljs-comment"># 修改为</span><br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.cpio,format=raw,id=hd0 \<br></code></pre></td></tr></table></figure></li><li><p>无法找到<code>RISCVVIRT.fd</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 因为编译 EDK2 固件时，参数是-b DEBUG 版本，原文是 RELEASE 版本，这两个版本路径不一样，所以找不到</span><br><span class="hljs-comment"># 原文参数</span><br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/RELEASE_GCC5/FV/RISCVVIRT.fd  \<br><span class="hljs-comment"># 修改为</span><br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd  \<br></code></pre></td></tr></table></figure></li></ol><p>At EFI Shell:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Shell&gt; fs0:\Image root=/dev/vdb console=ttyS0 rootwait earlycon<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713153915.bmp"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713153932.bmp"></p><h3 id="使用-virtio-scsi-磁盘"><a href="#使用-virtio-scsi-磁盘" class="headerlink" title="使用 virtio-scsi 磁盘"></a>使用 virtio-scsi 磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-variable">$WORK_DIR</span>/qemu/build/qemu-system-riscv64 -nographic \<br>-machine virt,aclint=on,aia=aplic-imsic,acpi=on -cpu rv64,ssofpmf=<span class="hljs-literal">true</span> -smp 8  -m 2G \<br>-bios <span class="hljs-variable">$WORK_DIR</span>/opensbi/build/platform/generic/firmware/fw_jump.elf \<br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd  \<br>-device virtio-scsi-pci,id=scsi0,num_queues=4 \<br>-device scsi-hd,drive=drive0,bus=scsi0.0,channel=0,scsi-id=0,lun=0 \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.cpio,format=raw,<span class="hljs-keyword">if</span>=none,id=drive0 \<br>-device virtio-scsi-pci,id=scsi1,num_queues=4 \<br>-device scsi-hd,drive=drive1,bus=scsi0.0,channel=0,scsi-id=1,lun=0 \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/efi.img,format=raw,<span class="hljs-keyword">if</span>=none,id=drive1 \<br>-device virtio-net-device,netdev=usernet \<br>-netdev user,id=usernet,hostfwd=tcp::9990-:22<br></code></pre></td></tr></table></figure><p>At EFI Shell:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Shell&gt; fs0:\Image root=/dev/sda console=ttyS0 rootwait earlycon<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>RISC-V</tag>
      
      <tag>ACPI</tag>
      
      <tag>Kernel</tag>
      
      <tag>内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-LAB-Cache Lab</title>
    <link href="/2022/07/11/CSAPP-LAB-Cache-Lab/"/>
    <url>/2022/07/11/CSAPP-LAB-Cache-Lab/</url>
    
    <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>开始这个实验前，需要学习《CSAPP 第六章-存储器层次结构》的相关内容，与缓存相关的内容，我也做了相关的<a href="https://dunky-z.github.io/2022/07/10/CPU-Cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/">CPU Cache 高速缓存学习记录</a>可以参考。</p><p>实验相关的文件可以从<a href="http://csapp.cs.cmu.edu/3e/labs.html">CS:APP3e, Bryant and O’Hallaron</a>下载。</p><p>其中，</p><ul><li>README：介绍实验目的和实验要求，以及实验的相关文件。需要注意的是，必须在 64-bit x86-64 system 上运行实验。需要安装 Valgrind 工具。</li><li>Writeup：实验指导。</li><li>Release Notes：版本发布信息。</li><li>Self-Study Handout：<strong>需要下载的压缩包</strong>，里面包含了待修改的源码文件等。</li></ul><p>下载 Self-Study Handout 并解压，得到如下文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── cachelab.c    <span class="hljs-comment"># 一些辅助函数，如打印输出等，不需要修改</span><br>├── cachelab.h    <span class="hljs-comment"># 同上</span><br>├── csim.c        <span class="hljs-comment"># 需要完善的主文件，需要在这里模拟Cache</span><br>├── csim-ref      <span class="hljs-comment"># 已经编译好的程序，我们模拟的Cache需要与这个程序运行的结果保持一致</span><br>├── driver.py     <span class="hljs-comment"># 驱动程序，运行 test-csim 和 test-trans</span><br>├── Makefile      <span class="hljs-comment"># 用来编译csim程序</span><br>├── README        <span class="hljs-comment"># </span><br>├── test-csim     <span class="hljs-comment"># 测试缓存模拟器</span><br>├── test-trans.c  <span class="hljs-comment"># 测试转置功能</span><br>├── tracegen.c    <span class="hljs-comment"># test-trans 辅助程序</span><br>├── traces        <span class="hljs-comment"># test-csim.c 使用的跟踪文件</span><br>│   ├── dave.trace<br>│   ├── long.trace<br>│   ├── trans.trace<br>│   ├── yi2.trace<br>│   └── yi.trace<br>└── trans.c<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711145159.png"></p><h2 id="Part-A-——-Writing-A-Cache-Simulator"><a href="#Part-A-——-Writing-A-Cache-Simulator" class="headerlink" title="Part A —— Writing A Cache Simulator"></a>Part A —— Writing A Cache Simulator</h2><p>在 Part A，我们将在 <code>csim.c</code> 中编写一个缓存模拟器，它将 <code>valgrind</code> 内存跟踪作为输入，在此跟踪上模拟高速缓存的命中/未命中行为，并输出命中、未命中和驱逐的总数。</p><p>这里的输入由<code>valgrind</code>通过以下命令生成的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l<br></code></pre></td></tr></table></figure><p><code>--log-fd=1</code>表示将输出输出到标准输出；<br><code>--tool=lackey</code>：Lackey 是一个简单的 Valgrind 工具，可进行各种基本程序测量；<br><code>--trace-mem=yes</code>：Lackey 的一个参数，启用后，Lackey 会打印程序几乎所有内存访问的大小和地址；<br><code>ls -l</code>：是一个简单的程序，可以查看当前目录下的文件列表。<br>也就是检测<code>ls -l</code>程序在运行时访问内存的情况。</p><p>执行结果像下面的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># [space]operation address,size</span><br>I  0400639c,4<br> L 1ffeffec00,8<br>I  040063a0,2<br> S 1ffeffea50,8<br>I  040063a2,4<br> L 1ffeffebf0,8<br>I  040063a6,3<br>I  040063a9,3<br> L 1ffeffebf8,4<br>I  040063ac,7<br></code></pre></td></tr></table></figure><p>操作字段表示内存访问的类型：<code>I</code>表示指令加载，<code>L</code>表示数据加载，<code>S</code>表示数据存储，<code>M</code>表示数据修改（即，数据加载后跟数据存储） ）。每个<code>I</code>之前都没有空格。每个<code>M</code>、<code>L</code>和<code>S</code>之前总是有一个空格。地址字段指定一个 <code>64</code> 位的十六进制内存地址。 <code>size</code> 字段指定操作访问的字节数。</p><p>了解这些基础后，<strong>我们最主要的是要明确，我们需要实现一个什么样的程序，这个程序具体有哪些参数，怎么执行的</strong>。<code>csim-ref</code>是已经完成的可执行文件，它的用法是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;<br></code></pre></td></tr></table></figure><ul><li><code>-h</code>：打印帮助信息；</li><li><code>-v</code>：显示详细信息，如是 I，L 还是 M；</li><li><code>-s &lt;s&gt;</code>：组索引位数（$S=2^{s}$组个数）；</li><li><code>-E &lt;E&gt;</code>：关联性（每组的行数）；</li><li><code>-b &lt;b&gt;</code>：块位数（$B=2^{b}$ 是块大小）；</li><li><code>-t &lt;tracefile&gt;</code>：valgrind 生成的文件；</li></ul><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace<br>hits:4 misses:5 evictions:3<br></code></pre></td></tr></table></figure><p>如果显示详细信息可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace<br>L 10,1 miss<br>M 20,1 miss hit<br>L 22,1 hit<br>S 18,1 hit<br>L 110,1 miss eviction<br>L 210,1 miss eviction<br>M 12,1 miss eviction hit<br>hits:4 misses:5 evictions:3<br></code></pre></td></tr></table></figure><p>我们的目的就是要完善<code>csim.c</code>，使其能够使用上面相同的参数，得到与<code>csim-ref</code>相同的结果。<br><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">Cache Lab Implementa/on and Blocking</a>这份 PPT 里有一些实验指导，可以参考。<br>首先需要解决的就是如何处理输入的参数，我们可以使用 PPT 里提到的<code>getopt</code>库来解决。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;cachelab.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;getopt.h&quot;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> S; <span class="hljs-comment">// 组个数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s; <span class="hljs-comment">// 组占的位数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> E;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> B;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> hits = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> misses = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> evictions = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CacheLine</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> tag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CacheLine</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CacheLine</span> *<span class="hljs-title">prev</span>;</span><br>&#125; CacheLine;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Cache</span> &#123;</span><br>    CacheLine *head;<br>    CacheLine *tail;<br>    <span class="hljs-keyword">int</span> *size;<br>&#125; Cache;<br><br><span class="hljs-keyword">static</span> Cache *cache;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parse_option</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **fileName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> option;<br>    <span class="hljs-keyword">while</span> ((option = getopt(argc, argv, <span class="hljs-string">&quot;s:E:b:t:&quot;</span>)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">switch</span> (option) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>            s = atoi(optarg);<br>            <span class="hljs-comment">// 传入的参数为占用的bit，需要转换为10进制</span><br>            S = <span class="hljs-number">1</span> &lt;&lt; s;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>            E = atoi(optarg);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>            B = atoi(optarg);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            <span class="hljs-built_in">strcpy</span>(*fileName, optarg);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialize_cache</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cache = <span class="hljs-built_in">malloc</span>(S * <span class="hljs-keyword">sizeof</span>(*cache));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<br>        cache[i].head = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CacheLine));<br>        cache[i].tail = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CacheLine));<br><br>        cache[i].head-&gt;next = cache[i].tail;<br>        cache[i].tail-&gt;prev = cache[i].head;<br>        (cache[i].size) = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>        *(cache[i].size) = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * @breif Add a new CacheLine to the Cache first line</span><br><span class="hljs-comment"> * @param nodeToDel CacheLine to be deleted</span><br><span class="hljs-comment"> * @param curLru  Current Cache</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert_first_line</span><span class="hljs-params">(CacheLine *node, Cache *curLru)</span></span><br><span class="hljs-function"></span>&#123;<br>    node-&gt;next = curLru-&gt;head-&gt;next;<br>    node-&gt;prev = curLru-&gt;head;<br><br>    curLru-&gt;head-&gt;next-&gt;prev = node;<br>    curLru-&gt;head-&gt;next = node;<br><br>    *(curLru-&gt;size) = *(curLru-&gt;size) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evict</span><span class="hljs-params">(CacheLine *nodeToDel, Cache *curLru)</span></span><br><span class="hljs-function"></span>&#123;<br>    nodeToDel-&gt;next-&gt;prev = nodeToDel-&gt;prev;<br>    nodeToDel-&gt;prev-&gt;next = nodeToDel-&gt;next;<br>    *(curLru-&gt;size) = *(curLru-&gt;size) - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> address)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0xFFFFFFFF</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> maskSet = mask &gt;&gt; (<span class="hljs-number">32</span> - s);<br>    <span class="hljs-comment">// 取出组索引</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> targetSet = ((maskSet) &amp; (address &gt;&gt; B));<br>    <span class="hljs-comment">// 取出标记</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> targetTag = address &gt;&gt; (s + B);<br><br>    Cache curLru = cache[targetSet];<br><br>    <span class="hljs-comment">// 查找是否存与当前标记位相同的缓存行</span><br>    CacheLine *cur = curLru.head-&gt;next;<br>    <span class="hljs-keyword">bool</span> found = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur != curLru.tail) &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;tag == targetTag) &#123;<br>            found = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (found) &#123;<br>        hits++;<br>        evict(cur, &amp;curLru);<br>        insert_first_line(cur, &amp;curLru);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; hit!, set: %d \n&quot;</span>, targetSet);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        CacheLine *newNode = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CacheLine));<br>        newNode-&gt;tag = targetTag;<br>        <span class="hljs-keyword">if</span> (*(curLru.size) == E) &#123; <span class="hljs-comment">// 如果缓存已满，则删除最后一个缓存行</span><br>            evict(curLru.tail-&gt;prev, &amp;curLru);<br>            insert_first_line(newNode, &amp;curLru);<br>            evictions++;<br>            misses++;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; evic &amp;&amp; miss set:%d\n&quot;</span>, targetSet);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            misses++;<br>            insert_first_line(newNode, &amp;curLru);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; miss %d\n&quot;</span>, targetSet);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cache_simulate</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fileName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 分配并初始化S组缓存</span><br>    initialize_cache();<br><br>    FILE *file = fopen(fileName, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">char</span> op;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(file, <span class="hljs-string">&quot; %c %x,%d&quot;</span>, &amp;op, &amp;address, &amp;size) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c, %x %d\n&quot;</span>, op, address, size);<br>        <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>            update(address);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:<br>            update(address);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>            update(address);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *fileName = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br><br>    parse_option(argc, argv, &amp;fileName);<br>    cache_simulate(fileName);<br>    printSummary(hits, misses, evictions);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>CSAPP-Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
      <tag>Linux</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU Cache 高速缓存</title>
    <link href="/2022/07/10/CPU-Cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/"/>
    <url>/2022/07/10/CPU-Cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081652018.png"></p><p>从 Cache、内存，到 SSD 和 HDD 硬盘，一台现代计算机中，就用上了所有这些存储器设备。其中，容量越小的设备速度越快，而且，CPU 并不是直接和每一种存储器设备打交道，而是每一种存储器设备，只和它相邻的存储设备打交道。比如，CPUCache 是从内存里加载而来的，或者需要写回内存，并不会直接写回数据到硬盘，也不会直接从硬盘加载数据到 CPUCache 中，而是先加载到内存，再从内存加载到 Cache 中。</p><p>这样，各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降，也就构成了我们日常所说的存储器层次结构。</p><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>缓存不是 CPU 的专属功能，可以把它当成一种策略，任何时候想要增加数据传输性能，都可以通过加一层缓存试试。</p><p>存储器层次结构的中心思想是，对于每个$k$，位于$k$层的更快更小的存储设备作为位于$k+1$层的更大更慢的存储设备的缓存。<a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86">下图</a>展示了存储器层次结构中缓存的一般性概念。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711145943.png"></p><div id="存储器层次结构中基本的缓存原理"></div><p>数据总是以块<code>block</code>为单位，在层与层之间来回复制。</p><p>说回高速缓存，按照摩尔定律，CPU 的访问速度每 18 个月便会翻一翻，相当于每年增长 60%。内存的访问速度虽然不断增长，却远没有那么快，每年只增长 7% 左右。这样就导致 CPU 性能和内存访问的差距不断拉大。为了弥补两者之间差异，现代 CPU 引入了<strong>高速缓存</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220708092012.png"></p><p>CPU 的读（load）实质上就是从缓存中读取数据到寄存器（register）里，在多级缓存的架构中，如果缓存中找不到数据（Cache miss），就会层层读取二级缓存三级缓存，一旦所有的缓存里都找不到对应的数据，就要去内存里寻址了。寻址到的数据首先放到寄存器里，其副本会驻留到 CPU 的缓存中。</p><p>CPU 的写（store）也是针对缓存作写入。并不会直接和内存打交道，而是通过某种机制实现数据从缓存到内存的写回（write back）。</p><p>缓存到底如何与 CPU 和主存数据交换的？CPU 如何从缓存中读写数据的？缓存中没有读的数据，或者缓存写满了怎么办？我们先从 CPU 如何读取数据说起。</p><h2 id="缓存读取"><a href="#缓存读取" class="headerlink" title="缓存读取"></a>缓存读取</h2><p>CPU 发起一个读取请求后，返回的结果会有如下几种情况：</p><ul><li>缓存命中 (cache hit)<br>要读取的数据刚好在缓存中，叫做<strong>缓存命中</strong>。</li><li>缓存不命中 (cache miss)<br>发送缓存不命中，缓存就得执行一直<strong>放置策略</strong>(placement policy)，比如 LRU。来决定从主存中取出的数据放到哪里。<ul><li><strong>强制性不命中</strong>(compulsory miss)/冷不命中(cold miss)：缓存中没有要读取的数据，需要从主存读取数据，并将数据放入缓存。</li><li><strong>冲突不命中</strong>(conflict miss)：缓存中有要读的数据，在采取放置策略时，从主存中取数据放到缓存时发生了冲突，这叫做冲突不命中。</li></ul></li></ul><h3 id="高速缓存存储器组织结构"><a href="#高速缓存存储器组织结构" class="headerlink" title="高速缓存存储器组织结构"></a>高速缓存存储器组织结构</h3><p>整个 Cache 被划分为 1 个或多个<strong>组</strong> (Set)，$S$ 表示组的个数。每个组包含 1 个或多个<strong>缓存行</strong>(Cache line)，$E$ 表示一个组中缓存行的行数。每个缓存行由三部分组成：<strong>有效位</strong>(valid)，<strong>标记位</strong>（tag），<strong>数据块</strong>（cache block）。</p><ul><li>有效位：该位等于 1，表示这个行数据有效。</li><li>标记位：唯一的标识了存储在高速缓存中的块，标识目标数据是否存在当前的缓存行中。</li><li>数据块：一部分内存数据的副本。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711171136.png"></p><p>Cache 的结构可以由元组$(S,E,B,m)$表示。不包括有效位和标记位。Cache 的大小为 $C=S \times E \times B$.</p><p>接下来看看 Cache 是如何工作的，当 CPU 执行数据加载指令，从内存地址 A 读取数据时，根据存储器层次原理，如果 Cache 中保存着目标数据的副本，那么就立即将数据返回给 CPU。那么 Cache 如何知道自己保存了目标数据的副本呢？</p><p>假设目标地址的数据长度为$m$位，这个地址被参数 $S$ 和 $B$ 分成了三个字段：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711174416.png"></p><p>首先通过长度为$s$的<strong>组索引</strong>，确定目标数据保存在哪一个组 (Set) 中，其次通过长度为$t$的<strong>标记</strong>，确定在哪一行，需要注意的是此时有效位必须等于 1，最后根据长度为$b$的<strong>块偏移</strong>，来确定目标数据在数据块中的确切位置。</p><blockquote><p>Q：既然读取 Cache 第一步是组选择，为什么不用高位作为组索引，而使用中间的为作为组索引？<br>A：如果使用了高位作索引，那么一些连续的内存块就会映射到相同的高速缓存块。如图前四个块映射到第一个缓存组，第二个四个块映射到第二个组，依次类推。如果一个程序有良好的空间局部性，顺序扫描一个数组的元素，那么在任何时候，缓存中都只保存在一个块大小的数组内容。这样对缓存的使用率很低。相比而言，如果使用中间的位作为组索引，那么相邻的块总是映射到不同的组，图中的情况能够存放整个大小的数组片。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711185819.png"></p></blockquote><h3 id="直接映射高速缓存-Direct-Mapped-Cache"><a href="#直接映射高速缓存-Direct-Mapped-Cache" class="headerlink" title="直接映射高速缓存 Direct Mapped Cache"></a>直接映射高速缓存 Direct Mapped Cache</h3><p>根据每个组的缓存行数 $E$ 的不同，Cache 被分为不同的类。每个组只有一行$E=1$的高速缓存被称为<strong>直接映射高速缓存</strong>(direct-mapped cache)。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711190845.png"></p><p>当一条加载指令指示 CPU 从主存地址 A 中读取一个字 w 时，会将该主存地址 A 发送到高速缓存中，则高速缓存会根据<strong>组选择</strong>，<strong>行匹配</strong>和<strong>字抽取</strong>三步来判断地址 A 是否命中。</p><p><strong>组选择</strong>(set selection)：根据组索引值来确定属于哪一个组，如图中索引长度为 5 位，可以检索 32 个组 ($2^5=32$)。当$s=0$时，此时组选择的结果为<code>set 0</code>，当$s=1$时，此时组选择的结果为<code>set 1</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711191708.png"></p><p>**行匹配 (line match)**：首先看缓存行的有效位，此时有效位为 1，表示当前数据有效。然后对比缓存行的标记<code>0110</code>与地址中的标记<code>0110</code>是否相等，如果相等，则表示目标数据在当前的缓存行中（缓存命中）。如果不一致或者有效位为 0，则表示目标数据不在当前的缓存行中（缓存不命中）。如果命中，就可以进行下一步字抽取。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711192435.png"></p><p>**字抽取 (word extraction)**：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于<code>100</code>时，表示目标数据起始地址位于字节 4 处。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711192757.png"></p><p>下面通过一个例子来解释清除这个过程。假设我们有一个直接映射高速缓存，描述为$(S,E,B,m) = (4,1,2,4)$。换句话说，高速缓存有 4 个组，每个组 1 行，每个数据块 2 个字节，地址长度为 4 位。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711194256.png"></p><p>从图中可以看出，8 个内存块，但只有 4 个高速缓存组，所以会有多个块映射到同一个高速缓存组中。例如，块 0 和块 4 都会被映射到组 0。</p><p>下面我们来模拟当 CPU 执行一系列读的时候，高速缓存的执行情况，我们假设每次 CPU 读 1 个字节的字。</p><p><strong>读地址 0(0000) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711193901.gif"></p><p><strong>读地址 1(0001) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711194838.gif"></p><p><strong>读地址 13(1101) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711195108.gif"></p><p><strong>读地址 8(1000) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711200054.gif"></p><p><strong>读地址 0(0000) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711200409.gif"></p><h3 id="组相联高速缓存-Set-Associative-Cache"><a href="#组相联高速缓存-Set-Associative-Cache" class="headerlink" title="组相联高速缓存 Set Associative Cache"></a>组相联高速缓存 Set Associative Cache</h3><p>由于直接映射高速缓存的组中只有一行，所以容易发生冲突不命中。组相联高速缓存 (Set associative cache) 运行有多行缓存行。但是缓存行最大不能超过 $C/B$。</p><p>如图一个组中包含了两行缓存行，这种我们称为 2 路相联高速缓存。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220712160513.png"></p><p><strong>组选择</strong>：与直接映射高速缓存的组选择过程一样。</p><p><strong>行匹配</strong>：因为一个组有多行，所以需要遍历所有行，找到一个有效位为 1，并且标记为与地址中的标记位相匹配的一行。如果找到了，表示缓存命中。</p><p><strong>字抽取</strong>：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于<code>100</code>时，表示目标数据起始地址位于字节 4 处。</p><p>如果不命中，那么就需要从主存中取出需要的数据块，但是将数据块放在哪一行缓存行呢？如果存在空行 ($valid=0$)，那就放到空行里。如果没有空行，就得选择一个非空行来替换，同时希望 CPU 不会很快引用这个被替换的行。这里介绍几个替换策略。</p><p>最简单的方式就是随机选择一行来替换，其他复杂的方式就是利用局部性原理，使得接下来 CPU 引用替换的行概率最小。如</p><ul><li>最不常使用 (LFU, Least Frequently Used)，选择使用次数最少的行。</li><li>最近最少使用 (LRU, Least Recently Used)，选择最近使用最少的行。</li></ul><h3 id="全相联高速缓存-Fully-Associative-Cache"><a href="#全相联高速缓存-Fully-Associative-Cache" class="headerlink" title="全相联高速缓存 Fully Associative Cache"></a>全相联高速缓存 Fully Associative Cache</h3><p>整个 Cache 只有一个组，这个组包含了所有的缓存行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713165007.png"></p><p><strong>组选择</strong>：因为只有一个组，所有默认总是选择 set 0。实际上这不就直接可以忽略了，访问的地址也就只需要划分为标记和偏移。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713165209.png"></p><p><strong>行匹配</strong>：同组相联高速缓存。</p><p><strong>字抽取</strong>：同组相联高速缓存。</p><p>由于硬件实现及成本等原因，全相联高速缓存只适合做小规模的缓存。例如虚拟内存中的 TLB（翻译备用缓存器，Translation Lookaside Buffer）。</p><h3 id="缓存写入"><a href="#缓存写入" class="headerlink" title="缓存写入"></a>缓存写入</h3><p>写入 Cache 的性能比写入主内存要快，那么写入数据到底是写入 Cache 还是写入主内存呢？如果直接写入主内存里，Cache 里面的数据是否会失效呢？</p><h4 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h4><p>写直达策略（Write-Through）：当数据要写入主内存里面，写入前，会先去判断数据是否已经在 Cache 里面了。如果数据已经在 Cache 里了，先把数据写入更新到 Cache 里面，再写入到主内存里面；如果数据不在 Cache 里，就只更新主内存。</p><h4 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h4><p>写回策略（Write-Back）：如果发现要写入的数据，就在 CPU Cache 里面，那么就只是更新 CPU Cache 里面的数据。同时，会标记 CPU Cache 里的这个 Block 是脏（Dirty）的，表示 CPU Cache 里面的这个 Block 的数据，和主内存是不一致的。如果发现，要写入的数据所对应的 Cache Block 里，放的是别的内存地址的数据，那么就要看一看，那个 Cache Block 里面的数据有没有标记成脏的。如果是脏的话，要先把这个 Cache Block 里面的数据，写入到主内存里面。然后，再把当前要写入的数据，写入到 Cache 里，同时把 Cache Block 标记成脏的。如果 Block 里面的数据没有被标记成脏的话，那么直接把数据写入到 Cache 里面，然后再把 Cache Block 标记成脏的就好了。</p><p>在用了写回这个策略之后，在加载内存数据到 Cache 里面的时候，也要多出一步同步脏 Cache 的动作。如果加载内存里面的数据到 Cache 的时候，发现 Cache Block 里面有脏标记，也要先把 Cache Block 里的数据写回到主内存，才能加载数据覆盖掉 Cache。</p><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p><a href="https://dunky-z.github.io/2022/05/29/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7MESI%E5%8D%8F%E8%AE%AE/">CPU 缓存一致性 MESI 协议 - 如云泊</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html">C/C++中 volatile 关键字详解 - chao_yu - 博客园</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/41806033">volatile 能解决 cache 的数据一致性吗？答案是不能_天才 2012 的博客-CSDN 博客_volatilewritecache</a><br><a href="https://www.cnblogs.com/xmzJava/p/11417943.html">cpu 缓存和 volatile - XuMinzhe - 博客园</a><br><a href="https://www.bilibili.com/video/BV18L411t7zY/?spm_id_from=333.788&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">【CSAPP-深入理解计算机系统】6-5. 直接映射高速缓存_哔哩哔哩_bilibili</a><br><a href="https://cloud.tencent.com/developer/article/1815375">24 张图 7000 字详解计算机中的高速缓存 - 腾讯云开发者社区 - 腾讯云</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>缓存一致性</tag>
      
      <tag>Cache</tag>
      
      <tag>组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码管理器-KeePass</title>
    <link href="/2022/07/09/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8-KeePass/"/>
    <url>/2022/07/09/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8-KeePass/</url>
    
    <content type="html"><![CDATA[<h2 id="KeePass-安装"><a href="#KeePass-安装" class="headerlink" title="KeePass 安装"></a><strong>KeePass 安装</strong></h2><p><strong>下载与安装</strong></p><p>官网： <a href="https://keepass.info/download.html">https://keepass.info/download.html</a></p><p>下载完成后进行安装，默认安装位置是：<code>C:\Program Files (x86)\KeePass Password Safe 2</code>文件夹下，可以根据自己需要选择安装路径。</p><p><strong>更改中文语言</strong></p><p>中文语言包： <a href="https://www.keepass.com.cn/language#:~:text=%E5%9C%A8keepass%E4%B8%AD%EF%BC%8C%E5%8D%95%E5%87%BB,%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8Keepass%E3%80%82">KeePass-Chinese_Simplified</a></p><p>将语言包下载后复制到安装路径下的<strong>Languages</strong>文件夹下，默认为：<strong>C:\Program Files (x86)\KeePass Password Safe 2\Languages。<strong><strong>重启软件</strong></strong>。</strong></p><p>点击 <strong>View</strong>-&gt;<strong>Change Language</strong>. 选择中文简体（Chinese-Simplified）。<strong>重启软件</strong>，即可完成语言更改。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091913508.png"></p><p>中文界面：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091913034.png"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h2><p>1.创建一个数据库</p><p>点击 文件-》新建。弹出对话框为数据库创建管理密码。这个密码是唯一需要记忆的密码。当然如果追求更高的安全性，可以点击<strong>显示高级选项</strong>，提供更多的密码选项。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091913919.png"></p><p>2.添加记录</p><p>点击添加记录，在弹出的窗口填入相关信息。即可完成密码添加。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091914888.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091914656.png"></p><p>如果是第一次使用的网站，第一次注册密码。可以通过密码生成器，生成一个高强度的密码来添加记录。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091914597.png"></p><p>3.创建一个密码生成模板</p><p>正常国内的网站可以使用的密码长度 6-16 位，可以使用大小写，数字，下划线。我们把这些选项勾选，密码长度设置 16 位。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091915434.png"></p><p>点击保存并给模板设置个名字方便下次使用</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091915338.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091915241.png"></p><p>如果保存后想更改一下，比如再加个可以使用空格，可以重新勾选刚刚的选项，保存时点击小三角，选择刚刚保存的方案就可以覆盖。</p><p><strong>导入 Chrome 已保存的密码</strong></p><p>很多小伙伴在使用 KeePass 之前肯定在 Chrome 等浏览器里也保存了很多密码。想将其导入 KeePass 方便管理。Chrome 是可以导出密码的，KeePass 也可以导入密码。</p><p>点击浏览器右上角，打开设置界面。找到<strong>密码</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091915807.png"></p><p>找到已保存的密码-》导出密码。选择方便找到的路径，保存密码记录。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091915014.png"></p><p>打开 KeePass，点击文件-》导入，选择 Chrome 浏览器的格式。点击文件夹图标找到刚刚导出的密码文件。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091916436.png"></p><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><h3 id="KeePass-搭配坚果云实现云同步"><a href="#KeePass-搭配坚果云实现云同步" class="headerlink" title="KeePass 搭配坚果云实现云同步"></a><strong>KeePass 搭配坚果云实现云同步</strong></h3><p><a href="https://www.jianguoyun.com/">登录坚果云</a>创建个人同步文件夹，若没有先注册。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091916293.png"></p><p>最好单独建一个专门的文件夹</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091916684.png"></p><p>将已经生成的数据库上传到这个文件夹下</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091916021.png"></p><p>点击右上角进入<strong>账户信息，</strong>点击<strong>安全选项：</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091916935.png"></p><p>点击添加应用</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091917760.png"></p><p>输入应用名称，应用名称只是方便区分作用，所以和要同步的应用名称一致就好：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091917877.png"></p><p>点击<strong>生成密码</strong>：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091917649.png"></p><p>此时云盘端配置完成，切回到 KeePass 进行客户端配置。点击<strong>文件</strong>-》<strong>同步</strong>-》<strong>与网址（URL）同步</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091917478.png"></p><p><strong>网址：</strong> <a href="https://dav.jianguoyun.com/dav/">https://dav.jianguoyun.com/dav/</a><strong>KeePass</strong>/<strong>keepassData.kdbx</strong></p><p><strong>注意：红色部分是个人同步文件夹的名称，绿色部分是上传的数据库全称，一定别忘了后缀</strong></p><p><strong>用户名：</strong>你的坚果云登录名（邮箱或者手机号）</p><p><strong>密码</strong>：生成应用的密码，（<strong>不是登录坚果云的密码</strong>）</p><p>点击确定，此时已经可以完成同步，但是每次同步仍然需要手动确定。参考了<a href="https://post.smzdm.com/p/660417/">什么值得买上小乐 CSN</a>的方法，通过触发器实现自动同步。</p><p>触发器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;TriggerCollection xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;<br>        &lt;Triggers&gt;<br>                &lt;Trigger&gt;<br>                        &lt;Guid&gt;L2euC7Mr/EKh7nPjueuZvQ==&lt;/Guid&gt;<br>                        &lt;Name&gt;SaveSync&lt;/Name&gt;<br>                        &lt;Events&gt;<br>                                &lt;Event&gt;<br>                                        &lt;TypeGuid&gt;s6j9/ngTSmqcXdW6hDqbjg==&lt;/TypeGuid&gt;<br>                                        &lt;Parameters&gt;<br>                                                &lt;Parameter&gt;1&lt;/Parameter&gt;<br>                                                &lt;Parameter&gt;kdbx&lt;/Parameter&gt;<br>                                        &lt;/Parameters&gt;<br>                                &lt;/Event&gt;<br>                        &lt;/Events&gt;<br>                        &lt;Conditions /&gt;<br>                        &lt;Actions&gt;<br>                                &lt;Action&gt;<br>                                        &lt;TypeGuid&gt;tkamn96US7mbrjykfswQ6g==&lt;/TypeGuid&gt;<br>                                        &lt;Parameters&gt;<br>                                                &lt;Parameter&gt;SaveSync&lt;/Parameter&gt;<br>                                                &lt;Parameter&gt;0&lt;/Parameter&gt;<br>                                        &lt;/Parameters&gt;<br>                                &lt;/Action&gt;<br>                                &lt;Action&gt;<br>                                        &lt;TypeGuid&gt;Iq135Bd4Tu2ZtFcdArOtTQ==&lt;/TypeGuid&gt;<br>                                        &lt;Parameters&gt;<br>                                                &lt;Parameter&gt;https://dav.jianguoyun.com/dav/keePass/passwordSync.kdbx&lt;/Parameter&gt;<br>                                                &lt;Parameter&gt;123456&lt;/Parameter&gt;<br>                                                &lt;Parameter&gt;123456&lt;/Parameter&gt;<br>                                        &lt;/Parameters&gt;<br>                                &lt;/Action&gt;<br>                                &lt;Action&gt;<br>                                        &lt;TypeGuid&gt;tkamn96US7mbrjykfswQ6g==&lt;/TypeGuid&gt;<br>                                        &lt;Parameters&gt;<br>                                                &lt;Parameter&gt;SaveSync&lt;/Parameter&gt;<br>                                                &lt;Parameter&gt;1&lt;/Parameter&gt;<br>                                        &lt;/Parameters&gt;<br>                                &lt;/Action&gt;<br>                        &lt;/Actions&gt;<br>                &lt;/Trigger&gt;<br>        &lt;/Triggers&gt;<br>&lt;/TriggerCollection&gt;<br></code></pre></td></tr></table></figure><p>复制触发器代码，点击<strong>工具</strong>-》<strong>触发器</strong>，点击<strong>工具</strong>-》<strong>从剪切板粘贴触发器</strong>：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091918521.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091918858.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091918743.png"></p><p>导入成功后，在触发器页面会多一个触发器：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091918790.png"></p><p>双击打开<strong>SaveSync</strong>,打开最后一个<strong>动作</strong>窗口：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091918061.png"></p><p>双击中间的条目：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091919250.png"></p><p>将信息换成同步云盘的信息：</p><p><strong>文件/网址：</strong> <a href="https://dav.jianguoyun.com/dav/">https://dav.jianguoyun.com/dav/</a><strong>KeePass</strong>/<strong>keepassData.kdbx</strong></p><p><strong>注意：红色部分是个人同步文件夹的名称，绿色部分是上传的数据库全称，一定别忘了后缀</strong></p><p><strong>IO 连接 - 用户名：</strong>你的坚果云登录名（邮箱或者手机号）</p><p><strong>IO 连接 - 密码</strong>：生成应用的密码，（<strong>不是登录坚果云的密码</strong>）</p><p>点击确定，回到主页面，点击<strong>工具</strong>-》<strong>选项</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091919251.png"></p><p>找到 <strong>高级</strong>，向下翻，在<strong>文件输入/输出连接</strong> 栏目里找到 <strong>写入数据库时使用文件交换</strong> 此项不勾选</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091919398.png"></p><p>点击确定，返回主页面。此时点击保存按钮或者 Ctrl+S。即可与云盘进行同步。</p><h3 id="Chrome-上使用插件实现密码自动填充与同步"><a href="#Chrome-上使用插件实现密码自动填充与同步" class="headerlink" title="Chrome 上使用插件实现密码自动填充与同步"></a><strong>Chrome 上使用插件实现密码自动填充与同步</strong></h3><p>在 KeePass 客户端安装<a href="https://github.com/kee-org/keepassrpc/releases">KeePassRPC 插件</a>：</p><p>将其放入安装目录（.\KeePass\Plugins）文件夹下，退出软件，重启即可自动安装。</p><p>在浏览器客户端安装<a href="https://chrome.google.com/webstore/detail/kee-password-manager/mmhlniccooihdimnnjhamobppdhaolme">浏览器插件</a>Kee，若无法科学上网，可能需要自行百度搜索 Kee 插件</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091919168.png"></p><p>安装完成后会跳出窗口提示授权，将 KeePass 客户端跳出的窗口中的红色授权码填入即可连接浏览器：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091920270.png"></p><p>使用 Kee</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091920016.png"></p><p>再次使用浏览器填写密码是可以看到文本框会有 logo，Kee 会自动填写已保存的密码。如果第一次登陆，在登录后可以点击浏览器插件图标，找到 Save latest login，保存刚刚输入的密码。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091920687.png"></p><p>密码管理器的重要作用之一就是生成高强度密码，可以用 KeePass 客户端来生成，也可以是 Kee 这个插件的一个生成密码功能生成。英文版的是<strong>Generate new password</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091920769.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Efficiency</tag>
      
      <tag>推荐</tag>
      
      <tag>KeePass</tag>
      
      <tag>工具</tag>
      
      <tag>密码管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile 能否解决缓存一致性问题</title>
    <link href="/2022/07/08/volatile%E8%83%BD%E5%90%A6%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/08/volatile%E8%83%BD%E5%90%A6%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="volatile-能否解决缓存一致性问题"><a href="#volatile-能否解决缓存一致性问题" class="headerlink" title="volatile 能否解决缓存一致性问题"></a>volatile 能否解决缓存一致性问题</h1><p>为何会产生这样的疑问，还得从一个工作中的 Bug 说起。在使用 PMP（Physical Memory Protect）对物理内存进行保护时，无法成功保护，简单来说 PMP 可以对一段物理内存设置保护，如保护这段内存不可写。测试时，先对这段内存写入<code>0x1234</code>，再读取这段内存。如果读取的值为<code>0x0</code>表示保护成功，但实际总能成功读取<code>0x1234</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> test;<br>test = read(<span class="hljs-number">0xFF740000</span>);<br>print(<span class="hljs-string">&quot;Before = %x\n&quot;</span>, test); <span class="hljs-comment">// 保护之前数据 Before = 0x1111 </span><br>PMP(<span class="hljs-number">0xFF740000</span>, <span class="hljs-number">0x400</span>);       <span class="hljs-comment">// 保护这段内存不可写</span><br>write(<span class="hljs-number">0xFF740000</span>, <span class="hljs-number">0x1234</span>);    <span class="hljs-comment">// 写入数据</span><br>test = read(<span class="hljs-number">0xFF740000</span>);<br>print(<span class="hljs-string">&quot;After = %x\n&quot;</span>, test);  <span class="hljs-comment">// 预期读取为0x0，实际总能成功读取0x1234</span><br></code></pre></td></tr></table></figure><p>因为读取的变量<code>test</code>设置为<code>volatile</code>，所以按照以往的理解，系统总是重新从它所在的内存读取数据，这里应该能正确读取出数据。</p><p>但是忽略了一点，当使用<code>volatile</code>变量时，CPU 只是不再使用寄存器中的值，直接去内存中读取数据，这里的内存实际上是包括 Cache 的。</p><p>所以当数据被 Cached 之后，当再次读取时，CPU 可能会直接读取 Cached 的数据，而不是去读取真正内存中的数据。因此，<strong>volatile 不能解决缓存一致性问题</strong>。</p><p>关于 Cache 的详细信息，请参考<a href="https://dunky-z.github.io/2022/07/10/CPU-Cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/">CPU Cache 高速缓存 - 如云泊</a>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>缓存一致性</tag>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZH-CS 可视化 - 常用的 Git 命令</title>
    <link href="/2022/07/07/ZH-CS%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%B8%B8%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/07/ZH-CS%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%B8%B8%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="CS-可视化-常用的-Git-命令"><a href="#CS-可视化-常用的-Git-命令" class="headerlink" title="CS 可视化 - 常用的 Git 命令"></a>CS 可视化 - 常用的 Git 命令</h1><blockquote><p>Author：Lydia Hallie<br>译：<a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1">🌳🚀 CS Visualized: Useful Git Commands - DEV Community</a></p></blockquote><p>尽管 Git 是一个非常强大的工具，但我想大多数人都会同意，当我说它也可能是……一场彻头彻尾的噩梦当我执行某个命令时分支交互，它将如何影响历史记录？当我在<code>master</code>分支执行<code>hard reset</code>、<code>force push</code>到 <code>origin</code>、在<code>.git</code>文件夹执行<code>rimraf</code>的时候，为什么我的同事都哭了？</p><p>我认为这将是创建一些最常见和最有用命令的可视化示例的完美用例！我介绍的许多命令都有可选参数，您可以使用这些参数来更改它们的行为。在我的示例中，我将介绍命令的默认行为，而不添加（太多）配置选项！</p><h2 id="Merging"><a href="#Merging" class="headerlink" title="Merging"></a>Merging</h2><p>拥有多个分支非常方便，可以将新更改彼此分开，并确保您不会意外地将未经批准或损坏的更改推送到生产环境。一旦更改获得批准，我们希望在我们的生产分支中获得这些更改！</p><p>将更改从一个分支转移到另一个分支的一种方法是执行 <code>git merge</code>！Git 可以执行两种类型的合并：<code>fast-forward</code> 或​​ <code>no-fast-forward</code>。</p><p>现在这可能没有多大意义，所以让我们看看差异！</p><h3 id="Fast-forward-ff"><a href="#Fast-forward-ff" class="headerlink" title="Fast-forward (--ff)"></a>Fast-forward (<code>--ff</code>)</h3><p>如果当前分支与即将合并过来的分支相比，没有额外的提交，这种就是<code>fast-forward</code>合并。Git 很会偷懒，它会首先尝试最简单的方案，即<code>fast-forward</code>。这种合并方式不会创建新的提交，只是把另一个分支的提交记录直接合并到当前分支。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707163529.gif"></p><p>完美的！我们现在可以在 <code>master</code> 分支上使用在 <code>dev</code> 分支上所做的所有更改。那么，<code>no-fast-forward</code> 到底是什么？</p><h3 id="No-fast-foward-no-ff"><a href="#No-fast-foward-no-ff" class="headerlink" title="No-fast-foward (--no-ff)"></a>No-fast-foward (<code>--no-ff</code>)</h3><p>如果与您要合并的分支相比，您当前的分支没有任何额外的提交，那就太好了，但不幸的是，这种情况很少见！如果我们在当前分支上提交了我们想要合并的分支没有的更改，Git 将执行 <code>no-fast-forward</code> 合并。</p><p>使用 <code>no-fast-forward</code> 合并，Git 在活动分支上创建一个新的<strong>合并提交</strong>。提交的父提交指向活动分支和我们要合并的分支！</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164009.gif"></p><p>没什么大不了的，完美的合并！ <code>master</code> 分支现在包含我们在 <code>dev</code> 分支上所做的所有更改。</p><h3 id="Merge-Conflicts"><a href="#Merge-Conflicts" class="headerlink" title="Merge Conflicts"></a>Merge Conflicts</h3><p>尽管 Git 擅长决定如何合并分支和向文件添加更改，但它不能总是自己做出这个决定。当我们尝试合并的两个分支在同一个文件的同一行上发生更改时，可能会发生这种情况，或者如果一个分支删除了另一个分支修改的文件，等等。</p><p>在这种情况下，Git 会要求您帮助决定我们要保留两个选项中的哪一个！假设在两个分支上，我们编辑了 <code>README.md</code> 中的第一行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164137.png"></p><p>如果我们想将 <code>dev</code> 合并到 <code>master</code> 中，这将导致合并冲突：您希望标题是 <code>Hello!</code> 还是 <code>Hey!</code>？</p><p>当试图合并分支时，Git 会告诉你冲突发生在哪里。我们可以手动删除不想保留的更改，保存更改，再次添加更改的文件，然后提交更改</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164314.gif"></p><p>耶！尽管合并冲突通常很烦人，但它完全有道理：Git 不应该自己决定选择哪一个更改。</p><h2 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h2><p>我们刚刚看到了如何通过执行 <code>git merge</code> 将更改从一个分支应用到另一个分支。另一种将更改从一个分支添加到另一个的方法是执行<code>git rebase</code>。</p><p><code>git rebase</code> <em>复制</em>当前分支的提交，并将这些复制的提交放在指定分支的顶部。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164518.gif"></p><p>完美，我们现在可以在 <code>dev</code> 分支上使用在 <code>master</code> 分支上所做的所有更改！</p><p>与合并相比，一个很大的区别是 Git 不会尝试找出要保留和不保留的文件。我们正在变基的分支总是有我们想要保留的最新更改！通过这种方式，您不会遇到任何合并冲突，并保持良好的线性 Git 历史记录。</p><p>这个例子展示了基于 <code>master</code> 分支的变基。然而，在更大的项目中，您通常不想这样做。 <code>git rebase</code> <strong>改变了项目的历史</strong>，因为为复制的提交创建了新的哈希！</p><p>每当您在功能分支上工作并且主分支已更新时，重新定基都很棒。您可以获得分支上的所有更新，这将防止未来的合并冲突！</p><h3 id="Interactive-Rebase"><a href="#Interactive-Rebase" class="headerlink" title="Interactive Rebase"></a>Interactive Rebase</h3><p>在重新提交提交之前，我们可以修改它们！我们可以使用 <em>interactive rebase</em> 来做到这一点。交互式变基对于您当前正在处理的分支也很有用，并且想要修改一些提交。</p><p>我们可以对我们正在变基的提交执行 6 项操作：</p><ul><li><code>reword</code>: Change the commit message</li><li><code>edit</code>: Amend this commit</li><li><code>squash</code>: Meld commit into the previous commit</li><li><code>fixup</code>: Meld commit into the previous commit, without keeping the commit’s log message</li><li><code>exec</code>: Run a command on each commit we want to rebase</li><li><code>drop</code>: Remove the commit</li></ul><p>惊人的！这样，我们可以完全控制我们的提交。如果我们想删除一个提交，我们可以直接 <code>drop</code> 它。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164621.gif"></p><p>或者，如果我们想将多个提交压缩在一起以获得更清晰的历史记录，没问题！</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164900.gif"></p><p>交互式变基使您可以对尝试变基的提交进行大量控制，即使在当前活动分支上也是如此！</p><h2 id="Resetting"><a href="#Resetting" class="headerlink" title="Resetting"></a>Resetting</h2><p>我们可能会提交我们以后不想要的更改。也许它是一个<code>WIP</code>提交，或者是一个引入错误的提交！在这种情况下，我们可以执行 <code>git reset</code>。</p><p><code>git reset</code> 会删除所有当前暂存的文件，并让我们控制 <code>HEAD</code> 应该指向的位置。</p><h3 id="Soft-reset"><a href="#Soft-reset" class="headerlink" title="Soft reset"></a>Soft reset</h3><p><em>软重置</em>将 <code>HEAD</code> 移动到指定的提交（或提交的索引与 <code>HEAD</code> 相比），而不会消除随后在提交中引入的更改！</p><p>假设我们不想保留添加了<code>style.css</code>文件的提交<code>9e78i</code>，也不想保留添加了<code>index.js</code>文件的提交<code>035cc</code>。但是，我们确实希望保留新添加的 <code>style.css</code> 和 <code>index.js</code> 文件！软重置的完美用例。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707165037.gif"></p><p>输入 <code>git status</code> 时，您会看到我们仍然可以访问对先前提交所做的所有更改。这很棒，因为这意味着我们可以修复这些文件的内容并在以后再次提交它们！</p><h3 id="Hard-reset"><a href="#Hard-reset" class="headerlink" title="Hard reset"></a>Hard reset</h3><p>有时，我们不想保留某些提交引入的更改。与软重置不同，我们不再需要访问它们。Git 应该简单地将其状态重置回指定提交时的状态：这甚至包括工作目录和暂存文件中的更改！</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707165117.gif"></p><p>Git 丢弃了在 <code>9e78i</code> 和 <code>035cc</code> 上引入的更改，并将其状态重置为提交 <code>ec5be</code> 时的状态。</p><h3 id="Reverting"><a href="#Reverting" class="headerlink" title="Reverting"></a>Reverting</h3><p>撤消更改的另一种方法是执行<code>git revert</code>。通过恢复某个提交，我们创建了一个包含恢复的更改的新提交！</p><p>假设 <code>ec5be</code> 添加了一个 <code>index.js</code> 文件。后来，我们实际上意识到我们不再希望这次提交引入的这种变化！让我们恢复 <code>ec5be</code> 提交。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707165159.gif"></p><p>完美的！提交<code>9e78i</code>恢复了由<code>ec5be</code>提交引入的更改。执行 <code>git revert</code> 非常有用，可以撤消某个提交，而无需修改分支的历史记录。</p><h2 id="Cherry-picking"><a href="#Cherry-picking" class="headerlink" title="Cherry-picking"></a>Cherry-picking</h2><p>当某个分支包含在活动分支上引入了我们需要的更改的提交时，我们可以 <code>cherry-pick</code> 该命令！通过 <code>cherry-pick</code> 提交，我们在活动分支上创建了一个新提交，其中包含由 <code>cherry-pick</code> 提交所引入的更改。</p><p>假设 <code>dev</code> 分支上的提交 <code>76d12</code> 添加了我们想要在 <code>master</code> 分支中的 <code>index.js</code> 文件的更改。我们不想要<em>整个</em>，我们只关心这一次提交！</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707170039.gif"></p><p>很酷，<code>master</code> 分支现在包含了 <code>76d12</code> 引入的更改！</p><h2 id="Fetching"><a href="#Fetching" class="headerlink" title="Fetching"></a>Fetching</h2><p>如果我们有一个远程 Git 分支，例如 GitHub 上的一个分支，则可能会发生远程分支具有当前分支没有的提交！也许另一个分支被合并了，你的同事推送了一个快速修复，等等。</p><p>我们可以通过在远程分支上执行 <code>git fetch</code> 在本地获取这些更改！它不会以任何方式影响您的本地分支：<code>fetch</code> 只是下载新数据。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707170120.gif"></p><p>我们现在可以看到自上次推送以来所做的所有更改！既然我们在本地拥有新数据，我们就可以决定要如何处理这些数据。</p><h2 id="Pulling"><a href="#Pulling" class="headerlink" title="Pulling"></a>Pulling</h2><p>虽然 <code>git fetch</code> 对于获取分支的远程信息非常有用，但我们也可以执行 <code>git pull</code>。 <code>git pull</code> 实际上是两个命令合二为一：<code>git fetch</code> 和 <code>git merge</code>。当我们从源中提取更改时，我们首先像使用 <code>git fetch</code> 一样获取所有数据，之后最新的更改会自动合并到本地分支中。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707170157.gif"></p><p>太棒了，我们现在与远程分支完美同步，并拥有所有最新更改！</p><h2 id="Reflog"><a href="#Reflog" class="headerlink" title="Reflog"></a>Reflog</h2><p>每个人都会犯错，这完全没关系！有时你可能会觉得你把你的 <code>git repo</code> 搞砸了，以至于你只想完全删除它。</p><p><code>git reflog</code> 是一个非常有用的命令，用于显示所有已采取的操作的日志！这包括合并、重置、恢复：基本上是对分支的任何更改。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707170250.gif"></p><p>如果您犯了错误，您可以根据 <code>reflog</code> 提供给我们的信息通过重置 <code>HEAD</code> 轻松地重做此操作！</p><p>假设我们实际上并不想合并 <code>origin</code> 分支。当我们执行 <code>git reflog</code> 命令时，我们看到合并前 repo 的状态是在 <code>HEAD@&#123;1&#125;</code>。让我们执行 <code>git reset</code> 将 HEAD 指向它在 <code>HEAD@&#123;1&#125;</code> 上的位置！</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707170316.gif"></p><p>我们可以看到最新的 action 已经推送到<code>reflog</code>了！</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Translation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言数组/结构体/结构体数组/联合体初始化</title>
    <link href="/2022/06/30/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84-%E7%BB%93%E6%9E%84%E4%BD%93-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-%E8%81%94%E5%90%88%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2022/06/30/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84-%E7%BB%93%E6%9E%84%E4%BD%93-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-%E8%81%94%E5%90%88%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">6</span>] = &#123; [<span class="hljs-number">0</span>]=<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>, [<span class="hljs-number">3</span>] =<span class="hljs-number">10</span>, [<span class="hljs-number">4</span>]=<span class="hljs-number">11</span> &#125;; 或<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">6</span>] = &#123; [<span class="hljs-number">0</span>]=<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, [<span class="hljs-number">3</span>] =<span class="hljs-number">10</span>, <span class="hljs-number">11</span> &#125;; 或<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">6</span>] = &#123; [<span class="hljs-number">3</span>] =<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, [<span class="hljs-number">0</span>]=<span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;; (指定顺序可变)<br>均等效于：<span class="hljs-keyword">int</span> arr[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>Note:</p><ol><li>若在某个指定初始化项目后跟有不至一个值，如<code>[3]=10,11</code>。则多出的数值用于对后续的数组元素进行初始化，即数值 11 用来初始化 arr[4]。</li><li>C 数组初始化一个或多个元素后，未初始化的元素将被自动地初始化为 0 或 NULL(针对指针变量)。未经过任何初始化的数组，所有元素的值都是不确定的。</li></ol><p>GNU C 还支持<code>[first … last]=value</code>(<code>…</code><strong>两侧有空格</strong>) 的形式，将该范围内的若干元素初始化为相同值。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> arr[]=&#123; [<span class="hljs-number">0</span> ... <span class="hljs-number">3</span>]=<span class="hljs-number">1</span>, [<span class="hljs-number">4</span> ... <span class="hljs-number">5</span>]=<span class="hljs-number">2</span>, [<span class="hljs-number">6</span> ... <span class="hljs-number">9</span>] =<span class="hljs-number">3</span>&#125;; 或<br><span class="hljs-keyword">int</span> arr[]=&#123; [<span class="hljs-number">0</span> ... <span class="hljs-number">3</span>]=<span class="hljs-number">1</span>, [<span class="hljs-number">4</span> ... <span class="hljs-number">5</span>]=<span class="hljs-number">2</span>, [<span class="hljs-number">6</span> ... <span class="hljs-number">8</span>] =<span class="hljs-number">3</span>, [<span class="hljs-number">9</span>] =<span class="hljs-number">3</span>&#125;;<br>均等效于：<span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><p>对于结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span>&#123;</span> <span class="hljs-keyword">int</span> a; <span class="hljs-keyword">int</span> b; &#125;; 或<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span>&#123;</span> <span class="hljs-keyword">int</span> a, b; &#125;;<br></code></pre></td></tr></table></figure><p>有以下几种初始化方式：<br>用<code>.fieldname=指定待初始化成员名</code>(成员初始化顺序可变)，<strong>推荐使用的方式</strong>，该方式初始化时不必严格按照定义时的顺序，灵活性很高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span> <span class="hljs-title">tStct</span> =</span> &#123;<br>    .a = <span class="hljs-number">1</span>,<br>    .b = <span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>用<code>fieldname:指定待初始化成员名</code>(成员初始化顺序可变)，GCC 2.5 已废除，但仍接受</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span> <span class="hljs-title">tStct</span> =</span> &#123;<br>    a : <span class="hljs-number">1</span>,<br>    b : <span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>用初始化列表初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span> <span class="hljs-title">tStct</span> =</span> &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br></code></pre></td></tr></table></figure><h2 id="结构体数组初始化"><a href="#结构体数组初始化" class="headerlink" title="结构体数组初始化"></a>结构体数组初始化</h2><p>方法一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span> <span class="hljs-title">ptStct</span>[10] =</span> &#123;<br>     [<span class="hljs-number">2</span>].b = <span class="hljs-number">0x2B</span>, [<span class="hljs-number">2</span>].a = <span class="hljs-number">0x2A</span>,<br>     [<span class="hljs-number">0</span>].a = <span class="hljs-number">0x0A</span> &#125;;<br></code></pre></td></tr></table></figure><p>方法二：该方法可以用于清除结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">memset</span>(ptStct, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct Structure) * <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="联合体初始化"><a href="#联合体初始化" class="headerlink" title="联合体初始化"></a>联合体初始化</h2><p>可用<code>.fieldname</code>(或已废弃的<code>fieldname:</code>) 指示符来指定使用联合体的哪个元素，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">UnionT</span> &#123;</span> <span class="hljs-keyword">int</span> i; <span class="hljs-keyword">double</span> d; &#125;;<br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">UnionT</span> <span class="hljs-title">tUnion</span> =</span> &#123; .d = <span class="hljs-number">4</span> &#125;;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-watch 周期执行命令</title>
    <link href="/2022/06/09/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-watch%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/06/09/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-watch%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>watch 命令的功能如其名，可以监视命令的执行结果。它实现的原理就是每隔一段时间执行一次命令，然后显示结果。他的用途很广，具体怎么用就靠想象力了。</p><h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">n <span class="hljs-comment"># 或--interval  watch默认每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。</span></span><br><span class="ruby"></span>-<span class="ruby">d <span class="hljs-comment"># 或--differences  用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。</span></span><br><span class="ruby"></span>-<span class="ruby">t <span class="hljs-comment"># 或-no-title  会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。</span></span><br><span class="ruby"></span>-<span class="ruby">h <span class="hljs-comment"># 或--help # 查看帮助文档</span></span><br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">watch</span> -d <span class="hljs-string">&#x27;ls -l | grep tmp&#x27;</span>       <span class="hljs-comment"># 监测当前目录中 scf&#x27; 的文件的变化</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git hooks 钩子的使用</title>
    <link href="/2022/05/30/Git-hooks%E9%92%A9%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/05/30/Git-hooks%E9%92%A9%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-hooks-简介"><a href="#Git-hooks-简介" class="headerlink" title="Git hooks 简介"></a>Git hooks 简介</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208271329199.png"></p><p>Git 能在特定的重要动作发生时触发自定义脚本。比如，<code>commit</code>之前检查<code>commit message</code>是否符合约定的格式，<code>push</code>之前检查代码格式是否正确，是否编译通过等等。Git 就提供了<code>hooks</code>这样的机制。</p><p>我们在哪能找到<code>hooks</code>呢？在初始化代码仓库<code>git init</code>时，Git 会自动为我们创建一个<code>.git/hooks</code>目录，里面存放了所有的钩子。因为<code>.git</code>是隐藏目录，显示隐藏目录后就可以找到<code>hooks</code>这个目录。</p><p>在 VSCode 里一般默认把<code>.git</code>目录排除显示，所以打开项目目录时不会显示该目录，我们可以收到在 VSCode 显示<code>.git</code>目录：打开设置界面，搜索<code>exclude</code>找到图中的设置，将<code>.git</code>目录从排除列表中移除，即可在 VSCode 中显示<code>.git</code>目录。</p><div align=center>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220530134106.png" height = "90%" /> </div><p>现在我们找到了<code>hooks</code>，该如何使用呢？<br>所有默认的<code>hooks</code>都是以<code>.sample</code>为后缀，只需要移除<code>.sample</code>即可激活<code>hooks</code>。</p><div align=center> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220530154954.png"    alt=""></div><p>随便打开一个<code>hooks</code>文件，我们可以发现，实际是<code>hooks</code>就是一个个<code>shell</code>脚本。这些脚本会在特定的动作发生时被执行。示范的这些<code>hooks</code>都是<code>shell</code>脚本，<strong>实际上只要是文件名正确的可执行脚本都可以使用</strong>，如将<code>pre-push</code>内容改为<code>python, Ruby</code>等等脚本都可以。</p><h2 id="如何使用一个-hooks"><a href="#如何使用一个-hooks" class="headerlink" title="如何使用一个 hooks"></a>如何使用一个 hooks</h2><p>以<code>pre-commit</code>这个<code>hooks</code>为例，来示范一下如何使用 Git hooks。</p><ul><li><p>打开<code>.git/hooks/pre-commit.sample</code>，这个<code>hooks</code>的大体功能是检查文件名是否包含非<code>ASCII</code>字符，如果包含，则无法执行<code>commit</code>操作，并提示用户修改文件名。</p></li><li><p>删除<code>pre-commit.sample</code>的后缀</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜ mv .git<span class="hljs-regexp">/hooks/</span>pre-commit.sample .git<span class="hljs-regexp">/hooks/</span>pre-commit<br></code></pre></td></tr></table></figure></li><li><p>添加一个有汉字的文件名，如<code>测试.md</code></p>  <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">➜  touch 测试.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure></li><li><p>将新文件提交</p>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">➜ git <span class="hljs-built_in">add</span> 测试.md<br>➜ git commit -m <span class="hljs-string">&quot;测试&quot;</span><br>Error: Attempt <span class="hljs-built_in">to</span> <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> non-ASCII <span class="hljs-built_in">file</span> name.<br><br>This can cause problems <span class="hljs-keyword">if</span> you want <span class="hljs-built_in">to</span> work <span class="hljs-keyword">with</span> people <span class="hljs-keyword">on</span> <span class="hljs-title">other</span> <span class="hljs-title">platforms</span>.<br><br>To be portable <span class="hljs-keyword">it</span> is advisable <span class="hljs-built_in">to</span> <span class="hljs-built_in">rename</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span>.<br><br>If you know what you are doing you can disable this check <span class="hljs-keyword">using</span>:<br><br>git config hooks.allownonascii <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>如果无法执行<code>pre-commit</code>可能未被赋予执行权限，修改一下权限即可：<code>chmod +x .git/hooks/pre-commit</code></p></blockquote></li></ul><p>我们可以发现，在进行<code>commit</code>操作时被中断了，会提示用户修改文件名。其他的<code>hooks</code>用法类似，我们可以自定义在什么时候可以<code>push</code>，什么时候可以<code>rebase</code>等等。</p><p><code>hooks</code>通常会被用来做提交代码前的一个检查，比如风格是否统一，编译是否通过等等。如果团队合作时，这样的检查最好能够与成员保持一致，但是<code>hooks</code>所在的<code>.git</code>目录是不会被Git自己版本管理的，换句话说，它不能推送到远端与成员共享。那么如何解决这个问题呢？</p><h2 id="如何同步hooks文件"><a href="#如何同步hooks文件" class="headerlink" title="如何同步hooks文件"></a>如何同步hooks文件</h2><h3 id="方案一：与源码放在一起"><a href="#方案一：与源码放在一起" class="headerlink" title="方案一：与源码放在一起"></a>方案一：与源码放在一起</h3><p>代码仓库中新建一个<code>hooks</code>目录，将该目录同步到远程。其他成员下载代码时也会下载<code>hooks</code>目录，通过脚本的方式将<code>hooks</code>目录覆盖本地的<code>.git/hooks</code>目录。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/bin/bash</span><br>cp -r .<span class="hljs-regexp">/hooks/</span> .git<span class="hljs-regexp">/hooks/</span><br>chmod +x -R .git/hooks<br>echo <span class="hljs-string">&#x27;Hooks sync to remote success!&#x27;</span><br><span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="方案二：使用pre-commit框架"><a href="#方案二：使用pre-commit框架" class="headerlink" title="方案二：使用pre-commit框架"></a>方案二：使用pre-commit框架</h3><p><code>pre_commit</code> 是 <code>pre-commit</code> 同名的开源应用，使用<code>pre-commit</code>，代码仓库里只需要有一个配置文件，所有成员都可以根据配置文件，使用<code>pre_commit</code>生成统一的<code>hooks</code>。</p><p><code>pre-commit</code>随着发展，已经不单单只能用于<code>git hooks的pre-commit</code>阶段，而是能作用于所有<code>git hooks</code>的所有阶段，如上面说的<code>prepare-commit-msg</code>, <code>commit-msg</code>, <code>post-commi</code>等。</p><p>安装pre-commit</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pre-commit<br></code></pre></td></tr></table></figure><p>在项目目录下，添加配置文件 <code>.pre-commit-config.yaml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">touch .pre-commit-config.yaml<br></code></pre></td></tr></table></figure><ul><li><p>首先了解配置的格式</p><ul><li>顶层有一个参数名为 <code>repos</code></li><li><code>repos</code> 中每个元素为 <code>repo</code> ，代表一个代码库，一般是<code>github</code>或<code>gitlab</code>链接。在使用时会从对应地址下载，如果出现下载慢的情况，可以在<code>gitee</code>搜索是否有相关镜像。</li><li>每个 <code>repo</code> 中有一个或多个 <code>hook</code> ，每个 <code>hook</code> 代表一个任务。</li><li>每个任务里可理解为一个命令行指令，例如<code>flake8/yapf/black</code>。</li></ul></li><li><p><code>pre_commit</code>官方提供了<a href="https://pre-commit.com/hooks.html">各种配置</a>，我们可以根据需要选择一个合适的。比如我需要一个格式化C语言代码的配置，选择了<a href="https://github.com/pre-commit/mirrors-clang-format">mirrors-clang-format</a>，还选了一个用来删除行尾空格的。</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">repos:</span><br><span class="hljs-bullet">-</span>   <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/pre-commit/pre-commit-hooks</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v4.3.0</span><br>    <span class="hljs-attr">hooks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">trailing-whitespace</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/pre-commit/mirrors-clang-format</span><br>    <span class="hljs-attr">rev:</span> <span class="hljs-string">v14.0.6</span><br>    <span class="hljs-attr">hooks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">clang-format</span><br>        <span class="hljs-attr">types_or:</span> [<span class="hljs-string">c</span>]<br></code></pre></td></tr></table></figure><p>  参数的含义可以参考<a href="https://pre-commit.com/#pre-commit-configyaml---top-level">pre-commit</a>的文档。每个id对应的其实都是一个程序，为了保证都能正常运行，还需要安装这些程序。一般在仓库的<code>README</code>中都会有提示如何安装。</p></li><li><p>根据配置文件安装<code>hooks</code><br>  在项目根目录下运行：</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pre-commit <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure></li><li><p>在执行<code>git commit</code>命令时将会自动检查。这个过程中，<code>pre-commit</code>会从仓库里下载代码，然后根据里面的配置执行相应的脚本。完成各种检查。</p></li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 手动对所有的文件执行 hooks，新增 hook 的时候可以执行，使得代码均符合规范。直接执行该指令则无需等到 pre-commit 阶段再触发 hooks</span><br>pre-commit run --all-files<br><span class="hljs-comment"># 执行特定 hooks</span><br>pre-commit run &lt;hook_id&gt;<br><span class="hljs-comment"># 将所有的hook更新到最新的版本/tag</span><br>pre-commit autoupdate<br><span class="hljs-comment"># 指定更新 repo</span><br>pre-commit autoupdate --repo https://github.com/pre-commit/mirrors-clang-format<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://blog.csdn.net/irving512/article/details/124377109">C++ 项目中使用 Pre-commit 协助实现代码规范检查_清欢守护者的博客-CSDN 博客</a></p></li><li><p><a href="https://www.jianshu.com/p/7951ff907ccb">git push 之前自动编译验证 - 简书</a></p></li><li><p><a href="https://blog.csdn.net/irving512/article/details/108701017">使用 pre-commit 实现代码检查_清欢守护者的博客-CSDN 博客</a></p></li><li><p><a href="https://pre-commit.com/#pre-commit-configyaml---top-level">pre-commit</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1eZ4y1G7hh/?spm_id_from=333.788">Git 基本原理介绍 (32)——git hook 和 python_哔哩哔哩_bilibili</a></p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU 缓存一致性 MESI 协议</title>
    <link href="/2022/05/29/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7MESI%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/05/29/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7MESI%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要缓存一致"><a href="#为什么需要缓存一致" class="headerlink" title="为什么需要缓存一致"></a>为什么需要缓存一致</h2><p>目前主流电脑的 CPU 都是多核心的，多核心的有点就是在不能提升 CPU 主频后，通过增加核心来提升 CPU 吞吐量。每个核心都有自己的 L1 Cache 和 L2 Cache，只是共用 L3 Cache 和主内存。每个核心操作是独立的，每个核心的 Cache 就不是同步更新的，这样就会带来缓存一致性（Cache Coherence）的问题。</p><p>举个例子，如图：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205291536919.gif"></p><p>有 2 个 CPU，主内存里有个变量<code>x=0</code>。CPU A 中有个需要将变量<code>x</code>加<code>1</code>。CPU A 就将变量<code>x</code>加载到自己的缓存中，然后将变量<code>x</code>加<code>1</code>。因为此时 CPU A 还未将缓存数据写回主内存，CPU B 再读取变量<code>x</code>时，变量<code>x</code>的值依然是<code>0</code>。</p><p>这里的问题就是所谓的缓存一致性问题，因为 CPU A 的缓存与 CPU B 的缓存是不一致的。</p><h2 id="如何解决缓存一致性问题"><a href="#如何解决缓存一致性问题" class="headerlink" title="如何解决缓存一致性问题"></a>如何解决缓存一致性问题</h2><h3 id="通过在总线加-LOCK-锁的方式"><a href="#通过在总线加-LOCK-锁的方式" class="headerlink" title="通过在总线加 LOCK 锁的方式"></a>通过在总线加 LOCK 锁的方式</h3><p>在锁住总线上加一个 LOCK 标识，CPU A 进行读写操作时，锁住总线，其他 CPU 此时无法进行内存读写操作，只有等解锁了才能进行操作。</p><p>该方式因为锁住了整个总线，所以效率低。</p><h3 id="缓存一致性协议-MESI"><a href="#缓存一致性协议-MESI" class="headerlink" title="缓存一致性协议 MESI"></a>缓存一致性协议 MESI</h3><p>该方式对单个缓存行的数据进行加锁，不会影响到内存其他数据的读写。</p><p>在学习 MESI 协议之前，简单了解一下总线嗅探机制（Bus Snooping）。要对自己的缓存加锁，需要通知其他 CPU，多个 CPU 核心之间的数据传播问题。最常见的一种解决方案就是总线嗅探。</p><p>这个策略，本质上就是把所有的读写请求都通过总线广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。MESI 就是基于总线嗅探机制的缓存一致性协议。</p><p>MESI 协议的由来是对 Cache Line 的四个不同的标记，分别是：</p><table><thead><tr><th align="center"><div style="width:50px">状态</div></th><th align="center"><div style="width:100px">状态</div></th><th><div style="width:200px">描述</div></th><th><div style="width:200px">监听任务</div></th></tr></thead><tbody><tr><td align="center">Modified</td><td align="center">已修改</td><td>该 Cache Line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中</td><td>Cache Line 必须时刻监听所有试图读该 Cache Line 相对于主存的操作，这种操作必须在缓存将该 Cache Line 写回主存并将状态改为 S 状态之前，被延迟执行</td></tr><tr><td align="center">Exclusive</td><td align="center">独享，互斥</td><td>该 Cache Line 有效，数据和内存中的数据一直，数据只存在于本 Cache</td><td>Cache Line 必须监听其他缓存读主存中该 Cache Line 的操作，一旦有这种操作，该 Cache Line 需要改为 S 状态</td></tr><tr><td align="center">Shared</td><td align="center">共享的</td><td>该 Cache Line 有效，数据和内存中的数据一直，数据存在于很多个 Cache 中</td><td>Cache Line 必须监听其他  Cache Line 使该 Cache Line 无效或者独享该 Cache Line 的请求，并将 Cache Line 改为 I 状态</td></tr><tr><td align="center">Invalid</td><td align="center">无效的</td><td>该 Cache Line 无效</td><td>无</td></tr></tbody></table><p>整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把各个状态之间的流转用表格总结了一下：</p><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:300px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">M</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">M</td></tr><tr><td align="center">M</td><td align="center">Local Write</td><td>修改 cache 数据，状态不变</td><td align="center">M</td></tr><tr><td align="center">M</td><td align="center">Remote Read</td><td>这行数据被写到内存中，使其他核能使用到最新数据，状态变为 S</td><td align="center">S</td></tr><tr><td align="center">M</td><td align="center">Remote Write</td><td>这行数据被写入内存中，其他核可以获取到最新数据，由于其他 CPU 修改该条数据，则本地 Cache 变为 I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">E</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">E</td></tr><tr><td align="center">E</td><td align="center">Local Write</td><td>修改数据，状态改为 M</td><td align="center">M</td></tr><tr><td align="center">E</td><td align="center">Remote Read</td><td>数据和其他 CPU 共享，变为 S</td><td align="center">S</td></tr><tr><td align="center">E</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为 I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,text-align: center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">S</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">S</td></tr><tr><td align="center">S</td><td align="center">Local Write</td><td>修改数据，状态改为 M，其他 CPU 的 Cache Line 状态改为 I</td><td align="center">M</td></tr><tr><td align="center">S</td><td align="center">Remote Read</td><td>数据和其他 CPU 共享，状态不变</td><td align="center">S</td></tr><tr><td align="center">S</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为 I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">I</td><td align="center">Local Read</td><td>1. 如果其他 CPU 没有这份数据，直接从内存中加载数据，状态变为 E；<br> 2. 如果其他 CPU 有这个数据，且 Cache Line 状态为 M，则先把 Cache Line 中的内容写回到主存。本地 Cache 再从内存中读取数据，这时两个 Cache Line 的状态都变为 S；<br>3. 如果其他 Cache Line 有这份数据，并且状态为 S 或者 E，则本地 Cache Line 从主存读取数据，并将这些 Cache Line 状态改为 S</td><td align="center">E 或者 S</td></tr><tr><td align="center">I</td><td align="center">Local Write</td><td>1. 先从内存中读取数据，如果其他 Cache Line 中有这份数据，且状态为 M，则现将数据更新到主存再读取，将 Cache Line 状态改为 M；<br> 2. 如果其他 Cache Line 有这份数据，且状态为 E 或者 S，则其他 Cache Line 状态改为 I</td><td align="center">M</td></tr><tr><td align="center">I</td><td align="center">Remote Read</td><td>数据和其他 CPU 共享，状态不变</td><td align="center">S</td></tr><tr><td align="center">I</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为 I</td><td align="center">I</td></tr></tbody></table><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>计算机组成原理</tag>
      
      <tag>CPU</tag>
      
      <tag>MESI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 设置终端为 Gitbash</title>
    <link href="/2022/05/24/VSCode%E8%AE%BE%E7%BD%AE%E7%BB%88%E7%AB%AF%E4%B8%BAGitbash/"/>
    <url>/2022/05/24/VSCode%E8%AE%BE%E7%BD%AE%E7%BB%88%E7%AB%AF%E4%B8%BAGitbash/</url>
    
    <content type="html"><![CDATA[<h2 id="设置终端为-Gitbash"><a href="#设置终端为-Gitbash" class="headerlink" title="设置终端为 Gitbash"></a>设置终端为 Gitbash</h2><p>用惯了 Linux 终端的命令，Windows 的 shell 真的太不顺手了，但是 Gitbash 很多命令相似，可以将默认的 shell 换成 Gitbash。</p><p>打开<code>settings.json</code>配置文件，添加如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;terminal.integrated.profiles.windows&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;PowerShell -NoProfile&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;source&quot;</span>: <span class="hljs-string">&quot;PowerShell&quot;</span>,<br>      <span class="hljs-attr">&quot;args&quot;</span>: [<br>        <span class="hljs-string">&quot;-NoProfile&quot;</span><br>      ]<br>    &#125;,<br>    <span class="hljs-attr">&quot;Git-Bash&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;D:\\Software\\Git\\bin\\bash.exe&quot;</span>, <span class="hljs-comment">//bin路径下的bash，不是git-bash.exe。否则会打开外部窗口</span><br>      <span class="hljs-attr">&quot;args&quot;</span>: []<br>    &#125;<br>  &#125;,<br><span class="hljs-string">&quot;terminal.integrated.defaultProfile.windows&quot;</span>: <span class="hljs-string">&quot;Git-Bash&quot;</span>,<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301517302.png"></p><h2 id="修改终端配色"><a href="#修改终端配色" class="headerlink" title="修改终端配色"></a>修改终端配色</h2><p>打开<a href="https://glitchbone.github.io/vscode-base16-term/#/">Base16 Terminal Colors for Visual Studio Code</a>，选择一款配置复制</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301515778.png"></p><p>打开 VScode<code>settings.json</code>，替换如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;workbench.colorCustomizations&quot;</span>: &#123;<br>       <span class="hljs-attr">&quot;terminal.background&quot;</span>:<span class="hljs-string">&quot;#1C2023&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.foreground&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminalCursor.background&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminalCursor.foreground&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBlack&quot;</span>:<span class="hljs-string">&quot;#1C2023&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBlue&quot;</span>:<span class="hljs-string">&quot;#AE95C7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightBlack&quot;</span>:<span class="hljs-string">&quot;#747C84&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightBlue&quot;</span>:<span class="hljs-string">&quot;#AE95C7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightCyan&quot;</span>:<span class="hljs-string">&quot;#95AEC7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightGreen&quot;</span>:<span class="hljs-string">&quot;#95C7AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightMagenta&quot;</span>:<span class="hljs-string">&quot;#C795AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightRed&quot;</span>:<span class="hljs-string">&quot;#C7AE95&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightWhite&quot;</span>:<span class="hljs-string">&quot;#F3F4F5&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightYellow&quot;</span>:<span class="hljs-string">&quot;#AEC795&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiCyan&quot;</span>:<span class="hljs-string">&quot;#95AEC7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiGreen&quot;</span>:<span class="hljs-string">&quot;#95C7AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiMagenta&quot;</span>:<span class="hljs-string">&quot;#C795AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiRed&quot;</span>:<span class="hljs-string">&quot;#C7AE95&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiWhite&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiYellow&quot;</span>:<span class="hljs-string">&quot;#AEC795&quot;</span><br>   &#125;,<br></code></pre></td></tr></table></figure><p>修改后效果</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301517302.png"></p><h2 id="修改终端字体"><a href="#修改终端字体" class="headerlink" title="修改终端字体"></a>修改终端字体</h2><p>方法一：打开 VScode<code>settings.json</code>，加上下面这个配置，字体改成自己电脑上的字体</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="hljs-string">&quot;JetBrains Mono&quot;</span>,<br><br></code></pre></td></tr></table></figure><p>方法二：打开设置页面，搜索<code>terminal font</code></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220524142319.png"></p><p>修改后的效果</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220524142612.png"></p><h2 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Git</tag>
      
      <tag>Gitbash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU 亲和性与中断亲和性</title>
    <link href="/2022/05/23/CPU%E4%BA%B2%E5%92%8C%E6%80%A7%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%BA%B2%E5%92%8C%E6%80%A7/"/>
    <url>/2022/05/23/CPU%E4%BA%B2%E5%92%8C%E6%80%A7%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%BA%B2%E5%92%8C%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><a href="https://mp.weixin.qq.com/s/HwDqCk8vtMdSEVSCLHAsbg">超线程技术 (Hyper-Threading)</a>：就是利用特殊的硬件指令，把两个逻辑内核 (CPU core) 模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了 CPU 的闲置时间，提高的 CPU 的运行效率。</p><p>我们常听到的双核四线程/四核八线程指的就是支持超线程技术的CPU.</p><p><strong>物理 CPU</strong>：机器上安装的实际 CPU, 比如说你的主板上安装了一个 8 核 CPU，那么物理 CPU 个数就是 1 个，所以物理 CPU 个数就是主板上安装的 CPU 个数。</p><p><strong>逻辑 CPU</strong>：一般情况，我们认为一颗 CPU 可以有多核，加上 Intel 的超线程技术 (HT), 可以在逻辑上再分一倍数量的 CPU core 出来；</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">逻辑<span class="hljs-meta">CPU</span>数量 = 物理<span class="hljs-meta">CPU</span>数量 x <span class="hljs-meta">CPU</span> cores x <span class="hljs-number">2</span>(如果支持并开启HT) //前提是<span class="hljs-meta">CPU</span>的型号一致，如果不一致只能一个一个的加起来，不用直接乘以物理<span class="hljs-meta">CPU</span>数量<br>//比如你的电脑安装了一块<span class="hljs-number">4</span>核<span class="hljs-meta">CPU</span>，并且支持且开启了超线程（HT）技术，那么逻辑<span class="hljs-meta">CPU</span>数量 = <span class="hljs-number">1</span> × <span class="hljs-number">4</span> × <span class="hljs-number">2</span> = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>Linux 下查看 CPU 相关信息</strong>, CPU 的信息主要都在<code>/proc/cupinfo</code>中。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># 查看物理CPU个数<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;physical id&quot;</span>|<span class="hljs-keyword">sort</span> -u|wc -l<br><span class="hljs-number">32</span><br><br># 查看每个物理CPU中core的个数(即核数)<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;cpu cores&quot;</span>|uniq<br><span class="hljs-number">1</span><br># 或者<br>➜    cat <span class="hljs-regexp">/proc/</span>cpuinfo | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;process&#x27;</span> | <span class="hljs-keyword">sort</span> | uniq | wc -l<br><span class="hljs-number">1</span><br><br># 查看逻辑CPU的个数<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;processor&quot;</span>|wc -l<br><span class="hljs-number">32</span><br><br># 查看CPU的名称型号<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;name&quot;</span>|cut -f2 -d:|uniq<br>Intel Xeon Processor (Skylake, IBRS)<br></code></pre></td></tr></table></figure><p><strong>Linux 查看某个进程运行在哪个逻辑 CPU 上</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -eo pid,<span class="hljs-keyword">args</span>,psr<br></code></pre></td></tr></table></figure><ul><li><code>pid</code>：进程 ID</li><li><code>args</code>：该进程执行时传入的命令行参数</li><li><code>psr</code>：分配给进程的逻辑 CPU</li></ul><p>例子：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle">➜  ps -eo pid,args,psr | <span class="hljs-keyword">grep</span> firefox<br><span class="hljs-number">20118</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -n  <span class="hljs-number">13</span><br><span class="hljs-number">20208</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c   <span class="hljs-number">9</span><br><span class="hljs-number">20266</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">29</span><br><span class="hljs-number">20329</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">24</span><br><span class="hljs-number">20499</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c   <span class="hljs-number">7</span><br><span class="hljs-number">20565</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">15</span><br><span class="hljs-number">20596</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">24</span><br><span class="hljs-number">20760</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">18</span><br><span class="hljs-number">22110</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">27</span><br><span class="hljs-number">25857</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">28</span><br><span class="hljs-number">26347</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">19</span><br><span class="hljs-number">26899</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">29</span><br></code></pre></td></tr></table></figure><p><strong>Linux 查看线程的 TID</strong></p><p>TID 就是 Thread ID，他和 POSIX 中<code>pthread_t</code>表示的线程 ID 完全不是同一个东西。</p><p>Linux 中的 POSIX 线程库实现的线程其实也是一个轻量级进程 (LWP),这个 TID 就是这个线程的真实 PID.</p><p>但是又不能通过<code>getpid()</code>函数获取，Linux 中定义了<code>gettid()</code>这个接口，但是通常都是未实现的，所以需要使用下面的方式获取 TID。</p><p>使用 API 获取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span>  </span><br><span class="hljs-keyword">pid_t</span> tid;<br>tid = <span class="hljs-built_in">syscall</span>(__NR_gettid); <span class="hljs-comment">// or syscall(SYS_gettid)  </span><br></code></pre></td></tr></table></figure><p>命令行方式获取：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 3种方法(推荐第三种方法)</span><br>➜  <span class="hljs-built_in">ps</span> <span class="hljs-literal">-efL</span> | grep prog_name<br>➜  <span class="hljs-built_in">ls</span> /proc/pid/task      //文件夹名即TID<br>➜  <span class="hljs-built_in">ps</span> <span class="hljs-literal">-To</span> <span class="hljs-string">&#x27;pid,lwp,psr,cmd&#x27;</span> <span class="hljs-literal">-p</span> PID<br></code></pre></td></tr></table></figure><h2 id="什么是-CPU-亲和性"><a href="#什么是-CPU-亲和性" class="headerlink" title="什么是 CPU 亲和性"></a>什么是 CPU 亲和性</h2><p>CPU 的亲和性 (Affinity)，属于一种调度属性，可以绑定进程到指定 CPU 上。 换句话说，就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器。</p><p>为何会出现这种技术？在 SMP(Symmetric Multi-Processing 对称多处理) 架构下，调度器会试图保持进程在相同的 CPU 上运行，这意味着进程通常不会在处理器之间频繁迁移，进程迁移的频率小就意味着产生的负载小。</p><p>又如，每个 CPU 本身自己会有缓存，缓存着进程使用的信息，而进程可能会被操作系统调度到其他 CPU 上，如此，CPU 缓存命中率就低了，当绑定 CPU 后，程序就会一直在指定的 CPU 跑，不会由操作系统调度到其他 CPU 上，性能有一定的提高。</p><p><strong>软亲和性</strong>:  就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，Linux 内核进程调度器天生就具有被称为 软 CPU 亲和性（affinity）的特性，这意味着进程通常不会在处理器之间频繁迁移。这种状态正是我们希望的，因为进程迁移的频率小就意味着产生的负载小。</p><p><strong>硬亲和性</strong>：简单来说就是利用 Linux 内核提供给用户的 API，强行将进程或者线程绑定到某一个指定的 CPU 核运行。</p><p>CPU affinity 使用位掩码 (bitmask) 表示，每一位都表示一个 CPU, 置 1 表示”绑定”。最低位表示第一个逻辑 CPU, 最高位表示最后一个逻辑 CPU。</p><p>CPU affinity 典型的表示方法是使用 16 进制，具体如下。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">0b00000000000000000000000000000001<br><span class="hljs-section">= 0x00000001</span><br>表示 processor #0<br><br>0b00000000000000000000000001010101<br><span class="hljs-section">= 0x00000055</span><br>表示 processors #0, #2, #4, #6<br><br>0b11111111111111111111111111111111<br><span class="hljs-section">= 0xFFFFFFFF</span><br>表示所有 processors (#0 through #31)<br></code></pre></td></tr></table></figure><h2 id="使用taskset命令设置-CPU-亲和性"><a href="#使用taskset命令设置-CPU-亲和性" class="headerlink" title="使用taskset命令设置 CPU 亲和性"></a>使用<code>taskset</code>命令设置 CPU 亲和性</h2><p><strong>命令行形式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">taskset <span class="hljs-selector-attr">[options]</span> <span class="hljs-attribute">mask</span> command <span class="hljs-selector-attr">[arg]</span>...<br>taskset <span class="hljs-selector-attr">[options]</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-selector-attr">[mask]</span> pid<br></code></pre></td></tr></table></figure><p><strong>参数解析</strong><br>[OPTIONS]taskset 的可选参数</p><ul><li><p><code>-a, --all-tasks</code> (旧版本中没有这个选项)</p><pre><code class="hljs">  这个选项涉及到了linux中TID的概念,他会将一个进程中所有的TID都执行一次CPU亲和性设置.  TID 就是 Thread ID，他和 POSIX 中 pthread_t 表示的线程 ID 完全不是同一个东西。  Linux中的POSIX线程库实现的线程其实也是一个进程(LWP),这个TID就是这个线程的真实PID.</code></pre></li><li><p><code>-p, --pid</code></p><pre><code class="hljs">  操作已存在的PID,而不是加载一个新的程序</code></pre></li><li><p><code>-c, --cpu-list</code></p><pre><code class="hljs">        声明CPU的亲和力使用数字表示而不是用位掩码表示. 例如 0,5,7,9-11.</code></pre></li><li><p><code>-h, --help</code></p><pre><code class="hljs">  显示帮助信息</code></pre></li><li><p><code>-V, --version</code></p><pre><code class="hljs">  显示版本信息</code></pre></li><li><p><code>mask</code> : cpu 亲和性，当没有<code>-c</code>选项时，其值前无论有没有<code>0x</code>标记都是 16 进制的，当有<code>-c</code>选项时，其值是十进制的。</p></li><li><p><code>command</code> : 命令或者可执行程序</p></li><li><p><code>pid</code> : 进程 ID，可以通过<code>ps/top/pidof</code>等命令获取</p></li></ul><p><code>[arg]</code> command 的参数</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="使用指定的-CPU-亲和性运行一个新程序"><a href="#使用指定的-CPU-亲和性运行一个新程序" class="headerlink" title="使用指定的 CPU 亲和性运行一个新程序"></a>使用指定的 CPU 亲和性运行一个新程序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskset [-c] mask <span class="hljs-built_in">command</span> [arg]...<br><span class="hljs-comment"># 举例: 使用CPU0运行ls命令显示/etc/init.d下的所有内容</span><br>taskset -c 0 ls -al /etc/init.d/<br></code></pre></td></tr></table></figure><h4 id="显示已经运行的进程的-CPU-亲和性"><a href="#显示已经运行的进程的-CPU-亲和性" class="headerlink" title="显示已经运行的进程的 CPU 亲和性"></a>显示已经运行的进程的 CPU 亲和性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskset -p pid<br><span class="hljs-comment"># 举例:查看init进程(PID=1)的CPU亲和性</span><br>taskset -p 1<br></code></pre></td></tr></table></figure><h4 id="改变已经运行进程的-CPU-亲和性"><a href="#改变已经运行进程的-CPU-亲和性" class="headerlink" title="改变已经运行进程的 CPU 亲和性"></a>改变已经运行进程的 CPU 亲和性</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq">taskset -p[c] mask pid<br>举例:打开<span class="hljs-number">2</span>个终端,在第一个终端运行<span class="hljs-built_in">top</span>命令,第二个终端中<br> 　　首先运行:[~]# ps -eo pid,args,psr | <span class="hljs-type">grep</span> <span class="hljs-built_in">top</span> #获取<span class="hljs-built_in">top</span>命令的pid和其所运行的CPU号<br> 　　其次运行:[~]# taskset -cp 新的CPU号 pid       #更改<span class="hljs-built_in">top</span>命令运行的CPU号<br> 　　最后运行:[~]# ps -eo pid,args,psr | <span class="hljs-type">grep</span> <span class="hljs-built_in">top</span> #查看是否更改成功<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">ps</span> <span class="hljs-string">-eo</span> <span class="hljs-string">pid,args,psr</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">top</span><br><span class="hljs-number">2501 </span><span class="hljs-string">nautilus-desktop</span>             <span class="hljs-number">24</span><br><span class="hljs-number">2634</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">18</span><br><span class="hljs-number">2658</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">11</span><br><span class="hljs-number">23848</span> <span class="hljs-string">top</span>                           <span class="hljs-number">6</span><br><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">taskset</span> <span class="hljs-string">-cp</span> <span class="hljs-number">10</span> <span class="hljs-number">23848</span><br><span class="hljs-string">pid</span> <span class="hljs-number">23848</span><span class="hljs-string">&#x27;s current affinity list: 0-31</span><br><span class="hljs-string">pid 23848&#x27;</span><span class="hljs-attr">s new affinity list:</span> <span class="hljs-number">10</span><br><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">ps</span> <span class="hljs-string">-eo</span> <span class="hljs-string">pid,args,psr</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">top</span><br> <span class="hljs-number">2501 </span><span class="hljs-string">nautilus-desktop</span>             <span class="hljs-number">24</span><br> <span class="hljs-number">2634</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">18</span><br> <span class="hljs-number">2658</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">11</span><br><span class="hljs-number">23848</span> <span class="hljs-string">top</span>                          <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><blockquote><p>一个用户要设定一个进程的 CPU 亲和性，如果目标进程是该用户的，则可以设置，如果是其他用户的，则会设置失败，提示 Operation not permitted.当然 root 用户没有任何限制。<br>任何用户都可以获取任意一个进程的 CPU 亲和性。</p></blockquote><h2 id="程序-API-实现硬亲和性"><a href="#程序-API-实现硬亲和性" class="headerlink" title="程序 API 实现硬亲和性"></a>程序 API 实现硬亲和性</h2><p>以下实验使用的源码可以从<a href="https://github.com/Dunky-Z/learning-linux/tree/main/Affinity">这个仓库</a>获取。</p><p>以下是一些设置亲和性时会用到的宏定义及函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span> <span class="hljs-comment">//注意&lt;pthread.h&gt;包含&lt;sched.h&gt;</span></span><br><br><span class="hljs-comment">/* MACRO */</span><br>        <span class="hljs-comment">// 对 CPU 集初始化，将其设置为空集</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_ZERO</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_ZERO_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 将 CPU 加入到 CPU 集中</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_SET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_SET_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 将 CPU 从 CPU 集中移除</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_CLR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_CLR_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 判断 CPU 是否在 CPU 集中</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_ISSET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_ISSET_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 计算 CPU 集的大小</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_COUNT</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_COUNT_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// The following macros perform logical operations on CPU sets </span><br>        <span class="hljs-comment">/* Store the logical AND of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_AND</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_AND_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Store the logical OR of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_OR</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_OR_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Store  the logical XOR of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_XOR</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_XOR_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Test whether two CPU set contain exactly the same CPUs. */</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_EQUAL</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *set1, <span class="hljs-keyword">cpu_set_t</span> *set2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_EQUAL_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *set1, <span class="hljs-keyword">cpu_set_t</span> *set2)</span></span>;<br>    <br>    <span class="hljs-comment">/* The following macros are used to allocate and deallocate CPU sets: */</span><br>        <span class="hljs-comment">/* Allocate a CPU set large enough to hold CPUs in the range 0 to num_cpus-1 */</span><br>        <span class="hljs-function"><span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-title">CPU_ALLOC</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num_cpus)</span></span>;<br>    <br>        <span class="hljs-comment">/* Return the size in bytes of the CPU set that would be needed to  hold  CPUs  in the  range 0 to num_cpus-1. </span><br><span class="hljs-comment">           This macro provides the value that can be used for the setsize argument in the CPU_*_S() macros */</span><br>        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">CPU_ALLOC_SIZE</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num_cpus)</span></span>;<br>        <br>        <span class="hljs-comment">/* Free a CPU set previously allocated by CPU_ALLOC(). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_FREE</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br><br><span class="hljs-comment">/* API */</span><br>    <span class="hljs-comment">/*该函数设置进程为 pid 的这个进程，让它运行在 mask 所设定的 CPU 上。如果 pid 的值为 0,</span><br><span class="hljs-comment">    *则表示指定的是当前进程，使当前进程运行在 mask 所设定的那些 CPU 上.</span><br><span class="hljs-comment">    *第二个参数 cpusetsize 是 mask 所指定的数的长度。通常设定为 sizeof(cpu_set_t).</span><br><span class="hljs-comment">    *如果当前 pid 所指定的进程此时没有运行在 mask 所指定的任意一个 CPU 上，</span><br><span class="hljs-comment">    *则该指定的进程会从其它 CPU 上迁移到 mask 的指定的一个 CPU 上运行.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sched_setaffinity</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *mask)</span></span>;<br>    <span class="hljs-comment">/*该函数获得 pid 所指示的进程的 CPU 位掩码，并将该掩码返回到 mask 所指向的结构中.</span><br><span class="hljs-comment">    *即获得指定 pid 当前可以运行在哪些 CPU 上.</span><br><span class="hljs-comment">    *同样，如果 pid 的值为 0.也表示的是当前进程</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sched_getaffinity</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *mask)</span></span>;<br>    <br>    <span class="hljs-comment">/* set CPU affinity attribute in thread attributes object */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_attr_setaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_attr_t</span> *attr, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">const</span> <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <span class="hljs-comment">/* get CPU affinity attribute in thread attributes object */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_attr_getaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_attr_t</span> *attr, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <br>    <span class="hljs-comment">/* set CPU affinity of a thread */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_setaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">const</span> <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <span class="hljs-comment">/* get CPU affinity of a thread */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_getaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br></code></pre></td></tr></table></figure><p>程序中会使用<code>syscall</code>来获取一些内核数据，<code>syscall</code>是执行一个系统调用，根据指定的参数<code>number</code>和所有系统调用的接口来确定调用哪个系统调用，用于用户空间跟内核之间的数据交换，下面是<code>syscall</code>函数原型及一些常用的<code>number</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//syscall - indirect system call</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE         <span class="hljs-comment">/* See feature_test_macros(7) */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span>   <span class="hljs-comment">/* For SYS_xxx definitions */</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number, ...)</span></span>;<br><br><span class="hljs-comment">// 查看缓存内存页面的大小；打印用%ld 长整型。</span><br>sysconf(_SC_PAGESIZE);  <br><span class="hljs-comment">// 查看内存的总页数；打印用%ld 长整型。</span><br>sysconf(_SC_PHYS_PAGES) <br><span class="hljs-comment">// 查看可以利用的总页数；打印用%ld 长整型。</span><br>sysconf(_SC_AVPHYS_PAGES) <br><span class="hljs-comment">// 查看 CPU 的个数；打印用%ld 长整。</span><br>sysconf(_SC_NPROCESSORS_CONF) <br><span class="hljs-comment">// 查看在使用的 CPU 个数；打印用%ld 长整。</span><br>sysconf(_SC_NPROCESSORS_ONLN) <br><span class="hljs-comment">// 计算内存大小。</span><br>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)sysconf(_SC_PAGESIZE) * (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)sysconf(_SC_PHYS_PAGES) <br><span class="hljs-comment">// 查看最大登录名长度；打印用%ld 长整。</span><br>sysconf(_SC_LOGIN_NAME_MAX) <br><span class="hljs-comment">// 查看最大主机长度；打印用%ld 长整。</span><br>sysconf(_SC_HOST_NAME_MAX) <br><span class="hljs-comment">// 每个进程运行时打开的文件数目；打印用%ld 长整。</span><br>sysconf(_SC_OPEN_MAX)  <br><span class="hljs-comment">// 查看每秒中跑过的运算速率；打印用%ld 长整。</span><br>sysconf(_SC_CLK_TCK) <br><br></code></pre></td></tr></table></figure><h3 id="使用-2-种方式-带和不带-S-后缀的宏-获取当前进程的-CPU-亲和性"><a href="#使用-2-种方式-带和不带-S-后缀的宏-获取当前进程的-CPU-亲和性" class="headerlink" title="使用 2 种方式 (带和不带_S 后缀的宏) 获取当前进程的 CPU 亲和性"></a>使用 2 种方式 (带和不带_S 后缀的宏) 获取当前进程的 CPU 亲和性</h3><p>相关的宏通常都分为 2 种，一种是带<code>_S</code>后缀的，一种不是不带<code>_S</code>后缀的，从声明上看带<code>_S</code>后缀的宏都多出一个参数 <code>setsize</code>。</p><p>从功能上看他们的区别是带<code>_S</code>后缀的宏是用于操作动态申请的<code>CPU set(s)</code>，所谓的动态申请其实就是使用宏 <code>CPU_ALLOC</code> 申请，</p><p>参数 <code>setsize</code> 可以是通过宏 <code>CPU_ALLOC_SIZE</code> 获得，两者的用法详见下面的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> WITH_S</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WITH_S</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> *pmask;<br>    <span class="hljs-keyword">size_t</span> cpusize;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 获取逻辑 CPU 个数 */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br><br>    pmask = CPU_ALLOC(nrcpus);<br>    cpusize = CPU_ALLOC_SIZE(nrcpus);<br>    CPU_ZERO_S(cpusize, pmask);<br><br>    <span class="hljs-comment">/* 获取 CPU 亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, cpusize, pmask) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        CPU_FREE(pmask);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET_S(i, cpusize, pmask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    CPU_FREE(pmask);<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br><br>    CPU_ZERO(&amp;mask);<br><br>    <span class="hljs-comment">/* 获取 CPU 亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取逻辑 CPU 个数 */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(i, &amp;mask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs delphi"># 直接运行，不设置亲和性，获取CPU亲和性为所有CPU都会被设置<br>➜  Affinity git:(main)   ./bin/main <br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#5</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#6</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#7</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#8</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#9</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#10</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#11</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#12</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#13</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#14</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#15</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#16</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#17</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#18</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#19</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#20</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#21</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#22</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#23</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#24</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#25</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#26</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#27</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#28</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#29</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#30</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#31</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>xffffffff<br><br># 使用taskset设置亲和性，将main程序绑定到第<span class="hljs-number">1</span>个CPU上，mask转化为<span class="hljs-number">16</span>进制为<span class="hljs-number">0</span>x1<br>➜  Affinity git:(main)  taskset <span class="hljs-number">1</span> ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>x1<br><br># 使用taskset设置亲和性，将main程序绑定到第<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>个CPU上，mask转化为<span class="hljs-number">16</span>进制为<span class="hljs-number">0</span>x55<br>➜  Affinity git:(main)  taskset <span class="hljs-number">55</span> ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#6</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>x55<br><br># 使用taskset设置亲和性，将main程序绑定到第<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>个CPU上，mask转化为<span class="hljs-number">16</span>进制为<span class="hljs-number">0</span>xf<br>➜  Affinity git:(main)  taskset F ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>xf<br></code></pre></td></tr></table></figure><h3 id="设置进程的-CPU-亲和性后再获取显示-CPU-亲和性"><a href="#设置进程的-CPU-亲和性后再获取显示-CPU-亲和性" class="headerlink" title="设置进程的 CPU 亲和性后再获取显示 CPU 亲和性"></a>设置进程的 CPU 亲和性后再获取显示 CPU 亲和性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span> <span class="hljs-comment">/* sysconf */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">/* exit */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br>    <br>    CPU_ZERO(&amp;mask);<br>    <br>    CPU_SET(<span class="hljs-number">0</span>, &amp;mask); <span class="hljs-comment">/* add CPU0 to cpu set */</span><br>    CPU_SET(<span class="hljs-number">2</span>, &amp;mask); <span class="hljs-comment">/* add CPU2 to cpu set */</span><br>    CPU_SET(<span class="hljs-number">3</span>, &amp;mask); <span class="hljs-comment">/* add CPU3 to cpu set */</span><br><br>    <span class="hljs-comment">/* 设置 CPU 亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_setaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) <br>    &#123;   <br>        perror(<span class="hljs-string">&quot;sched_setaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <br>    CPU_ZERO(&amp;mask);<br>    <br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) <br>    &#123;   <br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>       <span class="hljs-comment">/* get logical cpu number */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(i, &amp;mask))<br>        &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i); <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">➜  Affinity git:(main) ✗ ./bin/main <br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>bitmask = <span class="hljs-number">0</span>xd<br></code></pre></td></tr></table></figure><h3 id="设置线程的-CPU-属性后再获取显示-CPU-亲和性"><a href="#设置线程的-CPU-属性后再获取显示-CPU-亲和性" class="headerlink" title="设置线程的 CPU 属性后再获取显示 CPU 亲和性"></a>设置线程的 CPU 属性后再获取显示 CPU 亲和性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span> <span class="hljs-comment">//不用再包含&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> handle_error_en(en, msg) \</span><br><span class="hljs-meta">        do &#123; errno = en; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> s, j;<br>    <span class="hljs-keyword">cpu_set_t</span> cpuset;<br>    <span class="hljs-keyword">pthread_t</span> thread;<br>    <br>    thread = pthread_self();<br>    <br>    <span class="hljs-comment">/* Set affinity mask to include CPUs 0 to 7 */</span><br>    CPU_ZERO(&amp;cpuset);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>        CPU_SET(j, &amp;cpuset);<br>    <br>    s = pthread_setaffinity_np(thread, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;cpuset);<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>    &#123;<br>        handle_error_en(s, <span class="hljs-string">&quot;pthread_setaffinity_np&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* Check the actual affinity mask assigned to the thread */</span><br>    s = pthread_getaffinity_np(thread, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;cpuset);<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>    &#123;<br>        handle_error_en(s, <span class="hljs-string">&quot;pthread_getaffinity_np&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Set returned by pthread_getaffinity_np() contained:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; CPU_SETSIZE; j++) <span class="hljs-comment">//CPU_SETSIZE 是定义在&lt;sched.h&gt;中的宏，通常是 1024</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(j, &amp;cpuset))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    CPU %d\n&quot;</span>, j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gams">➜  Affinity git:(main) ./bin/main<br><span class="hljs-keyword">Set</span> returned <span class="hljs-comment">by pthread_getaffinity_np() contained:</span><br>    CPU <span class="hljs-comment">0</span><br>    CPU <span class="hljs-comment">1</span><br>    CPU <span class="hljs-comment">2</span><br>    CPU <span class="hljs-comment">3</span><br>    CPU <span class="hljs-comment">4</span><br>    CPU <span class="hljs-comment">5</span><br>    CPU <span class="hljs-comment">6</span><br>    CPU <span class="hljs-comment">7</span><br></code></pre></td></tr></table></figure><h3 id="使用-seched-setaffinity-设置线程的-CPU-亲和性"><a href="#使用-seched-setaffinity-设置线程的-CPU-亲和性" class="headerlink" title="使用 seched_setaffinity 设置线程的 CPU 亲和性"></a>使用 seched_setaffinity 设置线程的 CPU 亲和性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span> <span class="hljs-comment">// syscall</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> tid;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br>    <br>    CPU_ZERO(&amp;mask);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;mask); <span class="hljs-comment">/* add CPU0 to cpu set */</span><br>    CPU_SET(<span class="hljs-number">2</span>, &amp;mask); <span class="hljs-comment">/* add CPU2 to cpu set */</span><br><br>    <span class="hljs-comment">// 获取线程 id</span><br>    tid = syscall(__NR_gettid); <span class="hljs-comment">// or syscall(SYS_gettid);</span><br><br>    <span class="hljs-comment">// 对指定线程 id 设置 CPU 亲和性</span><br>    <span class="hljs-keyword">if</span> (sched_setaffinity(tid, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) <br>    &#123;<br>        perror(<span class="hljs-string">&quot;sched_setaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(i, &amp;mask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">➜  Affinity git:(main) ./bin/main<br>processor <span class="hljs-string">#0</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br>processor <span class="hljs-string">#2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span><br></code></pre></td></tr></table></figure><h2 id="什么是中断亲和性"><a href="#什么是中断亲和性" class="headerlink" title="什么是中断亲和性"></a>什么是中断亲和性</h2><p>计算机中，中断是一种电信号，由硬件产生并直接送到中断控制器上，再由中断控制器向 CPU 发送中断信号，CPU 检测到信号后，中断当前工作转而处理中断信号。CPU 会通知操作系统已经产生中断，操作系统就会对中断进行处理。<br>这里有篇推文：<a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247484717&idx=1&sn=2c1dd6c389c8476eb4fd178c714eaafc&scene=21#wechat_redirect">CPU 明明 8 个核，网卡为啥拼命折腾一号核？</a>生动的解释了中断亲和性。</p><p>默认情况下，Linux 中断响应会被平均分配到所有 CPU 核心上，势必会发生写新的数据和指令缓存，并与 CPU 核心上原有进程产生冲突，造成中断响应延迟，影响进程处理时间。为了解决这个问题，可以将中断（或进程）绑定到指定 CPU 核心上，中断（或进程）所需要指令代码和数据有更大概率位于指定 CPU 本地数据和指令缓存内，而不必进行新的写缓存，从而提高中断响应（或进程）的处理速度。</p><h2 id="中断亲和性的使用场景"><a href="#中断亲和性的使用场景" class="headerlink" title="中断亲和性的使用场景"></a>中断亲和性的使用场景</h2><p>对于文件服务器、Web 服务器，把不同的网卡 IRQ 均衡绑定到不同的 CPU 上将会减轻某 CP 的负载，提高多个 CPU 整体处理中断的能力; 对于数据库服务器，把磁盘控制器绑到一个 CPU、把网卡绑定到另一个 CPU 将会提高数据库的响应时间、优化性能。<br>合理的根据自己的生产环境和应用的特点来平衡 IRQ 中断有助于提高系统的整体吞吐能力和性能。</p><h2 id="中断绑定流程"><a href="#中断绑定流程" class="headerlink" title="中断绑定流程"></a>中断绑定流程</h2><ol><li><p>关闭中断平衡守护进程<br>中断平衡守护进程（irqbalance daemon）会周期性地将中断平均地公平地分配给各个 CPU 核心，默认开启。为了实现中断绑定，首先需要将中断平衡守护进程关闭。</p><ul><li><code>systemctl status irqbalance</code>查看守护进程的运行状态</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ systemctl status irqbalance<br><br>● irqbalance.service - irqbalance daemon<br>Loaded: loaded (/lib/systemd/system/irqbalance.service; enabled; vendor preset: <span class="hljs-built_in">enable</span><br>Active: active (running) since Thu 2022-05-19 14:46:20 CST; 1 weeks 1 days ago<br>Main PID: 1062 (irqbalance)<br>    Tasks: 2 (<span class="hljs-built_in">limit</span>: 4915)<br>CGroup: /system.slice/irqbalance.service<br>        └─1062 /usr/sbin/irqbalance --foreground<br><br>5月 19 14:46:20 zdd systemd[1]: Started irqbalance daemon.<br></code></pre></td></tr></table></figure><ul><li><code>systemctl stop irqbalance</code>关闭中断平衡守护进程，中断响应默认都会由 CPU0 核心处理。或者<code>systemctl disable irqbalance</code>取消中断平衡守护进程开机重启。因为关闭中断平衡守护进程过于强硬，可以在不关闭中断平衡守护进程条件下，让某些 CPU 核心脱离中断平衡守护进程的管理。</li></ul></li><li><p>绑定中断<br>中断绑定时，需要关闭系统中断平衡守护进程<code>systemctl stop irqbalance</code>计算机当前各种中断响应情况在 <code>/proc/interrupts</code> 文件中。</p><p> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205281336182.png"><br> 第一列是中断 ID 号，CPU N 列是中断在第 n 个 CPU 核心上的响应次数，倒数第二列是中断类型，最后一列是描述。  </p><p> 利用 echo 命令将 CPU 掩码写入 <code>/proc/irq/中断 ID/smp_affinity</code> 文件中，即可实现修改某一中断的 CPU 亲和性。例如  </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> 0x0004 &gt; /proc/irq /50/smp_affinity<br></code></pre></td></tr></table></figure></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/lubinlew/p/cpu_affinity.html">Linux 中 CPU 亲和性 (affinity) - LubinLew - 博客园</a><br><a href="https://blog.51cto.com/u_15302006/3075968">操作系统底层技术——CPU 亲和性_mb60ed33cfc44fa 的技术博客_51CTO 博客</a><br><a href="https://blog.51cto.com/u_15484754/4907846">linux 进程、线程与 CPU 的亲和性（affinity）_wx61d68abba262d 的技术博客_51CTO 博客</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247484717&idx=1&sn=2c1dd6c389c8476eb4fd178c714eaafc&scene=21#wechat_redirect">CPU 明明 8 个核，网卡为啥拼命折腾一号核？</a><br><a href="https://en.wikipedia.org/wiki/Processor_affinity">Processor affinity - Wikipedia</a><br><a href="https://mp.weixin.qq.com/s/HwDqCk8vtMdSEVSCLHAsbg">什么？一个核同时执行两个线程？</a><br><a href="https://www.cnblogs.com/wenqiang/p/6049978.html#!comments">linux 进程、线程与 CPU 的亲和性（affinity） - zhangwju - 博客园</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>CPU</tag>
      
      <tag>亲和性</tag>
      
      <tag>Affinity</tag>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SoC 存储器比较</title>
    <link href="/2022/05/21/SoC%E5%AD%98%E5%82%A8%E5%99%A8%E6%AF%94%E8%BE%83/"/>
    <url>/2022/05/21/SoC%E5%AD%98%E5%82%A8%E5%99%A8%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>也就是内部存储器，主要用来运行程序的，典型的就是 RAM 随机存储器（Random Access Memory），那么随机是什么意思？所谓随机，指的是当存储器中的数据被读取或写入时，所需要的时间与这段信息所在的位置无关（任何位置读写速度一样）。</p><p><strong>DRAM</strong>（Dynamic Random Access Memory，动态随机存储器）是最为常见的系统内存。我们使用的电脑和手机的运行内存都是 DRAM。DRAM 使用电容存储，DRAM 只能将数据保持很短的时间。为了保持数据，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。数据的存储，请参考数据存储模型。我们知道，电容中的电荷很容易变化，所以随着时间推移，电容中的电荷数会增加或减少，为了确保数据不会丢失，DRAM 每隔一段时间会给电容刷新（充电或放电）。动态：定时刷新数据</p><p><strong>SRAM</strong>（Static Random Access Memory，静态随机存储器），它是一种具有静止存取功能的内存，其内部机构比 DRAM 复杂，可以做到不刷新电路即能保存它内部存储的数据。<strong>静态：不需要刷新</strong></p><p><strong>DDR SDRAM</strong>（Double Data Rate SDRAM）：为双信道同步动态随机存取内存，是新一代的 SDRAM 技术。DDR 内存芯片的数据预取宽度（Prefetch）为 2 bit（SDRAM 的两倍）。</p><p><strong>DDR2 SDRAM</strong>（Double Data Rate Two SDRAM）：为双信道两次同步动态随机存取内存。DDR2 内存 Prefetch 又再度提升至 4 bit（DDR 的两倍）</p><p><strong>DDR3 SDRAM</strong>（Double Data Rate Three SDRAM）：为双信道三次同步动态随机存取内存。DDR3 内存 Prefetch 提升至 8 bit，即每次会存取 8 bits 为一组的数据。运算频率介于 800MHz -1600MHz 之间。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205211606655.png"></p><h2 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h2><p>外部存储器，通常用来存储文件的，一般也叫 ROM（<strong>Read-only memory</strong>）只读存储器。</p><p>CPU 连接内存和外存的连接方式不同。内存需要直接地址访问，所以是通过地址总线&amp;数据总线的总线式访问方式连接的（好处是直接访问，随机访问；坏处是占用 CPU 的地址空间，大小受限）；外存是通过 CPU 的外存接口来连接的（好处是不占用 CPU 的地址空间，坏处是访问速度没有总线式快，访问时序较复杂）</p><blockquote><p>我们平时用的硬盘，SD 卡都属于 ROM，但是他们却可以写入？ROM 严格意义来讲确实是只读的，但是随着储存器的发展，出现了可擦可编程只读存储器（EPROM）、电可擦可编程只读存储器（EEPROM）形式的半导体存储器，以及 flash。他们都是可写的。ROM 就不再单单只表示只读存储器了，一般来说与 RAM 相对，掉电不易失的存储器都被当做 ROM。</p></blockquote><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p>ROM（Read Only Memory）只读存储器，这种存储器（Memory）的内容任何情况下都不会改变，电脑与用户只能读取保存在这里的指令，和使用存储在 ROM 的资料，但不能变更或存入资料。ROM 被存储在一个非易失性芯片上，也就是说，即使在关机之后记忆的内容仍可以被保存，所以这种存储器多用来存储特定功能的程序，如<a href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E4%BB%B6">固件</a>。ROM 存储用来启动电脑的程序（如<a href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a>），电脑引导的时候 BIOS 提供一连串的指令对中央处理器（<a href="https://zh.wikipedia.org/wiki/CPU">CPU</a>）等组件进行初始化，在初始化过程中，BIOS 程序初始化并检查<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">RAM</a>。</p><h3 id="NorFlash"><a href="#NorFlash" class="headerlink" title="NorFlash"></a>NorFlash</h3><p>总线式访问，接到 SROM bank，优点是可以直接总线访问，一般用来启动。</p><h3 id="NandFlash"><a href="#NandFlash" class="headerlink" title="NandFlash"></a>NandFlash</h3><p>SLC：容量小，价格高，稳定性高</p><p>MLC：容量大，价格低，稳定性差，易出坏块</p><p><strong>iNand</strong><br>SanDisk 公司出产的 eMMC</p><p><strong>moviNand</strong><br>三星公司出产的 eMMC</p><p><strong>oneNAND</strong><br>三星公司出的一种 Nand，价格贵，用的少</p><p><strong>SD 卡（Secure Digital Memory Card）</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205192308956.png"></p><p><strong>TF 卡（TransFLash Card, MicroSD）</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205192309547.png"></p><p><strong>MMC 卡</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205192312777.png"></p><p><strong>eMMC 卡（embeded MMC）</strong><br>嵌入式的 MMC，可以当成一种芯片，内部做了坏块处理</p><p><strong>SATA 硬盘</strong></p><p>特点：机械式访问、磁存储原理、SATA 是接口。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>芯片开发</tag>
      
      <tag>SoC</tag>
      
      <tag>固件开发</tag>
      
      <tag>存储器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interlaken 协议</title>
    <link href="/2022/05/18/Interlaken%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/05/18/Interlaken%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对 Interlaken 协议文档的翻译加了一些自己的理解；</p></blockquote><p><strong>8b/10b编码</strong>：在串行通道上传输时，将 8bits 数据编码为 10bits 数据，做一个转换，使各位数据之间有更多的 1 到 0 和 0 到 1 的跳变，以便接收设备检测这些跳变，能更容易地恢复时钟。<strong>64B/67B 编码</strong>编码的原因也是类似的。这样，在串行通道上传输 10 位数据，实际上只传输了 8 位。</p><h2 id="协议层（Protocol-Layer）"><a href="#协议层（Protocol-Layer）" class="headerlink" title="协议层（Protocol Layer）"></a>协议层（Protocol Layer）</h2><h3 id="传输格式"><a href="#传输格式" class="headerlink" title="传输格式"></a>传输格式</h3><p>数据通过可配置数量的 SerDes 通道（Lane），再由 Interlaken 接口传输。在本文档中，通道被定义为两个 IC 之间的单工串行链路（simplex serial link）。该协议旨在与任意数量的通道一起运行（1 个或多个，没有上限）。实际实现时会固定一个数值，不会设计为可变值。</p><p>接口发送数据的基本单位是一个 8 字节的字（Word）。用 8 字节是为了符合<strong>64B/67B 编码</strong>，用于描述突发（Burst）的控制字的大小也是 8 字节。通过使基本传输单元与控制字大小相等，可以<strong>很容易地调整接口的宽度</strong>。</p><p>数据和控制字按顺序在通道上传输，从通道 0 开始，到通道 M 结束，并在下一个数据块中重复。图 4 说明了该过程</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517120049.png"></p><p>64B/67B编码在每个通道上独立进行。传输通过两种基本数据类型实现：数据字和控制字，他们通过64B/67B 帧位（framing bits）进行区分。这两种数据字类型的格式如下图所示：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517120402.png"></p><p>数据和控制信息都是以位 66～0 的顺序传输的，框架层引入了 4 个附加控制字，详细信息后面将描述。</p><h3 id="Burst-结构（Burst-Structure）"><a href="#Burst-结构（Burst-Structure）" class="headerlink" title="Burst 结构（Burst Structure）"></a>Burst 结构（Burst Structure）</h3><h4 id="数据传输流程"><a href="#数据传输流程" class="headerlink" title="数据传输流程"></a>数据传输流程</h4><p>Interlaken 接口的带宽在支持的通道上被划分为 Bursts。数据包通过一个或多个 Burst 在接口上传输。Burst 通过一个或多个控制字来描述。为了将任意大小的数据包分割成 Burst，定义以下两个参数：</p><ul><li>BurstMax：Burst 的最大大小（64Bytes 的倍数）</li><li>BurstShort：Burst 的最小大小（最小 32Bytes，增量为 8Bytes）</li></ul><p>该接口通常通过发送一个 BurstMax 长度的数据突发来运行，然后是一个控制字。发送设备中的调度逻辑可以自由选择信道服务的顺序，<strong>受流控状态的约束</strong>。Burst 在每个通道上传输，直到数据包完全传输，此时该通道上的新数据包传输才开始。</p><p>因为接口是信道化的，数据包的结束可能会在几个信道上连续地出现，每个信道上的剩余数据量非常小。由于发射器和接收器的存储器可能被理想地设计成宽数据通路，它们需要以非常高的速率来处理这种情况。为了减少接收器和发射器的负担，BurstShort 参数保证了连续的 Burst 控制字之间的最小间隔。最小的 BurstShort 间隔是 32 字节，更大的值可以以 8 字节为增量。</p><blockquote><p>如果没有最小 Burst 的限制，那么数据包太小的话，发送器或者接收器就会频繁收到 end-of-packet，这就增加了处理负担。</p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517142438.png" alt="示意如何保证 BurstShort 最小间隔。BurstShort 通过在下一个 Burst 控制字之前添加额外的空闲控制字来保证最小 Burst 的大小。图中，Idle Control Word 1 的 EOP_Format 指示 EOP 和 Last Data Word 的适当大小，Idle Control Word 1 的 CRC24 涵盖了 Last Data Word 和 Idle Control Word 1。插入 Idle Control Word 2 和 Idle Control Word 3 BurstShort 来保证 BurstShort 为 32 字节，随后的 Burst 控制字属于下一轮发送的数据。"></p><h4 id="控制字格式"><a href="#控制字格式" class="headerlink" title="控制字格式"></a>控制字格式</h4><p>突发通过一个 8 字节的控制字来描述。控制字在数据流中通过使用位 [66:64] 的“0x10”控制代码和位 [63] = ‘1’ 来标识突发和空闲控制字格式如第 16 页的图 7 所示：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517182706.png"></p><h3 id="流控（Flow-Control）"><a href="#流控（Flow-Control）" class="headerlink" title="流控（Flow Control）"></a>流控（Flow Control）</h3><p>Interlaken 的一个关键特性是能够传达每个通道背压（backpressure）。为了提供此功能，指定了两个选项：<strong>带外流控接口和带内通道</strong>。从语义上讲，流控制信息<strong>使用简单的开关机制来表示允许在特定通道上传输</strong>。</p><p>开关流控制状态与每个通道的单个状态位进行通信。按照惯例，“1”标识“XON”状态，表示允许发送器在该通道上发送数据。 “0”标识“XOFF”状态，表示发送器不允许在该通道上发送数据。</p><p>该协议没有 Credits 的概念；一旦通道被指示为 XON，发送器可以在该通道上发送尽可能多的数据，直到流控制状态更改为 XOFF。接收器选择在 XON 和 XOFF 状态之间切换的阈值是留给用户的可编程选项，取决于支持的通道数量、接收缓冲区的深度和给定环境的流控制延迟。</p><p>流控制通道可以选择映射到 calendar，从而流控制可以映射到任何一组 calendar entry。例如，这些可以包括通道到 calendar entry 的一对一映射、一对多映射或插入空字段以匹配具有不同通道定义的设备。</p><blockquote><p>Channel Calendar 将通道映射到流控状态槽</p></blockquote><p>这个 Calendar 结构也可以用来提供链路级的流控制，Calendar 中的一个 bit 代表了在整个接口上传输数据的权限。链路状态的极性将与通道状态的极性相同：“1”表示允许传输，“0”表示立即停止传输。要启用此功能，可以为每个 Calendar entry 配置通道信息或链接信息。为了促进低延迟链路状态，接口需要提供足够的 Calendar entry，以便在每个突发/空闲控制字的相同位位置编程链路状态。例如，使用超过 16 个通道，这可以通过以下设置执行：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517165148.png"></p><p>使用此方法，link status将始终出现在突发/空闲控制字的位[55]中。</p><h4 id="带外流控"><a href="#带外流控" class="headerlink" title="带外流控"></a>带外流控</h4><p>为了支持需要单工操作的系统，定义了带外流量控制选项。这是作为一个源同步接口实现的，并由以下信号指定：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>型号名称</td><td>功能</td></tr><tr><td>FC_CLK</td><td>与流控数据同步的时钟</td></tr><tr><td>FC_DATA</td><td>流量控制状态信息 (单比特)</td></tr><tr><td>FC_SYNC</td><td>一种同步信号，用于标识流控制 calendar 的开头</td></tr></tbody></table><p>每个信号的 pad 技术可以是 LVDS 或 LVCMOS。这些信号的逻辑时序关系如下图所示：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517165803.png"></p><p>带外流控制通道由 4 位 CRC 计算保护，该 CRC 计算覆盖了多达 64 位的流控制数据。根据^[P. Koopman and T. Chakravarty, Cyclic Redundancy Code (CRC) Polynomial Selection<br>for Embedded Networks, The International Conference on Dependable Networks and<br>Systems, DSN-2004.] 中的建议，CRC4 多项式为：</p><p>$$<br>x^4+x+1<br>$$</p><h4 id="带内流控"><a href="#带内流控" class="headerlink" title="带内流控"></a>带内流控</h4><p>当使用此选项时，接收器利用通过接口发送的控制字中的流控制状态，作为正常数据传输的一部分。提供此选项的目的是，需要最少数量的外部信号引脚的全双工实现。  </p><p>如 Figure 7 所示，控制字的流控制字段为 16 位，位于 bit[55:40]。控制字的位 [31:24] 也可以用于流控制的另外 8 位，总共 24 位。这些状态位表示每个 Interlaken Calendar 通道的 ON-OFF 流控制状态，当前 Calendar Entry X 在位 [55]，Calendar Entry X + 1 在位 [54]，依此类推。为了同步 calendar 的开始，在空闲/突发控制字中提供了“reset calendar”位。当该位为“1”时，calendar entry 0 的状态将出现在位 [55] 中。当“reset calendar”为“0”时，calendar 将从上一个控制字中保留的位置开始继续。当所有通道的流控状态被传输完，发送器将重置复位 calendar，然后重复上一轮顺序操作。Calendar 最后一个控制字中不需要的 bit（即，当通道数目不是状态数目的倍数时）被发送端置 0，接收端忽略。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interlaken</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AMBA 总线协议-AXI 协议</title>
    <link href="/2022/05/17/AMBA%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE-AXI%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/05/17/AMBA%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE-AXI%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="AXI"><a href="#AXI" class="headerlink" title="AXI"></a>AXI</h2><p>组成部分：</p><p>AXI4 协议中包含五种信道，通道之间相互独立且存在差别，通过通道进行通信之前需要使用 VALID/READY 进行握手，Read 和 Write 根据 Master 定义：</p><ul><li>读地址信道（Read Address Channel）</li><li>写地址信道（Write Address Channel）</li><li>读数据信道（Read Data Channel）</li><li>写数据信道（Write Data Channel）</li><li>写响应信道（Write Response Channel）</li></ul><p>还有两种 Component</p><ul><li>Master component</li><li>Slave component</li></ul><p>通信由 Master 发起，Master 可以对 Slave 进行读数据（read）或写（write）数据。每次读写操作都需要一个地址，读地址信道（Read Address Channel）和写地址信道（Write Address Channel）用于传输地址。在写完数据后，Master 需要确认 Slave 有没有收完数据，Slave 收到完整数据后，会通过写响应信道（Write Response Channel）给 Master 一个反馈（completion），表示写操作已经完成。</p><h3 id="VALID-READY-握手机制"><a href="#VALID-READY-握手机制" class="headerlink" title="VALID/READY 握手机制"></a>VALID/READY 握手机制</h3><p>AXI 五个信道相互独立，但是使用同一个握手机制来实现信息传递。</p><p>在握手机制中，通信双方分别扮演<strong>发送方</strong>(Source) 和<strong>接收方</strong>（Destination），两者的操作（技能）并不相同。</p><p><strong>发送方</strong>置高 <strong>VALID</strong> 信号表示发送方已经将数据，地址或者控制信息已经就绪，并保持于消息总线上。</p><p><strong>接收方</strong>置高 <strong>READY</strong> 信号表示接收方已经做好接收的准备。</p><p>当双方的 VALID/READY 信号同时为高，在时钟 ACLK 上升沿，完成一次数据传输。所有数据传输完毕后，双方同时置低自己的信号。</p><p>每个通道都有自己的 VALID /READY 握手信号对：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516200137.png"></p><p>在握手过程中，还会用到 LAST 信号。LAST 信号存在 Write Data Channel 和 Read Data Channel 中，分别表示为 WLAST 和 RLAST，用于标记 burst 的最后一次数据传输，当 slave 接收到 LAST 信号后，说明本次数据传输完成。</p><h4 id="双向流控"><a href="#双向流控" class="headerlink" title="双向流控"></a>双向流控</h4><p>所谓的<strong>双向流控</strong>机制，指的是发送方通过置起 VALID 信号控制发送的时机与速度，接收方也可以通过 READY 信号的置起与否控制接收速度。</p><p>发送方拥有传输的主动权，但接收方在不具备接收能力时，也能够置低信号停止传输，反压发送方。</p><h4 id="握手过程分析"><a href="#握手过程分析" class="headerlink" title="握手过程分析"></a>握手过程分析</h4><blockquote><p>图中 INFORMATION 信号无底色区域表示此时数据已经准备好，已经有新的数据到达。</p></blockquote><p><strong>VALID 信号先到</strong></p><p>发送方 VALID 信号早早就到了，但是接收方的 READY 信号在 T2 之前都没有发送。可能接收方在接收其他数据，或者被堵在数据通路上。</p><p>过了 T2 后，READY 信号到来，此时开始传输，直到 T3 结束，传输完成。</p><p>这里也体现了双向流控机制，发送方的 VALID 信号只要置高，再握手完成之前都不能置低，必须等到接收方 READY 信号置高。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201556.png"></p><p><strong>READY 信号先到</strong></p><p>READY 信号很自由，可以等待 VALID 信号到来再做响应，但也完全可以在 VALID 信号到来前就置高，表示接收端已经做好准备了。</p><p>而且，READY 信号与 VALID 不同，接收方可以置起 READY 之后在 VALID 置高之前都可以随时再置低 READY 信号。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201616.png"></p><p><strong>信号同时同时到达</strong></p><p>这个最简单，两个信号都等着一个时钟上升沿就完成传输了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201647.png"></p><h4 id="握手信号之间的依赖关系"><a href="#握手信号之间的依赖关系" class="headerlink" title="握手信号之间的依赖关系"></a>握手信号之间的依赖关系</h4><p>为了防止死锁发生，信号之间要遵循一些规矩，举例来说，如上面提到的 READY 信号依赖 VALID 信号，但是 VALID 信号不能根据 READY 信号来判断是否数据已准备好，否则将会造成死锁。下面详细解释读写过程中需要遵循的依赖关系。</p><ul><li>单箭头指向的两个信号，信号的置高，低没有顺序要求。</li><li>双箭头表示箭头所指对象应迟于箭头出发信号发送。</li></ul><p><strong>Read transaction dependencies</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517100503.png"></p><ul><li>Master 不得等待 Slave 置高 ARREADY</li><li>Slave 可以在置高 ARREADY 之前等待 ARVALID 置高</li><li>Slave 能够在 ARVALID 置高之前先置高 ARREADY</li><li>Slave 必须等待 ARVALID 和 ARREADY 都被置高，然后才置高 RVALID 以表示有效数据可用</li><li>在置高 RVALID 之前，Slave 不得等待 Master 置高 RREADY</li><li>Master 可以在置高 RREADY 之前等待 RVALID 被置高</li><li>Master 可以在 RVALID 被置高之前置高 RREADY</li></ul><p><strong>Write transaction dependencies</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517100647.png"></p><ul><li>在置高 AWVALID 或 WVALID 之前，Master 不得等待 Slave 置高 AWREADY 或 WREADY</li><li>Slave 可以在置高 AWREADY 之前等待 AWVALID 或 WVALID，或两者都等待</li><li>Slave 可以在 AWVALID 或 WVALID 或两者都被置高之前置高 AWREADY</li><li>在置高 WREADY 之前，Slave 可以等待 AWVALID 或 WVALID，或两者都等待</li><li>Slave 可以在 AWVALID 或 WVALID 或两者都被置高之前置高 WREADY</li><li>在置高 BVALID 之前，Slave 必须等待 WVALID 和 WREADY 都被置高<ul><li>Slave还必须在置高 BVALID 之前等待 WLAST 被置高，因为写入响应 BRESP 必须在写入事务的最后一次数据传输之后才发出信号</li></ul></li><li>在置高 BVALID 之前，Slave 不得等待 Master 置高 BREADY</li><li>Master 可以在置高 BREADY 之前等待 BVALID</li><li>Master 可以在 BVALID 被置高之前置高 BREADY</li></ul><h3 id="地址结构（Address-structure）"><a href="#地址结构（Address-structure）" class="headerlink" title="地址结构（Address structure）"></a>地址结构（Address structure）</h3><p>AXI 协议是基于 Burst 的，地址结构里声明了一些传输过程中需要的信号，如起始地址，burst 传输长度，传输模式等等。</p><h4 id="Burst"><a href="#Burst" class="headerlink" title="Burst"></a>Burst</h4><p>在介绍 Burst transfer 之前，需要解释一下什么是 Burst。在手册的术语表中，与 AXI 传输相关的有三个概念，分别是 transfer(beat)、burst、transaction。</p><ul><li><strong>AXI Transaction</strong>：the complete set of required operations on the AXI bus form the AXI Transaction.表示传输一段数据 (AXI burst) 所需的一整套操作；</li><li><strong>AXI Burst</strong>：any required payload data is transferred as an AXI Burst.表示 AXI 待传数据；</li><li><strong>AXI Beats</strong>：a burst can comprise multiple data transfers, or AXI Beats.表示 AXI burst 的组成，一个 Beat 就是一个 transfer。</li></ul><p>三者的关系：在 AXI 传输事务（Transaction）中，数据以突发传输（Burst）的形式组织。一次突发传输中可以包含一至多个数据（Transfer）。每个 transfer 因为使用一个周期，又被称为一拍数据（Beat）。</p><p>$$<br>\text{Transaction} = M <em>\text{Burst} ,M \geq 1 \<br>\text{Burst} = N</em> \text{Transfer( or Beat)} ,N \geq 1<br>$$</p><p>在地址通道中有三个信号控制进行控制，包括：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516151233.png"></p><p><strong>ARLEN(Burst Length)</strong></p><p>指一次突发传输中包含的数据传输 (transfer) 数量，在协议中使用 AxLen 信号控制。在 AXI4 中，INCR 类型最大支持长度为 256，其他类型最大长度为 16。而 AXI3 中这一数字无论何种模式均为 16。因此 AXI4 中 AxLen 信号位宽为 8bit，AXI3 中的 AxLen 则仅需要 4bit。</p><p><strong>ARSIZE(Burst Size)</strong></p><p>指传输中的数据位宽，具体地，是每周期传输数据的字节数量，在协议中使用 AXSIZE 信号控制。<strong>突发传输数据宽度不能超过数据总线本身的位宽</strong>。而当数据总线位宽大于突发传输宽度时，将根据协议的相关规定，将数据在部分数据线上传输。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516154710.png"></p><p><strong>ARBURST(Burst Type)</strong></p><p>Burst Type：AXI 协议中支持不同的 Burst 传输类型，主要分 FIXED、INCR、WRAP。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516144318.png"></p><ul><li><strong>FIXED 传输为地址固定传输</strong>，所有传输都会写在同一个地址中。主要应用在 FIFO 的传输中，因为 FIFO 为先入先出，只需要往同一个地址写数据即可。</li><li><strong>INCR 传输为地址递增传输</strong>，可根据具体的配置有固定长度递增和非定长递增。<strong>大部分的数据传输都是使用这种方式</strong>，尤其是在内存访问中，可以大大提高效率。</li><li><strong>WRAP 传输为地址回环传输</strong>，在一定长度后会回环到起始地址。主要应用在 Cache 操作中，因为 cache 是按照 cache line 进行操作，采用 wrap 传输可以方便的实现从内存中取回整个 cache line。</li></ul><p>AXI burst 读操作：<strong>master 只需要发送 burst 的起始地址</strong>，slave 会根据 burst 的起始地址与 burst 场地自动进行地址计算，将对应的数据与响应发送到 master 侧。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516143930.png"></p><p>AXI burst 写操作中，<strong>也只需要发送 burst 写的起始地址</strong>，slave 只需要接受起始地址，然后根据传输的长度将数据传输到对应的地址缓存中。只需要进行一次握手就可以实现地址通道的请求传输，避免系统总线的占用。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516144030.png"></p><h3 id="数据结构（Data-read-and-write-structure）"><a href="#数据结构（Data-read-and-write-structure）" class="headerlink" title="数据结构（Data read and write structure）"></a>数据结构（Data read and write structure）</h3><p>读写数据结构中声明了几种数据传输方式。</p><p>在介绍这些传输方式之前，需要了解<strong>WSTRB(Write strobes) 写选通信号</strong>。写选通信号 WSTRB 允许在写数据总线上进行 稀疏数据 传输。每个写选通信号对应写数据总线上的一个字节。当写选通断言时，表示写数据总线上对应的字节通道中包含将被更新到 memory 的有效信息。  </p><p>写数据总线上每 8 位具有一个写选通位，因此 WSTRB[n] 对应  WDATA[(8 x n) + 7 : (8 x n)]。默认情况下 WSTRB = 0xFFFF。也就是所有通路都是通的。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516162105.png"></p><h4 id="Narrow-Transfer"><a href="#Narrow-Transfer" class="headerlink" title="Narrow Transfer"></a>Narrow Transfer</h4><p>当本次传输中数据位宽小于通道本身的数据位宽时，称为<strong>窄位宽数据传输</strong>，或者直接翻译成<strong>窄传输</strong>。如下图，传输总线为 32bit，但是每次只传了 8 bit。</p><p>窄传输就是<strong>通过 STRB 信号指定有效传输数据的位宽来实现</strong>。针对一些特定的寄存器读写，或者在不同数据位宽的总线传输中会使用窄传输操作。如图，第一次传输时，WSTRB 信号为 0x01，WSTRB = b’001，表示 WDATA[7:0] 数据有效。</p><p>需要注意<strong>在多笔连续的窄传输操作中，STRB 会随着地址递增进行响应的变化</strong>，这样方便在系统设计使用中可以方便的将窄传输合并，从而提升系统传输效率。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516162805.png"></p><h4 id="Unaligned-Transfer"><a href="#Unaligned-Transfer" class="headerlink" title="Unaligned Transfer"></a>Unaligned Transfer</h4><p>AXI 协议规定单次 burst 传输中的数据，其地址不能跨越 4KB 边界。也就是在传输过程中会进行 4K 对齐。但是在某些时候，会期望在非对齐的地址开始一个突发，即非对齐传输。  </p><blockquote><p>协议中之所以规定一个 burst 不能跨越 4K 边界是为了避免一次 burst 访问两个 slave（每个 slave 的地址空间是 4K/1K 对齐的）。4K 对齐最大原因是系统中定义一个 page 大小是 4K，而所谓的 4K 边界是指低 12bit 为 0 的地址。</p></blockquote><p>非对齐传输是指<strong>有些传输指令不是按照 word 对齐，而是按照 Byte 对齐进行传输</strong>。起始地址可能是任意的地址。如下图中，起始地址为 0x1，则在系统上需要按照非对齐的方式进行传输。<strong>第一次传输采用 strb 信号指定对应的 Byte 有效，后面的传输可以按照正常的传输进行</strong>。</p><p>下图是一些传输示例，有阴影的格子表示当前字节不会被传输。</p><p>图一为正常的对齐传输，传输起始地址为 0x00。</p><p>图二为非对齐传输，起始地址为 0x01，第一个格子对应的 WSTRB = b’1110。</p><p>图三同上，只是 Burst length 为 5。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516171247.png"></p><p>图四也为非对齐传输，起始地址为 0x07。对应的 WSTRB = b’1000。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516171348.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AMBA</tag>
      
      <tag>AXI</tag>
      
      <tag>总线协议</tag>
      
      <tag>协议</tag>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言实现简单有限状态机</title>
    <link href="/2022/05/15/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <url>/2022/05/15/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>常说的状态机是有限状态机 FSM，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。<br>三个特征：</p><ul><li>状态总数（state）是有限的。</li><li>任一时刻，只处在一种状态之中。</li><li>某种条件下，会从一种状态转变（transition）到另一种状态。</li></ul><p>设计状态机的关键点：当前状态、外部输入、下一个状态。</p><h2 id="状态机分类"><a href="#状态机分类" class="headerlink" title="状态机分类"></a>状态机分类</h2><h3 id="Moore-型状态机"><a href="#Moore-型状态机" class="headerlink" title="Moore 型状态机"></a>Moore 型状态机</h3><p>Moore 型状态机特点是：输出只与当前状态有关（与输入信号无关）。相对简单，考虑状态机的下一个状态时只需要考虑它的当前状态就行了。</p><h3 id="Mealy-型状态机"><a href="#Mealy-型状态机" class="headerlink" title="Mealy 型状态机"></a>Mealy 型状态机</h3><p>Mealy 型状态机的特点是：输出不只和当前状态有关，还与输入信号有关。状态机接收到一个输入信号需要跳转到下一个状态时，状态机综合考虑 2 个条件（当前状态、输入值）后才决定跳转到哪个状态。</p><h2 id="实现一个简单的状态机"><a href="#实现一个简单的状态机" class="headerlink" title="实现一个简单的状态机"></a>实现一个简单的状态机</h2><p>代码参考<a href="https://github.com/AstarLight/FSM-framework">AstarLight/FSM-framework</a>。</p><p>以小明的一天设计出一个状态机，下图为状态转移图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205151353618.png"></p><p>首先，有限状态机的状态是有限的，我们可以定义一天中的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br> GET_UP,<br> GO_TO_SCHOOL,<br> HAVE_LUNCH,<br> DO_HOMEWORK,<br> SLEEP,<br>&#125;;<br></code></pre></td></tr></table></figure><p>状态机在没有事件的驱动下就是一潭死水，所以我们还需要定义出一些会发生的事件，去驱动状态机的运转：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br> EVENT1 = <span class="hljs-number">1</span>,<br> EVENT2,<br> EVENT3,<br>&#125;;<br></code></pre></td></tr></table></figure><p>再定义一些在某个状态下需要处理的动作，也就是函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetUp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming gets up!\n&quot;</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Go2School</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming goes to school!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HaveLunch</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming has lunch!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoHomework</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming does homework!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Go2Bed</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// do something</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming goes to bed!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个状态表结构，用来表示一个状态机的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FsmTable_s</span></span><br><span class="hljs-class">&#123;</span><br> <span class="hljs-keyword">int</span> event;              <span class="hljs-comment">//事件</span><br> <span class="hljs-keyword">int</span> CurState;           <span class="hljs-comment">//当前状态</span><br> <span class="hljs-keyword">void</span> (*eventActFun)();  <span class="hljs-comment">//函数指针</span><br> <span class="hljs-keyword">int</span> NextState;          <span class="hljs-comment">//下一个状态</span><br>&#125;FsmTable_t;<br></code></pre></td></tr></table></figure><p>接下来，我们就可以这个结构定义一个状态表，状态机根据这个表进行状态的流转：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">FsmTable_t XiaoMingTable[] =<br>&#123;<br> <span class="hljs-comment">//&#123;到来的事件，当前的状态，将要要执行的函数，下一个状态&#125;</span><br> &#123; EVENT1,  SLEEP,           GetUp,        GET_UP &#125;,<br> &#123; EVENT2,  GET_UP,          Go2School,    GO_TO_SCHOOL &#125;,<br> &#123; EVENT3,  GO_TO_SCHOOL,    HaveLunch,    HAVE_LUNCH &#125;,<br> &#123; EVENT1,  HAVE_LUNCH,      DoHomework,   DO_HOMEWORK &#125;,<br> &#123; EVENT2,  DO_HOMEWORK,     Go2Bed,       SLEEP &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>定义一个状态机结构，表示一个状态机：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FSM_s</span></span><br><span class="hljs-class">&#123;</span><br> FsmTable_t* FsmTable;   <span class="hljs-comment">//指向的状态表</span><br> <span class="hljs-keyword">int</span> curState;           <span class="hljs-comment">//FSM当前所处的状态</span><br><br>&#125;FSM_t;<br></code></pre></td></tr></table></figure><p>有了这些基本的结构，就可以写主函数了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> FSM_t fsm;                        <span class="hljs-comment">// 实例化一个状态机</span><br> InitFsm(&amp;fsm);                    <span class="hljs-comment">// 初始化状态机</span><br> <span class="hljs-keyword">int</span> event = EVENT1;               <span class="hljs-comment">// 初始化事件，为了启动状态机流转，</span><br>                                      <span class="hljs-comment">// 因为状态机只有在有时间发生时才会改变状态</span><br><br> <span class="hljs-comment">//小明的一天,周而复始的一天又一天，进行着相同的活动</span><br> <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event %d is coming...\n&quot;</span>, event);<br>  FSM_EventHandle(&amp;fsm, event); <span class="hljs-comment">// 有了初始事件，我们就需要处理这个事件，</span><br>                                      <span class="hljs-comment">// 再写一个处理事件的函数</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fsm current state %d\n&quot;</span>, fsm.curState);<br>  test(&amp;event); <br>  Sleep(<span class="hljs-number">1</span>);                     <span class="hljs-comment">//休眠1秒，方便观察</span><br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 测试用的，模拟事件的发生</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *event)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (*event == <span class="hljs-number">3</span>)<br> &#123;<br>  *event = <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">else</span><br> &#123;<br>  (*event)++;<br> &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>编写初始化状态机的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">int</span> g_state_max_num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 状态机的状态最大数量，根据状态表的大小来计算</span><br><span class="hljs-comment">// 初始化FSM</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitFsm</span><span class="hljs-params">(FSM_t* pFsm)</span></span><br><span class="hljs-function"></span>&#123;<br> g_state_max_num = <span class="hljs-keyword">sizeof</span>(XiaoMingTable) / <span class="hljs-keyword">sizeof</span>(FsmTable_t);<br> pFsm-&gt;curState = SLEEP; <span class="hljs-comment">// 初始状态为睡觉</span><br>    pFsm-&gt;FsmTable = XiaoMingTable;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写事件处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 事件处理 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSM_EventHandle</span><span class="hljs-params">(FSM_t* pFsm, <span class="hljs-keyword">int</span> event)</span></span><br><span class="hljs-function"></span>&#123;<br> FsmTable_t* pActTable = pFsm-&gt;FsmTable;<br> <span class="hljs-keyword">void</span> (*eventActFun)() = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//函数指针初始化为空</span><br> <span class="hljs-keyword">int</span> NextState;<br> <span class="hljs-keyword">int</span> CurState = pFsm-&gt;curState;<br><br> <span class="hljs-comment">/* 获取当前动作函数 */</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;g_max_num; i++)<br> &#123;<br>  <span class="hljs-comment">//当且仅当当前状态下来个指定的事件，我才执行它</span><br>  <span class="hljs-keyword">if</span> (event == pActTable[i].event &amp;&amp; CurState == pActTable[i].CurState)<br>  &#123;<br>   pActTable[i].eventActFun();                      <span class="hljs-comment">// 执行动作函数</span><br>            FSM_StateTransfer(pFsm, pActTable[i].NextState); <span class="hljs-comment">// 执行状态转移</span><br>   <span class="hljs-keyword">break</span>;<br>  &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 状态迁移 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSM_StateTransfer</span><span class="hljs-params">(FSM_t* pFsm, <span class="hljs-keyword">int</span> state)</span></span><br><span class="hljs-function"></span>&#123;<br> pFsm-&gt;curState = state;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/skyfsm/p/7071386.html">Linux 编程之有限状态机 FSM 的理解与实现 - Madcola - 博客园</a><br><a href="http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html">JavaScript 与有限状态机 - 阮一峰的网络日志</a><br><a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">有限状态机 - 维基百科，自由的百科全书</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>FSM</tag>
      
      <tag>有限状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接脚本入门</title>
    <link href="/2022/05/08/%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/08/%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>位置无关编码 (PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。</p><p>位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。</p><p>我们在设计一个程序时，会给这个程序指定一个运行地址（链接地址）。就是说我们在编译程序时其实心里是知道我们程序将来被运行时的地址（运行地址）的，而且必须给编译器链接器指定这个地址（链接地址）才行。</p><p>最后得到的二进制程序理论上是和你指定的运行地址有关的，将来这个程序被执行时必须放在当时编译链接时给定的那个地址（链接地址）下才行，否则不能运行（就叫位置有关代码）。但是有个别特别的指令他可以跟指定的地址（链接地址）没有关系，也就是说这些代码实际运行时不管放在哪里都能正常运行。</p><p><strong>运行地址</strong>：由运行时决定的（编译链接时是无法绝对确定运行时地址的）。</p><p><strong>链接地址</strong>：由程序员在编译链接的过程中，通过<code>Makefile</code>中<code>-Ttext xxx</code>或者<strong>在链接脚本中指定</strong>的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。</p><p>举例：Linux 中的应用程序。<code>gcc hello.c -o hello</code>，这时使用默认的链接地址就是<code>0x0</code>，所以应用程序都是链接在<code>0x0</code>地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享 4G 的虚拟地址空间。所以应用程序都可以链接到 0 地址，因为每个进程都是从 0 地址开始的。（编译时可以不给定链接地址而都使用<code>0x0</code>）</p><h2 id="编译链接过程"><a href="#编译链接过程" class="headerlink" title="编译链接过程"></a>编译链接过程</h2><h3 id="每个过程的作用"><a href="#每个过程的作用" class="headerlink" title="每个过程的作用"></a>每个过程的作用</h3><ul><li>预编译：预编译器执行。替换宏定义，删除注释等工作。</li><li>编译：编译器来执行。把源码<code>.c .S</code>编程机器码<code>.o</code>文件。</li><li>链接：链接器来执行。把<code>.o</code>文件中的各函数（段）按照一定规则（链接脚本来指定）累积在一起，形成可执行文件。</li><li>strip：strip 是把可执行程序中的符号信息给拿掉，以节省空间。（Debug 版本和 Release 版本）</li><li>objcopy：由可执行程序生成可烧录的镜像<code>bin</code>文件。</li></ul><h3 id="编译后生成的段"><a href="#编译后生成的段" class="headerlink" title="编译后生成的段"></a>编译后生成的段</h3><p>段就是程序的一部分，我们把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段放在合适的位置。</p><p>段名分为 2 种：一种是编译器链接器内部定好的，一种是程序员自己指定的、自定义的段名。<br>已有段名：</p><ul><li>代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西</li><li>数据段：（.data），数据段就是 C 语言中有显式初始化为非 0 的全局变量</li><li>bss 段：（.bss），又叫 ZI（zero initial）段，就是零初始化段，对应 C 语言中初始化为 0 的全局变量。</li><li>自定义段名：段名由程序员自己定义，段的属性和特征也由程序员自己定义。</li></ul><blockquote><p>C 语言中全局变量如果未显式初始化，值是 0。本质就是 C 语言把这类全局变量放在了 bss 段，从而保证了为 0。<br>C 运行时环境如何保证显式初始化为非 0 的全局变量的值在 main 之前就被赋值了？就是因为它把这类变量放在了.data 段中，而.data 段会在 main 执行之前被处理（初始化）。</p></blockquote><h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><h3 id="链接脚本做什么事？"><a href="#链接脚本做什么事？" class="headerlink" title="链接脚本做什么事？"></a>链接脚本做什么事？</h3><p>链接脚本其实是个规则文件，他是程序员用来指挥链接器工作的。链接器会参考链接脚本，并且使用其中规定的规则来处理<code>.o</code>文件中那些段，将其链接成一个可执行程序。</p><p>链接脚本的关键内容有 2 部分：段名 + 地址（作为链接地址的内存地址）。把段，放到一个地址的意思。</p><p>链接脚本就像是一个从上到下顺序执行的一个代码</p><ul><li><code>.</code> 表示当前位置</li><li><code>=</code> 表示赋值</li><li><code>*</code> 表示通配符</li></ul><p>链接脚本里的符号，可以在汇编源码里引用。</p><p>一个简易示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lds">SECTIONS<br>&#123;<br>    . = 0xd0024000; # 当前地址为0xd0024000<br>    <br>    .text : &#123;<br>        start.o<br>        * (.text)   # 所有的text段<br>    &#125;<br>            <br>    .data : &#123;<br>        * (.data)<br>    &#125;<br>    <br>    bss_start = .;  # bss_start的值为当前地址，是执行到这里的地址，不是最上面. = 0xd0024000的地址<br>    .bss : &#123;<br>        * (.bss)<br>    &#125;<br>    <br>    bss_end  = .;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h3><p><strong>任务：在 SRAM 中将代码从 0xd0020010 重定位到 0xd0024000</strong>。</p><p>第一点：通过链接脚本将代码链接到 0xd0024000<br>    重定位代码的作用就是：在PIC执行完之前（在代码中第一句位置有关码执行之前）必须将整个代码搬移到0xd0024000位置去执行，这就是重定位。</p><p>第二点：dnw 下载时将 bin 文件下载到 0xd0020010<br>    这样就能完成，下载代码与运行代码位置不同。</p><p>第三点：代码执行时通过代码前段的少量位置无关码将整个代码搬移到 0xd0024000。</p><p>第四点：使用一个长跳转跳转到 0xd0024000 处的代码继续执行，重定位完成。</p><p><strong>长跳转</strong>：一种跳转指令，类似于分支指令 B，BL 等作用的指令，跳转指令通过给 PC（r15）赋一个新值来完成代码跳转。当我们执行完重定位后，<strong>实际上 SRAM 中有两份代码的镜像</strong>（一份是我们下载到 0xd0020010 处的，一份是重定位到 0xd0024000 处的），这两份代码内容完全相同。</p><p><strong>短跳转</strong>：短跳转指令可以实现向前或向后 32MB 的地址空间跳转。</p><p>当链接地址和运行地址相同是，短跳转和长跳转实际效果一样。但是当链接地址和运行地址不同时，短跳转和长跳转就有差异了，这时候段跳转执行的是运行地址处的那一份，而长跳转执行的是链接地址的那一份。</p><p>重定位实际就是在运行地址处执行一段位置无关码 PIC，让这段 PIC（也就是重定位代码）从运行地址处把整个程序镜像拷贝一份到链接地址处，完了之后使用一句长跳转指令从运行地址处直接跳转到链接地址处去执行同一个函数（led_blink），这样就实现了重定位之后的无缝连接。</p><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs lds">/*<br> * 文件名：    led.s    <br> * 作者：    朱老师（朱友鹏）<br> * 描述：    演示重定位（在SRAM内部重定位）<br> */<br><br>#define WTCON        0xE2700000<br><br>#define SVC_STACK    0xd0037d80<br><br>.global _start                    // 把_start链接属性改为外部，这样其他文件就可以看见_start了<br>_start:<br>    // 第1步：关看门狗（向WTCON的bit5写入0即可）<br>    ldr r0, =WTCON<br>    ldr r1, =0x0<br>    str r1, [r0]<br>    <br>    // 第2步：设置SVC栈<br>    ldr sp, =SVC_STACK<br>    <br>    // 第3步：开/关icache<br>    mrc p15,0,r0,c1,c0,0;            // 读出cp15的c1到r0中<br>    //bic r0, r0, #(1&lt;&lt;12)            // bit12 置0  关icache<br>    orr r0, r0, #(1&lt;&lt;12)            // bit12 置1  开icache<br>    mcr p15,0,r0,c1,c0,0;<br>    <br>    // 第4步：重定位<br>    adr r0, _start          // adr加载时就叫短加载，此处adr指令用于加载_start当前运行地址，详解见正文    <br>    ldr r1, =_start         // ldr加载时如果目标寄存器是pc就叫长跳转，如果目标寄存器是r1等就叫长加载    <br>                            // 此处ldr指令用于加载_start的链接地址:0xd0024000<br><br>    // bss段的起始地址<br>    ldr r2, =bss_start    // 就是我们重定位代码的结束地址，重定位只需重定位代码段和数据段即可<br>                        // 该符号在链接脚本里定义<br>    cmp r0, r1            // 比较_start的运行时地址和链接地址是否相等<br>    beq clean_bss        // 如果相等说明不需要重定位，所以跳过copy_loop，直接到clean_bss<br>                        // 如果不相等说明需要重定位，那么会顺序执行下面的copy_loop进行重定位<br>                        // 重定位完成后继续执行clean_bss。<br><br>// 用汇编来实现的一个while循环<br>copy_loop:<br>    ldr r3, [r0], #4    // 源   r0内容写入r3，然后r0自增4<br>    str r3, [r1], #4    // 目的 r3内容写入r1，然后r1自增4<br>                        // 这两句代码就完成了4个字节内容的拷贝<br>    cmp r1, r2            // r1和r2都是用ldr加载的，都是链接地址，所以r1不断+4总能等于r2<br>    bne copy_loop<br><br>// 清bss段，其实就是在链接地址处把bss段全部清零<br>clean_bss:<br>    ldr r0, =bss_start                    <br>    ldr r1, =bss_end<br>    cmp r0, r1                // 如果r0等于r1，说明bss段为空，直接继续执行下面的代码<br>    beq run_on_dram            // 清除bss完之后的地址<br>    mov r2, #0<br><br>clear_loop:<br>    str r2, [r0], #4        // 先将r2中的值放入r0所指向的内存地址（r0中的值作为内存地址），<br>    cmp r0, r1                // 然后r0 = r0 + 4<br>    bne clear_loop<br><br>//    清理完bss段后重定位就结束了。然后当前的状况是：<br>//    1、当前运行地址还在0xd0020010开头的（重定位前的）那一份代码中运行着。<br>//    2、此时SRAM中已经有了2份代码，1份在d0020010开头，另一份在d0024000开头的位置。<br>//    然后就要长跳转了。<br><br>run_on_dram:    <br>    // 长跳转到led_blink开始第二阶段<br>    ldr pc, =led_blink                // ldr指令实现长跳转，把led_blink的值，写入pc寄存器<br>    <br>    // 从这里之后就可以开始调用C程序了<br>    //bl led_blink                    // bl指令实现短跳转<br>    <br>    // 汇编最后的这个死循环不能丢<br>    b .<br>    <br></code></pre></td></tr></table></figure><p><code>adr</code>与 ldr 伪指令的区别：<code>ldr</code>和<code>adr</code>都是伪指令</p><ul><li><code>adr</code>短加载，指令加载符号地址，加载的是运行时地址；</li><li><code>ldr</code>长加载，指令在加载符号地址时，加载的是链接地址；</li></ul><p>重定位就是汇编代码中的<code>copy_loop</code>函数，代码的作用是使用循环结构来逐句复制代码到链接地址。<br>复制的源地址是 SRAM 的<code>0xd0020010</code>，复制目标地址是 SRAM 的<code>0xd0024000</code>，复制长度是<code>bss_start</code>减去<code>_start</code>，所以复制的长度就是整个重定位需要重定位的长度，也就是整个程序中代码段 + 数据段的长度。<code>bss</code>段（bss 段中就是 0 初始化的全局变量）不需要重定位。</p><p>清除<code>bss</code>段是为了满足 C 语言的运行时要求（C 语言要求显式初始化为 0 的全局变量，或者未显式初始化的全局变量的值为 0，实际上 C 语言编译器就是通过清<code>bss</code>段来实现 C 语言的这个特性的）。一般情况下我们的程序是不需要负责清零<code>bss</code>段的（C 语言编译器和链接器会帮我们的程序自动添加一段头程序，这段程序会在我们的 main 函数之前运行，这段代码就负责清除<code>bss</code>）。但是在我们代码重定位了之后，因为编译器帮我们附加的代码只是帮我们清除了运行地址那一份代码中的<code>bss</code>，而未清除重定位地址处开头的那一份代码的<code>bss</code>，所以重定位之后需要自己去清除<code>bss</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>链接</tag>
      
      <tag>编译</tag>
      
      <tag>动态链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-存储与 IO 系统</title>
    <link href="/2022/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E4%B8%8EIO%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E4%B8%8EIO%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><h4 id="SRAM（Static-Random-Access-Memory，静态随机存取存储器）"><a href="#SRAM（Static-Random-Access-Memory，静态随机存取存储器）" class="headerlink" title="SRAM（Static Random-Access Memory，静态随机存取存储器）"></a>SRAM（Static Random-Access Memory，静态随机存取存储器）</h4><p>CPU 如果形容成人的大脑的话，那么 CPU Cache (高速缓存) 就好比人的记忆。它用的是 SRAM 芯片。</p><p>SRAM 的“静态”的意思是，只要处于通电状态，里面的数据就保持存在，一旦断电，数据就会丢失。SRAM 里 1bit 数据需要 6-8 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间，能够存的数据有限。因为其电路简单，访问速度非常快。</p><p>在 CPU 里，通常会有 L1、L2、L3 这样三层高速缓存。每个 CPU 核心都有一块属于自己的 L1 高速缓存，通常分成指令缓存和数据缓存，分开存放 CPU 使用的指令和数据。</p><p>L2 的 Cache 同样是每个 CPU 核心都有的，不过它往往不在 CPU 核心的内部。所以，L2 Cache 的访问速度会比 L1 稍微慢一些。而 L3Cache，则通常是多个 CPU 核心共用的，尺寸会更大一些，访问速度自然也就更慢一些。</p><p>你可以把 CPU 中的 L1Cache 理解为我们的短期记忆，把 L2/L3Cache 理解成长期记忆，把内存当成我们拥有的书架或者书桌。当我们自己记忆中没有资料的时候，可以从书桌或者书架上拿书来翻阅。这个过程中就相当于，数据从内存中加载到 CPU 的寄存器和 Cache 中，然后通过“大脑”，也就是 CPU，进行处理和运算。</p><h4 id="DRAM（Dynamic-Random-Access-Memory，动态随机存取存储器）"><a href="#DRAM（Dynamic-Random-Access-Memory，动态随机存取存储器）" class="headerlink" title="DRAM（Dynamic Random Access Memory，动态随机存取存储器）"></a>DRAM（Dynamic Random Access Memory，动态随机存取存储器）</h4><p>内存用的芯片和 Cache 有所不同，它用的是一种叫作 DRAM 的芯片，比起 SRAM 来说，它的密度更高，有更大的容量，而且它也比 SRAM 芯片便宜不少。</p><p>DRAM 被称为“动态”存储器，是因为 DRAM 需要靠不断地“刷新”，才能保持数据被存储起来。DRAM 的一个比特，只需要一个晶体管和一个电容就能存储。所以，DRAM 在同样的物理空间下，能够存储的数据也就更多，也就是存储的“密度”更大。但是，因为数据是存储在电容里的，电容会不断漏电，所以需要定时刷新充电，才能保持数据不丢失。DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问延时也就更长。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081652018.png"></p><p>从 Cache、内存，到 SSD 和 HDD 硬盘，一台现代计算机中，就用上了所有这些存储器设备。其中，容量越小的设备速度越快，而且，CPU 并不是直接和每一种存储器设备打交道，而是每一种存储器设备，只和它相邻的存储设备打交道。比如，CPUCache 是从内存里加载而来的，或者需要写回内存，并不会直接写回数据到硬盘，也不会直接从硬盘加载数据到 CPUCache 中，而是先加载到内存，再从内存加载到 Cache 中。</p><p>这样，各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降，也就构成了我们日常所说的存储器层次结构。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="CPU-cache"><a href="#CPU-cache" class="headerlink" title="CPU cache"></a>CPU cache</h3><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>缓存不是 CPU 的专属功能，可以把它当成一种策略，任何时候想要增加数据传输性能，都可以通过加一层缓存试试。</p><p>存储器层次结构的中心思想是，对于每个$k$，位于$k$层的更快更小的存储设备作为位于$k+1$层的更大更慢的存储设备的缓存。<a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86">下图</a>展示了存储器层次结构中缓存的一般性概念。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711145943.png"></p><div id="存储器层次结构中基本的缓存原理"></div><p>数据总是以块<code>block</code>为单位，在层与层之间来回复制。</p><p>说回高速缓存，按照摩尔定律，CPU 的访问速度每 18 个月便会翻一翻，相当于每年增长 60%。内存的访问速度虽然不断增长，却远没有那么快，每年只增长 7% 左右。这样就导致 CPU 性能和内存访问的差距不断拉大。为了弥补两者之间差异，现代 CPU 引入了<strong>高速缓存</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220708092012.png"></p><p>CPU 的读（load）实质上就是从缓存中读取数据到寄存器（register）里，在多级缓存的架构中，如果缓存中找不到数据（Cache miss），就会层层读取二级缓存三级缓存，一旦所有的缓存里都找不到对应的数据，就要去内存里寻址了。寻址到的数据首先放到寄存器里，其副本会驻留到 CPU 的缓存中。</p><p>CPU 的写（store）也是针对缓存作写入。并不会直接和内存打交道，而是通过某种机制实现数据从缓存到内存的写回（write back）。</p><p>缓存到底如何与 CPU 和主存数据交换的？CPU 如何从缓存中读写数据的？缓存中没有读的数据，或者缓存写满了怎么办？我们先从 CPU 如何读取数据说起。</p><h4 id="缓存读取"><a href="#缓存读取" class="headerlink" title="缓存读取"></a>缓存读取</h4><p>CPU 发起一个读取请求后，返回的结果会有如下几种情况：</p><ul><li>缓存命中 (cache hit)<br>要读取的数据刚好在缓存中，叫做<strong>缓存命中</strong>。</li><li>缓存不命中 (cache miss)<br>发送缓存不命中，缓存就得执行一直<strong>放置策略</strong>(placement policy)，比如 LRU。来决定从主存中取出的数据放到哪里。<ul><li><strong>强制性不命中</strong>(compulsory miss)/冷不命中(cold miss)：缓存中没有要读取的数据，需要从主存读取数据，并将数据放入缓存。</li><li><strong>冲突不命中</strong>(conflict miss)：缓存中有要读的数据，在采取放置策略时，从主存中取数据放到缓存时发生了冲突，这叫做冲突不命中。</li></ul></li></ul><h4 id="高速缓存存储器组织结构"><a href="#高速缓存存储器组织结构" class="headerlink" title="高速缓存存储器组织结构"></a>高速缓存存储器组织结构</h4><p>整个 Cache 被划分为 1 个或多个<strong>组</strong> (Set)，$S$ 表示组的个数。每个组包含 1 个或多个<strong>缓存行</strong>(Cache line)，$E$ 表示一个组中缓存行的行数。每个缓存行由三部分组成：<strong>有效位</strong>(valid)，<strong>标记位</strong>（tag），<strong>数据块</strong>（cache block）。</p><ul><li>有效位：该位等于 1，表示这个行数据有效。</li><li>标记位：唯一的标识了存储在高速缓存中的块，标识目标数据是否存在当前的缓存行中。</li><li>数据块：一部分内存数据的副本。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711171136.png"></p><p>Cache 的结构可以由元组$(S,E,B,m)$表示。不包括有效位和标记位。Cache 的大小为 $C=S \times E \times B$.</p><p>接下来看看 Cache 是如何工作的，当 CPU 执行数据加载指令，从内存地址 A 读取数据时，根据存储器层次原理，如果 Cache 中保存着目标数据的副本，那么就立即将数据返回给 CPU。那么 Cache 如何知道自己保存了目标数据的副本呢？</p><p>假设目标地址的数据长度为$m$位，这个地址被参数 $S$ 和 $B$ 分成了三个字段：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711174416.png"></p><p>首先通过长度为$s$的<strong>组索引</strong>，确定目标数据保存在哪一个组 (Set) 中，其次通过长度为$t$的<strong>标记</strong>，确定在哪一行，需要注意的是此时有效位必须等于 1，最后根据长度为$b$的<strong>块偏移</strong>，来确定目标数据在数据块中的确切位置。</p><blockquote><p>Q：既然读取 Cache 第一步是组选择，为什么不用高位作为组索引，而使用中间的为作为组索引？<br>A：如果使用了高位作索引，那么一些连续的内存块就会映射到相同的高速缓存块。如图前四个块映射到第一个缓存组，第二个四个块映射到第二个组，依次类推。如果一个程序有良好的空间局部性，顺序扫描一个数组的元素，那么在任何时候，缓存中都只保存在一个块大小的数组内容。这样对缓存的使用率很低。相比而言，如果使用中间的位作为组索引，那么相邻的块总是映射到不同的组，图中的情况能够存放整个大小的数组片。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711185819.png"></p></blockquote><h5 id="直接映射高速缓存-Direct-Mapped-Cache"><a href="#直接映射高速缓存-Direct-Mapped-Cache" class="headerlink" title="直接映射高速缓存 Direct Mapped Cache"></a>直接映射高速缓存 Direct Mapped Cache</h5><p>根据每个组的缓存行数 $E$ 的不同，Cache 被分为不同的类。每个组只有一行$E=1$的高速缓存被称为<strong>直接映射高速缓存</strong>(direct-mapped cache)。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711190845.png"></p><p>当一条加载指令指示 CPU 从主存地址 A 中读取一个字 w 时，会将该主存地址 A 发送到高速缓存中，则高速缓存会根据<strong>组选择</strong>，<strong>行匹配</strong>和<strong>字抽取</strong>三步来判断地址 A 是否命中。</p><p><strong>组选择</strong>(set selection)：根据组索引值来确定属于哪一个组，如图中索引长度为 5 位，可以检索 32 个组 ($2^5=32$)。当$s=0$时，此时组选择的结果为<code>set 0</code>，当$s=1$时，此时组选择的结果为<code>set 1</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711191708.png"></p><p>**行匹配 (line match)**：首先看缓存行的有效位，此时有效位为 1，表示当前数据有效。然后对比缓存行的标记<code>0110</code>与地址中的标记<code>0110</code>是否相等，如果相等，则表示目标数据在当前的缓存行中（缓存命中）。如果不一致或者有效位为 0，则表示目标数据不在当前的缓存行中（缓存不命中）。如果命中，就可以进行下一步字抽取。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711192435.png"></p><p>**字抽取 (word extraction)**：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于<code>100</code>时，表示目标数据起始地址位于字节 4 处。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711192757.png"></p><p>下面通过一个例子来解释清除这个过程。假设我们有一个直接映射高速缓存，描述为$(S,E,B,m) = (4,1,2,4)$。换句话说，高速缓存有 4 个组，每个组 1 行，每个数据块 2 个字节，地址长度为 4 位。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711194256.png"></p><p>从图中可以看出，8 个内存块，但只有 4 个高速缓存组，所以会有多个块映射到同一个高速缓存组中。例如，块 0 和块 4 都会被映射到组 0。</p><p>下面我们来模拟当 CPU 执行一系列读的时候，高速缓存的执行情况，我们假设每次 CPU 读 1 个字节的字。</p><p><strong>读地址 0(0000) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711193901.gif"></p><p><strong>读地址 1(0001) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711194838.gif"></p><p><strong>读地址 13(1101) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711195108.gif"></p><p><strong>读地址 8(1000) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711200054.gif"></p><p><strong>读地址 0(0000) 的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711200409.gif"></p><h5 id="组相联高速缓存-Set-Associative-Cache"><a href="#组相联高速缓存-Set-Associative-Cache" class="headerlink" title="组相联高速缓存 Set Associative Cache"></a>组相联高速缓存 Set Associative Cache</h5><p>由于直接映射高速缓存的组中只有一行，所以容易发生冲突不命中。组相联高速缓存 (Set associative cache) 运行有多行缓存行。但是缓存行最大不能超过 $C/B$。</p><p>如图一个组中包含了两行缓存行，这种我们称为 2 路相联高速缓存。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220712160513.png"></p><p><strong>组选择</strong>：与直接映射高速缓存的组选择过程一样。</p><p><strong>行匹配</strong>：因为一个组有多行，所以需要遍历所有行，找到一个有效位为 1，并且标记为与地址中的标记位相匹配的一行。如果找到了，表示缓存命中。</p><p><strong>字抽取</strong>：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于<code>100</code>时，表示目标数据起始地址位于字节 4 处。</p><p>如果不命中，那么就需要从主存中取出需要的数据块，但是将数据块放在哪一行缓存行呢？如果存在空行 ($valid=0$)，那就放到空行里。如果没有空行，就得选择一个非空行来替换，同时希望 CPU 不会很快引用这个被替换的行。这里介绍几个替换策略。</p><p>最简单的方式就是随机选择一行来替换，其他复杂的方式就是利用局部性原理，使得接下来 CPU 引用替换的行概率最小。如</p><h3 id="缓存一致性协议-MESI"><a href="#缓存一致性协议-MESI" class="headerlink" title="缓存一致性协议 MESI"></a>缓存一致性协议 MESI</h3><h4 id="为什么需要缓存一致"><a href="#为什么需要缓存一致" class="headerlink" title="为什么需要缓存一致"></a>为什么需要缓存一致</h4><p>目前主流电脑的 CPU 都是多核心的，多核心的有点就是在不能提升 CPU 主频后，通过增加核心来提升 CPU 吞吐量。每个核心都有自己的 L1 Cache 和 L2 Cache，只是共用 L3 Cache 和主内存。每个核心操作是独立的，每个核心的 Cache 就不是同步更新的，这样就会带来缓存一致性（Cache Coherence）的问题。</p><p>举个例子，如图：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205291536919.gif"></p><p>有 2 个 CPU，主内存里有个变量<code>x=0</code>。CPU A 中有个需要将变量<code>x</code>加<code>1</code>。CPU A 就将变量<code>x</code>加载到自己的缓存中，然后将变量<code>x</code>加<code>1</code>。因为此时 CPU A 还未将缓存数据写回主内存，CPU B 再读取变量<code>x</code>时，变量<code>x</code>的值依然是<code>0</code>。</p><p>这里的问题就是所谓的缓存一致性问题，因为 CPU A 的缓存与 CPU B 的缓存是不一致的。</p><h4 id="如何解决缓存一致性问题"><a href="#如何解决缓存一致性问题" class="headerlink" title="如何解决缓存一致性问题"></a>如何解决缓存一致性问题</h4><h5 id="通过在总线加-LOCK-锁的方式"><a href="#通过在总线加-LOCK-锁的方式" class="headerlink" title="通过在总线加 LOCK 锁的方式"></a>通过在总线加 LOCK 锁的方式</h5><p>在锁住总线上加一个 LOCK 标识，CPU A 进行读写操作时，锁住总线，其他 CPU 此时无法进行内存读写操作，只有等解锁了才能进行操作。</p><p>该方式因为锁住了整个总线，所以效率低。</p><h5 id="缓存一致性协议-MESI-1"><a href="#缓存一致性协议-MESI-1" class="headerlink" title="缓存一致性协议 MESI"></a>缓存一致性协议 MESI</h5><p>该方式对单个缓存行的数据进行加锁，不会影响到内存其他数据的读写。</p><p>在学习 MESI 协议之前，简单了解一下总线嗅探机制（Bus Snooping）。要对自己的缓存加锁，需要通知其他 CPU，多个 CPU 核心之间的数据传播问题。最常见的一种解决方案就是总线嗅探。</p><p>这个策略，本质上就是把所有的读写请求都通过总线广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。MESI 就是基于总线嗅探机制的缓存一致性协议。</p><p>MESI 协议的由来是对 Cache Line 的四个不同的标记，分别是：</p><table><thead><tr><th align="center"><div style="width:50px">状态</div></th><th align="center"><div style="width:100px">状态</div></th><th><div style="width:200px">描述</div></th><th><div style="width:200px">监听任务</div></th></tr></thead><tbody><tr><td align="center">Modified</td><td align="center">已修改</td><td>该 Cache Line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中</td><td>Cache Line 必须时刻监听所有试图读该 Cache Line 相对于主存的操作，这种操作必须在缓存将该 Cache Line 写回主存并将状态改为 S 状态之前，被延迟执行</td></tr><tr><td align="center">Exclusive</td><td align="center">独享，互斥</td><td>该 Cache Line 有效，数据和内存中的数据一直，数据只存在于本 Cache</td><td>Cache Line 必须监听其他缓存读主存中该 Cache Line 的操作，一旦有这种操作，该 Cache Line 需要改为 S 状态</td></tr><tr><td align="center">Shared</td><td align="center">共享的</td><td>该 Cache Line 有效，数据和内存中的数据一直，数据存在于很多个 Cache 中</td><td>Cache Line 必须监听其他  Cache Line 使该 Cache Line 无效或者独享该 Cache Line 的请求，并将 Cache Line 改为 I 状态</td></tr><tr><td align="center">Invalid</td><td align="center">无效的</td><td>该 Cache Line 无效</td><td>无</td></tr></tbody></table><p>整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把各个状态之间的流转用表格总结了一下：</p><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:300px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">M</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">M</td></tr><tr><td align="center">M</td><td align="center">Local Write</td><td>修改 cache 数据，状态不变</td><td align="center">M</td></tr><tr><td align="center">M</td><td align="center">Remote Read</td><td>这行数据被写到内存中，使其他核能使用到最新数据，状态变为 S</td><td align="center">S</td></tr><tr><td align="center">M</td><td align="center">Remote Write</td><td>这行数据被写入内存中，其他核可以获取到最新数据，由于其他 CPU 修改该条数据，则本地 Cache 变为 I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">E</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">E</td></tr><tr><td align="center">E</td><td align="center">Local Write</td><td>修改数据，状态改为 M</td><td align="center">M</td></tr><tr><td align="center">E</td><td align="center">Remote Read</td><td>数据和其他 CPU 共享，变为 S</td><td align="center">S</td></tr><tr><td align="center">E</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为 I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,text-align: center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">S</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">S</td></tr><tr><td align="center">S</td><td align="center">Local Write</td><td>修改数据，状态改为 M，其他 CPU 的 Cache Line 状态改为 I</td><td align="center">M</td></tr><tr><td align="center">S</td><td align="center">Remote Read</td><td>数据和其他 CPU 共享，状态不变</td><td align="center">S</td></tr><tr><td align="center">S</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为 I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">I</td><td align="center">Local Read</td><td>1. 如果其他 CPU 没有这份数据，直接从内存中加载数据，状态变为 E；<br> 2. 如果其他 CPU 有这个数据，且 Cache Line 状态为 M，则先把 Cache Line 中的内容写回到主存。本地 Cache 再从内存中读取数据，这时两个 Cache Line 的状态都变为 S；<br>3. 如果其他 Cache Line 有这份数据，并且状态为 S 或者 E，则本地 Cache Line 从主存读取数据，并将这些 Cache Line 状态改为 S</td><td align="center">E 或者 S</td></tr><tr><td align="center">I</td><td align="center">Local Write</td><td>1. 先从内存中读取数据，如果其他 Cache Line 中有这份数据，且状态为 M，则现将数据更新到主存再读取，将 Cache Line 状态改为 M；<br> 2. 如果其他 Cache Line 有这份数据，且状态为 E 或者 S，则其他 Cache Line 状态改为 I</td><td align="center">M</td></tr><tr><td align="center">I</td><td align="center">Remote Read</td><td>数据和其他 CPU 共享，状态不变</td><td align="center">S</td></tr><tr><td align="center">I</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为 I</td><td align="center">I</td></tr></tbody></table><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>计算机有五大组成部分，分别是：运算器、控制器、存储器、输入设备和输出设备。而内存就是其中的存储器。我们的数据和指令都需要先放到内存中，然后再被 CPU 执行。</p><p>操作系统中程序并不能直接访问物理内存，我们的内存需要被分成固定大小的页（Page），然后再通过<strong>虚拟内存地址（Virtual Address）到物理内存地址（Physical Address）的地址转换（Address Translation）</strong>，才能到达实际存放数据的物理内存位置。而我们的程序看到的内存地址，都是虚拟内存地址。那么如何进行转换的呢？</p><h3 id="简单页表"><a href="#简单页表" class="headerlink" title="简单页表"></a>简单页表</h3><p>最简单的方式，就是建立一张虚拟内存到物理内存的映射表，在计算机里叫做页表（Page Table）。页表这个地址转换的办法，会把一个内存地址分成页号（Directory）和偏移量（Offset）两个部分，是不是似曾相识，因为在前面的高速缓存里，缓存的结构也是这样的。</p><p>以一个 32 位地址举例，高 20 位是虚拟页号，可以从虚拟页表中找到物理页号的信息，低 12 位是偏移量，可以准确获得物理地址。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207161640968.png"></p><p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p><ul><li>把虚拟内存地址，切分成页号和偏移量的组合；</li><li>从页表里面，查询出虚拟页号，对应的物理页号；</li><li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207161645714.png"></p><p>但是这样的页表有个问题，它需要记录$2^{20}$个物理页表，这个存储关系，就好比一个 $2^{20}$大小的数组。一个页号是完整的 32 位的 4 字节（Byte），这样一个页表就需要 4MB 的空间。并且每个进程都会有这样一个页表，现代电脑正常都有成百上千个进程，如果用这样的页表肯定行不通的。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>所以，<strong>在一个实际的程序进程里面，虚拟内存占用的地址空间，通常是两段连续的空间。而不是完全散落的随机的内存地址</strong>。而多级页表，就特别适合这样的内存地址分布。</p><p><a href="https://zhuanlan.zhihu.com/p/357648933">谈一谈内存管理，虚拟内存，多级页表 - 知乎</a></p><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><h3 id="内存保护-可执行空间保护"><a href="#内存保护-可执行空间保护" class="headerlink" title="内存保护 - 可执行空间保护"></a>内存保护 - 可执行空间保护</h3><h3 id="内存保护-地址空间布局随机化"><a href="#内存保护-地址空间布局随机化" class="headerlink" title="内存保护 - 地址空间布局随机化"></a>内存保护 - 地址空间布局随机化</h3><p>Address Space Layout Randomization</p><h2 id="总线：计算机内部的高速公路"><a href="#总线：计算机内部的高速公路" class="headerlink" title="总线：计算机内部的高速公路"></a>总线：计算机内部的高速公路</h2><p>计算机由控制器、运算器、存储器、输入设备以及输出设备五大部分组成。CPU 所代表的控制器和运算器，要和存储器，也就是我们的主内存，以及输入和输出设备进行通信。那么计算机是用什么样的方式来完成，CPU 和内存、以及外部输入输出设备的通信呢？答案就是通过总线来通信。</p><p>计算机里有不同的硬件设备，如果设备与设备之间都单独连接，那么就需要 N*N 的连线。那么怎么降低复杂度呢？与其让各个设备之间互相单独通信，不如我们去设计一个公用的线路。CPU 想要和什么设备通信，通信的指令是什么，对应的数据是什么，都发送到这个线路上；设备要向 CPU 发送什么信息呢，也发送到这个线路上。这个线路就好像一个高速公路，各个设备和其他设备之间，不需要单独建公路，只建一条小路通向这条高速公路就好了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081510203.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081510711.png"></p><h3 id="三种线路和多总线架构"><a href="#三种线路和多总线架构" class="headerlink" title="三种线路和多总线架构"></a>三种线路和多总线架构</h3><p>首先，CPU 和内存以及高速缓存通信的总线，这里面通常有两种总线。这种方式，我们称之为双独立总线（Dual Independent Bus，缩写为 DIB）。CPU 里，有一个快速的本地总线（Local Bus），以及一个速度相对较慢的前端总线（Front-side Bus）。</p><p>现代的 CPU 里，通常有专门的高速缓存芯片。这里的高速本地总线，就是用来和高速缓存通信的。而前端总线，则是用来和主内存以及输入输出设备通信的。有时候，我们会把本地总线也叫作后端总线（Back-sideBus），和前面的前端总线对应起来。</p><p>除了前端总线呢，我们常常还会听到 PCI 总线、I/O 总线或者系统总线（System Bus）。看到这么多总线的名字，你是不是已经有点晕了。这些名词确实容易混为一谈。其实各种总线的命名一直都很混乱，我们不如直接来看一看 CPU 的硬件架构图。对照图来看，一切问题就都清楚了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081513938.png"></p><p>CPU 里面的北桥芯片，把我们上面说的前端总线，一分为二，变成了三个总线。我们的前端总线，其实就是系统总线。CPU 里面的内存接口，直接和系统总线通信，然后系统总线再接入一个 I/O 桥接器（I/OBridge）。这个 I/O 桥接器，一边接入了我们的内存总线，使得我们的 CPU 和内存通信；另一边呢，又接入了一个 I/O 总线，用来连接 I/O 设备。</p><p>事实上，真实的计算机里，这个总线层面拆分得更细。根据不同的设备，还会分成独立的 PCI 总线、ISA 总线等等。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081516341.png"></p><p>在物理层面，其实我们完全可以把总线看作一组“电线”。不过呢，这些电线之间也是有分工的，我们通常有三类线路。</p><ol><li>数据线（Data Bus），用来传输实际的数据信息，也就是实际上了公交车的“人”。</li><li>地址线（Address Bus），用来确定到底把数据传输到哪里去，是内存的某个位置，还是某一个 I/O 设备。这个其实就相当于拿了个纸条，写下了上面的人要下车的站点。</li><li>控制线（ControlBus），用来控制对于总线的访问。虽然我们把总线比喻成了一辆公交车。那么有人想要做公交车的时候，需要告诉公交车司机，这个就是我们的控制信号。</li></ol><p>尽管总线减少了设备之间的耦合，也降低了系统设计的复杂度，但同时也带来了一个新问题，那就是<strong>总线不能同时给多个设备提供通信功能</strong>。</p><p>我们的总线是很多个设备公用的，那多个设备都想要用总线，我们就需要有一个机制，去决定这种情况下，到底把总线给哪一个设备用。这个机制，就叫作<strong>总线裁决</strong>（Bus Arbitraction）</p><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>过去几年，计算机产业一直在为提升 I/O 设备的速度而努力，从机械硬盘 HDD 到固态硬盘 SSD，从 SATA 协议到 PCIE 协议，虽然速度都几十上百倍的增加，但是仍然不够快。因为相比于 CPU 基本都是 2GHz 的频率（每秒会有 20 亿次的操作），SSD 硬盘的 IOPS 的 2 万次操作就显得微不足道。</p><p>如果我们对于 I/O 的操作，都是由 CPU 发出对应的指令，然后等待 I/O 设备完成操作之后返回，那 CPU 有大量的时间其实都是在等待 I/O 设备完成操作。特别是当传输的数据量比较大的时候，比如进行大文件复制，如果所有数据都要经过 CPU，实在是有点儿太浪费时间了。</p><p>因此，计算机工程师们，就发明了<strong>DMA 技术</strong>，也就是<strong>直接内存访问（Direct Memory Access）技术</strong>，来减少 CPU 等待的时间。</p><h3 id="什么是-DMA"><a href="#什么是-DMA" class="headerlink" title="什么是 DMA"></a>什么是 DMA</h3><p>本质上，DMA 技术就是我们在主板上放一块<strong>独立的芯片</strong>。在进行内存和 I/O 设备的数据传输的时候，我们不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器（DMA Controller，简称 DMAC）。这块芯片，我们可以认为它其实就是一个<strong>协处理器</strong>（Co-Processor）。</p><p>DMAC 最有价值的地方体现在，当我们要传输的数据特别大、速度特别快，或者传输的数据特别小、速度特别慢的时候。</p><p>比如说，我们用千兆网卡或者硬盘传输大量数据的时候，如果都用 CPU 来搬运的话，肯定忙不过来，所以可以选择 DMAC。而当数据传输很慢的时候，DMAC 可以等数据到齐了，再向 CPU 发起中断，让 CPU 去处理，而不是让 CPU 在那里忙等待。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208152252016.png"></p><ol><li>首先，CPU 还是作为一个主设备，向 DMAC 设备发起请求。这个请求，其实就是在 DMAC 里面修改配置寄存器。</li><li>CPU 修改 DMAC 的配置的时候，会告诉 DMAC 这样几个信息：<ul><li>源地址的初始值：数据要从哪里传输过来。如果我们要从内存里面写入数据到硬盘上，那么就是要读取的数据在内存里面的地址</li><li>传输时候的地址增减方式：数据是从大的地址向小的地址传输，还是从小的地址往大的地址传输</li><li>传输的数据长度：也就是我们一共要传输多少数据</li></ul></li><li>设置完这些信息之后，DMAC 就会变成一个空闲的状态（Idle）。</li><li>如果我们要从硬盘上往内存里面加载数据，这个时候，硬盘就会向 DMAC 发起一个数据传输请求。这个请求并不是通过总线，而是通过一个额外的连线。</li><li>然后，我们的 DMAC 需要再通过一个额外的连线响应这个申请。</li><li>DMAC 这个芯片，就向硬盘的接口发起要总线读的传输请求。数据就从硬盘里面，读到了 DMAC 的控制器里面。</li><li>DMAC 再向我们的内存发起总线写的数据传输请求，把数据写入到内存里面。</li><li>DMAC 会反复进行上面第 6、7 步的操作，直到 DMAC 的寄存器里面设置的数据长度传输完成。</li><li>数据传输完成之后，DMAC 重新回到第 3 步的空闲状态。</li></ol><p>所以，整个数据传输的过程中，我们不是通过 CPU 来搬运数据，而是由 DMAC 这个芯片来搬运数据。但是 CPU 在这个过程中也是必不可少的。因为传输什么数据，从哪里传输到哪里，其实还是由 CPU 来设置的。这也是为什么，DMAC 被叫作 <strong>协处理器</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1cJ411K7HW?spm_id_from=333.999.0.0">【硬件科普】电脑主板右下角的散热片下面究竟隐藏着什么？详解主板南桥芯片组的功能和作用_哔哩哔哩_bilibili</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
      <tag>计算机组成原理</tag>
      
      <tag>页表</tag>
      
      <tag>DMA</tag>
      
      <tag>虚拟内存</tag>
      
      <tag>缓存</tag>
      
      <tag>总线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-处理器</title>
    <link href="/2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="建立数据通路：指令-运算-CPU"><a href="#建立数据通路：指令-运算-CPU" class="headerlink" title="建立数据通路：指令 + 运算=CPU"></a>建立数据通路：指令 + 运算=CPU</h2><p>指令周期</p><ul><li>Fetch（取得指令）：从内存里把指令加载到指令寄存器中。</li><li>Decode（指令译码）</li><li>Execute（执行指令）<br>重复操作这三步，这个循环称为指令周期。</li></ul><p>不同的步骤在不同组件内完成<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011556148.png"></p><p>机器周期/CPU周期：从内存里读取一条指令的最短时间。<br>时钟周期：就是机器的主频，一个 CPU 周期由多个时钟周期组成。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011607706.png"></p><p>操作元件：组合逻辑元件，ALU，功能是在特定的输入下，生成特定的输出。<br>存储元件：状态元件，寄存器。</p><p>将操作元件，操作原件通过数据总线的方式连接起来，就<strong>建立了数据通路</strong>了。</p><p>控制器：循环执行取址-译码，产生控制信号交给 ALU 处理。电路特别复杂，CPU 如果支持 2000 个指令，意味着控制器输出的信号有 2000 个不同的组合。</p><p>CPU 需要的电路</p><ul><li>根据输入计算出结果的一个电路，ALU</li><li>能够进行状态读写的电路元件，寄存器</li><li>按照固定周期，不停实现 PC 寄存器自增的电路</li><li>译码电路，能够对于拿到的内存地址获取对应的数据或者指令</li></ul><blockquote><p>Q :  CPU 好像一个永不停歇的机器，一直在不停地读取下一条指令去运行。那 为什么 CPU 还会有满载运行和 Idle 闲置的状态呢？<br>A：CPU 还会有满载运行和 Idle 闲置的状态，指的系统层面的状态。即使是 Idle 空闲状态，CPU 也在执行循环指令。<br>操作系统内核有 idle 进程，优先级最低，仅当其他进程都阻塞时被调度器选中。idle 进程循环执行 HLT 指令，关闭 CPU 大部分功能以降低功耗，收到中断信号时 CPU 恢复正常状态。CPU 在空闲状态就会停止执行，即切断时钟信号，CPU 主频会瞬间降低为 0，功耗也会瞬间降为 0。由于这个空闲状态是十分短暂的，所以你在任务管理器也只会看到 CPU 频率下降，不会看到降为 0。当 CPU 从空闲状态中恢复时，就会接通时钟信号，CPU 频率就会上升。所以你会在任务管理器里面看到 CPU 的频率起伏变化。</p></blockquote><p>实现一个完整的 CPU，除了<strong>组合逻辑电路</strong>，还需要<strong>时序逻辑电路</strong>。因为组合逻辑电路只是处理固定输入，得到固定输出，这种电路只能协助我们完成一些计算工作，干不了太复杂的工作。</p><p>时序逻辑电路可以解决这几个问题：</p><ul><li>自动运行问题<br>  时序电路接通之后可以<strong>不停地开启和关闭开关</strong>，进入一个自动运行的状态。这个使得我们上一讲说的，控制器不停地让 PC 寄存器自增读取下一条指令成为可能。</li><li>存储问题<br>  通过时序电路实现的触发器，<strong>能把计算结果存储在特定的电路里面</strong>， 而不是像组合逻辑电路那样，一旦输入有任何改变，对应的输出也会改变。</li><li><strong>时序协调问题</strong><br>  无论是程序实现的软件指令，还是到硬件层面，各种指令的操作都有<strong>先后的顺序</strong>要求。时序电路使得不同的事件按照时间顺序发生。</li></ul><p><strong>解决自动运行问题</strong><br>实现时序逻辑电路的第一步就需要一个时钟。CPU 的主频是一个晶振来实现的，晶振生成的电路信号就是我们的时钟信号。</p><p>实现如图所示，我们在原先一般只放一个开关的信号输入端，放上了两个开 关。一个开关 A，一开始是断开的，由我们手工控制；另外一个开关 B，一开始是合上的，<br>磁性线圈对准一开始就合上的开关 B。</p><p>于是，一旦我们合上开关 A，磁性线圈就会通电，产生磁性，开关 B 就会从合上变成断 开。一旦这个开关断开了，电路就中断了，磁性线圈就失去了磁性。于是，开关 B 又会弹 回到合上的状态。这样一来，电路接通，线圈又有了磁性。我们的电路就会来回不断地在开<br>启、关闭这两个状态中切换。</p><p>这个不断切换的过程，对于下游电路来说，就是不断地产生新的 0 和 1 这样的信号。如果 你在下游的电路上接上一个灯泡，就会发现这个灯泡在亮和暗之间不停切换。这个按照固定的周期不断在 0 和 1 之间切换的信号，就是我们的时钟信号。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011740388.png"></p><p>一般这样产生的时钟信号，就像你在各种教科书图例中看到的一样，是一个振荡产生的 0、1 信号。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011745410.png"></p><p>这种电路，其实就相当于把电路的输出信号作为输入信号，再回到当前电路。这样的电路构 造方式呢，我们叫作反馈电路（Feedback Circuit）。</p><p>上面这个反馈电路一般可以用下面这个示意图来表 示，其实就是一个输出结果接回输入的反相器（Inverter），也就是我们之前讲过的非门。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011746094.png"></p><p><strong>解决存储问题</strong></p><p>有了时钟信号，我们的系统里就有了一个像“自动门”一样的开关。利用这个开关和相同的 反馈电路，我们就可以构造出一个有“记忆”功能的电路。</p><p>我们先来看下面这个 <strong>RS 触发器</strong>电路。这个电路由两个或非门电路组成。我在图里面，把它 标成了 A 和 B。</p><p>或非门真值表：<br>|NOR|0| 1|<br>| —- | —- | —- |<br>|0|1|0|<br>|1|0|0|<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011851028.png"></p><ol><li>在这个电路一开始，输入开关都是关闭的，所以或非门（NOR）A 的输入是 0 和 0。对 应到我列的这个真值表，输出就是 1。而或非门 B 的输入是 0 和 A 的输出 1，对应输出 就是 0。B 的输出 0 反馈到 A，和之前的输入没有变化，A 的输出仍然是 1。而整个电 路的输出 Q，也就是 0。</li><li>当我们把 A 前面的开关 R 合上的时候，A 的输入变成了 1 和 0，输出就变成了 0，对应 B 的输入变成 0 和 0，输出就变成了 1。B 的输出 1 反馈给到了 A，A 的输入变成了 1 和 1，输出仍然是 0。所以把 A 的开关合上之后，电路仍然是稳定的，不会像晶振那样 振荡，但是整个电路的输出 Q 变成了 1。</li><li>这个时候，如果我们再把 A 前面的开关 R 打开，A 的输入变成和 1 和 0，输出还是 0，对应的 B 的输入没有变化，输出也还是 1。B 的输出 1 反馈给到了 A，A 的输入变成了 1 和 0，输出仍然是 0。这个时候，电路仍然稳定。开关 R 和 S 的状态和上面的第一步是一样的，但是最终的输出 Q 仍然是 1，和第 1 步里 Q 状态是相反的。我们的输入和刚才第二步的开关状态不一样，但是输出结果仍然保留在了第 2 步时的输出没有发生变 化。</li><li>这个时候，只有我们再去关闭下面的开关 S，才可以看到，这个时候，B 有一个输入必然是 1，所以 B 的输出必然是 0，也就是电路的最终输出 Q 必然是 0。</li></ol><p>这样一个电路，我们称之为触发器（Flip-Flop）。接通开关 R，输出变为 1，即使断开开 关，输出还是 1 不变。接通开关 S，输出变为 0，即使断开开关，输出也还是 0。也就是， <strong>当两个开关都断开的时候，最终的输出结果，取决于之前动作的输出结果，这个也就是我们说的记忆功能</strong>。</p><h2 id="面向流水线的指令设计"><a href="#面向流水线的指令设计" class="headerlink" title="面向流水线的指令设计"></a>面向流水线的指令设计</h2><h3 id="单指令周期处理器"><a href="#单指令周期处理器" class="headerlink" title="单指令周期处理器"></a>单指令周期处理器</h3><p>一条 CPU 指令的执行，有三步：取得指令，译码，执行。需要一个时钟周期。自然设计指令时，我们也希望一整条指令能在一个时钟周期内完成。这就是单指令周期处理器。</p><p>不过，时钟周期是固定的，但是指令的电路复杂程度是不同的，所以实际一条指令执行的时间是不同的。从前面的学习中也知道，随着门电路层数的增加，门延迟的存在，计算复杂的指令需要的时间更长。</p><p>不同指令的执行时间不同，但是我们需要让所有指令都在一个时钟周期内完成，那就只好<strong>把执行时间最长的那个指令和时钟周期设成一样</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205142125165.png"></p><p>所以，在单指令周期处理器里面，无论是执行一条用不到 ALU 的无条件跳转指令，还是一条计算起来电路特别复杂的浮点数乘法运算，我们都等要等满一个时钟周期。这样时钟频率就无法提高，因为太高了，有些复杂指令无法在一个时钟周期内运行完。</p><p>到这可能就有人发问了，之前不是说一个 CPU 时钟周期，可以认为是完成一条简单指令的时间。为什么单指令周期处理器上，却成了执行一条最复杂的指令的时间？</p><p>这是因为，无论是 PC 上使用的 Intel CPU，还是手机上使用的 ARM CPU，都不是单指令周期处理器，而是采用了一种叫作<strong>指令流水线</strong>（Instruction Pipeline）的技术。</p><h3 id="流水线设计"><a href="#流水线设计" class="headerlink" title="流水线设计"></a>流水线设计</h3><p>CPU 执行指令的过程和我们做饭一样，我们不会等米饭蒸好再洗菜，不会等肉腌好再切菜，而是蒸饭时，可以洗菜，腌肉时可以切菜。</p><p>CPU 的指令执行过程，其实也是由各个电路模块组成的。我们在取指令的时候，需要一个译码器把数据从内存里面取出来，写入到寄存器中；在指令译码的时候，我们需要另外一个译码器，把指令解析成对应的控制信号、内存地址和数据；到了指令执行的时候，我们需要的则是一个完成计算工作的 ALU。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205142142974.png"></p><p>这样一来，我们就不用把时钟周期设置成整条指令执行的时间，而是拆分成完成这样的一个一个小步骤需要的时间。同时，每一个阶段的电路在完成对应的任务之后，也不需要等待整个指令执行完成，而是可以直接执行下一条指令的对应阶段。</p><p>如果我们把一个指令拆分成“取指令 - 指令译码 - 执行指令”这样三个部分，那这就是一个<strong>三级的流水线</strong>。如果我们进一步把“执行指令”拆分成“ALU 计算（指令执行）- 内存访问 - 数据写回”，那么它就会变成一个<strong>五级的流水线</strong>。</p><p>五级的流水线，就表示我们在同一个时钟周期里面，同时运行五条指令的不同阶段。这个时候，虽然<strong>执行一条指令的时钟周期变成了 5</strong>，但是我们可以把 CPU 的主频提得更高了。<strong>我们不需要确保最复杂的那条指令在时钟周期里面执行完成，而只要保障一个最复杂的流水线级的操作，在一个时钟周期内完成就好了</strong>。</p><p>如果某一个操作步骤的时间太长，我们就可以考虑把这个步骤，拆分成更多的步骤，让所有步骤需要执行的时间尽量都差不多长。</p><p>既然流水线可以增加我们的吞吐率，你可能要问了，为什么我们不把流水线级数做得更深 呢？为什么不做成 20 级，乃至 40 级呢？这个其实有很多原因，我在之后几讲里面会详细讲解。这里，我先讲一个最基本的原因，就是增加流水线深度，其实是有性能成本的。</p><p>我们用来同步时钟周期的，不再是指令级别的，而是流水线阶段级别的。每一级流水线对应 的输出，都要放到流水线寄存器（Pipeline Register）里面，然后在下一个时钟周期，交给下一个流水线级去处理。所以，每增加一级的流水线，就要多一级写入到流水线寄存器的操作。虽然流水线寄存器非常快，比如只有 20 皮秒（ps，10−12 秒）。</p><p>但是，如果我们不断加深流水线，这些操作占整个指令的执行时间的比例就会不断增加。最后，我们的性能瓶颈就会出现在这些 overhead 上。如果我们指令的执行有 3 纳秒，也就 是 3000 皮秒。我们需要 20 级的流水线，那流水线寄存器的写入就需要花费 400 皮秒，占了超过 10%。如果我们需要 50 级流水线，就要多花费 1 纳秒在流水线寄存器上，占到 25%。这也就意味着，单纯地增加流水线级数，不仅不能提升性能，反而会有更多的 overhead 的开销。所以，设计合理的流水线级数也是现代 CPU 中非常重要的一点。</p><h2 id="FPGA-ASIC-TPU"><a href="#FPGA-ASIC-TPU" class="headerlink" title="FPGA/ASIC/TPU"></a>FPGA/ASIC/TPU</h2><h3 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h3><p>CPU 是由简单的门电路搭积木一样搭建出来的，那一个 CPU 里有多少个晶体管这样的电路开关呢？一个四核 i7 的 Intel CPU，有 20 亿个晶体管。那么问题来了，我们要设计一个 CPU，就要想办法连接这 20 亿个晶体管。</p><p>连接一次已经很难了，我们还要根据问题重新调整连接。设计更简单的特定功能的芯片，少说要几个月。而设计一个 CPU 往往以年计。在这个过程中，硬件工程师要设计、验证各种各样的方案，可能会遇到各种 BUG。如果每验证一个方案都要生产一块芯片，这代价太高了。</p><p>我们有没有什么办法，不用单独制造一块专门的芯片来验证 硬件设计呢？能不能设计一个硬件，通过不同的程序代码，来操作这个硬件之前的电路连线，通过“编程”让这个硬件 变成我们设计的电路连线的芯片呢？</p><p>这个，就是我们接下来要说的 <strong>FPGA</strong>，也就是<strong>现场可编程门阵列</strong>（Field-Programmable Gate Array）。</p><ul><li>P 代表 Programmable，也就是说这 是一个<strong>可以通过编程来控制的硬件</strong>。</li><li>G 代表 Gate，它就代表芯片里面的门电路。我们能够去进行编程组合的就是这样一个一个<strong>门电路</strong>。</li><li>A 代表的 Array，叫作阵列，说的是在一块 FPGA 上，密密麻麻列了<strong>大量 Gate 这样的门电路</strong>。</li><li>F，不太容易理解。它其实是说，一块 FPGA 这样的板子，<strong>可以进行在“现场”多次地进行编程</strong>。它不像 PAL（Programmable Array Logic，可编程阵列逻辑）这样更古老的硬件设备，只能“编程”一次，把预先写好的程序一次性烧录到硬件里面，之后就不能再修改了。</li></ul><p>我们之前说过，CPU 其实就是通过晶体管，来实现各 种组合逻辑或者时序逻辑。那么，<strong>我们怎么去“编程”连接这些线路呢</strong>？</p><p>FPGA 的解决方案分三步：</p><p><strong>第一，用存储换功能实现组合逻辑</strong>。在实现 CPU 的功能的时候，我们需要完成各种各样的电路逻辑。在 FPGA 里，这 些基本的电路逻辑，不是采用布线连接的方式进行的，而是 预先根据我们在软件里面设计的逻辑电路，算出对应的真值表，然后直接存到一个叫作 LUT（Look-Up Table，查找 表）的电路里面。这个 LUT 呢，其实就是一块存储空间，里面存储了“特定的输入信号下，对应输出 0 还是 1”。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081009007.png"></p><p><strong>第二，对于需要实现的时序逻辑电路，我们可以在 FPGA 里面直接放上 D 触发器，作为寄存器</strong>。这个和 CPU 里的触发器没有什么本质不同。不过，我们会把很多个 LUT 的电路和寄存器组合在一起，变成一个叫作逻辑簇（Logic Cluster）的东西。在 FPGA 里，这样组合了多个 LUT 和寄 存器的设备，也被叫做 CLB Configurable Logic Block，可配置逻辑块）。</p><p>可以把 CLB 想象成函数或者 API，设计更复杂的功能，不用重新造轮子，只需要调用函数或者 API 即可。设计芯片也是一样，不用再从门电路开始搭建，可以通过 CLB 组合搭建。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081014661.png"></p><p><strong>第三，FPGA 是通过可编程逻辑布线，来连接各个不同的 CLB，最终实现我们想要实现的芯片功能</strong>。这个可编程逻辑布线，你可以把它当成我们的铁路网。整个铁路系统已经铺 好了，但是整个铁路网里面，设计了很多个道岔。我们可以 通过控制道岔，来确定不同的列车线路。在可编程逻辑布线 里面，“编程”在做的，就是拨动像道岔一样的各个电路开 关，最终实现不同 CLB 之间的连接，完成我们想要的芯片<br>功能。</p><h3 id="ASIC"><a href="#ASIC" class="headerlink" title="ASIC"></a>ASIC</h3><p>除了 CPU，GPU 以及 FPGA，我们还需要用到很多其他芯片，比如除了音视频的芯片，或者专门用来挖矿的芯片。尽管 CPU 也能实现这些功能，但是有点大炮打蚊子的感觉。</p><p>于是针对一些特殊场景，单独设计一个芯片，我们称这些芯片为 ASIC（Application-Specific Integrated Circuit），专用集成电路。设计精简，制造成本低。</p><p>其实我们的 FPGA 也能做 ASIC 的事情，每次对 FPGA 进行编程，就是把 FPGA 电路编程了一个 ASIC。但是如果全用 FPGA，同样会浪费。因为每一个 LUT 电路，都可以实现与门以及或门，这比单纯连死的与门或者或门，用到的晶体管数量要多的多。自然功耗也要大得多，单片 FPGA 的生产制造成本也比 ASIC 要高。</p><table><thead><tr><th align="center"></th><th align="center">FPAG</th><th align="center">ASIC</th></tr></thead><tbody><tr><td align="center">一次性成本</td><td align="center">极低，约等于 0</td><td align="center">高</td></tr><tr><td align="center">量产成本</td><td align="center">高</td><td align="center">低</td></tr><tr><td align="center">延迟</td><td align="center">低</td><td align="center">低</td></tr><tr><td align="center">开发周期</td><td align="center">短</td><td align="center">长</td></tr><tr><td align="center">市场风险</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">开发环境</td><td align="center">设置 FPGA 需要硬件知识，编程和配置门槛很高</td><td align="center">需要底层硬件变成，开发难度很高</td></tr></tbody></table><h2 id="TPU"><a href="#TPU" class="headerlink" title="TPU"></a>TPU</h2><p>TPU（Tensor Processing Unit）张量处理器；</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>替换 Gitee 图床为腾讯云 COS</title>
    <link href="/2022/04/09/%E6%9B%BF%E6%8D%A2Gitee%E5%9B%BE%E5%BA%8A%E4%B8%BA%E8%85%BE%E8%AE%AF%E4%BA%91COS/"/>
    <url>/2022/04/09/%E6%9B%BF%E6%8D%A2Gitee%E5%9B%BE%E5%BA%8A%E4%B8%BA%E8%85%BE%E8%AE%AF%E4%BA%91COS/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1964208">Gitee 图床挂了</a>，但是各大云服务厂商提供的对象存储服务免费额度，对于个人小博客来说也够用了。下面介绍如何将图床更换为腾讯云 COS。</p><h2 id="下载原有图片"><a href="#下载原有图片" class="headerlink" title="下载原有图片"></a>下载原有图片</h2><p>从<code>gitee</code>下载整个仓库。保持原有目录结构。</p><h2 id="配置腾讯云-COS"><a href="#配置腾讯云-COS" class="headerlink" title="配置腾讯云 COS"></a>配置腾讯云 COS</h2><p>注册腾讯云账号，创建 COS 存储桶，选择公有读私有写。创建 COS 存储桶地址：<a href="https://console.cloud.tencent.com/cos">https://console.cloud.tencent.com/cos</a>，创建存储桶后可以在存储桶里打开防盗链设置。</p><p>创建桶–选择地域–填写名称–选择公有读私有写–点击创建。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091731554.png"></p><p>如果忘了设置读写权限可以按一下方法设置；<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727355.png"></p><p>选择<strong>菜单</strong>–<strong>文件列表</strong>。上传下载好的文件夹（整个仓库的文件夹）。鼠标放到<strong>选择文件</strong>出现<strong>上传文件夹选项</strong>，或者将文件夹<strong>拖入浏览器</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727353.png"></p><h2 id="配置-Picgo"><a href="#配置-Picgo" class="headerlink" title="配置 Picgo"></a>配置 Picgo</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727351.png"></p><p><strong>COS 版本</strong>：V5<br><strong>设定 Secreid，设定 Secrekey，设定 APPID：</strong> APPID、SecretID 与 SecretKey <a href="https://console.cloud.tencent.com/cam/capi">点此直达获取</a>。<br>选择继续使用–创建秘钥。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/202204091715578.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727352.png"></p><p><strong>设定存储空间名，设定存储区域：</strong> <a href="https://console.cloud.tencent.com/cos/bucket">点此获取存储空间名以及存储区域</a>。桶名称即存储空间名，所属区域：<code>ap-shanghai</code>即确认存储区域。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727354.png"></p><p><strong>指定存储区域：</strong><br>指定上传到 COS 的目录，比如我原先从<code>gitee</code>下载来的图床的仓库名是<code>markdown_picbed</code>，图片又保存在<code>markdown_picbed/img</code>目录下，那么就指定<code>markdown_picbed/img</code>目录。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091722487.png"></p><h2 id="替换旧图床-URL"><a href="#替换旧图床-URL" class="headerlink" title="替换旧图床 URL"></a>替换旧图床 URL</h2><p>VSCode 全局替换：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091753809.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>图床</tag>
      
      <tag>腾讯云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员的自我修养笔记</title>
    <link href="/2022/03/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。</p><h2 id="第三章-目标文件里有什么"><a href="#第三章-目标文件里有什么" class="headerlink" title="第三章 目标文件里有什么"></a>第三章 目标文件里有什么</h2><h3 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h3><p><strong>目标文件</strong>从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。</p><p>现在 PC 平台流形的可执行文件格式，主要是 Windows 下的 PE（Portable Executable）和 Linux 下的 ELF（Executable Linkable Format）,它们都是 COFF（Common file format）格式的变种。</p><p>指令和数据分开存放的好处：</p><ul><li><p>一方面当程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被设置成可读写和只读，这样可以防止程序的指令被有意或无意地改写。</p></li><li><p>另一方面是现代 CPU 有强大的缓存体系，由于缓存很重要，所以程序必须尽量提高缓存命中率。指令区和数据区分离有利于提高程序的局部性。现代 CPU 的缓存一般都被设计成数据缓存和指令缓存，所以程序的指令和数据分开存放对于 CPU 的缓存命中率提高有好处。</p></li><li><p>第三个原因，也是最重要的原因，就是当系统中运行着多个该进程副本时，他们的指令都是一样的，所以内存中只需要保存一份程序的指令部分。</p></li></ul><p><strong>真正了牛逼的程序员对自己的程序每一个字节都了如指掌。</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">objdump -h  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SimpleSsection</span>.</span></span>o  # 打印elf文件各个段的信息<br>size <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SimpleSsection</span>.</span></span>o           # 查看elf文件各个段的长度<br>objdump -s -d <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SimpleSsection</span>.</span></span>o # -s将所有段内容以十六进制打印，-d将所有包含指令的段反汇编<br></code></pre></td></tr></table></figure><table><thead><tr><th>段名称</th><th>内容</th></tr></thead><tbody><tr><td>.data</td><td>- 初始化的全局变量 <br> - 局部静态变量</td></tr><tr><td>.rodata</td><td>只读数据段，对这个段的任何修改都是非法的，保证了程序的安全性。 <br> 有时候编译器会把字符串放到 data 段<br> - 只读变量 const 修饰 <br> - 字符串常量</td></tr><tr><td>.bss</td><td>不占磁盘空间， <br>- 未初始化的全局变量 <br> - 未初始化的局部静态变量 <br> - 初始化为 0 的静态变量</td></tr><tr><td>.comment</td><td>存放编译器版本信息，比如字符串“GCC：（GNU）4.2.0”</td></tr><tr><td>.line</td><td>调试时的行号表，即源代码行号与编译后指令的对应表</td></tr><tr><td>.note</td><td>额外的编译器信息，如程序公司名，版本号</td></tr><tr><td>.symtab</td><td>Symbol Table 符号表</td></tr><tr><td>.plt</td><td>动态链接的跳转表</td></tr><tr><td>.got</td><td>动态链接的全局入口表</td></tr></tbody></table><p>段名称都是<code>.</code>前缀，表示这些表名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名称。比如可以加入一个<code>music</code>段，里面存一首 mp3 音乐，运行起来后就会播放音乐，打算自定义段不能使用<code>.</code>作为前缀，以免与系统保留段名冲突。</p><blockquote><p>Q: 如何将一个二进制文件，如图片，MP3 文件作为目标文件的一个段？<br>A: 可以使用 objcopy 工具，比如有一个图片 image..jpg，大小为 0x2100 字节：<br>$ objcopy -I binary -O elf32-i388 -B  i38 image.jpg image.o</p></blockquote><p>正常情况下编译出来的目标文件，代码会放到<code>.text</code>段，但是有时候你希望变量或者某些代码能放到你指定的段中去，以实现某些特定的功能。比如为了满足某些硬件的内存和 IO 地址布局。GCC 提供了扩展机制，使得程序员可以指定变量所处的段：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">__attribute__((<span class="hljs-name">section</span>(<span class="hljs-string">&quot;FOO&quot;</span>))) int global = <span class="hljs-number">42</span><span class="hljs-comment">;</span><br>__attribute__((<span class="hljs-name">section</span>(<span class="hljs-string">&quot;BAR&quot;</span>))) void foo<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="ELF-文件结构"><a href="#ELF-文件结构" class="headerlink" title="ELF 文件结构"></a>ELF 文件结构</h3><p>使用<code>readelf</code>命令查看 elf 文件详细信息。</p><ul><li><p>ELF 魔数，确认文件类型。</p></li><li><p>文件类型</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>ET_REL</td><td>1</td><td>可重定位文件，一般问.o文件</td></tr><tr><td>ET_EXEC</td><td>2</td><td>可执行文件</td></tr><tr><td>ET_DYN</td><td>3</td><td>共享目标文件，一般为.so文件</td></tr></tbody></table></li><li><p>机器类型</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>EM_M32</td><td>1</td><td>AT&amp;T WE 32100</td></tr><tr><td>EM_SPARC</td><td>2</td><td>SPARC</td></tr><tr><td>EM_M386</td><td>3</td><td>Intel x86</td></tr><tr><td>EM_68K</td><td>4</td><td>Motorola 68000</td></tr><tr><td>EM_88K</td><td>5</td><td>Motorola 88000</td></tr><tr><td>EM_860</td><td>6</td><td>Intel 80860</td></tr></tbody></table></li></ul><p><strong>段表</strong>是保存各个段的基本属性的结构。段表是除文件头外最重要的结构。编译器，链接器和装载器都是依靠段表来定位和访问各个段的属性。</p><h3 id="链接的接口-符号"><a href="#链接的接口-符号" class="headerlink" title="链接的接口 - 符号"></a>链接的接口 - 符号</h3><h4 id="符号表结构"><a href="#符号表结构" class="headerlink" title="符号表结构"></a>符号表结构</h4><p>链接过程的本质就是要把多个不同的目标文件之间相互粘到一起。</p><p>目标文件 B 要用到目标文件 A 的函数<code>foo</code>，我们称目标文件 A<strong>定义</strong>了函数<code>foo</code>，目标文件 B<strong>引用</strong>了目标文件 A 的函数<code>foo</code>。</p><p>链接中，我们将函数和变量统称为<strong>符号</strong>，函数名或变量名就是符号名。、</p><p>每一个目标文件都会有一个相应的符号表，表里记录了目标文件中所用到的所有符号。每个符号都有一个对应值，叫符号值，对于变量和函数来说，符号值就是他们的地址。</p><p>符号类型：</p><ul><li>定义在本目标文件的全局符号，可以被其他目标引用。</li><li>在本目标文件中应用的全局符号，却没有定义在本目标文件。</li><li>段名称，也就是段起始地址。</li><li>局部符号，一些静态变量等。</li><li>行号信息。</li></ul><p>最重要的就是第一类和第二类。链接只关心全局符号的相互粘合，其他都是次要的。</p><p>可以使用 <code>readelf</code> <code>objdump</code> <code>nm</code>等命令查看符号信息。</p><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><p>一些特殊符号，没有在程序中定义，但是可以直接声明并引用它：</p><ul><li><code>__executable_start</code>，程序起始地址，不是入口地址，是程序最开始的地址。</li><li><code>__etext</code> <code>__etext</code>  <code>etext</code> 代码段结束地址，代码段最末尾的地址。</li><li><code>_edata</code> <code>edata</code> 数据段结束地址，数据段最末尾地址。</li><li><code>__end</code>  <code>end</code> 程序结束地址。</li></ul><h4 id="符号修饰"><a href="#符号修饰" class="headerlink" title="符号修饰"></a>符号修饰</h4><p>符号应与对应的函数或者变量同名，但是在 C 语言发明时，已经存在了很多库和目标文件，如果再用一样的函数或变量就会冲突为了避免冲突，C 语言编译后符号名前会加上下划线<code>_</code>，如<code>foo</code>变成<code>_foo</code>，Fortran 语言编译后会在符号前后加上下划线<code>_foo_</code>。</p><p>C++具有类，继承，重载等复杂机制，为了支持这些复杂特性，人们发明了<strong>符号修饰</strong>和<strong>符号改编</strong>。</p><p><strong>函数签名</strong>包含了一个函数的信息，包括函数名，参数类型，所在类和名称空间等信息。它用于识别不同的函数。在编译器和链接器处理符号时，使用某种名称修饰的方法，是的每个函数签名对应一个<strong>修饰后名称</strong>。</p><p>由于不同的编译器采用不同的名字修饰方式，必然导致由不同编译器编译产生的目标文件无法正常互相链接，这是导致不同编译器之间不能互操作的主要原因之一。</p><h4 id="extern-C"><a href="#extern-C" class="headerlink" title="extern C"></a>extern C</h4><p>C++为了兼容 C，C++编译器会将在<code>extern C</code> 的大括号内部的代码当做 C 语言代码处理，这样就不会使用 C++的名称修饰机制。（也就不会在编译的时候加上下划线）</p><p>但是 C 语言并不支持<code>extern C</code>关键字，又不能为同一个库函数写两套头文件，这时候就可以用 C++的宏，<code>__cplusplus</code>。C++编译器会在编译 C++的程序时默认定义这个宏，我们可以用条件宏来判断当前编译单元是不是 C++代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">int</span> , <span class="hljs-keyword">size_t</span>)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="弱符号与强符号"><a href="#弱符号与强符号" class="headerlink" title="弱符号与强符号"></a>弱符号与强符号</h4><p>我们经常碰到符号重定义，多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候就会出现符号重定义的错误。比如在两个文件中定义了相同的全局变量。</p><p>对于C/C++来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。</p><p>也可以使用 GCC 的<code>__attribute__((weak))</code>来定义任何一个强符号为弱符号。</p><ul><li>不允许强符号被多次定义，如果多次定义，则链接器报重复定义错误；</li><li>如果一个符号在某文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</li><li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。</li></ul><h2 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a>第四章 静态链接</h2><h3 id="空间地址分配"><a href="#空间地址分配" class="headerlink" title="空间地址分配"></a>空间地址分配</h3><p>可执行文件中的代码段和数据段就是多个文件合并而来的，对于多个文件链接器如何将它们合并到输出文件？</p><p>按序叠加：最简单的方式，按照输入文件顺序依次合并。这会导致大量碎片，比如 x86 的硬件，段的装载地址和空间的对齐单位是页，也就是 4096 字节，那么如果一个段的长度只有 1 字节，它在内存里也要占用 4096 字节。</p><p>相似段合并：将所有相同性质的段合并在一起。</p><p>现在的链接器基本上采用第二种。使用这种方法的链接器都采用一种叫两步链接的方法。</p><p>第一步，空间与地址分配。扫描所有的输入目标文件，并且获得各个段的长度，属性和位置，并将输入目标文件中的符号表所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步，链接器将能够获得所有输入目标文件的段长度，并且将他们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。</p><p>第二部，符号解析与重定位。使用上面收集到的信息，读取输入文件中段的数据，重定位信息。并且进行符号解析与重定位，调整代码中的地址。</p><p>VMA（Virtual Memory Address）虚拟地址，LMA（Load Memory Address）加载地址。正常情况这两个值是一样的。</p><p>链接之前目标文件的所有短 VMA 都是 0，因为虚拟空间还没有被分配，默认为 0，链接之后各个段就会被分配相应的虚拟地址。</p><p>Linux 下，ELF 可执行文件默认从地址<code>0x8048000</code>开始分配。</p><h3 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">objdump</span> -d  查看代码段反汇编结果<br></code></pre></td></tr></table></figure><p>源代码在编译成目标文件时并不知道函数的调用地址。需要通过链接时重定位。</p><p>链接器如何知道哪些指令需要被调整？这就用到了<strong>重定位表</strong>。</p><p>重定位表就是 ELF 文件的一个段，所以其实重定位表也可以叫重定位段。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">objdump</span> -r 查看重定位表<br></code></pre></td></tr></table></figure><p>每个要被重定位的地方叫一个重定位入口（Relocation Entry）。</p><p>重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，或引用到定义在其他文件的符号。重定位过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，他就要确定这个符号的目标地址。这时候链接器就会取查找由所有输入目标文件的符号表组成的全局符号表，找到对应的符号进行重定位。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">readelf</span> -s 查看符号表<br></code></pre></td></tr></table></figure><p>对于 32 位 x86 平台下的 ELF 文件的重定位入口所修正的指令寻址方式只有两种：</p><ul><li>绝对近址 32 位寻址</li><li>相对近址 32 位寻址</li></ul><p>x86 基本重定位类型</p><table><thead><tr><th>宏定义</th><th>值</th><th>重定位修正方法</th></tr></thead><tbody><tr><td>R_386_32</td><td>1</td><td>绝对寻址修正 S+A</td></tr><tr><td>R_386_PC32</td><td>2</td><td>相对寻址修正 S+A-P</td></tr></tbody></table><p>A = 保存在被修正位置的值<br>P = 被修正的位置 (相对于段开始的偏移量或者虚拟地址)，注意，该值可通过 r_offset 计算得到<br>S = 符号的实际地址，即由 <code>r_info</code>的高 24 位指定的符号的实际地址</p><h2 id="第六章-可执行文件的装载与进程"><a href="#第六章-可执行文件的装载与进程" class="headerlink" title="第六章 可执行文件的装载与进程"></a>第六章 可执行文件的装载与进程</h2><p>程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。</p><h3 id="COMMON-块"><a href="#COMMON-块" class="headerlink" title="COMMON 块"></a>COMMON 块</h3><blockquote><p>Q:在目标文件中，编译器为什么不直接把未初始化的全局变量也当做未初始化的局部静态变量一样处理，为它在 BSS 段分配空间，而是将其标记为一个 COMMON 类型的变量？<br>A:当编译器将一个编译单元编译成目标文件时，如果该编译单元包含了弱符号（未初始化的全局变量就是典型），那么该弱符号最终所占大小未知，因为有可能其他编译单元中该符号所占空间比当前的大所以编译器此时无法为该符号在 BSS 段分配空间。但链接器在链接过程中可以确定弱符号大小，因为当链接器读取所有输入目标文件后，任何一个弱符号大小都可以确定，所以它可以在最终输出文件的 BSS 段为其分配空间。总体来看，未初始化全局变量最终还是被放在 BSS 段。</p></blockquote><p>GCC 的<code>-fno-common</code>吧所有未初始化的全局变量不以 COMMON 块形式处理。</p><p><code>__attribute__</code>扩展也可以实现，<code>int global __attribute__((nocommon))</code>。这样未初始化的全局变量就是强符号。</p><blockquote><p>Q: 为什么静态运行库里面一个目标文件只包含一个函数？比如 libc.o 里面 printf.o 只包含 printf() 函数，strlen.o 只有 strlen 函数？<br>A:因为链接器在链接静态库时是以目标文件为单位的，比如我们引用了静态库中的 printf 函数，那么链接器就会把库中包含 printf 函数的那个目标文件链接进来，如果很多函数写在一个目标文件中，就将没用到的函数一起链接进了输出结果中。</p></blockquote><h3 id="链接的过程控制"><a href="#链接的过程控制" class="headerlink" title="链接的过程控制"></a>链接的过程控制</h3><h2 id="第-6-章-可执行文件的装载与进程"><a href="#第-6-章-可执行文件的装载与进程" class="headerlink" title="第 6 章 可执行文件的装载与进程"></a>第 6 章 可执行文件的装载与进程</h2><p>程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。</p><p><strong>可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件又被叫做映像文件 (Image)。</strong></p><p>Segment 和 Section  很难从中文翻译上区分，ELF 文件按 Section 存储的，从装载的角度 ELF 文件又可以按照 Segment 划分。</p><h4 id="段地址对齐"><a href="#段地址对齐" class="headerlink" title="段地址对齐"></a>段地址对齐</h4><p>可执行文件需要被装载，装载一般通过虚拟内存页映射机制完成，页是映射的最小单位，对于 x86 处理器来说，默认页大小为 4096 字节，所以内存空间的长度必须是 4096 的整数倍，并且这段空间在物理内存和进程虚拟地址空间的起始地址必须是 4096 的整数倍。</p><h2 id="第-7-章-动态链接"><a href="#第-7-章-动态链接" class="headerlink" title="第 7 章 动态链接"></a>第 7 章 动态链接</h2><h2 id="第七章-动态链接"><a href="#第七章-动态链接" class="headerlink" title="第七章 动态链接"></a>第七章 动态链接</h2><h3 id="为什么要动态链接？"><a href="#为什么要动态链接？" class="headerlink" title="为什么要动态链接？"></a>为什么要动态链接？</h3><ul><li>内存和磁盘空间：如果两个程序都用到一个静态库，链接时就会有静态库的两个副本，运行时就会占用两份内存。</li><li>程序的开发与发布：一个程序用到的静态库如果有更新，那么程序就需要重新链接，发布给用户。</li></ul><p>要解决以上问题，最简单的方法就是把程序的模块相互分割开来，形成独立的文件，而不再将它们静态链接。就是不对目标文件进行链接，而等到程序运行时再链接。这就是<strong>动态链接的基本思想</strong>。</p><p>动态链接模块的装载地址是从<code>0x00000000</code>开始的。</p><p>共享对象的最终装载地址在编译时是不确定的。</p><h3 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h3><p>静态共享库：将程序的各个模块交给操作系统管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。</p><p><strong>装载时重定位</strong>：程序在编译时被装载的目标地址为<code>0x1000</code>，但是在装载时操作系统发现<code>0x1000</code>这个地址已经被别的程序使用了，从<code>0x4000</code>开始有一块足够大的空间可以容纳，那么该程序就可以被装载至<code>0x4000</code>，程序指令和数据所有引用都只需要加上<code>0x3000</code>偏移量即可。因为他们在程序中的相对位置是不会改变的。</p><p>地址无关代码为了解决共享对象指令中对绝对地址的重定位问题，基本想法是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>模块中四类地址引用：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204092152653.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101004886.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101004869.png"></p><p><strong>模块内部调用或者跳转</strong><br>不需要重定位，本身就是地址无关的。</p><p><strong>模块内部数据访问</strong><br>指令中不能包含数据的绝对地址，所以使用相对寻址的方式。</p><p><strong>模块间数据访问</strong><br>把跟地址相关的部分放到数据段里面。ELF 的做法是在数据段里面建立一个指向这些数据的指针数据，称为<strong>全局偏移表</strong>（GOT）。当代码需要引用全局变量时，可以通过 GOT 间接引用。</p><p>链接器在装载时会查找每个变量的地址，填充 GOT 每个项，当指令中需要访问变量时，程序会先找到 GOT，根据 GOT 中对应的地址，找到对应的变量。GOT 本身放在数据段，所以他可以在模块装载时被修改，并且每个进程有独立副本，相互不影响。</p><p>以访问变量 b 为例，程序首先计算出变量 b 的地址在 GOT 中的位置，即</p><p><code>0x10000000 + 0x454 + 0x118c + 0xfffffff8 = 0x100015d8</code></p><p><code>0xfffffff8</code>为<code>-8</code>的补码表示，然后使用寄存器间接寻址方式给变量 b 赋值 2。</p><p><strong>模块间调用跳转</strong><br>类似于模块机数据访问，不同的是 GOT 中相应项保存的是目标函数的地址。</p><hr><p><strong>各种地址引用方式</strong></p><table><thead><tr><th></th><th>指令跳转，调用</th><th>数据访问</th></tr></thead><tbody><tr><td>模块内部</td><td>相对跳转和调用</td><td>相对地址访问</td></tr><tr><td>模块外部</td><td>间接跳转和调用（GOT）</td><td>间接访问（GOT）</td></tr></tbody></table><hr><blockquote><p>Q : -fpic 和-fPIC 的区别？<br>A: 都是 GCC 产生地址无关代码的参数。<code>-fpic</code>产生的代码较小，<code>-fPIC</code>产生的代码较大。因为地址无关代码和硬件平台相关，在一些平台上<code>-fpic</code>会受到限制，比如全局符号的数量或者代码长度等，而后者没有这样的限制。</p></blockquote><blockquote><p>Q: 如果一个共享对象 lib.so 中定义了一个全局变量 G，进程 A 和进程 B 都是用了 lib.so。那么当进程 A 改变这个全局变量时，进程 B 的 G 是否受到影响？<br>A: 不会，应当 lib.so 被加载时，它的数据段部分在每个进程都有独立的副本。如果是同一个进程里的线程 A 和线程 B，那么他们是共享数据 G 的。</p></blockquote><p>如果代码不是地址无关的，它就不能被多个进程共享，就失去了节省内存的优点。但是装载是重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数是需要做一次计算当前地址以及间接地址寻址的过程。</p><h3 id="延迟绑定-PLT"><a href="#延迟绑定-PLT" class="headerlink" title="延迟绑定 PLT"></a>延迟绑定 PLT</h3><p>动态链接要比静态链接慢，一是因为动态链接下，对全局和静态数据的访问都要进行复杂的 GOT 定位，然后间接寻址。另外，程序开始执行时，动态链接器都要进行一次链接工作。</p><p>而在一个程序运行过程中，可能很多函数在程序执行完时都不会用到，如果一开始就把所有函数链接好实际就是一种浪费，所有 ELF 采用了一种叫做延迟绑定的做法，基本思想就是当函数<strong>第一次使用时</strong>才进行绑定（符号查找，重定位等）。</p><p>ELF 使用 PLT（Procedure Linkage Table）来实现延迟绑定。以调用<code>bar()</code>函数为例，之前的做法是通过 GOT 中的相应项进行跳转，而延迟绑定下，在这过程中间加了一层 PLT 间接跳转。每个外部函数在 PLT 中都有一个对应项，比如<code>bar()</code>在 PLT 中项的地址为<code>bar@plt</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">bar</span>@<span class="hljs-selector-tag">plt</span>:<br>    <span class="hljs-selector-tag">jmp</span> *(bar<span class="hljs-variable">@GOT</span>)<br>    <span class="hljs-selector-tag">push</span> <span class="hljs-selector-tag">n</span><br>    <span class="hljs-selector-tag">push</span> <span class="hljs-selector-tag">moduleID</span><br>    <span class="hljs-selector-tag">jump</span> <span class="hljs-selector-tag">_dl_runtime_resolve</span><br></code></pre></td></tr></table></figure><p>第一条是指令通过 GOT 间接跳转的指令，如果链接器在初始化阶段已经初始化该项，并将<code>bar()</code>地址填入该项，那么就能正确跳转到<code>bar()</code>。但是为了延迟绑定，链接器初始化时并没有将<code>bar()</code>地址填入，而是将第二条指令<code>push n</code>的地址填入了<code>bar@GOT</code>中，这一步不需要查找符号，代价很低。</p><p>第一条指令的效果就是跳转到第二条指令，第二条指令将数字<code>n</code>压入堆栈，这个数字是<code>bar</code>这个符号引用在重定位表<code>.rel.plt</code>中的下标。第三条指令将模块 ID 压入堆栈，最后跳转到<code>_dl_runtime_resolve</code>。</p><p><code>_dl_runtime_resolve</code>进行一系列工作后将<code>bar()</code>真正地址填入到<code>bar@GOT</code>。</p><p>一旦<code>bar()</code>这个函数被解析完，当面再次调用<code>bar@plt</code>时，第一条<code>jump</code>指令就能跳转到<code>bar()</code>的真正地址。<code>bar()</code>函数返回时根据堆栈里保存的<code>EIP</code>直接返回到调用者，而不会执行<code>bar@plt</code>中第二条指令。<strong>那段代码只会在符号未被解析时执行一次</strong>。</p><p>PLT 在 ELF 文件中以独立段存在，段名通常叫做<code>.plt</code>，因为它本身是一些地址无关的代码，所以可以跟代码段合并成同一个可读可执行的 Segment 被装载入内存。</p><h3 id="动态链接相关结构"><a href="#动态链接相关结构" class="headerlink" title="动态链接相关结构"></a>动态链接相关结构</h3><p><strong>.interp 段</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">objdump</span> -s a.out<br><br><span class="hljs-attribute">Contents</span> of section .interp:<br><span class="hljs-attribute">804811</span> <span class="hljs-number">2</span>f<span class="hljs-number">6</span>c<span class="hljs-number">6962</span> <span class="hljs-number">2</span>f<span class="hljs-number">6</span>c<span class="hljs-number">696</span>d <span class="hljs-number">6</span>c<span class="hljs-number">696</span>e<span class="hljs-number">78</span> <span class="hljs-number">782</span>e<span class="hljs-number">736</span>f  /lib/ld-linux.so.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>里面保存的就是可执行文件所需要的动态链接器的路径，在 Linux 下，可执行文件动态链接器几乎都是<code>/lib/ld-linux.so.2</code>。</p><p>这是个软链接，会他会指向系统中安装的动态链接器。当系统中的 Glibc 库更新时，软链接也会指向新的动态链接器，所以<code>.interp</code>段不需要修改。</p><p>可以通过以下命令查看可执行文件需要的动态链接器的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ readelf -l a.out | grep interpreter<br>    [Requesting program interpreter: /lib/ld-linux.so.2]<br></code></pre></td></tr></table></figure><p><strong>.dynamic 段</strong></p><p>动态链接 ELF 中最重要的结构，这里保存了动态链接器所需要的基本信息，如依赖哪些共享对象，动态链接符号表的位置，动态链接重定位表的位置，共享对象初始化代码的地址等。</p><p><strong>动态符号表</strong></p><p><code>Program1</code>程序一来<code>Lib.so</code>，引用到了里面的<code>foobar()</code>函数，那么对于<code>Program1</code>来说，称<code>Program1</code>导入（Import）了<code>foobar</code>函数，<code>foobar</code>是<code>Program1</code>的导入函数。</p><p>而站在<code>Lib.so</code>角度来说，它定义了<code>foobar</code>函数，我们称<code>Lib.so</code>导出（Export）了<code>foobar</code>函数，<code>foobar</code>是<code>Lib.so</code>的导出函数。</p><p>为了表示动态链接这些模块之间的符号导入导出关系，ELF 专门有一个叫做动态符号表的段来保存这些信息，段名通常叫<code>.dynsym</code>。</p><p><code>.dynsym</code>只保存与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。</p><p><strong>动态链接重定位表</strong></p><p>PIC 模式的共享对象也需要重定位。</p><p>对于使用 PIC 技术的可执行文件或共享对象来说，虽然代码段不需要重定位，但是数据段还包含了绝对地址的引用，因为代码段中绝对地址相关的部分被分离出来，变成了 GOT，而 GOT 实际上是数据段的一部分。</p><p>目标文件的重定位在静态链接时完成，共享对象的重定位在装载时完成。</p><p>目标文件里包含专门用于重定位信息的重定位表，比如<code>.rel.text</code>表示是代码段重定位表，<code>.rel.data</code>表示数据段重定位表。</p><p>共享对象里类似的重定位表叫做<code>.rel.dyn</code>和<code>.rel.plt</code>。<code>.rel.dyn</code>实际上是对数据引用的修正，它所修正的位置位于<code>.got</code>以及数据段；<code>.rel.plt</code>实际上是对代码引用的修正，它所修正的位置位于<code>.got.plt</code>。</p><p>用以下命令可以查看重定位表；</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101958979.png"></p><p><code>printf</code>这个重定位入口，它的类型为<code>R_386_JUMP_SLOT</code>，它的偏移为<code>0x000015d8</code>。它实际位于<code>.got.plt</code>中，前三项是被系统占用的，第四项开始才是真正存放导入函数地址的地方，刚好是<code>0x000015c8 + 4 * 3 = 0x000015d4</code>，即<code>__gmon_start__</code>。</p><p>当动态链接器要进行重定位时，先查找<code>printf</code>的地址，假设链接器在全局符号表中找到<code>printf</code>的地址为<code>0x08801234</code>，那么链接器就会将这个地址填入<code>.got.plt</code>中偏移为<code>0x000015d8</code>的位置。<strong>从而实现了地址重定位，即动态链接最关键的一步</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204102010906.png"></p><h3 id="动态链接时进程堆栈初始化信息"><a href="#动态链接时进程堆栈初始化信息" class="headerlink" title="动态链接时进程堆栈初始化信息"></a>动态链接时进程堆栈初始化信息</h3><h3 id="动态链接的步骤和实现"><a href="#动态链接的步骤和实现" class="headerlink" title="动态链接的步骤和实现"></a>动态链接的步骤和实现</h3><p>动态链接分为三步：启动动态链接本身，装载所有的共享对象，重定位和初始化。</p><blockquote><p>Q：动态链接器本身是动态链接还是静态链接？<br>A：动态链接器本身应该是静态链接的，它不能依赖于其他共享对象，动态链接器本身使用来帮助其他 ELF 文件解决共享对象依赖问题的，如果它也依赖其他共享对象，那就陷入矛盾了。</p></blockquote><blockquote><p>Q：动态链接器本身必须是 PIC 的吗？<br>A：动态链接器可以是 PIC 的也可以不是，但是往往用 PIC 会简单一些。</p></blockquote><blockquote><p>Q：动态链接器可以被当做可执行文件运行，那么它的装载地址是多少？<br>A：ld.so 的装载地址跟一般的共享对象一样，即<code>0x00000000</code>。这个装载地址是一个无效的装载地址，作为一个共享库，内核在装载它时会为其选择一个合适的装载地址。</p></blockquote><h3 id="显示运行时链接"><a href="#显示运行时链接" class="headerlink" title="显示运行时链接"></a>显示运行时链接</h3><h2 id="第-10-章-内存"><a href="#第-10-章-内存" class="headerlink" title="第 10 章 内存"></a>第 10 章 内存</h2><h3 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h3><p>在 32 位操作系统里，有 4GB 的寻址能力，大部分操作系统会将一部分挪给内核使用，应用程序无法直接访问这段内存。这部分称为内核空间。Windows 默认将高地址的 2GB 分给内核，Linux 默认分 1GB 给内核。</p><p>剩下的称为用户空间，在用户空间里也有一些特殊的地址区间：</p><ul><li>栈：维护函数调用上下文，通常在用户空间的最高地址处分配。</li><li>堆：用来容纳程序动态分配的内存区域，当使用 malloc 或者 new 分配内存时，得到的内存来自于堆。通常在栈下方。</li><li>可执行文件映像：存储可执行文件再内存里的映像，由装载器在装载时将可执行文件的内存读取活映射到这里。</li><li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。比如<code>NULL</code>。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301614683.png"></p><h3 id="栈与调用惯例"><a href="#栈与调用惯例" class="headerlink" title="栈与调用惯例"></a>栈与调用惯例</h3><p>栈保存了一个函数调用所需要的维护信息，通常这被称为栈帧。一般包括如下几个方面：</p><ul><li>函数的返回地址和参数</li><li>临时变量</li><li>保存的上下文</li></ul><p>一个函数的调用流程：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301632031.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301632216.png"></p><p>I386 标准函数进入和退出指令序列，基本形式：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>, x<br>[<span class="hljs-keyword">push</span> reg1]<br>...<br>[<span class="hljs-keyword">push</span> regn]<br><br>函数实际内存<br><br>[<span class="hljs-keyword">pop</span> regn]<br>...<br>[<span class="hljs-keyword">pop</span> reg1]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><hr><p><strong>Hot Patch Prologue 热补丁</strong><br>在 Windows 函数里，有些函数尽管使用了标准的进入指令序列，但是在这些指令之前却插入了一些特殊内容：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">mov</span> <span class="hljs-keyword">edi</span>,<span class="hljs-keyword">edi</span><br></code></pre></td></tr></table></figure><p>这条指令没有任何用，在汇编之后会成为一个占用 2 字节的机器码，纯粹为了占位符而存在，使用这条指令开头的函数整体看起来是这样的：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-symbol">FUNCTION:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>,<span class="hljs-built_in">edi</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br></code></pre></td></tr></table></figure><p>其中 nop 占 1 个字节，也是占位符，FUNCTION 为一个标号，表示函数入口，本身不占空间。</p><p>设计成这样的函数在运行时可以很容易被其他函数替换掉，在上面的指令序列中调用的函数是 FUNCTION，但是我们可以做一些修改，可以在运行时刻意改成调用函数 REPLACEMENT_FUNCTION。首先在进程内存空间任意处写入 REPLACEMENT_FUNCTION 的定义：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">REPLACEMENT_FUNCTION:</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br>...<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>然后修改原函数的内容：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">LABEL:</span>         <span class="hljs-meta"># 标号不占字节</span><br><span class="hljs-keyword">jmp</span> REPLACEMENT_FUNCTION <span class="hljs-meta"># 占5字节，刚好五个nop</span><br><span class="hljs-symbol">FUNCTION:</span>      <span class="hljs-meta"># 函数入口标号，不占字节</span><br><span class="hljs-keyword">jmp</span> LABEL      <span class="hljs-meta"># 近跳指令，占2字节，跳跃到上方，即使截获失败也不影响原函数执行</span><br><span class="hljs-keyword">push</span> ebp<br><span class="hljs-keyword">mov</span> ebp, esp<br>...<br></code></pre></td></tr></table></figure><p>将 5 个<code>nop</code>换成一个<code>jmp</code>指令，然后将占用两个字节的<code>mov edi,edi</code>换成另一个<code>jmp</code>指令。因为这个<code>jmp</code>指令跳转的距离非常近，因此被汇编器翻译成了一个“近跳”指令，这种指令只占用两个字节。但<strong>只能跳跃到当前地址前后 127 个字节范围的目标位置</strong>。</p><p>这里的替换机制，可以实现一种叫做<em>钩子</em>（HOOK）的技术，允许用户在某时刻截获特定函数的调用。</p><hr><p>函数传递参数时压栈顺序，传递参数是寄存器传参还是栈传参等等都需要遵守一定的约定，否则函数将无法正确执行，这样的约定称为<strong>调用惯例</strong>。</p><p>一个调用惯例一般会规定如下几个方面：</p><ul><li>函数参数的传递顺序和方式<ul><li>调用方压栈，函数自己从栈用取参数</li><li>调用方压栈顺序：从左至右，还是从右至左？</li></ul></li><li>栈的维护方式<ul><li>参数出栈，可以由调用方完成还是由函数自己完成？</li></ul></li><li>名字修饰的策略<ul><li>为了链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰，不同调用惯例有不同的名字修饰策略</li><li>没有显示指定调用惯例的函数默认是<code>cdecl</code>惯例</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> _cdecl <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">float</span> m)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>_cdel 是非标准关键字，在不同编译器中写法不同，在 gcc 中使用的是<code>__attribute__((cdecl))</code></p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><table><thead><tr><th>英文名</th><th>Linux</th><th align="center">扩展名</th><th>英文名</th><th>Windows</th><th align="center">扩展名</th><th>功能</th></tr></thead><tbody><tr><td>DSO-Dynamic Shared Objects</td><td>ELF 动态链接文件，动态共享对象，共享对象</td><td align="center">.so</td><td>DLL-Dynamic Linking Library</td><td>动态链接库</td><td align="center">.dll</td><td>1111</td></tr><tr><td>Static Shared Library</td><td>静态共享库</td><td align="center">2222</td><td>2222</td><td>2222</td><td align="center">2222</td><td>2222</td></tr><tr><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td></tr><tr><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td></tr><tr><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td></tr></tbody></table><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZH-什么是 Die-to-Die 接口</title>
    <link href="/2022/03/28/ZH-%E4%BB%80%E4%B9%88%E6%98%AFDie-to-Die%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/03/28/ZH-%E4%BB%80%E4%B9%88%E6%98%AFDie-to-Die%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Die-to-Die-接口"><a href="#什么是-Die-to-Die-接口" class="headerlink" title="什么是 Die-to-Die 接口"></a>什么是 Die-to-Die 接口</h1><blockquote><p>Author：Synopsys<br>译：<a href="https://www.synopsys.com/glossary/what-is-die-to-die-interface.html">What is a Die-to-Die Interface? – How it Works | Synopsys</a></p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>裸片到裸片（Die2Die）接口是一个功能块，它提供组装在同一封装中的两个硅管芯之间的数据接口。芯片到芯片接口利用非常短的通道连接封装内的两个芯片，以实现功率效率和非常高的带宽效率，这超出了传统芯片到芯片接口所能达到的效果。</p><p>Die2Die 接口通常由 PHY 和控制器块组成，控制器块在两个 die 上的内部互连结构之间提供无缝连接。Die2Die 的 PHY 使用高速 SerDes 架构或高密度并行架构实现，经过优化以支持多种先进的 2D、2.5D 和 3D 封装技术。</p><p>Die2Die 接口是推动行业趋势从单片 SoC 设计转向同一封装中的多 Die SoC 组件的关键推动力。这种方法减轻了人们对小型工艺节点的高成本/低产量日益增长的担忧，并提供了额外的产品模块化和灵活性。</p><h2 id="Die-to-Die-接口如何工作？"><a href="#Die-to-Die-接口如何工作？" class="headerlink" title="Die-to-Die 接口如何工作？"></a>Die-to-Die 接口如何工作？</h2><p>Die2Die 的接口，就像任何其他芯片到芯片的接口一样，在两个芯片之间建立了可靠的数据链路。</p><p>接口在逻辑上分为物理层、链路层和事务层。它在芯片运行期间建立和维护链路，同时向应用程序提供连接到内部互连结构的标准化并行接口。</p><p>通过添加诸如前向纠错 (FEC) 和/或循环冗余码 (CRC) 和重试等错误检测和纠正机制来保证链路可靠性。</p><p>物理层架构可以是基于 SerDes 或基于并行的。</p><ul><li><p>基于 SerDes 的架构包括并行到串行（串行到并行）数据转换、阻抗匹配电路和时钟数据恢复或时钟转发功能。它可以支持更高带宽的 NRZ 信令或 PAM-4 信令，最高可达 112 Gbps。SerDes 架构的主要作用是尽量减少简单 2D 类型封装（如有机基板）中的 I/O 互连数量。</p></li><li><p>基于并行的架构包括许多并行的低速简单收发器，每个收发器都由驱动器和具有转发时钟技术的接收器组成，以进一步简化架构。它支持 DDR 类型的信令。并行架构的主要作用是最大限度地降低密集 2.5D 型封装（如硅中介层）的功耗。</p></li></ul><h2 id="Die2Die-的优势"><a href="#Die2Die-的优势" class="headerlink" title="Die2Die 的优势"></a>Die2Die 的优势</h2><p>现代芯片实现趋向于基于在封装中组装多个裸片以提高模块化和灵活性的解决方案。当（单片）芯片尺寸接近全光罩尺寸时，这种多管芯方法还通过将功能分成几个管芯来提高产量，从而促进更具成本效益的解决方案。</p><p>Die 之间的接口必须满足此类系统的所有关键要求：</p><ul><li><p><strong>电源效率</strong>。多芯片系统实现应该与等效的单片实现一样节能。Die2Die 链接使用短距离、低损耗的信道，没有明显的不连续性。PHY 架构利用良好的通道特性来降低 PHY 复杂性并节省功耗。</p></li><li><p><strong>低延迟</strong>。将服务器或加速器 SoC 划分为多个 Die 不应导致内存架构不统一，因为访问不同 Die 中的内存具有显着不同的延迟。Die2Die 接口实现了简化的协议，并直接连接到芯片互连结构，以最大限度地减少延迟。</p></li><li><p><strong>高带宽效率</strong>。高级服务器、加速器和网络交换机需要在 Die 之间传输大量数据。Die2Die 接口必须能够支持所有需要的带宽，同时减少 Die 边缘的占用。通常使用两种替代方案来实现此目标：通过以非常高的每通道数据速率（高达 112 Gbps）部署 PHY 来最小化所需通道的数量，或者通过使用更精细的凸块间距（微凸块）来增加 PHY 的密度) 在大量并行化以实现所需带宽的低数据速率通道（高达 8 Gbps/通道）上。</p></li><li><p><strong>健壮的链接</strong>。Die2Die 链接必须没有错误。该接口必须实现足够强大的低延迟错误检测和纠正机制，以检测所有错误并以低延迟纠正它们。这些机制通常包括 FEC 和重试协议。</p></li></ul><h2 id="Die-to-Die-接口用例"><a href="#Die-to-Die-接口用例" class="headerlink" title="Die-to-Die 接口用例"></a>Die-to-Die 接口用例</h2><p>通过将多个 Die 组合到一个封装中，小芯片提供了另一种扩展摩尔定律的方法，同时实现了产品模块化和工艺节点优化。小芯片用于计算密集型、工作负载繁重的应用程序，如高性能计算 (HPC)。</p><p>针对 HPC、网络、超大规模数据中心和人工智能 (AI) 等应用程序的 die-to-die 接口有四个主要用例：</p><h3 id="Scale-SoC"><a href="#Scale-SoC" class="headerlink" title="Scale SoC"></a>Scale SoC</h3><p>目标是通过虚拟（裸片到裸片）连接来连接裸片，从而提高计算能力并为服务器和 AI 加速器创建多个 SKU，从而实现裸片之间的紧密耦合性能。</p><h3 id="Split-SoC"><a href="#Split-SoC" class="headerlink" title="Split SoC"></a>Split SoC</h3><p>目标是启用非常大的 SoC。大型计算和网络交换机芯片正在接近光罩限制。将它们分成几个裸片会带来技术可行性、提高产量、降低成本并扩展摩尔定律。</p><h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><p>其目的是聚合在不同模具中实现的多种不同的功能，以利用每个功能的最佳工艺节点，降低功率，并改善 FPGA、汽车和 5G 基站等应用的外形尺寸。</p><h3 id="Disaggregate"><a href="#Disaggregate" class="headerlink" title="Disaggregate"></a>Disaggregate</h3><p>目标是将中央芯片与 I/O 芯片分离，以便将中央芯片轻松迁移到高级工艺，同时将 I/O 芯片保持在保守节点中，以降低产品演进的风险/成本，实现重用并缩短时间在服务器、FPGA、网络交换机和其他应用程序中投放市场。</p><h2 id="Die-to-Die-接口和-Synopsys"><a href="#Die-to-Die-接口和-Synopsys" class="headerlink" title="Die-to-Die 接口和 Synopsys"></a>Die-to-Die 接口和 Synopsys</h2><p>Synopsys 结合了广泛的 Die2Die 112G USR/XSR 和 HBI PHY IP、控制器 IP 和中介层专业知识产品组合，提供全面的 die-to-die IP 解决方案，以支持芯片拆分、芯片分解、计算扩展和聚合的功能。基于 SerDes 的 112G USR/XSR PHY 和基于并行的 8G OpenHBI PHY 可用于高级 FinFET 工艺。可配置控制器使用具有重放和可选 (FEC) 功能的纠错机制，以最大限度地降低可靠芯片到芯片链接的误码率。它支持用于连贯和非连贯数据通信的 Arm® 特定接口。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li>PHY 架构</li><li>SerDes 架构</li><li>reticle<br><a href="https://www.zhihu.com/question/457213984">LCD 厂掩膜版叫 Mask,Fab 里掩膜版叫 reticle，两者有什么区别？ - 知乎</a></li></ul><h2 id="原文参考"><a href="#原文参考" class="headerlink" title="原文参考"></a>原文参考</h2><p><a href="https://www.synopsys.com/glossary/what-is-die-to-die-interface.html">What is a Die-to-Die Interface? – How it Works | Synopsys</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Translation</tag>
      
      <tag>Die2Die</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 编译后的程序放到指定目录，屏蔽 qDebug 输出</title>
    <link href="/2022/03/18/Qt%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%B1%8F%E8%94%BDqDebug%E8%BE%93%E5%87%BA/"/>
    <url>/2022/03/18/Qt%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%B1%8F%E8%94%BDqDebug%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="可执行程序放到指定目录"><a href="#可执行程序放到指定目录" class="headerlink" title="可执行程序放到指定目录"></a>可执行程序放到指定目录</h2><p>默认情况下 QtCreator 会将编译链接后的可执行程序与中间生成的文件防盗<code>build-***-</code>文件中，如何能将可执行文件生成在指定目录？</p><p>修改<code>.pro</code>:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">CONFIG(<span class="hljs-builtin-name">debug</span> ,<span class="hljs-builtin-name">debug</span>|release)&#123;<br>    DESTDIR = <span class="hljs-built_in">..</span>/<span class="hljs-builtin-name">debug</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    DESTDIR = <span class="hljs-built_in">..</span>/release<br>&#125;<br></code></pre></td></tr></table></figure><p><code>debug</code>版本放在<code>../debug</code>目录中，<code>release</code>版本放在<code>../release</code>目录中。</p><h2 id="屏蔽-qDebug-输出"><a href="#屏蔽-qDebug-输出" class="headerlink" title="屏蔽 qDebug 输出"></a>屏蔽 qDebug 输出</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">CONFIG(<span class="hljs-builtin-name">debug</span> ,<span class="hljs-builtin-name">debug</span>|release)&#123;<br>    DEFINES -= QT_NO_DEBUG_OUTPUT<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    DEFINES += QT_NO_DEBUG_OUTPUT<br>&#125;<br></code></pre></td></tr></table></figure><p><code>QT_NO_DEBUG_OUTPUT</code>即为屏蔽 qDebug 输出的宏定义，可以在<code>debug</code>版本中不屏蔽 qDebug 输出，<code>release</code>版本中屏蔽 qDebug 输出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_35173114/article/details/81037315">QT 屏蔽 qDebug()、qWarning() 打印信息_qq_35173114 的博客-CSDN 博客_qwarning</a><br><a href="https://www.cxyzjd.com/article/amwha/115263253">QT 的 QDebug 无法输出日志_amwha 的专栏 - 程序员宅基地_qdebug 打印不出来 - 程序员宅基地</a><br><a href="https://blog.csdn.net/hebbely/article/details/66970821">Qt Creator 中的.pro 文件的详解_hebbely 的博客-CSDN 博客_qt 的 pro 文件</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU 源码分析-QOM</title>
    <link href="/2022/03/09/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-QOM/"/>
    <url>/2022/03/09/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-QOM/</url>
    
    <content type="html"><![CDATA[<h2 id="QOM-简介"><a href="#QOM-简介" class="headerlink" title="QOM 简介"></a>QOM 简介</h2><p>QOM(QEMU Object Model) 是 QEMU 的一个模块，用于描述虚拟机的结构，包括虚拟机的 CPU、内存、硬盘、网络、输入输出设备等。QEMU 为了方便整个系统的构建，实现了自己的一套的面向对象机制，也就是 QOM(QEMU Object Model)。它能够方便的表示各个设备（Device）与总线（Bus）之间的关系。</p><p>这个模型主要包含四个结构体：</p><ul><li>Object: 是所有对象的 基类 Base Object</li><li>ObjectClass: 是所有类对象的基类</li><li>TypeInfo：是用户用来定义一个 Type 的工具型的数据结构</li><li>TypeImpl：TypeInfo 抽象数据结构，TypeInfo 的属性与 TypeImpl 的属性对应</li></ul><p>在 QEMU 里要初始化一个对象需要完成四步：</p><ul><li>将 TypeInfo 注册 TypeImpl</li><li>实例化 Class（ObjectClass）</li><li>实例化 Object</li><li>添加 Property</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-09-19-4995177f1aeb782fadaf586f8f5c8b32-qemu-QOM%E5%88%86%E6%9E%90.drawio%20-2--1a4eac.png"></p><h2 id="QOM-中的面向对象"><a href="#QOM-中的面向对象" class="headerlink" title="QOM 中的面向对象"></a>QOM 中的面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 QEMU 中通过 <strong>TypeInfo</strong> 来定义一个类。</p><p>例如 <code>x86_base_cpu_type_info</code> 就是一个 <code>class</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_base_cpu_type_info = &#123;<br>        .name = X86_CPU_TYPE_NAME(<span class="hljs-string">&quot;base&quot;</span>),<br>        .parent = TYPE_X86_CPU,<br>        .class_init = x86_cpu_base_class_init,<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>利用结构体包含来实现继承</strong>。这应该是所有的语言实现继承的方法，在 C++ 中，结构体包含的操作被语言内部实现了，而 C 语言需要自己实现。</p><p>例如 <code>x86_cpu_type_info</code> 的 <code>parent</code> 是 <code>cpu_type_info</code>, 他们的结构体分别是 <code>X86CPU</code> 和 <code>CPUState</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_cpu_type_info = &#123;<br>    .name = TYPE_X86_CPU,<br>    .parent = TYPE_CPU,<br>  <span class="hljs-comment">// ...</span><br>    .instance_size = <span class="hljs-keyword">sizeof</span>(X86CPU),<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo cpu_type_info = &#123;<br>    .name = TYPE_CPU,<br>    .parent = TYPE_DEVICE,<br>  <span class="hljs-comment">// ...</span><br>    .instance_size = <span class="hljs-keyword">sizeof</span>(CPUState),<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>X86CPU</code> 中包含一个 <code>CPUState</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPU</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    CPUState parent_obj;<br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br><br>    CPUNegativeOffsetState neg;<br></code></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态成员变量可以在类的多个对象中访问，但是要在类外声明。<strong>不同对象访问的其实是同一个实体，静态成员变量被多个对象共享</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_cpu_type_info = &#123;<br>    .name = TYPE_X86_CPU,<br>    .parent = TYPE_CPU,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(X86CPU),<br>    .instance_init = x86_cpu_initfn,<br>    .instance_post_init = x86_cpu_post_initfn,<br><br>    .abstract = <span class="hljs-literal">true</span>,<br>    .class_size = <span class="hljs-keyword">sizeof</span>(X86CPUClass),<br>    .class_init = x86_cpu_common_class_init,<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中 <code>X86CPU</code> 描述的是非静态成员，而 <code>X86CPUClass</code> 描述的是静态的成员。也就是说<code>class_init</code>初始化静态成员，<code>instance_init</code>初始化非静态成员。</p><p>那么何时初始化静态成员呢？首先得告诉系统，咱有<code>class_init</code>这个初始化函数，等需要的时候随时可以调用它初始化，所有先解决如何将这个初始化函数注册到系统中？</p><p>在<code>target/i386/cpu.c</code>最后使用了<code>type_init</code>。在<code>qemu/include/qemu/module.h</code>中有一个<code>type_init</code>宏定义，除了<code>type_init</code>还有其他宏，比如<code>block_init</code>，<code>opts_init</code>等。每个宏都表示一类<code>module</code>，通过<code>module_init</code>构造出来。我们展开这个宏，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __attribute__((constructor))<br>do_qemu_init_x86_cpu_register_types(<span class="hljs-keyword">void</span>) &#123;<br>  register_module_init(x86_cpu_register_types, MODULE_INIT_QOM);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>gcc</code> 扩展属性<code>__attribute__((constructor))</code>可以让 <code>do_qemu_init_x86_cpu_register_types</code> 在运行 <code>main</code> 函数之前运行。 <code>register_module_init</code> 会让 <code>x86_cpu_register_types</code> 这个函数挂载到 <code>init_type_list[MODULE_INIT_QOM]</code> 这个链表上。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210907133931.svg"></p><p>到底，所有的 <code>TypeInfo</code> 通过 <code>type_init</code> 都被放到 <code>type_table</code> 上了，之后通过 <code>Typeinfo</code> 的名称调用 <code>type_table_lookup</code> 获取到 <code>TypeImpl</code> 了。</p><p>到这里，将<code>TYPE_X86_CPU</code>注册进类系统，包括其初始化函数，这部分也就是 QEMU 中类型的构造。那么何时调用静态成员初始化函数呢？也就是类型的初始化。</p><p>静态成员是所有的对象公用的，其初始化显然要发生在所有的对象初始化之前。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">main<br>    qemu_init <br>        select_machine <br>            object_class_get_list <br>                object_class_foreach <br>                    g_hash_table_foreach <br>                        object_class_foreach_tramp <br>                            type_initialize <br>                                type_initialize <br>                                    x86_cpu_common_class_init <br></code></pre></td></tr></table></figure><p><code>select_machine</code> 需要获取所有的 <code>TYPE_MACHINE</code> 的 <code>class</code>, 其首先会调用所有的<code>class_list</code>，其会遍历 <code>type_table</code>，遍历的过程中会顺带 <code>type_initialize</code> 所有的 <code>TypeImpl</code> 进而调用的 <code>class_init</code>。</p><p>说完类型的初始化，再讲一下对象的初始化，也就是初始化非静态成员，也就是<code>instance_init</code>在何时被调用？</p><p>对象初始化，通过调用 <code>object_new</code> 来实现初始化。</p><ul><li><code>object_initialize_with_type</code><ul><li>初始化一个空的 :<code>Object::properties</code></li><li><code>object_init_with_type</code><ul><li>如果 <code>object</code> 有 <code>parent</code>，那么调用 <code>object_init_with_type</code> 首先初始化 <code>parent</code> 的</li><li>调用<code>TypeImpl::instance_init</code></li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">main <br>    qemu_init <br>        qmp_x_exit_preconfig <br>            qemu_init_board <br>                machine_run_board_init <br>                    pc_init_v6_1 <br>                        pc_init1 <br>                            x86_cpus_init <br>                                x86_cpu_new <br>                                    object_new <br>                                        object_new_with_type <br>                                            object_initialize_with_type <br>                                                object_init_with_type <br>                                                    x86_cpu_initfn <br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。为了实现多态，QOM 实现了一个非常重要的功能，就是动态类型转换。我们可以使用相关的函数，将一个<code>Object</code>的指针在运行时转换为子类对象的指针，可以将一个<code>ObjectClass</code>的指针在运行时转换为子类的指针。这样就可以调用子类中定义的函数指针来完成相应的功能。</p><p>QEMU 定义了一些列的宏封来进行动态类型转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//include/qom/object.h</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_INSTANCE_CHECKER:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the instance type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED InstanceType * \</span><br><span class="hljs-meta">    OBJ_NAME(const void *obj) \</span><br><span class="hljs-meta">    &#123; return OBJECT_CHECK(InstanceType, obj, TYPENAME); &#125;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_CLASS_CHECKERS:</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the class type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED ClassType * \</span><br><span class="hljs-meta">    OBJ_NAME##_GET_CLASS(const void *obj) \</span><br><span class="hljs-meta">    &#123; return OBJECT_GET_CLASS(ClassType, obj, TYPENAME); &#125; \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED ClassType * \</span><br><span class="hljs-meta">    OBJ_NAME##_CLASS(const void *klass) \</span><br><span class="hljs-meta">    &#123; return OBJECT_CLASS_CHECK(ClassType, klass, TYPENAME); &#125;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_OBJ_CHECKERS:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the three standard type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_OBJ_CHECKERS(InstanceType, ClassType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @MODULE_OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro is typically used in a header file, and will:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   - create the typedefs for the object and class structs</span><br><span class="hljs-comment"> *   - register the type for use with g_autoptr</span><br><span class="hljs-comment"> *   - provide three standard type cast functions</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The object struct and class struct need to be declared manually.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_DECLARE_TYPE(InstanceType, ClassType, MODULE_OBJ_NAME) \</span><br><span class="hljs-meta">    typedef struct InstanceType InstanceType; \</span><br><span class="hljs-meta">    typedef struct ClassType ClassType; \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    G_DEFINE_AUTOPTR_CLEANUP_FUNC(InstanceType, object_unref) \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    DECLARE_OBJ_CHECKERS(InstanceType, ClassType, \</span><br><span class="hljs-meta">                         MODULE_OBJ_NAME, TYPE_##MODULE_OBJ_NAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT:</span><br><span class="hljs-comment"> * @obj: A derivative of #Object</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Converts an object to a #Object.  Since all objects are #Objects,</span><br><span class="hljs-comment"> * this function will always succeed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT(obj) \</span><br><span class="hljs-meta">    ((Object *)(obj))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CLASS:</span><br><span class="hljs-comment"> * @class: A derivative of #ObjectClass.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Converts a class to an #ObjectClass.  Since all objects are #Objects,</span><br><span class="hljs-comment"> * this function will always succeed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CLASS(class) \</span><br><span class="hljs-meta">    ((ObjectClass *)(class))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CHECK:</span><br><span class="hljs-comment"> * @type: The C type to use for the return value.</span><br><span class="hljs-comment"> * @obj: A derivative of @type to cast.</span><br><span class="hljs-comment"> * @name: The QOM typename of @type</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A type safe version of @object_dynamic_cast_assert.  Typically each class</span><br><span class="hljs-comment"> * will define a macro based on this type to perform type safe dynamic_casts to</span><br><span class="hljs-comment"> * this object type.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If an invalid object is passed to this function, a run time assert will be</span><br><span class="hljs-comment"> * generated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CHECK(type, obj, name) \</span><br><span class="hljs-meta">    ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \</span><br><span class="hljs-meta">                                        __FILE__, __LINE__, __func__))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CLASS_CHECK:</span><br><span class="hljs-comment"> * @class_type: The C type to use for the return value.</span><br><span class="hljs-comment"> * @class: A derivative class of @class_type to cast.</span><br><span class="hljs-comment"> * @name: the QOM typename of @class_type.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A type safe version of @object_class_dynamic_cast_assert.  This macro is</span><br><span class="hljs-comment"> * typically wrapped by each type to perform type safe casts of a class to a</span><br><span class="hljs-comment"> * specific class type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CLASS_CHECK(class_type, class, name) \</span><br><span class="hljs-meta">    ((class_type *)object_class_dynamic_cast_assert(OBJECT_CLASS(class), (name), \</span><br><span class="hljs-meta">                                               __FILE__, __LINE__, __func__))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_GET_CLASS:</span><br><span class="hljs-comment"> * @class: The C type to use for the return value.</span><br><span class="hljs-comment"> * @obj: The object to obtain the class for.</span><br><span class="hljs-comment"> * @name: The QOM typename of @obj.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function will return a specific class for a given object.  Its generally</span><br><span class="hljs-comment"> * used by each type to provide a type safe macro to get a specific class type</span><br><span class="hljs-comment"> * from an object.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_GET_CLASS(class, obj, name) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(class, object_get_class(OBJECT(obj)), name)</span><br><br></code></pre></td></tr></table></figure><p>以<code>OBJECT_DECLARE_TYPE(X86CPU, X86CPUClass, X86_CPU)</code>为例，宏展开如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPU</span> <span class="hljs-title">X86CPU</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPUClass</span> <span class="hljs-title">X86CPUClass</span>;</span><br>G_DEFINE_AUTOPTR_CLEANUP_FUNC(X86CPU, object_unref)<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPU *<span class="hljs-title">X86_CPU</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPU *)object_dynamic_cast_assert(<br>      ((Object *)(obj)), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPUClass *<span class="hljs-title">X86_CPU_GET_CLASS</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPUClass *)object_class_dynamic_cast_assert(<br>      ((ObjectClass *)(object_get_class(((Object *)(obj))))), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPUClass *<span class="hljs-title">X86_CPU_CLASS</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *klass)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPUClass *)object_class_dynamic_cast_assert(<br>      ((ObjectClass *)(klass)), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>OBJECT_DECLARE_TYPE</code>通常在头文件中使用，效果是：</p><ul><li>创建了<code>X86CPU</code>和<code>X86CPUClass</code>的<code>typedef</code></li><li>用<code>G_DEFINE_AUTOPTR_CLEANUP_FUNC</code>注册类型</li><li>创建了三个类型转换函数<ul><li><code>X86_CPU</code> : 将任何一个 <code>object</code> 指针 转换为 <code>X86CPU</code>（Object 转子对象）</li><li><code>X86_CPU_GET_CLASS</code> : 根据 <code>object</code> 指针获取到 <code>X86CPUClass</code></li><li><code>X86_CPU_CLASS</code> : 根据 <code>ObjectClass</code> 指针转换到 <code>X86CPUClass</code>（基类转子类）</li></ul></li></ul><p>这里的转换依赖内存布局，子类型的第一个成员总是基类型。子类转基类就很容易，只需要强制类型转换就可以实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://martins3.github.io/qemu/qom.html#init">QEMU 中的面向对象 : QOM | Deep Dark Fantasy</a><br><a href="https://www.jianshu.com/p/4a9d26abb44d">浅谈 QEMU 的对象系统 - 简书</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU 源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RGB 与 YUV 颜色空间</title>
    <link href="/2022/03/01/RGB%E4%B8%8EYUV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/03/01/RGB%E4%B8%8EYUV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>RGB 和 YUV 都属于一种颜色编码方式，或者说颜色空间。</p><p>RGB 色彩模式是工业界的一种颜色标准，是通过对红、绿、蓝三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB 即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。</p><p>在 YUV 空间中，Y 代表亮度，其实 Y 就是图像的灰度值；UV 代表色差，U 和 V 是构成彩色的两个分量。在现代彩色电视系统中，通常采用三管彩色摄影机或彩色 CCD 摄影机进行取像，然后把取得的彩色图像信号经分色、分别放大校正后得到 RGB，再经过矩阵变换电路得到亮度信号 Y 和两个色差信号 B–Y(即 U)、R–Y(即 V)，最后发送端将亮度和色差三个信号分别进行编码，用同一信道发送出去。这种色彩的表示方法就是所谓的 YUV 色彩空间表示。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="RGB-格式"><a href="#RGB-格式" class="headerlink" title="RGB 格式"></a>RGB 格式</h3><h4 id="RGB16"><a href="#RGB16" class="headerlink" title="RGB16"></a>RGB16</h4><p>RGB16 数据格式主要有二种：RGB565 和 RGB555。</p><p>RGB565，每个像素用 16 比特位表示，占 2 个字节，RGB 分量分别使用 5 位、6 位、5 位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//获取高字节的5个bit</span><br>R = color &amp; <span class="hljs-number">0xF800</span>;<br><span class="hljs-comment">//获取中间6个bit</span><br>G = color &amp; <span class="hljs-number">0x07E0</span>;<br><span class="hljs-comment">//获取低字节5个bit</span><br>B = color &amp; <span class="hljs-number">0x001F</span>;<br></code></pre></td></tr></table></figure><p>RGB555，每个像素用 16 比特位表示，占 2 个字节，RGB 分量都使用 5 位 (最高位不用)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//获取高字节的5个bit</span><br>R = color &amp; <span class="hljs-number">0x7C00</span>;<br><span class="hljs-comment">//获取中间5个bit</span><br>G = color &amp; <span class="hljs-number">0x03E0</span>;<br><span class="hljs-comment">//获取低字节5个bit</span><br>B = color &amp; <span class="hljs-number">0x001F</span>;<br></code></pre></td></tr></table></figure><h4 id="RGB24"><a href="#RGB24" class="headerlink" title="RGB24"></a>RGB24</h4><p>RGB24 图像每个像素用 24 比特位表示，占 3 个字节，注意：在内存中 RGB 各分量的排列顺序为：<strong>BGR BGR BGR</strong>。</p><h4 id="RGB32"><a href="#RGB32" class="headerlink" title="RGB32"></a>RGB32</h4><p>RGB32 图像每个像素用 32 比特位表示，占 4 个字节，R，G，B 分量分别用 8 个 bit 表示，存储顺序为 B，G，R，最后 8 个字节保留。注意：在内存中 RGB 各分量的排列顺序为：<strong>BGRA BGRA BGRA</strong> ……。</p><p>本质就是带 alpha 通道的 RGB24，与 RGB32 的区别在与，保留的 8 个 bit 用来表示透明，也就是 alpha 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">R = color &amp; <span class="hljs-number">0x0000FF00</span>;<br>G = color &amp; <span class="hljs-number">0x00FF0000</span>;<br>B = color &amp; <span class="hljs-number">0xFF000000</span>;<br>A = color &amp; <span class="hljs-number">0x000000FF</span>;<br></code></pre></td></tr></table></figure><h3 id="YUV-采样"><a href="#YUV-采样" class="headerlink" title="YUV 采样"></a>YUV 采样</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220301170332.png"></p><ul><li>YUV444：一个像素就有 YUV 三个值，和 RGB 类似；一个 YUV 占 8+8+8 = 24bits 3 个字节。</li><li>YUV422：第一个像素有 YUV 三个值，第二个像素只有 Y，与前一个像素共用 UV；一个 YUV 占 8+4+4 = 16bits 2 个字节。</li><li>YUV420：上下四个像素共用一个 UV。一个 YUV 占 8+2+2 = 12bits 1.5 个字节。</li></ul><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="YUV2RGB"><a href="#YUV2RGB" class="headerlink" title="YUV2RGB"></a>YUV2RGB</h3><p>$$<br>R = Y + 1.403 \times (V-128)\<br>G=Y-0.343 \times (U-128) - 0.714 \times (V-128)\<br>B=Y + 1.770 \times (U-128)<br>$$</p><h3 id="RGB2YUV"><a href="#RGB2YUV" class="headerlink" title="RGB2YUV"></a>RGB2YUV</h3><p>$$<br>Y = 0.299 \times R + 0.587 \times G + 0.114 \times B\<br>U = -0.169 \times R - 0.331 \times G + 0.500 \times B + 128\<br>V = 0.500 \times R - 0.419 \times G - 0.081 \times B + 128\<br>$$</p><p>浮点型运算比较耗时，将所有运算换成位运算，提高效率。具体推倒过程见<a href="https://blog.csdn.net/weixin_40647819/article/details/92619298">色彩转换系列之 RGB 格式与 YUV 格式互转原理及实现_小武的博客-CSDN 博客_rgb yuv</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">Y= ((R &lt;&lt; <span class="hljs-number">6</span>) + (R &lt;&lt; <span class="hljs-number">3</span>) + (R &lt;&lt; <span class="hljs-number">2</span>) + R + (G &lt;&lt; <span class="hljs-number">7</span>) + (G &lt;&lt; <span class="hljs-number">4</span>) + (G &lt;&lt; <span class="hljs-number">2</span>) + (G &lt;&lt; <span class="hljs-number">1</span>) + (B &lt;&lt; <span class="hljs-number">4</span>) + (B &lt;&lt; <span class="hljs-number">3</span>) + (B &lt;&lt; <span class="hljs-number">2</span>) + B) &gt;&gt; <span class="hljs-number">8</span><br>U= (-((R &lt;&lt; <span class="hljs-number">5</span>) + (R &lt;&lt; <span class="hljs-number">3</span>) + (R &lt;&lt; <span class="hljs-number">1</span>)+ R) - ((G &lt;&lt; <span class="hljs-number">6</span>) + (G &lt;&lt; <span class="hljs-number">4</span>) + (G &lt;&lt; <span class="hljs-number">2</span>)+G) + (B &lt;&lt; <span class="hljs-number">7</span>) + <span class="hljs-number">32768</span>) &gt;&gt; <span class="hljs-number">8</span><br>V= ((R &lt;&lt; <span class="hljs-number">7</span>) - ((G &lt;&lt; <span class="hljs-number">6</span>) + (G &lt;&lt; <span class="hljs-number">5</span>) + (G &lt;&lt; <span class="hljs-number">3</span>) + (G &lt;&lt; <span class="hljs-number">3</span>) + G) - ((B &lt;&lt; <span class="hljs-number">4</span>) + (B &lt;&lt; <span class="hljs-number">2</span>) + B) + <span class="hljs-number">32768</span> )&gt;&gt; <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/cd7e73005ac4">RGB 和 YUV - 简书</a><br><a href="https://blog.csdn.net/fengbingchun/article/details/50216901">颜色空间 YUV 简介_网络资源是无限的-CSDN 博客_yuv 颜色空间</a><br><a href="https://blog.csdn.net/byhook/article/details/84262330">图解 RGB565、RGB555、RGB16、RGB24、RGB32、ARGB32 等格式的区别_handy 周-CSDN 博客_rgb565</a><br><a href="https://blog.csdn.net/byhook/article/details/84037338">图解 YU12、I420、YV12、NV12、NV21、YUV420P、YUV420SP、YUV422P、YUV444P 的区别_handy 周-CSDN 博客_yv12</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-指令和运算</title>
    <link href="/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/"/>
    <url>/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机指令"><a href="#计算机指令" class="headerlink" title="计算机指令"></a>计算机指令</h2><p>上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0 表示不打孔，1 表示打孔），送入特殊的计算机中执行。</p><p>从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。</p><p>从软件的角度来看，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作<strong>机器语言</strong>（Machine Language）。</p><p>不同的 CPU 能够听懂的语言不太一样。也就是 CPU 支持的语言不一样，这里的语言叫<strong>指令集</strong>（Instruction Set）。</p><p>一个计算机程序由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作<strong>存储程序型计算机</strong>（Stored-program Computer）。</p><p>了解了计算机指令和计算机指令集，接下来我们来看看，平时编写的代码，到底是怎么变成一条条计算机指令，最后被 CPU 执行的呢？我们拿一小段真实的 C 语言程序来看看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; <br>  <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>  a = a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过编译器，可以将上述代码编译成汇编代码，再通过汇编器，将汇编代码编译成机器码，最后通过 CPU 执行。</p><p>在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -g -c test.c<br>$ objdump -d -M intel -S test.o<br><br>test.o:     file format elf64-x86-64<br>Disassembly of section .text:<br>0000000000000000 &lt;main&gt;:<br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br>   0:   55                      push   rbp<br>   1:   48 89 e5                mov    rbp,rsp<br>  int a = 1; <br>   4:   c7 45 <span class="hljs-built_in">fc</span> 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1<br>  int b = 2;<br>   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2<br>  a = a + b;<br>  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]<br>  15:   01 45 <span class="hljs-built_in">fc</span>                add    DWORD PTR [rbp-0x4],eax<br>&#125;<br>  18:   5d                      pop    rbp<br>  19:   c3                      ret    <br></code></pre></td></tr></table></figure><p>左侧有一堆数字，这些就是一条条机器码；右边有一系列的<code>push</code>、<code>mov</code>、<code>add</code>、<code>pop</code> 等，这些就是对应的汇编代码。</p><p>了解了这个过程，下面我们放大局部，来看看这一行行的汇编代码和机器指令，到底是什么意思。</p><p>常见的指令可以分成五大类。</p><p>第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。</p><p>第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。</p><p>第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。</p><p>第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。</p><p>最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。</p><h2 id="指令跳转"><a href="#指令跳转" class="headerlink" title="指令跳转"></a>指令跳转</h2><h3 id="CPU-如何执行指令的"><a href="#CPU-如何执行指令的" class="headerlink" title="CPU 如何执行指令的"></a>CPU 如何执行指令的</h3><p>代码经过软件层面的编译后就是一条条二进制指令，指令交由 CPU 中几百亿个晶体管去执行。我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。而寄存器就是 CPU 内部，由多个<strong>触发器</strong>（Flip-Flop）或者<strong>锁存器</strong>（Latches）组成的简单电路。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。</p><p><code>N</code> 个触发器或者锁存器，就可以组成一个<code>N</code>位（Bit）的寄存器，能够保存 <code>N</code>位的数据。比方说，我们用的<code>64</code>位 <code>Intel</code>服务器，寄存器就是<code>64</code> 位的。</p><p>一个 CPU 里面会有很多种不同功能的寄存器。这里介绍三种比较特殊的。</p><ul><li><p>PC 寄存器（Program Counter Register），我们也叫<strong>指令地址寄存器</strong>（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。</p></li><li><p>指令寄存器（Instruction Register），用来存放当前正在执行的指令。</p></li><li><p>条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。</p></li></ul><p>除此之外还有<strong>整数寄存器</strong>、<strong>浮点数寄存器</strong>、<strong>向量寄存器</strong>和<strong>地址寄存器</strong>等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。</p><p>实际上，一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。</p><p>而有些特殊指令，比如上一讲我们讲到 <code>J</code> 类指令，也就是跳转指令，会修改 PC 寄存器里面的地址值。</p><h3 id="从-if…else-来看程序的执行和跳转"><a href="#从-if…else-来看程序的执行和跳转" class="headerlink" title="从 if…else 来看程序的执行和跳转"></a>从 if…else 来看程序的执行和跳转</h3><p>首先看如下的例程，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  srand(time(<span class="hljs-literal">NULL</span>));<br>  <span class="hljs-keyword">int</span> r = rand() % <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>)<br>  &#123;<br>    a = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    a = <span class="hljs-number">2</span>;<br>  &#125; <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g -c test.c<br>objdump -d -M intel -S test.o <br></code></pre></td></tr></table></figure><p>编译后打印出汇编代码如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">if (r == <span class="hljs-number">0</span>)<br> 3b:   <span class="hljs-number">83</span> <span class="hljs-number">7d</span> fc <span class="hljs-number">00</span>             <span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>],<span class="hljs-number">0x0</span><br> 3f:   <span class="hljs-number">75</span> <span class="hljs-number">09</span>                   <span class="hljs-keyword">jne</span>    4a &lt;main+<span class="hljs-number">0x4a</span>&gt;<br>   &#123;<br>       a = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br> <span class="hljs-number">41</span>:   c7 <span class="hljs-number">45</span> f8 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>],<span class="hljs-number">0x1</span><br> <span class="hljs-number">48</span>:   eb <span class="hljs-number">07</span>                   <span class="hljs-keyword">jmp</span>    <span class="hljs-number">51</span> &lt;main+<span class="hljs-number">0x51</span>&gt;<br>   &#125;<br>   else<br>   &#123;<br>       a = <span class="hljs-number">2</span><span class="hljs-comment">;</span><br> 4a:   c7 <span class="hljs-number">45</span> f8 <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>],<span class="hljs-number">0x2</span><br> <span class="hljs-number">51</span>:   b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0</span><br>   &#125; <br></code></pre></td></tr></table></figure><p>可以看到，这里对于 <code>r == 0</code>的条件判断，被编译成了 cmp 和 jne 这两条指令。</p><p><code>cmp</code> 指令比较了前后两个操作数的值，这里的<code>DWORD PTR</code> 代表操作的数据类型是 <code>32</code>位的整数，而 <code>[rbp-0x4]</code> 则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量 <code>r</code> 的值。第二个操作数 <code>0x0</code> 就是我们设定的常量<code>0</code>的 <code>16</code> 进制表示。<code>cmp</code> 指令的比较结果，会存入到条件码寄存器当中去。</p><p>在这里，如果比较的结果是 <code>True</code>，也就是 <code>r == 0</code>，就把零标志条件码（对应的条件码是 <code>ZF</code>，<code>Zero Flag</code>）设置为 <code>1</code>。除了零标志之外，<code>Intel</code> 的 <code>CPU</code> 下还有进位标志（<code>CF</code>，<code>Carry Flag</code>）、符号标志（<code>SF</code>，<code>Sign Flag</code>）以及溢出标志（<code>OF</code>，<code>Overflow Flag</code>），用在不同的判断条件下。</p><p><code>cmp</code> 指令执行完成之后，<code>PC</code> 寄存器会自动自增，开始执行下一条 <code>jne</code> 的指令。</p><p>跟着的 <code>jne</code> 指令，是 <code>jump if not equal</code> 的意思，它会查看对应的零标志位。如果为<code>0</code>，会跳转到后面跟着的操作数 <code>4a</code> 的位置。这个 <code>4a</code>，对应这里汇编代码的行号，也就是上面设置的 <code>else</code> 条件里的第一条指令。当跳转发生的时候，<code>PC</code> 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 <code>4a</code> 这个地址。这个时候，<code>CPU</code> 再把 <code>4a</code> 地址里的指令加载到指令寄存器中来执行。</p><p>跳转到执行地址为 <code>4a</code> 的指令，实际是一条 <code>mov</code> 指令，第一个操作数和前面的 <code>cmp</code> 指令一样，是另一个 <code>32</code> 位整型的寄存器地址，以及对应的 <code>2</code> 的<code>16</code> 进制值 <code>0x2</code>。<code>mov</code> 指令把 <code>2</code> 设置到对应的寄存器里去，相当于一个赋值操作。然后，<code>PC</code>寄存器里的值继续自增，执行下一条 <code>mov</code> 指令。</p><p>这条 <code>mov</code> 指令的第一个操作数<code>eax</code>，代表累加寄存器，第二个操作数<code>0x0</code>则是 <code>16</code> 进制的<code>0</code>的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的 <code>if</code> 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 <code>jmp</code> 的无条件跳转指令。跳转的地址就是这一行的地址<code>51</code>。我们的 <code>main</code> 函数没有设定返回值，而<code>mov eax</code>, <code>0x0</code> 其实就是给 <code>main</code> 函数生成了一个默认的为 <code>0</code> 的返回值到累加器里面。<code>if</code> 条件里面的内容执行完成之后也会跳转到这里，和 <code>else</code> 里的内容结束之后的位置是一样的。</p><h2 id="函数调用：为什么会发生-Stack-Overflow"><a href="#函数调用：为什么会发生-Stack-Overflow" class="headerlink" title="函数调用：为什么会发生 Stack Overflow"></a>函数调用：为什么会发生 Stack Overflow</h2><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>既然我们的程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在 Linux 下可以运行，而在 Windows 下却不行呢？反过来，Windows 上的程序在 Linux 上也是一样不能执行的。可是我们的 CPU 并没有换掉，它应该可以识别同样的指令呀？</p><p>将以下两个例程编译，然后通过 objdump 命令看看它们的汇编代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// add_lib.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-comment">// link_example.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> c = add(a, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %d\n&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g -c add_lib.c link_example.c<br>objdump -d -M intel -S add_lib.o<br>objdump -d -M intel -S link_example.o<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">add_lib.o:</span>     file format elf64-x86-<span class="hljs-number">64</span><br>Disassembly of <span class="hljs-meta">section</span> .text:<br><span class="hljs-number">0000000000000000</span> &lt;<span class="hljs-keyword">add</span>&gt;:<br>   <span class="hljs-number">0</span>:   <span class="hljs-number">55</span>                      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbp</span><br>   <span class="hljs-number">1</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbp</span>,<span class="hljs-built_in">rsp</span><br>   <span class="hljs-number">4</span>:   <span class="hljs-number">89</span> <span class="hljs-number">7d</span> fc                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>],<span class="hljs-built_in">edi</span><br>   <span class="hljs-number">7</span>:   <span class="hljs-number">89</span> <span class="hljs-number">75</span> f8                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>],<span class="hljs-built_in">esi</span><br><span class="hljs-symbol">   a:</span>   8b <span class="hljs-number">55</span> fc                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>]<br><span class="hljs-symbol">   d:</span>   8b <span class="hljs-number">45</span> f8                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>]<br>  <span class="hljs-number">10</span>:   <span class="hljs-number">01</span> d0                   <span class="hljs-keyword">add</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">edx</span><br>  <span class="hljs-number">12</span>:   <span class="hljs-number">5d</span>                      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rbp</span><br>  <span class="hljs-number">13</span>:   c3                      <span class="hljs-keyword">ret</span>    <br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">link_example</span>.o:     file format elf<span class="hljs-number">64</span>-x<span class="hljs-number">86</span>-<span class="hljs-number">64</span><br><span class="hljs-attribute">Disassembly</span> of section .text:<br><span class="hljs-attribute">0000000000000000</span> &lt;main&gt;:<br>   <span class="hljs-attribute">0</span>:   <span class="hljs-number">55</span>                      push   rbp<br>   <span class="hljs-attribute">1</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e<span class="hljs-number">5</span>                mov    rbp,rsp<br>   <span class="hljs-attribute">4</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>             sub    rsp,<span class="hljs-number">0</span>x<span class="hljs-number">10</span><br>   <span class="hljs-attribute">8</span>:   c<span class="hljs-number">7</span> <span class="hljs-number">45</span> fc <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    mov    DWORD PTR<span class="hljs-meta"> [rbp-0x4],0xa</span><br><span class="hljs-meta">   f:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5</span><br><span class="hljs-meta">  16:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]</span><br>  <span class="hljs-attribute">19</span>:   <span class="hljs-number">8</span>b <span class="hljs-number">45</span> fc                mov    eax,DWORD PTR<span class="hljs-meta"> [rbp-0x4]</span><br>  <span class="hljs-attribute">1c</span>:   <span class="hljs-number">89</span> d<span class="hljs-number">6</span>                   mov    esi,edx<br>  <span class="hljs-attribute">1e</span>:   <span class="hljs-number">89</span> c<span class="hljs-number">7</span>                   mov    edi,eax<br>  <span class="hljs-attribute">20</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    eax,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><br>  <span class="hljs-attribute">25</span>:   e<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          call   <span class="hljs-number">2</span>a &lt;main+<span class="hljs-number">0</span>x<span class="hljs-number">2</span>a&gt;<br>  <span class="hljs-attribute">2a</span>:   <span class="hljs-number">89</span> <span class="hljs-number">45</span> f<span class="hljs-number">4</span>                mov    DWORD PTR<span class="hljs-meta"> [rbp-0xc],eax</span><br><span class="hljs-meta">  2d:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]</span><br>  <span class="hljs-attribute">30</span>:   <span class="hljs-number">89</span> c<span class="hljs-number">6</span>                   mov    esi,eax<br>  <span class="hljs-attribute">32</span>:   <span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">3</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    lea    rdi,[rip+<span class="hljs-number">0</span>x<span class="hljs-number">0</span>]        # <span class="hljs-number">39</span> &lt;main+<span class="hljs-number">0</span>x<span class="hljs-number">39</span>&gt;<br>  <span class="hljs-attribute">39</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    eax,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><br>  <span class="hljs-attribute">3e</span>:   e<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          call   <span class="hljs-number">43</span> &lt;main+<span class="hljs-number">0</span>x<span class="hljs-number">43</span>&gt;<br>  <span class="hljs-attribute">43</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    eax,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><br>  <span class="hljs-attribute">48</span>:   c<span class="hljs-number">9</span>                      leave  <br>  <span class="hljs-attribute">49</span>:   c<span class="hljs-number">3</span>                      ret    <br></code></pre></td></tr></table></figure><p>既然代码已经被我们“编译”成了指令，我们不妨尝试运行一下 <code>./link_example.o</code>。</p><p>然而我们并不能成功运行，会得到一条<code>cannot execute binary file: Exec format error</code> 的错误。</p><p>我们再仔细看一下 objdump 出来的两个文件的代码，<strong>会发现两个程序的地址都是从 0 开始的</strong>。如果地址是一样的，程序如果需要通过 <code>call</code> 指令调用函数的话，<strong>它怎么知道应该跳转到哪一个文件里呢？</strong></p><p>无论是这里的运行报错，还是 <code>objdump</code> 出来的汇编代码里面的重复地址，都是因为<code>add_lib.o</code>以及 <code>link_example.o</code> 并不是一个可执行文件（Executable Program），而是目标文件（Object File）。<strong>只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。</strong></p><p>通过 <code>gcc</code> 的<code>-o</code>参数，可以生成对应的可执行文件。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>gcc -o link-example add_lib.o link_example.o<br><span class="hljs-variable">$ </span>./link_example<br>c = <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203032207712.png"></p><p>链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203032209801.png"></p><p>在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。</p><p>为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。其中一个非常重要的原因就是，<strong>两个操作系统下可执行文件的格式不一样</strong>。</p><p>我们今天讲的是 Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作 PE（Portable Executable Format）的文件格式。<strong>Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。</strong></p><p>如果我们有一个可以能够解析 PE 格式的装载器，我们就有可能在 Linux 下运行 Windows 程序了。这样的程序真的存在吗？没错，Linux 下著名的开源项目 Wine，就是通过兼容 PE 格式的装载器，使得我们能直接在 Linux 下运行 Windows 程序的。而现在微软的 Windows 里面也提供了 WSL，也就是 Windows Subsystem for Linux，可以解析和加载 ELF 格式的文件。</p><h2 id="程序装载"><a href="#程序装载" class="headerlink" title="程序装载"></a>程序装载</h2><h4 id="程序装载面临的挑战"><a href="#程序装载面临的挑战" class="headerlink" title="程序装载面临的挑战"></a>程序装载面临的挑战</h4><ul><li>可执行程序加载后占用的内存空间应该是连续的。<br>  这点很好理解，指令正常都是顺序执行的。</li><li>我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。<br>  计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用了。</li></ul><p>我们把指令里用到的内存地址叫作<strong>虚拟内存地址</strong>（Virtual Memory Address），实际在内存硬件里面的空间地址，我们叫<strong>物理内存地址</strong>（Physical Memory Address）。</p><p>程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了。对于任何一个程序来说，它看到的都是同样的内存地址。我们<strong>维护一个虚拟内存到物理内存的映射表</strong>，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。</p><h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><p>这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫<strong>分段</strong>（Segmentation）。这里的段，就是指系统分配出来的那个连续的内存空间。</p><p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处，第一个就是<strong>内存碎片</strong>（Memory Fragmentation）的问题。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203051544158.png"></p><p>我们可以通过<strong>内存交换</strong>（Memory Swapping）技术解决。</p><p>我们可以把 Python 程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里面。不过读回来的时候，我们不再把它加载到原来的位置，而是紧紧跟在那已经被占用了的 512MB 内存后面。这样，我们就有了连续的 256MB 内存空间，就可以去加载一个新的 200MB 的程序。</p><p>如果你自己安装过 Linux 操作系统，你应该遇到过分配一个 swap 硬盘分区的问题。这块分出来的磁盘空间，其实就是专门给 Linux 操作系统进行内存交换用的。</p><p>硬盘的访问速度要比内存慢很多，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。</p><h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p>既然问题出在内存碎片和内存交换的空间太大上，那么解决问题的办法就是，<strong>少出现一些内存碎片，并且让需要交换写入或者从磁盘装载的数据更少一点</strong>。于是就有了内存分页（Paging）。</p><p><strong>和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小</strong>。而对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。</p><p>从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。页的尺寸一般远远小于整个程序的大小。在 Linux 下，我们通常只设置成 4KB。</p><p><strong>由于内存空间都是预先划分好的，也就没有了不能使用的碎片</strong>，而只有被释放出来的很多 4KB 的页。即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，让整个机器被内存交换的过程给卡住。</p><p>分页的方式使得我们在加载程序的时候，<strong>不再需要一次性都把程序加载到物理内存中</strong>。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</p><p>实际上，我们的操作系统，的确是这么做的。当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的<strong>缺页错误</strong>（Page Fault）。我们的操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>如果我们有很多个程序都要通过装载器装载到内存里面，那里面链接好的同样的功能代码，也都需要再装载一遍，再占一遍内存空间。在一个运行上百个进程的系统中，这将会造成极大的资源浪费。</p><p>共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>（dynamic linking）是由一个叫做<strong>动态链接器</strong>（dynamic linker）的程序来执行的。Linux 中为<code>.so</code>文件，Windows 中为<code>.dll</code>文件。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203061034401.png"></p><h3 id="PIC-（Position-Independent-Code）"><a href="#PIC-（Position-Independent-Code）" class="headerlink" title="PIC （Position-Independent Code）"></a>PIC （Position-Independent Code）</h3><p>要想要在程序运行的时候共享代码，也有一定的要求，就是这些机器码必须是“<strong>地址无关</strong>”的。也就是说，我们编译出来的共享库文件的指令代码，放在哪个内存地址都能正常运行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203061037029.png"></p><p>对于所有动态链接共享库的程序来讲，虽然我们的<strong>共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的</strong>。我们没办法、也不应该要求动态链接同一个共享库的不同程序，必须把这个共享库所使用的虚拟内存地址变成一致。如果这样的话，我们写的程序就必须明确地知道内部的内存地址分配。</p><p>如何才能实现地址无关？</p><p>动态代码库内部的变量和函数调用都很容易解决，我们只需要使用<strong>相对地址</strong>（Relative Address）就好了。各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。因为整个共享库是放在一段连续的虚拟内存地址中的，无论装载到哪一段地址，不同指令之间的相对地址都是不变的。</p><h3 id="PLT-和-GOT"><a href="#PLT-和-GOT" class="headerlink" title="PLT 和 GOT"></a>PLT 和 GOT</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// lib.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LIB_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIB_H</span><br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_me_the_money</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">// lib.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_me_the_money</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Show me USD %d from lib.c \n&quot;</span>, money);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// show_me_poor.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lib.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> money = <span class="hljs-number">5</span>;<br>    show_me_the_money(money);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">gcc <span class="hljs-keyword">lib</span>.c -fPIC -<span class="hljs-keyword">shared</span> -o <span class="hljs-keyword">lib</span>.so<br>gcc -o show_me_poor show_me_poor.c ./<span class="hljs-keyword">lib</span>.so<br></code></pre></td></tr></table></figure><p><code>-fpic</code> 选项指示编译器生成与位置无关的代码。<code>-shared</code>选项指示链接器创建一个共享的目标文件。</p><p>然后，我们再通过 <code>gcc</code> 编译 <code>show_me_poor</code> 动态链接了 <code>lib.so</code> 的可执行文件。在这些操作都完成了之后，我们把 <code>show_me_poor</code> 这个文件通过 <code>objdump</code> 出来看一下。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">$ objdump -d -M intel -S show_me_poor<br><br>……<br><span class="hljs-number">0000000000400540</span> &lt;show_me_the_money@plt-<span class="hljs-number">0x10</span>&gt;:<br>  <span class="hljs-number">400540</span>:       ff <span class="hljs-number">35</span> <span class="hljs-number">12</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">push</span>   <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x200512</span>]        # 600a58 &lt;_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x8</span>&gt;<br>  <span class="hljs-number">400546</span>:       ff <span class="hljs-number">25</span> <span class="hljs-number">14</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">jmp</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x200514</span>]        # 600a60 &lt;_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x10</span>&gt;<br>  40054c:       0f 1f <span class="hljs-number">40</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">nop</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0x0</span>]<br> <br><span class="hljs-number">0000000000400550</span> &lt;show_me_the_money@plt&gt;:<br>  <span class="hljs-number">400550</span>:       ff <span class="hljs-number">25</span> <span class="hljs-number">12</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">jmp</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x200512</span>]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x18</span>&gt;<br>  <span class="hljs-number">400556</span>:       <span class="hljs-number">68</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">push</span>   <span class="hljs-number">0x0</span><br>  40055b:       e9 e0 ff ff ff          <span class="hljs-keyword">jmp</span>    <span class="hljs-number">400540</span> &lt;_init+<span class="hljs-number">0x28</span>&gt;<br>……<br><span class="hljs-number">0000000000400676</span> &lt;main&gt;:<br>  <span class="hljs-number">400676</span>:       <span class="hljs-number">55</span>                      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbp</span><br>  <span class="hljs-number">400677</span>:       <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbp</span>,<span class="hljs-built_in">rsp</span><br>  40067a:       <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>             <span class="hljs-keyword">sub</span>    <span class="hljs-built_in">rsp</span>,<span class="hljs-number">0x10</span><br>  40067e:       c7 <span class="hljs-number">45</span> fc <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>],<span class="hljs-number">0x5</span><br>  <span class="hljs-number">400685</span>:       8b <span class="hljs-number">45</span> fc                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>]<br>  <span class="hljs-number">400688</span>:       <span class="hljs-number">89</span> c7                   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>,<span class="hljs-built_in">eax</span><br>  40068a:       e8 c1 fe ff ff          <span class="hljs-keyword">call</span>   <span class="hljs-number">400550</span> &lt;show_me_the_money@plt&gt;<br>  40068f:       c9                      <span class="hljs-keyword">leave</span>  <br>  <span class="hljs-number">400690</span>:       c3                      <span class="hljs-keyword">ret</span>    <br>  <span class="hljs-number">400691</span>:       <span class="hljs-number">66</span> 2e 0f 1f <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">nop</span>    <span class="hljs-built_in">WORD</span> <span class="hljs-built_in">PTR</span> <span class="hljs-built_in">cs</span>:[<span class="hljs-built_in">rax</span>+<span class="hljs-built_in">rax</span>*<span class="hljs-number">1</span>+<span class="hljs-number">0x0</span>]<br>  <span class="hljs-number">400698</span>:       <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  40069b:       0f 1f <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">nop</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>+<span class="hljs-built_in">rax</span>*<span class="hljs-number">1</span>+<span class="hljs-number">0x0</span>]<br>……<br></code></pre></td></tr></table></figure><p>在 <code>main</code> 函数调用 <code>show_me_the_money</code> 的函数的时候，对应的代码是这样的：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">call</span>   <span class="hljs-number">400550</span> &lt;show_me_the_money<span class="hljs-symbol">@plt</span>&gt;<br></code></pre></td></tr></table></figure><p>这里后面有一个<code>@plt</code> 的关键字，代表了我们需要从<code>PLT</code>，也就是<strong>过程链接表</strong>（Procedure Link Table）里面找要调用的函数。对应的地址呢，则是 <code>400550</code> 这个地址。</p><p>那当我们把目光挪到上面的 400550 这个地址，你又会看到里面进行了一次跳转，这个跳转指定的跳转地址，你可以在后面的注释里面可以看到，GLOBAL_OFFSET_TABLE+0x18。这里的 GLOBAL_OFFSET_TABLE，就是我接下来要说的全局偏移表。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">400550</span>:       ff <span class="hljs-number">25</span> <span class="hljs-number">12</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       jmp    QWORD PTR<span class="hljs-meta"> [rip+0x200512]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt;</span><br></code></pre></td></tr></table></figure><p>在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张<strong>全局偏移表</strong>（GOT，Global Offset Table）。<strong>虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的</strong>。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。</p><p>虽然不同的程序调用的同样的动态库，各自的内存地址是独立的，调用的又都是同一个动态库，但是不需要去修改动态库里面的代码所使用的地址，而是各个程序各自维护好自己的 GOT，能够找到对应的动态库就好了。</p><h2 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h2><p>原码表示法，左侧第一位是符号位，符号位为 1 时表示负数，为 0 时表示正数。<br>补码表示法，我们不再把这一位当成单独的符号位，在剩下几位计算出的十进制前加上正负号，而是在计算整个二进制值的时候，在左侧最高位前面加个负号。</p><p>比如，一个 4 位的二进制补码数值 1011，转换成十进制，就是<br>$-1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1  + 1 \times 2^0 = -5$</p><p>一个 4 位的二进制数，可以表示从 -8 到 7 这 16 个整数，不会白白浪费一位。</p><p>字符集：表示的可以是字符的一个集合。比如说“第一版《新华字典》里面出现的所有汉字”，这是一个中文字符集。比如，我们日常说的<code>Unicode</code>，其实就是一个字符集，包含了 150 种语言的 14 万个不同的字符。</p><p>字符编码：对于字符集里的这些字符，怎么一一用二进制表示出来的一个字典。我们上面说的 <code>Unicode</code>，就可以用<code>UTF-8</code>、<code>UTF-16</code>，乃至 <code>UTF-32</code> 来进行编码，存储成二进制。</p><p>同样的文本，采用不同的编码存储下来。如果另外一个程序，用一种不同的编码方式来进行解码和展示，就会出现乱码。</p><h3 id="锟斤拷-烫烫烫"><a href="#锟斤拷-烫烫烫" class="headerlink" title="锟斤拷 烫烫烫"></a>锟斤拷 烫烫烫</h3><p>Unicode 编码一直持续在收录各种字元，这就可能会出现各种作业系统支援的 Unicode 字元不一样。这也就会导致 A 上的一个用 Unicode 编码的字元，在 B 上就会出现无法显示的情况。为了避免这种情况，在 Unicode 中定义了一个特殊字元�，它的 Unicode 编码为 0xFFFD。</p><p>假如 A 支援特殊字元⬆，但是 B 并不支援这个⬆，那么在 B 中将会用�来代替。</p><p>这个字元用 UTF-8 编码后，十六进位表示为<code>0xEF 0XBF 0XBD</code>。如果连续出现两个⬆符号，那么用 UTF-8 编码后的十六进位则表示为<code>0xEF 0XBF 0XBD 0xEF 0XBF 0XBD</code>，这时候再转码成 GBK，因为 GBK 中用两个位元组表示一个字元，那么上述的字元就成了锟（<code>0xEFBF</code>），斤（<code>0xBDEF</code>），拷（<code>0xBFBD</code>）。出现锟斤拷的原因就是 UTF-8 转码 GBK 的过程中出现了问题。当然如果想要出现锟斤拷，则至少需要两个字元出现乱码。</p><p>而“烫烫烫”，则是因为如果你用了 Visual Studio 的调试器，默认使用 MBCS 字符集。“烫”在里面是由 <code>0xCCCC</code> 来表示的，而 <code>0xCC</code> 又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。</p><h2 id="理解电路"><a href="#理解电路" class="headerlink" title="理解电路"></a>理解电路</h2><p>从以上的学习可以知道，最终执行的程序都是二进制的指令。那为何计算机最终选择了二进制呢？接下来看看计算机在硬件层面究竟是怎么表示二进制的，以此你就会明白，为什么计算机会选择二进制。</p><h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><h2 id="乘法器"><a href="#乘法器" class="headerlink" title="乘法器"></a>乘法器</h2><h2 id="浮点数和定点数"><a href="#浮点数和定点数" class="headerlink" title="浮点数和定点数"></a>浮点数和定点数</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 OpenSSL SSL_read: Connection was reset, errno 10054</title>
    <link href="/2022/02/16/%E8%A7%A3%E5%86%B3OpenSSL-SSL-read-Connection-was-reset-errno-10054/"/>
    <url>/2022/02/16/%E8%A7%A3%E5%86%B3OpenSSL-SSL-read-Connection-was-reset-errno-10054/</url>
    
    <content type="html"><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法一：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">http</span>.sslVerify <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> https<span class="hljs-variable">.sslVerify</span> <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure><p>方法三：<br>这可能是因为版本库的大小和 git 的默认缓冲区大小，所以通过下述操作（在 git bash 上），git 的缓冲区大小会增加。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//在仓库init后，添加以下配置</span><br>git <span class="hljs-keyword">config</span> http<span class="hljs-variable">.postBuffer</span> <span class="hljs-number">524288000</span><br><span class="hljs-comment">//如果仓库不是自己的，可以添加以下配置</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> http<span class="hljs-variable">.postBuffer</span> <span class="hljs-number">524288000</span><br></code></pre></td></tr></table></figure><p>方法四：<br>网速太慢，换个网速快的环境。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://stackoverflow.com/questions/46232906/git-clone-error-rpc-failed-curl-56-openssl-ssl-read-ssl-error-syscall-errno">windows - git clone error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 - Stack Overflow</a><br><a href="https://chowdera.com/2021/08/20210816115836695u.html">解决 OpenSSL SSL_read: Connection was reset, errno 10054 問題</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言中的变长数组与零长数组</title>
    <link href="/2022/02/11/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84/"/>
    <url>/2022/02/11/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>想必很多学习 C 语言的人都会在书上看到，<strong>数组在初始化时必须要确定长度（维度）</strong>，也就是说定义数组时，维度一定要用常量。但是在编程中很多人肯定发现了，及时像下面这样写，编译器也不会报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> n;             <br><span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[n];    <br></code></pre></td></tr></table></figure><p>这是怎么回事？难道以前我学的是错的吗？当然不是。最官方的解释应该是 C 语言的规范和编译器的规范说明了。</p><ul><li>在 ISO/IEC9899 标准的 <a href="http://busybox.net/~landley/c99-draft.html#6.7.5.2">6.7.5.2 Array declarators</a> 中明确说明了数组的长度可以为变量的，称为变长数组（VLA，variable length array）。（注：这里的变长指的是数组的长度是在运行时才能决定，但一旦决定在数组的生命周期内就不会再变。）</li><li>在 GCC 标准规范的 <a href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">6.19 Arrays of Variable Length</a> 中指出，作为编译器扩展，GCC 在 C90 模式和 C++ 编译器下遵守 ISO C99 关于变长数组的规范。</li></ul><p>原来这种语法确实是 C 语言规范，GCC 非常完美的支持了 ISO C99。但是在 C99 之前的 C 语言中，变长数组的语法是不存在的。</p><p>这种变长数组有什么好处呢？它可以实现与<code>alloca</code>函数一样的效果，在栈上进行动态的空间分配，并且在函数返回时自动释放内存，无需手动释放。</p><blockquote><p><code>alloca</code> 函数用来在栈上分配空间，当函数返回时自动释放，无需手动再去释放；</p></blockquote><p>可变数组示例：<br>所有可变修改 (VM) 类型的声明必须在块范围或函数原型范围内。使用 <code>static</code> 或 <code>extern</code> 存储类说明符声明的数组对象不能具有可变长度数组 (VLA) 类型。但是，使用静态存储类说明符声明的对象可以具有 <code>VM</code> 类型（即，指向 <code>VLA</code> 类型的指针）。最后，使用 <code>VM</code> 类型声明的所有标识符都必须是普通标识符，因此<strong>不能是结构或联合的成员</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> A[n];                       <span class="hljs-comment">// Error - file scope VLA.</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">int</span> <span class="hljs-params">(*p2)</span>[n]</span>;            <span class="hljs-comment">// Error - file scope VM.</span><br><span class="hljs-keyword">int</span> B[<span class="hljs-number">100</span>];                     <span class="hljs-comment">// OK - file scope but not VM.</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fvla</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> C[m][m])</span>   <span class="hljs-comment">// OK - VLA with prototype scope.</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> VLA[m][m]   <span class="hljs-comment">// OK - block scope typedef VLA.</span><br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> &#123;</span><br>                <span class="hljs-keyword">int</span> (*y)[n];        <span class="hljs-comment">// Error - y not ordinary identifier.</span><br>                <span class="hljs-keyword">int</span> z[n];           <span class="hljs-comment">// Error - z not ordinary identifier.</span><br>        &#125;;<br>        <span class="hljs-keyword">int</span> D[m];                   <span class="hljs-comment">// OK - auto VLA.</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> E[m];            <span class="hljs-comment">// Error - static block scope VLA.</span><br>        <span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> F[m];            <span class="hljs-comment">// Error - F has linkage and is VLA.</span><br>        <span class="hljs-keyword">int</span> (*s)[m];                <span class="hljs-comment">// OK - auto pointer to VLA.</span><br>        <span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">int</span> <span class="hljs-params">(*r)</span>[m]</span>;         <span class="hljs-comment">// Error - r had linkage and is</span><br>                                    <span class="hljs-comment">// a pointer to VLA.</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">int</span> <span class="hljs-params">(*q)</span>[m] </span>= &amp;B;    <span class="hljs-comment">// OK - q is a static block</span><br>                                    <span class="hljs-comment">// pointer to VLA.</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="零长数组"><a href="#零长数组" class="headerlink" title="零长数组"></a>零长数组</h2><p>GNU/GCC 在标准的 C/C++ 基础上做了有实用性的扩展，零长度数组（Arrays of Length Zero）就是其中一个知名的扩展。使用零长数组，把它作为结构体的最后一个元素非常有用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> &#123;</span><br>    <span class="hljs-keyword">int</span> length;<br>    <span class="hljs-keyword">char</span> contents[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> *<span class="hljs-title">thisline</span> =</span> (struct line *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span> (struct line) + this_length);<br>thisline-&gt;length = this_length;<br></code></pre></td></tr></table></figure><p>从上例就可以看出，零长数组在有固定头部的可变对象上非常适用，我们可以根据对象的大小动态地去分配结构体的大小。</p><p>在 <code>Linux</code> 内核中也有这种应用，例如由于 <code>PID</code> 命名空间的存在，每个进程 <code>PID</code> 需要映射到所有能看到其的命名空间上，但该进程所在的命名空间在开始并不确定（但至少为 <code>init</code> 命名空间），需要在运行是根据 <code>level</code> 的值来确定，所以在该结构体后面增加了一个长度为 <code>1</code> 的数组（因为至少在一个<code>init</code>命名空间上），使得该结构体 <code>pid</code> 是个可变长的结构体，在运行时根据进程所处的命名空间的 <code>level</code> 来决定 <code>numbers</code> 分配多大。（注：虽然不是零长度的数组，但用法是一样的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">atomic_t</span> count;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> level;<br>    <span class="hljs-comment">/* lists of tasks that use this pid */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span> <span class="hljs-title">tasks</span>[<span class="hljs-title">PIDTYPE_MAX</span>];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">upid</span> <span class="hljs-title">numbers</span>[1];</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="什么-0-长度数组不占用存储空间"><a href="#什么-0-长度数组不占用存储空间" class="headerlink" title="什么 0 长度数组不占用存储空间"></a>什么 0 长度数组不占用存储空间</h3><p>0 长度数组与指针实现有什么区别呢，为什么 0 长度数组不占用存储空间呢？</p><p>其实本质上涉及到的是一个 C 语言里面的数组和指针的区别问题。char a[1] 里面的 a 和 char *b 的 b 相同吗？</p><p>《Programming Abstractions in C》（Roberts, E. S.，机械工业出版社，2004.6）82 页里面说。</p><blockquote><p>“arr is defined to be identical to &amp;arr[0]”.</p></blockquote><p>也就是说，<code>char a[1]</code>里面的<code>a</code>实际是一个常量，等于<code>&amp;a[0]</code>。而<code>char *b</code>是有一个实实在在的指针变量<code>b</code>存在。所以，<code>a=b</code>是不允许的，而<code>b=a</code>是允许的。</p><p>本质上因为数组名它只是一个偏移量，数组名这个符号本身代 表了一个不可修改的<strong>地址常量</strong> （注意：数组名永远都不会是指针！ ），但对于这个数组的大小，我们可以进行动态分配，对于编译器而言，数组名仅仅是一个符号，它不会占用任何空间，它在结构体中，只是代表了一个偏移量，代表一个不可修改的地址常量！</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.cnblogs.com/hazir/p/variable_length_array.html">alloca 函数用来在栈上分配空间，当函数返回时自动释放，无需手动再去释放</a></p><p><a href="https://blog.csdn.net/gatieme/article/details/64131322">C 语言 0 长度数组 (可变数组/柔性数组) 详解_OSKernelLAB(gatieme)-CSDN 博客_柔性数组</a></p><p><a href="https://blog.csdn.net/weixin_43083491/article/details/112632310">零长数组（柔性数组、可变数组）的使用_禾仔仔的博客-CSDN 博客</a></p><p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Zero-Length.html#Zero-Length">Zero Length - Using the GNU Compiler Collection (GCC)</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH 原理</title>
    <link href="/2022/01/27/SSH%E5%8E%9F%E7%90%86/"/>
    <url>/2022/01/27/SSH%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>QEMU 源码分析-内存虚拟化</title>
    <link href="/2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <url>/2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1.大部分转载自<a href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a><br>2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改<br>3.部分内容根据自己理解补充添加</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：</p><ul><li>虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间；</li><li>虚拟机里面的物理内存（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存；</li><li>物理机的虚拟内存（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间；</li><li>物理机的物理内存（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。</li></ul><p>内存虚拟化的关键在于维护 <code>GPA</code> 到 <code>HVA</code> 的映射关系。</p><h2 id="页面分配和映射的两种方式"><a href="#页面分配和映射的两种方式" class="headerlink" title="页面分配和映射的两种方式"></a>页面分配和映射的两种方式</h2><p>要搞清楚 QEMU system emulation 的仿真架构，首先对于 Host OS，将 QEMU 作为进程启动，然后对于 QEMU 进程，会仿真各种硬件和运行 Guest OS，在这层 OS 上运行要全系统模拟的应用程序，因此对于 Guest OS 管理的内存要实现到 QEMU 进程的虚拟空间的转换需要 softMMU（即需要对 GPA 到 HVA 进行转换）。从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。</p><h3 id="影子页表-Shadow-Page-Table，SPT"><a href="#影子页表-Shadow-Page-Table，SPT" class="headerlink" title="影子页表 Shadow Page Table，SPT"></a>影子页表 Shadow Page Table，SPT</h3><p>第一种方式就是软件的方式，影子页表（Shadow Page Table）。</p><p>KVM 通过维护记录 GVA-&gt;HPA 的影子页表 SPT，减少了地址转换带来的开销，可以直接将 GVA 转换为 HPA。</p><p>内存映射要通过页表来管理，页表地址应该放在 CR3 寄存器里面。在软件虚拟化的内存转换中，GVA 到 GPA 的转换通过查询 CR3 寄存器来完成，CR3 中保存了 Guest 的页表基地址，然后载入 MMU 中进行地址转换。</p><p>在加入了 SPT 技术后，当 Guest 访问 CR3 时，KVM 会捕获到这个操作 EXIT_REASON_CR_ACCESS，之后 KVM 会载入特殊的 CR3 和影子页表，欺骗 Guest 这就是真实的 CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。</p><blockquote><p>本来的过程是，客户机要通过 cr3 找到客户机的页表，实现从 GVA 到 GPA 的转换，然后在宿主机上，要通过 cr3 找到宿主机的页表，实现从 HVA 到 HPA 的转换。<br>为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。<br>在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。</p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124192700.png"></p><p>为了快速检索 Guest 页表对应的影子页表，KVM 为每个客户机维护了一个 hash 表来进行客户机页表到影子页表之间的映射。对于每一个 Guest 来说，其页目录和页表都有唯一的 GPA，通过页目录/页表的 GPA 就可以在哈希链表中快速地找到对应的影子页目录/页表。</p><p>当 Guest 切换进程时，Guest 会把待切换进程的页表基址载入 CR3，而 KVM 将会截获这一特权指令。KVM 在哈希表中找到与此页表基址对应的影子页表基址，载入 Guest CR3，使 Guest 在恢复运行时 CR3 实际指向的是新切换进程对应的影子页表。</p><p>影子页表的引入，减少了 GVA-&gt;HPA 的转换开销，但是缺点在于需要为 Guest 的每个进程都维护一个影子页表，这将带来很大的内存开销。同时影子页表的建立是很耗时的，如果 Guest 的进程过多，将导致影子页表频繁切换。</p><p>因此 Intel 和 AMD 在此基础上提供了基于硬件的虚拟化技术 EPT。</p><h3 id="扩展页表-Extent-Page-Table，EPT"><a href="#扩展页表-Extent-Page-Table，EPT" class="headerlink" title="扩展页表 Extent Page Table，EPT"></a>扩展页表 Extent Page Table，EPT</h3><p>Intel 的 EPT（Extent Page Table）技术和 AMD 的 NPT（Nest Page Table）技术都对内存虚拟化提供了硬件支持。这两种技术原理类似，都是在硬件层面上实现 GVA 到 HPA 之间的转换。下面就以 EPT 为例分析一下 KVM 基于硬件辅助的内存虚拟化实现。</p><p>EPT 在原有客户机页表对客户机虚拟地址 GVA 到客户机物理地址 GPA 映射的基础上，又引入了 EPT 页表来实现客户机物理地址 GPA 到宿主机物理地址 HPA 的另一次映射。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。</p><p>即 EPT 技术采用了在两级页表结构，即原有 Guest OS 页表对 <strong>GVA-&gt;GPA</strong> 映射的基础上，又引入了 EPT 页表来实现 <strong>GPA-&gt;HPA</strong> 的另一次映射，这<strong>两次地址映射都是由硬件自动完成</strong>。</p><p>有了 EPT，在<strong>GPA-&gt;HPA</strong>转换的过程中，缺页会产生 EPT 缺页异常。KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。</p><p>KVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。</p><p>这里，我们重点看第二种方式。因为使用了 EPT 之后，客户机里面的页表映射，也即从 GVA 到 GPA 的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而 EPT 重点帮我们解决的就是从 GPA 到 HPA 的转换问题。因为要经过两次页表，所以 EPT 又 tdp(two dimentional paging)。</p><p>EPT 的页表结构也是分为四层，EPT Pointer（EPTP）指向 PML4 的首地址。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124194059.png"></p><h2 id="QEMU-的主要工作"><a href="#QEMU-的主要工作" class="headerlink" title="QEMU 的主要工作"></a>QEMU 的主要工作</h2><p>内存虚拟化的目的就是让虚拟机能够无缝的访问内存。有了 Intel EPT 的支持后，CPU 在 VMX non-root 状态时进行内存访问会再做一次 EPT 转换。在这个过程中，QEMU 会负责以下内容：</p><p>首先需要从自己的进程地址空间中申请内存用于 Guest<br>需要将上一步中申请到的内存的虚拟地址（HVA）和 Guest 的物理地址之间的映射关系传递给 KVM（kernel），即 GPA-&gt;HVA<br>需要组织一系列的数据结构来管理虚拟内存空间，并在内存拓扑结构更改时将最新的内存信息同步至 KVM 中</p><h2 id="QEMU-和-KVM-的工作分界"><a href="#QEMU-和-KVM-的工作分界" class="headerlink" title="QEMU 和 KVM 的工作分界"></a>QEMU 和 KVM 的工作分界</h2><p>QEMU 和 KVM 之间是通过 KVM 提供的 ioctl() 接口进行交互的。在内核的 kvm_vm_ioctl() 中，<strong>设置虚拟机内存</strong>的系统调用【kernel 就是一系列系统调用函数接口和处理逻辑，其中有个处理”创建/设置虚拟机内存“的系统调用接口】为  <code>VM_SET_USER_MEMORY_REGION</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">kvm_vm_ioctl</span><span class="hljs-params">(struct file *filp,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ioctl, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">case</span> KVM_SET_USER_MEMORY_REGION: &#123; <span class="hljs-comment">// 在 KVM 中注册用户空间传入的内存信息</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">kvm_userspace_mem</span>;</span><br><br>        r = -EFAULT;<br>         <span class="hljs-comment">// 将传入的数据结构复制到内核空间</span><br>        <span class="hljs-keyword">if</span> (copy_from_user(&amp;kvm_userspace_mem, argp, <span class="hljs-keyword">sizeof</span> kvm_userspace_mem))<br>            <span class="hljs-keyword">goto</span> out;<br><br>         <span class="hljs-comment">// 实际进行处理的函数</span><br>        r = kvm_vm_ioctl_set_memory_region(kvm, &amp;kvm_userspace_mem, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (r)<br>            <span class="hljs-keyword">goto</span> out;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里需要传递的参数类型为 <code>kvm_userspace_memory_region</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* for KVM_SET_USER_MEMORY_REGION */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;            <span class="hljs-comment">// slot 编号 [参考：https://www.cnblogs.com/LoyenWang/p/11922887.html]</span><br>    __u32 flags;           <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    __u64 guest_phys_addr; <span class="hljs-comment">// Guest 物理地址，即 GPA</span><br>    __u64 memory_size;     <span class="hljs-comment">// 内存大小，单位 bytes</span><br>    __u64 userspace_addr;  <span class="hljs-comment">// 从 QEMU 进程地址空间中分配内存的起始地址，即 HVA</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>KVM_SET_USER_MEMORY_REGION</code>这个 <code>ioctl</code> 主要目的就是设置<code>GPA-&gt;HVA</code>的映射关系，KVM 会继续调用<code>kvm_vm_ioctl_set_memory_region()</code>，在内核空间维护并管理 Guest 的内存。</p><h2 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h2><h3 id="AddressSpace"><a href="#AddressSpace" class="headerlink" title="AddressSpace"></a>AddressSpace</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>QEMU 用 AddressSpace 结构体表示 Guest 中 CPU/设备看到的内存【也就是Guest OS 可以在 QEMU 进程虚存中用到的所有内存，是 MemoryRegion 的集合，即 GPA 的整体】，类似于物理机中地址空间的概念，但在这里表示的是 Guest 的一段地址空间，如内存地址空间 <code>address_space_memory</code> 、<code>I/O</code> 地址空间<code>address_space_io</code>，它在 QEMU 源码<code>memory.c</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSpace</span> &#123;</span><br>    <span class="hljs-comment">/* private: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-keyword">char</span> *name;<br>    MemoryRegion *root;<br><br>    <span class="hljs-comment">/* Accessed via RCU.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatView</span> *<span class="hljs-title">current_map</span>;</span><br><br>    <span class="hljs-keyword">int</span> ioeventfd_nb;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionIoeventfd</span> *<span class="hljs-title">ioeventfds</span>;</span><br>    QTAILQ_HEAD(, MemoryListener) listeners;<br>    QTAILQ_ENTRY(AddressSpace) address_spaces_link;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个 AddressSpace 一般包含一系列的 MemoryRegion：<code>root</code>指针指向根级 MemoryRegion，而 root 可能有自己的若干个 sub-regions（子节点），于是形成树状结构。这些 MemoryRegion 通过树连接起来，树的根即为 AddressSpace 的 root 域。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>另外，QEMU 中有两个全局的静态 AddressSpace，在 memory.c 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> AddressSpace address_space_memory; <span class="hljs-comment">// 内存地址空间</span><br><span class="hljs-keyword">static</span> AddressSpace address_space_io;     <span class="hljs-comment">// I/O 地址空间</span><br></code></pre></td></tr></table></figure><p>其 root 域分别指向之后会提到的两个 MemoryRegion 类型变量：system_memory、system_io。</p><h3 id="MemoryRegion"><a href="#MemoryRegion" class="headerlink" title="MemoryRegion"></a>MemoryRegion</h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>MemoryRegion</code> 表示在 <code>Guest Memory Layout</code> 中的一段内存区域【也就是单元级 GPA 的概念，Guest OS 可以管理到的那些 Guest 物理内存单元】，它是联系 <code>GPA</code> 和 <code>RAMBlocks</code>（描述真实内存）之间的桥梁，在<code>memory.h</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> &#123;</span><br>    <span class="hljs-comment">/* All fields are private - violators will be prosecuted */</span><br>    <span class="hljs-keyword">const</span> MemoryRegionOps *ops;      <span class="hljs-comment">// 回调函数集合</span><br>    <span class="hljs-keyword">void</span> *opaque;<br>    MemoryRegion *parent;            <span class="hljs-comment">// 父 MemoryRegion 指针</span><br>    Int128 size;                     <span class="hljs-comment">// 该区域内存的大小</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> addr;         <span class="hljs-comment">// 在 Address Space 中的地址，即 HVA</span><br>    <span class="hljs-keyword">void</span> (*destructor)(MemoryRegion *mr);<br>    <span class="hljs-keyword">ram_addr_t</span> ram_addr;             <span class="hljs-comment">// MemoryRegion 的起始地址，即 GPA</span><br>    <span class="hljs-keyword">bool</span> subpage;<br>    <span class="hljs-keyword">bool</span> terminates;<br>    <span class="hljs-keyword">bool</span> readable;<br>    <span class="hljs-keyword">bool</span> ram;                        <span class="hljs-comment">// 是否表示 RAM</span><br>    <span class="hljs-keyword">bool</span> readonly; <span class="hljs-comment">/* For RAM regions */</span><br>    <span class="hljs-keyword">bool</span> enabled;                    <span class="hljs-comment">// 是否已经通知 KVM 使用这段内存</span><br>    <span class="hljs-keyword">bool</span> rom_device;<br>    <span class="hljs-keyword">bool</span> warning_printed; <span class="hljs-comment">/* For reservations */</span><br>    MemoryRegion *alias;             <span class="hljs-comment">// 是否为 MemoryRegion alias</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> alias_offset; <span class="hljs-comment">// 若为 alias，在原 MemoryRegion 中的 offset</span><br>    <span class="hljs-keyword">unsigned</span> priority;<br>    <span class="hljs-keyword">bool</span> may_overlap;<br>    QTAILQ_HEAD(subregions, MemoryRegion) subregions; <span class="hljs-comment">// 子区域链表头</span><br>    QTAILQ_ENTRY(MemoryRegion) subregions_link;       <span class="hljs-comment">// 子区域链表节点</span><br>    QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;       <span class="hljs-comment">// MemoryRegion 的名字，调试时使用</span><br>    <span class="hljs-keyword">uint8_t</span> dirty_log_mask; <span class="hljs-comment">// 表示哪一种 dirty map 被使用，共分三种</span><br>    <span class="hljs-keyword">unsigned</span> ioeventfd_nb;<br>    MemoryRegionIoeventfd *ioeventfds;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><p>在 QEMU 的 exec.c 中也定义了两个静态的 MemoryRegion 指针变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> MemoryRegion *system_memory; <span class="hljs-comment">// 内存 MemoryRegion，对应 address_space_memory</span><br><span class="hljs-keyword">static</span> MemoryRegion *system_io;     <span class="hljs-comment">// I/O MemoryRegion，对应 address_space_io</span><br></code></pre></td></tr></table></figure><p>与两个全局 AddressSpace 对应，即 AddressSpace 的 root 域指向这两个 MemoryRegion。</p><h4 id="MemoryRegion-的类型"><a href="#MemoryRegion-的类型" class="headerlink" title="MemoryRegion 的类型"></a>MemoryRegion 的类型</h4><p>MemoryRegion 有多种类型，可以表示一段 RAM、ROM、MMIO、alias(别名)。</p><p>若为 alias 则表示一个 MemoryRegion 的部分区域，例如，QEMU 会为 pc.ram 这个表示 RAM 的 MemoryRegion 添加两个 alias：ram-below-4g 和 ram-above-4g，之后会看到具体的代码实例。</p><p>另外，MemoryRegion 也可以表示一个 container，这就表示它只是其他若干个 MemoryRegion 的容器。</p><p>那么要如何创建不同类型的 <code>MemoryRegion</code> 呢？</p><p>在 QEMU 中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将 MemoryRegion 划分为以下三种类型：</p><ul><li>根级 MemoryRegion：直接通过 memory_region_init 初始化，没有自己的内存，用于管理 subregion，例如 system_memory：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    mr-&gt;ops = <span class="hljs-literal">NULL</span>;<br>    mr-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    mr-&gt;size = int128_make64(size);<br>    <span class="hljs-keyword">if</span> (size == UINT64_MAX) &#123;<br>        mr-&gt;size = int128_2_64();<br>    &#125;<br>    mr-&gt;addr = <span class="hljs-number">0</span>;<br>    mr-&gt;subpage = <span class="hljs-literal">false</span>;<br>    mr-&gt;enabled = <span class="hljs-literal">true</span>;<br>    mr-&gt;terminates = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 非实体 MemoryRegion，搜索时会继续前往其 subregions</span><br>    mr-&gt;ram = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 根级 MemoryRegion 不分配内存</span><br>    mr-&gt;readable = <span class="hljs-literal">true</span>;<br>    mr-&gt;readonly = <span class="hljs-literal">false</span>;<br>    mr-&gt;rom_device = <span class="hljs-literal">false</span>;<br>    mr-&gt;destructor = memory_region_destructor_none;<br>    mr-&gt;priority = <span class="hljs-number">0</span>;<br>    mr-&gt;may_overlap = <span class="hljs-literal">false</span>;<br>    mr-&gt;alias = <span class="hljs-literal">NULL</span>;<br>    QTAILQ_INIT(&amp;mr-&gt;subregions);<br>    <span class="hljs-built_in">memset</span>(&amp;mr-&gt;subregions_link, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> mr-&gt;subregions_link);<br>    QTAILQ_INIT(&amp;mr-&gt;coalesced);<br>    mr-&gt;name = g_strdup(name);<br>    mr-&gt;dirty_log_mask = <span class="hljs-number">0</span>;<br>    mr-&gt;ioeventfd_nb = <span class="hljs-number">0</span>;<br>    mr-&gt;ioeventfds = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 mr-&gt;addr 被设置为 0，而 mr-&gt;ram_addr 则并没有初始化。</p><ul><li>实体 <code>MemoryRegion</code>：通过<code>memory_region_init_ram()</code>初始化，有自己的内存（从 QEMU 进程地址空间中分配），大小为<code>size</code>，例如<code>ram_memory</code>、 <code>pci_memory</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram, *option_rom_mr;<br>    <span class="hljs-comment">/* ...*/</span><br><br>    <span class="hljs-comment">/* Allocate RAM.  We allocate it as a single memory region and use</span><br><span class="hljs-comment">     * aliases to address portions of it, mostly for backwards compatibility</span><br><span class="hljs-comment">     * with older qemus that used qemu_ram_alloc().</span><br><span class="hljs-comment">     */</span><br>    ram = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram));<br>    <span class="hljs-comment">// 调用 memory_region_init_ram 对 ram_memory 进行初始化</span><br>    memory_region_init_ram(ram, <span class="hljs-string">&quot;pc.ram&quot;</span>, below_4g_mem_size + above_4g_mem_size);<br>    vmstate_register_ram_global(ram);<br>    *ram_memory = ram;<br><br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size);<br>    mr-&gt;ram = <span class="hljs-literal">true</span>;<br>    mr-&gt;terminates = <span class="hljs-literal">true</span>;<br>    mr-&gt;destructor = memory_region_destructor_ram;<br>    mr-&gt;ram_addr = qemu_ram_alloc(size, mr);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里是先调用了<code>memory_region_init()</code>，之后设置 <code>RAM</code> 属性，并继续调用<code>qemu_ram_alloc()</code>分配内存。</p><ul><li>别名 <code>MemoryRegion</code>：通过<code>memory_region_init_alias()</code> 初始化，没有自己的内存，表示实体 <code>MemoryRegion</code> 的一部分。通过 <code>alias</code> 成员指向实体 <code>MemoryRegion</code>，<code>alias_offset</code>为在实体 <code>MemoryRegion</code> 中的偏移量，例如<code>ram_below_4g</code>、<code>ram_above_4g</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram_below_4g, *ram_above_4g;<br>    <span class="hljs-comment">/* ... */</span><br>    ram_below_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_below_4g));<br>    <span class="hljs-comment">// 调用 memory_region_init_alias 对 ram_below_4g 进行初始化</span><br>    memory_region_init_alias(ram_below_4g, <span class="hljs-string">&quot;ram-below-4g&quot;</span>, ram, <span class="hljs-number">0</span>, below_4g_mem_size);<br>    <span class="hljs-comment">/* ..</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_alias</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                              MemoryRegion *orig,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">target_phys_addr_t</span> offset,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size);<br>    mr-&gt;alias = orig; <span class="hljs-comment">// 指向实体 MemoryRegion</span><br>    mr-&gt;alias_offset = offset; <span class="hljs-comment">//通过 offset 得到实体的某一个部分</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RAMBlock"><a href="#RAMBlock" class="headerlink" title="RAMBlock"></a>RAMBlock</h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>MemoryRegion</code> 用来描述一段逻辑层面上的内存区域，而记录实际分配的内存地址信息的结构体则是 <code>RAMBlock</code>，在<code>ramblock.h</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RAMBlock</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> *<span class="hljs-title">mr</span>;</span><br>    <span class="hljs-keyword">uint8_t</span> *host;<br>    <span class="hljs-keyword">uint8_t</span> *colo_cache; <span class="hljs-comment">/* For colo, VM&#x27;s ram cache */</span><br>    <span class="hljs-keyword">ram_addr_t</span> offset;<br>    <span class="hljs-keyword">ram_addr_t</span> used_length;<br>    <span class="hljs-keyword">ram_addr_t</span> max_length;<br>    <span class="hljs-keyword">void</span> (*resized)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">uint64_t</span> length, <span class="hljs-keyword">void</span> *host);<br>    <span class="hljs-keyword">uint32_t</span> flags;<br>    <span class="hljs-comment">/* Protected by iothread lock.  */</span><br>    <span class="hljs-keyword">char</span> idstr[<span class="hljs-number">256</span>];<br>    <span class="hljs-comment">/* RCU-enabled, writes protected by the ramlist lock */</span><br>    QLIST_ENTRY(RAMBlock) next;<br>    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;<br>    <span class="hljs-keyword">int</span> fd;<br>    <span class="hljs-keyword">size_t</span> page_size;<br>    <span class="hljs-comment">/* dirty bitmap used during migration */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *bmap;<br>    <span class="hljs-comment">/* bitmap of already received pages in postcopy */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *receivedmap;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * bitmap to track already cleared dirty bitmap.  When the bit is</span><br><span class="hljs-comment">     * set, it means the corresponding memory chunk needs a log-clear.</span><br><span class="hljs-comment">     * Set this up to non-NULL to enable the capability to postpone</span><br><span class="hljs-comment">     * and split clearing of dirty bitmap on the remote node (e.g.,</span><br><span class="hljs-comment">     * KVM).  The bitmap will be set only when doing global sync.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> this bitmap is different comparing to the other bitmaps</span><br><span class="hljs-comment">     * in that one bit can represent multiple guest pages (which is</span><br><span class="hljs-comment">     * decided by the `clear_bmap_shift&#x27; variable below).  On</span><br><span class="hljs-comment">     * destination side, this should always be NULL, and the variable</span><br><span class="hljs-comment">     * `clear_bmap_shift&#x27; is meaningless.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *clear_bmap;<br>    <span class="hljs-keyword">uint8_t</span> clear_bmap_shift;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * RAM block length that corresponds to the used_length on the migration</span><br><span class="hljs-comment">     * source (after RAM block sizes were synchronized). Especially, after</span><br><span class="hljs-comment">     * starting to run the guest, used_length and postcopy_length can differ.</span><br><span class="hljs-comment">     * Used to register/unregister uffd handlers and as the size of the received</span><br><span class="hljs-comment">     * bitmap. Receiving any page beyond this length will bail out, as it</span><br><span class="hljs-comment">     * could not have been valid on the source.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">ram_addr_t</span> postcopy_length;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>可以看到在 <code>RAMBlock</code> 中 host 和 offset 域分别对应了 <code>HVA</code> 和<code>GPA</code>，因此也可以说 <code>RAMBlock</code> 中存储了<code>GPA-&gt;HVA</code>的映射关系，另外每一个 <code>RAMBlock</code> 都会指向其所属的 <code>MemoryRegion</code>。</p><h4 id="全局变量-ram-list"><a href="#全局变量-ram-list" class="headerlink" title="全局变量 ram_list"></a>全局变量 ram_list</h4><p>QEMU 在<code>ramlist.h</code>中定义了一个全局变量<code>ram_list</code>，以链表的形式维护了所有的 <code>RAMBlock</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RAMList</span> &#123;</span><br>    QemuMutex mutex;<br>    RAMBlock *mru_block;<br>    <span class="hljs-comment">/* RCU-enabled, writes protected by the ramlist lock. */</span><br>    QLIST_HEAD(, RAMBlock) blocks;<br>    DirtyMemoryBlocks *dirty_memory[DIRTY_MEMORY_NUM];<br>    <span class="hljs-keyword">uint32_t</span> version;<br>    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;<br>&#125; RAMList;<br><span class="hljs-keyword">extern</span> RAMList ram_list;<br></code></pre></td></tr></table></figure><p>每一个新分配的 <code>RAMBlock</code> 都会被插入到<code>ram_list</code>的头部。如需查找地址所对应的 <code>RAMBlock</code>，则需要遍历<code>ram_list</code>，当目标地址落在当前<code>RAMBlock</code>的地址区间时，该 <code>RAMBlock</code> 即为查找目标。</p><h4 id="AS、MR、RAMBlock-之间的关系"><a href="#AS、MR、RAMBlock-之间的关系" class="headerlink" title="AS、MR、RAMBlock 之间的关系"></a>AS、MR、RAMBlock 之间的关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225155936.png"></p><h3 id="FlatView"><a href="#FlatView" class="headerlink" title="FlatView"></a>FlatView</h3><p>AddressSpace 的 root 域及其子树共同构成了 Guest 的物理地址空间，但这些都是在 QEMU 侧定义的。要传入 KVM 进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其<strong>转换为一个“平坦”的地址模</strong>型，也就是一个从零开始、只包含地址信息的数据结构，这在 QEMU 中通过 <strong>FlatView</strong> 来表示。每个 AddressSpace 都有一个与之对应的 FlatView 指针 current_map，表示其对应的平面展开视图。</p><h4 id="结构体定义-3"><a href="#结构体定义-3" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>FlatView</code> 在<code>memory.c</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* Flattened global view of current active memory hierarchy.  Kept in sorted</span><br><span class="hljs-comment"> * order.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatView</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-keyword">unsigned</span> ref;<br>    FlatRange *ranges;      <span class="hljs-comment">// 对应的 FlatRange 数组</span><br>    <span class="hljs-keyword">unsigned</span> nr;            <span class="hljs-comment">// FlatRange 的数目</span><br>    <span class="hljs-keyword">unsigned</span> nr_allocated;  <span class="hljs-comment">// 当前数组的项数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSpaceDispatch</span> *<span class="hljs-title">dispatch</span>;</span><br>    MemoryRegion *root;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，<code>ranges</code>是一个数组，记录了 <code>FlatView</code> 下所有的 <code>FlatRange</code>。</p><h4 id="FlatRange"><a href="#FlatRange" class="headerlink" title="FlatRange"></a>FlatRange</h4><p>在 <code>FlatView</code> 中，<code>FlatRange</code> 表示在 <code>FlatView</code> 中的一段内存范围，同样在<code>memory.c</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Range of memory in the global map.  Addresses are absolute. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatRange</span> &#123;</span><br>    MemoryRegion *mr;           <span class="hljs-comment">// 指向所属的 MemoryRegion</span><br>    hwaddr offset_in_region;    <span class="hljs-comment">// 在全局 MemoryRegion 中的 offset，对应 GPA</span><br>    AddrRange addr;             <span class="hljs-comment">// 代表的地址区间，对应 HVA</span><br>    <span class="hljs-keyword">uint8_t</span> dirty_log_mask;<br>    <span class="hljs-keyword">bool</span> romd_mode;<br>    <span class="hljs-keyword">bool</span> readonly;<br>    <span class="hljs-keyword">bool</span> nonvolatile;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个 <code>FlatRange</code> 对应一段虚拟机物理地址区间，各个 <code>FlatRange</code> 不会重叠，<strong>按照地址的顺序保存在数组中</strong>，具体的地址范围由一个 <code>AddrRange</code> 结构来描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * AddrRange 用于表示 FlatRange 的起始地址及大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddrRange</span> &#123;</span><br>    Int128 start;<br>    Int128 size;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="MemoryRegionSection"><a href="#MemoryRegionSection" class="headerlink" title="MemoryRegionSection"></a>MemoryRegionSection</h3><h4 id="结构体定义-4"><a href="#结构体定义-4" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>在 <code>QEMU</code> 中，还有几个起到中介作用的结构体，<code>MemoryRegionSection</code> 就是其中之一。</p><p>之前介绍的 <code>FlatRange</code> 代表一个物理地址空间的片段，偏向于描述在 <code>Host</code> 侧即 <strong>AddressSpace 中的分布【Guest 的物理空间】</strong>，而 <code>MemoryRegionSection</code> 则代表在 <code>Guest</code> 侧即 <strong>MemoryRegion 中的片段</strong>。<code>MemoryRegionSection</code> 在<code>memory.h</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MemoryRegionSection: describes a fragment of a #MemoryRegion</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @mr: the region, or %NULL if empty</span><br><span class="hljs-comment"> * @address_space: the address space the region is mapped in</span><br><span class="hljs-comment"> * @offset_within_region: the beginning of the section, relative to @mr&#x27;s start</span><br><span class="hljs-comment"> * @size: the size of the section; will not exceed @mr&#x27;s boundaries</span><br><span class="hljs-comment"> * @offset_within_address_space: the address of the first byte of the section</span><br><span class="hljs-comment"> *     relative to the region&#x27;s address space</span><br><span class="hljs-comment"> * @readonly: writes to this section are ignored</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//只是起到描述的作用，描述了是哪个 AddressSpace 的 MemoryRegion，</span><br> <span class="hljs-comment">//并且在 MemoryRegion 中的 offset，和在 AddressSpace 展开为平坦内存的 offset</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionSection</span> &#123;</span>  <br>    MemoryRegion *mr;                               <span class="hljs-comment">// 所属的 MemoryRegion</span><br>    MemoryRegion *address_space;                    <span class="hljs-comment">// 关联的 AddressSpace</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> offset_within_region;        <span class="hljs-comment">// 在 MemoryRegion 内部的 offset</span><br>    <span class="hljs-keyword">uint64_t</span> size;                                  <span class="hljs-comment">// Section 的大小</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> offset_within_address_space; <span class="hljs-comment">// 在 AddressSpace 内部的 offset</span><br>    <span class="hljs-keyword">bool</span> readonly;                                  <span class="hljs-comment">// 是否为只读</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>offset_within_region</code>：在所属 <code>MemoryRegion</code> 中的<code>offset</code>。一个<code>AddressSpace</code> 可能由多个 <code>MemoryRegion</code> 组成，因此该 <code>offset</code> 是局部的</li><li><code>offset_within_address_space</code>：在所属 <code>AddressSpace</code> 中的 <code>offset</code>，它是全局的</li></ul><h4 id="和其他数据结构之间的关系"><a href="#和其他数据结构之间的关系" class="headerlink" title="和其他数据结构之间的关系"></a>和其他数据结构之间的关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125110422.png"></p><ul><li><code>AddressSpace</code> 的<code>root</code>指向对应的根级<code>MemoryRegion</code>，<code>current_map</code>指向<code>AddressSpace</code> 的<code>root</code>通过<code>generate_memory_topology()</code>生成的 <code>FlatView</code></li><li><code>FlatView</code> 中的<code>ranges</code>数组表示该<code>MemoryRegion</code> 所表示的<code>Guest</code>地址区间【GPA 的整个平坦物理空间】，并按照地址的顺序进行排列</li><li><code>MemoryRegionSection</code> 由<code>ranges</code>数组中的 <code>FlatRange</code> 对应生成，作为注册到 <code>KVM</code>中的基本单位</li></ul><hr><p><code>QEMU</code> 在用户空间申请内存后，需要将内存信息通过一系列系统调用传入内核空间的 <code>KVM</code>，由 <code>KVM</code> 侧进行管理，因此 <code>QEMU</code> 侧也定义了一些用于向 <code>KVM</code> 传递参数的结构体。</p><p>以下为<code>KVM</code>相关的数据结构。</p><h3 id="KVMSlot"><a href="#KVMSlot" class="headerlink" title="KVMSlot"></a>KVMSlot</h3><p><code>在 kvm_init.h</code>中定义，是 <code>KVM</code> 中内存管理的基本单位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KVMSlot</span></span><br><span class="hljs-class">&#123;</span><br>    hwaddr start_addr; <span class="hljs-comment">// Guest 物理地址，GPA</span><br>    <span class="hljs-keyword">ram_addr_t</span> memory_size;        <span class="hljs-comment">// 内存大小</span><br>    <span class="hljs-keyword">void</span> *ram; <span class="hljs-comment">// QEMU 用户空间地址，HVA</span><br>    <span class="hljs-keyword">int</span> slot;  <span class="hljs-comment">// Slot 编号</span><br>    <span class="hljs-keyword">int</span> flags; <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    <span class="hljs-comment">/* Dirty bitmap cache for the slot */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *dirty_bmap;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> dirty_bmap_size;<br>    <span class="hljs-comment">/* Cache of the address space ID */</span><br>    <span class="hljs-keyword">int</span> as_id;<br>    <span class="hljs-comment">/* Cache of the offset in ram address space */</span><br>    <span class="hljs-keyword">ram_addr_t</span> ram_start_offset;<br>&#125; KVMSlot;<br></code></pre></td></tr></table></figure><p><code>KVMSlot</code> 类似于内存插槽的概念。</p><h3 id="kvm-userspace-memory-region"><a href="#kvm-userspace-memory-region" class="headerlink" title="kvm_userspace_memory_region"></a>kvm_userspace_memory_region</h3><p>调用<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>时需要向 <code>KVM</code> 传递的参数，在<code>kvm.h</code>中定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* for KVM_SET_USER_MEMORY_REGION */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;            <span class="hljs-comment">// slot 编号</span><br>    __u32 flags;           <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    __u64 guest_phys_addr; <span class="hljs-comment">// Guest 物理地址，GPA</span><br>    __u64 memory_size;     <span class="hljs-comment">// 内存大小，bytes</span><br>    __u64 userspace_addr;  <span class="hljs-comment">// 从 QEMU 进程空间分配的起始地址，HVA</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="MemoryListener"><a href="#MemoryListener" class="headerlink" title="MemoryListener"></a>MemoryListener</h3><h4 id="结构体定义-5"><a href="#结构体定义-5" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>为了监控虚拟机的物理地址访问，对于每一个 <code>AddressSpace</code>，都会有一个 <code>MemoryListener</code> 与之对应。每当物理映射<code>GPA-&gt;HVA</code>发生改变时，就会回调这些函数。<strong>MemoryListener</strong> 是对一些事件的<strong>回调函数合集</strong>，在<code>memory.h</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MemoryListener: callbacks structure for updates to the physical memory map</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Allows a component to adjust to changes in the guest-visible memory map.</span><br><span class="hljs-comment"> * Use with memory_listener_register() and memory_listener_unregister().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryListener</span> &#123;</span><br>    <span class="hljs-keyword">void</span> (*begin)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*commit)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*region_add)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*region_del)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*region_nop)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_start)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_stop)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_sync)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_global_start)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*log_global_stop)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*eventfd_add)(MemoryListener *listener, MemoryRegionSection *section,<br>                        <span class="hljs-keyword">bool</span> match_data, <span class="hljs-keyword">uint64_t</span> data, EventNotifier *e);<br>    <span class="hljs-keyword">void</span> (*eventfd_del)(MemoryListener *listener, MemoryRegionSection *section,<br>                        <span class="hljs-keyword">bool</span> match_data, <span class="hljs-keyword">uint64_t</span> data, EventNotifier *e);<br>    <span class="hljs-comment">/* Lower = earlier (during add), later (during del) */</span><br>    <span class="hljs-keyword">unsigned</span> priority;<br>    MemoryRegion *address_space_filter;<br>    QTAILQ_ENTRY(MemoryListener) link;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="全局变量-memory-listeners"><a href="#全局变量-memory-listeners" class="headerlink" title="全局变量 memory_listeners"></a>全局变量 memory_listeners</h4><p>所有的 <code>MemoryListener</code> 都会挂在全局变量<code>memory_listeners</code>链表上，在<code>memory.c</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">QTAILQ_HEAD</span><span class="hljs-params">(, MemoryListener)</span> memory_listeners</span><br><span class="hljs-function">    </span>= QTAILQ_HEAD_INITIALIZER(memory_listeners);<br></code></pre></td></tr></table></figure><p>在<code>memory.c</code>中枚举了<code>ListenerDirection</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ListenerDirection</span> &#123;</span> Forward, Reverse &#125;;<br></code></pre></td></tr></table></figure><h3 id="重要数据结构总览"><a href="#重要数据结构总览" class="headerlink" title="重要数据结构总览"></a>重要数据结构总览</h3><table><thead><tr><th align="center">结构体名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">AddressSpace</td><td align="left">VM 能看到的一段地址空间，偏向 Host 侧【注意指的是偏向】</td></tr><tr><td align="center">MemoryRegion</td><td align="left">地址空间中一段逻辑层面的内存区域，偏向 Guest 侧</td></tr><tr><td align="center">RAMBlock</td><td align="left">记录实际分配的内存地址信息，存储了 GPA-&gt;HVA 的映射关系</td></tr><tr><td align="center">FlatView</td><td align="left">MemoryRegion 对应的平面展开视图，包含一个 FlatRange 类型的 ranges 数组</td></tr><tr><td align="center">FlatRange</td><td align="left">对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中</td></tr><tr><td align="center">MemoryRegionSection</td><td align="left">表示 MemoryRegion 中的片段</td></tr><tr><td align="center">MemoryListener</td><td align="left">回调函数集合</td></tr><tr><td align="center">KVMSlot</td><td align="left">KVM 中内存管理的基本单位，表示一个内存插槽</td></tr><tr><td align="center">kvm_userspace_memory_region</td><td align="left">调用 ioctl(KVM_SET_USER_MEMORY_REGION) 时需要向 KVM 传递的参数</td></tr></tbody></table><h2 id="具体实现机制"><a href="#具体实现机制" class="headerlink" title="具体实现机制"></a>具体实现机制</h2><p>QEMU 的内存申请流程大致可分为三个部分：回调函数的注册、AddressSpace 的初始化、实际内存的分配。下面将根据在 vl.c 的 main() 函数中的调用顺序分别介绍。</p><h3 id="回调函数的注册"><a href="#回调函数的注册" class="headerlink" title="回调函数的注册"></a>回调函数的注册</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125133808.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">configure_accelerator</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       └─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">()</span>                                     <span class="hljs-comment">// 初始化 KVM</span></span><br><span class="hljs-function">            ├─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_ioctl</span><span class="hljs-params">(KVM_CREATE_VM)</span>                  <span class="hljs-comment">// 创建 VM</span></span><br><span class="hljs-function">            ├─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_arch_init</span><span class="hljs-params">()</span>                           <span class="hljs-comment">// 针对不同的架构进行初始化</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">()</span>               <span class="hljs-comment">// 注册 kvm_memory_listener</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">()</span> <span class="hljs-comment">// 调用 region_add 回调</span></span><br><span class="hljs-function">                      └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span>        <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">                           └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">                                └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                     └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br></code></pre></td></tr></table></figure><p>进入<code>configure_accelerator()</code>后，<code>QEMU</code>会先调用<code>configure_accelerator()</code>设置 <code>KVM</code> 的加速支持，之后进入<code>kvm_init()</code>。该函数主要完成对 KVM 的初始化，包括一些常规检查如 <code>CPU</code> 个数、<code>KVM</code> 版本等，之后通过<code>kvm_ioctl(KVM_CREATE_VM)</code>与内核交互，创建 <code>KVM</code> 虚拟机。在<code>kvm_init()</code>的最后，会调用<code>memory_listener_register()</code>注册<code>kvm_memory_listener</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">(MachineState *ms)</span></span><br><span class="hljs-function"></span>&#123;<br>    MachineClass *mc = MACHINE_GET_CLASS(ms);<br>    <span class="hljs-comment">// 打开/dev/kvm</span><br>    s-&gt;fd = qemu_open_old(<span class="hljs-string">&quot;/dev/kvm&quot;</span>, O_RDWR);<br>    <span class="hljs-comment">// 创建 VM</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        ret = kvm_ioctl(s, KVM_CREATE_VM, type);<br>    &#125; <span class="hljs-keyword">while</span> (ret == -EINTR);<br><span class="hljs-comment">/* ... */</span><br>    ret = kvm_arch_init(s); <span class="hljs-comment">// 针对不同的架构进行初始化</span><br><br>    <span class="hljs-comment">// 对于以下 AddressSpace，设置其对应的 listener</span><br>    kvm_memory_listener_register(s, &amp;s-&gt;memory_listener,<br>                                 &amp;address_space_memory, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;kvm-memory&quot;</span>);<br>    memory_listener_register(&amp;kvm_coalesced_pio_listener,<br>                             &amp;address_space_io);<br><span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">(MemoryListener *listener, AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryListener *other = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* Only one of them can be defined for a listener */</span><br>    assert(!(listener-&gt;log_sync &amp;&amp; listener-&gt;log_sync_global));<br><br>    listener-&gt;address_space = as;<br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;memory_listeners)<br>        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;memory_listeners)-&gt;priority) &#123;<br>        QTAILQ_INSERT_TAIL(&amp;memory_listeners, listener, link);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        QTAILQ_FOREACH(other, &amp;memory_listeners, link) &#123;<br>            <span class="hljs-keyword">if</span> (listener-&gt;priority &lt; other-&gt;priority) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        QTAILQ_INSERT_BEFORE(other, listener, link);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;as-&gt;listeners)<br>        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;as-&gt;listeners)-&gt;priority) &#123;<br>        QTAILQ_INSERT_TAIL(&amp;as-&gt;listeners, listener, link_as);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        QTAILQ_FOREACH(other, &amp;as-&gt;listeners, link_as) &#123;<br>            <span class="hljs-keyword">if</span> (listener-&gt;priority &lt; other-&gt;priority) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        QTAILQ_INSERT_BEFORE(other, listener, link_as);<br>    &#125;<br><br>    listener_add_address_space(listener, as);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后的<code>listener_add_address_space()</code>主要是将 listener 注册到其对应的 <code>AddressSpace</code> 上，并根据 <code>AddressSpace</code> 对应的 <code>FlatRange</code> 数组，生成 <code>MemoryRegionSection</code>【<code>MemoryRegionSection</code>就像是为<code>FlatRange</code>数组设置的一种中介表示，便于传入<code>KVM</code>，因为传入<code>KVM</code>应该是对平坦内存的一种表示】，并注册到 <code>KVM</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">(MemoryListener *listener,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    FlatView *view;<br>    FlatRange *fr;<br><br>    <span class="hljs-keyword">if</span> (listener-&gt;begin) &#123;<br>        listener-&gt;begin(listener);<br>    &#125;<br>    <span class="hljs-comment">/* 开启内存脏页记录 */</span><br>    <span class="hljs-keyword">if</span> (global_dirty_tracking) &#123;<br>        <span class="hljs-keyword">if</span> (listener-&gt;log_global_start) &#123;<br>            listener-&gt;log_global_start(listener);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 遍历 AddressSpace 对应的 FlatRange 数组，并将其转换成 MemoryRegionSection */</span><br>    view = address_space_get_flatview(as);<br>    FOR_EACH_FLAT_RANGE(fr, view) &#123;<br>        MemoryRegionSection section = section_from_flat_range(fr, view);<br>        <span class="hljs-comment">/* 将 section 所代表的内存区域注册到 KVM 中 */</span><br>        <span class="hljs-keyword">if</span> (listener-&gt;region_add) &#123;<br>            listener-&gt;region_add(listener, &amp;section);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fr-&gt;dirty_log_mask &amp;&amp; listener-&gt;log_start) &#123;<br>            listener-&gt;log_start(listener, &amp;section, <span class="hljs-number">0</span>, fr-&gt;dirty_log_mask);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (listener-&gt;commit) &#123;<br>        listener-&gt;commit(listener);<br>    &#125;<br>    flatview_unref(view);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于此时 <code>AddressSapce</code> 尚未初始化，所以此处的循环为空，仅是在全局注册了<code>kvm_memory_listener</code>。最后调用了<code>kvm_memory_listener-&gt;region_add()</code>，对应的实现是<code>kvm_region_add()</code>，该函数最终会通过<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>，将 <code>QEMU</code> 侧申请的内存信息传入 <code>KVM</code> 进行注册，这里的流程会在下一部分进行分析。</p><h3 id="AddressSpace-的初始化"><a href="#AddressSpace-的初始化" class="headerlink" title="AddressSpace 的初始化"></a>AddressSpace 的初始化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125154841.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">void</span> <span class="hljs-title">cpu_exec_init_all</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       ├─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_map_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 初始化 system_memory/io 这两个全局 MemoryRegion</span></span><br><span class="hljs-function">       |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">set_system_memory_map</span><span class="hljs-params">()</span> <span class="hljs-comment">// address_space_memory-&gt;root = system_memory</span></span><br><span class="hljs-function">       |    |    └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_update_topology</span><span class="hljs-params">()</span>        <span class="hljs-comment">// 为 MemoryRegion 生成 FlatView</span></span><br><span class="hljs-function">       |    |         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">()</span>   <span class="hljs-comment">// as-&gt;current_map = new_view</span></span><br><span class="hljs-function">       |    |              └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    |                   └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span>        <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">       |    |                        └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">       |    |                             └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    |                                  └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br><span class="hljs-function">       |    |</span><br><span class="hljs-function">       |    └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">()</span> <span class="hljs-comment">// 注册对应的 MemoryListener</span></span><br><span class="hljs-function">       |         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |</span><br><span class="hljs-function">       └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io_mem_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_io</span><span class="hljs-params">()</span> <span class="hljs-comment">// ram/rom/unassigned/notdirty/subpage-ram/watch</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>第一部分在全局注册了<code>kvm_memory_listener</code>，但由于<code>AddressSpace</code> 尚未初始化，实际上并未向 <code>KVM</code> 中注册任何实际的内存信息。<code>QEMU</code> 在<code>main()</code>函数中会继续调用<code>cpu_exec_init_all()</code>对<code>AddressSpace</code>进行初始化，该函数实际上是对两个 <code>init</code> 函数的封装调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cpu_exec_init_all</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    qemu_mutex_init(&amp;ram_list.mutex);<br>    <span class="hljs-comment">/* The data structures we set up here depend on knowing the page size,</span><br><span class="hljs-comment">     * so no more changes can be made after this point.</span><br><span class="hljs-comment">     * In an ideal world, nothing we did before we had finished the</span><br><span class="hljs-comment">     * machine setup would care about the target page size, and we could</span><br><span class="hljs-comment">     * do this much later, rather than requiring board models to state</span><br><span class="hljs-comment">     * up front what their requirements are.</span><br><span class="hljs-comment">     */</span><br>    finalize_target_page_bits();<br>    io_mem_init();      <span class="hljs-comment">// 初始化六个I/O MemoryRegion</span><br>    memory_map_init(); <span class="hljs-comment">// 初始化两个全局 AddressSpace，以及对应的 MemoryRegion、FlatView</span><br>    qemu_mutex_init(&amp;map_client_list_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>先来看<code>memory_map_init()</code>，主要用来初始化两个全局的系统地址空间<code>system_memory</code>、<code>system_io</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_map_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    system_memory = g_malloc(<span class="hljs-keyword">sizeof</span>(*system_memory));<br>    <span class="hljs-comment">// 1. 初始化 system_memory</span><br>    memory_region_init(system_memory, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;system&quot;</span>, UINT64_MAX);<br>    <span class="hljs-comment">// 2. 设置 address_space_memory 关联 system_memory</span><br>    <span class="hljs-comment">// 这两个都是全局变量，也就是把内存地址空间和 IO 地址空间于对应的 MemoryRegion 联系起来 </span><br>    <span class="hljs-comment">//及其对应的 FlatView</span><br>    address_space_init(&amp;address_space_memory, system_memory, <span class="hljs-string">&quot;memory&quot;</span>);<br><br>    system_io = g_malloc(<span class="hljs-keyword">sizeof</span>(*system_io));<br>    <span class="hljs-comment">// 1. 初始化 system_io  </span><br>    memory_region_init_io(system_io, <span class="hljs-literal">NULL</span>, &amp;unassigned_io_ops, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;io&quot;</span>,<br>                          <span class="hljs-number">65536</span>);<br>    <span class="hljs-comment">// 2. 设置 address_space_io 关联 system_io </span><br>    <span class="hljs-comment">// 及其对应的 FlatView</span><br>    address_space_init(&amp;address_space_io, system_io, <span class="hljs-string">&quot;I/O&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里比较重要的是<code>address_space_init()</code>，先设置 <code>AddressSpace</code> 对应的 <code>MemoryRegion</code>，之后根据<code>system_memory</code>更新<code>address_space_memory</code>对应的 <code>FlatView</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">address_space_init</span><span class="hljs-params">(AddressSpace *as, MemoryRegion *root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_ref(root);<br>    <span class="hljs-comment">// 将 address_space_memory 的 root 域指向 system_memory</span><br>    as-&gt;root = root;        <br>    as-&gt;current_map = <span class="hljs-literal">NULL</span>;<br>    as-&gt;ioeventfd_nb = <span class="hljs-number">0</span>;<br>    as-&gt;ioeventfds = <span class="hljs-literal">NULL</span>;<br>    QTAILQ_INIT(&amp;as-&gt;listeners);<br>    QTAILQ_INSERT_TAIL(&amp;address_spaces, as, address_spaces_link);<br>    as-&gt;name = g_strdup(name ? name : <span class="hljs-string">&quot;anonymous&quot;</span>);<br>    <span class="hljs-comment">// 根据 system_memory 更新 address_space_memory 对应的 FlatView</span><br>    address_space_update_topology(as);  <br>    address_space_update_ioeventfds(as);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>address_space_update_topology()</code>会继续调用<code>generate_memory_topology()</code>生成 <code>AddressSpace</code> 对应的 <code>FlatView</code>视图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">(AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);<br><br>    flatviews_init();<br>    <span class="hljs-keyword">if</span> (!g_hash_table_lookup(flat_views, physmr)) &#123;<br>        generate_memory_topology(physmr);<br>    &#125;<br>    address_space_set_flatview(as);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>address_space_update_topology()</code>会先调用<code>generate_memory_topology()</code>生成<code>system_memory</code>更新后的视图<code>new_view</code>，再将<code>address_space_memory</code>的<code>current_map</code>指向这个<code>new_view</code>，最后销毁<code>old_view</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_set_flatview</span><span class="hljs-params">(AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    FlatView *old_view = address_space_to_flatview(as);<br>    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);<br>    FlatView *new_view = g_hash_table_lookup(flat_views, physmr);<br><br>    assert(new_view);<br><br>    <span class="hljs-keyword">if</span> (old_view == new_view) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_ref(old_view);<br>    &#125;<br><br>    flatview_ref(new_view);<br><br>    <span class="hljs-keyword">if</span> (!QTAILQ_EMPTY(&amp;as-&gt;listeners)) &#123;<br>        FlatView tmpview = &#123; .nr = <span class="hljs-number">0</span> &#125;, *old_view2 = old_view;<br><br>        <span class="hljs-keyword">if</span> (!old_view2) &#123;<br>            old_view2 = &amp;tmpview;<br>        &#125;<br>        address_space_update_topology_pass(as, old_view2, new_view, <span class="hljs-literal">false</span>);<br>        address_space_update_topology_pass(as, old_view2, new_view, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Writes are protected by the BQL.  */</span><br>    qatomic_rcu_set(&amp;as-&gt;current_map, new_view);<br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_unref(old_view);<br>    &#125;<br><br>    <span class="hljs-comment">/* Note that all the old MemoryRegions are still alive up to this</span><br><span class="hljs-comment">     * point.  This relieves most MemoryListeners from the need to</span><br><span class="hljs-comment">     * ref/unref the MemoryRegions they get---unless they use them</span><br><span class="hljs-comment">     * outside the iothread mutex, in which case precise reference</span><br><span class="hljs-comment">     * counting is necessary.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_unref(old_view);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>address_space_update_topology_pass()</code>的最后，会调用<code>MEMORY_LISTENER_UPDATE_REGION</code>这个宏，触发<code>region_add</code>对应的回调函数<code>kvm_region_add()</code>。</p><p>这个宏在<code>memory.c</code>中定义，会将 <code>FlatView</code> 中的 <code>FlatRange</code> 转换为 <code>MemoryRegionSection</code>，作为入参传递给<code>kvm_region_add()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* No need to ref/unref .mr, the FlatRange keeps it alive.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...)  \</span><br><span class="hljs-meta">    do &#123;                                                                \</span><br><span class="hljs-meta">        MemoryRegionSection mrs = section_from_flat_range(fr,           \</span><br><span class="hljs-meta">                address_space_to_flatview(as));                         \</span><br><span class="hljs-meta">        MEMORY_LISTENER_CALL(as, callback, dir, &amp;mrs, ##_args);         \</span><br><span class="hljs-meta">    &#125; while(0)</span><br></code></pre></td></tr></table></figure><p>而<code>kvm_region_add()</code>实际上是对<code>kvm_set_phys_mem()</code>的封装调用。该函数比较复杂，会根据传入的<code>section</code>填充 KVMSlot，再传递给<code>kvm_set_user_memory_region()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">(KVMMemoryListener *kml, KVMSlot *slot, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">new</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    KVMState *s = kvm_state;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">mem</span>;</span><br>    <span class="hljs-keyword">int</span> ret;<br><br>    <span class="hljs-comment">// 根据 KVMSlot 填充 kvm_userspace_memory_region</span><br>    mem.slot = slot-&gt;slot | (kml-&gt;as_id &lt;&lt; <span class="hljs-number">16</span>);<br>    mem.guest_phys_addr = slot-&gt;start_addr;<br>    mem.userspace_addr = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)slot-&gt;ram;<br>    mem.flags = slot-&gt;flags;<br><br>    <span class="hljs-keyword">if</span> (slot-&gt;memory_size &amp;&amp; !<span class="hljs-keyword">new</span> &amp;&amp; (mem.flags ^ slot-&gt;old_flags) &amp; KVM_MEM_READONLY) &#123;<br>        <span class="hljs-comment">/* Set the slot size to 0 before setting the slot to the desired</span><br><span class="hljs-comment">         * value. This is needed based on KVM commit 75d61fbc. */</span><br>        mem.memory_size = <span class="hljs-number">0</span>;<br>        ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> err;<br>        &#125;<br>    &#125;<br>    mem.memory_size = slot-&gt;memory_size;<br>    ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>    slot-&gt;old_flags = mem.flags;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里又将 <code>KVMSlot</code> 转换为 <code>kvm_userspace_memory_region</code>，作为<code>ioctl()</code>的参数，交给内核中的 <code>KVM</code> 进行内存的注册【设置<code>GPA-&gt;HVA</code>的映射关系，在内核空间维护并管理 Guest 的内存】。</p><p>至此 QEMU 侧负责管理内存的数据结构均已完成初始化，<strong>可以参考下面的图片了解各数据结构之间的对应关系</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127155506.png"></p><h3 id="实际内存的分配"><a href="#实际内存的分配" class="headerlink" title="实际内存的分配"></a>实际内存的分配</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127160121.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">void</span> machine-&gt;<span class="hljs-title">init</span><span class="hljs-params">(ram_size, ...)</span></span><br><span class="hljs-function">       └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc_init_pci</span><span class="hljs-params">(ram_size, ...)</span> <span class="hljs-comment">// 初始化虚拟机</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc_init1</span><span class="hljs-params">(system_memory, system_io, ram_size, ...)</span></span><br><span class="hljs-function">                 ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">(pci_memory, <span class="hljs-string">&quot;pci&quot;</span>, ...)</span> <span class="hljs-comment">// pci_memory, rom_memory</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">void</span> <span class="hljs-title">pc_memory_init</span><span class="hljs-params">()</span> <span class="hljs-comment">// 初始化内存，分配实际的物理内存地址</span></span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">()</span> <span class="hljs-comment">// 创建 pc.ram, pc.rom 并分配内存</span></span><br><span class="hljs-function">                      |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |    └─ <span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |         └─ <span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc_from_ptr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |</span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">vmstate_register_ram_global</span><span class="hljs-params">()</span> <span class="hljs-comment">// 将 MR 的 name 写入 RAMBlock 的 idstr</span></span><br><span class="hljs-function">                      |    └─ <span class="hljs-keyword">void</span> <span class="hljs-title">vmstate_register_ram</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |         └─ <span class="hljs-keyword">void</span> <span class="hljs-title">qemu_ram_set_idstr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |</span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_alias</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 初始化 ram_below_4g, ram_above_4g</span></span><br><span class="hljs-function">                      └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_add_subregion</span><span class="hljs-params">()</span> <span class="hljs-comment">// 在 system_memory 中添加 subregions</span></span><br><span class="hljs-function">                           └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_add_subregion_common</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_update_topology</span><span class="hljs-params">()</span> <span class="hljs-comment">// 为 MemoryRegion 生成 FlatView</span></span><br><span class="hljs-function">                                     └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">()</span> <span class="hljs-comment">// as-&gt;current_map = new_view</span></span><br><span class="hljs-function">                                          └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                               └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span> <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">                                                    └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">                                                         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                                              └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br></code></pre></td></tr></table></figure><p>之前的回调函数注册、AddressSpace 的初始化，实际上均没有对应的物理内存。【实际的内存是在 RAMBlock 中】</p><p>我们再回到 <code>qemu</code> 启动的 <code>main</code> 函数中。接下来的初始化过程会调用 <code>pc_init1</code>。在这里面，对于 <code>CPU</code> 虚拟化，我们会调用 <code>pc_cpus_init</code>。另外，<code>pc_init1</code> 还会调用<code>pc_memory_init</code>，进行内存的虚拟化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram, *option_rom_mr;         <span class="hljs-comment">// 两个实体 MR: pc.ram, pc.rom</span><br>    MemoryRegion *ram_below_4g, *ram_above_4g; <span class="hljs-comment">// 两个别名 MR: ram_below_4g, ram_above_4g</span><br><br>    <span class="hljs-comment">/* Allocate RAM.  We allocate it as a single memory region and use</span><br><span class="hljs-comment">     * aliases to address portions of it, mostly for backwards compatibility</span><br><span class="hljs-comment">     * with older qemus that used qemu_ram_alloc().</span><br><span class="hljs-comment">     */</span><br>    ram = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram)); <span class="hljs-comment">// 创建 ram</span><br>    <span class="hljs-comment">// 分配具体的内存（实际上会创建一个 RAMBlock 并将其 offset 值写入 ram.ram_addr，对应 GPA）</span><br>    memory_region_init_ram(ram, <span class="hljs-string">&quot;pc.ram&quot;</span>, below_4g_mem_size + above_4g_mem_size);<br>    <span class="hljs-comment">// 将 MR 的 name 写入 RAMBlock 的 idstr</span><br>    vmstate_register_ram_global(ram);<br>    *ram_memory = ram;<br><br>    <span class="hljs-comment">// 创建 ram_below_4g 表示 4G 以下的内存</span><br>    ram_below_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_below_4g));<br>    memory_region_init_alias(ram_below_4g, <span class="hljs-string">&quot;ram-below-4g&quot;</span>, ram, <span class="hljs-number">0</span>, below_4g_mem_size);<br>    <span class="hljs-comment">// 将 ram_below_4g 挂在 system_memory 下</span><br>    memory_region_add_subregion(system_memory, <span class="hljs-number">0</span>, ram_below_4g);<br><br>    <span class="hljs-keyword">if</span> (above_4g_mem_size &gt; <span class="hljs-number">0</span>) &#123;<br>        ram_above_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_above_4g));<br>        memory_region_init_alias(ram_above_4g, <span class="hljs-string">&quot;ram-above-4g&quot;</span>, ram, below_4g_mem_size, above_4g_mem_size);<br>        memory_region_add_subregion(system_memory, <span class="hljs-number">0x100000000</span>ULL, ram_above_4g);<br>    &#125;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的重点在于<code>memory_region_init_ram()</code>，它通过<code>qemu_ram_alloc()</code>获取 ram 这个 <code>MemoryRegion</code> 对应的 <code>RAMBlock</code> 的<code>offset</code>，并存入<code>ram.ram_addr</code>，这样就可以在<code>ram_list</code>中根据该字段查找 <code>MR</code> 对应的 <code>RAMBlock</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">(MemoryRegion *mr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size); <span class="hljs-comment">// 填充字段，初始化默认值</span><br>    mr-&gt;ram = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示为 RAM</span><br>    mr-&gt;terminates = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示为实体 MemoryRegion</span><br>    mr-&gt;destructor = memory_region_destructor_ram;<br>    mr-&gt;ram_addr = qemu_ram_alloc(size, mr); <span class="hljs-comment">// 这里保存 RAMBlock 的 offset，即 GPA</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而 qemu_ram_alloc() 最终会调用 qemu_ram_alloc_from_ptr()，创建一个对应大小 RAMBlock 并分配内存，返回对应的 GPA 地址存入 mr-&gt;ram_addr 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc_from_ptr</span><span class="hljs-params">(<span class="hljs-keyword">ram_addr_t</span> size, <span class="hljs-keyword">void</span> *host,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   MemoryRegion *mr)</span></span><br><span class="hljs-function"></span>&#123;<br>    RAMBlock *new_block; <span class="hljs-comment">// 创建一个 RAMBlock</span><br><br>    size = TARGET_PAGE_ALIGN(size); <span class="hljs-comment">// 页对齐</span><br>    new_block = g_malloc0(<span class="hljs-keyword">sizeof</span>(*new_block)); <span class="hljs-comment">// 初始化 new_block</span><br><br>    new_block-&gt;mr = mr; <span class="hljs-comment">// 将 new_block-&gt; 指向入参的 MemoryRegion</span><br>    new_block-&gt;offset = find_ram_offset(size); <span class="hljs-comment">// 从 ram_list 中的 RAMBlock 之间找到一段可以满足 size 需求的 gap，并返回起始地址的 offset，对应 GPA</span><br>    <span class="hljs-keyword">if</span> (host) &#123; <span class="hljs-comment">// 新建的 RAMBlock host 字段为空，跳过</span><br>        new_block-&gt;host = host;<br>        new_block-&gt;flags |= RAM_PREALLOC_MASK;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mem_path) &#123; <span class="hljs-comment">// 未指定 mem_path</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (__linux__) &amp;&amp; !defined(TARGET_S390X)</span><br>            new_block-&gt;host = file_ram_alloc(new_block, size, mem_path);<br>            <span class="hljs-keyword">if</span> (!new_block-&gt;host) &#123;<br>                new_block-&gt;host = qemu_vmalloc(size);<br>                qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;-mem-path option unsupported\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (xen_enabled()) &#123;<br>                xen_ram_alloc(new_block-&gt;offset, size, mr);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kvm_enabled()) &#123; <span class="hljs-comment">// 从这里继续</span><br>                <span class="hljs-comment">/* some s390/kvm configurations have special constraints */</span><br>                new_block-&gt;host = kvm_vmalloc(size); <span class="hljs-comment">// 实际上还是调用 qemu_vmalloc(size)</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                new_block-&gt;host = qemu_vmalloc(size); <span class="hljs-comment">// 从 QEMU 的线性空间中分配 size 大小的内存，返回 HVA</span><br>            &#125;<br>            qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);<br>        &#125;<br>    &#125;<br>    new_block-&gt;length = size; <span class="hljs-comment">// 将 length 设置为 size</span><br><br>    QLIST_INSERT_HEAD(&amp;ram_list.blocks, new_block, next); <span class="hljs-comment">// 将该 RAMBlock 插入 ram_list 头部</span><br><br>    ram_list.phys_dirty = g_realloc(ram_list.phys_dirty, <span class="hljs-comment">// 重新分配 ram_list.phys_dirty 的内存空间</span><br>                                       last_ram_offset() &gt;&gt; TARGET_PAGE_BITS);<br>    <span class="hljs-built_in">memset</span>(ram_list.phys_dirty + (new_block-&gt;offset &gt;&gt; TARGET_PAGE_BITS),<br>           <span class="hljs-number">0</span>, size &gt;&gt; TARGET_PAGE_BITS);<br>    cpu_physical_memory_set_dirty_range(new_block-&gt;offset, size, <span class="hljs-number">0xff</span>); <span class="hljs-comment">// 对该 RAMBlock 对应的内存标记为 dirty</span><br><br>    qemu_ram_setup_dump(new_block-&gt;host, size);<br><br>    <span class="hljs-keyword">if</span> (kvm_enabled())<br>        kvm_setup_guest_memory(new_block-&gt;host, size);<br><br>    <span class="hljs-keyword">return</span> new_block-&gt;offset;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来<code>ram</code>【其实就是<code>system memory</code>，整个<code>Guest</code>物理空间的大小】对应的 <code>RAMBlock</code> 中就分配好了 <code>GPA</code> 和 <code>HVA</code>，就可以<strong>将内存信息同步至 KVM 侧</strong>了。</p><p>最后回到<code>pc_memory_init()</code>中，在分配完实际内存后，会先调用<code>memory_region_init_alias()</code>初始化<code>ram_below_4g</code>、<code>ram_above_4g</code>这两个<code>alias</code>，之后调用<code>memory_region_add_subregion()</code>将这两个 <code>alias</code> 指向<code>ram</code>这个实体 <code>MemoryRegion</code>。如下图，该函数最终会触发<code>kvm_region_add()</code>回调，将实际的内存信息传入 <code>KVM</code> 注册。该过程如下图所示，与之前分析的流程相同，此处不再赘述。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163205.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟机的内存管理也是需要用户态的 <code>qemu</code> 和内核态的 <code>KVM</code> 共同完成。为了加速内存映射，需要借助硬件的 <code>EPT</code> 技术。</p><h3 id="QEMU-侧"><a href="#QEMU-侧" class="headerlink" title="QEMU 侧"></a>QEMU 侧</h3><ul><li><p>创建一系列 <code>MemoryRegion</code>，分别表示 <code>Guest</code> 中的 <code>RAM</code>、<code>ROM</code> 等区域。<code>MemoryRegion</code>之间通过 <code>alias</code> 或 <code>subregions</code> 的方式维护相互之间的关系，从而进一步细化区域的定义</p></li><li><p>对于一个实体 <code>MemoryRegion</code>（非 <code>alias</code>），在初始化内存的过程中 <code>QEMU</code> 会创建它所对应的 <code>RAMBlock</code>。该 <code>RAMBlock</code> 通过调用<code>qemu_ram_alloc_from_ptr()</code>从 <code>QEMU</code> 的进程地址空间中<strong>以 mmap 的方式分配内存</strong>，并负责<strong>维护该 MemoryRegion 对应内存的起始 GPA/HVA/size 等相关信息</strong>【在<code>qemu_ram_alloc_from_ptr</code>中创建的新<code>RAMBlock</code>有<code>offset</code>、<code>host</code>的赋值，即<code>GPA-&gt;HVA</code>的对应关系】</p></li><li><p><code>AddressSpace</code> 表示 <code>Guest</code> 的物理地址空间。如果 <code>AddressSpace</code> 中的 <code>MemoryRegion</code> 发生变化，则注册的 <code>listener</code> 会被触发，将所属的 <code>MemoryRegion</code> 树展开生成一维的 <code>FlatView</code>，比较 FlatRange 是否发生了变化。如果是，则调用相应的方法对 <code>MemoryRegionSection</code> 进行检查，更新 <code>QEMU</code> 中的 <code>KVMSlot</code>，同时填充<code>kvm_userspace_memory_region</code>结构体，作为<code>ioctl()</code>的参数更新 <code>KVM</code> 中的<code>kvm_memory_slot</code></p></li></ul><h3 id="KVM-侧"><a href="#KVM-侧" class="headerlink" title="KVM 侧"></a>KVM 侧</h3><ul><li><p>当 <code>QEMU</code> 通过<code>ioctl()</code>创建 <code>vcpu</code> 时，调用<code>kvm_mmu_create()</code>初始化 <code>MMU</code> 相关信息。<br>当 <code>KVM</code> 要进入 <code>Guest</code> 前，<code>vcpu_enter_guest()=&gt;kvm_mmu_reload()</code>会将根级页表地址加载到 <code>VMCS</code>，让 <code>Guest</code> 使用该页表</p></li><li><p>当发生<code>EPT Violation</code> 时，<code>VM-EXIT</code>到 <code>KVM</code> 中。如果是缺页，则根据 <code>GPA</code> 算出 <code>gfn</code>，再根据 <code>gfn</code> 找到对应的 <code>KVMSlot</code>，从中得到对应的 <code>HVA</code>。然后根据 <code>HVA</code> 算出对应的 <code>pfn</code>，确保该 <code>Page</code> 位于内存中。填好缺失的页之后，需要更新 <code>EPT</code>，完善其中缺少的页表项，逐层补全页表</p></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163418.png"></p><blockquote><p>虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即 <code>mmap</code> 分配的虚拟内存空间被访问的时候，先查看 <code>EPT</code> 页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。<br>如果没有映射过，则虚拟机会通过<code>VM-Exit</code>指令回到宿主机模式，通过 <code>handle_ept_violation</code> 补充页表映射。先是通过 <code>handle_mm_fault</code>为虚拟机的物理内存空间分配真正的物理页面，然后通过 <code>__direct_map</code> 添加 <code>EPT</code> 页表映射。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127171031.jpg"></p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://xudaxian.fun/2020/09/03/QEMU%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">“QEMU 内存空间虚拟化及内存管理” - B10g | FΓom 许大仙</a><br><a href="https://www.cnblogs.com/LoyenWang/p/13943005.html">【原创】Linux 虚拟化 KVM-Qemu 分析（五）之内存虚拟化 - LoyenWang - 博客园</a><br><a href="https://blog.csdn.net/xiongwenwu/article/details/58586013">KVM/Qemu 工作原理系列目录_xiongwenwu 的专栏-CSDN 博客_qemu 目录结构</a><br><a href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU 源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 VSCode 配置远程连接，过程试图写入的管道不存在</title>
    <link href="/2022/01/19/%E8%A7%A3%E5%86%B3VSCode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%87%E7%A8%8B%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8/"/>
    <url>/2022/01/19/%E8%A7%A3%E5%86%B3VSCode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%87%E7%A8%8B%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201192309069.png"></p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>本地记录的服务器信息和现有的产生了冲突</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>将<code>known_hosts</code>文件的内容全部删除。</p><p><code>C:\Users\user name\.ssh\known_hosts</code></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>搜遍全网几乎都是上述方法，应该绝大部分人通过上述方法都能解决。如果你也跟我一样不走运，不管是重新生成公私钥，还是删除<code>hnow_hosts</code>都不行，那么可以尝试修改 VSCode 使用的<code>ssh.exe</code>。Windows 下默认使用的是环境变量里配置的<code>OpenSSH</code>提供的<code>ssh.exe</code>。你可以将环境变量里的<code>OpenSSH</code>删除。然后在<code>VSCode</code>设置里搜索<code>remote</code>，也就是设置插件<code>remote ssh</code>。</p><p>将 Path 强制设置成<code>Git</code>安装包内的<code>ssh.exe</code></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201192304598.png"></p><p>或者<code>mobaxterm</code>安装包内的<code>ssh.exe</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://codeantenna.com/a/8z5QCm29iy">Debug | VSCode | 过程试图写入的管道不存在 - CodeAntenna</a></p><p><a href="https://blog.csdn.net/weixin_42096901/article/details/105193366">VScode 通过 remote ssh 连接虚拟机 &amp; 报错 过程试图写入的管道不存在（已解决）_Tasdily 的博客-CSDN 博客_vscode 过程试图写入的管道不存在</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 帧缓冲</title>
    <link href="/2022/01/17/Linux%E5%B8%A7%E7%BC%93%E5%86%B2/"/>
    <url>/2022/01/17/Linux%E5%B8%A7%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220118092227.png"></p><h2 id="帧缓冲主要结构"><a href="#帧缓冲主要结构" class="headerlink" title="帧缓冲主要结构"></a>帧缓冲主要结构</h2><ul><li><p>fb_info<br>  该结构体记录当前帧缓冲设备的状态信息，如果系统中有多个帧缓冲设备，就需要两个fb_info结构，这个结构只在内核中可以看到，对用户空间不可见。</p></li><li><p>fb_var_screeninfo<br>  该结构体记录指定的帧缓冲设备和显示模式中可以被修改的信息，其中包括显示器分辨率等信息。</p></li><li><p>fb_fix_screeninfo<br>  该结构体表示帧缓冲设备中一些不能修改的参数，包括特定的显示模式，屏幕缓冲区的物理地址，显示缓冲区的长度信息。</p></li><li><p>fb_ops<br>  LCD底层硬件操作接口集。比如<code>fb_open</code>、<code>fb_release</code>、<code>fb_read</code>、<code>fb_write</code>、<code>fb_ioctl</code>、<code>fb_mmap</code>等：</p></li><li><p>fb_cmap<br>  <code>fb_cmap</code>指定颜色映射，用于以内核可以理解的方式存储用户的颜色定义。</p></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220117192106.png"></p><h2 id="帧缓冲显示原理"><a href="#帧缓冲显示原理" class="headerlink" title="帧缓冲显示原理"></a>帧缓冲显示原理</h2><p>帧缓冲设备是一种显示抽象的设备，也可以被理解为它是一个内存区域，上面的应用程序可以直接对显示缓冲区进行读和写操作，就像访问文件的通用接口一样，用户可以认为帧缓冲是一块内存，能读取数据的内存块也可以向这个内存写入数据，因此显示器显示图形界面实际上根据根据的是指定的内存数据块内的数据。</p><p>帧缓冲的显示缓冲区位于 Linux 内核地址空间，应用程序不能直接访问内核地址空间，在 Linux 中，只有一个内存的内核地址空间映射到用户地址空间才可以由用户访问，内存的映射是通过<code>MMAP</code>函数实现的在 Linux 中。对于帧缓冲，虚拟地址是通过内存映射的方法将显示缓冲区内核地址映射到用户空间的，然后用户可以通过读和写这部分的虚拟地址来访问显示缓冲区，在屏幕上绘图。</p><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><p>使用帧缓冲之前应该首先确定 Linux 系统上已安装了帧缓冲驱动，可以在目录<code>/dev/</code>下查找<code>fb*</code>如，<code>/dev/fb0, /dev/fb1</code>等设备来确定是否安装。如果没有需要安装一个帧缓冲驱动的模块到内核，或者重新编译内核生成一个带帧缓冲模块的镜像。</p><p>使用帧缓冲需要进入控制台模式，即纯命令行的模式进行编程。一般可以通过快捷键<code>CTRL+ALT+F1</code>进入控制台模式，<code>CTRL+ALT+F7</code>切回图形窗口。如果控制台模式没有登录，可以<code>CTRL+ALT+F6</code>尝试登录。</p><p>因硬件显示设备的物理显示区是通过帧缓存区操作，而帧缓存区是处于内核空间，应用程序不能随意操作，此时可以通过系统调用<code>mmap</code>把帧缓存映射到用户空间，在用户空间中创建出帧缓存映射区（用户图像数据缓存区），以后只需把用户图像数据写入到帧缓存映射区就可在硬件设备上显示图像。</p><p>具体实现流程如下：</p><h3 id="打开帧缓冲设备-dev-f0"><a href="#打开帧缓冲设备-dev-f0" class="headerlink" title="打开帧缓冲设备/dev/f0"></a>打开帧缓冲设备<code>/dev/f0</code></h3><p>在Linux的/dev目录的寻找b*设备文件然后使用读写模式打开它，Linux 系统将使用通用的<code>open</code>系统调用来完成功能， <code>open</code>的功能原型如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>Path</code>是准备打开的文件或设备的路径参数；</li><li><code>oflags</code>指定打开文件时使用的参数；</li><li><code>flags</code>参数的指定，是通过组合文件访问模式和其他的可选模式一起的，可以支持多个模式或，参数必须是指定下列文件的访问模式。<ul><li>只读：O_RDONLLY</li><li>只写：O_WRONLY</li><li>读写：O_RDWR</li></ul></li></ul><p>简而言之， <code>open</code>函数建立设备文件的访问路径。如果操作成功，它返回一个文件描述符，只是一个文件描述符，它将不使用其他任何正在运行的进程共享。如果两个程序同时打开相同的文件，将得到两个不同的文件描述符。如果他们执行文件写入操作，他们将操作每个文件描述符，不会发生冲突，写完之后退出。他们的数据不会互相交织在一起的，但会互相的彼此覆盖 (后写完的内容覆盖前面写的内容)，两个程序来读取和写入的文件位置看似一样但是有各自不同拷贝所以不会发生交织。如果<code>open</code>调用未能返回<code>1</code>，则将全局变量<code>errno</code>设置为指示失败的原因。</p><h3 id="通过系统调用ioctl函数获得帧设备相关信息"><a href="#通过系统调用ioctl函数获得帧设备相关信息" class="headerlink" title="通过系统调用ioctl函数获得帧设备相关信息"></a>通过系统调用<code>ioctl</code>函数获得帧设备相关信息</h3><p>通过顿缓冲文件描述符，屏幕的分辨率、颜色深度等信息可以被获得，帧缓冲驱动中存放了这些对应的信息，必须使用 Linux 系统调用<code>ioctl</code>首先将帧缓冲的文件描述符和<code>fb_var_screeninfo</code> 结构体对应起来。</p><p>结构体<code>fb_var_screeninfo</code>包含以下三个重要数据结构：</p><ul><li>屏幕的 x 方向分辨率，像素作为单位。</li><li>屏幕的 Y 方向分辨率，像素作为单位。</li><li>屏幕的像素颜色深度，每个像素用多少比特数表示。</li></ul><p><code>ioctl</code>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> __request, ...)</span> __THROW</span>;<br></code></pre></td></tr></table></figure><p><code>ioctl</code>调用实现访问设备驱动各种各样的配置信息功能，它提供了一个控制设备的行为和配置底层服务接口的驱动函数，各种设备驱动程序，例如套接字和系统终端，还有磁带机都有<code>ioctl</code>命令可以支持。</p><ul><li><code>__fd</code>：<code>ioctl</code>命令中是该帧缓冲的文件描述符；</li><li><code>__request</code>：<code>ioctl</code>函数将要执行的命令，实现参数给定的对象描述符中指定的函数操作，各种设备支持的功能是有差异的<ul><li><code>FBIOGET_VSCREENINFO</code>命令字返回与Framebuffer有关的固定的信息；</li><li><code>FBIOGET_VSCREENINFO</code>命令字返回与 Framebuffer 有关的可变的信息；</li></ul></li><li>第三个参数是一个指针用来指向结构体<code>fb_var_screeninfo</code>。</li></ul><p>最后使用者可以通过结构体<code>fb_var_screeninfo</code>来获得屏幕的分辨率和颜色位深和其他重要的屏幕信息。根据这些信息可以计算屏幕缓冲区的大小：屏幕缓冲区大小 (以字节为单位) = 屏幕宽度x高度x屏幕颜色深度/8</p><h3 id="帧缓冲映射"><a href="#帧缓冲映射" class="headerlink" title="帧缓冲映射"></a>帧缓冲映射</h3><p>在进行帧缓冲的<code>MMAP</code>映射之前，要先得到帧缓冲文件描述符，才能像屏幕上面显示，必须首先将缓冲区的内核地址映射映射到用户地址空间。Linux 系统将使用<code>MMAP</code>系统调用完成功能，<code>MMAP</code>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">mmap</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *__addr, <span class="hljs-keyword">size_t</span> __len, <span class="hljs-keyword">int</span> __prot,</span></span><br><span class="hljs-params"><span class="hljs-function">     <span class="hljs-keyword">int</span> __flags, <span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">__off_t</span> __offset)</span> __THROW</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>__addr</code>：返回一个指向<code>mmap</code>函数的内存区域的指针，与内容相关的文件指针，通过指针可以访问帧缓冲区的内存区域。</p></li><li><p><code>__len</code>：可以请求使用特定内存地址，通过设置地址参数，如果值为<code>0</code>，将自动分配指针，这是推荐的做法，否则会降低程序的可移植性，因为不同的系统可用的地址范围是不一样的。</p></li><li><p><code>__prot</code>：设置内存访问的权限设定，通过端口相关的参数定义，位的定义值如下：</p><ul><li><code>PORT_EXEC</code>:允许内存段的执行。</li><li><code>PORT_NONE</code>:无法访问内存段。</li><li><code>PORT_READ</code>:允许读取内存段。</li><li><code>PORT_WRITE</code>:允许编写内存段。</li></ul></li><li><p><code>__flags</code>：改变控制参数标志，能够影响该内存段的作用域，如下所示：</p><ul><li><code>MAP_FIXED</code>:内存段必须位于addr中指定的地址。</li><li><code>MAP_SHARED</code>:内存的修改保存到一个文件中。</li><li><code>MAP_PRIVATE</code>:内存段是私人的，变化仅在本地范围内有效。</li></ul></li><li><p><code>__fd</code>：是通过一个<code>open</code>调用得到的访问文件的描述符。</p></li><li><p><code>offset</code>：用于指定访问数据的开始偏移量在内存段中，和访问普通文件使用方式是相同的，再指定文件描述符参数，以及访问的数据长度参数即可。</p></li></ul><h3 id="读写帧缓冲"><a href="#读写帧缓冲" class="headerlink" title="读写帧缓冲"></a>读写帧缓冲</h3><p><code>MMAP</code>返回的指针，可以访问到帧缓冲内存区，可以定位到屏幕缓冲区具体为每个显示像素的位置，通过读函数调用读取对应的位置数据在帧缓冲内存中，相反写操作对应于内存的写入数据可以显示内容写到屏幕上。</p><h3 id="解除帧缓冲映射"><a href="#解除帧缓冲映射" class="headerlink" title="解除帧缓冲映射"></a>解除帧缓冲映射</h3><p>在绘图完成后，帧缓冲文件描述符必须被释放之前，解除帧缓冲区的地址映射，使用 Linux 系统调用完成<code>mmap</code>函数的逆函数实现，即是<code>munmap</code>，函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *__addr, <span class="hljs-keyword">size_t</span> __len)</span> __THROW</span>;<br></code></pre></td></tr></table></figure><p><code>addr</code>参数应该与调用<code>MMAP</code>时指定的参数值一致， <code>len</code>参数也应该与之前调用<code>MMAP</code>时指定的<code>len</code>参数保持一致。</p><p><code>mmap</code>调用返回<code>0</code>成功，失败则返回<code>1</code>，同时将全局变量<code>erno</code>设置为指示失败的原因。</p><h3 id="调用close关闭设备"><a href="#调用close关闭设备" class="headerlink" title="调用close关闭设备"></a>调用<code>close</code>关闭设备</h3><p>使用帧缓冲设备后，应关闭相应的文件描述符，使用 Linux 系统标准的函数完成关闭功能，<code>close</code>函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">close</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> __fd)</span></span>;<br></code></pre></td></tr></table></figure><p><code>close</code>的参数和在开始调用<code>open</code>时指定的参数一致，文件描述符释放后可以重用，结束调用成功返回<code>0</code>，失败返回<code>1</code>。</p><h2 id="帧缓冲实例"><a href="#帧缓冲实例" class="headerlink" title="帧缓冲实例"></a>帧缓冲实例</h2><p>以下代码摘自<a href="https://github.com/xianjimli/linux-framebuffer-tools">xianjimli/linux-framebuffer-tools: linux framebuffer tool</a>，演示了帧缓冲设备的使用流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">fb_info_t</span> *<span class="hljs-title">linux_fb_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint32_t</span>                 size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">fb_info_t</span>               *fb   = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_fix_screeninfo</span> <span class="hljs-title">fix</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_var_screeninfo</span> <span class="hljs-title">var</span>;</span><br>    return_value_if_fail(filename != <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    fb = (<span class="hljs-keyword">fb_info_t</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">fb_info_t</span>));<br>    return_value_if_fail(fb != <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 打开帧缓冲设备，O_RDWR 读写模式</span><br>    fb-&gt;fd = open(filename, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fb-&gt;fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        log_debug(<span class="hljs-string">&quot;open %s failed(%d)\n&quot;</span>, filename, errno);<br>        <span class="hljs-built_in">free</span>(fb);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">// 通过系统调用 ioctl 函数获得帧设备相关信息</span><br>    <span class="hljs-comment">// FBIOGET_FSCREENINFO 命令字返回与 Framebuffer 有关的固定的信息</span><br>    <span class="hljs-keyword">if</span> (ioctl(fb-&gt;fd, FBIOGET_FSCREENINFO, &amp;fix) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> fail;<br>    <span class="hljs-comment">//命令字返回与 Framebuffer 有关的可变的信息</span><br>    <span class="hljs-keyword">if</span> (ioctl(fb-&gt;fd, FBIOGET_VSCREENINFO, &amp;var) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> fail;<br><br>    var.xoffset = <span class="hljs-number">0</span>;<br>    var.yoffset = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 显示</span><br>    ioctl(fb-&gt;fd, FBIOPAN_DISPLAY, &amp;(var));<br><br>    log_debug(<span class="hljs-string">&quot;fb_info_t: %s\n&quot;</span>, filename);<br>    log_debug(<span class="hljs-string">&quot;fb_info_t: xres=%d yres=%d bits_per_pixel=%d mem_size=%d\n&quot;</span>, var.xres, var.yres,<br>              var.bits_per_pixel, fb_size(fb));<br>    log_debug(<span class="hljs-string">&quot;fb_info_t: red(%d %d) green(%d %d) blue(%d %d)\n&quot;</span>, var.red.offset, var.red.length,<br>              var.green.offset, var.green.length, var.blue.offset, var.blue.length);<br><br>    fb-&gt;w           = var.xres;<br>    fb-&gt;h           = var.yres;<br>    fb-&gt;bpp         = var.bits_per_pixel / <span class="hljs-number">8</span>;<br>    fb-&gt;line_length = fix.line_length;<br><br>    size = fb_size(fb);<br>    <span class="hljs-comment">// 帧缓冲映射</span><br>    <span class="hljs-comment">// PROT_READ | PROT_WRITE:可读写</span><br>    <span class="hljs-comment">// MAP_SHARED：内存的修改保存到一个文件</span><br>    fb-&gt;data = (<span class="hljs-keyword">uint8_t</span> *)mmap(<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fb-&gt;fd, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (fb-&gt;data == MAP_FAILED)<br>    &#123;<br>        log_debug(<span class="hljs-string">&quot;map framebuffer failed.\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br><br>    log_debug(<span class="hljs-string">&quot;line_length=%d mem_size=%d\n&quot;</span>, fix.line_length, fb_size(fb));<br>    log_debug(<span class="hljs-string">&quot;xres_virtual =%d yres_virtual=%d xpanstep=%d ywrapstep=%d\n&quot;</span>, var.xres_virtual,<br>              var.yres_virtual, fix.xpanstep, fix.ywrapstep);<br><br>    <span class="hljs-keyword">return</span> fb;<br>fail:<br>    log_debug(<span class="hljs-string">&quot;%s is not a framebuffer.\n&quot;</span>, filename);<br>    close(fb-&gt;fd);<br>    <span class="hljs-built_in">free</span>(fb);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>感兴趣可以下载源码编译运行，其中<code>/bin/fbshow</code>可以使用帧缓冲设备显示图片。图形界面下直接运行可能提示无法运行，需要<code>Chrtl+Alt+F1</code>切换到控制台模式。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220120202118.png"></p><h2 id="LCD-与-Framebuffer-的关系"><a href="#LCD-与-Framebuffer-的关系" class="headerlink" title="LCD 与 Framebuffer 的关系"></a>LCD 与 Framebuffer 的关系</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225141549.jpg"></p><p>LCD 控制器首先通过 VDEN 信号，使能。接下来根据 VCLK 时钟信号，在像素点上“喷涂”不同的颜色（打个比方），控制器有 VD（video data）信号，传送不同颜色信息。每来一个时钟信号，就向右移动一个像素，根据行同步信号 HSYNC，就从最右边移动到最左边。当移动到右下角时根据垂直同步信号 VSYNC。</p><p>那么问题来了，不同颜色的信息从哪里来？就是从上文介绍的 Framebuffer 中来的。</p><p>很多人都会说操纵 LCD 显示就是操纵 FrameBuffer，表面上来看是这样的。实际上是 FrameBuffer 就是 Linux 内核驱动申请的一片内存空间，然后 LCD 内有一片 sram，CPU 内部有个 LCD 控制器，它有个单独的 dma 用来将 FrameBuffer 中的数据拷贝到 LCD 的 sram 中去 拷贝到 LCD 的 sram 中的数据就会显示在 LCD 上，LCD 驱动和 FrameBuffer 驱动没有必然的联系，它只是驱动 LCD 正常工作的，比如有信号传过来，那么 LCD 驱动负责把信号转成显示屏上的内容，至于什么内容这就是应用层要处理的。</p><blockquote><p>静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。<br>DMA（Direct Memory Access），直接内存访问。使用 DMA 的好处就是它不需要 CPU 的干预而直接服务外设，这样 CPU 就可以去处理别的事务，从而提高系统的效率。</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://carlyleliu.github.io/2021/Linux%E9%A9%B1%E5%8A%A8%E4%B9%8BFramebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">Linux 驱动之 Framebuffer 子系统 | 量子范式</a><br><a href="https://www.codenong.com/cs106598190/">Linux 驱动开发（9）——- framebuffer 驱动详解 | 码农家园</a><br><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201502&filename=1015587486.nh&uniplatform=NZKPT&v=KNvhApgKTzqH-mWxqP6f8BkbDR9mSjPHz8PfaxqDg2f1j30XqnHzSDsvwoqz-CbX">嵌入式系统中帧缓冲显示模块的设计与实现 - 中国知网</a><br><a href="https://github.com/tsuibin/research/tree/master/framebuffer/fivechess/fivechess-0.1">research/framebuffer/fivechess/fivechess-0.1 at master · tsuibin/research</a><br><a href="https://www.shangmayuan.com/a/f67d260756ce42258a9ed4ef.html">五子棋 framebuffer 版 - 尚码园</a><br><a href="https://blog.csdn.net/yangwen123/article/details/12096483">FrameBuffer 驱动程序分析_深入剖析 Android 系统-CSDN 博客_framebuffer</a><br><a href="https://github.com/xianjimli/linux-framebuffer-tools">xianjimli/linux-framebuffer-tools: linux framebuffer tool</a><br><a href="https://www.bilibili.com/video/BV1HW411L76t?p=2">韦东山_嵌入式 Linux_第 2 期_Linux 高级驱动视频教程_免费试看版_哔哩哔哩_bilibili</a><br><a href="https://zhuanlan.zhihu.com/p/356443723">Linux LCD Frambuffer 基础介绍和使用（1） - 知乎</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>FrameBuffer</tag>
      
      <tag>LCD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 ssh permission denied(publickey)</title>
    <link href="/2022/01/13/%E8%A7%A3%E5%86%B3Git%20ssh%20permission%20denied(publickey)/"/>
    <url>/2022/01/13/%E8%A7%A3%E5%86%B3Git%20ssh%20permission%20denied(publickey)/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">linux&gt; ssh -p 2221 xxx@gerrit.com<br>xxx@gerrit.com: Permission denied(publickey)<br></code></pre></td></tr></table></figure><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>本次出错是在测试是否能连接 gerrit 时。连接 GitHub 也可能会出现。只要用到 ssh 功能的都有可能。</p><p>出错的原因：</p><ul><li>网页（如 gerrit,github）没有设置公钥，一般为<code>id_rsa.pub</code>内容；</li><li>本地生成了多个公私钥，配对配错了；</li><li>本地没有配置好<code>git</code>，比如<code>git config</code>时用户名或者邮箱填错；</li><li>需要开启 ssh 代理；</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>生成密钥<code>cd ~/.ssh &amp;&amp; ssh-keygen</code></li><li>复制公钥内容，添加到网页中<code>github</code>或者<code>gerrit</code>的设置里。<code>cat id_rsa.pub | xclip</code></li><li>配置<code>git</code>账户<ul><li><code>git config --global user.name &quot;bob&quot;</code></li><li><code>git config --global user.email bob@...</code></li></ul></li></ul><p>以上检查无误，仍然报错</p><ul><li>开启<code>ssh</code>代理<ul><li><code>eval $(ssh-agent -s)</code></li></ul></li><li>将私钥加入代理<ul><li><code>ssh-add ~/.ssh/id_rsa</code></li></ul></li></ul><h2 id="登陆用户时启动-ssh-agent"><a href="#登陆用户时启动-ssh-agent" class="headerlink" title="登陆用户时启动 ssh-agent"></a>登陆用户时启动 ssh-agent</h2><p>如果不幸你的问题就是需要开启<code>ssh-agent</code>，那么每次重启电脑都需要开启一次。这也是相当麻烦的，可以通过将以下配置添加到<code>~/.bashrc</code>中，让 Linux 启动时自动开启<code>ssh-agent</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># Add following code at the end of ~/.bashrc</span><br><br><span class="hljs-comment"># Check if ~/.pid_ssh_agent exists.</span><br><span class="hljs-keyword">if</span> [ -f ~/.pid_ssh_agent ]; <span class="hljs-keyword">then</span><br><br>    <span class="hljs-built_in">source</span> ~/.pid_ssh_agent<br><br>    <span class="hljs-comment"># Check process of ssh-agent still exists.</span><br>    TEST=$(ssh-add -l)<br><br>    <span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$TEST</span>&quot;</span> ]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># Reinit if not.</span><br>        NEED_INIT=1<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">else</span><br>    NEED_INIT=1 <span class="hljs-comment"># PID file doesm&#x27;t exist, reinit it.</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># Try start ssh-agent.</span><br><span class="hljs-keyword">if</span> [ ! -z <span class="hljs-string">&quot;<span class="hljs-variable">$NEED_INIT</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> $(ssh-agent -s) | sed -e <span class="hljs-string">&#x27;s/echo[ A-Za-z0-9]*;//g&#x27;</span> &gt; ~/.pid_ssh_agent <span class="hljs-comment"># save the PID to file.</span><br>    <span class="hljs-built_in">source</span> ~/.pid_ssh_agent<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/2643502/git-how-to-solve-permission-denied-publickey-error-when-using-git">ssh - Git: How to solve Permission denied (publickey) error when using Git? - Stack Overflow</a></p><p><a href="https://fenying.net/post/2017/12/20/auto-init-ssh-agent/">Linux 登陆用户时启动 ssh-agent 并复用 - Fenying</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 安装 Node.js 以及 hexo</title>
    <link href="/2022/01/10/Linux%E5%AE%89%E8%A3%85nodejs/"/>
    <url>/2022/01/10/Linux%E5%AE%89%E8%A3%85nodejs/</url>
    
    <content type="html"><![CDATA[<h2 id="安装-Node-js-过程"><a href="#安装-Node-js-过程" class="headerlink" title="安装 Node.js 过程"></a>安装 Node.js 过程</h2><p>进入该网站<a href="https://nodejs.org/zh-cn/download/">下载 | Node.js</a><br>也可以进入该网站下载历史版本，<a href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js</a></p><p>进入 download 目录，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> download<br><span class="hljs-attribute">wget</span> https://nodejs.org/dist/v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>/node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span>.tar.xz  -O nodejs.tar.xz<br></code></pre></td></tr></table></figure><p>解压</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -xvf node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span>.tar.xz<br></code></pre></td></tr></table></figure><p>改名 Node.js</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span> nodejs<br></code></pre></td></tr></table></figure><p>将 npm，node 两个程序建立软连接，能够全局可用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln -s <span class="hljs-regexp">/download/</span>nodejs<span class="hljs-regexp">/bin/</span>npm <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span> <br><br>ln -s <span class="hljs-regexp">/download/</span>nodejs<span class="hljs-regexp">/bin/</span>node <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span><br></code></pre></td></tr></table></figure><p>检查是否安装</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br><br>npm -v<br></code></pre></td></tr></table></figure><h2 id="安装-hexo-过程"><a href="#安装-hexo-过程" class="headerlink" title="安装 hexo 过程"></a>安装 hexo 过程</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm i hexo-<span class="hljs-keyword">cli</span> -g<br>hexo -v<br></code></pre></td></tr></table></figure><p>如果出现命令未找到到错误，说明 hexo 还未加入全局变量。<br>将下面命令加入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim ~/.bashrc<br>export PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nodejs/</span>lib<span class="hljs-regexp">/node_modules/</span>hexo-cli<span class="hljs-regexp">/bin/</span>:<span class="hljs-variable">$PATH</span> <br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js</a><br><a href="https://learnku.com/articles/32767">Linux 安装 Node.js | F2E 前端技术论坛</a><br><a href="https://segmentfault.com/a/1190000024422534">Linux 下安装 node 及 npm - SegmentFault 思否</a><br><a href="https://zhuanlan.zhihu.com/p/35668237">超详细 Hexo+Github 博客搭建小白教程 - 知乎</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言__attribute__使用</title>
    <link href="/2022/01/08/C%E8%AF%AD%E8%A8%80-attribute-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/08/C%E8%AF%AD%E8%A8%80-attribute-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>__attribute__</code> 其实是个编译器指令，告诉编译器声明的特性，或者让编译器进行更多的错误检查和高级优化。</p><p><code>__attribute__</code> 可以设置<a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Function-Attributes.html#Function-Attributes">函数属性（Function Attribute）</a>、<a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Variable-Attributes.html#Variable-Attributes">变量属性（Variable Attribute）</a>和<a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Type-Attributes.html#Type-Attributes">类型属性（Type Attribute）</a>。每一类都包含数十种属性，本文不会逐一解释，只抛砖引玉，完整属性可以查看链接中的官方文档。</p><p>一个属性说明符的形式是<code>__attribute__ ((attribute-list))</code>。一个属性列表是一个可能为空的逗号分隔的属性序列，其中每个属性都是以下的一个。</p><ul><li>属性为空。空属性会被忽略。</li><li>一个单词（可能是未使用的标识符，也可能是 const 等保留字）。</li><li>一个单词，后面跟着括号中的属性参数。这些参数采用以下形式之一：<ul><li>一个标识符。例如，<code>mode</code>属性使用这种形式。</li><li>一个标识符，后跟一个逗号和一个以逗号分隔的非空表达式列表。例如，<code>format</code>属性使用这种形式。</li><li>一个可能是空的逗号分隔的表达式列表。例如，<code>format_arg</code>属性使用这种形式，该列表是一个单一的整数常量表达式，而<code>alias</code>属性也使用这种形式，该列表是一个单一的字符串常量。</li></ul></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><p>该属性可以设置函数的别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __f() &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;__attribute__ test\n&quot;</span>); &#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((weak, alias(<span class="hljs-string">&quot;__f&quot;</span>)))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  f();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*--- 输出 ---*/</span> <br><span class="hljs-comment">//__attribute__ test</span><br></code></pre></td></tr></table></figure><p>函数<code>f()</code>的别名为<code>__f()</code>，调用<code>f()</code>即调用<code>__f()</code>。</p><h4 id="alloc-size"><a href="#alloc-size" class="headerlink" title="alloc_size"></a>alloc_size</h4><p><code>alloc_size</code>属性用来告诉编译器，函数的返回值指向内存，其中的大小由一个或两个函数参数给出。GCC 使用这些信息来提高<code>__builtin_object_size</code>的正确性。</p><p><code>alloc_size</code>后面可以跟一到二个参数，<code>alloc_size</code> 后面跟的参数是指定使用函数的第几个参数。</p><ul><li><p>函数的参数的个数只有一个，那么 alloc_size 的参数只能是 1。通过<code>__builtin_object_size</code> 获取的值 就是传入的参数值。如图，我们给函数<code>my_malloc</code> 传入的值是<code>100</code> ，那么我们通过<code>__builtin_object_size</code> 获取的值就是<code>100</code>。</p></li><li><p>函数的参数的个数多余两个，那么<code>alloc_size</code> 的最多可以指定两个参数。传入两个参数，<code>__builtin_object_size</code>的值是这两个参数的乘积。传入一个参数，<code>__builtin_object_size</code>的值就是这个参数的值。如图，<code>my_callocd</code>函数指定的参数是<code>alloc_size(2,3)</code>，通过<code>__builtin_object_size</code>获取的值就是<code>my_callocd</code>传入的第二和三个参数的乘积（2*3=6）。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_calloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((alloc_size(<span class="hljs-number">1</span>)))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_realloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((alloc_size(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_calloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_realloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> p = my_calloc(<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size : %ld\n&quot;</span>, __builtin_object_size(p, <span class="hljs-number">0</span>));<br><br>  <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> a = my_realloc(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size : %ld\n&quot;</span>, __builtin_object_size(a, <span class="hljs-number">1</span>));<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*--- 输出 ---*/</span> <br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure><h4 id="constructor-priority-destructor-priority"><a href="#constructor-priority-destructor-priority" class="headerlink" title="constructor (priority) / destructor (priority)"></a>constructor (priority) / destructor (priority)</h4><p><code>constructor</code>属性使该函数在执行进入<code>main()</code>之前被自动调用。同样地，<code>destructor</code>属性使函数在<code>main()</code>完成后或<code>exit()</code>被调用后被自动调用。具有这些属性的函数对于初始化将在程序执行过程中隐含使用的数据非常有用。</p><p><code>constructor</code> 和 <code>+load</code> 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。</p><p>若有多个 <code>constructor</code> 且想控制优先级的话，可以写成 <code>attribute((constructor(101)))</code>，里面的数字越小优先级越高，<code>1 ~ 100</code> 为系统保留。</p><h3 id="变量属性"><a href="#变量属性" class="headerlink" title="变量属性"></a>变量属性</h3><h4 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h4><p>该属性在变量作用域结束时，调用指定的一个函数。这个属性只能应用于自动函数范围的变量；它不能应用于参数或具有静态存储期限的变量。该函数必须接受一个参数，一个指向与变量兼容的类型的指针。函数的返回值（如果有的话）被忽略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_cleanup</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **str)</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after cleanup: %s\n&quot;</span>, *str);<br>  <span class="hljs-built_in">free</span>(*str);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br><br>  <span class="hljs-keyword">char</span> *str __attribute__((__cleanup__(test_cleanup))) = <span class="hljs-literal">NULL</span>;<br>  str = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>((<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)) * <span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;test&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;before cleanup : %s\n&quot;</span>, str);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*--- 输出 ---*/</span> <br><span class="hljs-comment">//before cleanup : test</span><br><span class="hljs-comment">//after cleanup: test</span><br></code></pre></td></tr></table></figure><p>作用域结束包括大括号结束、<code>return</code>、<code>goto</code>、<code>break</code>、<code>exception</code>等各种情况。在上面的实验中，<code>main</code>函数返回标志变量<code>str</code>作用域结束，所以最后才打印<code>after cleanup: test</code>。</p><h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><h4 id="aligned-alignment"><a href="#aligned-alignment" class="headerlink" title="aligned (alignment)"></a>aligned (alignment)</h4><p>这个属性指定了函数的最小对齐方式，以字节为单位。对齐的大小只能增加，不能减小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> &#123;</span><br>  <span class="hljs-keyword">char</span> sex;<br>  <span class="hljs-keyword">int</span> length;<br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">char</span> value[<span class="hljs-number">15</span>];<br>&#125; __attribute__((aligned(<span class="hljs-number">1</span>)));<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> <span class="hljs-title">my_stu</span>;</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d \n&quot;</span>, <span class="hljs-keyword">sizeof</span>(my_stu));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p,%p,%p \n&quot;</span>, &amp;my_stu, &amp;my_stu.length, &amp;my_stu.name,<br>         &amp;my_stu.value);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*---  __attribute__((aligned(1)));输出 ---*/</span> <br><span class="hljs-comment">//28 </span><br><span class="hljs-comment">//0x55af2ba25020 0x55af2ba25024,0x55af2ba25028,0x55af2ba2502a</span><br><span class="hljs-comment">/*---  __attribute__((aligned(4)));输出 ---*/</span> <br><span class="hljs-comment">//28 </span><br><span class="hljs-comment">//0x556fbce54020 0x556fbce54024,0x556fbce54028,0x556fbce5402a </span><br><span class="hljs-comment">/*---  __attribute__((aligned(8)));输出 ---*/</span> <br><span class="hljs-comment">//32 </span><br><span class="hljs-comment">//0x5646e130e040 0x5646e130e044,0x5646e130e048,0x5646e130e04a</span><br></code></pre></td></tr></table></figure><p>由以上代码实验结果发现，默认对齐代下为 4 字节，小于这个值就被忽略，大于 4 字节才生效。</p><h2 id="Refernece"><a href="#Refernece" class="headerlink" title="Refernece"></a>Refernece</h2><p><a href="https://www.jianshu.com/p/e2dfccc32c80"><strong>attribute</strong> 机制使用 - 简书</a><br><a href="https://blog.csdn.net/wangweixaut061/article/details/6549768">C 语言复杂声明解析_wangweixaut061 的专栏-CSDN 博客_c 语言复杂声明</a><br><a href="http://www.360doc.com/content/15/0305/15/14530056_452758913.shtml"><strong>attribute</strong> 你知多少？</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C 语言 typedef 用法</title>
    <link href="/2022/01/07/C%E8%AF%AD%E8%A8%80typedef%E7%94%A8%E6%B3%95/"/>
    <url>/2022/01/07/C%E8%AF%AD%E8%A8%80typedef%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>typedef</code>为 C 语言的关键字，作用是为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char 等）和自定义的数据类型（struct 等）。在使用语法上类似与<code>static</code>，<code>extern</code>等。<br><code>typedef</code> 行为有点像 <code>#define</code> 宏，用其实际类型替代同义字。不同点是 <code>typedef</code>在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。</p><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a; ———— 传统变量声明表达式<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">myint_t</span>; ———— 使用新的类型名<span class="hljs-keyword">myint_t</span>替换变量名a<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">myint_t</span>; ———— 在语句开头加上<span class="hljs-keyword">typedef</span>关键字，<span class="hljs-keyword">myint_t</span>就是我们定义的新类型<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> (*pfunA)(<span class="hljs-built_in">int</span> a); ———— 传统变量（函数）声明表达式<br><span class="hljs-built_in">void</span> (*PFUNA)(<span class="hljs-built_in">int</span> a); ———— 使用新的类型名PFUNA替换变量名pfunA<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">void</span> (*PFUNA)(<span class="hljs-built_in">int</span> a); ———— 在语句开头加上<span class="hljs-keyword">typedef</span>关键字，PFUNA就是我们定义的新类型<br></code></pre></td></tr></table></figure><p>促使我写这篇文章的原因不是如何去用<code>typedef</code>，而是在代码中看不懂如何简化了一个复杂声明。比如上文的</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef void (*<span class="hljs-type">PFUNA</span>)(int a);<br></code></pre></td></tr></table></figure><p>本以为是将<code>void</code>类型替换成了<code>(*PFUNA)(int a)</code>，但是语法上这明显讲不通啊。现在明白了，这就是将<code>void (*pfunA)(int a);</code>类型名换成了<code>PFUNA</code>。以后就可以用<code>PFUNA</code>来声明变量。比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PFUNA</span> arr[<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>表示声明了一个大小为<code>10</code>的数组，数组的元素是<code>PFUNA</code>类型。将<code>PFUNA</code>类型展开就是，这是一个函数指针，函数参数为<code>int</code>类型，返回值为<code>void</code>类型。完整的含义就是，<strong>声明了一个大小为<code>10</code>的数组，数组元素是函数指针，函数参数为<code>int</code>类型，返回值为<code>void</code>类型</strong>。</p><h2 id="代码简化"><a href="#代码简化" class="headerlink" title="代码简化"></a>代码简化</h2><p><code>typedef</code>可以为复杂的声明定义一个新的简单的别名。关于复杂声明，可以阅读这篇<a href="https://dunky-z.github.io/2021/10/22/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/">C 语言复杂声明</a>。<br>方法是：在原来的声明里逐步用别名替换一部分复杂声明，递归操作，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">//复杂声明</span><br>void <span class="hljs-comment">(*b[10]) (void (*)</span>());<br></code></pre></td></tr></table></figure><p>变量名为<code>b</code>，先替换右边部分括号里的，<code>pFunParam</code>为别名</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef void (*pFunParam)();<br></code></pre></td></tr></table></figure><p>再替换左边的变量<code>b</code>，<code>pFunx</code>为别名二：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef void (*pFunx)(pFunParam);<br></code></pre></td></tr></table></figure><p>简化后的声明：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pFunx <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[10]</span>;<br></code></pre></td></tr></table></figure><h2 id="减少错误"><a href="#减少错误" class="headerlink" title="减少错误"></a>减少错误</h2><p>定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 这多数不符合我们的意图，它只声明了一个指向字符变量的指针，<br><span class="hljs-regexp">//</span> 和一个字符变量；<br>char* pa, pb;<br></code></pre></td></tr></table></figure><p>以下则可行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span>* PCHAR;<br>PCHAR pa, pb;  <br></code></pre></td></tr></table></figure><p>这种用法很有用，特别是<code>char* pa, pb</code>的定义，初学者往往认为是定义了两个字符型指针，其实不是，而用<code>typedef char* PCHAR</code>就不会出现这样的问题，减少了错误的发生。</p><h2 id="直观简洁"><a href="#直观简洁" class="headerlink" title="直观简洁"></a>直观简洁</h2><p>声明<code>struct</code>新对象时，必须要带上<code>struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagPOINT1</span></span><br><span class="hljs-class"> &#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y; <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagPOINT1</span> <span class="hljs-title">p1</span>;</span><br></code></pre></td></tr></table></figure><p>在经常使用这个结构体时，就显得麻烦，可以用<code>typedef</code>简化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagPOINT</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>&#125;POINT;<br></code></pre></td></tr></table></figure><h2 id="定义平台无关的类型"><a href="#定义平台无关的类型" class="headerlink" title="定义平台无关的类型"></a>定义平台无关的类型</h2><p>当跨平台时，只要改下 <code>typedef</code> 本身就行，不用对其他源码做任何修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u_32t; <br></code></pre></td></tr></table></figure><h2 id="掩饰复合类型"><a href="#掩饰复合类型" class="headerlink" title="掩饰复合类型"></a>掩饰复合类型</h2><p><code>typedef</code> 还可以掩饰复合类型，如指针和数组。</p><p>例如，你不用像下面这样重复定义有 81 个字符元素的数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> line[<span class="hljs-number">81</span>];<br></code></pre></td></tr></table></figure><p>定义一个 <code>typedef</code>，每当要用到相同类型和大小的数组时，可以这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> Line[<span class="hljs-number">81</span>]; <br></code></pre></td></tr></table></figure><p>此时 Line 类型即代表了具有 81 个元素的字符数组，使用方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Line text, secondline; <br></code></pre></td></tr></table></figure><p>同样，可以象下面这样隐藏指针语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> * pstr;<br></code></pre></td></tr></table></figure><p>这里将带我们到达第一个 <code>typedef</code> 陷阱。标准函数 <code>strcmp()</code>有两个<code>const char *</code>类型的参数。因此，它可能会误导人们象下面这样声明 <code>mystrcmp()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mystrcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pstr, <span class="hljs-keyword">const</span> pstr)</span></span>; <br></code></pre></td></tr></table></figure><p>用 GNU 的 gcc 和 g++编译器，是会出现警告的，按照顺序，<code>const pstr</code>被解释为<code>char* const</code>（一个指向 <code>char</code> 的指针常量），两者表达的并非同一意思。为了得到正确的类型，应当如下声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pstr;<br></code></pre></td></tr></table></figure><h2 id="typedef-和存储类关键字"><a href="#typedef-和存储类关键字" class="headerlink" title="typedef 和存储类关键字"></a>typedef 和存储类关键字</h2><p><code>typedef</code> 就像 <code>auto</code>，<code>extern</code>，<code>mutable</code>，<code>static</code>，和 <code>register</code> 一样，是一个存储类关键字。这并不是说 <code>typedef</code> 会真正影响对象的存储特性；它只是说在语句构成上，<code>typedef</code> 声明看起来象 <code>static</code>，<code>extern</code> 等类型的变量声明。下面将带到第二个陷阱：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> FAST_COUNTER; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>编译通不过。问题出在你不能在声明中有多个存储类关键字。因为符号 <code>typedef</code> 已经占据了存储类关键字的位置，在 <code>typedef</code> 声明中不能用 <code>register</code>（或任何其它存储类关键字）。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/liitdar/article/details/80069638">typedef 介绍_liitdar 的博客-CSDN 博客_typedef</a></p><p><a href="https://blog.csdn.net/wangqiulin123456/article/details/8284939">关于 typedef 的用法总结_IT 民工-CSDN 博客_typedef</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 批处理定时任务</title>
    <link href="/2022/01/05/Windows%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2022/01/05/Windows%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="折腾背景"><a href="#折腾背景" class="headerlink" title="折腾背景"></a>折腾背景</h2><p>一些常用的离线软件在重新安装，重装电脑或者更好环境时，调教好的配置总需要重新设置一遍，甚是麻烦。但是这些设置通常都保存在配置文件里，只要能备份好这些配置文件，下次重装后覆盖就可以恢复所需设置。</p><p>现在的问题就是如何备份这些配置文件，可以选择各类网盘，硬盘等等。但是这些多少都有点炮打蚊子，小题大做。而且定时备份也不是很方便。既然配置文件都很小，其实就是个文本文件，那有个万能免费存储地 GitHub 就派上用场了。我们只要把配置文件定时 push 到 GitHub 即可，以后随时可以 clone 下来。</p><p>首先建立一个私密仓库，用来专门存放配置文件。其次通过批处理命令，将配置文件复制到本地仓库的文件夹下。最后设置定时任务。</p><h2 id="折腾过程"><a href="#折腾过程" class="headerlink" title="折腾过程"></a>折腾过程</h2><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>这一步不用赘述了，主要就是要勾选私密仓库，保护隐私，一些配置文件可能会包含个人信息。</p><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>将仓库克隆到本地后就是个文件夹，这一步主要就是如何能把安装在不同位置的软件的配置文件，都汇集到这个仓库下。通过批处理命令可以快速，方便的完成。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-built_in">echo</span> <span class="hljs-built_in">Start</span> backup config files! # 打印这句话<br><br><span class="hljs-built_in">copy</span> D:\Tools\MouseInc\MouseInc.json  D:\Develop\fxxk-config\mouseinc # 将前者复制到后者<br><br><span class="hljs-built_in">copy</span> D:\Tools\JD\Config.ini  D:\Develop\fxxk-config\jd<br><br><span class="hljs-built_in">cd</span>  /d D:\Develop\fxxk-config # 切换目录<br><br># git推送的一些命令<br>git add .   <br>git commit -m &quot;update&quot;<br>git push<br><br># 防止窗口闪退<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>一些常用命令参考<a href="https://gist.github.com/675816156/7bcec2bc6f45faa64acdb75acfef6912">WindowDos 批处理指导</a>。</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>控制面板-管理工具 - 任务计划程序<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201052247765.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201052247153.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201052247889.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201052248070.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201052248353.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 unable to install libpng12.so.0</title>
    <link href="/2022/01/05/%E8%A7%A3%E5%86%B3unable-to-install-libpng12-so-0/"/>
    <url>/2022/01/05/%E8%A7%A3%E5%86%B3unable-to-install-libpng12-so-0/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><code>apt</code>工具损坏了，在修复时使用了<code>sudo apt-get install -f</code>命令，中途会提示需要安装<code>libpng12-0</code>，但是始终无法安装，会提示如下错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Unpacking libpng12-0:amd64 (1.2.50-2+deb8u3) ... dpkg: error <br>processing archive libpng12-0_1.2.50-2+deb8u3_amd64.deb <br>(--install): unable to install new version of <span class="hljs-string">&#x27;/usr/lib/</span><br><span class="hljs-string">x86_64-linux-gnu/libpng12.so.0&#x27;</span>: No such file or directory <br>Errors were encountered <span class="hljs-keyword">while</span> processing: libpng12-0_1.2.50-2<br>+deb8u3_amd64.deb<br><br></code></pre></td></tr></table></figure><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>具体原因未知，网上答案众说纷纭。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>这个问题遇到的人还挺多的，解决方法也各不相同，我先说我自己最终解决的方法。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li><p>将软件源更换成中科院的源，使用 Linux 自带的<strong>软件和更新</strong>工具，具体方法参考<a href="https://dunky-z.github.io/2021/07/30/%E6%9B%B4%E6%8D%A2Ubuntu%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/">这篇文章</a>。更换完之后可以重新尝试安装，有人换源后即可成功安装。</p></li><li><p>如果未能安装成功，可能曾经手动添加过软件源，将其删除。</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 将所有内容注释</span><br>vim <span class="hljs-regexp">/etc/</span>apt/sources.list<br></code></pre></td></tr></table></figure></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li><p>下载已安装的库文件<code>libpng12.so.0</code>，可以从<a href="https://www.aliyundrive.com/s/pf9cAPjuqfn">该链接</a>下载。</p></li><li><p>将该文件复制到它本该安装的位置。</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> cp libpng<span class="hljs-number">12</span>.so.<span class="hljs-number">0</span> /usr/lib/x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>-linux-gnu/<br></code></pre></td></tr></table></figure></li></ol><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-built_in"> add-apt-repository </span>ppa:linuxuprising/libpng12<br>sudo apt update<br>sudo apt install libpng12-0<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 入门-Trap</title>
    <link href="/2021/12/30/RISC-V%E5%85%A5%E9%97%A8-Trap%E5%92%8CException/"/>
    <url>/2021/12/30/RISC-V%E5%85%A5%E9%97%A8-Trap%E5%92%8CException/</url>
    
    <content type="html"><![CDATA[<h1 id="Trap-简介"><a href="#Trap-简介" class="headerlink" title="Trap 简介"></a>Trap 简介</h1><h2 id="控制流（Control-Flow）和-Trap"><a href="#控制流（Control-Flow）和-Trap" class="headerlink" title="控制流（Control Flow）和 Trap"></a>控制流（Control Flow）和 Trap</h2><ul><li>控制流（Control Flow）<br>从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列<br>$$a_0,a_1,\dotsb,a_{n-1}$$<br>每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。</li><li>异常控制流（Exceptional Control Flow, ECF）<br>系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。<ul><li>exception</li><li>interrupt</li></ul></li></ul><p>RISC-V 把 <code>ECF</code> 统称为 <code>Trap</code>。</p><h2 id="RISC-V-Trap-处理中涉及的寄存器"><a href="#RISC-V-Trap-处理中涉及的寄存器" class="headerlink" title="RISC-V Trap 处理中涉及的寄存器"></a>RISC-V Trap 处理中涉及的寄存器</h2><table><thead><tr><th align="center">寄存器</th><th align="center">全称</th><th align="left">用途说明</th></tr></thead><tbody><tr><td align="center">mtvec</td><td align="center">Machine Trap-Vector Base-Address</td><td align="left">它保存发生异常时处理器需要跳转到的地址。</td></tr><tr><td align="center">mepc</td><td align="center">Machine Exception Program Counter</td><td align="left">当 trap 发生时，hart 会将发生 trap 所对应的指令的地址值（pc）保存在 mepc 中。</td></tr><tr><td align="center">mcause</td><td align="center">Machine Cause</td><td align="left">当 trap 发生时，hart 会设置该寄存器通知我们 trap 发生的原因。</td></tr><tr><td align="center">mtval</td><td align="center">Machine Trap Value</td><td align="left">它保存了 exception 发生时的附加信息：譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身，对于其他异常，它的值为 0。</td></tr><tr><td align="center">mstatus</td><td align="center">Machine Status</td><td align="left">用于跟踪和控制 hart 的当前操作状态（特别地，包括关闭和打开全局中断）。</td></tr><tr><td align="center">mscratch</td><td align="center">Machine Scratch</td><td align="left">Machine 模式下专用寄存器，我们可以自己定义其用法，譬如用该寄存器保存当前在 hart 上运行的 task 的上下文（context）的地址。</td></tr></tbody></table><h3 id="mtvec（Machine-Trap-Vector-Base-Address）"><a href="#mtvec（Machine-Trap-Vector-Base-Address）" class="headerlink" title="mtvec（Machine Trap-Vector Base-Address）"></a>mtvec（Machine Trap-Vector Base-Address）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104173734.png"></p><blockquote><p>WARL: Write Any Values, Read Legal Values</p></blockquote><ul><li><p>BASE：trap 入口函数的基地址，必须保证四字节对齐；</p></li><li><p>MODE：进一步用于控制入口函数的地址配置方式：</p><ul><li><p>Direct，所有异常和中断发生后，PC都跳转到BASE指定的地址处；</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201041945310.png"></p><p>通常中断处理函数内部会有<code>switch case</code>条件语句，通过不同的中断采用不同的处理方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">reg_t</span> <span class="hljs-title">trap_handler</span><span class="hljs-params">(<span class="hljs-keyword">reg_t</span> epc, <span class="hljs-keyword">reg_t</span> cause)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">reg_t</span> return_pc = epc;<br>    <span class="hljs-keyword">reg_t</span> cause_code = cause &amp; <span class="hljs-number">0xfff</span>;<br>    <br>    <span class="hljs-keyword">if</span> (cause &amp; <span class="hljs-number">0x80000000</span>) &#123;<br>        <span class="hljs-comment">/* Asynchronous trap - interrupt */</span><br>        <span class="hljs-keyword">switch</span> (cause_code) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            uart_puts(<span class="hljs-string">&quot;software interruption!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>            uart_puts(<span class="hljs-string">&quot;timer interruption!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:<br>            uart_puts(<span class="hljs-string">&quot;external interruption!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            uart_puts(<span class="hljs-string">&quot;unknown async exception!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Synchronous trap - exception */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sync exceptions!, code = %d\n&quot;</span>, cause_code);<br>        panic(<span class="hljs-string">&quot;OOPS! What can I do!&quot;</span>);<br>        <span class="hljs-comment">//return_pc += 4;</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> return_pc;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Vectored，异常的处理方式同上，但是中断的入口地址以数组方式排列；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asm">trap_vector:<br>    # save context(registers).<br>    csrrw t6, mscratch, t6 # swap t6 and mscratch<br>    reg_save t6<br><br>    # Save the actual t6 register, which we swapped into<br>    # mscratch<br>    mv t5, t6  # t5 points to the context of current task<br>    csrr t6, mscratch # read t6 back from mscratch<br>    sw t6, 120(t5) # save t6 with t5 as base<br><br>    # Restore the context pointer into mscratch<br>    csrw mscratch, t5<br><br>    # call the C trap handler in trap.c<br>    csrr a0, mepc<br>    csrr a1, mcause<br>    call trap_handler<br><br>    # trap_handler will return the return address via a0.<br>    csrw mepc, a0<br><br>    # restore context(registers).<br>    csrr t6, mscratch<br>    reg_restore t6<br><br>    # return to whatever we were doing before trap.<br>    mret<br></code></pre></td></tr></table></figure><p>MODE可取值如下：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104174219.png"></p></li></ul></li></ul><p>采用<code>Vectored</code>方式效率更高。</p><h3 id="mepc（Machine-Exception-Program-Counter）"><a href="#mepc（Machine-Exception-Program-Counter）" class="headerlink" title="mepc（Machine Exception Program Counter）"></a>mepc（Machine Exception Program Counter）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201041958237.png"></p><p>当<code>trap</code>发生时，<code>pc</code>会被替换为 <code>mtvec</code>设定的地址，同时<code>hart</code> 会设置<code>mepc</code>为当前指令或者下一条指令的地址（处理异常时，mepc 为当前指令的地址，处理中断时，mepc 为下一条指令的地址）。</p><p>当我们需要退出<code>trap</code> 时可以调用特殊的 <code>mret</code> 指令，该指令会将<code>mepc</code>中的值恢复到<code>pc</code>中（实现返回的效果）；</p><p>在处理 <code>trap</code> 的程序中我们可以修改 <code>mepc</code> 的值达到改变<code>mret</code> 返回地址的目的。</p><h3 id="mcause（Machine-Cause）"><a href="#mcause（Machine-Cause）" class="headerlink" title="mcause（Machine Cause）"></a>mcause（Machine Cause）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042012549.png"></p><p>当 <code>trap</code> 发生时，<code>hart</code> 会设置该寄存器通知我们 <code>trap</code> 发生的原因。</p><p>最高位 <code>Interrupt</code> 为 1 时标识了当前 <code>trap</code> 为<code>interrupt</code>，否则是<code>exception</code>。</p><p>剩余的 <code>Exception Code</code> 用于标识具体的<code>interrupt</code>或者<code>exception</code> 的种类。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042014689.png"></p><h3 id="mtval（Machine-Trap-Value）"><a href="#mtval（Machine-Trap-Value）" class="headerlink" title="mtval（Machine Trap Value）"></a>mtval（Machine Trap Value）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042016744.png"></p><p>当 <code>trap</code> 发生时，除了通过<code>mcause</code> 可以获取<code>exception</code>的种类 <code>code</code> 值外，<code>hart</code> 还提供了 <code>mtval</code> 来提供<code>exception</code> 的其他信息来辅助我们执行更进一步的操作。</p><p>具体的辅助信息由特定的硬件实现定义，RISC-V 规范没有定义具体的值。但规范定义了一些行为，譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身等。</p><h3 id="mstatus（Machine-Status）"><a href="#mstatus（Machine-Status）" class="headerlink" title="mstatus（Machine Status）"></a>mstatus（Machine Status）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042020644.png"></p><p>寄存器各个位可以大致分为以下三类，其中<code>x</code>可以为<code>U,S,M</code>。表示用户模式以及两种特权模式。</p><ul><li><p><code>xIE</code>（x=M/S/U）: 分别用于打开（1）或者关闭（0）M/S/U 模式下的全局中断。当 <code>trap</code> 发生时，<code>hart</code>会自动将 <code>xIE</code> 设置为 0。</p></li><li><p><code>xPIE</code>（x=M/S/U）:当 <code>trap</code> 发生时用于保存 <code>trap</code> 发生之前的 <code>xIE</code> 值。</p></li><li><p><code>xPP</code>（x=M/S）:当 <code>trap</code> 发生时用于保存 <code>trap</code> 发生之前的权限级别值。注意没有 <code>UPP</code>。因为异常只会从低权限向高权限跳转，通常低权限如<code>user</code>模式，会被置于上方，高权限如内核一般都会画在下方，这也解释了异常，中断处理为什么叫<code>trap</code>，因为是向下陷入的过程。</p></li><li><p>其他标志位涉及内存访问权限、虚拟内存控制等，暂不考虑。</p></li></ul><h2 id="Trap-处理流程"><a href="#Trap-处理流程" class="headerlink" title="Trap 处理流程"></a>Trap 处理流程</h2><blockquote><p>主要为 Exception，下一章详解 Interrupt。</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将<code>trap</code>的基地址写入寄存器，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042053570.png"></p><h3 id="Top-Half"><a href="#Top-Half" class="headerlink" title="Top Half"></a>Top Half</h3><ol><li>把 <code>mstatus</code> 的 <code>MIE</code> 值复制到 <code>MPIE</code> 中，清除 <code>mstatus</code>中的 <code>MIE</code> 标志位，效果是中断被禁止。</li><li>设置<code>mepc</code>，同时<code>PC</code>被设置为 <code>mtvec</code>。（需要注意的是，对于<code>exception</code>， <code>mepc</code>指向导致异常的指令；对于 <code>interrupt</code>，它指向被中断的指令的下一条指令的位置。）</li><li>根据 <code>trap</code> 的种类设置 <code>mcause</code>，并根据需要为<code>mtval</code>设置附加信息。</li><li>将 <code>trap</code> 发生之前的权限模式保存在 <code>mstatus</code> 的 <code>MPP</code> 域中，再把<code>hart</code> 权限模式更改为 <code>M</code>（也就是说无论在任何 <code>Level</code> 下触发<code>trap</code>，<code>hart</code> 首先切换到 <code>Machine</code> 模式）。</li></ol><h3 id="Bottom-Half"><a href="#Bottom-Half" class="headerlink" title="Bottom Half"></a>Bottom Half</h3><ol><li>保存（save）当前控制流的上下文信息（利用 <code>mscratch</code>）；</li><li>调用 C 语言的 <code>trap handler</code>;</li><li>从 <code>trap handler</code> 函数返回，<code>mepc</code>的值有可能需要调整；</li><li>恢复（restore）上下文的信息；</li><li>执行<code>MRET</code>指令返回到 <code>trap</code>之前的状态。</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">trap_vector</span>:<br> <span class="hljs-comment"># save context(registers).</span><br> <span class="hljs-attribute">csrrw</span> t<span class="hljs-number">6</span>, mscratch, t<span class="hljs-number">6</span> # swap t<span class="hljs-number">6</span> and mscratch<br> <span class="hljs-attribute">reg_save</span> t<span class="hljs-number">6</span><br><br> <span class="hljs-comment"># Save the actual t6 register, which we swapped into</span><br> <span class="hljs-comment"># mscratch</span><br> <span class="hljs-attribute">mv</span> t<span class="hljs-number">5</span>, t<span class="hljs-number">6</span>  # t<span class="hljs-number">5</span> points to the context of current task<br> <span class="hljs-attribute">csrr</span> t<span class="hljs-number">6</span>, mscratch # read t<span class="hljs-number">6</span> back from mscratch<br> <span class="hljs-attribute">sw</span> t<span class="hljs-number">6</span>, <span class="hljs-number">120</span>(t<span class="hljs-number">5</span>) # save t<span class="hljs-number">6</span> with t<span class="hljs-number">5</span> as base<br><br> <span class="hljs-comment"># Restore the context pointer into mscratch</span><br> <span class="hljs-attribute">csrw</span> mscratch, t<span class="hljs-number">5</span><br><br> <span class="hljs-comment"># call the C trap handler in trap.c</span><br> <span class="hljs-attribute">csrr</span> a<span class="hljs-number">0</span>, mepc<br> <span class="hljs-attribute">csrr</span> a<span class="hljs-number">1</span>, mcause<br> <span class="hljs-attribute">call</span> trap_handler<br><br> <span class="hljs-comment"># trap_handler will return the return address via a0.</span><br> <span class="hljs-attribute">csrw</span> mepc, a<span class="hljs-number">0</span><br><br> <span class="hljs-comment"># restore context(registers).</span><br> <span class="hljs-attribute">csrr</span> t<span class="hljs-number">6</span>, mscratch<br> <span class="hljs-attribute">reg_restore</span> t<span class="hljs-number">6</span><br><br> <span class="hljs-comment"># return to whatever we were doing before trap.</span><br> <span class="hljs-attribute">mret</span><br></code></pre></td></tr></table></figure><h3 id="退出-trap：编程调用-MRET-指令"><a href="#退出-trap：编程调用-MRET-指令" class="headerlink" title="退出 trap：编程调用 MRET 指令"></a>退出 trap：编程调用 MRET 指令</h3><p>针对不同权限级别下如何退出 trap 有各自的返回指令<code>xRET</code>（x = M/S/U）。以在 <code>M</code> 模式下执行<code>mret</code> 指令为例，会执行如下操作：</p><ul><li>当前 <code>Hart 的权限级别 = mstatus.MPP</code>；<code>mstatus.MPP = U</code>（如果 hart 不支持 U 则为 M）</li><li><code>mstatus.MIE = mstatus.MPIE</code>; <code>mstatus.MPIE = 1</code></li><li><code>pc = mepc</code></li></ul><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><ul><li><p>本地（Local）中断</p><ul><li>软中断software interrupt</li><li>定时器中断 timer interrupt</li></ul></li><li><p>全局（Global）中断</p><ul><li>外部中断 externel interrupt</li></ul></li></ul><h2 id="RISC-V-中断编程中涉及的寄存器"><a href="#RISC-V-中断编程中涉及的寄存器" class="headerlink" title="RISC-V 中断编程中涉及的寄存器"></a>RISC-V 中断编程中涉及的寄存器</h2><table><thead><tr><th align="center">寄存器</th><th align="center">全称</th><th align="left">用途说明</th></tr></thead><tbody><tr><td align="center">mie</td><td align="center">Machine Interrupt Enable</td><td align="left">用于进一步控制（打开和关闭）software interrupt/timer interrupt/external interrupt</td></tr><tr><td align="center">mip</td><td align="center">Machine Interrupt Pending</td><td align="left">它列出目前已发生等待处理的中断。</td></tr></tbody></table><h3 id="mie-Machine-Interrupt-Enable"><a href="#mie-Machine-Interrupt-Enable" class="headerlink" title="mie(Machine Interrupt Enable)"></a>mie(Machine Interrupt Enable)</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042159268.png"></p><p>打开（1）或者关闭（0）M/S/U 模式下对应的 External/Timer/Software 中断。</p><h3 id="mip-Machine-Interrupt-Pending"><a href="#mip-Machine-Interrupt-Pending" class="headerlink" title="mip(Machine Interrupt Pending)"></a>mip(Machine Interrupt Pending)</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042200772.png"></p><p>获取当前 M/S/U 模式下对应的 External/Timer/Software 中断是否发生。</p><h2 id="中断处理流程"><a href="#中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程</h2><h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><ol><li>把 <code>mstatus</code> 的 <code>MIE</code> 值复制到 <code>MPIE</code> 中，清除 <code>mstatus</code> 中的 MIE 标志位，效果是中断被禁止。</li><li>当前的 <code>PC</code> 的下一条指令地址被复制到 <code>mepc</code> 中，同时 <code>PC</code> 被设置为<code>mtvec</code>。注意如果我们设置 <code>mtvec.MODE = vetcored</code>，<code>PC =mtvec.BASE + 4 × exception-code</code>。</li><li>根据 <code>interrupt</code> 的种类设置 <code>mcause</code>，并根据需要为 <code>mtval</code> 设置附加信息。</li><li>将 <code>trap</code> 发生之前的权限模式保存在 <code>mstatus</code> 的 <code>MPP</code> 域中，再把<code>hart</code> 权限模式更改为 <code>M</code>。</li></ol><h3 id="退出中断"><a href="#退出中断" class="headerlink" title="退出中断"></a>退出中断</h3><p>以在 M 模式下执行 mret 指令为例，会执行如下操作：</p><ul><li>当前 Hart 的权限级别 = mstatus.MPP; mstatus.MPP= U（如果 hart 不支持 U 则为 M）</li><li>mstatus.MIE = mstatus.MPIE; mstatus.MPIE = 1</li><li>pc = mepc</li></ul><h1 id="PLIC（Platform-Level-Interrupt-Controller）"><a href="#PLIC（Platform-Level-Interrupt-Controller）" class="headerlink" title="PLIC（Platform-Level Interrupt Controller）"></a>PLIC（Platform-Level Interrupt Controller）</h1><h2 id="PLIC-简介"><a href="#PLIC-简介" class="headerlink" title="PLIC 简介"></a>PLIC 简介</h2><p>HART 只能处理一个中断，PLIC 相当于一个控制中心，它通过中断类型，优先级等等来选出一个需要处理的中断。协调多个中断，服务一个 HART。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042206664.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART0_IRQ = <span class="hljs-number">10</span>, <span class="hljs-comment">//Interrupt Source ID</span><br>    RTC_IRQ = <span class="hljs-number">11</span>,<br>    VIRTIO_IRQ = <span class="hljs-number">1</span>, <span class="hljs-comment">/* 1 to 8 */</span><br>    VIRTIO_COUNT = <span class="hljs-number">8</span>, <br>    PCIE_IRQ = <span class="hljs-number">0x20</span>, <span class="hljs-comment">/* 32 to 35 */</span><br>    VIRTIO_NDEV = <span class="hljs-number">0x35</span> <span class="hljs-comment">/* Arbitrary maximum number of interrupts */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Interrupt Source ID 范围：1 ~ 53（0x35）</li><li>0 预留不用</li></ul><p><code>PLIC</code>本身也是一个外设，RISC-V 规范规定，<code>PLIC</code> 的寄存器编址采用内存映射（memory map）方式。每个寄存器的宽度为 32-bit。</p><p>具体寄存器编址采用 <code>base + offset</code> 的格式，且 <code>base</code> 由各个特定<code>platform</code> 自己定义。针对 <code>QEMU-virt</code>，其 <code>PLIC</code> 的设计参考了<code>FU540-C000</code>，<code>base</code> 为 <code>0x0c000000</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> MemMapEntry virt_memmap[] = &#123;<br>    [VIRT_DEBUG] =       &#123;        <span class="hljs-number">0x0</span>,         <span class="hljs-number">0x100</span> &#125;,<br>    [VIRT_MROM] =        &#123;     <span class="hljs-number">0x1000</span>,        <span class="hljs-number">0xf000</span> &#125;,<br>    [VIRT_TEST] =        &#123;   <span class="hljs-number">0x100000</span>,        <span class="hljs-number">0x1000</span> &#125;,<br>    [VIRT_RTC] =         &#123;   <span class="hljs-number">0x101000</span>,        <span class="hljs-number">0x1000</span> &#125;,<br>    [VIRT_CLINT] =       &#123;  <span class="hljs-number">0x2000000</span>,       <span class="hljs-number">0x10000</span> &#125;,<br>    [VIRT_ACLINT_SSWI] = &#123;  <span class="hljs-number">0x2F00000</span>,        <span class="hljs-number">0x4000</span> &#125;,<br>    [VIRT_PCIE_PIO] =    &#123;  <span class="hljs-number">0x3000000</span>,       <span class="hljs-number">0x10000</span> &#125;,<br>    [VIRT_PLIC] =        &#123;  <span class="hljs-number">0xc000000</span>, VIRT_PLIC_SIZE(VIRT_CPUS_MAX * <span class="hljs-number">2</span>) &#125;,<br>    [VIRT_UART0] =       &#123; <span class="hljs-number">0x10000000</span>,         <span class="hljs-number">0x100</span> &#125;,<br>    [VIRT_VIRTIO] =      &#123; <span class="hljs-number">0x10001000</span>,        <span class="hljs-number">0x1000</span> &#125;,<br>    [VIRT_FW_CFG] =      &#123; <span class="hljs-number">0x10100000</span>,          <span class="hljs-number">0x18</span> &#125;,<br>    [VIRT_FLASH] =       &#123; <span class="hljs-number">0x20000000</span>,     <span class="hljs-number">0x4000000</span> &#125;,<br>    [VIRT_PCIE_ECAM] =   &#123; <span class="hljs-number">0x30000000</span>,    <span class="hljs-number">0x10000000</span> &#125;,<br>    [VIRT_PCIE_MMIO] =   &#123; <span class="hljs-number">0x40000000</span>,    <span class="hljs-number">0x40000000</span> &#125;,<br>    [VIRT_DRAM] =        &#123; <span class="hljs-number">0x80000000</span>,           <span class="hljs-number">0x0</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="PLIC-编程接口-寄存器"><a href="#PLIC-编程接口-寄存器" class="headerlink" title="PLIC 编程接口 - 寄存器"></a>PLIC 编程接口 - 寄存器</h2><h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><p>功能：设置某一路中断源的优先级<br>内存映射地址：<code>BASE + (interrupt-id) * 4</code></p><ul><li>每个 <code>PLIC</code> 中断源对应一个寄存器，用于配置该中断源的优先级。</li><li><code>QEMU-virt</code> 支持 7 个优先级。0 表示对该中断源禁用中断。其余优先级，1 最低，7 最高。</li><li>如果两个中断源优先级相同，则根据中断源的 ID 值进一步区分优先级，ID 值越小的优先级越高。</li></ul><h3 id="Pending"><a href="#Pending" class="headerlink" title="Pending"></a>Pending</h3><p>功能：用于指示某一路中断源是否发生<br>内存映射地址：<code>BASE + 0x1000 + ((interrupt-id) / 32) * 4</code></p><ul><li>每个 <code>PLIC</code> 包含 2 个 32 位的 <code>Pending</code> 寄存器，因为总共有 54 个中断源，每一个 <code>bit</code> 对应一个中断源，如果为 1 表示该中断源上发生了中断（进入<code>Pending</code> 状态），有待 <code>hart</code> 处理，否则表示该中断源上当前无中断发生。</li><li><code>Pending</code> 寄存器中断的 <code>Pending</code> 状态可以通过<code>claim</code> 方式清除。</li><li>第一个 <code>Pending</code> 寄存器的第 0 位对应不存在的 0 号中断源，其值永远为 0。</li></ul><h3 id="Enable"><a href="#Enable" class="headerlink" title="Enable"></a>Enable</h3><p>功能：针对某个 <code>hart</code> 开启或者关闭某一路中断源<br>内存映射地址：<code>BASE + 0x2000 + (hart) * 0x80</code></p><ul><li>每个 <code>Hart</code> 有 2 个 <code>Enable</code> 寄存器（<code>Enable1</code> 和 <code>Enable2</code>）用于针对该<code>Hart</code> 启动或者关闭某路中断源。</li><li>每个中断源对应 <code>Enable</code> 寄存器的一个 <code>bit</code>，其中<code>Enable1</code> 负责控制 1 ~ 31 号中断源；<code>Enable2</code> 负责控制 <code>32 ~ 53</code> 号中断源。将对应的 <code>bit</code> 位设置为 1 表示使能该中断源，否则表示关闭该中断源。</li></ul><h3 id="Threshold"><a href="#Threshold" class="headerlink" title="Threshold"></a>Threshold</h3><p>功能：针对某个 hart 设置中断源优先级的阈值<br>内存映射地址：<code>BASE + 0x200000 + (hart) * 0x1000</code></p><ul><li>每个 <code>Hart</code> 有 1 个 <code>Threshold</code> 寄存器用于设置中断优先级的阈值。</li><li>所有小于或者等于（&lt;=）该阈值的中断源即使发生了也会被 <code>PLIC</code> 丢弃。特别地，当阈值为 0 时允许所有中断源上发生的中断；当阈值为 7 时丢弃所有中断源上发生的中断。</li></ul><h3 id="Claim-Complete"><a href="#Claim-Complete" class="headerlink" title="Claim/Complete"></a>Claim/Complete</h3><p>功能：如下<br>内存映射地址：<code>BASE + 0x200004 + (hart) * 0x1000</code></p><ul><li><code>Claim</code> 和 <code>Complete</code> 是同一个寄存器，每个 <code>Hart</code> 一个。</li><li>对该寄存器执行读操作称之为 <code>Claim</code>，即获取当前发生的最高优先级的中断源<code>ID</code>。<code>Claim</code> 成功后会清除对应的 <code>Pending</code> 位。</li><li>对该寄存器执行写操作称之为 <code>Complete</code>。所谓 <code>Complete</code>指的是通知<code>PLIC</code> 对该路中断的处理已经结束。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">external_interrupt_handler</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">int</span> irq = plic_claim(); <span class="hljs-comment">//</span><br><br> <span class="hljs-keyword">if</span> (irq == UART0_IRQ)&#123;<br>        uart_isr();<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (irq) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unexpected interrupt irq = %d\n&quot;</span>, irq);<br> &#125;<br> <br> <span class="hljs-keyword">if</span> (irq) &#123;<br>  plic_complete(irq); <span class="hljs-comment">//</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/17-56-05-db617fc7aad1c476c3c38e4ee44a770b-20220828175604-f9d5e6.png"></p><h1 id="CLINT-（Core-Local-INTerruptor）"><a href="#CLINT-（Core-Local-INTerruptor）" class="headerlink" title="CLINT （Core Local INTerruptor）"></a>CLINT （Core Local INTerruptor）</h1><p>定时器中断，属于本地中断的一种，由芯片内部<code>CLINT</code>设备产生的中断。</p><ul><li>RISC-V 规范规定，CLINT 的寄存器编址采用内存映射（memory map）方式。</li><li>具体寄存器编址采用<code>base + offset</code>的格式，且 <code>base</code> 由各个特定 <code>platform</code> 自己定义。针对 <code>QEMU-virt</code>，其 CLINT 的设计参考了 <code>SFIVE</code>，<code>base</code> 为 <code>0x2000000</code>。</li></ul><h2 id="CLINT-编程接口-寄存器-Timer-部分"><a href="#CLINT-编程接口-寄存器-Timer-部分" class="headerlink" title="CLINT 编程接口 - 寄存器 (Timer 部分)"></a>CLINT 编程接口 - 寄存器 (Timer 部分)</h2><h3 id="mtime"><a href="#mtime" class="headerlink" title="mtime"></a>mtime</h3><p>功能：<code>real-time</code> 计数器（counter）<br>内存映射地址：<code>BASE + 0xbff8</code></p><ul><li>由晶振产生，系统全局唯一，在 <code>RV32</code> 和 <code>RV64</code> 上都是 64-bit。系统必须保证该计数器的值始终按照一个固定的频率递增。</li><li>上电复位时，硬件负责将 <code>mtime</code> 的值恢复为 0。</li></ul><h3 id="mtimecmp"><a href="#mtimecmp" class="headerlink" title="mtimecmp"></a>mtimecmp</h3><p>功能：定时器比较寄存器<br>内存映射地址：<code>BASE + 0x4000 + (hart) * 8)</code></p><ul><li><p>每个 <code>hart</code> 一个 <code>mtimecmp</code> 寄存器，64-bit。</p></li><li><p>上电复位时，系统不负责设置 mt`imecmp 的初值。</p></li><li><p>当<code>mtime &gt;= mtimecmp</code> 时，<code>CLINT</code> 会产生一个 <code>timer</code> 中断。如果要使能该中断需要保证全局中断打开并且<code>mie.MTIE</code> 标志位置 <code>1</code>。</p></li><li><p>当 <code>timer</code> 中断发生时，<code>hart</code> 会设置 <code>mip.MTIP</code>，程序可以在 <code>mtimecmp</code> 中写入新的值清除<code>mip.MTIP</code>。</p></li></ul><h2 id="时钟节拍-tick"><a href="#时钟节拍-tick" class="headerlink" title="时钟节拍 tick"></a>时钟节拍 tick</h2><ul><li>操作系统中最小的时间单位；</li><li><code>Tick</code> 的单位（周期）由硬件定时器的周期决定<br>（通常为 1 ~ 100ms）；</li><li><code>Tick</code> 周期越小，也就是<code>1s</code>内产生的中断越多，系统的精度越高，但开销越大。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 使用 sftp 插件上传本地文件至局域网服务器</title>
    <link href="/2021/12/24/VSCode%E4%BD%BF%E7%94%A8sftp%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%87%B3%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2021/12/24/VSCode%E4%BD%BF%E7%94%A8sftp%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%87%B3%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>测试代码时经常需要上传文件至服务器端运行，每次上传都需要通过第三方传输工具如 FileZilla，有了<code>SFTP</code>插件，可以直接在 VSCode 上编译成功后，一键上传本地文件。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>打开插件中心，搜索<code>sftp</code>，安装量最高的就是我们需要的插件，点击安装。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104114810.png"></p><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><p>插件安装完成后，输入快捷键<code>Control + Shift + P</code> 弹出命令面板，然后输入<code>sftp:config</code>，回车，当前工程的<code>.vscode</code>文件夹下就会自动生成一个<code>sftp.json</code>文件，我们需要在这个文件里配置的内容可以是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.xxx&quot;</span>, <span class="hljs-comment">//服务器 ip</span><br>  <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp 模式是 22</span><br>  <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>  <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>  <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;ftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>  <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">&quot;privateKeyPath&quot;</span>: <span class="hljs-literal">null</span>,   <span class="hljs-comment">//存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件）</span><br>  <span class="hljs-attr">&quot;passphrase&quot;</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">&quot;passive&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;interactiveAuth&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;remotePath&quot;</span>: <span class="hljs-string">&quot;/root/node/build/&quot;</span>, <span class="hljs-comment">//服务器上的文件地址</span><br>  <span class="hljs-attr">&quot;context&quot;</span>: <span class="hljs-string">&quot;./server/build&quot;</span>,      <span class="hljs-comment">//本地的文件地址</span><br>  <span class="hljs-attr">&quot;uploadOnSave&quot;</span>: <span class="hljs-literal">true</span>,             <span class="hljs-comment">//监听保存并上传</span><br>  <span class="hljs-attr">&quot;syncMode&quot;</span>: <span class="hljs-string">&quot;update&quot;</span>,<br>  <span class="hljs-attr">&quot;watcher&quot;</span>: &#123;<br>    <span class="hljs-comment">//监听外部文件</span><br>    <span class="hljs-attr">&quot;files&quot;</span>: <span class="hljs-literal">false</span>,                 <span class="hljs-comment">//外部文件的绝对路径</span><br>    <span class="hljs-attr">&quot;autoUpload&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;autoDelete&quot;</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;ignore&quot;</span>: [<br>    <span class="hljs-comment">//指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹</span><br>    <span class="hljs-comment">//注意每一行后面有逗号，最后一行没有逗号</span><br>    <span class="hljs-comment">//忽略项</span><br>    <span class="hljs-string">&quot;**/.vscode/**&quot;</span>,<br>    <span class="hljs-string">&quot;**/.git/**&quot;</span>,<br>    <span class="hljs-string">&quot;**/.DS_Store&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><ul><li><p>可以直接右击文件，选择<code>Upload</code>，会将文件上传至配置好的<code>remotePath</code>。</p></li><li><p>可以<code>Control + Shift + P</code>输入<code>sftp</code>，选择想要执行的命令，命令都是字面意思，不多做解释。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104115716.png"></p></li><li><p>如果有多个 IP 需要配置，可以在<code>sftp.json</code>文件中，通过方括号<code>[]</code>添加。比如</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>    &#123;<br>    <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.01&quot;</span>, <span class="hljs-comment">//服务器 ip</span><br>    <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp模式是22</span><br>    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>    <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;sftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>    <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>    &#125;,<br>    &#123;<br>    <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.02&quot;</span>, <span class="hljs-comment">//服务器 ip</span><br>    <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp模式是22</span><br>    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>    <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;sftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>    <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>    &#125;,<br>    &#123;<br>    <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.03&quot;</span>, <span class="hljs-comment">//服务器 ip</span><br>    <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp模式是22</span><br>    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>    <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;sftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>    <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>    &#125;<br>]<br></code></pre></td></tr></table></figure></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 程序内存区域分配</title>
    <link href="/2021/12/22/C%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D/"/>
    <url>/2021/12/22/C%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>ELF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>芯片启动过程全解析</title>
    <link href="/2021/12/18/%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/12/18/%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>内容总结自 B 站 Up<a href="https://www.bilibili.com/video/BV1AN411R7Be/?spm_id_from=333.788.recommend_more_video.1">【蛋饼嵌入式】我提着鞋带拎自己？嵌入式芯片启动过程全解析，彻底理解 bootloader</a></p><p>当你按下电源开关的那一瞬间，第一行代码如何在芯片上运行起来的呢？嵌入式软件代码需要一定的方式烧录到芯片中才能运行，除了物理刻蚀，无论是通讯端口的传输或者调试端口的烧录，都需要驱动程序的支持。所以说是<strong>程序烧录了程序，软件启动了软件</strong>。</p><p>这就像自己提着自己的鞋带，把自己拎起来。靴子（Boot）,鞋带（Strap），提鞋带（Loader）。这就是<code>Boot Strap Loader</code>的命名来源。通常称<code>BootLoader</code>，中文翻译为<strong>自举</strong>。</p><p><code>BootLoader</code>是芯片最初运行的代码吗？当然不是，其实每一块芯片在出厂时都在其内部的<code>ROM</code>中，烧录了它最基础的软件。CPU 搬运并运行的第一条代码的默认位置，就在<code>ROM</code>的地址空间。所以一切的起始都在硬件上。</p><p>以 X86 架构的鼻祖 8086 芯片为例，按下开关的一瞬间，芯片 Reset 引脚接收到了电平跳变，在一连串电路的作用下，代码段寄存器<code>CS</code>恢复成<code>0XFFFF</code>，指令指针寄存器<code>IP</code>恢复成<code>0X0000</code>，他们组合成 20 位的地址正好等于 ROM 中存放第一条代码的位置。之后取出这里的指令在跳转到别处。</p><p>ARM 架构的芯片也是类似的过程，对于 32 位的芯片，通电后，<code>PC</code>指针寄存器复位至零地址，随后从中断向量表表头的 reset 向量处获取下一个跳转的地址。这时候的代码已经以二进制形式存储，处理器可以直接搬到自身缓存中运行。有了这部分代码，就能跳转到存放有更多更复杂的代码的地址。执行硬件自检，基本的初始化操作，提供基础的输入输出支持。之后可以将操作系统从外部的存储空间加载到内部。代码就这样接力式的流转起来。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191002002.png"></p><p>所以我们把出厂就写在<code>ROM</code>里，负责启动后续用户软件的软件，称为<code>Boot ROM</code>或者<code>ROM Code</code>。现在不一定是用只读存储器（Read Only Memory），但是至少是一块掉电不易失的存储器，现在主要用<code>EEPROM</code>，<code>NOR Flash</code>。我们一般没有权限修改它，但是它也不完全是黑盒，大部分芯片都会有外部启动配置引脚，通常是以拨码快关的形式。对于 PC 机来说，<code>Boot ROM</code>就是我们常说的<code>BIOS</code>，它也有启动配置途径。而且提供了交互界面，用于配置部分功能和选择后续的引导设备。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191009985.png"></p><p>除了芯片自带的<code>Boot ROM</code>，还需要再给自己实际的应用程序，写一个二次引导代码或者 N 次引导代码，用作操作系统，文件系统加载等等。我们所说的<code>Bootloader</code>时，其实大多数就是这样的二次引导代码。</p><p>这些事其实<code>Boot ROM</code>它也能做，但是<code>Boot ROM</code>实现的功能和配置方法不灵活，但是<code>Bootloader</code>是开发人员可以而完全控制的引导代码。</p><p>在设计<code>Bootloader</code>时，<code>MCU</code>的引导步骤就开始和嵌入式 Linux 或者 PC 有所不同。这一定程度与芯片架构所采用的的存储方案有关。</p><p>先来说<code>MCU</code>，与<code>SOC</code>相比<code>MCU</code>的主要特征是单核和或多核同构的微处理器，单核或多核同构，主频 &lt; 1GHz，没有<code>MMU</code>内存管理单元，只能运行实时操作系统。常见<code>MCU</code>内核：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191051828.png"></p><p>程序的主要运行介质为<code>NOR Flash</code>，因为和<code>RAM</code>一样有分离的地址线和数据线。并且可以以字节长度精确寻址，所以程序不需要拷贝到<code>RAM</code>中运行的。</p><p>以英飞凌家的 TC27x 系列 MCU 为例，上电后的默认取址位置是<code>0x8FFF 8000</code>，这就是他的<code>Boot ROM</code>在<code>NorFlash</code>中的地址。并且这块<code>Boot Rom</code>分为<code>SSW</code>，<code>BSL</code>，<code>TF</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191055339.png"></p><p>SSW 每次上电必须运行，他会根据写在<code>program flash</code>，<code>PFO</code>地址的前 32byte 中的配置字，来决定<code>SSW</code>执行完的跳转地址。我们可以选择一个合适的跳转地址，比如<code>0x80000020</code>，放上自己写的<code>Bootloader</code>。也可以选择不跳转，运行厂家提供的<code>Bootloader</code>（BSL）。</p><p><code>MCU</code>下的<code>Bootloader</code>主要完成的事情有以下：</p><ul><li>关闭看门狗，初始化中断和 trap 向量表，进行时钟和外设初始化，让芯片正常运行起来。</li><li>提供<code>CAN</code>,<code>UART</code>, <code>ETH</code>等用于通讯功能的驱动，能够接收外部数据传输请求。</li><li>提供<code>FLASH</code>的读写与擦除驱动，设计服务来对通讯端口接收到的更新代码进行校验、存储，以及跳转操作系统或后续应用程序代码。</li><li>如有必要，还会开发一些基础诊断服务，串口交互程序等等。</li></ul><p>那么运行 Linux 的<code>SOC</code>和 PC 的这一过程有何不同呢。还是先看存储方案，运行嵌入式 Linux 的 SoC。一般将它的操作系统，文件系统和他的应用程序放在<code>nand flash</code>中。运行代码前，现将代码搬运到<code>SRAM</code>中，相比<code>MCU</code>多了一道步骤。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191101930.png"></p><p>对于<code>SOC</code>的<code>Boot ROM</code> 和 PC 的<code>BIOS</code>而言，他们结束运行前的最终任务，是将某些代码从<code>nand flash</code>搬运到<code>SRAM</code>中，其中最重要的内容就是<code>Boot Loader</code>。</p><p>而一般<code>SOC</code>的<code>Bootloader</code>，又分为<code>SPL</code>（Secondary Program Loader）和<code>uBOOT</code>两个阶段。<code>SPL</code>的 Secondary 就是相对于<code>BootROM</code>而言，他就像是接力赛中的第二棒选手。<code>SPL</code>会初始化更大空间的外部<code>DRAM</code>，再把<code>uBoot</code>搬运到外部<code>DRAM</code>中去运行。<code>uBoot</code>作为第三棒选手，开始运行它的初始化程序。之后再根据系统环境变量，将 OS 内核搬运到外部<code>DRAM</code>中去运行。OS 再完成根文件系统的加载等等等等。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191116399.gif"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bootloader</tag>
      
      <tag>Boot Rom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定时器 Timer 基础</title>
    <link href="/2021/12/15/%E5%AE%9A%E6%97%B6%E5%99%A8Timer%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/12/15/%E5%AE%9A%E6%97%B6%E5%99%A8Timer%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>定时器（Timer），又叫计时器，顾名思义，它的主要功能就是计时。因为 CPU 计时会占用大量资源，而定时器独立于 CPU，专门用来计时。单核 CPU 好比人的大脑，一心不可二用，它只能知道自己当前要干什么。人可以用闹钟来提醒自己某个时间需要做某件事，而 CPU 就需要定时器来完成这样的工作。</p><p>当定时器被开启后，里面的计数器就以计数器时钟的频率开始运行，内部的计数值不断增加。例如一个时钟为<code>1MHz</code>的定时器，被开启后每隔<code>1us</code>计数值就会加 1。但计数值不可能无限增加，最大值比如<code>65535</code>。将这个十进制数转为二进制数后应该是一个 16 位的二进制数<code>1111 1111 1111 1111</code>。所以我们需要有一个 16 位大小的存储空间来存储它。那这就是一个 16 位定时器。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>定时器可以让 SoC 在执行主程序的同时，可以 (通过定时器) 具有计时功能，到了一定时间 (计时结束) 后，定时器会产生中断提醒 CPU，CPU 会去处理中断并执行定时器中断的 ISR，从而去执行预先设定好的事件。打个比方，定时器就像一个秘书，CPU 就是老板。老板每天都有很多事要做，具体时间安排不想操心，就安排给秘书。秘书每天就是盯着表，到点就提醒老板要做某事。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>外设的工作频率是与它所挂载在的外设总线的时钟频率相同的。但工作频率不是时钟频率，工作频率到时钟频率需要进行一次分频。这个可调节的分频值使得定时器的计时更加灵活。这个分频值就是需要设置的第一个参数<strong>预分频系数</strong>。</p><p>$$<br>计数器时钟频率 = 工作频率/(预分频系数+1)<br>$$</p><p>$$<br>定时频率 = 计时器时钟频率/(自动重载值+1)<br>$$</p><p>假设定时器时钟频率为<code>1MHz</code>，那定时<code>1ms</code>该如何做？计数 1000 次即可。最大的计数值就是<strong>自动重载值</strong>，是我们需要设置的第二个参数。定时器被打开后，计数值就增加，一旦达到自动重载值就会出发定时器溢出中断，就实现了定时<code>1ms</code>。</p><h2 id="计数模式"><a href="#计数模式" class="headerlink" title="计数模式"></a>计数模式</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211214100956.png"></p><ul><li><p>中心计数：计数器从 0 开始计数到自动装入的值 -1，产生一个计数器溢出事件，0 然后向下计数到 1 并且产生一个计数器溢出事件，然后再从 0 开始重新计数。</p></li><li><p>向上计数：计数器从 0 计数到自动加载值 (TIMx_ARR) ，然后重新从 0 开始计数并且产生一个计数器溢出事件。</p></li><li><p>向下计数：计数器从自动装入的值 (TIMx_ARR) 开始向下计数到 0，然后从自动装入的值重新开始，并产生一个计数器向下溢出事件。</p></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211214140256.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>Timer</tag>
      
      <tag>外设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Qt-QObject::connect: Cannot queue arguments of type‘QTextCursor’错误</title>
    <link href="/2021/12/04/%E8%A7%A3%E5%86%B3Qt-QObject-connect-Cannot-queue-arguments-of-type-%E2%80%98QTextCursor%E2%80%99%E9%94%99%E8%AF%AF/"/>
    <url>/2021/12/04/%E8%A7%A3%E5%86%B3Qt-QObject-connect-Cannot-queue-arguments-of-type-%E2%80%98QTextCursor%E2%80%99%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>我在线程中直接调用了 QTextEdit 的 append 函数时，候就会出现下面的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">QObject::connect: Cannot queue arguments of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;QTextCursor&#x27;</span><br> <br>(Make sure <span class="hljs-string">&#x27;QTextCursor&#x27;</span> is registered using qRegisterMetaType().)<br></code></pre></td></tr></table></figure><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>原因是**我们不能通过线程来修改 UI，较为安全的修改用户界面的方式是向 UI 窗口发送信号 (signal)**，较为简单的方式是使用 Qt threading 类。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在窗口类中定义信号和槽，并声明和实现一个接口函数，这个接口函数由线程调用，在接口函数中 emit 一个信号，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//mainwindow.h</span><br>signals:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AppendText</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span>;<br><span class="hljs-keyword">private</span> slots:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SlotAppendText</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span>;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Append</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span>;<br><span class="hljs-comment">//mainwindow.cpp</span><br><span class="hljs-built_in">connect</span>(<span class="hljs-keyword">this</span>,<span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">AppendText</span>(QString)),<span class="hljs-keyword">this</span>,<span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">SlotAppendText</span>(QString)));<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClassName::Append</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">emit <span class="hljs-title">AppendText</span><span class="hljs-params">(<span class="hljs-string">&quot;ok: string1&quot;</span>)</span></span>;<br>&#125;<br><span class="hljs-comment">//thread.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ThreadClassName::SlotAppendText</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span><br><span class="hljs-function"></span>&#123;<br>    mText.<span class="hljs-built_in">append</span>(text);<br>&#125;<br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Linux 启动出现 fsck exited with status code 4</title>
    <link href="/2021/12/04/%E8%A7%A3%E5%86%B3Linux%E5%90%AF%E5%8A%A8%E5%87%BA%E7%8E%B0fsck-exited-with-status-code-4/"/>
    <url>/2021/12/04/%E8%A7%A3%E5%86%B3Linux%E5%90%AF%E5%8A%A8%E5%87%BA%E7%8E%B0fsck-exited-with-status-code-4/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112041102634.png"></p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>磁盘检测不能通过，可能是因为系统突然断电或其它未正常关闭系统导致。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>根据提示可以看到是<code>dev/sda5</code>这个扇区出现了异常，所以通过<code>fsck</code>命令修复文件系统。<a href="https://www.runoob.com/linux/linux-comm-fsck.html">详细命令解释</a>。</p><p>将<code>sda5</code>改为自己损坏的扇区即可，等待一段时间修复完成后，输入<code>exit</code>即可重启。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fsck -y  /dev/sda5<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 跨窗口，控件类传递数据</title>
    <link href="/2021/12/02/Qt%E8%B7%A8%E7%AA%97%E5%8F%A3%EF%BC%8C%E6%8E%A7%E4%BB%B6%E7%B1%BB%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/"/>
    <url>/2021/12/02/Qt%E8%B7%A8%E7%AA%97%E5%8F%A3%EF%BC%8C%E6%8E%A7%E4%BB%B6%E7%B1%BB%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p>本文基于<a href="https://blog.csdn.net/shihoongbo/article/details/48681979">【Qt】窗体间传递数据（跨控件跨类），三种情况与处理方法</a></p><p>已知三个窗体，A 为 B C 的父控件，B 与 C 互为兄弟控件<br>那么参数传递分三种情况：</p><ol><li>B 向 A（C 向 A）传递参数</li><li>B 向 C（C 向 B）传递参数</li><li>A 向 B（A 向 C）传递参数</li></ol><p>三个空间关系模型参考如下，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211208122116.png"></p><h2 id="B-向-A（C-向-A）传递参数"><a href="#B-向-A（C-向-A）传递参数" class="headerlink" title="B 向 A（C 向 A）传递参数"></a>B 向 A（C 向 A）传递参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//B.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>signals:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toA</span><span class="hljs-params">([ParamList])</span></span>;<br>&#125;<br><br><span class="hljs-comment">//B.cpp</span><br>B::<span class="hljs-built_in">B</span>()<br>&#123;<br>    <span class="hljs-function">emit <span class="hljs-title">toA</span><span class="hljs-params">([ParamList])</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//A.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>   B *b;<br><span class="hljs-keyword">private</span> slots:<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fromB</span><span class="hljs-params">([ParamList])</span></span>;<br>&#125;<br><br><span class="hljs-comment">//A.cpp</span><br>A::<span class="hljs-built_in">A</span>()<br>&#123;<br>    b = <span class="hljs-keyword">new</span> B;<br>    <span class="hljs-built_in">connect</span>(b, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">toA</span>([ParamList])), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">fromB</span>([ParamList])));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A::fromB</span><span class="hljs-params">([ParamList])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//get[ParamList]</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-向-C（C-向-B）传递参数"><a href="#B-向-C（C-向-B）传递参数" class="headerlink" title="B 向 C（C 向 B）传递参数"></a>B 向 C（C 向 B）传递参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//A.h</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  B *b;<br>  C *c;<br>&#125;<br><br><span class="hljs-comment">//A.cpp</span><br>A::<span class="hljs-built_in">A</span>()<br>&#123;<br>  b = <span class="hljs-keyword">new</span> B;<br>  c = <span class="hljs-keyword">new</span> C;<br>  <span class="hljs-built_in">connect</span>(b, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">toC</span>([ParamList]), c, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">fromB</span>([ParamList])));<br>&#125;<br><br><span class="hljs-comment">//B.h</span><br>class B<br>&#123;<br>signals:<br> <span class="hljs-keyword">void</span> <span class="hljs-built_in">toC</span>([ParamList]);<br>&#125;<br><br><span class="hljs-comment">//B.cpp</span><br>B::<span class="hljs-built_in">B</span>()<br>&#123;<br>  emit <span class="hljs-built_in">toC</span>([ParamList]);<br>&#125;<br><br><span class="hljs-comment">//C.h</span><br>class C<br>&#123;<br><span class="hljs-keyword">private</span> slots:<br>  <span class="hljs-keyword">void</span> <span class="hljs-built_in">fromB</span>([ParamList]);<br>&#125;<br><br><span class="hljs-comment">//C.cpp</span><br><span class="hljs-keyword">void</span> C::<span class="hljs-built_in">fromB</span>([ParamList])<br>&#123;<br><span class="hljs-comment">//get[ParamList]</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A-向-B（A-向-C）传递参数"><a href="#A-向-B（A-向-C）传递参数" class="headerlink" title="A 向 B（A 向 C）传递参数"></a>A 向 B（A 向 C）传递参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//B.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fromA</span><span class="hljs-params">([ParamList])</span></span>;<br>&#125; <br><br><span class="hljs-comment">//B.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B::fromA</span><span class="hljs-params">([ParamList])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//get[ParamList]</span><br>&#125;<br><br><span class="hljs-comment">//A.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>   B *b;<br>&#125;<br><br><span class="hljs-comment">//A.cpp</span><br>A:<span class="hljs-built_in">A</span>()<br>&#123;<br>    b = <span class="hljs-keyword">new</span> B;<br>    b-&gt;<span class="hljs-built_in">fromA</span>([ParamList]);<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clang-Format 格式化代码</title>
    <link href="/2021/12/01/Clang-Format%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/12/01/Clang-Format%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install clang-format<br></code></pre></td></tr></table></figure><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>每每到这时候就越能感受到用 Linux 作为开发环境的优势，Windows 安装就稍显复杂了。</p><ol><li><p>你可以选择安装完整的 LLVM，在<code>bin</code>目录可以看到<code>clang-format.exe</code>。安装完后，将 <code>bin</code> 目录<strong>添加到环境变量</strong>中。</p></li><li><p>你也可以只下载<code>clang-format.exe</code>，从<a href="https://llvm.org/builds/">LLVM Snapshot Builds</a>下载安装包。在下载页面的底部。同样你需要将单独下载的文件<strong>加入到环境变量</strong>中。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208271559281.png"></p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h3><p>Linux 可以直接命令行，使用以 LLVM 代码风格格式化<code>main.cpp</code>, 结果直接写到<code>main.cpp</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang g-format -i main.cpp -style=LLVM<br></code></pre></td></tr></table></figure><h3 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h3><p>如果每次编码都命令行执行一遍那也太麻烦了，而且每次修改也不止一个文件。最好的方式就是每次保存文件时自动格式化。比如 VSCode 已经内置了<code>Clang-Format</code>稍作配置即可实现，接下来介绍几种常见 IDE 如何配置<code>Clang-Format</code>。</p><h4 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h4><p>VSCode 最常用，因为内置了<code>Clang-Format</code>也最容易配置。</p><ul><li>安装<code>C/C++</code>插件，<code>Ctrl+Shift+X</code>打开应用商店，搜索<code>C/C++</code>找到下图插件，安装后会自动安装<code>Clang-Format</code>程序，无需单独下载。默认安装路径为：<br><code>C:\Users\(你的用户名)\.vscode\extensions\ms-vscode.cpptools-1.7.1\LLVM\bin\clang-format.exe</code>。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012311818.png"></li><li>打开设置页面（左下角齿轮 - 设置），搜索<code>format</code>，勾选<code>Format On Save</code>，每次保存文件时自动格式化文档。下方的设置是决定每次格式化是整个文档，还是做过修改的内容。默认是<code>file</code>，对整个文档进行格式化。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012304766.png"></li><li>仍在设置页面搜索<code>Clang</code>，配置如下。<code>.clang-format</code>文件最后详解。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012321838.png"></li><li>效果图<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012327867.gif"></li></ul><h4 id="QtCreator"><a href="#QtCreator" class="headerlink" title="QtCreator"></a>QtCreator</h4><ul><li>安装<code>Beautifier</code>插件：帮助（<code>Help</code>）-关于插件（<code>About Plugins</code>）- <code>Beautifier</code>勾选，重启 QtCreator。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202183720.png"></li><li>工具（Tool）- <code>Beautifier</code>，配置如图。该配置，保存文档时自动格式化，并选择<code>Clang-Format</code>作为格式化工具。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202184119.png"><br>配置<code>Clang-Format</code>程序路径，如果开头已经<code>apt install</code>安装过，这里会自动补全。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202184247.png"></li><li><code>Use predefined style</code>可以选择内置的一些代码风格，如<code>LLVM</code>，<code>Google</code>等。</li><li><code>Use customized style</code>使用自定义的一些代码风格。点击添加（<code>Add</code>）将配置文件粘贴进去即可，具体配置文件见最后。</li><li>别忘了点击<code>OK</code>保存。</li></ul><h4 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h4><ul><li><p>安装<code>cppstyle</code>插件：Help - Eclipse Marketplace - 搜索<code>cppstyle</code>。</p></li><li><p>下载<code>cpplint</code>。<br>  可以去github上下载<a href="https://github.com/google/styleguide">cpplint的源码</a>，下载完之后解压放到某个目录下。</p></li><li><p>在<code>Window</code> - <code>Preferences</code> - <code>C/C++</code> - <code>CppStyle</code>页面把<code>clang-format</code>的路径添加进去，然后把<code>cpplint</code>的目录指向刚才下载的<code>styleguide</code>目录下的<code>cpplint/cpplint.py</code>就可以了。勾选下面的<code>Enable cpplint</code>，<code>Run clang-format on file save</code>，然后点击<code>Apply and Close</code>保存修改并退出。如下图所示。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202190912.png"></p></li><li><p>此时再保存代码，将会出现如下错误，因为我们还未给当前项目编写配置文件<code>.clang-format</code>。将最后一章提到的配置文件放到当前项目的下即可，程序会自动搜索。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Cannot find .clang-format or _clang-format configuration file under any level parent directories of path.<br>Clang-format will default to Google style.<br></code></pre></td></tr></table></figure></li></ul><h2 id="配置简介"><a href="#配置简介" class="headerlink" title="配置简介"></a>配置简介</h2><p>上文多次提到了<code>.clang-format</code>配置文件，该文件决定了代码如何格式化，现在来介绍如何使用该文件。</p><h3 id="导出-clang-format文件"><a href="#导出-clang-format文件" class="headerlink" title="导出.clang-format文件"></a>导出<code>.clang-format</code>文件</h3><p>如果重新编写一份配置文件，需要考虑的东西太多，<code>clang-format</code>内置了一些常见风格，我们可以根据已有的配置文件稍作修改，形成自己的代码风格。所以我们先导出一份内置的配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang-format -style=可选格式名 -dump-config &gt; .clang-format<br><span class="hljs-comment"># 可选格式最好写预设那那几个写最接近你想要的格式。比如我想要接近 Google C++ style 的。我就写-style=google</span><br></code></pre></td></tr></table></figure><h3 id="各个选项的含义"><a href="#各个选项的含义" class="headerlink" title="各个选项的含义"></a>各个选项的含义</h3><p>这里给出了配置的含义，感兴趣也可以查看官方文档，还提供了一些有案例，描述更清晰。</p><p>一些比较明显的代码分格区别</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># 括号是分行，还是不分行，只有当 BreakBeforeBraces 设置为 Custom 时才有效<br>BraceWrapping:<br>  AfterCaseLabel:  <span class="hljs-literal">true</span><br>  # <span class="hljs-keyword">class</span> 定义后面<br>  <span class="hljs-symbol">AfterClass:      <span class="hljs-symbol">true</span></span><br>  # 控制语句后面<br>  <span class="hljs-symbol">AfterControlStatement: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterEnum:       <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterFunction:   <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterNamespace:  <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterObjCDeclaration: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterStruct:     <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterUnion:      <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterExternBlock: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">BeforeCatch:     <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">BeforeElse:      <span class="hljs-symbol">true</span></span><br>  # 缩进大括号，<span class="hljs-symbol">if</span> <span class="hljs-symbol">else</span> 语句后面的括号缩进<br>  <span class="hljs-symbol">IndentBraces:    <span class="hljs-symbol">false</span></span><br>  <span class="hljs-symbol">SplitEmptyFunction: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">SplitEmptyRecord: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">SplitEmptyNamespace: <span class="hljs-symbol">true</span></span><br><span class="hljs-symbol">BreakBeforeBinaryOperators: <span class="hljs-symbol">None</span></span><br><span class="hljs-symbol">BreakBeforeBraces: <span class="hljs-symbol">Custom</span></span><br><br># <span class="hljs-symbol">tab</span> 宽度<br><span class="hljs-symbol">TabWidth: <span class="hljs-symbol">4</span></span><br><br># 换行缩进字符数<br><span class="hljs-symbol">IndentWidth:     <span class="hljs-symbol">4</span></span><br><br># 宏定义对齐<br><span class="hljs-symbol">AlignConsecutiveMacros: <span class="hljs-symbol">AcrossEmptyLinesAndComments</span></span><br></code></pre></td></tr></table></figure><p>基于LLVM代码风格修改的个人使用版本：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">Language:</span>        <span class="hljs-string">Cpp</span><br><span class="hljs-comment"># BasedOnStyle:  LLVM</span><br><span class="hljs-attr">AccessModifierOffset:</span> <span class="hljs-number">-2</span><br><span class="hljs-attr">AlignAfterOpenBracket:</span> <span class="hljs-string">Align</span><br><span class="hljs-comment"># 宏定义对齐</span><br><span class="hljs-attr">AlignConsecutiveMacros:</span> <span class="hljs-string">AcrossEmptyLinesAndComments</span><br><span class="hljs-attr">AlignConsecutiveAssignments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignConsecutiveDeclarations:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignConsecutiveBitFields:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignEscapedNewlines:</span> <span class="hljs-string">Right</span><br><span class="hljs-attr">AlignOperands:</span>   <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignTrailingComments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowAllArgumentsOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowAllConstructorInitializersOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowShortBlocksOnASingleLine:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 是否允许短方法单行，只有一行的函数将不会分行，直接写在函数名后</span><br><span class="hljs-attr">AllowShortFunctionsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">AllowShortLambdasOnASingleLine:</span> <span class="hljs-string">All</span><br><span class="hljs-attr">AllowShortIfStatementsOnASingleLine:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">AllowShortLoopsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">AlwaysBreakAfterDefinitionReturnType:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">AlwaysBreakAfterReturnType:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">AlwaysBreakTemplateDeclarations:</span> <span class="hljs-string">MultiLine</span><br><span class="hljs-attr">BinPackArguments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">BinPackParameters:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 括号是分行，还是不分行，只有当 BreakBeforeBraces 设置为 Custom 时才有效</span><br><span class="hljs-attr">BraceWrapping:</span><br>  <span class="hljs-attr">AfterCaseLabel:</span>  <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># class 定义后面</span><br>  <span class="hljs-attr">AfterClass:</span>      <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 控制语句后面</span><br>  <span class="hljs-attr">AfterControlStatement:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterEnum:</span>       <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterFunction:</span>   <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterNamespace:</span>  <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterObjCDeclaration:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterStruct:</span>     <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterUnion:</span>      <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterExternBlock:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">BeforeCatch:</span>     <span class="hljs-literal">true</span><br>  <span class="hljs-attr">BeforeElse:</span>      <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 缩进大括号</span><br>  <span class="hljs-attr">IndentBraces:</span>    <span class="hljs-literal">false</span><br>  <span class="hljs-attr">SplitEmptyFunction:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">SplitEmptyRecord:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">SplitEmptyNamespace:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">BreakBeforeBinaryOperators:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">BreakBeforeBraces:</span> <span class="hljs-string">Custom</span><br><span class="hljs-attr">BreakBeforeInheritanceComma:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">BreakInheritanceList:</span> <span class="hljs-string">BeforeColon</span><br><span class="hljs-attr">BreakBeforeTernaryOperators:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">BreakConstructorInitializersBeforeComma:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">BreakConstructorInitializers:</span> <span class="hljs-string">BeforeColon</span><br><span class="hljs-attr">BreakAfterJavaFieldAnnotations:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">BreakStringLiterals:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">ColumnLimit:</span>     <span class="hljs-number">100</span><br><span class="hljs-attr">CommentPragmas:</span>  <span class="hljs-string">&#x27;^ IWYU pragma:&#x27;</span><br><span class="hljs-attr">CompactNamespaces:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">ConstructorInitializerAllOnOneLineOrOnePerLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">ConstructorInitializerIndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">ContinuationIndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">Cpp11BracedListStyle:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">DeriveLineEnding:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">DerivePointerAlignment:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">DisableFormat:</span>   <span class="hljs-literal">false</span><br><span class="hljs-attr">ExperimentalAutoDetectBinPacking:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">FixNamespaceComments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">ForEachMacros:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">foreach</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Q_FOREACH</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">BOOST_FOREACH</span><br><span class="hljs-attr">IncludeBlocks:</span>   <span class="hljs-string">Preserve</span><br><span class="hljs-attr">IncludeCategories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span>           <span class="hljs-string">&#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span><br>    <span class="hljs-attr">Priority:</span>        <span class="hljs-number">2</span><br>    <span class="hljs-attr">SortPriority:</span>    <span class="hljs-number">0</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span>           <span class="hljs-string">&#x27;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#x27;</span><br>    <span class="hljs-attr">Priority:</span>        <span class="hljs-number">3</span><br>    <span class="hljs-attr">SortPriority:</span>    <span class="hljs-number">0</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span>           <span class="hljs-string">&#x27;.*&#x27;</span><br>    <span class="hljs-attr">Priority:</span>        <span class="hljs-number">1</span><br>    <span class="hljs-attr">SortPriority:</span>    <span class="hljs-number">0</span><br><span class="hljs-attr">IncludeIsMainRegex:</span> <span class="hljs-string">&#x27;(Test)?$&#x27;</span><br><span class="hljs-attr">IncludeIsMainSourceRegex:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">IndentCaseLabels:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">IndentGotoLabels:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">IndentPPDirectives:</span> <span class="hljs-string">None</span><br><span class="hljs-comment"># 换行缩进字符数</span><br><span class="hljs-attr">IndentWidth:</span>     <span class="hljs-number">4</span><br><span class="hljs-attr">IndentWrappedFunctionNames:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">JavaScriptQuotes:</span> <span class="hljs-string">Leave</span><br><span class="hljs-attr">JavaScriptWrapImports:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">KeepEmptyLinesAtTheStartOfBlocks:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">MacroBlockBegin:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">MacroBlockEnd:</span>   <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">MaxEmptyLinesToKeep:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">NamespaceIndentation:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">ObjCBinPackProtocolList:</span> <span class="hljs-string">Auto</span><br><span class="hljs-attr">ObjCBlockIndentWidth:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">ObjCSpaceAfterProperty:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">ObjCSpaceBeforeProtocolList:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">PenaltyBreakAssignment:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="hljs-number">19</span><br><span class="hljs-attr">PenaltyBreakComment:</span> <span class="hljs-number">300</span><br><span class="hljs-attr">PenaltyBreakFirstLessLess:</span> <span class="hljs-number">120</span><br><span class="hljs-attr">PenaltyBreakString:</span> <span class="hljs-number">1000</span><br><span class="hljs-attr">PenaltyBreakTemplateDeclaration:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">PenaltyExcessCharacter:</span> <span class="hljs-number">1000000</span><br><span class="hljs-attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="hljs-number">60</span><br><span class="hljs-attr">PointerAlignment:</span> <span class="hljs-string">Right</span><br><span class="hljs-attr">ReflowComments:</span>  <span class="hljs-literal">true</span><br><span class="hljs-attr">SortIncludes:</span>    <span class="hljs-literal">true</span><br><span class="hljs-attr">SortUsingDeclarations:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceAfterCStyleCast:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceAfterLogicalNot:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceAfterTemplateKeyword:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeAssignmentOperators:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeCpp11BracedList:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceBeforeCtorInitializerColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeInheritanceColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeParens:</span> <span class="hljs-string">ControlStatements</span><br><span class="hljs-attr">SpaceBeforeRangeBasedForLoopColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceInEmptyBlock:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceInEmptyParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesBeforeTrailingComments:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">SpacesInAngles:</span>  <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInConditionalStatement:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInContainerLiterals:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpacesInCStyleCastParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInSquareBrackets:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceBeforeSquareBrackets:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">Standard:</span>        <span class="hljs-string">Latest</span><br><span class="hljs-attr">StatementMacros:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Q_UNUSED</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">QT_REQUIRE_VERSION</span><br><span class="hljs-attr">TabWidth:</span>        <span class="hljs-number">8</span><br><span class="hljs-attr">UseCRLF:</span>         <span class="hljs-literal">false</span><br><span class="hljs-attr">UseTab:</span>          <span class="hljs-string">Never</span><br><span class="hljs-string">...</span><br><br></code></pre></td></tr></table></figure><h3 id="格式化最新的commit代码"><a href="#格式化最新的commit代码" class="headerlink" title="格式化最新的commit代码"></a>格式化最新的commit代码</h3><p><code>clang-format</code>还提供一个<code>clang-format-diff.py</code>脚本，用来格式化<code>patch</code>，<code>code review</code>提交代码前，跑一遍下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 格式化最新的 commit，并直接在原文件上修改<br>git diff -U0 HEAD^ | clang-format-diff.py -i -p1<br></code></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="如何看懂官方文档并编写配置文件"><a href="#如何看懂官方文档并编写配置文件" class="headerlink" title="如何看懂官方文档并编写配置文件"></a>如何看懂官方文档并编写配置文件</h4><p><a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">官方文档</a>里有各种设置的示例代码，即使不知道想要的格式化是哪个配置参数，翻一翻官方文档是示例大概率能找到。那么找到了想要的配置参数，如何在文件里配置呢？</p><p>以宏定义对齐为例。我们想要宏定义的值保持对齐的状态，如下一节图片所示。可以翻一遍官方文档，可以发现这个示例代码对应的参数可能是我们想要的，<code>AlignConsecutiveMacros</code>翻译为<strong>对齐连续的宏定义</strong>。那应该八九不离十了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112202021134.png"></p><p>找到了参数如何编写配置文件呢？可以继续看这个参数下面的更多示例，每一个示例都对应一个配置可能值<code>Possible values</code>。</p><ul><li><p><code>ACS_None</code> (in configuration: <code>None</code>)<br>Do not align macro definitions on consecutive lines.<br><code>ACS_None</code>为这个配置的缩写，<code>None</code>表示在配置文件里的值。该配置表示不对宏定义进行对齐操作，在配置文件里可以添加如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">AlignConsecutiveMacros:</span> None<br></code></pre></td></tr></table></figure></li><li><p><code>ACS_Consecutive</code> (in configuration: <code>Consecutive</code>)<br>Align macro definitions on consecutive lines. This will result in formattings like:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SHORT_NAME       42</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LONGER_NAME      0x007f</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EVEN_LONGER_NAME (2)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> foo(x) (x * x)</span><br><span class="hljs-comment">/* some comment */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bar(y, z) (y + z)</span><br></code></pre></td></tr></table></figure><p><code>ACS_Consecutive</code>为这个配置的缩写，<code>Consecutive</code>表示在配置文件里的值。该配置表示对连续的宏定义进行对齐，在配置文件里可以添加如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">AlignConsecutiveMacros:</span> Consecutive<br></code></pre></td></tr></table></figure></li></ul><h4 id="宏定义对齐失效"><a href="#宏定义对齐失效" class="headerlink" title="宏定义对齐失效"></a>宏定义对齐失效</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 宏定义对齐</span><br><span class="hljs-symbol">AlignConsecutiveMacros:</span> AcrossEmptyLinesAndComments<br></code></pre></td></tr></table></figure><p>使用宏定义对齐更详细的配置，可以<a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">参考官方文档</a>。使用该配置一定要使用等宽的字体，否则配置生效但是显示不正确。<br>比如我是用<strong>微软雅黑</strong>字体作为编码字体，因为该字体每个字符不等宽，导致格式化正确，但是显示不正确。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112201954096.png"></p><p>如果将字体换位等宽字体如常用的<strong>Consolas</strong>，就可以正常显示。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112201958869.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Qt</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《代码整洁之道》读书笔记</title>
    <link href="/2021/11/29/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/11/29/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="代码整洁之道"><a href="#代码整洁之道" class="headerlink" title="代码整洁之道"></a>代码整洁之道</h1><h2 id="整洁代码"><a href="#整洁代码" class="headerlink" title="整洁代码"></a>整洁代码</h2><h3 id="整洁之道"><a href="#整洁之道" class="headerlink" title="整洁之道"></a>整洁之道</h3><ul><li><p>代码是我们最终用来表达需求的那种语言，代码永存；</p></li><li><p>时时保持代码整洁，稍后等于永不（<strong>Later equals never</strong>）；</p></li><li><p>整洁代码力求集中，每个函数、每个类和每个模块都全神贯注于一件事；</p></li><li><p>整洁代码简单直接，从不隐藏设计者的意图；</p></li><li><p>整洁代码应当有单元测试和验收测试。它使用有意义的命名，代码通过其字面表达含义；</p></li><li><p>消除重复代码，提高代码表达力。  </p></li></ul><h2 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><h3 id="避免误导"><a href="#避免误导" class="headerlink" title="避免误导"></a>避免误导</h3><ul><li><p>“一组账号”别用<code>accountList</code>表示，<code>List</code>对程序员有特殊含义，可以用 <code>accountGroup</code>、<code>bunchOfAccounts</code>、甚至是<code>accounts</code>；</p></li><li><p><strong>不使用区别较小的名称</strong>，<code>ZYXControllerForEfficientHandlingOfStrings</code>和 <code>ZYXControllerForEfficientStorageOfStrings</code>难以辨别；</p></li><li><p>不使用小写 l、大写 O 作变量名，看起来像常量 1、0。</p></li></ul><h3 id="做有意义的区分"><a href="#做有意义的区分" class="headerlink" title="做有意义的区分"></a>做有意义的区分</h3><ul><li><p><strong>不以数字系列命名</strong>(a1、a2、a3)，按照真实含义命名；</p></li><li><p><strong><code>Product/ProductInfo/ProductData</code></strong> 意思无区别，只统一用一个；</p></li><li><p>别写冗余的名字，变量名别带<code>variable</code>、表名别带<code>table</code>。</p></li></ul><h3 id="使用读得出来的名称"><a href="#使用读得出来的名称" class="headerlink" title="使用读得出来的名称"></a>使用读得出来的名称</h3><ul><li><code>genymdhms</code>（生成日期，年、月、日、时、分、秒）肯定不如<code>generation timestamp</code>（生成时间戳）方便交流。</li></ul><h3 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a>使用可搜索的名称</h3><ul><li>单字母名称和数字常量很难在上下文中找出。名称长短应与其作用域大小相对应，越是频繁出现的变量名称得越容易搜索 (越长)。</li></ul><h3 id="命名时避免使用编码"><a href="#命名时避免使用编码" class="headerlink" title="命名时避免使用编码"></a>命名时避免使用编码</h3><ul><li><p>把类型和作用域编码进名称里增加了解码负担。意味着新人除了了解代码逻辑之外，还需要学习这种<strong>编码语言</strong>；</p></li><li><p>别使用<strong>匈牙利语标记法</strong>(格式：**[Prefix]-BaseTag-Name** 其中 BaseTag 是数据类型的缩写，Name 是变量名字)，纯属多余。例如，<code>szCmdLine</code>的前缀<code>sz</code>表示“以零结束的字符串”；</p></li><li><p>不必用<code>m_</code>前缀来表明成员变量；</p></li><li><p>接口和实现别在名称中编码。接口名<code>IShapeFactory</code>的<strong>前导”I”是废话</strong>。如果接口和实现必须选一个编码，宁可选实现，<code>ShapeFactoryImp</code>都比对接口名称编码来的好。</p></li></ul><h3 id="避免思维映射"><a href="#避免思维映射" class="headerlink" title="避免思维映射"></a>避免思维映射</h3><ul><li><p>不应当让读者在脑中把你的名称翻译为他们熟知的名称。例如，循环计数器自然有可能被命名为<code>i</code>或<code>j</code>或<code>k</code>，但千万别用字母<code>l</code>；</p></li><li><p>专业程序员了解，<strong>明确是王道</strong>，编写能方便他人理解的代码。</p></li></ul><h3 id="类名、方法名"><a href="#类名、方法名" class="headerlink" title="类名、方法名"></a>类名、方法名</h3><ul><li><strong>类名应当是名词</strong>或名词短语，<strong>方法名应当是动词</strong>或动词短语。</li></ul><h3 id="命名不要耍宝幽默"><a href="#命名不要耍宝幽默" class="headerlink" title="命名不要耍宝幽默"></a>命名不要耍宝幽默</h3><ul><li>言到意到，意到言到，不要在命名上展示幽默感。</li></ul><h3 id="每个概念用一个词"><a href="#每个概念用一个词" class="headerlink" title="每个概念用一个词"></a>每个概念用一个词</h3><ul><li><code>fetch</code>、<code>retrieve</code>、<code>get</code>约定一个一直用即可。</li></ul><h3 id="尽管使用计算机科学术语"><a href="#尽管使用计算机科学术语" class="headerlink" title="尽管使用计算机科学术语"></a>尽管使用计算机科学术语</h3><ul><li>只有程序员才会读你的代码，不需要按照问题所在邻域取名称。</li></ul><h3 id="别用双关语"><a href="#别用双关语" class="headerlink" title="别用双关语"></a>别用双关语</h3><ul><li><code>add</code>方法一般语义是：根据两个值获得一个新的值。<strong>如果要把单个值加入到某个集合</strong>，用<code>insert</code>或<code>append</code>命名更好，这里用<code>add</code>就是双关语了。</li></ul><h3 id="添加有意义的语境"><a href="#添加有意义的语境" class="headerlink" title="添加有意义的语境"></a>添加有意义的语境</h3><ul><li>很少有名称能自我说明，<strong>需要用良好命名的类、函数、或者命名空间来放置名称</strong>，给读者提供语境，如果做不到的话，给名称添加前缀就是最后一招了。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="越短越好"><a href="#越短越好" class="headerlink" title="越短越好"></a>越短越好</h3><ul><li><p>短小，20 行封顶；</p></li><li><p><code>if/else/while</code>语句的代码块应该只有一行，该行应该是一个函数调用语句；</p></li><li><p>函数的缩进层级不应该多于一层或两层。</p></li></ul><h3 id="一个函数只做一件事"><a href="#一个函数只做一件事" class="headerlink" title="一个函数只做一件事"></a>一个函数只做一件事</h3><ul><li><p>如果函数只是做了该函数名下<strong>同一抽象层上的步骤</strong>，则函数只做了一件事；</p></li><li><p>要判断函数是否不止做了一件事，就是要看是否能<strong>再拆出一个函数</strong>；</p></li></ul><h3 id="每个函数一个抽象层级"><a href="#每个函数一个抽象层级" class="headerlink" title="每个函数一个抽象层级"></a>每个函数一个抽象层级</h3><ul><li><strong>向下规则</strong>：让代码拥有自顶向下的阅读顺序。每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能循抽象层级向下阅读了。</li></ul><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><ul><li><strong>把 switch 埋在较低的抽象层级</strong>，一般可以放在抽象工厂底下，用于创建多态对象。</li></ul><h3 id="使用描述性的名称"><a href="#使用描述性的名称" class="headerlink" title="使用描述性的名称"></a>使用描述性的名称</h3><ul><li><p>函数越短小、功能越集中，就越便于取个好名字；</p></li><li><p>别害怕长名称，<strong>长而具有描述性的名称，要比短而令人费解的名称好，要比描述性的长注释好；</strong></p></li><li><p>别害怕花时间取名字。</p></li></ul><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li><p><strong>参数越少越好</strong>，0 参数最好，尽量避免用三个以上参数；</p></li><li><p>参数越多，编写组合参数的测试用例就越困难；</p></li><li><p><strong>别用标识参数</strong>，向函数传入<code>bool</code>值是不好的，这意味着函数不止做一件事。可以将此函数拆成两个；</p></li><li><p>如果函数需要<strong>两个、三个或者三个以上参数</strong>，就说明其中<strong>一些参数应该封装成类了</strong>；</p></li><li><p><strong>将参数的顺序编码进函数名</strong>，减轻记忆参数顺序的负担，例如 <code>assertExpectedEqualsActual(expected, actual)</code>。</p></li></ul><h3 id="副作用-函数在正常工作任务之外对外部环境所施加的影响"><a href="#副作用-函数在正常工作任务之外对外部环境所施加的影响" class="headerlink" title="副作用 (函数在正常工作任务之外对外部环境所施加的影响)"></a>副作用 (函数在正常工作任务之外对外部环境所施加的影响)</h3><ul><li><p>检查密码并且初始化<code>session</code>的方法命名为<code>checkPasswordAndInitializeSession</code>而非 <code>checkPassword</code>，<strong>即使违反单一职责原则也不要有副作用</strong>；</p></li><li><p>避免使用”输出参数”，<strong>如果函数必须修改某种状态，就修改所属对象的状态吧</strong>。</p></li></ul><h3 id="设置-写-和查询-读-分离"><a href="#设置-写-和查询-读-分离" class="headerlink" title="设置 (写) 和查询 (读) 分离"></a>设置 (写) 和查询 (读) 分离</h3><p>-</p><pre><code class="hljs"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;unclebob&quot;</span>)) <br>&#123; <br>    ... <br>&#125;<br></code></pre></td></tr></table></figure>含义模糊不清。应该改为:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (attributeExists(<span class="hljs-string">&quot;username&quot;</span>)) <br>&#123; <br>    setAttribute(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;unclebob&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><h3 id="使用异常代替返回错误码"><a href="#使用异常代替返回错误码" class="headerlink" title="使用异常代替返回错误码"></a>使用异常代替返回错误码</h3><ul><li><p><strong>返回错误码</strong>会要求调用者立刻处理错误，从而<strong>引起深层次的嵌套结构</strong>；</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (deletePate(page) == E_OK) <br>&#123;<br>    <span class="hljs-keyword">if</span> (xxx() == E_OK) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (yyy() == E_OK) <br>        &#123;<br>            <span class="hljs-built_in">log</span>();<br>        &#125; <br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-built_in">log</span>();<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">log</span>();<br>    &#125;<br>&#125; <br><span class="hljs-keyword">else</span> <br>&#123;<br>    <span class="hljs-built_in">log</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>所以需要用<code>try catch</code>异常机制；</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">try</span> <br>&#123;<br>    deletePage();<br>    xxx();<br>    yyy();<br>    zzz();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) <br>&#123;<br>    <span class="hljs-built_in">log</span>(e-&gt;getMessage());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>try/catch</code>代码块丑陋不堪，所以最好把<code>try</code>和 <code>catch</code>代码块的主体抽离出来，单独形成函数。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">try</span> <br>&#123;<br>    <span class="hljs-keyword">do</span>();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) <br>&#123;<br>    handle();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="不要写重复代码"><a href="#不要写重复代码" class="headerlink" title="不要写重复代码"></a>不要写重复代码</h3><ul><li>重复是软件中一切邪恶的根源。当算法改变时需要修改多处地方。</li></ul><h3 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h3><ul><li><p>只要函数保持短小，偶尔出现的<code>return</code>、<code>break</code>、<code>continue</code>语句没有坏处，甚至还比单入单出原则更具有表达力。<code>goto</code>只有在大函数里才有道理，应该尽量避免使用。</p></li><li><p>并不需要一开始就按照这些规则写函数，没人做得到。想些什么就写什么，然后再打磨这些代码，按照这些规则组装函数。</p></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p>若编程语言足够有表现力，我们就不需要注释；</p></li><li><p>注释总是一种失败，因为我们无法找到不用注释就能表达自我的方法；</p></li><li><p>代码在演化，注释却不总是随之变动，会变得越来越不准确。</p></li></ul><h3 id="用代码来阐述"><a href="#用代码来阐述" class="headerlink" title="用代码来阐述"></a>用代码来阐述</h3><ul><li><p>创建一个与注释所言同一事物的函数即可，</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// check to see if the employee is eligible for full benefits </span><br><span class="hljs-keyword">if</span> ((employee.falgs &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; <span class="hljs-number">65</span>))<br></code></pre></td></tr></table></figure><p>应替换为</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (employee.isEligibleForFullBenefits())<br></code></pre></td></tr></table></figure></li></ul><h3 id="好注释"><a href="#好注释" class="headerlink" title="好注释"></a>好注释</h3><ul><li><p>法律信息，并且只要有可能就指向标准许可或者外部文档，而不是放全文；</p></li><li><p>提供基本信息，如解释某个<strong>抽象方法的返回值</strong>；</p></li><li><p>对意图的解释，反应了作者某个决定后面的意图；</p></li><li><p>阐释。把某些<strong>晦涩的参数或者返回值</strong>的意义<strong>翻译成可读的形式</strong>(更好的方法是让它们自身变得足够清晰，但是类似标准库的代码我们无法修改)；</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (b.compareTo(a) == <span class="hljs-number">1</span>) <span class="hljs-comment">//b &gt; a</span><br></code></pre></td></tr></table></figure></li><li><p>警示。<code>// don&#39;t run unless you have some time to kill</code>；</p></li><li><p><code>TODO</code>注释；</p></li><li><p>放大 一些看似不合理之物的重要性。</p></li></ul><h3 id="坏注释"><a href="#坏注释" class="headerlink" title="坏注释"></a>坏注释</h3><ul><li><p>自言自语；</p></li><li><p>多余的注释。<strong>把逻辑在注释里写一遍不能比代码提供更多信息</strong>，读它不比读代码简单。<strong>一目了然的成员变量别加注释</strong>，显得很多余；</p></li><li><p>误导性注释；</p></li><li><p>遵循规矩的注释。<strong>每个函数都加注释、每个变量都加注释是愚蠢的</strong>；</p></li><li><p>日志式注释。有了代码版本控制工具，不必在文件开头维护修改时间、修改人这类日志式的注释；</p></li><li><p><strong>能用函数或者变量表示就别用注释</strong>；</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// does the module from the global list &lt;mod&gt; </span><br><br><span class="hljs-comment">// depend on the subsystem we are part of?</span><br><span class="hljs-keyword">if</span> (smodule.getDependSubsystems().contains(subSysMod.getSubSystem())<br></code></pre></td></tr></table></figure><p>  可以改为：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList moduleDependees = smodule.getDependSubsystems();<br>String ourSubSystem = subSysMod.getSubSystem();<br><span class="hljs-keyword">if</span> (moduleDependees.contains(ourSubSystem))<br></code></pre></td></tr></table></figure></li><li><p>位置标记。<strong>标记多了会被我们忽略掉</strong>；</p><p><code>///////////////////// Actions //////////////////////////</code></p></li><li><p>右括号注释；</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">try</span> <br>&#123;<br>    <span class="hljs-keyword">while</span> () <br>    &#123;<br>        <span class="hljs-keyword">if</span> () <br>        &#123;<br>        ...<br>        &#125; <span class="hljs-comment">// if</span><br>        ...<br>    &#125; <span class="hljs-comment">// while</span><br>    ...<br>&#125; <span class="hljs-comment">// try</span><br></code></pre></td></tr></table></figure><p>如果你想标记右括号，其实应该做的是缩短函数</p></li><li><p>署名 <code>/* add by rick */</code> 源代码控制工具会记住你，<strong>署名注释跟不上代码的演变</strong>；</p></li><li><p>注释掉的代码。会导致看到这段代码其他人不敢删除，使用版本控制系统，可以大胆删除需要注释的代码；</p></li><li><p>信息过多。别在注释中添加有趣的历史话题或者无关的细节；</p></li><li><p>没解释清楚的注释。注释的作用是解释未能自行解释的代码，如果注释本身还需要解释就太遗憾了；</p></li><li><p>短函数的函数头注释。<strong>为短函数选个好名字比函数头注释要好</strong>；</p></li><li><p>非公共API函数的<code>javadoc/phpdoc</code>注释。</p></li></ul><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="垂直格式"><a href="#垂直格式" class="headerlink" title="垂直格式"></a>垂直格式</h3><ul><li><p>短文件比长文件更易于理解。<strong>平均200行，最多不超过500行的单个文件可以构造出色的系统</strong>；</p></li><li><p>像报纸一样排版，由略及详，层层递进；</p></li><li><p>区隔: 封包声明、导入声明、每个函数之间，都用空白行分隔开，<strong>空白行下面标识着新的独立概念</strong>，表示一个思路的开始</p></li><li><p>靠近: 紧密相关的代码应该互相靠近，例如<strong>一个类里的属性之间别用空白行隔开</strong>；</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReporterConfig</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">//The class name of the reporter listener</span><br>    <span class="hljs-keyword">private</span> String m_className;<br>    <span class="hljs-comment">//The properties of the reporter listener</span><br>    <span class="hljs-keyword">private</span> List&lt;Property&gt; m_properties = <span class="hljs-keyword">new</span> ArrayList&lt;Property&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addProperty</span><span class="hljs-params">(Property property)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        m_properties.add(property);<br>    &#125;<br>&#125;<br><span class="hljs-comment">///////////////////////对比////////////////////////////////////</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReporterConfig</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> String m_className;<br>    <span class="hljs-keyword">private</span> List&lt;Property&gt; m_properties = <span class="hljs-keyword">new</span> ArrayList&lt;Property&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addProperty</span><span class="hljs-params">(Property property)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        m_properties.add(property);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>变量声明应尽可能靠近其使用位置</strong>：循环中的控制变量应该总是在循环语句中声明；</p></li><li><p><strong>成员变量应该放在类的顶部声明</strong>，不要四处放置；</p></li><li><p><strong>如果某个函数调用了另外一个，就应该把它们放在一起</strong>。我们希望底层细节最后展现出来，不用沉溺于细节，所以<strong>调用者尽可能放在被调用者之上；</strong></p></li><li><p>执行同一基础任务的几个函数应该放在一起。</p></li></ul><h3 id="水平格式"><a href="#水平格式" class="headerlink" title="水平格式"></a>水平格式</h3><ul><li><p>一行代码不必死守80字符的上限，偶尔到达100字符不超过120字符即可；</p></li><li><p>区隔与靠近: 空格强调左右两边的分割。*<em>赋值运算符两边加空格，函数名与左圆括号之间不加空格，乘法运算符在与加减法运算符组合时不用加空格(a</em>b - c)**；</p></li><li><p>不必水平对齐。例如声明一堆成员变量时，各行不用每一个单词都对齐，代码自动格式化工具通常会把这类对齐消除掉；</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>　<span class="hljs-title">FitNesseExpediter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResponseSender</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span>　　 Socket　　　　　　　 socket;<br>    <span class="hljs-keyword">private</span>　　 InputStream　　　   input;<br>    <span class="hljs-keyword">private</span>　　 OutputStream　　　  output;<br>    <span class="hljs-keyword">private</span>　　 Request　　　　　　  request;<br>&#125;　　<br></code></pre></td></tr></table></figure></li><li><p>短小的<code>if</code>、<code>while</code>、函数里最好也不要违反缩进规则，不要这样:<code>if (xx == yy) z = 1</code>；</p></li><li><p><code>while</code>语句为空，最好分行写分号；</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="团队规则"><a href="#团队规则" class="headerlink" title="团队规则"></a>团队规则</h3><ul><li>团队绝对不要用各种不同的风格来编写源代码，这样会增加其复杂度。</li></ul><h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><ul><li>对象：暴露行为 (接口),隐藏数据 (私有变量)  ；</li><li>数据结构：没有明显的行为 (接口),暴露数据。如<code>DTO</code>(Data Transfer Objects)、<code>Entity</code>；</li></ul><h3 id="数据，对象的反对称性"><a href="#数据，对象的反对称性" class="headerlink" title="数据，对象的反对称性"></a>数据，对象的反对称性</h3><ul><li><p>使用<strong>数据结构便于</strong>在不改动现在数据结构的前提下<strong>添加新函数</strong>；使用<strong>对象便于</strong>在不改动既有函数的前提下<strong>添加新类</strong>；</p></li><li><p>使用<strong>数据结构难以添加新数据结构</strong>，因为必须修改所有函数；使用<strong>对象难以添加新函数</strong>，因为必须修改所有类；</p></li><li><p>万物皆对象只是个传说，有时候我们也会在简单数据结构上做一些过程式的操作。</p></li></ul><h3 id="Law-of-Demeter"><a href="#Law-of-Demeter" class="headerlink" title="Law of Demeter"></a>Law of Demeter</h3><ul><li><p><strong>模块不应该了解它所操作对象的内部情形</strong>；</p></li><li><p><code>class C</code>的方法<code>f</code>只应该调用以下对象的方法：</p><ul><li><p><code>C</code></p></li><li><p>在方法<code>f</code>里创建的对象</p></li><li><p>作为参数传递给方法<code>f</code>的对象</p></li><li><p><code>C</code>持有的对象</p></li></ul></li><li><p>方法不应调用 <strong>由任何函数返回的对象</strong> 的方法。下面的代码违反了 demeter 定律：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();<br></code></pre></td></tr></table></figure></li><li><p>一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p></li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>错误处理很重要，但是不能凌乱到打乱代码逻辑。</li></ul><h3 id="使用异常而不是返回错误码"><a href="#使用异常而不是返回错误码" class="headerlink" title="使用异常而不是返回错误码"></a>使用异常而不是返回错误码</h3><ul><li><p>如果使用错误码，调用者必须在函数返回时<strong>立刻处理错误</strong>，但这很容易被我们忘记；</p></li><li><p>错误码通常会导致<strong>嵌套</strong><code>if else</code>。</p></li></ul><h3 id="先写-try-catch-语句"><a href="#先写-try-catch-语句" class="headerlink" title="先写 try-catch 语句"></a>先写 try-catch 语句</h3><ul><li>当编写可能会抛异常的代码时，先写好<code>try-catch</code>再往里堆逻辑。</li></ul><h3 id="在-catch-里尽可能的记录"><a href="#在-catch-里尽可能的记录" class="headerlink" title="在 catch 里尽可能的记录"></a>在 catch 里尽可能的记录</h3><ul><li>在<code>catch</code>里尽可能的记录错误信息，记录失败的操作以及失败的类型</li></ul><h3 id="依调用者定义异常类"><a href="#依调用者定义异常类" class="headerlink" title="依调用者定义异常类"></a>依调用者定义异常类</h3><ul><li>对错误分类有很多方式。可以依其来源分类：是来自组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？</li></ul><h3 id="别返回-null-值"><a href="#别返回-null-值" class="headerlink" title="别返回 null 值"></a>别返回 null 值</h3><ul><li><p>返回<code>null</code>值只要一处没检查<code>null</code>，应用程序就会失败；</p></li><li><p>当想返回<code>null</code>值的时候，<strong>可以试试抛出异常，或者返回特例模式的对象。</strong></p></li></ul><h3 id="别传递-null-值"><a href="#别传递-null-值" class="headerlink" title="别传递 null 值"></a>别传递 null 值</h3><ul><li><p>在方法中传递<code>null</code>值是一种糟糕的做法，应该尽量避免；</p></li><li><p>在方法里用<code>if</code>或<code>assert</code>过滤<code>null</code>值参数，但是还是会出现运行时错误，没有良好的办法对付调动者意外传入的<code>null</code>值，恰当的做法就是<strong>禁止传入<code>null</code>值</strong>。</p></li></ul><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><h3 id="将第三方代码干净利落地整合进自己的代码中"><a href="#将第三方代码干净利落地整合进自己的代码中" class="headerlink" title="将第三方代码干净利落地整合进自己的代码中"></a>将第三方代码干净利落地整合进自己的代码中</h3><ul><li><p>避免公共 API 返回边界接口，或者将边界接口作为参数传递给 API。将边界保留在近亲类中；</p></li><li><p>不要在生产代码中试验新东西，而是编写测试来理解第三方代码；</p></li><li><p>避免我们的代码过多地了解第三方代码中的特定信息。</p></li><li><p>学习性测试是一种精确试验，帮助我们增进对 API 的理解。</p></li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="TDD-Test-driven-development-三定律"><a href="#TDD-Test-driven-development-三定律" class="headerlink" title="TDD(Test-driven development) 三定律"></a>TDD(Test-driven development) 三定律</h3><ul><li><p><em>First Law: You may not write production code until you have written a failing unit test.</em></p></li><li><p><em>Second Law: You may not write more of a unit test than is sufficient to fail, and not compiling is failing.</em></p></li><li><p><em>Third Law: You may not write more production code than is sufficient to pass the currently failing test.</em></p></li></ul><h3 id="保持测试整洁"><a href="#保持测试整洁" class="headerlink" title="保持测试整洁"></a>保持测试整洁</h3><ul><li><p><strong>脏测试等同于没测试</strong>，测试代码越脏生产代码越难修改；</p></li><li><p>测试代码和生产代码一样重要；</p></li><li><p>整洁的测试代码最应具有的要素是：<strong>整洁性</strong>。<strong>测试代码中不要有大量重复代码的调用。</strong></p></li></ul><h3 id="每个测试一个断言"><a href="#每个测试一个断言" class="headerlink" title="每个测试一个断言"></a>每个测试一个断言</h3><ul><li><p>每个测试函数<strong>有且仅有一个断言语句</strong>；</p></li><li><p>每个测试函数中<strong>只测试一个概念</strong>。</p></li></ul><h3 id="整洁的测试依赖于-FIRST-规则"><a href="#整洁的测试依赖于-FIRST-规则" class="headerlink" title="整洁的测试依赖于 FIRST 规则"></a>整洁的测试依赖于 FIRST 规则</h3><ul><li><p><strong>fast</strong>: 测试代码应该<strong>能够快速运行</strong>，因为我们需要频繁运行它；</p></li><li><p><strong>independent</strong>: 测试应该<strong>相互独立</strong>，某个测试不应该依赖上一个测试的结果，测试可以以任何顺序进行；</p></li><li><p><strong>repeatable</strong>: 测试应可以在任何环境中通过；</p></li><li><p><strong>self-validating</strong>: 测试应该有<code>bool</code>值输出，不应通过查看日志来确认测试结果，不应手工对比两个文本文件确认测试结果；</p></li><li><p><strong>timely</strong>: 及时编写测试代码。<strong>单元测试应该在生产代码之前编写</strong>，否则生产代码会变得难以测试。</p></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的组织"><a href="#类的组织" class="headerlink" title="类的组织"></a>类的组织</h3><p>以下针对 JAVA 语言，其他语言类似，变量在前，方法在后，公有在前，私有在后。</p><ul><li><p>公共静态常量</p></li><li><p>私有静态变量</p></li><li><p>私有实体变量</p></li><li><p>公共函数</p></li><li><p>私有工具函数</p></li></ul><p>如果测试需要调用一个函数或变量，可以设为保护类型。</p><h3 id="类应该短小"><a href="#类应该短小" class="headerlink" title="类应该短小"></a>类应该短小</h3><ul><li><p>对于函数我们计算<strong>代码行数</strong>衡量大小，对于类我们使用<strong>权责</strong>来衡量；</p></li><li><p><strong>类的名称应当描述其权责</strong>。类的命名是判断类长度的第一个手段，如果无法为某个类命以准确的名称，这个类就太长了。类名包含模糊的词汇，如<code>Processor</code>、<code>Manager</code>、<code>Super</code>，这种现象就说明有不恰当的<strong>权责聚集</strong>情况；</p></li><li><p>单一权责原则（Single Responsibility Principle，SRP）: 类或者模块应该有一个权责——只有一条修改的理由 (A class should have only one reason to change.)；</p></li><li><p>系统应该由许多短小的类而不是少量巨大的类组成；</p></li><li><p>类应该只有少量的实体变量，如果一个类中每个实体变量都被每个方法所使用，则说明该类具有<strong>最大的内聚性</strong>。创建最大化的内聚类不太现实，但是应该以高内聚为目标，<strong>内聚性越高说明类中的方法和变量互相依赖、互相结合形成一个逻辑整体</strong>；</p></li><li><p><strong>保持内聚性就会得到许多短小的类</strong>。如果你想把一个大函数的某一小部分拆解成单独的函数，拆解出的函数使用了大函数中的 4 个变量，不必<strong>将 4 个变量作为参数传递到新函数里</strong>，仅需<strong>将这 4 个变量提升为大函数所在类的实体变量</strong>，但是这么做却因为实体变量的增多而丧失了类的内聚性，更好多做法是<strong>让这 4 个变量拆出来，拥有自己的类</strong>。将大函数拆解成小函数往往是将类拆分为小类的时机。</p></li></ul><h3 id="为了修改而组织"><a href="#为了修改而组织" class="headerlink" title="为了修改而组织"></a>为了修改而组织</h3><ul><li><p>类应当对扩展开放，对修改封闭 (开放闭合原则)；</p></li><li><p>在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。</p></li></ul><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><h3 id="将系统的构造与使用分开"><a href="#将系统的构造与使用分开" class="headerlink" title="将系统的构造与使用分开"></a>将系统的构造与使用分开</h3><ul><li>软件系统应将起始过程和之后的运行逻辑分开。</li></ul><h3 id="分解-main"><a href="#分解-main" class="headerlink" title="分解 main"></a>分解 main</h3><ul><li><p><strong>将全部构造过程搬迁到 main</strong>或者被称之为<code>main</code>的模块中，涉及系统其余部分时，<strong>假设所有对象都已经正确构造</strong>；</p></li><li><p>依赖注入 (DI)，控制反转 (IoC) 是分离构造与使用的强大机制。</p></li></ul><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><h3 id="表达力"><a href="#表达力" class="headerlink" title="表达力"></a>表达力</h3><ul><li><p>作者把代码写的越清晰，其他人理解代码就越快；</p></li><li><p>太多时候我们深入于要解决的问题中，写出能工作的代码之后，就转移到下一个问题上，没有下足功夫调整代码让后来者易于阅读。多少尊重一下我们的手艺，花一点点时间在每个函数和类上。</p></li></ul><h3 id="尽可能少的类和方法"><a href="#尽可能少的类和方法" class="headerlink" title="尽可能少的类和方法"></a>尽可能少的类和方法</h3><ul><li><p>为了保持类和函数的短小，我们可能会早出太多细小的类和方法；</p></li><li><p>类和方法数量太多，有时是由毫无意义的教条主义导致的。</p></li></ul><h3 id="以上-4-条规则优先级依次递减。重要的是测试、消除重复、表达意图"><a href="#以上-4-条规则优先级依次递减。重要的是测试、消除重复、表达意图" class="headerlink" title="以上 4 条规则优先级依次递减。重要的是测试、消除重复、表达意图"></a>以上 4 条规则优先级依次递减。重要的是测试、消除重复、表达意图</h3><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="为什么要并发编程"><a href="#为什么要并发编程" class="headerlink" title="为什么要并发编程"></a>为什么要并发编程</h3><ul><li><p>并发总能改进性能；</p></li><li><p>编写并发程序无需修改设计；</p></li><li><p>在采用<code>Web</code>或<code>EJB</code>容器的时候，理解并发问题并不重要。</p></li></ul><h3 id="防御并发代码问题的原则与技巧"><a href="#防御并发代码问题的原则与技巧" class="headerlink" title="防御并发代码问题的原则与技巧"></a>防御并发代码问题的原则与技巧</h3><ul><li><p>遵循单一职责原则。分离并发代码与非并发代码；</p></li><li><p>限制临界区数量、限制对共享数据的访问；</p></li><li><p>避免使用共享数据，使用对象的副本；</p></li><li><p>线程尽可能地独立，不与其他线程共享数据。</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git-git pull 与 git pull --rebase 的区别</title>
    <link href="/2021/11/29/Git-git-pull%E4%B8%8Egit-pull-rebase%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/11/29/Git-git-pull%E4%B8%8Egit-pull-rebase%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull == git fetch + git merge<br>git pull --rebase == git fetch + git rebase<br></code></pre></td></tr></table></figure><p>拆解来看这两个命令就是在拉取远端代码后，是合并还是进行变基操作。</p><p>假设当前有三个提交<code>A,B,C</code>，并且分支<code>feature</code>都与远程代码同步。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129154905.png"></p><p>我们在<code>feature</code>上做了一些修改，并产生了<code>E</code>提交，远程也有用户进行了更新到了<code>D</code>提交。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129155138.png"></p><p>此时我们需要<code>git fetch</code>获取最新的代码，然后<code>git merge</code>解决冲突后重新<code>git add</code> <code>git commit</code>，得到<code>F</code>提交。最后<code>git push</code>即可成功推送，得到如下的关系</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129155544.png"></p><p>而使用<code>git rebase</code>将会创建一个新的提交<code>F</code>，<code>F</code>的文件内容和上面<code>F</code>的一样，但我们将 E 提交废除，当它不存在（图中用虚线表示）。由于这种删除，避免了菱形的产生，保持提交曲线为直线。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129162532.png"></p><p>在<code>rebase</code>的过程中，有时也会有冲突，这时 Git 会停止<code>rebase</code>并让用户去解决冲突，解决完冲突后，用<code>git add</code>添加修改的文件，然后不用执行<code>git commit</code>，直接执行<code>git rebase --continue</code>，这样 git 会继续 apply 余下的补丁。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git 同一文件被多人修改了文件名该如何处理</title>
    <link href="/2021/11/28/Git%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E8%A2%AB%E5%A4%9A%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E6%96%87%E4%BB%B6%E5%90%8D%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <url>/2021/11/28/Git%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E8%A2%AB%E5%A4%9A%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E6%96%87%E4%BB%B6%E5%90%8D%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>用户一修改了文件名，并推送到了远端。用户二也修改了文件名，在进行推送时，就会被拒绝。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282158733.png"></p><p>拉取最新代码后发现有相同的文件，只是文件名不同。<code>index1.htm</code>和<code>index2.htm</code>两个文件内容是完全相同的。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282159666.png"></p><p>查看当前状态，可知有其他想把文件名修改为<code>index2.htm</code>。此时只需要根据提示，删除<code>index.htm</code>。协商后决定保留哪一个文件，比如我们决定保留<code>index1.htm</code>。那么删除<code>index2.htm</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282203900.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282204020.png"></p><p>最后在<code>commit</code>一次，即可顺利推送。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282205646.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 他人同时修改了文件名和文件内容该如何处理</title>
    <link href="/2021/11/27/Git%E4%BB%96%E4%BA%BA%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E4%BA%86%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <url>/2021/11/27/Git%E4%BB%96%E4%BA%BA%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E4%BA%86%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>用户一修改了文件名，并提交远端。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272319842.png"></p><p>用户二修改了文件内容，也进行了推送，<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272320474.png"></p><p>当然会被无情拒绝，<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272321244.png"></p><p>解决这个问题也十分简单，Git 可以智能的感知到只是文件名被修改，只需要一个<code>git pull</code>命令就可以解决。弹出弹窗可以直接保存退出，默认不变就行。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 不同人修改了相同文件的相同区域</title>
    <link href="/2021/11/27/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E7%9B%B8%E5%90%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%90%8C%E5%8C%BA%E5%9F%9F/"/>
    <url>/2021/11/27/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E7%9B%B8%E5%90%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%90%8C%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<p>不同人修改了文件的相同区域，如果向远端推送，肯定会被拒绝。这时候就需要解决冲突，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272217729.png"></p><p>首先拉取远端最新的代码，会提示有冲突的文件，<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272220539.png"></p><p>打开冲突的文件，git 会对冲突区域进行标记，<code>&lt;&lt;&lt;&lt;&lt;&lt;</code>到<code>======</code>区域表示远端的代码。<code>======</code>到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>表示本地的代码。这时候就需要自己来判断需要哪些代码，也可以增删一些内容，修改完成后将这些标识符号删除，然后保存退出。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272221887.png"></p><p><code>git status</code>查看当前状态，提示还有未合并的路径，需要进行<code>commit</code>操作。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272256325.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272256627.png"></p><p>及时<code>git push</code>当前代码。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 文件删除仍然在 Trash 目录下占用空间，该如何删除 Trash 下的文件</title>
    <link href="/2021/11/25/Linux%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E4%BB%8D%E7%84%B6%E5%9C%A8Trash%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Trash%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <url>/2021/11/25/Linux%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E4%BB%8D%E7%84%B6%E5%9C%A8Trash%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Trash%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>查阅了一个<a href="https://askubuntu.com/questions/351400/deleting-contents-of-local-share-trash-expunged">网上的答案</a>，大意就是，你删除了属于你的文件夹，但其中包含属于另一个用户的文件时，文件可能会卡住，就会在 Trash 目录里不会被彻底删除。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo rm -rv /home/&lt;your_username&gt;/.<span class="hljs-built_in">local</span>/share/Trash/expunged/*<br></code></pre></td></tr></table></figure><p>PS：发现一个好用的磁盘分析工具，Linux 内置应用<code>Disk Usage Analyzer</code>。按<code>Win</code>键后搜索框搜索即可打开。</p><p>图形化的方式快速找到占用空间较大的目录，文件。可以右击直接删除。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211125102946.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 如何合并连续的多个 commit</title>
    <link href="/2021/11/24/Git%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%A4%9A%E4%B8%AAcommit/"/>
    <url>/2021/11/24/Git%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%A4%9A%E4%B8%AAcommit/</url>
    
    <content type="html"><![CDATA[<ul><li><p>确定需要合并的<code>commit</code><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242323497.png"></p></li><li><p>变基操作，以需要合并的<code>commit</code>下方的结点为基准。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242324125.png"></p></li><li><p>交互式变基，<code>squash</code>表示合并到上方<code>commit</code><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242325615.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242326279.png"></p></li><li><p>编写合并<code>commit</code>的<code>message</code>，保留原先的不变<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242328440.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242328175.png"></p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 不同人修改了同一文件的不同区域该如何处理</title>
    <link href="/2021/11/23/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <url>/2021/11/23/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ul><li><code>git fetch</code> <code>git merge</code><br>或者</li><li><code>git pull</code></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 修改老旧 commit 的 message</title>
    <link href="/2021/11/22/Git%E4%BF%AE%E6%94%B9%E8%80%81%E6%97%A7commit%E7%9A%84message/"/>
    <url>/2021/11/22/Git%E4%BF%AE%E6%94%B9%E8%80%81%E6%97%A7commit%E7%9A%84message/</url>
    
    <content type="html"><![CDATA[<p><strong>以下操作仅限于维护自己的分支，不建议对团队共享的代码进行修改。</strong></p><p>以最近三次提交为例，假设想要修改第二个提交的<code>message</code>。可以使用<code>git rebase</code>命令<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222255230.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> rebase -i <span class="hljs-number">27</span>d<span class="hljs-number">2</span>f<br></code></pre></td></tr></table></figure><ul><li><code>-i</code>交互式变基</li><li><code>27d2f</code>需要改变<code>message</code>的提交的父节点</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222258390.png"></p><p>弹出页面可以使用提供的命令进行操作，比如<code>pick</code>意思就是挑选需要的<code>commit</code>。本次任务需要修改<code>message</code>，从下方帮助文档里可以找到<code>reword</code>命令，可以保留<code>commit</code>，只修改<code>message</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222301367.png"></p><p>保存退出后，会弹出另外一个界面。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222302032.png"></p><p>在这里就可以真正修改需要更新的<code>message</code>。保存退出即可。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222303965.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 修改最新 commit 的 message</title>
    <link href="/2021/11/22/Git%E4%BF%AE%E6%94%B9%E6%9C%80%E6%96%B0commit%E7%9A%84message/"/>
    <url>/2021/11/22/Git%E4%BF%AE%E6%94%B9%E6%9C%80%E6%96%B0commit%E7%9A%84message/</url>
    
    <content type="html"><![CDATA[<p><code>commit</code>提交后觉得描述信息不准确，想重新修改<code>message</code>内容，该如何操作？</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span><br></code></pre></td></tr></table></figure><p>弹出页面就和<code>git commit</code>操作时的一样，将其改为新内容即可。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 C 语言 undefined reference to pthread_join</title>
    <link href="/2021/11/17/%E8%A7%A3%E5%86%B3C%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/"/>
    <url>/2021/11/17/%E8%A7%A3%E5%86%B3C%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><code>undefined reference to sleep</code>同样的问题。<br>在使用 C 语言线程函数时，需要包含<code>#include &lt;pthread&gt;</code>，编译时就会报这种错误。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p><code>pthread</code> 库不是 <code>Linux</code> 系统默认的库，连接时需要使用静态库 <code>libpthread.a</code>，所以在使用<code>pthread_create()</code>创建线程，以及调用<code>pthread_atfork()</code>函数建立<code>fork</code>处理程序时，需要链接该库。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc thread.c -o thread -lpthread<br></code></pre></td></tr></table></figure><p>如果是<code>Makefile</code>配置的编译条件，在<code>Makefile</code>文件中加上如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CFLAGS += -lpthread<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 QT 点击按钮无响应</title>
    <link href="/2021/11/16/%E8%A7%A3%E5%86%B3QT%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%97%A0%E5%93%8D%E5%BA%94/"/>
    <url>/2021/11/16/%E8%A7%A3%E5%86%B3QT%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%97%A0%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>在运行中的界面上点击按钮没有效果，像是按钮上层有其他遮盖层。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p><code>widget</code>的父控件上又添加了其他<code>Widget</code>，覆盖在了按钮上，因此无法点击。通过<code>new</code>得到的控件，默认显示在比它<code>new</code>的早的控件上面。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 将有按钮的那一层widget置于上层</span><br>widget-&gt;<span class="hljs-built_in">raise</span>();<br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 QT 在构造函数中写的控件不显示的问题</title>
    <link href="/2021/11/16/%E8%A7%A3%E5%86%B3QT%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%86%99%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/11/16/%E8%A7%A3%E5%86%B3QT%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%86%99%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>在新窗口中的构造函数中添加控件运行后却没有显示</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><ul><li><p>新建的工程师 MainWindow 子类工程，没有设置父窗口。</p></li><li><p>没有将控件的父窗口设置成自己定义的 widget。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br> <br>QMainWindow::<span class="hljs-built_in">QMainWindow</span>(QMainWindow*parent) :<br>    <span class="hljs-built_in">QMainWindow</span>(parent),<br>    <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::QMainWindow)<br>&#123;<br>     ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;add&quot;</span>);<br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;del&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法 1：给按钮控件设置父窗口：QWidget，并且把按钮添加到父窗口中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QHBoxLayout&gt;</span></span><br> <br>QMainWindow::<span class="hljs-built_in">QMainWindow</span>(QMainWindow*parent) :<br>    <span class="hljs-built_in">QMainWindow</span>(parent),<br>    <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::QMainWindow)<br>&#123;<br>     ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br>     QWidget* w = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QWidget</span>();<br>     <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setCentralWidget</span>(w);<br>     QHBoxLayout* hLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;add&quot;</span>);<br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;del&quot;</span>);<br>     hLayout-&gt;<span class="hljs-built_in">addWidget</span>(button_1);<br>     hLayout-&gt;<span class="hljs-built_in">addWidget</span>(button_2);<br>     w-&gt;<span class="hljs-built_in">setLayout</span>(hLayout);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法 2：手动指定父窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QHBoxLayout&gt;</span></span><br> <br>QMainWindow::<span class="hljs-built_in">QMainWindow</span>(QMainWindow*parent) :<br>    <span class="hljs-built_in">QMainWindow</span>(parent),<br>    <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::QMainWindow)<br>&#123;<br>     ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br>    <br>    <br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;add&quot;</span>);<br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;del&quot;</span>);<br>     button_1-&gt;<span class="hljs-built_in">setParent</span>(<span class="hljs-keyword">this</span>);<br>     button_2-&gt;<span class="hljs-built_in">setParent</span>(<span class="hljs-keyword">this</span>);<br>     button_2-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">300</span>,<span class="hljs-number">100</span>);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QWidget 中 update 不执行 paintEvent</title>
    <link href="/2021/11/15/%E8%A7%A3%E5%86%B3QWidget%E4%B8%ADupdate%E4%B8%8D%E6%89%A7%E8%A1%8CpaintEvent/"/>
    <url>/2021/11/15/%E8%A7%A3%E5%86%B3QWidget%E4%B8%ADupdate%E4%B8%8D%E6%89%A7%E8%A1%8CpaintEvent/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>手动执行<code>update()</code>或者<code>repaint()</code>都不能执行<code>paintEvent</code>函数。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>如果是代码<code>new</code>出来的控件，检查是否正确显示，比如有没有加入到<code>layout</code>中。或者有没有设置父窗口（可能被其他空间遮挡）。</p><p>检查控件<code>width</code>或者<code>height</code>大小是否不为 0。如果为 0，也不会出出发<code>paintEvent</code>。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>参考 QT 在构造函数中写的控件不显示</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 C++中 vector 声明错误 expected parameter declarator</title>
    <link href="/2021/11/13/%E8%A7%A3%E5%86%B3C-%E4%B8%ADvector%E5%A3%B0%E6%98%8E%E9%94%99%E8%AF%AFexpected-parameter-declarator/"/>
    <url>/2021/11/13/%E8%A7%A3%E5%86%B3C-%E4%B8%ADvector%E5%A3%B0%E6%98%8E%E9%94%99%E8%AF%AFexpected-parameter-declarator/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">QVector&lt;<span class="hljs-keyword">uint32_t</span>&gt; <span class="hljs-title">buttonPins</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><br></code></pre></td></tr></table></figure><p>声明了一个长度为 3 的<code>vector</code>数组，编译是会报这个错误。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>编译器可能无法区分这是一个成员函数声明还是一个成员变量声明，也就是产生歧义。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法 1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">QVector&lt;<span class="hljs-keyword">uint32_t</span>&gt; buttonPins = QVector&lt;<span class="hljs-keyword">uint32_t</span>&gt;(<span class="hljs-number">3</span>);<span class="hljs-comment">//明确这是一个成员变量</span><br><br></code></pre></td></tr></table></figure><p>方法 2：默认构造函数里面进行成员变量的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">MainWindow::<span class="hljs-built_in">MainWindow</span>(QWidget *parent) : <span class="hljs-built_in">QMainWindow</span>(parent),<br>    <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::MainWindow),<span class="hljs-built_in">buttonPins</span>(<span class="hljs-number">3</span>)&#123;&#125;<br></code></pre></td></tr></table></figure><p>方法 3：列表初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">QVector&lt;<span class="hljs-keyword">uint32_t</span>&gt; buttonPins&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 expected identifier before‘(’token</title>
    <link href="/2021/11/12/%E8%A7%A3%E5%86%B3expected-identifier-before-%E2%80%98-%E2%80%99-token/"/>
    <url>/2021/11/12/%E8%A7%A3%E5%86%B3expected-identifier-before-%E2%80%98-%E2%80%99-token/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>比如在一个枚举类型中，会告诉你某行有这种错误。又或者，在一个宏定义语句中出现这种错误。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>一般来说，出现这种情况，是语句中有些定义的名字发生了冲突。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>定位错误位置，搜索是否有同名的函数，变量等等。改个名字。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU 源码分析-外设模拟（以 GPIO 为例）</title>
    <link href="/2021/11/11/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%A4%96%E8%AE%BE%E6%A8%A1%E6%8B%9F%EF%BC%88%E4%BB%A5GPIO%E4%B8%BA%E4%BE%8B%EF%BC%89/"/>
    <url>/2021/11/11/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%A4%96%E8%AE%BE%E6%A8%A1%E6%8B%9F%EF%BC%88%E4%BB%A5GPIO%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="QEMU-模拟外设的原理"><a href="#QEMU-模拟外设的原理" class="headerlink" title="QEMU 模拟外设的原理"></a>QEMU 模拟外设的原理</h2><p>QEMU 主要是实现了 CPU 核的模拟，可以读写某个地址。<br>QEMU 的模拟外设的原理很简单：<strong>硬件即内存</strong>。<br>要在 QEMU 上模拟某个外设，思路就是：</p><ul><li>CPU 读某个地址时，QEMU 模拟外设的行为，把数据返回给 CPU</li><li>CPU 写某个地址时，QEMU 获得数据，用来模拟外设的行为。<br>即：要模拟外设备，我们只需要针对外设的地址提供对应的读写函数即可。</li></ul><p>以 GPIO 为例：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211111102930.png"></p><p>QEMU 为<code>GPIO</code>内存地址提供读写回调函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sifive_gpio_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque, hwaddr offset, <span class="hljs-keyword">uint64_t</span> value, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">sifive_gpio_read</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque, hwaddr offset, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span><br></code></pre></td></tr></table></figure><h2 id="给外设地址提供读写函数"><a href="#给外设地址提供读写函数" class="headerlink" title="给外设地址提供读写函数"></a>给外设地址提供读写函数</h2><p>怎么描述某段地址：基地址、大小？如何给这段地址提供读写函数呢？这段地址设置好后，如何添加进<code>system_memory</code>去？有 2 种方法。</p><p><strong>法 1：memory_region_init_io/memory_region_add_subregion</strong><br>以<code>SIFIVE_UART</code>为例，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">memory_region_init_io(&amp;s-&gt;mmio, <span class="hljs-literal">NULL</span>, &amp;uart_ops, s,<br>                        TYPE_SIFIVE_UART, <span class="hljs-number">0x2000</span>);<br>memory_region_add_subregion(address_space, base, &amp;s-&gt;mmio);<br></code></pre></td></tr></table></figure><p><code>memory_region_init_io</code>函数初始化<code>iomem</code>，读写函数，大小。<br><code>memory_region_add_subregion</code>函数<code>s-&gt;iomem</code>指定了基地址，并添加进<code>system_memory</code>中。<br>以后，客户机上的程序读写这块地址时，就会导致对应的读写函数被调用。</p><p><strong>法 2：memory_region_init_io/sysbus_init_mmio/sysbus_mmio_map</strong><br>以<code>SIFIVE_GPIO</code>为例，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">memory_region_init_io(&amp;s-&gt;mmio, OBJECT(dev), &amp;gpio_ops, s, TYPE_SIFIVE_GPIO, SIFIVE_GPIO_SIZE);<br><br>sysbus_init_mmio(SYS_BUS_DEVICE(dev), &amp;s-&gt;mmio);<br></code></pre></td></tr></table></figure><p><code>memory_region_init_io</code>函数初始化<code>iomem</code>，读写函数，大小。<br><code>sysbus_init_mmio</code>将<code>mmin</code>传给设备；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sysbus_mmio_map(SYS_BUS_DEVICE(&amp;s-&gt;gpio), <span class="hljs-number">0</span>, memmap[SIFIVE_E_DEV_GPIO0].base);<br></code></pre></td></tr></table></figure><p><code>sysbus_mmio_map</code>从设备中吧<code>mmio</code>添加进<code>system_memory</code>并指定基地址。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU 源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QEMU</tag>
      
      <tag>GPIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU 源码分析 - 虚拟外设创建</title>
    <link href="/2021/11/09/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9F%E5%A4%96%E8%AE%BE%E5%88%9B%E5%BB%BA/"/>
    <url>/2021/11/09/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9F%E5%A4%96%E8%AE%BE%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="QOM-简介"><a href="#QOM-简介" class="headerlink" title="QOM 简介"></a>QOM 简介</h1><p>QOM(QEMU Object Model) 是 QEMU 的一个模块，用于描述虚拟机的结构，包括虚拟机的 CPU、内存、硬盘、网络、输入输出设备等。QEMU 为了方便整个系统的构建，实现了自己的一套的面向对象机制，也就是 QOM(QEMU Object Model)。它能够方便的表示各个设备（Device）与总线（Bus）之间的关系。</p><p>这个模型主要包含四个结构体：</p><ul><li>Object: 是所有对象的 基类 Base Object</li><li>ObjectClass: 是所有类对象的基类</li><li>TypeInfo：是用户用来定义一个 <code>Type</code> 的工具型的数据结构</li><li>TypeImpl：TypeInfo 抽象数据结构，<code>TypeInfo</code> 的属性与 <code>TypeImpl</code> 的属性对应</li></ul><p>在 QEMU 里要初始化一个对象需要完成四步：</p><ul><li>将 <code>TypeInfo</code> 注册 <code>TypeImpl</code></li><li>实例化 <code>Class</code>（ObjectClass）</li><li>实例化 <code>Object</code></li><li>添加 <code>Property</code></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/15-09-19-4995177f1aeb782fadaf586f8f5c8b32-qemu-QOM%E5%88%86%E6%9E%90.drawio%20-2--1a4eac.png"></p><h1 id="如何描述硬件"><a href="#如何描述硬件" class="headerlink" title="如何描述硬件"></a>如何描述硬件</h1><p>一个板子上有很多硬件：芯片，LED、按键、LCD、触摸屏、网卡等等。芯片里面也有很多部件，比如 CPU、GPIO、SD 控制器、中断控制器等等。</p><p>这些硬件，或是部件，各有不同。怎么描述它们？</p><p>每一个都使用一个 <code>TypeInfo</code> 结构体来描述，<code>TypeInfo</code> 是用户用来定义一个 Type 的工具型的数据结构。它包含了很多成员变量，这些成员合在一起描述了一个设备类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// include/qom/object.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeInfo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *parent;<br>    <span class="hljs-keyword">size_t</span> instance_size;<br>    <span class="hljs-keyword">size_t</span> instance_align;<br>    <span class="hljs-keyword">void</span> (*instance_init)(Object *obj);<br>    <span class="hljs-keyword">void</span> (*instance_post_init)(Object *obj);<br>    <span class="hljs-keyword">void</span> (*instance_finalize)(Object *obj);<br>    <span class="hljs-keyword">bool</span> abstract;<br>    <span class="hljs-keyword">size_t</span> class_size;    <span class="hljs-keyword">void</span> (*class_init)(ObjectClass *klass, <span class="hljs-keyword">void</span> *data);<br>    <span class="hljs-keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="hljs-keyword">void</span> *data);<br>    <span class="hljs-keyword">void</span> *class_data;    InterfaceInfo *interfaces;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个结构体我们在刚刚也提到，他在图里是独立的，在注册的时候会将它的信息都传给 Typeimpl 结构体。</p><p>我们以 Timer 为例，我们要添加一个 Timer 外设，首先就要定义一个 Typeinfo 结构体。他在代码中像这样。我们只看 name，这里用一个宏赋值，这个宏是个我们定义的字符串，它唯一标识了这个硬件。这些结构体在运行时会被注册进程序里，保存在一个链表中备用，为什么是备用，因为不是每一个硬件都会被用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// hw/timer/dw_timer.c</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo dw_timer_info = &#123;<br>    .name          = TYPE_DW_TIMER,<br>    .parent        = TYPE_SYS_BUS_DEVICE,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(DWTimerState),<br>    .instance_init = dw_timer_init,<br>    .class_init    = dw_timer_class_init,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这些结构体在运行时会被注册进程序里，保存在一个链表中备用，为什么是备用，因为不是每一个硬件都会被用到。</p><h1 id="如何注册硬件"><a href="#如何注册硬件" class="headerlink" title="如何注册硬件"></a>如何注册硬件</h1><p>什么是注册，说白了就是将一些可能需要的信息添加到系统中，在系统运行时能够随时调用到。就拿 Timer 来说，现在将一些信息添加到了列表，系统运行起来时我可以随时从链表中取出 Timer 这个设备的信息，用来实例化一个 Timer，但是我没有注册 Timer，也就是没有将其加入到链表，那我后期就无法找到它。</p><p>怎么注册这些<code>TypeInfo</code>结构体呢？在实现的源码中有这个函数 <code>dw_timer_register_types()</code>，他是用来注册 Timer 这个设备的。</p><p>我们追根溯源，调用过程如下，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/16-03-53-4d2fcf4deb7a9ed9c13a22a7fe3111be-20221107160352-084c2a.png"></p><ul><li>分配一个 <code>TypeImpl</code> 结构体，使用 <code>Typeinfo</code> 来设置它</li><li>把 <code>TypeImpl</code> 加入链表：<code>type_table</code></li></ul><p>在 QEMU 里面，有一个全局的哈希表 <code>type_table</code>，用来存放所有定义的类。在 <code>type_new</code> 里面，我们先从全局表里面根据名字 <code>type_table_lookup</code> 查找找这个类。</p><ul><li>如果找到，说明这个类曾经被注册过，就报错；</li><li>如果没有找到，说明这是一个新的类，则将 <code>Typeinfo</code> 里面信息填到 <code>TypeImpl</code> 里面。<code>type_table_add</code> 会将这个类注册到全局的表里面。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/16-11-19-19d9b8686c2a5758a0231181b0fb4dfa-qemu-%E6%B3%A8%E5%86%8C%E8%AE%BE%E5%A4%87.drawio-8a4c5c.png"></p><p>以上的过程可以用上图来表示。<code>Typeinfo</code> 通过 <code>type_new()</code> 生成一个对应的 <code>TypeImpl</code> 类型，并以 <code>name</code> 为关键字添加到名为 <code>type_table</code> 的一个 hash table 中。</p><p>什么时候注册这些设备呢？不需要我们去调用注册函数，以 Timer 为例，在 <code>hw/timer/dw_timer.c</code> 中有如下代码，一般在最后一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">type_init(dw_timer_register_types)<br></code></pre></td></tr></table></figure><p><code>F12</code>找到这个宏定义，我们追根溯源，调用过程如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">type_init()<br>    -&gt; module_init()<br>        -&gt; register_module_init()<br><br>type_init(dw_timer_register_types)<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> type_init(function) module_init(function, MODULE_INIT_QOM)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> module_init(function, type)                                         \</span><br><span class="hljs-meta">static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \</span><br><span class="hljs-meta">&#123;                                                                           \</span><br><span class="hljs-meta">    register_module_init(function, type);                                   \</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register_module_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*fn)(<span class="hljs-keyword">void</span>), module_init_type type)</span></span><br><span class="hljs-function"></span>&#123;<br>    ModuleEntry *e;     <span class="hljs-comment">//构造 ModuleEntry</span><br>    ModuleTypeList *l;  <span class="hljs-comment">//构造链表</span><br><br>    e = g_malloc0(<span class="hljs-keyword">sizeof</span>(*e));<br>    e-&gt;init = fn;       <span class="hljs-comment">//设置初始化函数，fn 即 sifive_gpio_register_types</span><br>    e-&gt;type = type;<br><br>    l = find_type(type);<br><br>    QTAILQ_INSERT_TAIL(l, e, node);<span class="hljs-comment">//将 ModuleEntry 插入链表尾</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>type_init</code>是个宏定义，调用了<code>__attribute__((constructor))</code>函数，我们知道这个 C 语言中位数不多的在<code>main</code>函数执行前，执行的函数。函数中调用了<code>register_module_init</code>注册函数，说明在<code>main</code>函数执行前，已经注册好硬件了。该函数将一个新的<code>ModuleEntry</code>加到链表里。</p><p>注意，注册的只是个函数，并不是注册了设备。也就是已上过程，只是把一个 <code>ModuleEntry</code> 放到了一个链表里，这个 <code>ModuleEntry</code> 带了两个信息，一个是函数，一个是类型。这个函数就是我们真正的注册注册函数。</p><p>已上过程大概是如下所示：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/18-31-54-b5c189903fc73c76057f57a95a10310d-qemu-module%20init%20%E9%93%BE%E8%A1%A8.drawio-1309c1.png"></p><p>那什么时候还真正注册设备呢，我们就得回到主函数，它有以下调用流程，在 <code>module_call_init</code> 中，我们会找到 <code>MODULE_INIT_QOM</code> 这种类型对应的 <code>ModuleTypeList</code><br>找出列表中所有的 <code>ModuleEntry</code>，然后调用每个 <code>ModuleEntry</code> 的 <code>init</code> 函数。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/18-34-25-ad40a288b1376c0f9136c609b7d7ee0c-20221107183424-6d1641.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// softmmu/runstate.c</span><br>module_call_init(MODULE_INIT_QOM);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// utils/module.csoftmmu/runstate.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">module_call_init</span><span class="hljs-params">(module_init_type type)</span></span><br><span class="hljs-function"></span>&#123;<br>    ModuleTypeList *l;<br>    ModuleEntry *e;<br>    <span class="hljs-comment">// 找到 MODULE_INIT_QOM 这种类型对应的 ModuleTypeList</span><br>    l = find_type(type);<br>    QTAILQ_FOREACH(e, l, node) &#123;<br>        e-&gt;init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="初始化设备"><a href="#初始化设备" class="headerlink" title="初始化设备"></a>初始化设备</h1><p>到这里我们需要注意，我们在注册设备的时候虽然将设备从 <code>Typeinfo</code> 变成了 <code>TypeImpl</code>，把 <code>Typeinfo</code> 里的信息都复制到了 <code>TypeImpl</code>，但是 <code>class_init</code> 还没有被调用，也即这个类现在还处于纸面的状态。</p><p>什么时候才真正初始化这个类呢，这得等在用到它的时候。我们在一块板子上才会用到一个设备。我们使用的是 Sifive-e 这个板子，准确来说我们用的不是这个板子，我们只是在原先的代码上做了修改。</p><p>为了方便描述，就当是用的 sifive-e 这个板子。在实现的源码里，有 <code>object_initialize_child</code>函数，跟踪一下调用流程可以看到最后在 <code>type_initialize</code> 函数中初始化了类。同时我们也看到在 <code>object_init_with_type</code> 函数中实例化了类。这个稍后再讲。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// hw/riscv/sifive_e.cstatic void sifive_e_soc_init(Object *obj)</span><br>&#123;<br>    MachineState *ms = MACHINE(qdev_get_machine());<br>    SiFiveESoCState *s = RISCV_E_SOC(obj);<br>.<br>.<br>.    object_initialize_child(obj, <span class="hljs-string">&quot;timer&quot;</span>, &amp;s-&gt;timer,<br>                            TYPE_DW_TIMER);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C">object_initialize_child(obj, name, &amp;s-&gt;timer, TYPE_DW_TIMER);<br>    object_initialize_child_internal()<br>        object_initialize_child_with_props()<br>            object_initialize_child_with_propsv()<br>                object_initialize()<br>                    object_initialize_with_type()<br>                        type_initialize()<br>                        &#123;<br>                            <span class="hljs-keyword">if</span> (ti-&gt;class_init) &#123;<br>                                ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data);<br>                            &#125;<br>                        &#125;<br>                        object_init_with_type()<br>                        &#123;       <br>                            <span class="hljs-keyword">if</span> (ti-&gt;instance_init) &#123;<br>                                ti-&gt;instance_init(obj);<br>                            &#125;<br>                        &#125;<br></code></pre></td></tr></table></figure><p>在调用 <code>class_init</code> 函数时，其实就是调用的设备模块下的 <code>dw_timer_class_init</code>，这个函数中又是一些配置，尤其是 <code>realize</code> 函数的配置。还有一些属性的配置，如 Timer 的频率。</p><p>到这里，我们才有有了一个真正意义上的设备类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C">hw/timer/dw_timer.<span class="hljs-function">c </span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dw_timer_class_init</span><span class="hljs-params">(ObjectClass *klass, <span class="hljs-keyword">void</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 这里又是一些配置，尤其是回调函数的配置</span><br>    DeviceClass *dc = DEVICE_CLASS(klass);<br>    dc-&gt;reset = dw_timer_reset;<br>    <span class="hljs-comment">// 设置 Timer 基本属性如频率等</span><br>    device_class_set_props(dc, dw_timer_properties);<br>    dc-&gt;vmsd = &amp;vmstate_dw_timer;<br>    dc-&gt;realize = dw_timer_realize;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实例化设备"><a href="#实例化设备" class="headerlink" title="实例化设备"></a>实例化设备</h1><p>说白了初始化过程就是在配置各种结构体成员的过程，比如刚刚的初始化过程就是在配置 <code>DeviceClass</code> 这个类的各个成员。实际上我们还没有真正实例化 Timer，我们还不能使用它。</p><p>我们只有在实例化后才能使用它，也就是之前提到的 <code>instance_init()</code>。但是在 QEMU 中要实例化一个设备，不仅仅需要调用 <code>instance_init</code>，还需要调用刚刚初始化时设置的 <code>realize</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo dw_timer_info = &#123;<br>    .name          = TYPE_DW_TIMER,<br>    .parent        = TYPE_SYS_BUS_DEVICE,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(DWTimerState),<br>    .instance_init = dw_timer_init,<br>    .class_init    = dw_timer_class_init,<br>&#125;;<br><span class="hljs-comment">// hw/timer/dw_timer.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dw_timer_init</span><span class="hljs-params">(Object *obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWTimerState *s = DWTIMER(obj);<br>    <span class="hljs-comment">// 为这段内存注册回调函数</span><br>    memory_region_init_io(&amp;s-&gt;iomem, obj, &amp;dw_timer_ops, s,<br>                          <span class="hljs-string">&quot;dw_timer&quot;</span>, <span class="hljs-number">0x2000</span>);<br>    sysbus_init_mmio(SYS_BUS_DEVICE(obj), &amp;s-&gt;iomem);<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数的功能很像，具体细节差异我也还没弄明白，但是需要注意的是 <code>instance_init</code> 一定要在 <code>realize</code> 之前完成，并且没有错误。否则将无法完成实例化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// hw/timer/dw_timer.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dw_timer_realize</span><span class="hljs-params">(DeviceState *dev, Error **errp)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWTimerState *s = DWTIMER(dev);<br>    sysbus_init_irq(SYS_BUS_DEVICE(dev), &amp;s-&gt;irq);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        s-&gt;timer[i] = timer_new_ns(QEMU_CLOCK_VIRTUAL, dw_timer_interrupt, s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>instance_init</code> 这个函数主要完成的工作就是为一段内存绑定了读写函数，为什么要这么做，我们再往下看。</p><h1 id="如何操作设备"><a href="#如何操作设备" class="headerlink" title="如何操作设备"></a>如何操作设备</h1><p>设备创建完成了，那 QEMU 是如何模拟设备的行为的？这也是 QEMU 驱动开发最重要的一步，因为以上的部分是实现设备所必须的，我们只需要参考其他已经实现的模块，修改成我们的信息即可。</p><p>但是每个 IP 的寄存器不同，他们的功能也就不同，这是我们真正需要实现的内容。我们知道写驱动其实就是操作各个 IP 的寄存器，以实现想要的功能。对应到 QEMU 中，就成了在操作各个寄存器时，我们要在 QEMU 中将驱动寄存器的功能先模拟出来，再返回给驱动程序。</p><p>以 Timer 为例我想要获取 <code>TimerNLoadCount</code> 的值，真实硬件有这个寄存器保存了值，但是 QEMU 上我们就得维护一个变量去保存这个值。在需要的时候能读取到。比如代码里比较重要的参数是 <code>offset</code>，这个参数是基于外设基地址的偏移，其实就是寄存器的偏移量。比如我们查看 Timer 的手册，<code>TimerNLoadCount</code> 偏移量为 0，所以当我们在驱动中读取地址为 <code>0x2000000</code> 时，代码就会走到这里，因为我们维护了一个 <code>timer_n_load_count</code> 变量，所以我直接将这个变量当前值返回即可，这就是这个寄存器的值。我们要写这个寄存器也同理，我们需要更新 <code>timer_n_load_count</code> 这个变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hw/timer/dw_timer.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">dw_timer_read</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque, hwaddr offset,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">unsigned</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWTimerState *s = opaque;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">switch</span> (offset) &#123;<br>    <span class="hljs-keyword">case</span> TimerNLoadCount:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>*<span class="hljs-number">0x14</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>*<span class="hljs-number">0x14</span>:<br>        index = offset / <span class="hljs-number">0x14</span>;<br>        <span class="hljs-keyword">return</span> s-&gt;timer_n_load_count[index];<br>.<br>.<br>.<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dw_timer_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque, hwaddr offset,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">uint64_t</span> val64, <span class="hljs-keyword">unsigned</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWTimerState *s = opaque;<br>    <span class="hljs-keyword">uint32_t</span> value = val64;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> change = <span class="hljs-number">0</span>;    <span class="hljs-keyword">switch</span> (offset) &#123;<br>    <span class="hljs-keyword">case</span> TimerNLoadCount:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>*<span class="hljs-number">0x14</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>*<span class="hljs-number">0x14</span>:<br>        index = (offset) / <span class="hljs-number">0x14</span>;<br>        s-&gt;timer_n_load_count[index] = value;<br>        set_alarm_time(s,index);<br>        <span class="hljs-keyword">return</span>;<br>.<br>.<br>.<br>&#125;<br></code></pre></td></tr></table></figure><p>读写函数写好了，需要给谁调用呢。我们刚刚提到了，这是个回调函数，我们需要给一段内存注册这个回调函数。如代码所示。我们给 Timer iomem 绑定了读写函数。具体哪一段地址还没定，但是我们定了 <code>0x2000</code> 这么长一段。我觉得这里应该是最高位的一个寄存器偏移量。因为再高就没啥用了，或者就是 SoC 里定的寄存器空间大小 <code>0x1000</code>。这里应该是为了图省事写的一个值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// hw/timer/dw_timer.c</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> MemoryRegionOps dw_timer_ops = &#123;<br>    .read = dw_timer_read,<br>    .write = dw_timer_write,<br>    .endianness = DEVICE_NATIVE_ENDIAN,<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dw_timer_init</span><span class="hljs-params">(Object *obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWTimerState *s = DWTIMER(obj);<br>    <span class="hljs-comment">// 为这段内存注册回调函数</span><br>    memory_region_init_io(&amp;s-&gt;iomem, obj, &amp;dw_timer_ops, s,<br>                          <span class="hljs-string">&quot;dw_timer&quot;</span>, <span class="hljs-number">0x2000</span>);<br>    sysbus_init_mmio(SYS_BUS_DEVICE(obj), &amp;s-&gt;iomem);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面在<code>hw/riscv/sifive_e.c</code>里会映射寄存器空间到 QEMU 的内存空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// hw/riscv/sifive_e.c</span><br>sysbus_mmio_map(SYS_BUS_DEVICE(&amp;s-&gt;timer), <span class="hljs-number">0</span>, memmap[SIFIVE_E_DEV_TIMER].base);<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/haiyonghao/p/14440761.html">QEMU 中基于 QOM 的 VFIO 类的定义 - EwanHai - 博客园</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU 源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决一台电脑配置两个 GIT 账户</title>
    <link href="/2021/10/30/%E8%A7%A3%E5%86%B3%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E4%B8%A4%E4%B8%AAGIT%E8%B4%A6%E6%88%B7/"/>
    <url>/2021/10/30/%E8%A7%A3%E5%86%B3%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E4%B8%A4%E4%B8%AAGIT%E8%B4%A6%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<p>公司的也在用 git，但是账号和地址肯定都不同，需要配置两个不同的提交环境。</p><h2 id="生成两个-Key"><a href="#生成两个-Key" class="headerlink" title="生成两个 Key"></a>生成两个 Key</h2><h3 id="生成第一个-Key"><a href="#生成第一个-Key" class="headerlink" title="生成第一个 Key"></a>生成第一个 Key</h3><p>如果电脑上已经在用 Git 了就无需重新生成 key，用当前的就可以。key 保存在<code>~/.ssh</code>文件夹内。</p><p>如果第一次使用，就使用以下命令重新生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  .ssh ssh-keygen -t rsa -C home_pc<br>Generating public/private rsa key pair.<br>Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/home/dominic/.ssh/id_rsa): id_rsa_pc<br><br></code></pre></td></tr></table></figure><p><code>home_pc</code>就是个备注名，假设我们这个 key 是平时捣腾 GitHub 玩，用来和 GitHub 同步用的，<code>id_rsa_pc</code>是生成的文件名，打开<code>id_rsa_pc.pub</code>可以看到生成的 key 最后就是备注名（如下）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">ssh<span class="hljs-literal">-rsa</span> AAAAB3NzaC1yc2EAAAADAQABAAABR/Fyj7Pz+e+/////////////////ZbdPGtHB86fLQYh/uR+TKcCERedrDKzGPdVt8= home_pc<br></code></pre></td></tr></table></figure><h3 id="配置-GitHub-SSH"><a href="#配置-GitHub-SSH" class="headerlink" title="配置 GitHub SSH"></a>配置 GitHub SSH</h3><p>路径为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">Github-头像<span class="hljs-literal">-settings</span><span class="hljs-literal">-SSH</span> and GPG keys<span class="hljs-literal">-New</span> SSH key<br></code></pre></td></tr></table></figure><h3 id="测试连通"><a href="#测试连通" class="headerlink" title="测试连通"></a>测试连通</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure><h3 id="生成第二-Key"><a href="#生成第二-Key" class="headerlink" title="生成第二 Key"></a>生成第二 Key</h3><p>这个 key 就打算用来和公司代码同步用，所以备注名换成了<code>work_ubuntu</code>，文件名也换成了<code>id_rsa_work</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  .ssh ssh-keygen -t rsa -C work_ubuntu<br>Generating public/private rsa key pair.<br>Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/home/dominic/.ssh/id_rsa): id_rsa_work<br><br></code></pre></td></tr></table></figure><h3 id="配置公司-SSH"><a href="#配置公司-SSH" class="headerlink" title="配置公司 SSH"></a>配置公司 SSH</h3><p>和 GitHub 类似，根据自己公司使用的平台设置。</p><h2 id="配置本地账户"><a href="#配置本地账户" class="headerlink" title="配置本地账户"></a>配置本地账户</h2><p>因为本地的代码仓库可能是从 GitHub 下载的，也有从公司仓库下载的。那么提交代码时就需要为仓库配置指定的用户名和邮箱。以前只有一个 GitHub，所以配置时使用的是<code>-global</code>参数，任何一个仓库都是配置的相同的用户名与邮箱，而现在需要区分。</p><h3 id="取消全局配置"><a href="#取消全局配置" class="headerlink" title="取消全局配置"></a>取消全局配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-comment"># 取消全局 用户名/邮箱 配置</span><br>git config --global --<span class="hljs-built_in">unset</span> user.name<br>git config --global --<span class="hljs-built_in">unset</span> user.email<br><br><br></code></pre></td></tr></table></figure><h3 id="单独配置代码仓"><a href="#单独配置代码仓" class="headerlink" title="单独配置代码仓"></a>单独配置代码仓</h3><p>进入项目目录，有<code>.git</code>目录的那一级。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 单独设置每个repo 用户名/邮箱</span><br>git config user.email “xxxx@xx.com”<br>git config user.name “xxxx”<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言复杂声明</title>
    <link href="/2021/10/22/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/"/>
    <url>/2021/10/22/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>C 语言常常因为声明的语法问题而受到人们的批评，特别是涉及到函数指针的语法。C 语言的语法力图使声明和使用相一致。对于简单的情况，C 语言的做法是很有效的，但是，如果情况比较复杂，则容易让人混淆，原因在于，C 语言的声明不能从左至右阅读，而且使用了太多的圆括号。<br>在 C 中，声明的形式为（dcl 是 declaration 的简写）：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">dcl: optional *&#x27;s <span class="hljs-built_in">direct</span>-dcl（含有可选<span class="hljs-string">&quot;*&quot;</span>的<span class="hljs-built_in">direct</span>-dcl）<br><span class="hljs-built_in">direct</span>-dcl name<br>            (dcl)<br>            <span class="hljs-built_in">direct</span>-dcl()<br>            <span class="hljs-built_in">direct</span>-dcl[optional size] <br></code></pre></td></tr></table></figure><p>简而言之，声明符<code>dc1</code>(可以理解成间接声明) 就是前面可能带有多个<code>*</code>的<code>direcr-dclo</code>。<code>direct-dcl</code>可以是<code>name</code>、由一对圆括号括起来的<code>dcl</code>、后面跟有一对圆括号的<code>direct-dcl</code>、后面跟有用方括号括起来的表示可选长度的<code>direc-dcl</code>。</p><p>根据该规则进行逆向解析，就可以得到正确的声明。简化一下：<code>TypeName Declarator;</code>其中，<code>Declarator</code>就是声明中的那个<code>name</code>。当你遇到任何你不能理解的声明时，这个法则就是救命稻草。最简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> aInt;<br></code></pre></td></tr></table></figure><p>这里，<code>int</code>是<code>TypeName</code>，<code>aInt</code>是<code>Declarator</code>。</p><p>再说明一下结合紧密度。在声或定义变量时，可以使用一些修饰比如<code>*</code>，<code>[]</code>，<code>()</code>等。<code>()</code>（非函数声明中的<code>()</code>）具有最高的紧密度，其次才是函数和数组的<code>()</code>和<code>[]</code>。</p><p>没有<code>*</code>的声明称为直接声明（<code>direct-dcl</code>），而有<code>*</code>称为声明（<code>dcl</code>）。直接声明要比声明结合的紧。分解声明时，先读出结合紧的。在这里，我把<code>direct-dcl</code>称为更紧的结合，它比<code>dcl</code>结合得紧。</p><p>最后，需要你用英语来读出这个声明。对于<code>[]</code>，应该读成<code>array of</code>。</p><p>对于复杂的定义，可以将其分解。比如<code>T (*p)()</code>可以分解成<code>T D1()</code>，<code>D1</code>读作：*<code>function returning T</code><em>。其中<code>D1</code>是<code>*p</code>。那么该声明应该读成：</em><code>p is a poniter to</code>*。二者合在一起，就变成了 *<code>p is a pointer to function returning T</code>*，即：<code>p</code>是指向返回<code>T</code>类对象的函数的指针。</p><p>再看一个稍微复杂的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">T (*pfa[])();<br></code></pre></td></tr></table></figure><p>根据<code>dcl</code>和<code>direct-dcl</code>，可以分解成<code>T1 D1</code>（因为结合紧密度），<code>T1</code>也就是<code>T ()</code>，那么应该读作：<br>*<code>D1 is function returning T</code>*。</p><p><code>D1</code>又可以写成<code>T2 D2</code>，其中<code>T2</code>是<code>T1 []</code>，可以分解成<code>T1 D2[]</code>，读作：*<code>array of D2 function returning T</code>*。</p><p><code>D2</code>是指针，读作：*<code>pointers to</code><em>。那么整个 <em><code>T (*pfa[])()</code></em> 应该读作：</em><code>pfa is an array of pointers to function returning T</code>*，即：<code>pfa</code>是个存放指向返回 T 类对象函数的指针的数组。</p><p>换种方式看，在这个例子中，<code>pfa</code>是名字，<code>T(*[])()</code>是类型。将<code>(*pfa[])</code>视为一体（<code>direct-dcl</code>），称为<code>D1</code>，那么可以写成<code>T D1()</code>，*<code>function returning object of T</code>*。在<code>D1</code>中，将<code>*pfa</code>视为一体（<code>dcl</code>），称为<code>D2</code>，那么<code>*pfa[]</code>应该是<code>D2[]</code>（direct-dcl），<code>array of D2</code>。合起来就是 *<code>array of D2 function returning object of T</code>*。<code>D2</code>是<code>*pfa</code>（dcl），替换到前面这句话，结果就是 *<code>array of pointers to function returning object of T</code>*。</p><p>有了这些说明，可以试着做一下下面的题，看看自己是否真的理解了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> **argv<br>    <span class="hljs-comment">// argv:  pointer to pointer to char</span><br>    <span class="hljs-comment">// 指向 char 型指针的指针</span><br><span class="hljs-keyword">int</span> (*daytab)[<span class="hljs-number">13</span>]<br>    <span class="hljs-comment">// daytab:  pointer to array[13] of int</span><br>    <span class="hljs-comment">// 指向 int 型数组的指针</span><br><span class="hljs-keyword">int</span> *daytab[<span class="hljs-number">13</span>]<br>    <span class="hljs-comment">// daytab:  array[13] of pointer to int</span><br>    <span class="hljs-comment">// 存放 int 型指针的数组</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">comp</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-comment">// comp: function returning pointer to void</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回值为指向 void 型指针的函数</span></span><br><span class="hljs-function"><span class="hljs-title">void</span> <span class="hljs-params">(*comp)</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-comment">// comp: pointer to function returning void</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 指向返回值为 void 型函数的指针</span></span><br><span class="hljs-function"><span class="hljs-title">char</span> <span class="hljs-params">(*(*x())[])</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-comment">// x: function returning pointer to array[] of</span></span><br><span class="hljs-function">    <span class="hljs-comment">// pointer to function returning char</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回值为 char 型的函数</span></span><br><span class="hljs-function"><span class="hljs-title">char</span> <span class="hljs-params">(*(*x[<span class="hljs-number">3</span>])())</span>[5]</span><br><span class="hljs-function">    <span class="hljs-comment">// x: array[3] of pointer to function returning</span></span><br><span class="hljs-function">    <span class="hljs-comment">// pointer to array[5] of char</span></span><br></code></pre></td></tr></table></figure><p>理解复杂声明可用的“右左法则”：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">int</span> (*<span class="hljs-function"><span class="hljs-keyword">func</span>)<span class="hljs-params">(<span class="hljs-keyword">int</span> *p)</span>;</span><br></code></pre></td></tr></table></figure><p>首先找到变量名<code>func</code>，外面有一对圆括号，而且左边是一个<code>*</code>号，这说明<code>func</code>是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明<code>(*func)</code>是一个函数，所以<code>func</code>是一个指向这类函数的指针，即函数指针，这类函数具有<code>int*</code>类型的形参，返回值类型是<code>int</code>。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">int <span class="hljs-comment">(*func[5])(int *)</span>;<br></code></pre></td></tr></table></figure><p><code>func</code>右边是一个<code>[]</code>运算符，说明<code>func</code>是具有<code>5</code>个元素的数组；<code>func</code>的左边有一个<code>*</code>，说明<code>func</code>的元素是指针（注意这里的<code>*</code>不是修饰<code>func</code>，而是修饰<code>func[5]</code>的，原因是<code>[]</code>运算符优先级比<code>*</code>高，<code>func</code>先跟<code>[]</code>结合）。跳出这个括号，看右边，又遇到圆括号，说明<code>func</code>数组的元素是函数类型的指针，它指向的函数具有<code>int*</code>类型的形参，返回值类型为<code>int</code>。</p><p>在 C++中，规则比 C 要复杂一些。不过，基本思想保持不变，按照 C 的原则来理解复杂的声明，基本上就能满足要求了。没有在这里列出 C++的规则一方面是因为太广，不能覆盖全；另一个原因就是，按照 C 的规则来就足够了，毕竟 C++要与 C 兼容。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言共享内存实现 CyclicBuffer 循环缓冲区</title>
    <link href="/2021/10/21/C%E8%AF%AD%E8%A8%80%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0CyclicBuffer%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    <url>/2021/10/21/C%E8%AF%AD%E8%A8%80%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0CyclicBuffer%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>完整代码详见<a href="https://github.com/Dunky-Z/learning-linux/tree/main/helloworld/c/CyclicBuffer">GitHub CyclicBuffer</a>。</p><h2 id="什么是循环缓冲区"><a href="#什么是循环缓冲区" class="headerlink" title="什么是循环缓冲区"></a>什么是循环缓冲区</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211021171456.gif"></p><p>循环缓冲区通常应用在模块与模块之间的通信，可以减少程序挂起的时间，节省内存空间。</p><p>如图所示，蓝色箭头表示读取指针，红色表示写入指针。写入指针可以在缓冲区有剩余空间时不中断地写入数据，读取指针可以在循环缓冲区有数据时不停读取。</p><h2 id="如何设计循环缓冲区"><a href="#如何设计循环缓冲区" class="headerlink" title="如何设计循环缓冲区"></a>如何设计循环缓冲区</h2><p>为了方便两个进程之间的通信，我们在共享内存中创建循环缓冲区。基本原理如图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211021173628.png"></p><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CyclicBuffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">uint8_t</span> buf[CYCBUFFSIZ];    <span class="hljs-comment">//缓冲区</span><br>    <span class="hljs-keyword">uint8_t</span> read;               <span class="hljs-comment">//读指针</span><br>    <span class="hljs-keyword">uint8_t</span> write;              <span class="hljs-comment">//写指针</span><br>    <span class="hljs-keyword">uint32_t</span> valid_size;        <span class="hljs-comment">//已写入数据数</span><br>&#125; CyCBuf;<br></code></pre></td></tr></table></figure><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cycbuff_write</span><span class="hljs-params">(CyCBuf *cycbuff, <span class="hljs-keyword">uint8_t</span> ch)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (cycbuff_isfull(cycbuff))<br>        ;<br>    cycbuff-&gt;buf[cycbuff-&gt;write] = ch;<br>    cycbuff-&gt;write++;<br>    cycbuff-&gt;write %= CYCBUFFSIZ;<br>    cycbuff-&gt;valid_size++;<br>&#125;<br></code></pre></td></tr></table></figure><p>写入数据前，要检查缓冲区是否已满，如果已满就得挂起等待。直到缓冲区有空间再进行写入。</p><p>写入指针每次写完向后偏移一位，<code>valid_size</code>记录当前缓冲区中有效数据个数。</p><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">cycbuff_read</span><span class="hljs-params">(CyCBuf *cycbuff)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint8_t</span> ch;<br>    <span class="hljs-keyword">while</span> (cycbuff_isempty(cycbuff))<br>        ;<br>    ch = cycbuff-&gt;buf[cycbuff-&gt;read];<br>    cycbuff-&gt;read++;<br>    cycbuff-&gt;read %= CYCBUFFSIZ;<br>    cycbuff-&gt;valid_size--;<br>    <span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取数据前，要检查缓冲区是否为空，如果为空就要挂起等待。</p><h3 id="判断空"><a href="#判断空" class="headerlink" title="判断空"></a>判断空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cycbuff_isempty</span><span class="hljs-params">(CyCBuf *cycbuff)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cycbuff-&gt;valid_size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断满"><a href="#判断满" class="headerlink" title="判断满"></a>判断满</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cycbuff_isfull</span><span class="hljs-params">(CyCBuf *cycbuff)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cycbuff-&gt;valid_size == CYCBUFFSIZ)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本次实验中，为了方便期间，用<code>valid_size</code>保存有效数据个数，没有用读写指针是否重合来判断，这就无需再考虑读写指针重合时，是空还是满。</p><h2 id="数据收发流程"><a href="#数据收发流程" class="headerlink" title="数据收发流程"></a>数据收发流程</h2><h3 id="服务端-写入"><a href="#服务端-写入" class="headerlink" title="服务端 - 写入"></a>服务端 - 写入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(CyCBuf *cycbuff, SHMS *shms)</span></span><br><span class="hljs-function"></span>&#123;<br>    cycbuff_init(cycbuff);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Enter Message: &quot;</span>);<br>        <span class="hljs-keyword">uint8_t</span> ch[BUFFERSIZE];<br>        fgets(ch, BUFFERSIZE, <span class="hljs-built_in">stdin</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; ch[i] != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; i &lt; BUFFERSIZE; i++)<br>        &#123;<br>            cycbuff_write(cycbuff, ch[i]);<br>        &#125;<br>        cycbuff_write(cycbuff, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SHMS *shms</code>为共享内存相关数据，有关共享内存的使用可以参考<a href="https://dunky-z.github.io/2021/08/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88SharedMemory%EF%BC%89/">进程间通信（IPC）之共享内存（SharedMemory）</a>。</p><h3 id="客户端-读取"><a href="#客户端-读取" class="headerlink" title="客户端 - 读取"></a>客户端 - 读取</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">(CyCBuf *cycbuff, SHMS *shms)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server operational: shm id is %d\n&quot;</span>, shms-&gt;shmid);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">uint8_t</span> ch;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Recv Message: &quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            ch = cycbuff_read(cycbuff);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            fflush(<span class="hljs-built_in">stdout</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取数据以回车符为分界，当读到回车符时进行换行处理，并等待接收下一波数据。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211021195237.gif"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Circular_buffer">Circular buffer</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决 gcc 编译后 fflush 失效</title>
    <link href="/2021/10/21/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/"/>
    <url>/2021/10/21/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>使用<code>scanf()</code>获取输入时，因为涉及键盘缓冲区的问题，每次输入后想要把缓冲清空，但是在 gcc 编译后，使用<code>fflush</code>无法清空缓冲区。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>C 标准 (ISO/IEC 9899:1999 standard) 规定<code>fflush(stdin)</code>操作是未定义的&lt;参看《ISO/IEC 9899:1999 standard》p270&gt;;。也就是说不一定能实现刷新功能，但有的编译器可能不遵循标准，对<code>fflush(stdin)</code>操作不予警告，并且有时可能产生正确的结果，但最好不要这样使用。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>通过 <code>while</code> 循环把输入流中的余留数据“吃”掉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> c;<br><span class="hljs-keyword">while</span> ((c=getchar()) != ‘\n’ &amp;&amp; c != EOF);<br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 入门-RVOS 系统引导</title>
    <link href="/2021/10/20/RISC-V%E5%85%A5%E9%97%A8-RVOS%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/"/>
    <url>/2021/10/20/RISC-V%E5%85%A5%E9%97%A8-RVOS%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统定义与分类"><a href="#操作系统定义与分类" class="headerlink" title="操作系统定义与分类"></a>操作系统定义与分类</h2><p>操作系统（英语：Operating System，缩写：OS）是一组系统软件程序，狭义上就是内核如 Linux，广义上就是内核加一组软件组成的发行包，如 Ubuntu，Debian：  </p><p>• 主管并控制计算机操作、运用和运行硬件、软件资源  </p><p>• 提供公共服务来组织用户交互。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816201351.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816201945.png"></p><h2 id="硬件的基本概念"><a href="#硬件的基本概念" class="headerlink" title="硬件的基本概念"></a>硬件的基本概念</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202320868.png"></p><ul><li>Hart</li><li>Platform<br>不能说是个板子，应该理解为芯片。早期的板子就是一块芯片加上各种外设，但是随着技术发展，板子越来越小，外设却并没有变少，是因为外设都被集成到了芯片中。当所有外设都被集成，那么芯片就是 platform。</li><li>SoC(System on Chip)<br>片上系统</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202328649.png"></p><p>QEMU 模拟 virt 这个平台，这个平台有八个 Hart。</p><h2 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202331403.png"></p><p>为了方便访问外设，现在主流的 platform 会对外设的内存地址做一个映射。映射到 platform 的真实物理地址。对真实物理地址进行操作时，就是对外设的地址进行操作。</p><p>物理地址从最低位到最高位都被分配给了各种外设。</p><h2 id="引导过程介绍"><a href="#引导过程介绍" class="headerlink" title="引导过程介绍"></a>引导过程介绍</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202342918.png"></p><p>通电后，会先到箭头所指的地址，这个地址就是对应的 ROM 外设首地址。ROM 相当于一个小硬盘，断电后不会丢失数据。这里面固化了一些指令。</p><p>主要就是跳转指令，运行到 kernel 段继续执行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212317389.png"></p><p>八核同时会执行这个过程。</p><p>以上是硬件的部分过程，软件该如何写？</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212320524.png"></p><p>为了简化学习流程和降低调试难度，目前只支持单核，其余七个核处于空转状态。</p><h3 id="如何判断当前-Hart-是不是第一个？"><a href="#如何判断当前-Hart-是不是第一个？" class="headerlink" title="如何判断当前 Hart 是不是第一个？"></a>如何判断当前 Hart 是不是第一个？</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212323556.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212325328.png"></p><p>这些寄存器必须使用以下的指令读写：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212325081.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212327552.png"></p><p>以上指令就是将寄存器值进行一次<strong>交换</strong>，只不过这个过程是原子性的，不能被打断。</p><p><code>CSRRW</code>经常会用在伪指令<code>CSRW</code>中，完整指令中，第一步向<code>x0</code>写入数据，就是空操作，第二步将<code>rs</code>写入<code>csr</code>。这个伪指令就是完成了一个写入<code>csr</code>的操作。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212333753.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212335906.png"></p><p><code>mhartid</code>就是<code>machine hart id</code>。</p><p>学习以上几个指令，就可以完成判断 hart 是否为第一个的工作了，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212337619.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">csrr t0, mhartid    #读寄存器值<br>mv tp, t0           #<br>bnez t0, park       # 跳转指令，不等于 0 就跳转到 park 标签<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 6502">wfi<br>休眠指令<br></code></pre></td></tr></table></figure><h3 id="如何初始化栈空间"><a href="#如何初始化栈空间" class="headerlink" title="如何初始化栈空间"></a>如何初始化栈空间</h3><h3 id="如何跳转到-C-语言环境"><a href="#如何跳转到-C-语言环境" class="headerlink" title="如何跳转到 C 语言环境"></a>如何跳转到 C 语言环境</h3><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs 6502"># start.S<br>#include &quot;platform.h&quot;<br><br>    # size of each hart&#x27;s stack is 1024 bytes<br>    .equ    STACK_SIZE, 1024<br><br>    .global    _start<br><br>    .text<br>_start:<br>    # park harts with id != 0<br>    csrr    t0, mhartid     # read current hart id<br>    mv      tp, t0          # keep CPU&#x27;s hartid in its tp for later usage.<br>    bnez    t0, park        # if we&#x27;re not on the hart 0<br>                            # we park the hart<br>    # Setup stacks, the stack grows from bottom to top, so we put the<br>    # stack pointer to the very end of the stack range.<br>    slli    t0, t0, 10      # shift left the hart id by 1024<br><br>    ###### 初始化栈空间 ######<br>    # set the initial stack pointer to the end of the first stack space<br>    la      sp, stacks + STACK_SIZE    <br>    # move the current hart stack pointer to its place in the stack space<br>    add     sp, sp, t0       <br>    ###### 初始化栈空间  ######<br>    <br>    ###### 跳转到C语言环境 ######<br>    j       start_kernel     # hart 0 jump to c, start_kernel is the entry point of the kernel<br>    ###### 跳转到C语言环境 ######<br><br>park:<br>    wfi<br>    j    park<br><br>stacks:<br>    # allocate space for all the harts stacks<br>    .skip    STACK_SIZE * MAXNUM_CPU <br>    .end                # End of file<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// kernel.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_kernel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;&#125;; <span class="hljs-comment">// stop here!</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="通过-UART-打印信息"><a href="#通过-UART-打印信息" class="headerlink" title="通过 UART 打印信息"></a>通过 UART 打印信息</h2><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211022171638.png"></p><p>真实的硬件开发是有一个快开发板，但是这个课程里使用的是 QEMU 来模拟开发板的硬件环境。如果要在程序里打印一段信息，正常的情况是在开发板上连接显示器，但是这里是通过将信息用串口传到主机上，然后用主机的屏幕显示信息。</p><p>串口线里是有两根线，负责收信息和发信息。</p><h3 id="UART-特点"><a href="#UART-特点" class="headerlink" title="UART 特点"></a>UART 特点</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211022172156.png"></p><ul><li>并行就是需要多根线，比如有两根线，那么就可以一次发送两位。但是串行节省材料。</li><li>数据通信就会涉及同步的问题，同步的话需要一根时钟线来协商好发送时间和接收时间。而 UART 使用异步，发送的数据不仅仅是真实的数据，还会带有一些标识信息。这些标识可以判断出是收还是发。</li></ul><h3 id="物理接口"><a href="#物理接口" class="headerlink" title="物理接口"></a>物理接口</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252233134.png"></p><h3 id="UART-通讯协议"><a href="#UART-通讯协议" class="headerlink" title="UART 通讯协议"></a>UART 通讯协议</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252235270.png"></p><p>图示中横轴可以表示时间，纵轴表示高低电平。</p><p>在需要发送数据时，会进行“下拉”1bit，1bit 持续的时间就是波特率分之一秒。</p><p>数据在发送过程中可能会受到干扰，会产生畸变，所以需要检验位来判断是否发生畸变。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252246423.png"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252305528.png"></p><p>在软件中，配置 UART 就是配置寄存器的信息。</p><p>在板子上有个元器件叫晶振（crystal），他会产生固定频率的时钟。一种是 1.8432MHZ，一种是 7.3728MHZ。想要获得指定的输出频率就需要对寄存器进行配置。查表可以得到配置信息。比如获得 38.4K 频率的输出，就要配置寄存器值为 3。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252310435.png"></p><p>LCR 寄存器功能比较多，将第 7 位设置为 1 就是用来设置波特率。</p><p>图中<code>DLL</code>和<code>DLM</code>寄存器就是需要配置的寄存器。因为 UART 寄存器都是 8 位的，将值<code>0x0003</code>高位<code>0x00</code>存在<code>DLM</code>中，将低位<code>0x03</code>存入<code>DLL</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Segmentation fault (core dumped)</title>
    <link href="/2021/10/20/%E8%A7%A3%E5%86%B3Segmentation-fault-core-dumped/"/>
    <url>/2021/10/20/%E8%A7%A3%E5%86%B3Segmentation-fault-core-dumped/</url>
    
    <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><p>在使用半导体作为内存的材料前，人类是利用线圈当作内存的材料（发明者为王安），线圈就叫作 <code>core</code> ，用线圈做的内存就叫作 <code>core memory</code>。如今，半导体工业澎勃发展，已经没有人用<code>core memory</code> 了，不过，在许多情况下，人们还是把记忆体叫作 <code>core</code> 。</p><h3 id="Core-dump"><a href="#Core-dump" class="headerlink" title="Core dump"></a>Core dump</h3><p>我们在开发（或使用）一个程序时，最怕的就是程序莫明其妙地宕掉。虽然系统没事，但我们下次仍可能遇到相同的问题。于是这时操作系统就会把程序宕掉时的内存内容 <code>dump</code> 出来（现在通常是写在一个叫 <code>core</code> 的 <code>file</code> 里面），让我们做为参考。这个动作就叫作 <code>core dump</code>。</p><h3 id="如何获取-Core-文件"><a href="#如何获取-Core-文件" class="headerlink" title="如何获取 Core 文件"></a>如何获取 Core 文件</h3><p>1、在一些 Linux 版本下，默认是不产生<code>core</code>文件的，首先可以查看一下系统<code>core</code>文件的大小限制：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>:~/segfault<span class="hljs-symbol">$</span> ulimit -c<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>2、可以看到默认设置情况下，本机 Linux 环境下发生段错误时不会自动生成<code>core</code>文件，下面设置下<code>core</code>文件的大小限制（单位为 KB）：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>:~/segfault<span class="hljs-symbol">$</span> ulimit -c <span class="hljs-number">1024</span><br><span class="hljs-symbol">$</span>:~/segfault<span class="hljs-symbol">$</span> ulimit -c<br><span class="hljs-number">1024</span><br></code></pre></td></tr></table></figure><p>3、重新运行程序，如果发生段错误，就会生成<code>core</code>文件。</p><h2 id="出现段错误的可能原因"><a href="#出现段错误的可能原因" class="headerlink" title="出现段错误的可能原因"></a>出现段错误的可能原因</h2><h3 id="访问不存在的内存地址"><a href="#访问不存在的内存地址" class="headerlink" title="访问不存在的内存地址"></a>访问不存在的内存地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> *ptr = <span class="hljs-literal">NULL</span>;<br>        *ptr = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问系统保护的内存地址"><a href="#访问系统保护的内存地址" class="headerlink" title="访问系统保护的内存地址"></a>访问系统保护的内存地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> *ptr = (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0</span>;<br>        *ptr = <span class="hljs-number">100</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问只读的内存地址"><a href="#访问只读的内存地址" class="headerlink" title="访问只读的内存地址"></a>访问只读的内存地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">char</span> *ptr = <span class="hljs-string">&quot;test&quot;</span>;<br>        <span class="hljs-built_in">strcpy</span>(ptr, <span class="hljs-string">&quot;TEST&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        main();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="段错误信息获取"><a href="#段错误信息获取" class="headerlink" title="段错误信息获取"></a>段错误信息获取</h2><p>程序发生段错误时，提示信息很少，下面有几种查看段错误的发生信息的途径。</p><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>dmesg 可以在应用程序 crash 掉时，显示内核中保存的相关信息。如下所示，通过<code>dmesg</code>命令可以查看发生段错误的程序名称、引起段错误发生的内存地址、指令指针地址、堆栈指针地址、错误代码、错误原因等。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$:~/segfault$ dmesg<br><span class="hljs-selector-attr">[ 2329.479037]</span> segfault3<span class="hljs-selector-attr">[2700]</span>: segfault at <span class="hljs-number">80484</span>e0 ip <span class="hljs-number">00</span>d2906a sp bfbbec3c error <span class="hljs-number">7</span> <span class="hljs-keyword">in</span> libc-<span class="hljs-number">2.10</span>.<span class="hljs-number">1</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-attr">[cb4000+13e000]</span><br></code></pre></td></tr></table></figure><h3 id="g"><a href="#g" class="headerlink" title="-g"></a>-g</h3><p>使用 gcc 编译程序的源码时，加上<code>-g</code>参数，这样可以使得生成的二进制文件中加入可以用于 gdb 调试的有用信息。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>:~/segfault<span class="hljs-symbol">$</span> gcc -g -o segfault3 segfault3.c<br><br></code></pre></td></tr></table></figure><h3 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h3><p>使用 nm 命令列出二进制文件中的符号表，包括符号地址、符号类型、符号名等，这样可以帮助定位在哪里发生了段错误。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs sqf">panfeng@ubuntu:~/segfault$ nm segfault3<br><span class="hljs-number">08049</span>f20 d <span class="hljs-variable">_DYNAMIC</span><br><span class="hljs-number">08049</span>ff4 d <span class="hljs-variable">_GLOBAL_OFFSET_TABLE_</span><br><span class="hljs-number">080484</span>dc R <span class="hljs-variable">_IO_stdin_used</span><br>         w <span class="hljs-variable">_Jv_RegisterClasses</span><br><span class="hljs-number">08049</span>f10 d <span class="hljs-variable">__CTOR_END__</span><br><span class="hljs-number">08049</span>f0c d <span class="hljs-variable">__CTOR_LIST__</span><br><span class="hljs-number">08049</span>f18 D <span class="hljs-variable">__DTOR_END__</span><br><span class="hljs-number">08049</span>f14 d <span class="hljs-variable">__DTOR_LIST__</span><br><span class="hljs-number">080484</span>ec r <span class="hljs-variable">__FRAME_END__</span><br><span class="hljs-number">08049</span>f1c d <span class="hljs-variable">__JCR_END__</span><br><span class="hljs-number">08049</span>f1c d <span class="hljs-variable">__JCR_LIST__</span><br><span class="hljs-number">0804</span>a014 A <span class="hljs-variable">__bss_start</span><br><span class="hljs-number">0804</span>a00c D <span class="hljs-variable">__data_start</span><br><span class="hljs-number">08048490</span> t <span class="hljs-variable">__do_global_ctors_aux</span><br><span class="hljs-number">08048360</span> t <span class="hljs-variable">__do_global_dtors_aux</span><br><span class="hljs-number">0804</span>a010 D <span class="hljs-variable">__dso_handle</span><br>         w <span class="hljs-variable">__gmon_start__</span><br><span class="hljs-number">0804848</span>a T <span class="hljs-variable">__i686</span>.get_pc_thunk.bx<br><span class="hljs-number">08049</span>f0c d <span class="hljs-variable">__init_array_end</span><br><span class="hljs-number">08049</span>f0c d <span class="hljs-variable">__init_array_start</span><br><span class="hljs-number">08048420</span> T <span class="hljs-variable">__libc_csu_fini</span><br><span class="hljs-number">08048430</span> T <span class="hljs-variable">__libc_csu_init</span><br>         U <span class="hljs-variable">__libc_start_main</span>@@GLIBC_2.<span class="hljs-number">0</span><br><span class="hljs-number">0804</span>a014 A <span class="hljs-variable">_edata</span><br><span class="hljs-number">0804</span>a01c A <span class="hljs-variable">_end</span><br><span class="hljs-number">080484</span>bc T <span class="hljs-variable">_fini</span><br><span class="hljs-number">080484</span>d8 R <span class="hljs-variable">_fp_hw</span><br><span class="hljs-number">080482</span>bc T <span class="hljs-variable">_init</span><br><span class="hljs-number">08048330</span> T <span class="hljs-variable">_start</span><br><span class="hljs-number">0804</span>a014 b completed.<span class="hljs-number">6990</span><br><span class="hljs-number">0804</span>a00c W data_start<br><span class="hljs-number">0804</span>a018 b dtor_idx.<span class="hljs-number">6992</span><br><span class="hljs-number">080483</span>c0 t frame_dummy<br><span class="hljs-number">080483</span>e4 T main<br>         U memcpy@@GLIBC_2.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h3><p>使用 ldd 命令查看二进制程序的共享链接库依赖，包括库的名称、起始地址，这样可以确定段错误到底是发生在了自己的程序中还是依赖的共享库中。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">$:~<span class="hljs-regexp">/segfault$ ldd ./</span>segfault3<br>    linux-gate.so.<span class="hljs-number">1</span> =&gt;  (<span class="hljs-number">0</span>x00e08000)<br>    libc.so.<span class="hljs-number">6</span> =&gt; <span class="hljs-regexp">/lib/</span>tls<span class="hljs-regexp">/i686/</span>cmov/libc.so.<span class="hljs-number">6</span> (<span class="hljs-number">0</span>x00675000)<br>    <span class="hljs-regexp">/lib/</span>ld-linux.so.<span class="hljs-number">2</span> (<span class="hljs-number">0</span>x00482000)<br></code></pre></td></tr></table></figure><h2 id="调试方法和技巧"><a href="#调试方法和技巧" class="headerlink" title="调试方法和技巧"></a>调试方法和技巧</h2><h3 id="使用-gcc-和-gdb"><a href="#使用-gcc-和-gdb" class="headerlink" title="使用 gcc 和 gdb"></a>使用 gcc 和 gdb</h3><h4 id="调试流程"><a href="#调试流程" class="headerlink" title="调试流程"></a>调试流程</h4><ol><li>为了能够使用 gdb 调试程序，在编译阶段加上-g 参数，</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>:~/segfault<span class="hljs-symbol">$</span> gcc -g -o segfault3 segfault3.c<br></code></pre></td></tr></table></figure><ol start="2"><li>使用 gdb 命令调试程序：</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$:~<span class="hljs-regexp">/segfault$ gdb -q ./</span>segfault3 <br>Reading symbols <span class="hljs-keyword">from</span> ./segfault3...done.<br>(gdb) <br></code></pre></td></tr></table></figure><ol start="3"><li>进入 gdb 后，运行程序：</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">(gdb) run<br>Starting program: ./segfault3 <br><br>Program received signal SIGSEGV, Segmentation fault.<br><span class="hljs-number">0</span>x001a306a in memcpy () <span class="hljs-keyword">from</span> <span class="hljs-regexp">/lib/</span>tls<span class="hljs-regexp">/i686/</span>cmov/libc.so.<span class="hljs-number">6</span><br>(gdb) <br></code></pre></td></tr></table></figure><p>从输出看出，程序收到<code>SIGSEGV</code>信号，触发段错误，并提示地址<code>0x001a306a</code>、调用 memcpy 报的错，位于<code>/lib/tls/i686/cmov/libc.so.6</code>库中。</p><ol start="4"><li>完成调试后，输入<code>quit</code>命令退出 gdb：</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ol><li><p>仅当能确定程序一定会发生段错误的情况下使用。</p></li><li><p>当程序的源码可以获得的情况下，使用<code>-g</code>参数编译程序。</p></li><li><p>一般用于测试阶段，生产环境下 gdb 会有副作用：使程序运行减慢，运行不够稳定，等等。</p></li><li><p>即使在测试阶段，如果程序过于复杂，gdb 也不能处理。</p></li></ol><h3 id="使用-core-文件和-gdb"><a href="#使用-core-文件和-gdb" class="headerlink" title="使用 core 文件和 gdb"></a>使用 core 文件和 gdb</h3><p>在上节中提到段错误会触发<code>SIGSEGV</code>信号，通过<code>man 7 signal</code>，可以看到<code>SIGSEGV</code>默认的<code>handler</code>会打印段错误出错信息，并产生<code>core</code>文件，由此我们可以借助于程序异常退出时生成的<code>core</code>文件中的调试信息，使用 gdb 工具来调试程序中的段错误。</p><h4 id="调试流程-1"><a href="#调试流程-1" class="headerlink" title="调试流程"></a>调试流程</h4><ol><li>运行有段错误的程序，生成 core 文件。</li><li>gdb 加载 core 文件</li></ol><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">$:~/segfault$ gdb ./segfault3 ./core <br>Reading symbols <span class="hljs-keyword">from</span> /home/panfeng/segfault/segfault3...done.<br><br><span class="hljs-symbol">warning:</span> Can<span class="hljs-comment">&#x27;t read pathname for load map: 输入/输出错误.</span><br>Reading symbols <span class="hljs-keyword">from</span> /<span class="hljs-keyword">lib</span>/tls/i686/cmov/libc.so.<span class="hljs-number">6</span>...(no debugging symbols found)...done.<br>Loaded symbols <span class="hljs-keyword">for</span> /<span class="hljs-keyword">lib</span>/tls/i686/cmov/libc.so.<span class="hljs-number">6</span><br>Reading symbols <span class="hljs-keyword">from</span> /<span class="hljs-keyword">lib</span>/ld-linux.so.<span class="hljs-number">2</span>...(no debugging symbols found)...done.<br>Loaded symbols <span class="hljs-keyword">for</span> /<span class="hljs-keyword">lib</span>/ld-linux.so.<span class="hljs-number">2</span><br>Core was generated <span class="hljs-keyword">by</span> `./segfault3<span class="hljs-comment">&#x27;.</span><br>Program terminated <span class="hljs-keyword">with</span> signal <span class="hljs-number">11</span>, Segmentation fault.<br>#<span class="hljs-number">0</span>  <span class="hljs-number">0</span>x0018506a <span class="hljs-keyword">in</span> memcpy () <span class="hljs-keyword">from</span> /<span class="hljs-keyword">lib</span>/tls/i686/cmov/libc.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>从输出看出，同上节中一样的段错误信息。</p><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ol><li><p>适合于在实际生成环境下调试程序的段错误（即在不用重新发生段错误的情况下重现段错误）。</p></li><li><p>当程序很复杂，core 文件相当大时，该方法不可用。</p></li></ol><h3 id="使用-objdump"><a href="#使用-objdump" class="headerlink" title="使用 objdump"></a>使用 objdump</h3><h4 id="调试流程-2"><a href="#调试流程-2" class="headerlink" title="调试流程"></a>调试流程</h4><ol><li>使用 dmesg 命令，找到最近发生的段错误输出信息：</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$:~<span class="hljs-string">/segfault</span>$ dmesg<br><span class="hljs-string">...</span> <span class="hljs-string">...</span><br>[17257.502808] segfault3[3320]: segfault at 80484e0 ip 0018506a sp bfc1<span class="hljs-keyword">cd</span>6c error 7 in libc-2.10.1.so[110000+13e000]<br></code></pre></td></tr></table></figure><p>其中，对我们接下来的调试过程有用的是发生段错误的地址：<code>80484e0</code>和指令指针地址：<code>0018506a</code>。</p><ol start="2"><li>使用<code>objdump</code>生成二进制的相关信息，重定向到文件中：</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$:~<span class="hljs-regexp">/segfault$ objdump -d ./</span>segfault3 &gt; segfault3Dump<br></code></pre></td></tr></table></figure><p>其中，生成的<code>segfault3Dump</code>文件中包含了二进制文件的<code>segfault3</code>的汇编代码。</p><ol start="3"><li>在<code>segfault3Dump</code>文件中查找发生段错误的地址：</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">panfeng</span>@ubuntu:~/segfault$ grep -n -A <span class="hljs-number">10</span> -B <span class="hljs-number">10</span> <span class="hljs-string">&quot;80484e0&quot;</span> ./segfault<span class="hljs-number">3</span>Dump <br><span class="hljs-attribute">121</span>- <span class="hljs-number">80483</span>df:    ff d<span class="hljs-number">0</span>                    call   *%eax<br><span class="hljs-attribute">122</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">1</span>:    c<span class="hljs-number">9</span>                       leave  <br><span class="hljs-attribute">123</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">2</span>:    c<span class="hljs-number">3</span>                       ret    <br><span class="hljs-attribute">124</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">3</span>:    <span class="hljs-number">90</span>                       nop<br><span class="hljs-attribute">125</span>-<br><span class="hljs-attribute">126</span>-<span class="hljs-number">080483</span>e<span class="hljs-number">4</span> &lt;main&gt;:<br><span class="hljs-attribute">127</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">4</span>:    <span class="hljs-number">55</span>                       push   %ebp<br><span class="hljs-attribute">128</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">5</span>:    <span class="hljs-number">89</span> e<span class="hljs-number">5</span>                    mov    %esp,%ebp<br><span class="hljs-attribute">129</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">7</span>:    <span class="hljs-number">83</span> e<span class="hljs-number">4</span> f<span class="hljs-number">0</span>                 and    $<span class="hljs-number">0</span>xfffffff<span class="hljs-number">0</span>,%esp<br><span class="hljs-attribute">130</span>- <span class="hljs-number">80483</span>ea:    <span class="hljs-number">83</span> ec <span class="hljs-number">20</span>                 sub    $<span class="hljs-number">0</span>x<span class="hljs-number">20</span>,%esp<br><span class="hljs-attribute">131</span>: <span class="hljs-number">80483</span>ed:    c<span class="hljs-number">7</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">1</span>c e<span class="hljs-number">0</span> <span class="hljs-number">84</span> <span class="hljs-number">04</span>     movl   $<span class="hljs-number">0</span>x<span class="hljs-number">80484</span>e<span class="hljs-number">0</span>,<span class="hljs-number">0</span>x<span class="hljs-number">1</span>c(%esp)<br><span class="hljs-attribute">132</span>- <span class="hljs-number">80483</span>f<span class="hljs-number">4</span>:    <span class="hljs-number">08</span> <br><span class="hljs-attribute">133</span>- <span class="hljs-number">80483</span>f<span class="hljs-number">5</span>:    b<span class="hljs-number">8</span> e<span class="hljs-number">5</span> <span class="hljs-number">84</span> <span class="hljs-number">04</span> <span class="hljs-number">08</span>           mov    $<span class="hljs-number">0</span>x<span class="hljs-number">80484</span>e<span class="hljs-number">5</span>,%eax<br><span class="hljs-attribute">134</span>- <span class="hljs-number">80483</span>fa:    c<span class="hljs-number">7</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>     movl   $<span class="hljs-number">0</span>x<span class="hljs-number">5</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%esp)<br><span class="hljs-attribute">135</span>- <span class="hljs-number">8048401</span>:    <span class="hljs-number">00</span> <br><span class="hljs-attribute">136</span>- <span class="hljs-number">8048402</span>:    <span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">04</span>              mov    %eax,<span class="hljs-number">0</span>x<span class="hljs-number">4</span>(%esp)<br><span class="hljs-attribute">137</span>- <span class="hljs-number">8048406</span>:    <span class="hljs-number">8</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">1</span>c              mov    <span class="hljs-number">0</span>x<span class="hljs-number">1</span>c(%esp),%eax<br><span class="hljs-attribute">138</span>- <span class="hljs-number">804840</span>a:    <span class="hljs-number">89</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span>                 mov    %eax,(%esp)<br><span class="hljs-attribute">139</span>- <span class="hljs-number">804840</span>d:    e<span class="hljs-number">8</span> <span class="hljs-number">0</span>a ff ff ff           call   <span class="hljs-number">804831</span>c &lt;memcpy@plt&gt;<br><span class="hljs-attribute">140</span>- <span class="hljs-number">8048412</span>:    c<span class="hljs-number">9</span>                       leave  <br><span class="hljs-attribute">141</span>- <span class="hljs-number">8048413</span>:    c<span class="hljs-number">3</span>                       ret    <br></code></pre></td></tr></table></figure><p>通过对以上汇编代码分析，得知段错误发生<code>main</code>函数，对应的汇编指令是<code>movl $0x80484e0,0x1c(%esp)</code>，接下来打开程序的源码，找到汇编指令对应的源码，也就定位到段错误了。</p><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ol><li>不需要<code>-g</code>参数编译，不需要借助于<code>core</code>文件，但需要有一定的汇编语言基础。</li></ol><p>2、如果使用了 gcc 编译优化参数（-O1，-O2，-O3）的话，生成的汇编指令将会被优化，使得调试过程有些难度。</p><h3 id="使用-catchsegv"><a href="#使用-catchsegv" class="headerlink" title="使用 catchsegv"></a>使用 catchsegv</h3><p><code>catchsegv</code>命令专门用来扑获段错误，它通过动态加载器（ld-linux.so）的预加载机制（PRELOAD）把一个事先写好的库（/lib/libSegFault.so）加载上，用于捕捉断错误的出错信息。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$:~/segfault$ catchsegv ./segfault3<br>Segmentation fault (core dumped)<br>*** Segmentation fault<br>Register dump:<br><br> EAX: <span class="hljs-number">00000000</span>   EBX: <span class="hljs-number">00fb3ff4</span>   ECX: <span class="hljs-number">00000002</span>   EDX: <span class="hljs-number">00000000</span><br> ESI: <span class="hljs-number">080484e5</span>   EDI: <span class="hljs-number">080484e0</span>   EBP: bfb7ad38   ESP: bfb7ad0c<br><br> EIP: <span class="hljs-number">00ee806a</span>   EFLAGS: <span class="hljs-number">00010203</span><br><br> CS: <span class="hljs-number">0073</span>   DS: <span class="hljs-number">007b</span>   ES: <span class="hljs-number">007b</span>   FS: <span class="hljs-number">0000</span>   GS: <span class="hljs-number">0033</span>   SS: <span class="hljs-number">007b</span><br><br> Trap: <span class="hljs-number">0000000e</span>   Error: <span class="hljs-number">00000007</span>   OldMask: <span class="hljs-number">00000000</span><br> ESP/signal: bfb7ad0c   CR2: <span class="hljs-number">080484e0</span><br><br>Backtrace:<br>/lib/libSegFault.so[<span class="hljs-number">0x3b606f</span>]<br>??:<span class="hljs-number">0</span>(??)[<span class="hljs-number">0xc76400</span>]<br>/lib/tls/i686/cmov/libc.so<span class="hljs-number">.6</span>(__libc_start_main+<span class="hljs-number">0xe6</span>)[<span class="hljs-number">0xe89b56</span>]<br>/build/buildd/eglibc-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>/csu/../sysdeps/i386/elf/start.S:<span class="hljs-number">122</span>(_start)[<span class="hljs-number">0x8048351</span>]<br><br>Memory <span class="hljs-built_in">map</span>:<br><br><span class="hljs-number">00258000</span>-<span class="hljs-number">00273000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">157</span> /lib/ld-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00273000</span>-<span class="hljs-number">00274000</span> r--p <span class="hljs-number">0001a000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">157</span> /lib/ld-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00274000</span>-<span class="hljs-number">00275000</span> rw-p <span class="hljs-number">0001b000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">157</span> /lib/ld-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">003b4000</span>-<span class="hljs-number">003b7000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">13105</span> /lib/libSegFault.so<br><span class="hljs-number">003b7000</span>-<span class="hljs-number">003b8000</span> r--p <span class="hljs-number">00002000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">13105</span> /lib/libSegFault.so<br><span class="hljs-number">003b8000</span>-<span class="hljs-number">003b9000</span> rw-p <span class="hljs-number">00003000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">13105</span> /lib/libSegFault.so<br><span class="hljs-number">00c76000</span>-<span class="hljs-number">00c77000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> [vdso]<br><span class="hljs-number">00e0d000</span>-<span class="hljs-number">00e29000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">4817</span> /lib/libgcc_s.so<span class="hljs-number">.1</span><br><span class="hljs-number">00e29000</span>-<span class="hljs-number">00e2a000</span> r--p <span class="hljs-number">0001b000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">4817</span> /lib/libgcc_s.so<span class="hljs-number">.1</span><br><span class="hljs-number">00e2a000</span>-<span class="hljs-number">00e2b000</span> rw-p <span class="hljs-number">0001c000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">4817</span> /lib/libgcc_s.so<span class="hljs-number">.1</span><br><span class="hljs-number">00e73000</span>-<span class="hljs-number">00fb1000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">1800</span> /lib/tls/i686/cmov/libc-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00fb1000</span>-<span class="hljs-number">00fb2000</span> ---p <span class="hljs-number">0013e000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">1800</span> /lib/tls/i686/cmov/libc-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00fb2000</span>-<span class="hljs-number">00fb4000</span> r--p <span class="hljs-number">0013e000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">1800</span> /lib/tls/i686/cmov/libc-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00fb4000</span>-<span class="hljs-number">00fb5000</span> rw-p <span class="hljs-number">00140000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">1800</span> /lib/tls/i686/cmov/libc-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00fb5000</span>-<span class="hljs-number">00fb8000</span> rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">303895</span> /home/segfault/segfault3<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">303895</span> /home/segfault/segfault3<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">303895</span> /home/segfault/segfault3<br><span class="hljs-number">09432000</span>-<span class="hljs-number">09457000</span> rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> [heap]<br>b78cf000-b78d1000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b78df000-b78e1000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>bfb67000-bfb7c000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> [stack]<br></code></pre></td></tr></table></figure><h2 id="如何避免段错误"><a href="#如何避免段错误" class="headerlink" title="如何避免段错误"></a>如何避免段错误</h2><ol><li><p>出现段错误时，首先应该想到段错误的定义，从它出发考虑引发错误的原因。</p></li><li><p>在使用指针时，定义了指针后记得初始化指针，在使用的时候记得判断是否为 NULL。</p></li><li><p>在使用数组时，注意数组是否被初始化，数组下标是否越界，数组元素是否存在等。</p></li><li><p>在访问变量时，注意变量所占地址空间是否已经被程序释放掉。</p></li><li><p>在处理变量时，注意变量的格式控制是否合理等。</p></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 入门-RISC-V 汇编语言编程</title>
    <link href="/2021/10/16/RISC-V%E5%85%A5%E9%97%A8-RISC-V%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/10/16/RISC-V%E5%85%A5%E9%97%A8-RISC-V%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="汇编语法介绍"><a href="#汇编语法介绍" class="headerlink" title="汇编语法介绍"></a>汇编语法介绍</h2><p>一条典型的 RISC-V 汇编语句由三个部分组成<code>[label:][operation][comment]</code>。<br>后缀<code>.s</code>和<code>.S</code>区别：后者纯汇编。</p><ul><li>label(标号)</li><li>operation 可以有以下多种类型：<ul><li>instruction (指令) ：直接对应二进制机器指令的宇符串</li><li>pseudo-instruction (伪指令) ：为了提高编写代码的效率，可以用一条伪指令指示汇编器产生多条实际的指令 (instructions)。</li><li>directive (指示/伪操作) ：通过类似指令的形式(以”.”开头),通知汇编器如何控制代码的产生等，不对应具体的指令。</li><li>macro：采用.macro/.endm 自定义的宏<br>例子</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">.macro do_nothing  # directive<br>  nop    # pseudo-instruction<br>  nop    # pseudo-instruction<br>.endm      # directive<br><br>  .text    # directive<br>  .global _start  # directive<br>_start:     # Label<br>  li x6, 5  # pseudo-instruction<br>  li x7, 4  # pseudo-instruction<br>  add x5, x6, x7  # instruction<br>  do_nothing  # Calling macro<br>stop:  j stop    # statement in one line<br><br>  .end    # End of file<br></code></pre></td></tr></table></figure><ul><li>comment（注释）以<code>#</code>开头到行尾</li></ul><h2 id="RISC-V-汇编指令总览"><a href="#RISC-V-汇编指令总览" class="headerlink" title="RISC-V 汇编指令总览"></a>RISC-V 汇编指令总览</h2><h3 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h3><ul><li>寄存器<ul><li>32个通用寄存器,<code>x0 ~ x31</code>（注意：本章节课程仅涉及RV32I的通用寄存器组）；</li><li>在 RISC-V 中，Hart 在执行算术逻辑运算时所操作的数据必须直接来自寄存器。</li></ul></li><li>内存<ul><li>Hart可以执行在寄存器和内存之间的数据读写操作；</li><li>读写操作使用字节 (Byte) 为基本单位进行寻址；</li><li>RV32可以访问最多<code>2^32</code>个字节的内存空间。</li></ul></li></ul><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826142737.png"></p><p>指令长度：32bit，本文讨论的都是 RV32 指令集</p><p>指令对齐：指令加载到内存是以 32bit 对齐</p><p><code>funct3</code>、<code>funct7</code>和<code>opcode</code>一起决定指令类型，<code>funct3</code>表示占 3bit，<code>funct7</code>占 7bit。</p><p><code>opcode</code>映射关系：</p><ul><li>[1:0] 永远为 11</li><li>[4:2] 为下图横轴</li><li>[6:5] 为下图纵轴，三部分决定指令的类型。</li></ul><p>以<code>BEQ</code>指令为例<code>opcode=1100011</code>。<code>[4:2]=000</code>，<code>[6:5]=11</code>查表可得<code>BEQ</code>指令类型为<code>BRANCH</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220811194125.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220811194216.png" alt="The RISC-V Instruction Set Manual"></p><h4 id="小端序"><a href="#小端序" class="headerlink" title="小端序"></a>小端序</h4><ul><li>主机字节序 (HBO-Host Byte Order)</li><li>一个多字节整数在计算机内存中存储的字节顺序称主机字节序 (HBO- Host Byte Order，或者叫本地字节序)</li><li>不同类型 CPU 的 HBO 不同，这与 CPU 的设计有关。分为大端序 (Big-Endian) 和小端序 (Little-Endian)</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826144713.png"></p><h4 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220811195352.png"></p><p><code>rd</code>（register destination）目标寄存器，<code>rs</code>（register source）源寄存器，大小都是 5bit，因为可以表示<code>2^5=32</code>寄存器。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220811195422.png"></p><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>算数指令只包含加减，不包含乘除，乘除运算有专门的扩展。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108262335167.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108262343942.png"></p><p>数据传送顺序是由后向前，和正常的编码习惯类似。</p><h4 id="SUB-Substract"><a href="#SUB-Substract" class="headerlink" title="SUB Substract"></a>SUB Substract</h4><p><strong>练习</strong></p><p>现知道某条 RISC-V 的机器指令在内存中的值为<code>b3 05 95 00</code>,从左往右为从低地址到高地址，单位为字节，请将其翻译为对应的汇编指令。</p><ul><li>确定字节序<br>在 RISC-V 中存放是小端序，根据题意真正指令应该是<code>00 95 05 b3</code></li><li>转换二进制<br>机器码是二进制，所以需要将上述指令值转换为二进制，可得<code>0000000 01001 01010 000 01011 0110011</code></li><li>查阅手册<br>查阅<code>The RISC-V Instruction Set Manual Volume I: Unprivileged ISA</code>找到<code>RV32/64G Instruction Set Listings</code>指令表格，低 7 位是<code>opcode</code>，查表可得<code>0110011</code>对应操作码有多个<code>SLLI SRAI SUB</code>等等，此时再看最高位<code>00000000</code>,可以确定是<code>ADD</code>指令</li><li>将分割的二进制转成十进制<br><code>0000000 9 10 000 11 010011</code>-&gt;<code>ADD x11 x10 x9</code></li></ul><h4 id="ADDI-ADD-Immediate"><a href="#ADDI-ADD-Immediate" class="headerlink" title="ADDI ADD Immediate"></a>ADDI ADD Immediate</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918102935.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104115.png"></p><h4 id="LUI-Load-Upper-Immediate"><a href="#LUI-Load-Upper-Immediate" class="headerlink" title="LUI Load Upper Immediate"></a>LUI Load Upper Immediate</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104625.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104556.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104911.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104929.png"></p><h4 id="LI"><a href="#LI" class="headerlink" title="LI"></a>LI</h4><p><img src="https://secure2.wostatic.cn/static/j4jbakqQTGuyjHGDqXsnAf/image.png"></p><h4 id="AUIPC"><a href="#AUIPC" class="headerlink" title="AUIPC"></a>AUIPC</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816133111.png"></p><p>经常用于构造一个相对地址。</p><h4 id="LA"><a href="#LA" class="headerlink" title="LA"></a>LA</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816133406.png"></p><h4 id="基于算术运算指令实现的其他伪指令"><a href="#基于算术运算指令实现的其他伪指令" class="headerlink" title="基于算术运算指令实现的其他伪指令"></a>基于算术运算指令实现的其他伪指令</h4><p><code>x0</code>寄存器具有特殊含义，往里写数据没有意义<br><code>NOP</code>指令主要为了占位，空转</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918103237.png"></p><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816133744.png"></p><h4 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h4><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 6502">10101010<br>11111111(-1)<br>--------  XOR<br>01010101<br></code></pre></td></tr></table></figure><h3 id="移位运算指令"><a href="#移位运算指令" class="headerlink" title="移位运算指令"></a>移位运算指令</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816134208.png"></p><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><p>只有右移，没有左移。左移会把最高位覆盖。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816134425.png"></p><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 6502">10001000 &gt;&gt; 2<br>= 11100001<br></code></pre></td></tr></table></figure><h3 id="内存读写指令"><a href="#内存读写指令" class="headerlink" title="内存读写指令"></a>内存读写指令</h3><p>加载，内存读，将数据从内存读入寄存器</p><p>Store，内存写，将数据从寄存器写出到内存</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816134941.png"></p><blockquote><p>为何对 word 的 加载 不区分无符号和有符号方式 (RV32)？RV32 下寄存器是 4 字节，加载 word 也是 4 字节，自然不需要扩展。</p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816135526.png"></p><blockquote><p>为何 store 不区分有符号还是无符号？因为从目的地址只有 1 字节，不管是写 1 字节，2 字节，还是 4 字节，都只用到最低的 1 字节。不需要考虑符号</p></blockquote><blockquote><p>立即数分两个地方存，为了解码效率</p></blockquote><h3 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211008115038.png"></p><p>指令格式中的立即数 (imm) 存放有些奇怪，第 [1-4] 位和第 [11] 位放在一起，第 [5-10] 位和第 [12] 位放在一起。这是为了迎合硬件处理效率，编程时不需要考虑立即数存储方式。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816145400.png"></p><h3 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816152941.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816152959.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816153100.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  a = a+b;<br>  <span class="hljs-keyword">return</span>;   <span class="hljs-comment">// jalr x0 0(x5)  当前指令的下一条指令存到x0中，并跳转到（0 + x5)，也就是sum的下一条指令</span><br>&#125;<br><br><span class="hljs-keyword">void</span> _start()<br>&#123;<br>  sum(); <span class="hljs-comment">// jal x5 sum  把sum的下一条指令存到x5，然后跳转到sum</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如何解决长距离跳转？使用 AUIPC 来构建一个大数，配合 JALR 使用。如  auipc x6,imm-20  jalr x1,x6,imm-12</p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816162732.png"></p><h2 id="RISC-V-指令寻址模式总结"><a href="#RISC-V-指令寻址模式总结" class="headerlink" title="RISC-V 指令寻址模式总结"></a>RISC-V 指令寻址模式总结</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220816162913.png"></p><h2 id="汇编函数调用约定"><a href="#汇编函数调用约定" class="headerlink" title="汇编函数调用约定"></a>汇编函数调用约定</h2><h3 id="函数调用过程概述"><a href="#函数调用过程概述" class="headerlink" title="函数调用过程概述"></a>函数调用过程概述</h3><p>栈（stack）数据结构，在函数调用过程中会用来保存变量，函数地址等等。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162130267.png"></p><p>栈帧里保存的变量是自动变量，会被内存自动释放。</p><p>为何要有调用者与被调用者保存的概念</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162137133.png"></p><p>函数调用过程中就会有参数和返回值的传递，自己写的函数可能由别人来调用，如果没有约定好某个参数存放位置，就不能够顺利执行函数。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162144447.png"></p><p>因为寄存器需要经常在编程中使用，所以 ABI 名就是寄存器的别名。</p><blockquote><p>这些寄存器其实都可以设置成被调用者保存，也就是在被调用函数中保存一遍为啥还要分这么多<br>答：因为保存一遍效率低</p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162209273.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162217164.gif"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162234551.png"></p><h4 id="尾调用实例"><a href="#尾调用实例" class="headerlink" title="尾调用实例"></a>尾调用实例</h4><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs 6502"># Calling Convention<br># Demo to create a leaf routine<br>#<br># void _start()<br># &#123;<br>#     // calling leaf routine<br>#     square(3);<br># &#125;<br>#<br># int square(int num)<br># &#123;<br>#     return num * num;<br># &#125;<br><br>  .text        # Define beginning of text section<br>  .global  _start    # Define entry _start<br><br>_start:<br>  la sp, stack_end  # prepare stack for calling functions<br><br>  li a0, 3      # pass 3 to square<br>  call square     # call square<br><br>  # the time return here, a0 should stores the result<br>stop:<br>  j stop        # Infinite loop to stop execution<br><br># int square(int num)<br>square:<br>  # prologue<br>  addi sp, sp, -8     # reserve space for local variables<br>  sw s0, 0(sp)     # save s0<br>  sw s1, 4(sp)      # save s1<br><br>  # `mul a0, a0, a0` should be fine,<br>  # programing as below just to demo we can contine use the stack<br>  mv s0, a0           # s0 = a0<br>  mul s1, s0, s0      # s1 = s0 * s0<br>  mv a0, s1        # a0 = s1<br><br>  # epilogue<br>  lw s0, 0(sp)      # restore s0<br>  lw s1, 4(sp)     # restore s1<br>  addi sp, sp, 8      # release space for local variables<br>  <br>  ret          # return from function<br><br>  # add nop here just for demo in gdb<br>  nop <br><br>  # allocate stack space<br>stack_start:<br>  .rept 10     # reserve 10 words for stack<br>  .word 0     # fill with 0<br>  .endr        # end of repeat<br>stack_end: <br><br>  .end      # End of file<br><br><br><br></code></pre></td></tr></table></figure><h4 id="非尾调用实例"><a href="#非尾调用实例" class="headerlink" title="非尾调用实例"></a>非尾调用实例</h4><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs 6502"># Calling Convention<br># Demo how to write nested routines<br>#<br># void _start()<br># &#123;<br>#     // calling nested routine<br>#     aa_bb(3, 4);<br># &#125;<br>#<br># int aa_bb(int a, int b)<br># &#123;<br>#     return square(a) + square(b);<br># &#125;<br>#<br># int square(int num)<br># &#123;<br>#     return num * num;<br># &#125;<br><br>  .text        # Define beginning of text section<br>  .global  _start    # Define entry _start<br><br>_start:<br>  la sp, stack_end  # prepare stack for calling functions<br><br>  # aa_bb(3, 4);<br>  li a0, 3      # load argument a<br>  li a1, 4      # load argument b<br>  call aa_bb       # call aa_bb<br><br>stop:<br>  j stop      # Infinite loop to stop execution<br><br># int aa_bb(int a, int b)<br># return a^2 + b^2<br>aa_bb:<br>  # prologue<br>  addi sp, sp, -16  # decrement stack pointer by 16 bytes<br>  sw s0, 0(sp)    # save s0<br>  sw s1, 4(sp)    # save s1<br>  sw s2, 8(sp)    # save s2<br>  sw ra, 12(sp)    # save ra<br>  <br>  # cp and store the input params<br>  mv s0, a0      # copy a to s0<br>  mv s1, a1      # copy b to s1<br><br>  # sum will be stored in s2 and is initialized as zero<br>  li s2, 0      # initialize s2 to zero<br><br>  mv a0, s0      # copy s0 to a0<br>  jal square      # call square<br>  add s2, s2, a0    # add a0 to s2<br>  <br>  mv a0, s1      # copy s1 to a0<br>  jal square      # call square<br>  add s2, s2, a0    # add a0 to s2<br>  <br>  mv a0, s2      # copy s2 to a0<br><br>  # epilogue<br>  lw s0, 0(sp)    # restore s0<br>  lw s1, 4(sp)    # restore s1    <br>  lw s2, 8(sp)    # restore s2<br>  lw ra, 12(sp)    # restore ra<br>  addi sp, sp, 16    # increment stack pointer by 16 bytes<br>  ret          # return from aa_bb<br><br># int square(int num)<br>square:<br>  # prologue<br>  addi sp, sp, -8    # decrement stack pointer by 8 bytes<br>  sw s0, 0(sp)    # save s0<br>  sw s1, 4(sp)    # save s1<br><br>  # `mul a0, a0, a0` should be fine,<br>  # programing as below just to demo we can contine use the stack<br>  mv s0, a0      # copy a to s0<br>  mul s1, s0, s0    # s1 = a * a<br>  mv a0, s1      # copy s1 to a0<br><br>  # epilogue<br>  lw s0, 0(sp)    # restore s0      <br>  lw s1, 4(sp)    # restore s1<br>  addi sp, sp, 8    # increment stack pointer by 8 bytes<br>  <br>  ret          # return from square<br>  <br>  # add nop here just for demo in gdb<br>  nop            <br><br>  # allocate stack space<br>stack_start:<br>  .rept 10      # allocate 10 words of stack space<br>  .word 0        # initialize stack space to 0<br>  .endr        # end of stack allocation<br>stack_end:<br>  .end      # End of file<br><br></code></pre></td></tr></table></figure><h2 id="汇编与-C-混合编程"><a href="#汇编与-C-混合编程" class="headerlink" title="汇编与 C 混合编程"></a>汇编与 C 混合编程</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>遵守 ABI（Abstract Binary Interface）的规定</p><ul><li>数据类型大小，布局，对齐</li><li>函数调用约定</li><li>系统调用约定<br>等等</li></ul><p>RISC-V 函数调用约定规定</p><ul><li>函数参数采用寄存器<code>a0-a7</code></li><li>函数返回值采用寄存器<code>a0,a1</code></li></ul><h3 id="汇编嵌入-C-语言"><a href="#汇编嵌入-C-语言" class="headerlink" title="汇编嵌入 C 语言"></a>汇编嵌入 C 语言</h3><figure class="highlight plaintext"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs 6502"># ASM call C<br><br>  .text      # Define beginning of text section<br>  .global  _start    # Define entry _start<br>  .global  foo    # foo is a C function defined in test.c<br><br>_start:<br>  la sp, stack_end  # prepare stack for calling functions<br><br>  # RISC-V uses a0 ~ a7 to transfer parameters<br>  li a0, 1<br>  li a1, 2<br>  call foo    #调用了C语言函数<br>  # RISC-V uses a0 &amp; a1 to transfer return value<br>  # check value of a0<br><br>stop:<br>  j stop      # Infinite loop to stop execution<br><br>  nop      # just for demo effect<br><br>stack_start:<br>  .rept 10<br>  .word 0<br>  .endr<br>stack_end:<br><br>  .end      # End of file<br><br></code></pre></td></tr></table></figure><p><code>call foo</code>就是在调用 C 语言函数，<code>foo</code>。<br><code>.global foo</code>告诉编译器<code>foo</code>函数定义在外面。</p><h3 id="C-语言嵌入汇编"><a href="#C-语言嵌入汇编" class="headerlink" title="C 语言嵌入汇编"></a>C 语言嵌入汇编</h3><p>下图中为简化写法</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162347033.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162342119.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言可变参数</title>
    <link href="/2021/10/12/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <url>/2021/10/12/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>学习过程中查看了<code>printf()</code>源码，遇到了这样的函数定义，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fmt, ...)</span></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br>    va_list args;<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>    va_start(args, fmt);<br>    vsprint(buf, fmt, args);<br>    va_end(args);<br>    <br>    <span class="hljs-built_in">puts</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>参数中的三个点号，就是 C 语言中可变参数的标识。这样的函数称为可变参数函数。这种函数需要固定数量的<strong>强制参数</strong>（mandatory argument），后面是<strong>数量可变的可选参数</strong>（optional argument）。</p><p>这种函数<strong>必须至少有一个</strong>强制参数。可选参数的类型可以变化。可选参数的数量由强制参数的值决定，或由用来定义可选参数列表的特殊值决定。</p><p>C 语言中最常用的可变参数函数例子是<code>printf（）</code>和 <code>scanf（）</code>。这两个函数都有一个强制参数，即格式化字符串。格式化字符串中的转换修饰符决定了可选参数的数量和类型。</p><p>可变参数函数要获取可选参数时，必须通过一个类型为 <code>va_list</code> 的对象，它包含了参数信息。这种类型的对象也称为参数指针（argument pointer），它包含了栈中至少一个参数的位置。可以使用这个参数指针从一个可选参数移动到下一个可选参数，由此，函数就可以获取所有的可选参数。<code>va_list</code> 类型被定义在头文件 <code>stdarg.h</code> 中。</p><p>当编写支持参数数量可变的函数时，必须用 <code>va_list</code> 类型定义参数指针，以获取可选参数。在下面的讨论中，<code>va_list</code> 对象被命名为 <code>argptr</code>。可以用 <code>4</code>个宏来处理该参数指针，这些宏都定义在头文件 <code>stdarg.h</code> 中：</p><ul><li><p>宏 <code>va_start</code> 使用第一个可选参数的位置来初始化 <code>argptr</code> 参数指针。该宏的第二个参数必须是该函数最后一个有名称参数的名称。必须先调用该宏，才可以开始使用可选参数。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">va_start</span><span class="hljs-params">(va_list argptr, lastparam)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>展开宏 <code>va_arg</code> 会得到当前 <code>argptr</code> 所引用的可选参数，也会将 <code>argptr</code> 移动到列表中的下一个参数。宏 <code>va_arg</code> 的第二个参数是刚刚被读入的参数的类型。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">type <span class="hljs-title">va_arg</span><span class="hljs-params">(va_list argptr, type)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>当不再需要使用参数指针时，必须调用宏 <code>va_end</code>。如果想使用宏 <code>va_start</code> 或者宏 <code>va_copy</code> 来重新初始化一个之前用过的参数指针，也必须先调用宏 <code>va_end</code>。<code>va_end</code>被定义为空。它只是为实现与 va_start 配对 (实现代码对称和”代码自注释”(根据代码就能知道功能，不需要额外注释) 功能)</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">va_end</span><span class="hljs-params">(va_list argptr)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>宏 <code>va_copy</code> 使用当前的<code>src</code>值来初始化参数指针 <code>dest</code>。然后就可以使用 <code>dest</code>中的备份获取可选参数列表，从<code>src</code> 所引用的位置开始。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">va_copy</span><span class="hljs-params">(va_list dest, va_list src)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数 add() 计算可选参数之和</span><br><span class="hljs-comment">// 参数：第一个强制参数指定了可选参数的数量，可选参数为 double 类型</span><br><span class="hljs-comment">// 返回值：和值，double 类型</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">( <span class="hljs-keyword">int</span> n, ... )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br>  va_list argptr;<br>  va_start( argptr, n );             <span class="hljs-comment">// 初始化 argptr</span><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; n; ++i )          <span class="hljs-comment">// 对每个可选参数，读取类型为 double 的参数，</span><br>    sum += va_arg( argptr, <span class="hljs-keyword">double</span> ); <span class="hljs-comment">// 然后累加到 sum 中</span><br>  va_end( argptr );<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>简易<code>printf</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-comment">/* minprintf: minimal printf with variable arqument list */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">minprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fmt, ...)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br>    GPIO<br>    va_list ap; <span class="hljs-comment">/* points to each unnamed arq in turn */</span><br>    <span class="hljs-keyword">char</span> *p, *sval;<br>    <span class="hljs-keyword">int</span> ival;<br>    <span class="hljs-keyword">double</span> dval;<br>    va_start(ap, fmt); <span class="hljs-comment">/* make ap point to 1st unnamed arg */</span><br>    <span class="hljs-keyword">for</span> (p = fmt; *p; p++) &#123;<br>        <span class="hljs-keyword">if</span> (*p != <span class="hljs-string">&#x27;%&#x27;</span>) &#123;<br>            <span class="hljs-built_in">putchar</span>(*p);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">switch</span> (*++p) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>         ival = va_arg(ap, <span class="hljs-keyword">int</span>);<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ival);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br>            dval = va_arg(ap, <span class="hljs-keyword">double</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f&quot;</span>, dval);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>            <span class="hljs-keyword">for</span> (sval = va_arq(ap, <span class="hljs-keyword">char</span> *); *sval; sval++)<br>                <span class="hljs-built_in">putchar</span>(*sval);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">putchar</span>(*p);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    va_end(ap); <span class="hljs-comment">/* clean up when done */</span><br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下将编译结果输出到文件</title>
    <link href="/2021/09/30/Linux%E4%B8%8B%E5%B0%86%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6/"/>
    <url>/2021/09/30/Linux%E4%B8%8B%E5%B0%86%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>在命令行编译项目时，经常遇到编译结果太长，覆盖了最先输出的结果，此时就需要将结果输出到文件再查看。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">make &gt; make.log 2&gt;&amp;1<br><span class="hljs-comment"># make 编译命令</span><br><span class="hljs-comment"># make.log 输出文件名</span><br><span class="hljs-comment"># 2 文件描述符，标准错误</span><br><span class="hljs-comment"># &gt; 重定向符，输出</span><br><span class="hljs-comment"># &amp;1 文件描述符&amp;，文件描述符1 标准输入</span><br></code></pre></td></tr></table></figure><p>该命令功能即将<code>make</code>编译时输出，标准错误重定向为标准输入，写入到<code>make.log</code>文件中。符号的含义可以参考<a href="">Linux 文件描述符</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 文件描述符</title>
    <link href="/2021/09/30/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <url>/2021/09/30/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux 中一切皆文件，比如 C++ 源文件、视频文件、Shell 脚本、可执行文件等，就连键盘、显示器、鼠标等硬件设备也都是文件。</p><p>一个 Linux 进程可以打开成百上千个文件，为了表示和区分已经打开的文件，Linux 会给每个文件分配一个编号（一个 ID），这个编号就是一个整数，被称为<strong>文件描述符</strong>（File Descriptor）。</p><h2 id="文件描述符是什么？"><a href="#文件描述符是什么？" class="headerlink" title="文件描述符是什么？"></a>文件描述符是什么？</h2><p>一个 Linux 进程启动后，会在内核空间中创建一个 <code>PCB</code> 控制块，<code>PCB</code> 内部有一个<strong>文件描述符表</strong>（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。</p><p>除了文件描述符表，系统还需要维护另外两张表：</p><ul><li>打开文件表（Open file table）</li><li><code>i-node</code> 表（i-node table）</li></ul><p>文件描述符表每个进程都有一个，打开文件表和 <code>i-node</code> 表整个系统只有一个，它们三者之间的关系如下图所示。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210930132546.png"></p><p>对上图的说明：</p><ul><li>在进程<code>A</code> 中，文件描述符 <code>1</code> 和<code>20</code> 都指向了同一个打开文件表项，标号为 <code>23</code>（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 <code>dup()</code>、<code>dup2()</code>、<code>fcntl()</code> 或者对同一个文件多次调用了 <code>open()</code> 函数形成的。</li><li>进程 <code>A</code> 的文件描述符 <code>2</code>和进程<code>B</code> 的文件描述符<code>2</code> 都指向了同一个文件，这可能是在调用 <code>fork()</code> 后出现的（即进程 <code>A</code>、<code>B</code>是父子进程关系），或者是不同的进程独自去调用<code>open()</code> 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</li><li>进程 <code>A</code> 的描述符<code>0</code>和进程<code>B</code>的描述符<code>3</code>分别指向不同的打开文件表项，但这些表项均指向 <code>i-node</code> 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 <code>open()</code> 调用。同一个进程两次打开同一个文件，也会发生类似情况。</li></ul><p>通过文件描述符，可以找到文件指针，从而进入打开文件表。该表存储了以下信息：</p><ul><li>文件偏移量，也就是文件内部指针偏移量。调用<code>read()</code>或者<code>write()</code> 函数时，文件偏移量会自动更新，当然也可以使用 <code>lseek()</code> 直接修改。</li><li>状态标志，比如只读模式、读写模式、追加模式、覆盖模式等。</li><li><code>i-node</code> 表指针。</li></ul><p>然而，要想真正读写文件，还得通过打开文件表的 i-node 指针进入</p><ul><li><code>i-node</code> 表，该表包含了诸如以下的信息：</li><li>文件类型，例如常规文件、套接字或 <code>FIFO</code>。</li><li>文件大小。</li><li>时间戳，比如创建时间、更新时间。</li><li>文件锁。</li></ul><h2 id="标准文件描述符"><a href="#标准文件描述符" class="headerlink" title="标准文件描述符"></a>标准文件描述符</h2><table><thead><tr><th align="center">文件描述符</th><th align="center">用途</th><th align="center">POSIX 名称</th><th align="center">stdio 流</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">标准输入</td><td align="center">STDIN FILENO</td><td align="center">stdin</td></tr><tr><td align="center">1</td><td align="center">标准输出</td><td align="center">STDOUT FILENO</td><td align="center">stdout</td></tr><tr><td align="center">2</td><td align="center">标准错误</td><td align="center">STDERR FILENO</td><td align="center">stderr</td></tr></tbody></table><p>标准文件描述符通常会和重定向符<code>&lt;,&gt;,&lt;&lt;,&gt;&gt;</code>结合使用。箭头向左表示输入重定向，向右表示输出重定向。文件描述符中的<code>0</code>通常省略。如<code>0&lt; ~ &lt;</code>，<code>0&lt;&lt; ~ &lt;&lt;</code>。</p><h3 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h3><p>使用<code>wc</code>命令统计文档中有多少行字，命令格式如下，详细介绍参考<a href="https://dunky-z.github.io/2021/07/30/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-wc%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AD%97%E5%A4%9A%E5%B0%91%E8%A1%8C/">这篇文章</a>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">wc  <span class="hljs-selector-attr">[选项]</span>  <span class="hljs-selector-attr">[文件名]</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat test.txt<br>This is a <span class="hljs-built_in">test</span> file.<br>Hello world!<br><br>$ wc -l &lt;test.txt<br>2<br></code></pre></td></tr></table></figure><p>这里的重定向符号<code>&lt;</code>作用就是将<code>test.txt</code>的内容作为标准输入，传递给<code>wc</code>命令。</p><h2 id="标准输出与标准错误"><a href="#标准输出与标准错误" class="headerlink" title="标准输出与标准错误"></a>标准输出与标准错误</h2><p>这个我们每天都在接触，但是可能没有留意。假设我当前目录下只有一个<code>test.txt</code>文件，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat text.txt<br>This is a <span class="hljs-built_in">test</span> file.<br>Hello world!            <span class="hljs-comment">#标准输出1</span><br><br>$ cat text.md<br>cat: test.md: No such file or directory <span class="hljs-comment">#标准错误2</span><br><br>$ ls text.txt text.md 1&gt;file.out 2&gt;file.err <br><span class="hljs-comment"># 执行后,没有任何返回值. 原因是, 返回值都重定向到相应的文件中了,而不再前端显示 </span><br>$ cat file.out <br>text.txt <br><br>$ cat file.err <br>cat: test.md: No such file or directory<br></code></pre></td></tr></table></figure><h2 id="amp-描述符"><a href="#amp-描述符" class="headerlink" title="&amp;描述符"></a><code>&amp;</code>描述符</h2><p><code>&amp;</code> 是一个描述符，如果<code>1</code>或<code>2</code>前不加<code>&amp;</code>，会被当成一个普通文件。</p><p><code>1&gt;&amp;2</code> 意思是把标准输出重定向到标准错误。<br><code>2&gt;&amp;1</code> 意思是把标准错误输出重定向到标准输出。<br><code>&amp;&gt;filename</code> 意思是把标准输出和标准错误输出都重定向到文件 filename 中</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://c.biancheng.net/view/942.html">Linux Shell 重定向（输入输出重定向）精讲</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode 快速添加注释模板</title>
    <link href="/2021/09/29/VScode%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/09/29/VScode%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>通常函数的注释一般都比较长，而且每个函数注释都格式一致，例如下面的函数注释模板。如果每次写注释都要复制一遍比较麻烦，复制完还要删除多余的字符。但是现有的编辑器一般都支持快捷输入。下面介绍在 VSCode 中如何快捷输入注释模板。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p><code>Ctrl+Shift+P</code>打开编辑器命令窗口 - 输入<code>snippets</code>-选择<code>Preferences:Configure User Snippets</code>-选择·c.json·<br>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210929170226.png"><br>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210929170717.png"></p></li><li><p>更改如下：</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">   &#123;<br><br><span class="hljs-comment">// Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and</span><br><span class="hljs-comment">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span><br><span class="hljs-comment">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the</span><br><span class="hljs-comment">// same ids are connected.</span><br><span class="hljs-comment">// Example:</span><br><span class="hljs-comment">// &quot;Print to console&quot;: &#123;</span><br><span class="hljs-comment">//  &quot;prefix&quot;: &quot;log&quot;,</span><br><span class="hljs-comment">//  &quot;body&quot;: [</span><br><span class="hljs-comment">//   &quot;console.log(&#x27;$1&#x27;);&quot;,</span><br><span class="hljs-comment">//   &quot;$2&quot;</span><br><span class="hljs-comment">//  ],</span><br><span class="hljs-comment">//  &quot;description&quot;: &quot;Log output to console&quot;</span><br><span class="hljs-comment">// &#125;</span><br> <span class="hljs-attr">&quot;Function comment&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;prefix&quot;</span>: <span class="hljs-string">&quot;funcom&quot;</span>,<br> <span class="hljs-attr">&quot;body&quot;</span>: [<br>   <span class="hljs-string">&quot;/*&quot;</span><br>    <span class="hljs-string">&quot;* Description:      &quot;</span><br>    <span class="hljs-string">&quot;*Input Parameter:  &quot;</span><br>    <span class="hljs-string">&quot;* Output Parameter: &quot;</span><br>    <span class="hljs-string">&quot;*Return:           &quot;</span><br>    <span class="hljs-string">&quot;*/ &quot;</span><br> ],<br> <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;function comment&quot;</span><br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>prefix</code>:输入时的缩写，触发器</p></li><li><p><code>body</code>:内容</p></li><li><p><code>description</code>:描述</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6844903869424599053">VSCode 利用 Snippets 设置超实用的代码块 - 掘金</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QtCreator 快速添加注释模板</title>
    <link href="/2021/09/28/QtCreator%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/09/28/QtCreator%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>通常函数的注释一般都比较长，而且每个函数注释都格式一致，例如下面的函数注释模板。如果每次写注释都要复制一遍比较麻烦，复制完还要删除多余的字符。但是现有的编辑器一般都支持快捷输入。下面介绍在 QtCreator 中如何快捷输入注释模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Description:      // 函数功能、性能等的描述  </span><br><span class="hljs-comment"> * Input Parameter:  // 输入参数说明，包括每个参数的作 </span><br><span class="hljs-comment"> * Output Parameter: // 对输出参数的说明。 </span><br><span class="hljs-comment"> * Return:           // 函数返回值的说明 </span><br><span class="hljs-comment"> */</span> <br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>QtCreator-菜单栏工具（Tool）- 选项（Options）- 文本编辑器（Text Editor）- 片段（Snippets）</li><li>组（Group）选择<code>C++</code>-添加（Add）<br>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210928193309.png"></li><li>现在要为我们的触发（Trigger）起个名字，因为是函数注释，我起了个<code>funcom</code>，然后在下方空白框里填入注释模板。Apply 保存。如图<br>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210928193538.png"></li><li>在需要添加注释模板的地方输入<code>funcom</code>即可提示快捷输入，回车即可添加注释模板。<br>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210928194108.gif"></li></ul><p>我们可以看到片段里有很多熟悉的内容，比如<code>if else</code>，我们在写代码时输入<code>if else</code>自动补全花括号其实就是在这里设置的。同理，我们还可以设置一些其他需要的快捷输入内容。比如行注释，文件注释，经常使用的代码框架等等。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>QtCreator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 修改 UI 文件不生效</title>
    <link href="/2021/09/26/Qt%E4%BF%AE%E6%94%B9UI%E6%96%87%E4%BB%B6%E4%B8%8D%E7%94%9F%E6%95%88/"/>
    <url>/2021/09/26/Qt%E4%BF%AE%E6%94%B9UI%E6%96%87%E4%BB%B6%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>修改了 UI 文件后，在代码中无法调用新增的内容。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>导致<code>ui_*.h</code>文件没有更新的原因是源代码中<code>#include ui_*.h</code>的位置和实际生成的位置不同，引用的是老的<code>ui_*.h</code></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法一：</p><p>项目设置文件<code>.pro</code>内增加 <code>UI_DIR=./UI</code>，同时删除掉源代码目录中<code>ui_*.h</code>，<code>clear all</code>,<code>-&gt;qmake-&gt;rebuilt all</code><br>方法二：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210926105252.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QtCreator 修改项目构建目录</title>
    <link href="/2021/09/25/QtCreator%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%9B%AE%E5%BD%95/"/>
    <url>/2021/09/25/QtCreator%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>QtCreator 构建项目时，会在统计目录新建一个<code>build-xxx-debug</code>的目录，如果想要自己修改这个目录的位置，名称，该怎么办。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>仅修改工具（Tool）–&gt;选项 (Options)–&gt;构建和运行 (Build&amp;Run) 中<code>Default build directory：./%&#123;CurrentBuild:Name&#125;</code>是不会生效的。</p><ul><li><p>将工具–&gt;选项–&gt;构建和运行中<code>Default build directory</code>修改为<code>./%&#123;CurrentBuild:Name&#125;</code>（改为你想要的目标目录都行）；</p></li><li><p>把 QtCreator 关闭，把工程目录下后缀名为<code>.pro.user</code>的文件删掉；</p></li><li><p>用 QtCreator 打开工程，会提示你创建构建目录，此时提示的就是你修改后的<code>Default build directory</code>中填写的目录；</p></li></ul><p>其中<code>.pro.user</code>文件记录了编译器、构建工具链、构建目录、版本…..等工程编译相关信息，想要更换项目的编译环境，得删除这个文件，由 QtCreator 自动重新创建。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-把本地仓库同步到 GitHub</title>
    <link href="/2021/09/23/Git%E6%8A%8A%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5%E5%88%B0GitHub/"/>
    <url>/2021/09/23/Git%E6%8A%8A%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5%E5%88%B0GitHub/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>因为现在大部分情况下是先从远程 Clone 下来代码，所以这一功能用的不多。但是如果自己想把本地已有的代码同步到远程，本文就可以解决这一的需求。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p>GitHub 新建一个仓库，并复制 SSH 地址</p>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:git201901/git_learning.git<br></code></pre></td></tr></table></figure></li><li><p><code>git remote add 名称</code></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pc:git-learning suling$ git remote add github git@github.com:git201901/git_learning.git<br></code></pre></td></tr></table></figure><p>  这里的<code>github</code>就是自定义的一个名称，用于替换后面的远程地址。方便后续<code>git push github</code>以及<code>git fetch github</code>。</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Undefined reference to 问题</title>
    <link href="/2021/09/17/%E8%A7%A3%E5%86%B3Undefined-reference-to%E9%97%AE%E9%A2%98/"/>
    <url>/2021/09/17/%E8%A7%A3%E5%86%B3Undefined-reference-to%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="链接时缺失了相关目标文件"><a href="#链接时缺失了相关目标文件" class="headerlink" title="链接时缺失了相关目标文件"></a>链接时缺失了相关目标文件</h2><p>这是最典型最常见的情况。比如新添加了一个模块<code>fun.h fun.c</code>两个文件，其他文件中使用了这个模块里的函数，如果编译时忘记加上这两个文件，调用<code>fun</code>模块函数的地方，就会报<code>undefined reference</code>错误。</p><p>这个问题在编辑器中一般不容易发现，因为头文件包含是正确的，编辑器能够找到相关的函数及其实现，所以在编写代码时不会报错。</p><h2 id="链接时缺少相关的库文件"><a href="#链接时缺少相关的库文件" class="headerlink" title="链接时缺少相关的库文件"></a>链接时缺少相关的库文件</h2><p>这个原因和上一条类似，我们在调用静态库中的函数时，编译时如果没有将静态库一起编译，就会报同样的错误。</p><h2 id="链接的库文件中又使用了另一个库文件"><a href="#链接的库文件中又使用了另一个库文件" class="headerlink" title="链接的库文件中又使用了另一个库文件"></a>链接的库文件中又使用了另一个库文件</h2><p>在使用第三方库时，一定要在编译中加入第三方库的路径。</p><h2 id="多个库文件链接顺序问题"><a href="#多个库文件链接顺序问题" class="headerlink" title="多个库文件链接顺序问题"></a>多个库文件链接顺序问题</h2><p>在链接命令中给出所依赖的库时，需要注意库之间的依赖顺序，依赖其他库的库一定要放到被依赖库的前面，这样才能真正避免 undefined reference 的错误，完成编译链接。</p><h2 id="声明与实现不一致"><a href="#声明与实现不一致" class="headerlink" title="声明与实现不一致"></a>声明与实现不一致</h2><p>这个原因也比较典型，注意排查声明与实现的参数是否一致，返回值是否一致。</p><h2 id="在-c-代码中链接-c-语言的库"><a href="#在-c-代码中链接-c-语言的库" class="headerlink" title="在 c++代码中链接 c 语言的库"></a>在 c++代码中链接 c 语言的库</h2><p>在<code>C++</code>代码中，调用了<code>C</code>语言库的函数，因此链接的时候找不到，解决方法是在相关文件添加一个<code>extern &quot;C&quot;</code>的声明即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顾名思义，这个错误就是<strong>未定义</strong>你使用的内容导致的。所以要排查使用的内容是否能够被正确“找到”。使用的时候有没有声明，有没有定义，声明与定义是否一致，编译时能否正确链接等等。</p><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><p><a href="https://segmentfault.com/a/1190000006049907">“undefined reference to” 问题汇总及解决方法</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C++</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++如何避免过多使用全局变量</title>
    <link href="/2021/09/17/C-C-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <url>/2021/09/17/C-C-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>‘</p><p>具体实例可以参考<a href="https://blog.csdn.net/maple_2014/article/details/109541104">Marc Pony</a></p><h2 id="指针传参"><a href="#指针传参" class="headerlink" title="指针传参"></a>指针传参</h2><p>C 语言中，全局变量用结构体封装，设计函数时，将参数以结构体指针形式传入。</p><h2 id="定义获取变量的方法-函数"><a href="#定义获取变量的方法-函数" class="headerlink" title="定义获取变量的方法/函数"></a>定义获取变量的方法/函数</h2><p>定义一个函数以<code>get/set</code>全局变量，利用<code>static</code>变量，将全局变量作用域限定于该函数，将全局变量隐藏起来。</p><h2 id="善用static"><a href="#善用static" class="headerlink" title="善用static"></a>善用<code>static</code></h2><p>把全局变量定义在某一个 .c 文件中，并定义为 static 类型，然后定义一系列操作这个变量的函数，头文件里面只有操作函数，没有变量的声明</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言 sizeof(结构体) 到底有多大</title>
    <link href="/2021/09/15/C%E8%AF%AD%E8%A8%80sizeof-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%A4%A7/"/>
    <url>/2021/09/15/C%E8%AF%AD%E8%A8%80sizeof-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="C-语言中各个数据类型的大小"><a href="#C-语言中各个数据类型的大小" class="headerlink" title="C 语言中各个数据类型的大小"></a>C 语言中各个数据类型的大小</h2><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1 字节</td><td align="center">-128 到 127 或 0 到 255</td></tr><tr><td align="center">unsigned char</td><td align="center">1 字节</td><td align="center">0 到 255</td></tr><tr><td align="center">signed char</td><td align="center">1 字节</td><td align="center">-128 到 127</td></tr><tr><td align="center">int</td><td align="center">2 或 4 字节</td><td align="center">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td align="center">unsigned int</td><td align="center">2 或 4 字节</td><td align="center">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td align="center">short</td><td align="center">2 字节</td><td align="center">-32,768 到 32,767</td></tr><tr><td align="center">unsigned short</td><td align="center">2 字节</td><td align="center">0 到 65,535</td></tr><tr><td align="center">long</td><td align="center">4 字节</td><td align="center">-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="center">unsigned long</td><td align="center">4 字节</td><td align="center">0 到 4,294,967,295</td></tr><tr><td align="center">结构体 (struct)</td><td align="center">待分析，需要考虑字节对齐</td><td align="center"></td></tr><tr><td align="center">联合 (union)</td><td align="center">所有成员中最长的</td><td align="center"></td></tr><tr><td align="center">枚举 (enum)</td><td align="center">根据数据类型</td><td align="center"></td></tr></tbody></table><h2 id="单层结构体大小"><a href="#单层结构体大小" class="headerlink" title="单层结构体大小"></a>单层结构体大小</h2><p>如果结构体中的成员数据类型相同，这样的情况最简单，<code>结构体大小=数据类型*数据个数</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test1</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>&#125; T1;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test2</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>&#125; T2;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T1 t1;<br>    <span class="hljs-keyword">int</span> siz01 = <span class="hljs-keyword">sizeof</span>(t1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, siz01); <span class="hljs-comment">//8</span><br><br>    T2 t2;<br>    <span class="hljs-keyword">int</span> siz02 = <span class="hljs-keyword">sizeof</span>(t2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, siz02); <span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是结构体中通常数据类型都各不相同，成员<strong>按照定义时的顺序依次存储在连续的内存空间</strong>。和数组不一样的是，结构体的大小不是所有成员大小简单的相加，需要考虑到地址对齐问题。看下面这样的一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test3</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">int</span> c;<br>&#125; T3;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T3 t3;<br>    <span class="hljs-keyword">int</span> siz03 = <span class="hljs-keyword">sizeof</span>(t3);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t3: %d\n&quot;</span>, siz03); <span class="hljs-comment">//t3: 12</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>sizeof</code>求该结构体的大小，发现值为<code>12</code>。<code>int</code>占<code>4</code>个字节，<code>char</code>占<code>1</code>个字节，结果应该是<code>9</code>个字节才对啊，为什么呢？</p><p>先介绍一个相关的概念——<strong>偏移量</strong>。偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员<code>int a</code>的偏移量为<code>0</code>。第二个成员<code>char b</code>的偏移量是第一个成员的偏移量加上第一个成员的大小<code>0+4</code>,其值为<code>4</code>；第三个成员<code>int c</code>的偏移量是第二个成员的偏移量加上第二个成员的大小<code>4+1</code>,其值为<code>5</code>。</p><p>即结构体的大小等于最后一个成员变量的地址与第一个成员变量的地址之差，再加上最后一个成员变量的大小。</p><p>如果不考虑对齐的情况，变量在内存中的存放如下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t3</span><br>    ________<br><span class="hljs-number">0</span>  |aaaabccc| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |c       | <span class="hljs-number">15</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><p>当我们凭直觉去用<code>4+1+4=9</code>来计算结构体大小时并不会觉得有什么错，但是通过内存的排放可以直观的看到，第三个变量的存放有点奇怪。CPU 从内存中读取肯定也是极为不便的。实际存储变量时，地址要求对齐的。编译器在编译程序时会遵循两条原则：</p><ul><li>结构体变量中成员的偏移量必须是成员大小的整数倍（<code>0</code>被认为是任何数的整数倍）</li><li>结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。</li></ul><p>我们在回头分析上述的例子，前两个成员的偏移量<code>0 4</code>都满足要求，但第三个成员的偏移量为<code>5</code>，并不是自身<code>int</code>大小的整数倍。编译器在处理时会在第二个成员后面补上<code>3</code>个空字节，使得第三个成员的偏移量变成<code>8</code>。结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为<code>12</code>，满足公倍数要求。</p><p>直观描述这个结构体在内存中的存储如下，<code>星号*表示该段内存因为内存对齐被占用，也就是其实际大小。字母个数表示其单独拿出来的大小</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t3</span><br>    ________<br><span class="hljs-number">0</span>  |aaaab***| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |cccc    | <span class="hljs-number">15</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><p>再看一例，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test4</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">short</span> b;<br>&#125; T4;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T4 t4;<br>    <span class="hljs-keyword">int</span> siz04 = <span class="hljs-keyword">sizeof</span>(t4);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t4: %d\n&quot;</span>, siz04); <span class="hljs-comment">//t4: 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 成员<code>int a</code>的偏移量为 0；成员<code>short b</code>的偏移量为 4，都不需要调整。但计算出来的大小为<code>6</code>，显然不是成员<code>int a</code>大小的整数倍。因此，编译器会在成员<code>int b</code>后面补上<code>2</code>个字节，使得结构体的大小变成<code>8</code>从而满足第二个公倍数要求。</p><p>由此可见，结构体类型需要考虑到字节对齐的情况，<strong>不同的顺序会影响结构体的大小</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test5</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-keyword">char</span> c;<br>&#125; T5;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test6</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">int</span> c;<br>&#125; T6;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T5 t5;<br>    <span class="hljs-keyword">int</span> siz05 = <span class="hljs-keyword">sizeof</span>(t5);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t5: %d\n&quot;</span>, siz05); <span class="hljs-comment">//t5: 12</span><br><br>    T4 t6;<br>    <span class="hljs-keyword">int</span> siz06 = <span class="hljs-keyword">sizeof</span>(t6);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t6: %d\n&quot;</span>, siz06); <span class="hljs-comment">//t6: 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个结构体成员都一样，但是一个大小为<code>12</code>一个大小为<code>8</code>。我们将其在内存的存储画出来就可以明白，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t5</span><br>    ________<br><span class="hljs-number">0</span>  |a***bbbb| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |c***    | <span class="hljs-number">15</span><br>    ‾‾‾‾‾‾‾‾<br><span class="hljs-comment">//t6</span><br>    ________<br><span class="hljs-number">0</span>  |ab**cccc| <span class="hljs-number">7</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>结构体大小等于最后一个成员的偏移量加上最后一个成员的大小</li><li>结构体变量中成员的偏移量必须是成员大小的整数倍（<code>0</code>被认为是任何数的整数倍）</li><li>结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数</li><li>不同的顺序会影响结构体的大小</li></ul><h2 id="嵌套结构体大小"><a href="#嵌套结构体大小" class="headerlink" title="嵌套结构体大小"></a>嵌套结构体大小</h2><p>对于嵌套的结构体，需要将其展开。对结构体求<code>sizeof</code>时，上述两种原则变为：</p><ul><li>展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test7</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">short</span> a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">char</span> b;<br>        <span class="hljs-keyword">int</span> c;<br>    &#125; tt;<br>    <span class="hljs-keyword">int</span> d;<br>&#125; T7;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T7 t7;<br>    <span class="hljs-keyword">int</span> siz07 = <span class="hljs-keyword">sizeof</span>(t7);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t7: %d\n&quot;</span>, siz07); <span class="hljs-comment">//t7: 16</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据原则一，<code>tt</code>的偏移量应该是<code>4</code>，而不是<code>2</code>。</p><p>在内存中的存储，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t7</span><br>    ________<br><span class="hljs-number">0</span>  |aa**b***| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |ccccdddd| <span class="hljs-number">15</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test8</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">char</span> b;<br>        <span class="hljs-keyword">int</span> c;<br>    &#125; tt;<br>    <span class="hljs-keyword">char</span> d;<br>    <span class="hljs-keyword">char</span> e;<br>    <span class="hljs-keyword">char</span> f;<br>    <span class="hljs-keyword">char</span> g;<br>    <span class="hljs-keyword">char</span> h;<br>&#125; T8;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T8 t8;<br>    <span class="hljs-keyword">int</span> siz08 = <span class="hljs-keyword">sizeof</span>(t8);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t8: %d\n&quot;</span>, siz08); <span class="hljs-comment">//t8: 20</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体<code>tt</code>单独计算占用空间为<code>8</code>，而<code>t8</code>则是<code>20</code>，不是<code>8</code>的整数倍，这说明在计算<code>sizeof(t8)</code>时，将嵌套的结构体<code>tt</code>展开了，这样<code>t8</code>中最大的成员为<code>tt.c</code>，占用 4 个字节，<code>20</code>为 4 的整数倍。如果将<code>tt</code>当做一个整体，结果应该是<code>24</code>了。</p><p>在内存中的存储，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t8</span><br>    ________<br><span class="hljs-number">0</span>  |a***b***| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |ccccdefg| <span class="hljs-number">15</span><br><span class="hljs-number">16</span> |h***    | <span class="hljs-number">31</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><p>另一个特殊的例子是结构体中包含数组，其大小计算应当和处理嵌套结构体一样，将其展开，如下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test9</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">float</span> b;<br>    <span class="hljs-keyword">int</span> c[<span class="hljs-number">2</span>];<br>&#125; T9;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T9 t9;<br>    <span class="hljs-keyword">int</span> siz09 = <span class="hljs-keyword">sizeof</span>(t9);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t9: %d\n&quot;</span>, siz09); <span class="hljs-comment">//t9: 16</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>char a</code>占一个字节，偏移量为<code>0</code>，<code>short b</code>占四字节，偏移量为<code>2</code>，不是最大成员的整数倍，这里取最大成员是<code>int</code>或者<code>short</code>的大小的倍数。而不是整个数组<code>int c[2]</code>的倍数。所以<code>short b</code>偏移量扩展为<code>4</code>。</p><p>内存中存储，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t9</span><br>    ________<br><span class="hljs-number">0</span>  |a***bbbb| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |cccccccc| <span class="hljs-number">15</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</li><li>想象在内存中的存储，保证对齐要求，基本上可以比较准确的算出来</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 命令行带参数启动 Qt 程序</title>
    <link href="/2021/09/13/Qt%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E5%90%AF%E5%8A%A8Qt%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/09/13/Qt%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E5%90%AF%E5%8A%A8Qt%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们经常用到命令行参数，比如最常见的 Linux 命令，显示所有文件<code>ls -a</code>,<code>ls</code>其实就是一个程序，<code>-a</code>就是该程序需要解析的一个参数。那么如何能让 Qt 程序也能解析命令行参数，从命令行启动呢？</p><p>Qt 从 5.2 版开始提供了两个类<code>QCommandLineOption</code>和<code>QCommandLineParser</code>来解析应用的命令行参数。</p><h2 id="添加程序属性信息，帮助，版本"><a href="#添加程序属性信息，帮助，版本" class="headerlink" title="添加程序属性信息，帮助，版本"></a>添加程序属性信息，帮助，版本</h2><p>一个程序启动后，我们会在命令行看到程序的一些简要信息，以及可以使用<code>-v</code>命令显示其版本信息，这些通用的参数以及被 Qt 分装好，可以直接使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QCommandLineParser&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    QCommandLineParser parser;                        <span class="hljs-comment">// 定义解析实例</span><br>    parser.<span class="hljs-built_in">setApplicationDescription</span>(<span class="hljs-string">&quot;TestCommandLine&quot;</span>);  <span class="hljs-comment">// 描述可执行程序的属性</span><br>    parser.<span class="hljs-built_in">addHelpOption</span>();                           <span class="hljs-comment">// 添加帮助命令</span><br>    parser.<span class="hljs-built_in">addVersionOption</span>();                        <span class="hljs-comment">// 添加版本选择命令</span><br>    parser.<span class="hljs-built_in">process</span>(a);                                <span class="hljs-comment">// 把用户的命令行的放入解析实例</span><br>    MainWindow w;<br>    w.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜ ./CommandLine -h<br>Usage: ./CommandLine [options]<br>TestCommandLine<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Displays <span class="hljs-built_in">help</span> on commandline options.<br>  --help-all     Displays <span class="hljs-built_in">help</span> including Qt specific options.<br>  -v, --version  Displays version information.<br></code></pre></td></tr></table></figure><h2 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QCommandLineParser&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QCommandLineOption&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    QCommandLineParser parser;                        <span class="hljs-comment">// 定义解析实例</span><br>    parser.<span class="hljs-built_in">setApplicationDescription</span>(<span class="hljs-string">&quot;TestCommandLine&quot;</span>);  <span class="hljs-comment">// 描述可执行程序的属性</span><br>    parser.<span class="hljs-built_in">addHelpOption</span>();                           <span class="hljs-comment">// 添加帮助命令</span><br>    parser.<span class="hljs-built_in">addVersionOption</span>();                        <span class="hljs-comment">// 添加版本选择命令</span><br><br>    <span class="hljs-function">QCommandLineOption  <span class="hljs-title">CommandExe</span><span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>, QGuiApplication::translate(<span class="hljs-string">&quot;main&quot;</span>,<span class="hljs-string">&quot;Take  the  first  argument  as a command to execute, &quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                                          <span class="hljs-string">&quot;rather than reading commands from a script or standard input.  &quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                                          <span class="hljs-string">&quot;If  any  fur‐\ther  arguments  are  given,  &quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                                          <span class="hljs-string">&quot;the  first  one is assigned to $0,&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                                          <span class="hljs-string">&quot; rather than being used as a positional parameter.&quot;</span>))</span></span>;<br><br>    parser.<span class="hljs-built_in">addOption</span>(CommandExe);<br>    parser.<span class="hljs-built_in">process</span>(a);                                <span class="hljs-comment">// 把用户的命令行的放入解析实例</span><br>    MainWindow w;<br>    w.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vim">➜ ./CommandLine -h<br>Usage: ./CommandLine [<span class="hljs-keyword">options</span>]<br>TestCommandLine<br><br>Option<span class="hljs-variable">s:</span><br>  -h, --<span class="hljs-keyword">help</span>     Displays <span class="hljs-keyword">help</span> <span class="hljs-keyword">on</span> commandline <span class="hljs-keyword">options</span>.<br>  --<span class="hljs-keyword">help</span>-<span class="hljs-keyword">all</span>     Displays <span class="hljs-keyword">help</span> including Qt specific <span class="hljs-keyword">options</span>.<br>  -v, --<span class="hljs-keyword">version</span>  Displays <span class="hljs-keyword">version</span> information.<br>  -<span class="hljs-keyword">c</span>             Take  the  <span class="hljs-keyword">first</span>  <span class="hljs-keyword">argument</span>  <span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">command</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">execute</span>, rather<br>                 than reading commands from <span class="hljs-keyword">a</span> script <span class="hljs-built_in">or</span> standard <span class="hljs-built_in">input</span>.  If  any<br>                 fur‐ her  arguments  are  given,  the  <span class="hljs-keyword">first</span>  one <span class="hljs-keyword">is</span> assigned<br>                 <span class="hljs-keyword">to</span> $<span class="hljs-number">0</span>, rather than being used <span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> positional parameter.<br></code></pre></td></tr></table></figure><h2 id="获取参数值"><a href="#获取参数值" class="headerlink" title="获取参数值"></a>获取参数值</h2><p>如果需要从命令行获取参数值，那么必须要给参数值，指定一个名字。如，参数接收的是路径，可以<code>setValueName(&quot;path&quot;)</code>，如，参数接收的是个数值，可以<code>setValueName(&quot;value&quot;)</code>。</p><p>如果不设置参数值名称，那么将无法获取其值。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 不同人修改了不同的文件该如何处理</title>
    <link href="/2021/09/12/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <url>/2021/09/12/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>同一个项目，<strong>不同的开发者修改了不同的文件</strong>，如何解决同步冲突。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="用户一修改"><a href="#用户一修改" class="headerlink" title="用户一修改"></a>用户一修改</h3><p>第一个用户新建一个分支，<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222312698.png"></p><p>以上命令就是新建一个分支<code>feature/add_git_commands</code> 将其与远端分支<code>origin/feature/add_git_commands</code>相关联，并切换到该分支。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222317370.png"></p><p>修改 readme 文件，并推送到远端。因为新建分支时已经做了与远端关联，所以可以直接<code>git push</code>。</p><h3 id="用户二修改"><a href="#用户二修改" class="headerlink" title="用户二修改"></a>用户二修改</h3><p>第二个用户，首先拉取远端分支。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232232495.png"></p><p><code>git branch -v</code>查看本地分支，保持不变，但是<code>git branch -av</code>查看所有分支，可以发现多了两个远端分支。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232233342.png"></p><p>新建本地分支，保持与远端分支名相同。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232235005.png"></p><p>此时再对与 readme 不同的文件进行修改，提交，推送都会比较顺利。因为当前分支保持<code>fast forward</code>。</p><p>用户二继续做开发，但是没再往远端推送代码。在此期间，用户一对远端代码进行了更新。用户二想再次推送代码，将会报错，提示当前提交不再<code>fast forward</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232242069.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li><p><code>git fetch</code>远端分支<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232243841.png"></p></li><li><p><code>git merge</code>合并远端分支<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232245751.png"></p></li></ul><p>因为两个用户修改的不同文件，所以合并不会产生冲突。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 TypeError [ERR_INVALID_ARG_TYPE]: The data argument must be of type string or an instance of Buffe</title>
    <link href="/2021/09/10/%E8%A7%A3%E5%86%B3TypeError-ERR-INVALID-ARG-TYPE-The-data-argument-must-be-of-type-string-or-an-instance-of-Buffe/"/>
    <url>/2021/09/10/%E8%A7%A3%E5%86%B3TypeError-ERR-INVALID-ARG-TYPE-The-data-argument-must-be-of-type-string-or-an-instance-of-Buffe/</url>
    
    <content type="html"><![CDATA[<p>安装 GitBook 时出现这个错误，将<code>node</code>版本降级即可</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs smali">MINGW64 ~/Desktop/dir1/dir11<br>$ gitbook init<br>warn: no summary file in this book<br>info: create SUMMARY.md<br><br>TypeError [ERR_INVALID_ARG_TYPE]: The <span class="hljs-string">&quot;data&quot;</span> argument must be of type string<br><span class="hljs-built_in"> or </span>an<span class="hljs-built_in"> instance </span>of Buffer, TypedArray,<span class="hljs-built_in"> or </span>DataView. Received an<span class="hljs-built_in"> instance </span>of<br>Promise<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言预处理</title>
    <link href="/2021/09/09/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <url>/2021/09/09/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是预处理"><a href="#什么是预处理" class="headerlink" title="什么是预处理"></a>什么是预处理</h2><p>C 语言通过预处理器提供了一些语言功能。从概念上讲，预处理器是编译过程中单独执行的第一个步骤。两个最常用的预处理器指令是：<code>#include</code> 指令 (用于在编译期间把指定文件的内容包含进当前文件中) 和 <code>#define</code> 指令 (用任意字符序列替代一个标记)。</p><p>为啥要进行预先处理呢？如果要深入的了解的话可以参考《程序员的自我修养：链接、装载与库》这本书。这里举一个非常常见的例子，假如我们编写跨平台的程序时，我们就需要考虑不同平台的系统库是不同的，如果只包含了一个平台下的库文件，换个平台编译就可能出错。这时候就需要在编译前进行预处理。</p><p>有重要的预处理器指令：<br>| 指令     | 描述|<br>|:———-:|:—–:|<br>| #define  | 定义宏|<br>| #include | 包含一个源代码文件|<br>| #undef   | 取消已定义的宏|<br>| #ifdef   | 如果宏已经定义，则返回真|<br>| #ifndef  | 如果宏没有定义，则返回真|<br>| #if      | 如果给定条件为真，则编译下面代码|<br>| #else    | #if 的替代方案|<br>| #elif    | 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 |<br>| #endif   | 结束一个 #if……#else 条件编译块|<br>| #error   | 当遇到标准错误时，输出错误消息|<br>| #pragma  | 使用标准化方法，向编译器发布特殊的命令到编译器中|</p><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><h3 id="if"><a href="#if" class="headerlink" title="#if"></a><code>#if</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 整型常量表达式1</span><br>    程序段<span class="hljs-number">1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> 整型常量表达式2</span><br>    程序段<span class="hljs-number">2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> 整型常量表达式3</span><br>    程序段<span class="hljs-number">3</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    程序段<span class="hljs-number">4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>它的意思是：如常“表达式 1”的值为真（非 0），就对“程序段 1”进行编译，否则就计算“表达式 2”，结果为真的话就对“程序段 2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 <code>#else</code> 。这一点和 <code>if else</code> 非常类似。</p><p>需要注意的是， <code>#if</code> 命令要求判断条件为<strong>整型常量表达式</strong>，也就是说，表达式中不能包含变量，而且结果必须是整数；而 <code>if</code> 后面的表达式没有限制，只要符合语法就行。这是 <code>#if</code> 和 <code>if</code> 的一个重要区别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//不同的平台下引入不同的头文件</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _WIN32  <span class="hljs-comment">//识别 Windows 平台</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __linux__  <span class="hljs-comment">//识别 Linux 平台</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//不同的平台下调用不同的函数</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _WIN32  <span class="hljs-comment">//识别 Windows 平台</span></span><br>    Sleep(<span class="hljs-number">5000</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __linux__  <span class="hljs-comment">//识别 Linux 平台</span></span><br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;http://c.biancheng.net/&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ifedf"><a href="#ifedf" class="headerlink" title="#ifedf"></a><code>#ifedf</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span>  宏名</span><br>    程序段<span class="hljs-number">1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    程序段<span class="hljs-number">2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a><code>#ifndef</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> 宏名</span><br>    程序段<span class="hljs-number">1</span> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> </span><br>    程序段<span class="hljs-number">2</span> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>与<code>#ifdef</code>相比，仅仅是将 <code>#ifdef</code> 改为了 <code>#ifndef</code>。它的意思是，如果当前的宏未被定义，则对“程序段 1”进行编译，否则对“程序段 2”进行编译，这与<code>#ifdef</code> 的功能正好相反。</p><h2 id="文件包含-include"><a href="#文件包含-include" class="headerlink" title="文件包含#include"></a>文件包含#include</h2><p><code>#include</code> 叫做文件包含命令，用来引入对应的头文件（.h 文件）。 <code>#include</code> 的处理过程很简单，就是将<strong>头文件的内容插入到该命令所在的位置</strong>，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。</p><p><code>#include</code> 的用法有两种，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdHeader.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myHeader.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>使用尖括号 <code>&lt; &gt;</code> 和双引号 <code>&quot; &quot;</code> 的区别在于头文件的搜索路径不同：</p><ul><li>使用尖括号<code>&lt; &gt;</code>，编译器会到环境变量下查找头文件；</li><li>使用双引号<code>&quot; &quot;</code>，编译器首先在当前目录下查找头文件，如果没有找到，再到环境变量下查找。</li></ul><p>注意事项：</p><ul><li>在头文件中尽量不要进行函数的定义，只对其进行声明。否则如果有多个源文件链接时会报错</li><li>某一个头文件的内容发生变化，所有包含该文件的源文件都需要重新编译</li><li>一个<code>#include</code>命令指定一个头文件，多个头文件需要多个<code>#include</code></li><li>包含可以嵌套</li><li>文件 1 包含文件 2，文件 2 用到文件 3，则文件 3 的包含命令#include 应放在文件 1 的头部第一行；</li><li>被包含文件中的静态全局变量不用在包含文件中声明</li></ul><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p><code>#define</code> 叫做宏定义命令，它也是 C 语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就<strong>全部替换成指定的字符串</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  宏名  字符串    <span class="hljs-comment">//基本格式</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100           <span class="hljs-comment">//将所有N都替换成整数100</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> forever for (;;) <span class="hljs-comment">//该语句为无限循环定义了一个新名字forever</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max(A, B) ((A)&gt; (B) ? (A) : (B) )</span><br><br></code></pre></td></tr></table></figure><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>对于函数，其调用必须要将程序执行的顺序跳转到函数所在内存的某个地址，在将函数程序执行完成后，再跳转回去执行函数调用前的地方。这种跳转操作要求在函数执行前保存现场并记录当前执行地址，函数调用返回后要恢复现场，并按原来保存地址继续执行。因此，函数调用会有一定的时间和空间方面的开销，必将影响程序的运行效率。</p><p>对于宏，它只是在预处理的地方<strong>把代码展开</strong>，而不需要额外的空间和时间方面的开销，因此调用宏比调用函数更有效率。</p><p>但是，宏也有很多的问题和缺陷：</p><ul><li>在 C 语言中，宏容易出现一些边界性的问题，容易产生歧义。(优先级的问题，能加括号都加括号)</li><li>在 C++语言中，宏不可以调用 C++类中的私有或受保护的成员。</li></ul><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>能用括号的地方都用括号，不要偷懒省略，以免歧义，特别是于带参宏定义不仅要在参数两侧加括号，还应该在整个字符串外加括号</li><li>宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换</li><li>宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用<code>#undef</code>命令</li><li>代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替</li><li>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换</li><li>习惯上宏名用大写字母表示，以便于与变量区别</li><li>可用宏定义表示数据类型，使书写方便</li><li>带参数的宏和函数很相似，但有本质上的区别：宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，<strong>它没有机会参与编译，也不会占用内存</strong>。而函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。</li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>从上文可知，可以看到宏有一些难以避免的问题，对于不能访问 C++类中私有或者受保护的成员，我们应该如何解决呢？</p><h3 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h3><p>关键字 <code>inline</code> 告诉编译器，任何地方只要调用内联函数，就直接把该函数的机器码插入到调用它的地方。这样程序执行更有效率，就好像将内联函数中的语句直接插入到了源代码文件中需要调用该函数的地方一样。</p><h3 id="why-1"><a href="#why-1" class="headerlink" title="why"></a>why</h3><p>内联函数是代码被插入到调用者代码处的函数。如同 <code>#define</code> 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（过程化集成）被编译器优化。</p><p>内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而<strong>内联函数是通过编译器控制来实现的</strong>。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以像调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>对于内联函数，其工作原理是：</p><p>对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型）。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。在调用一个内联函数时，编译器首先检查调用是否正确（<strong>进行类型安全检查</strong>，或者进行<strong>自动类型转换</strong>，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。</p><p>这个过程与预处理有显著的不同，<strong>因为预处理器不能进行类型安全检查，或者进行自动类型转换</strong>。假如内联函数是成员函数，对象的地址（this）会被放在合适的地方，这也是预处理器办不到的。</p><h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h3><ul><li>当你定义一个内联函数时，在函数定义前加上 <code>inline</code> 关键字，并且将定义放入<strong>头文件</strong>。</li><li>内联函数必须是和函数体声明在一起才有效</li><li>内联函数不宜过大，比如循环体，递归体就不适合内联。如果过大，编译器会放弃内联，采用普通方式调用函数。</li></ul><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><p><a href="https://www.runoob.com/cprogramming/c-preprocessors.html">C 预处理器</a><br><a href="http://c.biancheng.net/view/1878.html">C 语言预处理命令是什么？</a><br><a href="https://developer.aliyun.com/article/632378">C 语言中宏与内联函数解析</a><br><a href="http://c.biancheng.net/view/339.html">C 语言内联函数</a><br><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">内联函数</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 expected &#39;char * const*&#39; but argument is of type &#39;char **&#39;</title>
    <link href="/2021/09/08/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/"/>
    <url>/2021/09/08/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/</url>
    
    <content type="html"><![CDATA[<p>在使用<code>exec</code>系列函数时，<code>execle</code>，<code>execv</code>，<code>execvp</code>三个函数，都可以使用<code>char *arg[]</code>传入启动参数。以下面的程序为例，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-keyword">char</span> *argv[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-literal">NULL</span>&#125;;<br>    ret = execvp(<span class="hljs-string">&quot;ls&quot;</span>,argv);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        perror(<span class="hljs-string">&quot;execl error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译时就会出现一下，警告，</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">expected &#x27;<span class="hljs-built_in">char</span> * <span class="hljs-keyword">const</span>*&#x27; but argument <span class="hljs-keyword">is</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> &#x27;<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> **&#x27;<br></code></pre></td></tr></table></figure><p>因为项目中不允许警告产生，所以编译选项是<code>-Werror</code>，所有警告都会被升级成错误。编译时就会产生如下提示，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ccl : all warnings being treated as errors<br></code></pre></td></tr></table></figure><p>如果是平时练习，改一下编译选项，把这个警告忽略就行，但是现在只能解决。</p><p>出现这个问题就是因为定义数组时<code>char *argv[]</code>类型是<code>char **</code>。但是<code>execvp()</code>函数签名是<code>execvp(const char *file, char *const argv[]);</code>第二个参数的类型是<code>char * const *</code>。</p><p>本以为直接将变量定义更改成<code>char * const argv[]</code>就行了，但是它等价于<code>const char **</code>，所以仍然不能和函数签名匹配。</p><p>实在没办法只能改成如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;entering main process---\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-keyword">char</span> str1[] = <span class="hljs-string">&quot;ls&quot;</span>;<br>    <span class="hljs-keyword">char</span> str2[] = <span class="hljs-string">&quot;-l&quot;</span>;<br>    <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> argv[] = &#123;str1, str2, <span class="hljs-literal">NULL</span>&#125;;<br>    ret = execvp(<span class="hljs-string">&quot;ls&quot;</span>,argv);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        perror(<span class="hljs-string">&quot;execl error&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exiting main process ----\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者在将形参<code>argv</code>进行强制转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;entering main process---\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    ret = execvp(<span class="hljs-string">&quot;ls&quot;</span>,(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> *)argv);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        perror(<span class="hljs-string">&quot;execl error&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exiting main process ----\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 中调试带 Makefile 文件的项目</title>
    <link href="/2021/09/06/VSCode%E4%B8%AD%E8%B0%83%E8%AF%95%E5%B8%A6Makefile%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/09/06/VSCode%E4%B8%AD%E8%B0%83%E8%AF%95%E5%B8%A6Makefile%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>在调试 QEMU 时，自己需要修改源文件，但是每次修改都需要在命令行重新<code>make</code>编译一遍，比较麻烦，想到之前刚刚配置过<code>tasks.json</code>文件，可以把命令行任务配置到文件里，<code>make</code>命令不也一样可以加入吗？修改<code>tasks.json</code>文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>    &#123;<br>       <span class="hljs-comment">//任务的名字方便执行</span><br>      <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;make qemu&quot;</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>      <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>,<br>      <span class="hljs-attr">&quot;args&quot;</span>:[<br>          <span class="hljs-comment">//8 线程编译</span><br>          <span class="hljs-string">&quot;-j8&quot;</span>,<br>      ],<br>      <span class="hljs-attr">&quot;options&quot;</span>: &#123;<br>        <span class="hljs-comment">//切换到 build 文件夹下</span><br>        <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span> <br>      &#125;,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-comment">// 启动 qemu 供调试器连接</span><br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>        <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Run Qemu Server(RISCV)&quot;</span>,<br>        <span class="hljs-comment">//在执行这个任务前，先执行 make qemu 任务、</span><br>        <span class="hljs-comment">//这样就可以在执行调试时，自动先编译一遍</span><br>        <span class="hljs-attr">&quot;dependsOn&quot;</span>: <span class="hljs-string">&quot;make qemu&quot;</span>,<br>        <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;qemu-system-riscv64&quot;</span>,<br>        <span class="hljs-attr">&quot;args&quot;</span>: [<br>            <span class="hljs-string">&quot;-g&quot;</span>,<br>            <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>        ],<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 gcc-multilib : 依赖：gcc-4.8-multilib (&gt;= 4.8.2-5~) 但是它将不会被安装</title>
    <link href="/2021/09/03/%E8%A7%A3%E5%86%B3gcc-multilib-%E4%BE%9D%E8%B5%96-gcc-4-8-multilib-4-8-2-5-%E4%BD%86%E6%98%AF%E5%AE%83%E5%B0%86%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%AE%89%E8%A3%85/"/>
    <url>/2021/09/03/%E8%A7%A3%E5%86%B3gcc-multilib-%E4%BE%9D%E8%B5%96-gcc-4-8-multilib-4-8-2-5-%E4%BD%86%E6%98%AF%E5%AE%83%E5%B0%86%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这是一类问题，不仅限于安装 gcc，这类问题的根本原因在于，<strong>Ubuntu 已安装的软件包版本高，而所安装软件的依赖包版本低</strong>，这样在安装高版软件时，已有的软件包依赖你要安装的软件包，你把软件包升级了，可能就会破坏这个依赖关系，所以<code>apt-get</code>不让你安装。</p><p>这时就要请到大杀器-<code>aptitude</code>，它与 <code>apt-get</code>一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 <code>apt-get</code> 不同的是，<code>aptitude</code>在处理依赖问题上更佳一些。举例来说，<code>aptitude</code>在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$sudo</span> apt-get install aptitude  <span class="hljs-regexp">//</span>安装aptitude包管理器<br><span class="hljs-variable">$sudo</span> aptitude install gcc-multilib <span class="hljs-regexp">//</span>用新的包管理器安装你要安装的软件<br></code></pre></td></tr></table></figure><p>安装<code>gcc-multilib</code>时会把所有依赖包一并安装，此时会让你同意，选择<code>n</code>就行。</p><p>接下来就会解决已经安装的包之间的依赖关系，他会降级或升级一些软件包来匹配当前安装的软件版本，此时选择<code>y</code>。</p><p>完成以上操作，再次正常安装需要的软件包即可成功安装。</p><p>如果无法正常安装，重复以上操作，每次都选择<code>n</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 fatal error: bits/libc-header-start.h：no such file</title>
    <link href="/2021/09/03/%E8%A7%A3%E5%86%B3fatal-error-bits-libc-header-start-h%EF%BC%9Ano-such-file/"/>
    <url>/2021/09/03/%E8%A7%A3%E5%86%B3fatal-error-bits-libc-header-start-h%EF%BC%9Ano-such-file/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>想要分别编译 32 位和 64 位的程序时，gcc 出现了错误，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">In <span class="hljs-keyword">file</span> included <span class="hljs-keyword">from</span> func_call.c:<span class="hljs-number">1</span>:<br><span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/stdio.h:27:10: fatal error: bits/</span>libc-header-start.h: 没有那个文件或目录<br>   <span class="hljs-number">27</span> | #<span class="hljs-keyword">include</span> &lt;bits/libc-header-start.h&gt;<br>      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~<br>compilation terminated.<br></code></pre></td></tr></table></figure><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>问题原因猜测是默认 gcc 只提供当前机器的版本，解决如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">install</span> gcc-multilib<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
      <tag>汇编语言</tag>
      
      <tag>GCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU 源码分析-虚拟 CPU 创建</title>
    <link href="/2021/09/01/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9FCPU%E5%88%9B%E5%BB%BA/"/>
    <url>/2021/09/01/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9FCPU%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>先开个头吧，把创建流程稍微捋一下，找到创建虚拟 CPU 的模块。至于中间的流程还没有详细分析，万事开头难，先上手再说吧。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210901182329.svg"></p><h2 id="qemu-add-opts解析-qemu-的命令行"><a href="#qemu-add-opts解析-qemu-的命令行" class="headerlink" title="qemu_add_opts解析 qemu 的命令行"></a><code>qemu_add_opts</code>解析 qemu 的命令行</h2><p><code>qemu_init</code>函数中下面这一长串内容，就是在解析命令行的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu drive opts)</span></span>;<br><span class="hljs-function">qemu add drive <span class="hljs-title">opts</span><span class="hljs-params">(&amp;qemu Legacy drive opts)</span></span>;<br><span class="hljs-function">qemu add drive <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu common drive opts)</span></span>;<br><span class="hljs-function">qemu add drive <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu drive opts)</span></span>;<br><span class="hljs-function">qemu add drive <span class="hljs-title">opts</span> <span class="hljs-params">(sbdry runtime opts)</span></span>;<br><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(qemu chardev opts)</span></span>;<br><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu device opts)</span></span>;<br><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu netdev opts)</span></span>;<br><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu nic opts)</span></span>;<br><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(sqemu net opts</span></span><br><span class="hljs-params"><span class="hljs-function">qemu add opts (&amp;qemu rtc opts)</span></span><br><span class="hljs-params"><span class="hljs-function">qemu add opts (&amp;qemu global_opts);</span></span><br><span class="hljs-params"><span class="hljs-function">qemu add opts (&amp;qemu mon opts);</span></span><br><span class="hljs-params"><span class="hljs-function">qemu add opts (sqemu trace opts);</span></span><br><span class="hljs-params"><span class="hljs-function">.</span></span><br><span class="hljs-params"><span class="hljs-function">.</span></span><br><span class="hljs-params"><span class="hljs-function">.</span></span><br></code></pre></td></tr></table></figure><p>为什么有这么多的 <code>opts</code>呢？这是因为，实际运行中创建的<code>kvm</code>参数会复杂<code>N</code>倍。这里我们贴一个开源云平台软件 <code>OpenStack</code> 创建出来的<code>KVM</code>的参数，如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-system-x86_64<br>-enable-kvm<br>-name instance-00000024<br>-machine pc-i440fx-trusty,accel=kvm,usb=off<br>-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme<br>-m 2048<br>-smp 1,sockets=1,cores=1,threads=1<br>......<br>-rtc base=utc,driftfix=slew<br>-drive file=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if=none,id=drive-virtio-disk0,format=qcow2,cache=none<br>-device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x4,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1<br>-netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37<br>-device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3<br>-chardev file,id=charserial0,path=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/console.log<br>-vnc 0.0.0.0:12<br>-device cirrus-vga,id=video0,bus=pci.0,addr=0x2<br></code></pre></td></tr></table></figure><ul><li><p><code>-enable-kvm</code>：表示启用硬件辅助虚拟化。</p></li><li><p><code>-name instance-00000024</code>：表示虚拟机的名称。</p></li><li><p><code>-machine pc-i440fx-trusty,accel=kvm,usb=off</code>：machine 是什么呢？其实就是计算机体系结构。不知道什么是体系结构的话，可以订阅极客时间的另一个专栏《深入浅出计算机组成原理》。<br>qemu 会模拟多种体系结构，常用的有普通 PC 机，也即 x86 的 32 位或者 64 位的体系结构、Mac 电脑 PowerPC 的体系结构、Sun 的体系结构、MIPS 的体系结构，精简指令集。如果使用 KVM hardware-assisted virtualization，也即 BIOS 中 VD-T 是打开的，则参数中 <code>accel=kvm</code>。如果不使用 <code>hardware-assisted virtualization</code>，用的是纯模拟，则有参数 <code>accel = tcg</code>，<code>-no-kvm</code>。</p></li><li><p><code>-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme</code>：表示设置 CPU，SandyBridge 是 Intel 处理器，后面的加号都是添加的 CPU 的参数，这些参数会显示在 /proc/cpuinfo 里面。</p></li><li><p><code>-m 2048</code>：表示内存。</p></li><li><p><code>-smp 1,sockets=1,cores=1,threads=1</code>：<code>SMP</code> 我们解析过，叫对称多处理器，和<code>NUMA</code> 对应。qemu 仿真了一个具有 1 个 <code>vcpu</code>，一个 <code>socket</code>，一个 <code>core</code>，一个 <code>threads</code> 的处理器。<br><code>socket</code>、<code>core</code>、<code>threads</code> 是什么概念呢？<code>socket</code> 就是主板上插 CPU 的槽的数目，也即常说的“路”，<code>core</code> 就是我们平时说的“核”，即双核、4 核等。<code>thread</code> 就是每个 core 的硬件线程数，即超线程。举个具体的例子，某个服务器是：2 路 4 核超线程（一般默认为 2 个线程），通过 <code>cat /proc/cpuinfo</code>，我们看到的是 242=16 个<code>processor</code>，很多人也习惯成为 16 核了。</p></li><li><p><code>-rtc base=utc,driftfix=slew</code>：表示系统时间由参数 <code>-rtc</code> 指定。</p></li><li><p><code>-device cirrus-vga,id=video0,bus=pci.0,addr=0x2</code>：表示显示器用参数 <code>-vga</code> 设置，默认为 <code>cirrus</code>，它模拟了 <code>CL-GD5446PCI VGA card</code>。</p></li><li><p>有关网卡，使用 <code>-net</code> 参数和 <code>-device</code>。</p></li><li><p>从 HOST 角度：<code>-netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37</code>。</p></li><li><p>从 GUEST 角度：<code>-device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3</code>。</p></li><li><p>有关硬盘，使用 <code>-hda -hdb</code>，或者使用 <code>-drive</code> 和 <code>-device</code>。</p></li><li><p>从 HOST 角度：<code>-drive file=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if=none,id=drive-virtio-disk0,format=qcow2,cache=none</code></p></li><li><p>从 GUEST 角度：<code>-device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x4,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1</code></p></li><li><p><code>-vnc 0.0.0.0:12</code>：设置 VNC。</p></li></ul><h2 id="module-call-init初始化所有模块"><a href="#module-call-init初始化所有模块" class="headerlink" title="module_call_init初始化所有模块"></a><code>module_call_init</code>初始化所有模块</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">--&gt; <span class="hljs-title">qemu_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">--&gt; <span class="hljs-title">qemu_init_subsystems</span><span class="hljs-params">()</span></span><br><span class="hljs-function">--&gt; <span class="hljs-title">module_call_init</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>当虚拟机真的要使用物理资源的时候，对下面的物理机上的资源要进行请求，所以它的工作模式有点儿类似操作系统对接驱动。驱动要符合一定的格式，才能算操作系统的一个模块。同理，qemu 为了模拟各种各样的设备，也需要管理各种各样的模块，这些模块也需要符合一定的格式。</p><p>定义一个 qemu 模块会调用 <code>type_init</code>。例如，<code>kvm</code> 的模块要在 <code>accel/kvm/kvm-all.c</code> 文件里面实现。在这个文件里面，有一行下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo kvm_accel_type = &#123;<br>    .name = TYPE_KVM_ACCEL,<br>    .parent = TYPE_ACCEL,<br>    .instance_init = kvm_accel_instance_init,<br>    .class_init = kvm_accel_class_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(KVMState),<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_type_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    type_register_static(&amp;kvm_accel_type);<br>&#125;<br><br>type_init(kvm_type_init);<br></code></pre></td></tr></table></figure><p>找到<code>type_init</code>的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> type_init(function) module_init(function, MODULE_INIT_QOM)</span><br></code></pre></td></tr></table></figure><p>从代码里面的定义我们可以看出来，<code>type_init</code> 后面的参数是一个函数，调用 <code>type_init</code> 就相当于调用 <code>module_init</code>，在这里函数就是 <code>kvm_type_init</code>，类型就是 <code>MODULE_INIT_QOM</code>。</p><p>再查看一下<code>module_init</code>的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//include/qemu/module.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> module_init(function, type)                                         \</span><br><span class="hljs-meta">static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \</span><br><span class="hljs-meta">&#123;                                                                           \</span><br><span class="hljs-meta">    register_module_init(function, type);                                   \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><p><code>module_init</code> 最终要调用 <code>register_module_init</code>。属于 <code>MODULE_INIT_QOM</code> 这种类型的，有一个 <code>Module</code> 列表 <code>ModuleTypeList</code>，列表里面是一项一项的 <code>ModuleEntry</code>。<code>KVM</code> 就是其中一项，并且会初始化每一项的 <code>init</code> 函数为参数表示的函数 <code>fn</code>，也即 <code>KVM</code> 这个 <code>module</code> 的 <code>init</code> 函数就是 <code>kvm_type_init</code>。</p><p>当然，<code>MODULE_INIT_QOM</code> 这种类型会有很多很多的 <code>module</code>，从后面的代码我们可以看到，所有调用 <code>type_init</code> 的地方都注册了一个 <code>MODULE_INIT_QOM</code> 类型的 <code>Module</code>。</p><p>了解了 <code>Module</code> 的注册机制，我们继续回到 <code>qemu_init_subsystems</code> 函数中 <code>module_call_init</code> 的调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qemu_init_subsystems</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    Error *err;<br>    os_set_line_buffering();<br>    module_call_init(MODULE_INIT_TRACE);<br>    qemu_init_cpu_list();<br>    qemu_init_cpu_loop();<br>    qemu_mutex_lock_iothread();<br>    atexit(qemu_run_exit_notifiers);<br>    module_call_init(MODULE_INIT_QOM);<br>    module_call_init(MODULE_INIT_MIGRATION);<br>.<br>.<br>.<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// utils/module.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">module_call_init</span><span class="hljs-params">(module_init_type type)</span></span><br><span class="hljs-function"></span>&#123;<br>    ModuleTypeList *l;<br>    ModuleEntry *e;<br>    l = find_type(type);<br>    QTAILQ_FOREACH(e, l, node) &#123;<br>        e-&gt;init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>module_call_init</code> 中，我们会找到 <code>MODULE_INIT_QOM</code> 这种类型对应的 <code>ModuleTypeList</code>，找出列表中所有的 <code>ModuleEntry</code>，然后调用每个 <code>ModuleEntry</code> 的 <code>init</code> 函数。这里需要注意的是，在 <code>module_call_init</code> 调用的这一步，所有 <code>Module</code> 的 <code>init</code> 函数都已经被调用过了。</p><p>后面我们会看到很多的 <code>Module</code>，当我们后面再次遇到时，需要意识到，它的 <code>init</code> 函数在这里也被调用过了。这里我们还是以对于 <code>kvm</code> 这个 <code>module</code> 为例子，看看它的 <code>init</code> 函数都做了哪些事情。我们会发现，其实它调用的是 <code>kvm_type_init</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_type_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    type_register_static(&amp;kvm_accel_type);<br>&#125;<br><span class="hljs-function">TypeImpl *<span class="hljs-title">type_register_static</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> type_register(info);<br>&#125;<br><span class="hljs-function">TypeImpl *<span class="hljs-title">type_register</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(info-&gt;parent);<br>    <span class="hljs-keyword">return</span> type_register_internal(info);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> TypeImpl *<span class="hljs-title">type_register_internal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    TypeImpl *ti;<br>    ti = type_new(info);<br> <br>    type_table_add(ti);<br>    <span class="hljs-keyword">return</span> ti;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> TypeImpl *<span class="hljs-title">type_new</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    TypeImpl *ti = g_malloc0(<span class="hljs-keyword">sizeof</span>(*ti));<br>    <span class="hljs-keyword">int</span> i;<br> <br>    <span class="hljs-keyword">if</span> (type_table_lookup(info-&gt;name) != <span class="hljs-literal">NULL</span>) &#123;<br>    &#125;<br>    ti-&gt;name = g_strdup(info-&gt;name);<br>    ti-&gt;parent = g_strdup(info-&gt;parent);<br>    ti-&gt;class_size = info-&gt;class_size;<br>    ti-&gt;instance_size = info-&gt;instance_size;<br>    ti-&gt;class_init = info-&gt;class_init;<br>    ti-&gt;class_base_init = info-&gt;class_base_init;<br>    ti-&gt;class_data = info-&gt;class_data;<br>    ti-&gt;instance_init = info-&gt;instance_init;<br>    ti-&gt;instance_post_init = info-&gt;instance_post_init;<br>    ti-&gt;instance_finalize = info-&gt;instance_finalize;<br>    ti-&gt;abstract = info-&gt;abstract;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; info-&gt;interfaces &amp;&amp; info-&gt;interfaces[i].type; i++) &#123;<br>        ti-&gt;interfaces[i].<span class="hljs-keyword">typename</span> = g_strdup(info-&gt;interfaces[i].type);<br>    &#125;<br>    ti-&gt;num_interfaces = i;<br>    <span class="hljs-keyword">return</span> ti;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">type_table_add</span><span class="hljs-params">(TypeImpl *ti)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(!enumerating_types);<br>    g_hash_table_insert(type_table_get(), (<span class="hljs-keyword">void</span> *)ti-&gt;name, ti);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> GHashTable *<span class="hljs-title">type_table_get</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> GHashTable *type_table;<br> <br>    <span class="hljs-keyword">if</span> (type_table == <span class="hljs-literal">NULL</span>) &#123;<br>        type_table = g_hash_table_new(g_str_hash, g_str_equal);<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> type_table;<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo kvm_accel_type = &#123;<br>    .name = TYPE_KVM_ACCEL,<br>    .parent = TYPE_ACCEL,<br>    .class_init = kvm_accel_class_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(KVMState),<br>&#125;;<br></code></pre></td></tr></table></figure><p>调用流程如下：虚线表示返回</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210907133931.svg"></p><p>每一个 <code>Module</code> 既然要模拟某种设备，那应该定义一种类型 <code>TypeImpl</code> 来表示这些设备，这其实是一种<code>面向对象编程</code>的思路，只不过这里用的是纯 C 语言的实现，所以需要变相实现一下类和对象。</p><p><code>kvm_type_init</code> 会注册 <code>kvm_accel_type</code>，定义上面的代码，我们可以认为这样动态定义了一个类。这个类的名字是 <code>TYPE_KVM_ACCEL</code>，这个类有父类 <code>TYPE_ACCEL</code>，这个类的初始化应该调用函数 <code>kvm_accel_class_init</code>。如果用这个类声明一个对象，对象的大小应该是 <code>instance_size</code>。</p><p>在 <code>type_register_internal</code> 中，我们会根据 <code>kvm_accel_type</code> 这个 <code>TypeInfo</code>，创建一个<code>TypeImpl</code> 来表示这个新注册的类，也就是说，<code>TypeImpl</code> 才是我们想要声明的那个 <code>class</code>。在 qemu 里面，有一个全局的哈希表 <code>type_table</code>，用来存放所有定义的类。在 <code>type_new</code> 里面，我们先从全局表里面根据名字<code>type_table_lookup</code>查找找这个类。如果找到，说明这个类曾经被注册过，就报错；如果没有找到，说明这是一个新的类，则将 <code>TypeInfo</code> 里面信息填到 <code>TypeImpl</code> 里面。<code>type_table_add</code> 会将这个类注册到全局的表里面。到这里，我们注意，<code>class_init</code> 还没有被调用，也即这个类现在还处于纸面的状态。</p><p>这点更加像 Java 的反射机制了。在 Java 里面，对于一个类，首先我们写代码的时候要写一个 <code>class xxx</code> 的定义，编译好就放在<code>.class</code> 文件中，这也是出于纸面的状态。然后，Java 会有一个 <code>Class</code> 对象，用于读取和表示这个纸面上的 <code>class xxx</code>，可以生成真正的对象。</p><p>相同的过程在后面的代码中我们也可以看到，<code>class_init</code> 会生成<code>XXXClass</code>，就相当于 Java 里面的 <code>Class</code>对象，<code>TypeImpl</code> 还会有一个 <code>instance_init</code> 函数，相当于构造函数，用于根据 <code>XXXClass</code> 生成 <code>Object</code>，这就相当于 Java 反射里面最终创建的对象。和构造函数对应的还有 <code>instance_finalize</code>，相当于析构函数。</p><p>这一套反射机制放在 <code>qom</code> 文件夹下面，全称 <code>QEMU Object Model</code>，也即用 C 实现了一套<strong>面向对象的反射机制</strong>。</p><h2 id="初始化-machine"><a href="#初始化-machine" class="headerlink" title="初始化 machine"></a>初始化 machine</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210913115046.svg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vl.c</span><br>qemu_create_machine (select_machine());<br></code></pre></td></tr></table></figure><p>在创建 machine 之前，先要通过<code>select_machine</code>确定一个<code>machine</code>。<code>select_machine</code>又是怎么确定的呢，这就和我们命令行的输入有关，比如我们<code>-m spike</code>，那么这里就会选择<code>spike</code>作为<code>machine</code>。它的定义在<code>hw/riscv/spike.c</code>中。</p><p>在源码最后有这么一句，会和我们上面解析的<code>type_init</code> 是一样的，在全局的表里面注册了一个全局的名字是<code>spike</code>的纸面上的 <code>class</code>，也即 <code>TypeImpl</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">type_init(spike_machine_init_reqister_types)<br></code></pre></td></tr></table></figure><p>现在全局表中有这个纸面上的 <code>class</code> 了。我们回到 <code>select_machine</code>。</p><p>在 <code>select_machine</code> 中，有两种方式可以生成 <code>MachineClass</code>。一种方式是 <code>find_default_machine</code>，找一个默认的；另一种方式是 <code>machine_parse</code>，通过解析参数生成 <code>MachineClass</code>。无论哪种方式，都会调用 <code>object_class_get_list</code> 获得一个 <code>MachineClass</code> 的列表，然后在里面找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> MachineClass *<span class="hljs-title">select_machine</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    GSList *machines = object_class_get_list(TYPE_MACHINE, <span class="hljs-literal">false</span>);<br>    MachineClass *machine_class = find_default_machine(machines);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optarg;<br>    QemuOpts *opts;<br>    Location loc;<br>    loc_push_none(&amp;loc);<br>    opts = qemu_get_machine_opts();<br>    qemu_opts_loc_restore(opts);<br>    optarg = qemu_opt_get(opts, <span class="hljs-string">&quot;type&quot;</span>);<br>    <span class="hljs-keyword">if</span> (optarg) &#123;<br>        machine_class = machine_parse(optarg, machines);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!machine_class) &#123;<br>        error_report(<span class="hljs-string">&quot;No machine specified, and there is no default&quot;</span>);<br>        error_printf(<span class="hljs-string">&quot;Use -machine help to list supported machines\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    loc_pop(&amp;loc);<br>    g_slist_free(machines);<br>    <span class="hljs-keyword">return</span> machine_class;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> MachineClass *<span class="hljs-title">find_default_machine</span><span class="hljs-params">(GSList *machines)</span></span><br><span class="hljs-function"></span>&#123;<br>    GSList *el;<br>    MachineClass *default_machineclass = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (el = machines; el; el = el-&gt;next) &#123;<br>        MachineClass *mc = el-&gt;data;<br><br>        <span class="hljs-keyword">if</span> (mc-&gt;is_default) &#123;<br>            assert(default_machineclass == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-string">&quot;Multiple default machines&quot;</span>);<br>            default_machineclass = mc;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> default_machineclass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> MachineClass *<span class="hljs-title">machine_parse</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, GSList *machines)</span></span><br><span class="hljs-function"></span>&#123;<br>    MachineClass *mc;<br>    GSList *el;<br>    <span class="hljs-keyword">if</span> (is_help_option(name)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Supported machines are:\n&quot;</span>);<br>        machines = g_slist_sort(machines, machine_class_cmp);<br>        <span class="hljs-keyword">for</span> (el = machines; el; el = el-&gt;next) &#123;<br>            MachineClass *mc = el-&gt;data;<br>            <span class="hljs-keyword">if</span> (mc-&gt;alias) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-20s %s (alias of %s)\n&quot;</span>, mc-&gt;alias, mc-&gt;desc, mc-&gt;name);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-20s %s%s%s\n&quot;</span>, mc-&gt;name, mc-&gt;desc,<br>                   mc-&gt;is_default ? <span class="hljs-string">&quot; (default)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>                   mc-&gt;deprecation_reason ? <span class="hljs-string">&quot; (deprecated)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    mc = find_machine(name, machines);<br>    <span class="hljs-keyword">if</span> (!mc) &#123;<br>        error_report(<span class="hljs-string">&quot;unsupported machine type&quot;</span>);<br>        error_printf(<span class="hljs-string">&quot;Use -machine help to list supported machines\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mc;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>object_class_get_list</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">GSList *<span class="hljs-title">object_class_get_list</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *implements_type,<span class="hljs-keyword">bool</span> include_abstract)</span></span><br><span class="hljs-function"></span>&#123;<br>    GSList *<span class="hljs-built_in">list</span> = <span class="hljs-literal">NULL</span>;<br>    object_class_foreach(object_class_get_list_tramp,<br>                         implements_type, include_abstract, &amp;<span class="hljs-built_in">list</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">object_class_foreach</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*fn)(ObjectClass *klass, <span class="hljs-keyword">void</span> *opaque),</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *implements_type, <span class="hljs-keyword">bool</span> include_abstract,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">void</span> *opaque)</span></span><br><span class="hljs-function"></span>&#123;<br>    OCFData data = &#123; fn, implements_type, include_abstract, opaque &#125;;<br><br>    enumerating_types = <span class="hljs-literal">true</span>;<br>    g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &amp;data);<br>    enumerating_types = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在全局表 <code>type_table_get()</code> 中，对于每一项 <code>TypeImpl</code>，我们都执行 <code>object_class_foreach_tramp</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">object_class_foreach_tramp</span><span class="hljs-params">(gpointer key, gpointer value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       gpointer opaque)</span></span><br><span class="hljs-function"></span>&#123;<br>    OCFData *data = opaque;<br>    TypeImpl *type = value;<br>    ObjectClass *k;<br>    type_initialize(type);<br>    k = type-&gt;class;<br>    <span class="hljs-keyword">if</span> (!data-&gt;include_abstract &amp;&amp; type-&gt;abstract) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (data-&gt;implements_type &amp;&amp; <br>        !object_class_dynamic_cast(k, data-&gt;implements_type)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    data-&gt;fn(k, data-&gt;opaque);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>object_class_foreach_tramp</code> 中，会调用将 <code>type_initialize</code>，这里面会调用 <code>class_init</code> 将纸面上的 <code>class</code> 也即 <code>TypeImpl</code> 变为 <code>ObjectClass</code>，<code>ObjectClass</code> 是所有<code>Class</code> 类的祖先，<code>MachineClass</code> 是它的子类。</p><p>因为在 <code>machine</code> 的命令行里面，我们指定了名字为<code>spike</code>，就肯定能够找到我们注册过了的 <code>TypeImpl</code>，并调用它的 <code>class_init</code> 函数。</p><p>所以，当 <code>select_machine</code> 执行完毕后，就有一个 <code>MachineClass</code> 了。</p><p>接着，我们回到 <code>qemu_create_machine</code> 中的<code>object_new_with_class</code>。这就很好理解了，<code>MachineClass</code> 是一个 <code>Class</code> 类，接下来应该通过它生成一个 <code>Instance</code>，也即对象，这就是 <code>object_new_with_class</code> 的作用。</p><p><code>object_new_with_class</code> 中，<code>TypeImpl</code> 的 <code>instance_init</code> 会被调用，创建一个对象。<code>current_machine</code> 就是这个对象，它的类型是<code>MachineState</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">Object *<span class="hljs-title">object_new_with_class</span><span class="hljs-params">(ObjectClass *klass)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> object_new_with_type(klass-&gt;type);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> Object *<span class="hljs-title">object_new_with_type</span><span class="hljs-params">(Type type)</span></span><br><span class="hljs-function"></span>&#123;<br>    Object *obj;<br>    type_initialize(type);<br>    obj = g_malloc(type-&gt;instance_size);<br>    object_initialize_with_type(obj, type-&gt;instance_size, type);<br>    obj-&gt;<span class="hljs-built_in">free</span> = g_free;<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，绕了这么大一圈，有关体系结构的对象才创建完毕，接下来很多的设备的初始化，包括 CPU 和内存的初始化，都是围绕着体系结构的对象来的，后面我们会常常看到<code>current_machine</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220308180036.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/nm90/p/15661202.html">Qemu CPU 虚拟化 - 人生一世，草木一秋。 - 博客园</a><br><a href="https://www.cnblogs.com/LoyenWang/p/13796537.html">【原创】Linux 虚拟化 KVM-Qemu 分析（四）之 CPU 虚拟化（2） - LoyenWang - 博客园</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU 源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 文件系统</title>
    <link href="/2021/08/31/Qt%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/31/Qt%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>Qt 通过<code>QIODevice</code>提供了对 <code>I/O</code> 设备的抽象，这些设备具有读写字节块的能力。下面是 <code>I/O</code> 设备的类图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210831200940.png"></p><p>图中所涉及的类及其用途简要说明如下：</p><p><code>QIODevice</code>：所有<code>I/O</code>设备类的父类，提供了字节块读写的通用操作以及基本接口；<br><code>QFlie</code>：访问本地文件或者嵌入资源；<br><code>QTemporaryFile</code>：创建和访问本地文件系统的临时文件；<br><code>QBuffer</code>：读写<code>QByteArray</code>；<br><code>QProcess</code>：运行外部程序，处理进程间通讯；<br><code>QAbstractSocket</code>：所有套接字类的父类；<br><code>QTcpSocket</code>：<code>TCP</code>协议网络数据传输；<br><code>QUdpSocket</code>：传输 <code>UDP</code> 报文；<br><code>QSslSocket</code>：使用 <code>SSL/TLS</code> 传输数据；<br><code>QFileDevice</code>：Qt5 新增加的类，提供了有关文件操作的通用实现。</p><h2 id="QFile-及其相关类"><a href="#QFile-及其相关类" class="headerlink" title="QFile 及其相关类"></a>QFile 及其相关类</h2><p>我们通常会将文件路径作为参数传给<code>QFile</code>的构造函数。不过也可以在创建好对象最后，使用<code>setFileName()</code>来修改。<code>QFile</code>需要使用<code>/</code>作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如<code>C:/windows</code>这样的路径在 Windows 平台下同样是可以的。</p><p><code>QFile</code>主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。我们可以使用<code>QDataStream</code>或<code>QTextStream</code>类来读写文件，也可以使用<code>QIODevice</code>类提供的<code>read()</code>、<code>readLine()</code>、<code>readAll()</code>以及<code>write()</code>这样的函数。值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过<code>QFileInfo</code>获取，而不是自己分析文件路径字符串。</p><p>在这段代码中，我们首先使用<code>QFile</code>创建了一个文件对象。这个文件名字是 <code>test.txt</code>。只要将这个文件放在同执行路径一致的目录下即可。可以使用<code>QDir::currentPath()</code>来获得应用程序执行时的当前路径。只要将这个文件放在与当前路径一致的目录下即可。然后，我们使用<code>open()</code>函数打开这个文件，打开形式是只读方式，文本格式。这个类似于<code>fopen()</code>的 <code>r</code> 这样的参数。<code>open()</code>函数返回一个 <code>bool</code> 类型，如果打开失败，我们在控制台输出一段提示然后程序退出。否则，我们利用 <code>while</code> 循环，将每一行读到的内容输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QWidget&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDebug&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QFile&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QFileInfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;test.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text))<br>    &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Open file failed.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (!file.<span class="hljs-built_in">atEnd</span>())<br>        &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; file.<span class="hljs-built_in">readLine</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">QFileInfo <span class="hljs-title">info</span><span class="hljs-params">(file)</span></span>;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">isDir</span>();            <span class="hljs-comment">//false</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">isExecutable</span>();     <span class="hljs-comment">//false</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">baseName</span>();         <span class="hljs-comment">//test</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">completeBaseName</span>(); <span class="hljs-comment">//test.txt</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">suffix</span>();           <span class="hljs-comment">//txt</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">completeSuffix</span>();   <span class="hljs-comment">//txt</span><br><br>    <span class="hljs-function">QFileInfo <span class="hljs-title">fi</span><span class="hljs-params">(<span class="hljs-string">&quot;/tmp/archive.tar.gz&quot;</span>)</span></span>;<br>    QString base = fi.<span class="hljs-built_in">baseName</span>();          <span class="hljs-comment">// base = &quot;archive&quot;</span><br>    QString cbase = fi.<span class="hljs-built_in">completeBaseName</span>(); <span class="hljs-comment">// base = &quot;archive.tar&quot;</span><br>    QString ext = fi.<span class="hljs-built_in">suffix</span>();             <span class="hljs-comment">// ext = &quot;gz&quot;</span><br>    QString ext = fi.<span class="hljs-built_in">completeSuffix</span>();     <span class="hljs-comment">// ext = &quot;tar.gz&quot;</span><br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h2><p>本节，我们将学习<code>QDataStream</code>的使用以及一些技巧。</p><p><code>QDataStream</code>提供了基于<code>QIODevice</code>的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、CPU 或者字节顺序（大端或小端）。例如，在安装了 Windows 平台的 PC 上面写入的一个数据流，可以不经过任何处理，直接拿到运行了 Solaris 的 SPARC 机器上读取。由于数据流就是二进制流，因此我们也可以直接读写没有编码的二进制数据，例如图像、视频、音频等。</p><p><code>QDataStream</code>既能够存取 <code>C++</code> 基本类型，如 <code>int</code>、<code>char</code>、<code>short</code> 等，也可以存取复杂的数据类型，例如自定义的类。实际上，<code>QDataStream</code>对于类的存储，是将复杂的类分割为很多基本单元实现的。</p><p>结合<code>QIODevice</code>，<code>QDataStream</code>可以很方便地对文件、网络套接字等进行读写操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<br><span class="hljs-function">QDataStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;file)</span></span>;<br>out &lt;&lt; <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;the answer is&quot;</span>);<br>out &lt;&lt; (qint32)<span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure><p>在这段代码中，我们首先打开一个名为 file.dat 的文件（注意，我们为简单起见，并没有检查文件打开是否成功，这在正式程序中是不允许的）。然后，我们将刚刚创建的<code>file</code>对象的指针传递给一个<code>QDataStream</code>实例<code>out</code>。类似于<code>std::cout</code>标准输出流，<code>QDataStream</code>也重载了输出重定向&lt;&lt;运算符。后面的代码就很简单了：将<code>“the answer is”</code>和数字<code>42</code>输出到数据流（如果你不明白这句话的意思，这可是宇宙终极问题的答案，请自行搜索《银河系漫游指南》）。由于我们的 <code>out</code> 对象建立在<code>file</code>之上，因此相当于将宇宙终极问题的答案写入<code>file</code>。</p><p>需要指出一点：最好使用<code>Qt</code>整型来进行读写，比如程序中的<code>qint32</code>。这保证了在任意平台和任意编译器都能够有相同的行为。</p><p>我们通过一个例子来看看 <code>Qt</code> 是如何存储数据的。例如<code>char *</code>字符串，在存储时，会首先存储该字符串包括<code>\0</code>结束符的长度（32位整型），然后是字符串的内容以及结束符<code>\0</code>。在读取时，先以<code>32</code>位整型读出整个的长度，然后按照这个长度取出整个字符串的内容。</p><p>但是，如果你直接运行这段代码，你会得到一个空白的 <code>file.dat</code>，并没有写入任何数据。这是因为我们的<code>file</code>没有正常关闭。为性能起见，数据只有在文件关闭时才会真正写入。因此，我们必须在最后添加一行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">file.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 如果不想关闭文件，可以使用 file.flush();</span><br></code></pre></td></tr></table></figure><p>重新运行一下程序，你就得到宇宙终极问题的答案了。</p><p>我们已经获得宇宙终极问题的答案了，下面，我们要将这个答案读取出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br><span class="hljs-function">QDataStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;<br>QString str;<br>qint32 a;<br>in &gt;&gt; str &gt;&gt; a;<br></code></pre></td></tr></table></figure><p>这段代码没什么好说的。唯一需要注意的是，你必须按照写入的顺序，将数据读取出来。也就是说，程序数据写入的顺序必须预先定义好。在这个例子中，我们首先写入字符串，然后写入数字，那么就首先读出来的就是字符串，然后才是数字。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。</p><p>由于二进制流是纯粹的字节数据，带来的问题是，如果程序不同版本之间按照不同的方式读取（前面说过，<code>Qt</code> 保证读写内容的一致，但是并不能保证不同 <code>Qt</code> 版本之间的一致），数据就会出现错误。因此，我们必须提供一种机制来确保不同版本之间的一致性。通常，我们会使用如下的代码写入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<br><span class="hljs-function">QDataStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;file)</span></span>;<br><br><span class="hljs-comment">// 写入魔术数字和版本</span><br>out &lt;&lt; (quint32)<span class="hljs-number">0xA0B0C0D0</span>;<br>out &lt;&lt; (qint32)<span class="hljs-number">123</span>;<br><br>out.<span class="hljs-built_in">setVersion</span>(QDataStream::Qt_4_0);<br><br><span class="hljs-comment">// 写入数据</span><br>out &lt;&lt; lots_of_interesting_data;<br></code></pre></td></tr></table></figure><p>所谓魔术数字，是二进制输出中经常使用的一种技术。二进制格式是人不可读的，并且通常具有相同的后缀名（比如 <code>dat</code> 之类），因此我们没有办法区分两个二进制文件哪个是合法的。所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性。在本例中，我们在文件最开始写入 <code>0xA0B0C0D0</code>，在读取的时候首先检查这个数字是不是 <code>0xA0B0C0D0</code>。如果不是的话，说明这个文件不是可识别格式，因此根本不需要去继续读取。一般二进制文件都会有这么一个魔术数字，例如 <code>Java</code> 的 <code>class</code> 文件的魔术数字就是 <code>0xCAFEBABE</code>，使用二进制查看器就可以查看。魔术数字是一个 <code>32</code> 位的无符号整型，因此我们使用<code>quint32</code>来得到一个平台无关的 <code>32</code> 位无符号整型。</p><p><code>out &lt;&lt; (qint32)123</code>是标识文件的版本。我们用魔术数字标识文件的类型，从而判断文件是不是合法的。但是，文件的不同版本之间也可能存在差异：我们可能在第一版保存整型，第二版可能保存字符串。为了标识不同的版本，我们只能将版本写入文件。比如，现在我们的版本是 <code>123</code>。</p><p><code>out.setVersion(QDataStream::Qt_4_0)</code>上面一句是文件的版本号，但是，<code>Qt</code>不同版本之间的读取方式可能也不一样。这样，我们就得指定<code>Qt</code> 按照哪个版本去读。这里，我们指定以<code>Qt 4.0</code> 格式去读取内容。</p><p>当我们这样写入文件之后，我们在读取的时候就需要增加一系列的判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br><span class="hljs-function">QDataStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;<br><br><span class="hljs-comment">// 检查魔术数字</span><br>quint32 magic;<br>in &gt;&gt; magic;<br><span class="hljs-keyword">if</span> (magic != <span class="hljs-number">0xA0B0C0D0</span>) <br>&#123;<br>    <span class="hljs-keyword">return</span> BAD_FILE_FORMAT;<br>&#125;<br><br><span class="hljs-comment">// 检查版本</span><br>qint32 version;<br>in &gt;&gt; version;<br><span class="hljs-keyword">if</span> (version &lt; <span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">return</span> BAD_FILE_TOO_OLD;<br>&#125;<br><span class="hljs-keyword">if</span> (version &gt; <span class="hljs-number">123</span>) &#123;<br>    <span class="hljs-keyword">return</span> BAD_FILE_TOO_NEW;<br>&#125;<br><br><span class="hljs-keyword">if</span> (version &lt;= <span class="hljs-number">110</span>) &#123;<br>    in.<span class="hljs-built_in">setVersion</span>(QDataStream::Qt_3_2);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    in.<span class="hljs-built_in">setVersion</span>(QDataStream::Qt_4_0);<br>&#125;<br><br><span class="hljs-comment">// 读取数据</span><br>in &gt;&gt; lots_of_interesting_data;<br><span class="hljs-keyword">if</span> (version &gt;= <span class="hljs-number">120</span>) &#123;<br>    in &gt;&gt; data_new_in_version_1_2;<br>&#125;<br>in &gt;&gt; other_interesting_data;<br></code></pre></td></tr></table></figure><p>我们通过下面一段代码看看什么是流的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::ReadWrite);<br><br><span class="hljs-function">QDataStream <span class="hljs-title">stream</span><span class="hljs-params">(&amp;file)</span></span>;<br>QString str = <span class="hljs-string">&quot;the answer is 42&quot;</span>;<br>QString strout;<br><br>stream &lt;&lt; str;<br>file.<span class="hljs-built_in">flush</span>();<br>stream &gt;&gt; strout;<br></code></pre></td></tr></table></figure><p>在这段代码中，我们首先向文件中写入数据，紧接着把数据读出来。有什么问题吗？运行之后你会发现，<code>strout</code>实际是空的。为什么没有读取出来？我们不是已经添加了<code>file.flush()</code>;语句吗？原因并不在于文件有没有写入，而是在于我们使用的是“流”。<strong>所谓流，就像水流一样，它的游标会随着输出向后移动</strong>。当使用<code>&lt;&lt;</code>操作符输出之后，流的游标已经到了最后，此时你再去读，当然什么也读不到了。所以你需要在输出之后重新把游标设置为<code>0</code>的位置才能够继续读取。具体代码片段如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stream &lt;&lt; str;<br>stream.<span class="hljs-built_in">device</span>()-&gt;<span class="hljs-built_in">seek</span>(<span class="hljs-number">0</span>);<br>stream &gt;&gt; strout;<br></code></pre></td></tr></table></figure><h2 id="文本文件读写"><a href="#文本文件读写" class="headerlink" title="文本文件读写"></a>文本文件读写</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 操作系统-虚拟化</title>
    <link href="/2021/08/31/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <url>/2021/08/31/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h4 id="QEMU-工作原理"><a href="#QEMU-工作原理" class="headerlink" title="QEMU 工作原理"></a>QEMU 工作原理</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721140349.png"></p><p>单纯使用 qemu，采用的是完全虚拟化的模式。qemu 向 Guest OS 模拟 CPU，也模拟其他的硬件，GuestOS 认为自己和硬件直接打交道，其实是同 qemu 模拟出来的硬件打交道，qemu 会将这些指令转译给真正的硬件。由于所有的指令都要从 qemu 里面过一手，因而性能就会比较差。</p><p>完全虚拟化是非常慢的，所以要使用硬件辅助虚拟化技术 Intel-VT，AMD-V，所以需要 CPU 硬件开启这个标志位，一般在 BIOS 里面设置。当确认开始了标志位之后，通过 KVM，GuestOS 的 CPU 指令不用经过 Qemu 转译，直接运行，大大提高了速度。所以，KVM 在内核里面需要有一个模块，来设置当前 CPU 是 Guest OS 在用，还是 Host OS 在用。</p><p>可以通过如下命令查看内核模块中是否有 KVM</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lsmod <span class="hljs-string">| grep kvm</span><br></code></pre></td></tr></table></figure><p>KVM 内核模块通过 <code>/dev/kvm</code> 暴露接口，用户态程序可以通过 <code>ioctl</code>来访问这个接口。Qemu 将 KVM 整合进来，将有关 CPU 指令的部分交由内核模块来做，就是 qemu-kvm (qemu-system-XXX)。</p><p>qemu 和 kvm 整合之后，CPU 的性能问题解决了。另外 Qemu 还会模拟其他的硬件，如网络和硬盘。同样，全虚拟化的方式也会影响这些设备的性能。</p><p>于是，qemu 采取半虚拟化的方式，让 Guest OS 加载特殊的驱动来做这件事情。</p><p>例如，网络需要加载 <code>virtio_net</code>，存储需要加载 <code>virtio_blk</code>，Guest 需要安装这些半虚拟化驱动，GuestOS 知道自己是虚拟机，所以数据会直接发送给半虚拟化设备，经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。</p><h3 id="计算虚拟化之-CPU"><a href="#计算虚拟化之-CPU" class="headerlink" title="计算虚拟化之 CPU"></a>计算虚拟化之 CPU</h3><h3 id="计算虚拟化之内存"><a href="#计算虚拟化之内存" class="headerlink" title="计算虚拟化之内存"></a>计算虚拟化之内存</h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Linux 操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 操作系统-进程管理</title>
    <link href="/2021/08/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//process.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">create_process</span> <span class="hljs-params">(<span class="hljs-keyword">char</span>* program, <span class="hljs-keyword">char</span>** arg_list)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">create_process</span> <span class="hljs-params">(<span class="hljs-keyword">char</span>* program, <span class="hljs-keyword">char</span>** arg_list)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> child_pid;<br>    child_pid = fork ();<br>    <span class="hljs-keyword">if</span> (child_pid != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> child_pid;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">execvp</span> (program, arg_list);<br>        <span class="hljs-built_in">abort</span> ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们创建的子程序运行了一个最最简单的命令 <code>ls</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//createprocess.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">create_process</span> <span class="hljs-params">(<span class="hljs-keyword">char</span>* program, <span class="hljs-keyword">char</span>** arg_list)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span>* arg_list[] = &#123;<br>        <span class="hljs-string">&quot;ls&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<br>        <span class="hljs-string">&quot;/etc/yum.repos.d/&quot;</span>,<br>        <span class="hljs-literal">NULL</span><br>    &#125;;<br>    <span class="hljs-built_in">create_process</span> (<span class="hljs-string">&quot;ls&quot;</span>, arg_list);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>CPU 看不懂源码里的函数，命令，CPU 只认二进制数据，所以源码需要翻译成<code>01</code>二进制数据，这个过程就是<strong>编译（Compile）</strong>的过程。</p><p>编译出的文件好比一个公司的项目执行计划书，你要把一个项目执行好，计划书得有章法，有一定格式。在 Linux 下，二进制程序也有这样的格式，叫<strong>ELF</strong>（Executeable and Linkable Format，可执行与可链接格式），这个格式可以根据编译的结果不同，分为不同的格式。</p><h3 id="ELF-可重定位文件"><a href="#ELF-可重定位文件" class="headerlink" title="ELF-可重定位文件"></a>ELF-可重定位文件</h3><p>下图展示了如何从源码到二进制文件的转化</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810085445.png"></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -<span class="hljs-keyword">c</span> -fPIC process.<span class="hljs-keyword">c</span><br>gcc -<span class="hljs-keyword">c</span> -fPIC createprocess.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p><code>-fPIC</code>作用于编译阶段，告诉编译器产生与位置无关代码 (Position-Independent Code)。产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。</p><p>在编译的时候，先做<strong>预处理</strong>工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为<code>.o</code>文件，这就是<code>ELF</code>的第一种类型，<strong>可重定位文件</strong>（Relocatable File）。文件格式如下，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810085520.png"></p><p><code>ELF</code> 文件的头是用于描述整个文件的。这个文件格式在内核中有定义，分别为 <code>struct elf32_hdr</code> 和 <code>struct elf64_hdr</code>。</p><table><thead><tr><th>section</th><th>内容</th></tr></thead><tbody><tr><td>.text</td><td>放编译好的二进制可执行代码</td></tr><tr><td>.data</td><td>已经初始化好的全局变量（临时变量放在栈里）</td></tr><tr><td>.rodata</td><td>只读数据，例如字符串常量、const 的变量</td></tr><tr><td>.bss</td><td>未初始化全局变量，运行时会置 0</td></tr><tr><td>.symtab</td><td>符号表，记录的则是函数和变量</td></tr><tr><td>.strtab</td><td>字符串表、字符串常量和变量名</td></tr></tbody></table><p>第一种 ELF 文件叫可重定位文件，为啥可重定位？我们可以想象一下，这个编译好的代码和变量，将来<strong>加载到内存</strong>里面的时候，都是要加载到一定位置的。比如说，调用一个函数，其实就是跳到这个函数所在的代码位置执行；再比如修改一个全局变量，也是要到变量的位置那里去修改。但是现在这个时候，还是<code>.o</code>文件，不是一个可以直接运行的程序，这里面只是部分代码片段。</p><p>例如这里的 <code>create_process</code>函数，将来被谁调用，在哪里调用都不清楚，就更别提确定位置了。所以，<code>.o</code>里面的位置是不确定的，但是必须是可重新定位的，因为它将来是要做函数库的嘛，就是一块砖，哪里需要哪里搬，搬到哪里就重新定位这些代码、变量的位置。</p><h4 id="ELF-可执行文件"><a href="#ELF-可执行文件" class="headerlink" title="ELF-可执行文件"></a>ELF-可执行文件</h4><p>要让<code>create_process</code>这个函数作为库文件重用，需要将其形成库文件，最简单的类型是静态链接库<code>.a</code>文件，它将一系列<code>.o</code>文件归档为一个文件。使用<code>ar</code>命令创建<code>.a</code>文件。<a href="">使用方法看这里</a>。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ar <span class="hljs-literal">cr</span> libstaticprocess.<span class="hljs-keyword">a</span> <span class="hljs-built_in">process</span>.o<br></code></pre></td></tr></table></figure><p>虽然这里 <code>libstaticprocess.a</code> 里面只有一个<code>.o</code>，但是实际情况可以有多个<code>.o</code>。当有程序要使用这个静态连接库的时候，会将.o 文件提取出来，链接到程序中。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">gcc</span> -o staticcreateprocess createprocess.o -L. -lstaticprocess<br></code></pre></td></tr></table></figure><p><code>-L</code>表示在当前目录下找<code>.a</code>文件，<code>-lstaticprocess</code> 会自动补全文件名，比如加前缀 <code>lib</code>，后缀<code>.a</code>，变成 <code>libstaticprocess.a</code>，找到这个<code>.a</code>文件后，将里面的 process.o 取出来，和 <code>createprocess.o</code> 做一个链接，形成二进制执行文件 <code>staticcreateprocess</code>。</p><p>在链接过程中，重定位就起作用了，在<code>createprocess.o</code>里调用了<code>create_process</code>函数，但是不能确定位置，现在将<code>process.o</code>合并进来，就知道位置了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810114727.png"></p><p>这个格式和<code>.o</code> 文件大致相似，还是分成一个个的 <code>section</code>，并且被节头表描述。只不过这些<code>section</code> 是多个<code>.o</code> 文件合并过的。但是这个时候，这个文件已经是马上就可以加载到内存里面执行的文件了，因而这些 <code>section</code> 被分成了需要加载到内存里面的<strong>代码段</strong>、<strong>数据段</strong>和<strong>不需要加载</strong>到内存里面的部分，将小的 <code>section</code> 合成了大的段 <code>segment</code>，并且在最前面加一个<strong>段头表</strong>（Segment Header Table）。</p><p>在代码里面的定义为 <code>struct elf32_phdr</code>和 <code>struct elf64_phdr</code>，这里面除了有对于段的描述之外，最重要的是 <code>p_vaddr</code>，这个是这个段加载到内存的虚拟地址。</p><p>在 <code>ELF</code> 头里面，有一项 <code>e_entry</code>，也是个虚拟地址，是这个<strong>程序运行的入口</strong>。</p><h4 id="ELF-共享对象文件"><a href="#ELF-共享对象文件" class="headerlink" title="ELF-共享对象文件"></a>ELF-共享对象文件</h4><p>静态库一旦被链接，代码和变量的<code>section</code>会被合并，所以运行时不依赖静态库文件，但是缺点就是，相同代码段被多个程序使用，在<strong>内存里会有多份</strong>，而且<strong>静态库更新需要重新编译</strong>。</p><p>因而就出现了另一种，<strong>动态链接库</strong>（Shared Libraries），不仅仅是一组对象文件的简单归档，而是多个对象文件的重新组合，可被多个程序共享。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">gcc -<span class="hljs-keyword">shared</span> -fPIC -o libdynamicprocess.so <span class="hljs-keyword">process</span>.o<br></code></pre></td></tr></table></figure><p>当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">gcc</span> -o dynamiccreateprocess createprocess.o -L. -ldynamicprocess<br></code></pre></td></tr></table></figure><p>当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在 <code>/lib</code> 和<code>/usr/lib</code> 文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定 <code>LD_LIBRARY_PATH</code>环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment"># export LD_LIBRARY_PATH=.</span><br><span class="hljs-comment"># ./dynamiccreateprocess</span><br><span class="hljs-comment"># total 40</span><br>-rw-r--r--.<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 1572 </span>Oct<span class="hljs-number"> 24 </span>18:38 CentOS-Base.repo<br>......<br></code></pre></td></tr></table></figure><p>动态链接库，就是<code>ELF</code>的第三种类型，<strong>共享对象文件</strong>（Shared Object）。</p><p>文件格式和上两种文件稍有不同，首先，多了一个<code>.interp</code>的 <code>Segment</code>，这里面是 <code>ld-linux.so</code>，这是动态链接器，也就是说，运行时的链接动作都是它做的。</p><p>另外，<code>ELF</code>文件中还多了两个<code>section</code>，一个是<code>.plt</code>，<strong>过程链接表</strong>（Procedure Linkage Table，PLT），一个是。<code>got.plt</code>，<strong>全局偏移量表</strong>（Global Offset Table，GOT）。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>在内核中，有<code>linux_binfmt elf_format</code>数据结构定义了加载 ELF 的方法，使用<code>load_elf_binary</code>加载二进制文件，该函数由<code>do_execve</code>调用，学过系统调用知道<code>exec</code>调用了<code>do_execve</code>函数。所以流程为</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">exec</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">do_execve</span>-&gt;</span>load_elf_binary<br></code></pre></td></tr></table></figure><h4 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h4><p>所有进程都是从父进程 fork 来的，祖宗进程就是<code>init</code> 进程。</p><p>系统启动之后，<code>init</code> 进程会启动很多的<code>daemon</code> 进程，为系统运行提供服务，然后就是启动 <code>getty</code>，让用户登录，登录后运行 <code>shell</code>，用户启动的进程都是通过 <code>shell</code>运行的，从而形成了一棵进程树。</p><p>我们可以通过 <code>ps -ef</code>命令查看当前系统启动的进程，我们会发现有三类进程。<code>PID 1</code> 的进程就是我们的<code>init</code>进程 <code>systemd</code>，<code>PID 2</code> 的进程是内核线程 <code>kthreadd</code>。</p><p>内核态进程的<code>PPID</code>祖先进程都是 2 号进程，用户态进程祖先进程都是 1 号进程，<code>tty</code>列是问号的，说明是后台服务进程。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810143343.png"></p><h2 id="进程数据结构"><a href="#进程数据结构" class="headerlink" title="进程数据结构"></a>进程数据结构</h2><p>在 Linux 里面，无论是进程还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构<code>task_struct</code>进行管理。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826183622.png"></p><p>每个任务应该包含的字段：</p><h3 id="任务-ID"><a href="#任务-ID" class="headerlink" title="任务 ID"></a>任务 ID</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">pid_t</span> pid; <span class="hljs-meta">#process id</span><br><span class="hljs-keyword">pid_t</span> tgid; <span class="hljs-meta">#thread group ID</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">group_leader</span>;</span> <br></code></pre></td></tr></table></figure><p>为何要有这么多 ID，一个不够吗？</p><ul><li>可以方便任务展示，比如在命令行中 ps 显示所有进程，只显示<code>pid_t pid</code>，而不会把所有内部线程摊开展示，这样太碍眼。</li><li>方便下达命令，当我 kill 一个进程时，我们是对整个进程发送信号，但是有时候一些命令只需要对某个线程发送信号。</li><li></li></ul><h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Signal handlers: */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">signal_struct</span>    *<span class="hljs-title">signal</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sighand_struct</span>    *<span class="hljs-title">sighand</span>;</span><br><span class="hljs-keyword">sigset_t</span>      blocked;<br><span class="hljs-keyword">sigset_t</span>      real_blocked;<br><span class="hljs-keyword">sigset_t</span>      saved_sigmask;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigpending</span>    <span class="hljs-title">pending</span>;</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>      sas_ss_sp;<br><span class="hljs-keyword">size_t</span>        sas_ss_size;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>      sas_ss_flags;<br></code></pre></td></tr></table></figure><p>这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。</p><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> state;    <span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><br><span class="hljs-keyword">int</span> exit_state;<br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags;<br><br></code></pre></td></tr></table></figure><p><code>state</code>可取值定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Used in tsk-&gt;state: */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_RUNNING                    0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_INTERRUPTIBLE              1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_UNINTERRUPTIBLE            2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __TASK_STOPPED                  4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __TASK_TRACED                   8</span><br><span class="hljs-comment">/* Used in tsk-&gt;exit_state: */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXIT_DEAD                       16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXIT_ZOMBIE                     32</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXIT_TRACE                      (EXIT_ZOMBIE | EXIT_DEAD)</span><br><span class="hljs-comment">/* Used in tsk-&gt;state again: */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_DEAD                       64</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_WAKEKILL                   128</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_WAKING                     256</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_PARKED                     512</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_NOLOAD                     1024</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_NEW                        2048</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_STATE_MAX                  4096</span><br></code></pre></td></tr></table></figure><p>可以发现 Linux 通过 bitset 方式设置状态，当前什么状态，哪一位就置 1。</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>进程的状态切换往往涉及调度，下面这些字段都是用于调度的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 是否在运行队列上</span><br><span class="hljs-keyword">int</span>               on_rq;<br><span class="hljs-comment">// 优先级</span><br><span class="hljs-keyword">int</span>               prio;<br><span class="hljs-keyword">int</span>               static_prio;<br><span class="hljs-keyword">int</span>               normal_prio;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>      rt_priority;<br><span class="hljs-comment">// 调度器类</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span>  *<span class="hljs-title">sched_class</span>;</span><br><span class="hljs-comment">// 调度实体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span>       <span class="hljs-title">se</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_rt_entity</span>    <span class="hljs-title">rt</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_dl_entity</span>    <span class="hljs-title">dl</span>;</span><br><span class="hljs-comment">// 调度策略</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>      policy;<br><span class="hljs-comment">// 可以使用哪些 CPU</span><br><span class="hljs-keyword">int</span>            nr_cpus_allowed;<br><span class="hljs-keyword">cpumask_t</span>      cpus_allowed;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_info</span>    <span class="hljs-title">sched_info</span>;</span><br></code></pre></td></tr></table></figure><h3 id="运行统计信息"><a href="#运行统计信息" class="headerlink" title="运行统计信息"></a>运行统计信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">u64        utime;<span class="hljs-comment">// 用户态消耗的 CPU 时间</span><br>u64        stime;<span class="hljs-comment">// 内核态消耗的 CPU 时间</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>      nvcsw;<span class="hljs-comment">// 自愿 (voluntary) 上下文切换计数</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>      nivcsw;<span class="hljs-comment">// 非自愿 (involuntary) 上下文切换计数</span><br>u64        start_time;<span class="hljs-comment">// 进程启动时间，不包含睡眠时间</span><br>u64        real_start_time;<span class="hljs-comment">// 进程启动时间，包含睡眠时间</span><br></code></pre></td></tr></table></figure><h3 id="进程亲缘关系"><a href="#进程亲缘关系" class="headerlink" title="进程亲缘关系"></a>进程亲缘关系</h3><p>进程有棵进程树，所以有亲缘关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">real_parent</span>;</span> <span class="hljs-comment">/* real parent process */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">parent</span>;</span> <span class="hljs-comment">/* recipient of SIGCHLD, wait4() reports */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">children</span>;</span>      <span class="hljs-comment">/* list of my children */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">sibling</span>;</span>       <span class="hljs-comment">/* linkage in my parent&#x27;s children list */</span><br></code></pre></td></tr></table></figure><p>通常情况下，<code>real_parent</code> 和 <code>parent</code> 是一样的，但是也会有另外的情况存在。例如，<code>bash</code> 创建一个进程，那进程的 parent 和 <code>real_parent</code> 就都是 <code>bash</code>。如果在 bash 上使用 <code>GDB</code> 来 <code>debug</code> 一个进程，这个时候 <code>GDB</code> 是 <code>real_parent</code>，<code>bash</code> 是这个进程的 <code>parent</code>。</p><h3 id="进程权限"><a href="#进程权限" class="headerlink" title="进程权限"></a>进程权限</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Objective and real subjective task credentials (COW): */</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>         *<span class="hljs-title">real_cred</span>;</span><br><span class="hljs-comment">/* Effective (overridable) subjective task credentials (COW): */</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>   </span><br></code></pre></td></tr></table></figure><p><code>real_cred</code> 就是说明谁能操作我这个进程，而 <code>cred</code> 就是说明我这个进程能够操作谁。</p><p>总结到一起，<code>task_struct</code>结构图如下，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826190834.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Linux 操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPPLAB-Bomb Lab</title>
    <link href="/2021/08/29/CSAPP-LAB-Bomb%20Lab/"/>
    <url>/2021/08/29/CSAPP-LAB-Bomb%20Lab/</url>
    
    <content type="html"><![CDATA[<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="缩写注释"><a href="#缩写注释" class="headerlink" title="缩写注释"></a>缩写注释</h3><p>CSAPP：Computer Systems A Programmer’s Perspective（深入理解计算机操作系统）。CSAPP（C：P166，O：P278）表示书本的中文版第 166 页，英文原版第 278 页。</p><h3 id="寄存器信息"><a href="#寄存器信息" class="headerlink" title="寄存器信息"></a>寄存器信息</h3><p>了解寄存器的基本用途，看到一个汇编代码，可以大概了解这个寄存器是在栈中使用的，还是保存参数的，是调用者保存，还是被调用者保存。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830160500.png"></p><div STYLE="page-break-after: always;"></div><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>调试过程用到的 GDB 命令可以先参考<a href="https://dunky-z.github.io/2021/08/29/GDB%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/">GDB 调试入门</a>这篇文章。文中所用例子也是摘自与 BombLab 的源码，更容易理解如何使用。还有一定比较重要的是，如何使用 gdb 带参数调试。为了不用每次运行<code>bomb</code>程序都需要重新输入答案，<code>bomb</code>程序可以读取文本信息，在文本文件中写入答案即可免去手动输入。</p><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>拆弹专家已上线，开干！！！！！！！！！！！！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;"><br>(gdb) b phase_1<br>(gdb) b explode_bomb<br>(gdb) disas phase_1<br>Dump of assembler code for function phase_1:&#x27;<br>   0x0000000000400ee0 &lt;+0&gt;: sub    $0x8,%rsp<br>   0x0000000000400ee4 &lt;+4&gt;: mov    $0x402400,%esi<br>   0x0000000000400ee9 &lt;+9&gt;: callq  0x401338 &lt;strings_not_equal&gt;<br>   0x0000000000400eee &lt;+14&gt;: test   %eax,%eax<br>   0x0000000000400ef0 &lt;+16&gt;: je     0x400ef7 &lt;phase_1+23&gt;<br>   0x0000000000400ef2 &lt;+18&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400ef7 &lt;+23&gt;: add    $0x8,%rsp<br>   0x0000000000400efb &lt;+27&gt;: retq   <br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li>3：将栈指针<code>rsp</code>减去 8 个字节，也就是申请 8 个字节的栈空间</li><li>4：将一个立即数存到寄存器<code>esi</code>中</li><li>5：调用函数<code>strings_not_equal</code>，该函数第一条语句的地址为<code>0x401338</code>。<code>callq</code>指令的执行过程可参考书本 CSAPP（C：P166，O：P278）</li><li>6：使用<code>test</code>命令（同<code>and</code>命令，不修改目标对象的值）来测试<code>eax</code>中的值是否为<code>0</code>，如果为<code>0</code>则跳过引爆炸弹的函数</li><li>7：这一句和上一句是一个整体，如果<code>eax==0</code>,就跳转到<code>0x400ef7</code>，这个地址也就是第 9 行的地址，成功跳过了引爆炸弹函数。意思就是我们输入的某个字符串成功匹配，也就是<code>strings_not_equal</code>函数返回值为 0。</li><li>8：调用函数<code>explode_bomb</code>，引爆炸弹</li><li>9：将栈指针<code>rsp</code>加上 8 个字节，也就是恢复 8 个字节的栈空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) disas strings_not_equal <br>Dump of assembler code for function strings_not_equal:<br>=&gt; 0x0000000000401338 &lt;+0&gt;: push   %r12<br>   0x000000000040133a &lt;+2&gt;: push   %rbp<br>   0x000000000040133b &lt;+3&gt;: push   %rbx<br>   0x000000000040133c &lt;+4&gt;: mov    %rdi,%rbx<br>   0x000000000040133f &lt;+7&gt;: mov    %rsi,%rbp<br>   0x0000000000401342 &lt;+10&gt;: callq  0x40131b &lt;string_length&gt;<br>   0x0000000000401347 &lt;+15&gt;: mov    %eax,%r12d<br>   0x000000000040134a &lt;+18&gt;: mov    %rbp,%rdi<br>   0x000000000040134d &lt;+21&gt;: callq  0x40131b &lt;string_length&gt;<br>   0x0000000000401352 &lt;+26&gt;: mov    $0x1,%edx<br>   0x0000000000401357 &lt;+31&gt;: cmp    %eax,%r12d<br>   0x000000000040135a &lt;+34&gt;: jne    0x40139b &lt;strings_not_equal+99&gt;<br>   0x000000000040135c &lt;+36&gt;: movzbl (%rbx),%eax<br>   0x000000000040135f &lt;+39&gt;: test   %al,%al<br>   0x0000000000401361 &lt;+41&gt;: je     0x401388 &lt;strings_not_equal+80&gt;<br>   0x0000000000401363 &lt;+43&gt;: cmp    0x0(%rbp),%al<br>   0x0000000000401366 &lt;+46&gt;: je     0x401372 &lt;strings_not_equal+58&gt;<br>   0x0000000000401368 &lt;+48&gt;: jmp    0x40138f &lt;strings_not_equal+87&gt;<br>   0x000000000040136a &lt;+50&gt;: cmp    0x0(%rbp),%al<br>   0x000000000040136d &lt;+53&gt;: nopl   (%rax)<br>   0x0000000000401370 &lt;+56&gt;: jne    0x401396 &lt;strings_not_equal+94&gt;<br>   0x0000000000401372 &lt;+58&gt;: add    $0x1,%rbx<br>   0x0000000000401376 &lt;+62&gt;: add    $0x1,%rbp<br>   0x000000000040137a &lt;+66&gt;: movzbl (%rbx),%eax<br>   0x000000000040137d &lt;+69&gt;: test   %al,%al<br>   0x000000000040137f &lt;+71&gt;: jne    0x40136a &lt;strings_not_equal+50&gt;<br>   0x0000000000401381 &lt;+73&gt;: mov    $0x0,%edx<br>   0x0000000000401386 &lt;+78&gt;: jmp    0x40139b &lt;strings_not_equal+99&gt;<br>   0x0000000000401388 &lt;+80&gt;: mov    $0x0,%edx<br>   0x000000000040138d &lt;+85&gt;: jmp    0x40139b &lt;strings_not_equal+99&gt;<br>   0x000000000040138f &lt;+87&gt;: mov    $0x1,%edx<br>   0x0000000000401394 &lt;+92&gt;: jmp    0x40139b &lt;strings_not_equal+99&gt;<br>   0x0000000000401396 &lt;+94&gt;: mov    $0x1,%edx<br>   0x000000000040139b &lt;+99&gt;: mov    %edx,%eax<br>   0x000000000040139d &lt;+101&gt;: pop    %rbx<br>   0x000000000040139e &lt;+102&gt;: pop    %rbp<br>   0x000000000040139f &lt;+103&gt;: pop    %r12<br>   0x00000000004013a1 &lt;+105&gt;: retq   <br>End of assembler dump.<br>       <br></code></pre></td></tr></table></figure><ul><li>3-5：在函数调用时先保存相关寄存器值，<code>rbp</code>和<code>rbx</code>就是用来保存两个参数的寄存器</li><li>6：将寄存器<code>rdi</code>的值复制到寄存器<code>rbp</code></li><li>7：将寄存器<code>rsi</code>的值复制到寄存器<code>rbx</code></li></ul><p>其实看到这里就一直能够猜到答案是什么了。我们通过之前的<code>phase_1</code>函数能够大概知道需要输入一个值进行比较，如果比较正确就能解除炸弹。现在我们又进入到了这个比较函数，比较函数有两个参数，分别保存在两个寄存器里。我们正常的思维如果写一个比较函数，肯定一个参数是我们输入的值，一个参数是正确的值。</p><p>这里看到了<code>rsi</code>寄存器，我们还记得在<code>phase_1</code>函数中第 4 行的<code>esi</code>寄存器吗？这两个寄存器是同一个寄存器，只不过<code>esi</code>是寄存器的低 32 位，既然<code>esi</code>已经赋值了，那剩下的一个参数保存我们输入的内容。所以<code>esi</code>内存的内容就是我们需要的正确答案。我们只要把寄存器<code>esi</code>中的值打印出来，或者内存地址为<code>0x402400</code>的内容打印出来即可。可以通过以下三条命令查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) p (char*)($esi)<br>$5 = 0x402400 &quot;Border relations with Canada have never been better.&quot;<br>(gdb) x/s 0x402400<br>0x402400: &quot;Border relations with Canada have never been better.&quot;<br>(gdb) x/s $esi<br>0x402400: &quot;Border relations with Canada have never been better.&quot;<br></code></pre></td></tr></table></figure><p>将答案复制，然后继续运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">The program being debugged has been started already.<br>Start it from the beginning? (y or n) y<br>Starting program: /home/dominic/learning-linux/bomb/bomb <br>Welcome to my fiendish little bomb. You have 6 phases with<br>which to blow yourself up. Have a nice day!<br>Border relations with Canada have never been better.<br><br>Breakpoint 2, 0x0000000000400ee0 in phase_1 ()<br>(gdb) s<br>Single stepping until exit from function phase_1,<br>which has no line number information.<br>main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at bomb.c:75<br>75     phase_defused();                 /* Drat!  They figured it out!<br>(gdb) s<br>77     printf(&quot;Phase 1 defused. How about the next one?\n&quot;);<br></code></pre></td></tr></table></figure><p>从 13 行<code>phase_defused()</code>可以知道我们已经解除了炸弹，从 15 行<code>printf</code>函数也可以看到，需要进行下一个炸弹的拆除。过来人的建议，在这里就开始分析<code>phase_2</code>，寻找答案，因为继续执行就要开始输入内容了，将无法调试。</p><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>继续分析第二个炸弹，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) disas phase_2<br>Dump of assembler code for function phase_2:<br>   0x0000000000400efc &lt;+0&gt;: push   %rbp<br>   0x0000000000400efd &lt;+1&gt;: push   %rbx<br>   0x0000000000400efe &lt;+2&gt;: sub    $0x28,%rsp<br>   0x0000000000400f02 &lt;+6&gt;: mov    %rsp,%rsi<br>   0x0000000000400f05 &lt;+9&gt;: callq  0x40145c &lt;read_six_numbers&gt;<br>   0x0000000000400f0a &lt;+14&gt;: cmpl   $0x1,(%rsp)<br>   0x0000000000400f0e &lt;+18&gt;: je     0x400f30 &lt;phase_2+52&gt;<br>   0x0000000000400f10 &lt;+20&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f15 &lt;+25&gt;: jmp    0x400f30 &lt;phase_2+52&gt;<br>   0x0000000000400f17 &lt;+27&gt;: mov    -0x4(%rbx),%eax<br>   0x0000000000400f1a &lt;+30&gt;: add    %eax,%eax<br>   0x0000000000400f1c &lt;+32&gt;: cmp    %eax,(%rbx)<br>   0x0000000000400f1e &lt;+34&gt;: je     0x400f25 &lt;phase_2+41&gt;<br>   0x0000000000400f20 &lt;+36&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f25 &lt;+41&gt;: add    $0x4,%rbx<br>   0x0000000000400f29 &lt;+45&gt;: cmp    %rbp,%rbx<br>   0x0000000000400f2c &lt;+48&gt;: jne    0x400f17 &lt;phase_2+27&gt;<br>   0x0000000000400f2e &lt;+50&gt;: jmp    0x400f3c &lt;phase_2+64&gt;<br>   0x0000000000400f30 &lt;+52&gt;: lea    0x4(%rsp),%rbx<br>   0x0000000000400f35 &lt;+57&gt;: lea    0x18(%rsp),%rbp<br>   0x0000000000400f3a &lt;+62&gt;: jmp    0x400f17 &lt;phase_2+27&gt;<br>   0x0000000000400f3c &lt;+64&gt;: add    $0x28,%rsp<br>   0x0000000000400f40 &lt;+68&gt;: pop    %rbx<br>   0x0000000000400f41 &lt;+69&gt;: pop    %rbp<br>   0x0000000000400f42 &lt;+70&gt;: retq   <br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li>3-6：保存程序入口地址，变量等内容，就不再赘述了</li><li>7: 调用<code>read_six_numbers</code>函数，根据函数名我们可以猜测这个函数需要读入六个数字</li><li>8-9：比较寄存器<code>rsp</code>存的第一个数字是否等于<code>0x1</code>，如果等于就跳转到<code>phase_2+52</code>处继续执行，如果不等于就执行<code>explode_bomb</code>。栈中保存了六个输入的数字，保存顺序是从右往左，假如输入<code>1,2,3,4,5,6</code>。那么入栈的顺序就是<code>6,5,4,3,2,1</code>，寄存器<code>rsp</code>指向栈顶，也就是数字<code>1</code>的地址。</li><li>21:假设第一个数字正确，我们跳转到<code>&lt;+52&gt;</code>位置，也就是第 21 行，将<code>rsp+0x4</code>写入寄存器<code>rbx</code>，栈指针向上移动四个字节，也就是取第二个输入的参数，将它赋给寄存器<code>rbx</code></li><li>22：将<code>rsp+0x18</code>写入寄存器<code>rbp</code>，十六进制<code>0x18=24</code>，4 个字节一个数，刚好 6 个数，就是将输入参数的最后一个位置赋给寄存器<code>rbp</code></li><li>23：跳到<code>phase_2+27</code>继续执行</li><li>12：<code>rbx-0x4</code>赋给寄存器<code>eax</code>。第 21 行我们知道，<code>rbx</code>此时已经到第二个参数了，这一句就是说把第一个参数的值写入寄存器<code>eax</code></li><li>13：将<code>eax</code>翻一倍，第 8 行知道第一个参数值为<code>1</code>，所以此时<code>eax</code>值为<code>2</code></li><li>14-15：比较<code>eax</code>是否等于<code>rbx</code>。<code>rbx</code>此时保存的是第二个参数，这里也就是比较第二个参数是否等于<code>2</code>。如果等于跳转到<code>phase_2+41</code>位置，如果不等于就调用爆炸函数</li><li>17-18：假设第二个参数就是 2，我们跳过了炸弹来到第 17 行，将<code>rbx</code>继续上移，然后比较<code>rbp</code>是否等于<code>rbx</code>，我们知道<code>rbp</code>保存了最后一个参数的地址，所以这里的意思就是看看参数有没有到最后一个参数。</li><li>19：如果<code>rbx&lt;rbp</code>，意思就是还没到最后一个参数，就跳转到<code>phase_2+27</code></li><li>12：再次回到第 12 行，这里就是相当于一个循环了，让<code>rbx</code>一直向上移动，分别存入第 2，3，4，5，6 个参数，在移动到下一个参数时先保存当前参数到寄存器<code>eax</code>让其翻一倍，然后<code>rbx</code>再移动到下一个参数，比较<code>eax==rbx</code>。直到<code>rbx</code>越过了<code>rbp</code>。程序跳转到<code>phase_2+64</code>，将栈空间恢复。</li></ul><p>以上分析也可以得出答案了，我们只要输入一个以<code>1</code>为初值，公比为<code>2</code>，个数为<code>6</code>的等比数列就是答案，也就是<code>1 2 4 8 16 32</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell&#123;.line-numbers&#125;">(gdb) c<br>Continuing.<br>Phase 1 defused. How about the next one?<br>1 2 4 8 16 32<br><br>Breakpoint 6, 0x00000000004015c4 in phase_defused ()<br>(gdb) s<br>Single stepping until exit from function phase_defused,<br>which has no line number information.<br>main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at bomb.c:84<br>84     printf(&quot;That&#x27;s number 2.  Keep going!\n&quot;);<br>(gdb) s<br></code></pre></td></tr></table></figure><p>这个炸弹的作者应该再心狠手辣一点，把函数名换成<code>read_some_numbers</code>，这样我们就不得不看这个函数的内容了，因为这个函数里还有一个坑，这个坑在函数名字上一句被填了。那就是这个函数会对参数个数做判断，如果小于 5 就爆炸。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) disas read_six_numbers<br>Dump of assembler code for function read_six_numbers:<br>   0x000000000040145c &lt;+0&gt;: sub    $0x18,%rsp<br>   0x0000000000401460 &lt;+4&gt;: mov    %rsi,%rdx<br>   0x0000000000401463 &lt;+7&gt;: lea    0x4(%rsi),%rcx<br>   0x0000000000401467 &lt;+11&gt;: lea    0x14(%rsi),%rax<br>   0x000000000040146b &lt;+15&gt;: mov    %rax,0x8(%rsp)<br>   0x0000000000401470 &lt;+20&gt;: lea    0x10(%rsi),%rax<br>   0x0000000000401474 &lt;+24&gt;: mov    %rax,(%rsp)<br>   0x0000000000401478 &lt;+28&gt;: lea    0xc(%rsi),%r9<br>   0x000000000040147c &lt;+32&gt;: lea    0x8(%rsi),%r8<br>   0x0000000000401480 &lt;+36&gt;: mov    $0x4025c3,%esi<br>   0x0000000000401485 &lt;+41&gt;: mov    $0x0,%eax<br>   0x000000000040148a &lt;+46&gt;: callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>   0x000000000040148f &lt;+51&gt;: cmp    $0x5,%eax<br>   0x0000000000401492 &lt;+54&gt;: jg     0x401499 &lt;read_six_numbers+61&gt;<br>   0x0000000000401494 &lt;+56&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000401499 &lt;+61&gt;: add    $0x18,%rsp<br>   0x000000000040149d &lt;+65&gt;: retq   <br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li>3：申请 24 个字节栈空间</li><li>4：<code>rdx=rsi</code>，将输入参数的第一个参数放到寄存器<code>rdx</code>中，为啥是第一个参数，因为<code>rsi</code>现在保存的地址是栈顶位置，栈顶目前保存就是第一个参数。</li><li>5：<code>rcx = rsi + 4</code>，把第二个参数的地址传给寄存器<code>rcx</code></li><li>6：<code>rax = rsi + 20</code>，把第六个参数的地址传给寄存器<code>rax</code></li><li>7：<code>rsp + 8 = rax</code>第八个参数</li><li>8：<code>rax = rsi + 16</code>，把第五个参数传给</li><li>9：<code>rsp = rax</code>第七个参数</li><li>10：<code>r9 = rsi + 12</code>把第四个参数传给寄存器<code>r9</code></li><li>11：<code>r8 = rsi + 8</code>把第三个参数传给寄存器<code>r8</code></li><li>12：</li><li>13：<code>eax = 0</code></li><li>14：调用输入函数<code>sscanf</code></li><li>15-17：函数返回值个数与 5 比较，如果小于 5 就爆炸，否则返回</li></ul><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">0x0000000000400f43 &lt;+0&gt;: sub    $0x18,%rsp<br>0x0000000000400f47 &lt;+4&gt;: lea    0xc(%rsp),%rcx<br>0x0000000000400f4c &lt;+9&gt;: lea    0x8(%rsp),%rdx<br>0x0000000000400f51 &lt;+14&gt;: mov    $0x4025cf,%esi<br>0x0000000000400f56 &lt;+19&gt;: mov    $0x0,%eax<br>0x0000000000400f5b &lt;+24&gt;: callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>0x0000000000400f60 &lt;+29&gt;: cmp    $0x1,%eax<br>0x0000000000400f63 &lt;+32&gt;: jg     0x400f6a &lt;phase_3+39&gt;<br>0x0000000000400f65 &lt;+34&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>0x0000000000400f6a &lt;+39&gt;: cmpl   $0x7,0x8(%rsp)<br>0x0000000000400f6f &lt;+44&gt;: ja     0x400fad &lt;phase_3+106&gt;<br>0x0000000000400f71 &lt;+46&gt;: mov    0x8(%rsp),%eax<br>0x0000000000400f75 &lt;+50&gt;: jmpq   *0x402470(,%rax,8)<br>0x0000000000400f7c &lt;+57&gt;: mov    $0xcf,%eax<br>0x0000000000400f81 &lt;+62&gt;: jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400f83 &lt;+64&gt;: mov    $0x2c3,%eax<br>0x0000000000400f88 &lt;+69&gt;: jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400f8a &lt;+71&gt;: mov    $0x100,%eax<br>0x0000000000400f8f &lt;+76&gt;: jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400f91 &lt;+78&gt;: mov    $0x185,%eax<br>0x0000000000400f96 &lt;+83&gt;: jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400f98 &lt;+85&gt;: mov    $0xce,%eax<br>0x0000000000400f9d &lt;+90&gt;: jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400f9f &lt;+92&gt;: mov    $0x2aa,%eax<br>0x0000000000400fa4 &lt;+97&gt;: jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400fa6 &lt;+99&gt;: mov    $0x147,%eax<br>0x0000000000400fab &lt;+104&gt;: jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400fad &lt;+106&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>0x0000000000400fb2 &lt;+111&gt;: mov    $0x0,%eax<br>0x0000000000400fb7 &lt;+116&gt;: jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400fb9 &lt;+118&gt;: mov    $0x137,%eax<br>0x0000000000400fbe &lt;+123&gt;: cmp    0xc(%rsp),%eax<br>0x0000000000400fc2 &lt;+127&gt;: je     0x400fc9 &lt;phase_3+134&gt;<br>0x0000000000400fc4 &lt;+129&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>0x0000000000400fc9 &lt;+134&gt;: add    $0x18,%rsp<br>0x0000000000400fcd &lt;+138&gt;: retq   <br><br></code></pre></td></tr></table></figure><ul><li>1：开辟 24 字节的栈空间</li><li>2：<code>rcx = rsp + 12</code>第二个参数</li><li>3：<code>rdx = rsp + 8</code>第一个参数</li><li>4-8：和<code>phase_2</code>里<code>read_six_numbers</code>函数中的第 13 行开始一样，输入数据，判断一下输入参数的个数，只不过这里是返回值个数大于 1，如果参数个数正确就跳到<code>phase_3+39</code>也就是第 10 行，否则引爆炸弹。</li><li>10-11：如果<code>7 &lt; rsp + 8 等价于 7 &lt; rdx 等价于 7 &lt; 第一个参数</code>就跳转到<code>phase_3+106</code>，爆炸。这里确定第一个数必须小于 7</li><li>12：<code>eax = rsp + 8 等价于 eax = 第一个参数</code></li><li>13：跳转至<code>0x402470 + 8 * rax</code>处，具体跳转到哪里根据第一个值做判断</li><li>14：<code>eax = 207</code></li><li>15：跳转至<code>phase_3+123</code>,即 32 行</li><li>16：<code>eax = 707</code></li><li>17：跳转到 32 行</li><li>18：<code>eax = 256</code></li><li>19：跳转到 32 行</li><li>20：<code>eax = 389</code></li><li>21-27：以此类推</li><li>29：<code>eax = 0</code></li><li>30：</li><li>31：<code>eax = 311</code></li><li>32-34：比较<code>eax</code>和<code>rsp + 12</code> 等价于 比较 第二个参数和<code>eax</code>。如果相等就返回，如果不等就引爆。</li></ul><p>分析至此，我们也就知道了程序的大概流程，输入两个值，第一个值必须小于等于 7，第二个值根据第一个值来确定，具体等于多少，根据跳转表确定，因为第一个值有八个数，也就对应着汇编中八段寄存器<code>eax</code>赋值的过程，我们只要输入第一个合法的数值，然后再打印出寄存器<code>eax</code>的值，即可确定答案。</p><p>比如我们先测试一下第一个值为 0 时，对应的第二个值为多少，我们输入<code>0  10</code>，因为只是测试，第二个值任意。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stata">That&#x27;s number 2.  <span class="hljs-keyword">Keep</span> going! <span class="hljs-comment">//接上个炸弹后面</span><br>88     <span class="hljs-keyword">input</span> = read_line();<br>(gdb) <span class="hljs-keyword">n</span><br>0 10              <span class="hljs-comment">//输入测试答案</span><br>89     phase_3(<span class="hljs-keyword">input</span>);<br>(gdb) <span class="hljs-keyword">n</span><br>Breakpoint 4, 0x0000000000400f43 <span class="hljs-keyword">in</span> phase_3 ()<br>(gdb) <span class="hljs-keyword">n</span><br>Single stepping until <span class="hljs-keyword">exit</span> from function phase_3,<br><span class="hljs-keyword">which</span> has <span class="hljs-keyword">no</span> <span class="hljs-keyword">line</span> number information.<br>Breakpoint 2, 0x000000000040143a <span class="hljs-keyword">in</span> explode_bomb ()<br>(gdb) p <span class="hljs-variable">$eax</span><br><span class="hljs-variable">$14</span> = 207         <span class="hljs-comment">//207即是答案</span><br></code></pre></td></tr></table></figure><p>输入真正答案测试，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">(gdb) n<br><span class="hljs-number">0</span> <span class="hljs-number">207</span>                         <span class="hljs-regexp">//</span>输入答案<br><span class="hljs-number">89</span>     phase_3(input);<br>(gdb) n<br>Breakpoint <span class="hljs-number">4</span>, <span class="hljs-number">0</span>x0000000000400f43 <span class="hljs-keyword">in</span> phase_3 ()<br>(gdb) n<br>Single stepping until <span class="hljs-keyword">exit</span> from <span class="hljs-keyword">function</span> phase_3,<br>which has no line number information.<br>main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at bomb.c:<span class="hljs-number">90</span><br><span class="hljs-number">90</span>     phase_defused();    <span class="hljs-regexp">//</span>炸弹拆除<br>(gdb) <br><span class="hljs-number">91</span>     printf(<span class="hljs-string">&quot;Halfway there!\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>我们上面说过，第一个值有八种可能，所以这题答案也有八个，我们只要挨个测试<code>0-7</code>，分别打印出寄存器<code>eax</code>的值就可以得到所有答案。他们分别是</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">207</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">311</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">707</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">256</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">389</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">206</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">682</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">327</span><br></code></pre></td></tr></table></figure><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>行百里者半九十，NO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) disas phase_4<br>Dump of assembler code for function phase_4:<br>   0x000000000040100c &lt;+0&gt;: sub    $0x18,%rsp<br>   0x0000000000401010 &lt;+4&gt;: lea    0xc(%rsp),%rcx<br>   0x0000000000401015 &lt;+9&gt;: lea    0x8(%rsp),%rdx<br>   0x000000000040101a &lt;+14&gt;: mov    $0x4025cf,%esi<br>   0x000000000040101f &lt;+19&gt;: mov    $0x0,%eax<br>   0x0000000000401024 &lt;+24&gt;: callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>   0x0000000000401029 &lt;+29&gt;: cmp    $0x2,%eax<br>   0x000000000040102c &lt;+32&gt;: jne    0x401035 &lt;phase_4+41&gt;<br>   0x000000000040102e &lt;+34&gt;: cmpl   $0xe,0x8(%rsp)<br>   0x0000000000401033 &lt;+39&gt;: jbe    0x40103a &lt;phase_4+46&gt;<br>   0x0000000000401035 &lt;+41&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>   0x000000000040103a &lt;+46&gt;: mov    $0xe,%edx<br>   0x000000000040103f &lt;+51&gt;: mov    $0x0,%esi<br>   0x0000000000401044 &lt;+56&gt;: mov    0x8(%rsp),%edi<br>   0x0000000000401048 &lt;+60&gt;: callq  0x400fce &lt;func4&gt;<br>   0x000000000040104d &lt;+65&gt;: test   %eax,%eax<br>   0x000000000040104f &lt;+67&gt;: jne    0x401058 &lt;phase_4+76&gt;<br>   0x0000000000401051 &lt;+69&gt;: cmpl   $0x0,0xc(%rsp)<br>   0x0000000000401056 &lt;+74&gt;: je     0x40105d &lt;phase_4+81&gt;<br>   0x0000000000401058 &lt;+76&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>   0x000000000040105d &lt;+81&gt;: add    $0x18,%rsp<br>   0x0000000000401061 &lt;+85&gt;: retq   <br></code></pre></td></tr></table></figure><ul><li>1-8：开辟空间，保存参数信息，调用输入函数，和上面的分析重复，不再赘述。注意的是第 6 行，<code>x/s 0x4025cf</code>可知两个参数是整型数值。</li><li>9-10：参数个数必须等于 2，否则引爆</li><li>11-12：<code>14</code>与<code>rsp + 8</code>比较，等价于<code>14</code>与第一个参数比较。表示第一个参数必须小于等于 14，否则引爆。</li><li>14：<code>edx = 14</code></li><li>15：<code>esi = 0</code></li><li>16：<code>edi = rsp + 8</code>即<code>edi = 第一个参数</code></li><li>17：调用函数<code>fun4</code>，参数分别为<code>edi 0 14</code></li><li>18：测试返回值是否为 0，如果不为 0，引爆</li><li>20-22：比较<code>0</code>和<code>rsp + 12</code>，如果不等，引爆，否则返回</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) disas func4<br>Dump of assembler code for function func4:<br>   0x0000000000400fce &lt;+0&gt;: sub    $0x8,%rsp<br>   0x0000000000400fd2 &lt;+4&gt;: mov    %edx,%eax<br>   0x0000000000400fd4 &lt;+6&gt;: sub    %esi,%eax<br>   0x0000000000400fd6 &lt;+8&gt;: mov    %eax,%ecx<br>   0x0000000000400fd8 &lt;+10&gt;: shr    $0x1f,%ecx<br>   0x0000000000400fdb &lt;+13&gt;: add    %ecx,%eax<br>   0x0000000000400fdd &lt;+15&gt;: sar    %eax<br>   0x0000000000400fdf &lt;+17&gt;: lea    (%rax,%rsi,1),%ecx<br>   0x0000000000400fe2 &lt;+20&gt;: cmp    %edi,%ecx<br>   0x0000000000400fe4 &lt;+22&gt;: jle    0x400ff2 &lt;func4+36&gt;<br>   0x0000000000400fe6 &lt;+24&gt;: lea    -0x1(%rcx),%edx<br>   0x0000000000400fe9 &lt;+27&gt;: callq  0x400fce &lt;func4&gt;<br>   0x0000000000400fee &lt;+32&gt;: add    %eax,%eax<br>   0x0000000000400ff0 &lt;+34&gt;: jmp    0x401007 &lt;func4+57&gt;<br>   0x0000000000400ff2 &lt;+36&gt;: mov    $0x0,%eax<br>   0x0000000000400ff7 &lt;+41&gt;: cmp    %edi,%ecx<br>   0x0000000000400ff9 &lt;+43&gt;: jge    0x401007 &lt;func4+57&gt;<br>   0x0000000000400ffb &lt;+45&gt;: lea    0x1(%rcx),%esi<br>   0x0000000000400ffe &lt;+48&gt;: callq  0x400fce &lt;func4&gt;<br>   0x0000000000401003 &lt;+53&gt;: lea    0x1(%rax,%rax,1),%eax<br>   0x0000000000401007 &lt;+57&gt;: add    $0x8,%rsp<br>   0x000000000040100b &lt;+61&gt;: retq   <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C">func (edi, esi, edx)<br>&#123;<br>   <span class="hljs-comment">// edi = 第一个参数, esi = 0, edx = 14</span><br>   eax = edx            <span class="hljs-comment">// 4:mov %edx, %eax</span><br>   eax = eax -esi       <span class="hljs-comment">// 5:sub esi, %eax</span><br>   eax = edx -esi<br>   ecx = eax            <span class="hljs-comment">// 6:mov %eax, %ecx</span><br>   ecx = edx - esi<br>   eсx = ecx &gt;&gt; <span class="hljs-number">31</span>      <span class="hljs-comment">// 7:shr  $0x1f, %ecx</span><br>   ecx = (edx - esi) &gt;&gt; <span class="hljs-number">31</span><br>   eax = eax + ecx      <span class="hljs-comment">// 8:add %ecx, %eax</span><br>   eax = (edx - esi) + ((edx - esi) &gt;&gt; <span class="hljs-number">31</span>)<span class="hljs-comment">//替换eax和ecx</span><br>   eax = eax &gt; <span class="hljs-number">1</span>;       <span class="hljs-comment">// 9:sar %eax</span><br>   eax = ((edx - esi) +((edx -esi) &gt;&gt; <span class="hljs-number">31</span>)) / <span class="hljs-number">2</span><br>   ecx = eax + esi * <span class="hljs-number">1</span>   <span class="hljs-comment">// 10:lea (rax,ersi,1), %ecx</span><br>   ecx = ((edx - esi) +((edx -esi) &gt;&gt; <span class="hljs-number">31</span>)) / <span class="hljs-number">2</span> + esi * <span class="hljs-number">1</span><br><br>   ecx = ((<span class="hljs-number">14</span> - <span class="hljs-number">0</span>) + ((<span class="hljs-number">14</span> - <span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">31</span>)) / <span class="hljs-number">2</span> + <span class="hljs-number">0</span><br>   ecx = <span class="hljs-number">7</span><br><br>   <span class="hljs-comment">// 11:cmp %edi, %ecx</span><br>   <span class="hljs-keyword">if</span> (ecx &lt;= edi)<br>   &#123;<br>      <span class="hljs-comment">// 12:jle 400ff2</span><br>      eax = <span class="hljs-number">0</span>    <span class="hljs-comment">// mov $0x0,%eax</span><br>      <span class="hljs-comment">// 18:cmp %edi, %ecx</span><br>      <span class="hljs-keyword">if</span>(ecx &gt;= edi)<br>      &#123;<br>         <span class="hljs-comment">// 19:jge    0x401007 &lt;func4+57&gt;</span><br>         <span class="hljs-keyword">return</span>;<br>         <span class="hljs-comment">//由此可以得知道 edx == edi</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">0x0000000000401062 &lt;+0&gt;: push   %rbx<br>0x0000000000401063 &lt;+1&gt;: sub    $0x20,%rsp<br>0x0000000000401067 &lt;+5&gt;: mov    %rdi,%rbx<br>0x000000000040106a &lt;+8&gt;: mov    %fs:0x28,%rax<br>0x0000000000401073 &lt;+17&gt;: mov    %rax,0x18(%rsp)<br>0x0000000000401078 &lt;+22&gt;: xor    %eax,%eax<br>0x000000000040107a &lt;+24&gt;: callq  0x40131b &lt;string_length&gt;<br>0x000000000040107f &lt;+29&gt;: cmp    $0x6,%eax<br>0x0000000000401082 &lt;+32&gt;: je     0x4010d2 &lt;phase_5+112&gt;<br>0x0000000000401084 &lt;+34&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>0x0000000000401089 &lt;+39&gt;: jmp    0x4010d2 &lt;phase_5+112&gt;<br>0x000000000040108b &lt;+41&gt;: movzbl (%rbx,%rax,1),%ecx<br>0x000000000040108f &lt;+45&gt;: mov    %cl,(%rsp)<br>0x0000000000401092 &lt;+48&gt;: mov    (%rsp),%rdx<br>0x0000000000401096 &lt;+52&gt;: and    $0xf,%edx<br>0x0000000000401099 &lt;+55&gt;: movzbl 0x4024b0(%rdx),%edx<br>0x00000000004010a0 &lt;+62&gt;: mov    %dl,0x10(%rsp,%rax,1)<br>0x00000000004010a4 &lt;+66&gt;: add    $0x1,%rax<br>0x00000000004010a8 &lt;+70&gt;: cmp    $0x6,%rax<br>0x00000000004010ac &lt;+74&gt;: jne    0x40108b &lt;phase_5+41&gt;<br>0x00000000004010ae &lt;+76&gt;: movb   $0x0,0x16(%rsp)<br>0x00000000004010b3 &lt;+81&gt;: mov    $0x40245e,%esi<br>   0x00000000004010b8 &lt;+86&gt;: lea    0x10(%rsp),%rdi<br>0x00000000004010bd &lt;+91&gt;: callq  0x401338 &lt;strings_not_equal&gt;<br>0x00000000004010c2 &lt;+96&gt;: test   %eax,%eax<br>0x00000000004010c4 &lt;+98&gt;: je     0x4010d9 &lt;phase_5+119&gt;<br>0x00000000004010c6 &lt;+100&gt;: callq  0x40143a &lt;explode_bomb&gt;<br>0x00000000004010cb &lt;+105&gt;: nopl   0x0(%rax,%rax,1)<br>0x00000000004010d0 &lt;+110&gt;: jmp    0x4010d9 &lt;phase_5+119&gt;<br>0x00000000004010d2 &lt;+112&gt;: mov    $0x0,%eax<br>0x00000000004010d7 &lt;+117&gt;: jmp    0x40108b &lt;phase_5+41&gt;<br>0x00000000004010d9 &lt;+119&gt;: mov    0x18(%rsp),%rax<br>0x00000000004010de &lt;+124&gt;: xor    %fs:0x28,%rax<br>0x00000000004010e7 &lt;+133&gt;: je     0x4010ee &lt;phase_5+140&gt;<br>0x00000000004010e9 &lt;+135&gt;: callq  0x400b30 &lt;__stack_chk_fail@plt&gt;<br>0x00000000004010ee &lt;+140&gt;: add    $0x20,%rsp<br>0x00000000004010f2 &lt;+144&gt;: pop    %rbx<br>0x00000000004010f3 &lt;+145&gt;: retq   <br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>CSAPP-Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GDB</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB 调试入门</title>
    <link href="/2021/08/29/GDB%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/"/>
    <url>/2021/08/29/GDB%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="file-加载程序"><a href="#file-加载程序" class="headerlink" title="file 加载程序"></a>file 加载程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) file bomb<br>Reading symbols from bomb...<br></code></pre></td></tr></table></figure><h2 id="set-args-带参数调试"><a href="#set-args-带参数调试" class="headerlink" title="set args 带参数调试"></a>set args 带参数调试</h2><p>有时候程序不是直接可以运行的，需要加上一些必要的参数。带上参数运行很容易，只要在程序名后加上相应参数即可，但是如何带上参数进行调试呢？这就需要<code>set args</code>命令。</p><p>比如在<code>BombLab</code>实验中，我们不可能一次解决所有<code>phase</code>，但是每次重新调试，已经解决的<code>phase</code>还要重新输入一次答案，这就很麻烦，好在这个实验的作者也考虑到了，他支持读取文本。我们可以把答案预先写入一个文本文件中，程序读取已经保存的答案即可跳过相应的<code>phase</code>。</p><p>假设我们把答案写入了<code>solutions.txt</code>文件中，首先，我们加载程序，然后通过<code>set args solutions.txt</code>设置运行参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) file bomb<br>Reading symbols from bomb...<br>(gdb) <span class="hljs-built_in">set</span> args solutions.txt <br>(gdb) r<br>Starting program: /home/dominic/learning-linux/bomb/bomb solutions.txt <br>Welcome to my fiendish little bomb. You have 6 phases with<br><span class="hljs-built_in">which</span> to blow yourself up. Have a nice day!<br>Phase 1 defused. How about the next one?<br>That<span class="hljs-string">&#x27;s number 2.  Keep going!</span><br></code></pre></td></tr></table></figure><h2 id="list-查看源码"><a href="#list-查看源码" class="headerlink" title="list 查看源码"></a>list 查看源码</h2><h3 id="查看-10-行源码"><a href="#查看-10-行源码" class="headerlink" title="查看 10 行源码"></a>查看 10 行源码</h3><p>每条命令显示 10 行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) l<br>23 #include &lt;stdio.h&gt;<br>24 #include &lt;stdlib.h&gt;<br>25 #include &quot;support.h&quot;<br>26 #include &quot;phases.h&quot;<br>27 <br>28 /* <br>29  * Note to self: Remember to erase this file so my victims will have no<br>30  * idea what is going on, and so they will all blow up in a<br>31  * spectaculary fiendish explosion. -- Dr. Evil <br>32  */<br>(gdb) l<br>33 <br>34 FILE *infile;<br>35 <br>36 int main(int argc, char *argv[])<br>37 &#123;<br>38     char *input;<br>39 <br>40     /* Note to self: remember to port this bomb to Windows and put a <br>41      * fantastic GUI on it. */<br>42<br></code></pre></td></tr></table></figure><h3 id="set-list-num-设置默认显示代码行数"><a href="#set-list-num-设置默认显示代码行数" class="headerlink" title="set list num 设置默认显示代码行数"></a>set list num 设置默认显示代码行数</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">(gdb) <span class="hljs-keyword">set</span> list <span class="hljs-comment">20</span>   //默认显示<span class="hljs-comment">20</span>行代码<br></code></pre></td></tr></table></figure><h3 id="list-linenumber-查看指定行代码"><a href="#list-linenumber-查看指定行代码" class="headerlink" title="list linenumber 查看指定行代码"></a>list linenumber 查看指定行代码</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">(gdb) l <span class="hljs-number">10</span>  <br>(gdb) l <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.h</span> : <span class="hljs-number">10</span> <span class="hljs-comment">//指定main.c文件中的第十行</span><br></code></pre></td></tr></table></figure><h3 id="list-function-查看指定函数的代码"><a href="#list-function-查看指定函数的代码" class="headerlink" title="list function 查看指定函数的代码"></a>list function 查看指定函数的代码</h3><h2 id="break-打断点"><a href="#break-打断点" class="headerlink" title="break 打断点"></a>break 打断点</h2><h3 id="break-linenum-对指定行打断点"><a href="#break-linenum-对指定行打断点" class="headerlink" title="break linenum 对指定行打断点"></a>break linenum 对指定行打断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b 36<br>Note: breakpoint 1 also set at pc 0x400da0.<br>Breakpoint 2 at 0x400da0: file bomb.c, line 37.<br></code></pre></td></tr></table></figure><h3 id="break-function-对指定函数打断点"><a href="#break-function-对指定函数打断点" class="headerlink" title="break function 对指定函数打断点"></a>break function 对指定函数打断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b main<br>Breakpoint 3 at 0x400da0: file bomb.c, line 37.<br>(gdb) b phase_1<br>Breakpoint 4 at 0x400ee0<br></code></pre></td></tr></table></figure><h2 id="删除断点包括禁用断点"><a href="#删除断点包括禁用断点" class="headerlink" title="删除断点包括禁用断点"></a>删除断点包括禁用断点</h2><h3 id="delete-删除所有断点"><a href="#delete-删除所有断点" class="headerlink" title="delete 删除所有断点"></a>delete 删除所有断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) delete <br>Delete all breakpoints? (y or n) y<br></code></pre></td></tr></table></figure><h3 id="disable-breakpoint-禁用断点"><a href="#disable-breakpoint-禁用断点" class="headerlink" title="disable breakpoint 禁用断点"></a>disable breakpoint 禁用断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) info b #先看有哪些断点<br>Num     Type           Disp Enb Address            What<br>3       breakpoint     keep y   0x0000000000400da0 in main at bomb.c:37<br>4       breakpoint     keep y   0x0000000000400ee0 &lt;phase_1&gt;<br>(gdb) d 3 #禁用第三号断点<br>(gdb) info b #再次查看断点信息发现已经没有第三号断点<br>Num     Type           Disp Enb Address            What<br>4       breakpoint     keep y   0x0000000000400ee0 &lt;phase_1&gt;<br></code></pre></td></tr></table></figure><h3 id="clear-function-删除一个函数中所有的断点"><a href="#clear-function-删除一个函数中所有的断点" class="headerlink" title="clear function 删除一个函数中所有的断点"></a>clear function 删除一个函数中所有的断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) info b<br>Num     Type           Disp Enb Address            What<br>4       breakpoint     keep y   0x0000000000400ee0 &lt;phase_1&gt;<br>(gdb) clear phase_1<br>(gdb) info b<br>Deleted breakpoint 4 No breakpoints or watchpoints.<br></code></pre></td></tr></table></figure><h2 id="启动与退出"><a href="#启动与退出" class="headerlink" title="启动与退出"></a>启动与退出</h2><h3 id="run-启动程序直到遇到断点"><a href="#run-启动程序直到遇到断点" class="headerlink" title="run 启动程序直到遇到断点"></a>run 启动程序直到遇到断点</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">(gdb) <span class="hljs-builtin-name">run</span>  <br></code></pre></td></tr></table></figure><h3 id="start-启动程序并在第一条代码处停下"><a href="#start-启动程序并在第一条代码处停下" class="headerlink" title="start 启动程序并在第一条代码处停下"></a>start 启动程序并在第一条代码处停下</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">(gdb) <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><h3 id="x-配置-gdb-常用命令"><a href="#x-配置-gdb-常用命令" class="headerlink" title="x 配置 gdb 常用命令"></a>x 配置 gdb 常用命令</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gdb -<span class="hljs-selector-tag">q</span> -x gdbinit<br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//gdbinit</span><br><span class="hljs-keyword">display</span>/z <span class="hljs-symbol">$</span>xs<br><span class="hljs-keyword">display</span>/z <span class="hljs-symbol">$</span>x6<br><span class="hljs-keyword">display</span>/z <span class="hljs-symbol">$</span>x7<br><span class="hljs-keyword">set</span> disassemble-next-line <span class="hljs-comment">on</span><br>b <span class="hljs-comment">_start</span><br>target <span class="hljs-comment">remote: 34</span><br></code></pre></td></tr></table></figure><p>有了配置文件，就不用每次启动 gdb 时都要重新输入一遍调试命令。</p><h3 id="quit-退出调试"><a href="#quit-退出调试" class="headerlink" title="quit 退出调试"></a>quit 退出调试</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">(gdb) <span class="hljs-keyword">quit</span><br></code></pre></td></tr></table></figure><h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><h3 id="print-打印变量值"><a href="#print-打印变量值" class="headerlink" title="print 打印变量值"></a>print 打印变量值</h3><table><thead><tr><th>格式化字符 (/fmt)</th><th>说明</th></tr></thead><tbody><tr><td>/x</td><td>以十六进制的形式打印出整数。</td></tr><tr><td>/d</td><td>以有符号、十进制的形式打印出整数。</td></tr><tr><td>/u</td><td>以无符号、十进制的形式打印出整数。</td></tr><tr><td>/o</td><td>以八进制的形式打印出整数。</td></tr><tr><td>/t</td><td>以二进制的形式打印出整数。</td></tr><tr><td>/f</td><td>以浮点数的形式打印变量或表达式的值。</td></tr><tr><td>/c</td><td>以字符形式打印变量或表达式的值。</td></tr></tbody></table><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">(gdb) p i       <span class="hljs-meta"># 10进制</span><br>$5 = <span class="hljs-number">3</span><br>(gdb) p/x i     <span class="hljs-meta"># 16进制</span><br>$6 = <span class="hljs-number">0x3</span><br>(gdb) p/o i     <span class="hljs-meta"># 8进制</span><br>$7 = <span class="hljs-number">03</span><br><br></code></pre></td></tr></table></figure><h3 id="打印地址值"><a href="#打印地址值" class="headerlink" title="打印地址值"></a>打印地址值</h3><p>表示从内存地址 0x54320 读取内容，h 表示以双字节为单位，3 表示输出 3 个单位，u 表示按照十六进制显示。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">(gdb) x/<span class="hljs-number">3</span>uh <span class="hljs-number">0x54320</span> <br></code></pre></td></tr></table></figure><p>查看当前程序栈的内容：x/10x $sp–&gt;打印 stack 的前 10 个元素<br>查看当前程序栈的信息：info frame—-list general info about the frame<br>查看当前程序栈的参数：info args—lists arguments to the function<br>查看当前程序栈的局部变量：info locals—list variables stored in the frame<br>查看当前寄存器的值：info registers(不包括浮点寄存器)</p><h3 id="ptype-打印变量类型"><a href="#ptype-打印变量类型" class="headerlink" title="ptype 打印变量类型"></a>ptype 打印变量类型</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">(gdb) ptype i<br>type =<span class="hljs-built_in"> int</span><br><span class="hljs-built_in"></span>(gdb) ptype array[i]<br>type =<span class="hljs-built_in"> int</span><br><span class="hljs-built_in"></span>(gdb) ptype<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span>type =<span class="hljs-built_in"> int </span>[12]<br></code></pre></td></tr></table></figure><h3 id="display-跟踪显示变量"><a href="#display-跟踪显示变量" class="headerlink" title="display 跟踪显示变量"></a>display 跟踪显示变量</h3><p><code>print</code>命令可以打印出变量的值，但是只是一次性的。如果我们想要跟踪某个变量的变化，可以使用<code>display</code>命令，每当程序在断点处停下，都会打印出跟踪的变量值。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">(gdb) <span class="hljs-attribute">display</span> <br></code></pre></td></tr></table></figure><p><code>info display</code>查看已跟踪的变量，<code>delete display</code>取消跟踪显示变量。</p><h3 id="step-执行一行代码"><a href="#step-执行一行代码" class="headerlink" title="step 执行一行代码"></a>step 执行一行代码</h3><p>执行一行代码，如果改行代码是函数，将进入函数内部。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(gdb)</span> s<br></code></pre></td></tr></table></figure><h3 id="finish-跳出函数"><a href="#finish-跳出函数" class="headerlink" title="finish 跳出函数"></a>finish 跳出函数</h3><p>如果通过<code>s</code>单步调试进入到函数内部，想要跳出这个函数体，可以执行 <code>finish</code>命令。如果想要跳出函数体必须要<strong>保证函数体内不能有有效断点</strong>，否则无法跳出。</p><h3 id="next-执行一行代码"><a href="#next-执行一行代码" class="headerlink" title="next 执行一行代码"></a>next 执行一行代码</h3><p><code>next</code> 命令和 <code>step</code> 命令功能是相似的，只是在使用 <code>next</code> 调试程序的时候不会进入到函数体内部，<code>next</code> 可以缩写为 <code>n</code>。</p><h3 id="until-跳出循环体"><a href="#until-跳出循环体" class="headerlink" title="until 跳出循环体"></a>until 跳出循环体</h3><p>通过 until 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要保证，<strong>要跳出的循环体内部不能有有效的断点</strong>，<strong>必须要在循环体的开始 / 结束行执行该命令</strong>。</p><h2 id="layout-分割窗口，边调试边看源码"><a href="#layout-分割窗口，边调试边看源码" class="headerlink" title="layout 分割窗口，边调试边看源码"></a>layout 分割窗口，边调试边看源码</h2><h3 id="layout-src"><a href="#layout-src" class="headerlink" title="layout src"></a>layout src</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830153452.png"></p><h3 id="layout-asm"><a href="#layout-asm" class="headerlink" title="layout asm"></a>layout asm</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830153520.png"></p><h3 id="layout-split"><a href="#layout-split" class="headerlink" title="layout split"></a>layout split</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830153555.png"></p><h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><h3 id="s-S"><a href="#s-S" class="headerlink" title="-s -S"></a><code>-s -S</code></h3><p><code>-s</code>启动<code>gdb server</code>，默认端口号为 1234<br><code>-S</code>让程序在<code>_start</code>处停下。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GDB</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oh-my-zsh 让你的终端更加顺手（眼）</title>
    <link href="/2021/08/29/oh-my-zsh%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%BB%88%E7%AB%AF%E6%9B%B4%E5%8A%A0%E9%A1%BA%E6%89%8B%EF%BC%88%E7%9C%BC%EF%BC%89/"/>
    <url>/2021/08/29/oh-my-zsh%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%BB%88%E7%AB%AF%E6%9B%B4%E5%8A%A0%E9%A1%BA%E6%89%8B%EF%BC%88%E7%9C%BC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>主题：evan</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/12-36-00-26c3a41581cb4dc000d8c78d6ca8a8ce-20220911123600-4f3a26.png"></p><p>主题：dallas</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/12-36-51-167fdec4a32cab8991e86880c5f8ca19-20220911123650-efd6fd.png"></p><p>主题：robbyrussell</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/09/11/12-37-28-73012302d8cccf379a5f7664265e5c26-20220911123727-adbe5e.png"></p><h2 id="如果原先其他电脑安装过"><a href="#如果原先其他电脑安装过" class="headerlink" title="如果原先其他电脑安装过"></a>如果原先其他电脑安装过</h2><p>把<code>.oh-my-zsh</code>整个文件夹，<code>.zshrc</code>，<code>.zsh_history</code>复制到<code>/home/user/</code>目录；</p><p>安装<code>zsh</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">sudo apt install zsh<br><br></code></pre></td></tr></table></figure><p>切换<code>shell</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">chsh -s /bin/zsh<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">source ~/.zshrc<br></code></pre></td></tr></table></figure><p>即可使用。所有配置都会和原先一样。</p><h2 id="如果是新安装"><a href="#如果是新安装" class="headerlink" title="如果是新安装"></a>如果是新安装</h2><p>官方方法，<code>curl</code>和<code>wget</code>二选一即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh<br>wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh<br></code></pre></td></tr></table></figure><p>应该也有人和我一样，可能会遇到连接 GitHub 失败的问题，要不就是 SSL 验证失败，要不就是连接无响应。可以更换下面的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text"># 先下载<br>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh<br>## 再替换<br>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<br></code></pre></td></tr></table></figure><p>重启终端即可成功。</p><p>如果无法访问 GitHub，其实<code>oh-my-zsh</code>并不需要安装，完整的工程就是<code>oh-my-zsh</code>本体，只要想办法把整个工程下载下来，并重命名为<code>oh-my-zsh</code>即可。所以找找 gitee 有没有相关工程。这也是为什么从旧电脑里直接复制<code>.oh-my-zsh</code>就能用的原因。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="oh-my-zsh-sh-parse-error-near-lt-lt-lt-’"><a href="#oh-my-zsh-sh-parse-error-near-lt-lt-lt-’" class="headerlink" title="oh-my-zsh.sh parse error near `&lt;&lt;&lt;’"></a>oh-my-zsh.sh parse error near `&lt;&lt;&lt;’</h3><p>一般是在更新<code>oh-my-zsh</code>时出现，因为更新相当于就是从远程拉取了内容，可能本地的<code>oh-my-zsh.sh</code>脚本自己做了修改与远程冲突了。只要退回上个版本，重新拉取就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$ZSH</span><br>git reset --hard HEAD^<br>git pull --rebase<br></code></pre></td></tr></table></figure><p>如果本地修改了一些内容需要保留，可以打开<code>oh-my-zsh.sh</code>看看冲突在哪，自己做个备份，保存一下。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Plugins</tag>
      
      <tag>zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 绘制系统</title>
    <link href="/2021/08/27/Qt%E7%BB%98%E5%88%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/27/Qt%E7%BB%98%E5%88%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>本篇文章所涉及代码可在<a href="https://github.com/Dunky-Z/learning-qt/tree/main/QtRoad2">此处查看</a>。</p><h2 id="绘制系统简介"><a href="#绘制系统简介" class="headerlink" title="绘制系统简介"></a>绘制系统简介</h2><p>Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于<code>QPainter</code>,<code>QPainterDevice</code>和<code>QPaintEngine</code>三个类。</p><p><code>QPainter</code>用来执行绘制的操作；<code>QPaintDevice</code>是一个二维空间的抽象，这个二维空间允许<code>QPainter</code>在其上面进行绘制，也就是<code>QPainter</code>工作的空间；<code>QPaintEngine</code>提供了画笔（<code>QPainter</code>）在不同的设备上进行绘制的统一的接口。<code>QPaintEngine</code>类应用于<code>QPainter</code>和<code>QPaintDevice</code>之间，通常对开发人员是透明的。</p><p>三个类的关系：<code>QPainter-&gt;QPaintEngine-&gt;QPaintDevice</code>。通过这个关系我们也可以知道，<code>QPainter</code>通过<code>QPaintEngine</code>翻译指令在<code>QPaintDevice</code>上绘制。</p><p>通过一个实例来了解一下绘制系统的，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPainter&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QWidget&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPaintEvent&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaintedWidget</span> :</span> <span class="hljs-keyword">public</span> QWidget<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PaintedWidget</span>(QWidget *parent = <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;paintwidget.h&quot;</span></span><br><br>PaintedWidget::<span class="hljs-built_in">PaintedWidget</span>(QWidget *parent) : <span class="hljs-built_in">QWidget</span>(parent)<br>&#123;<br>    <span class="hljs-built_in">resize</span>(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br>    <span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;Paint Demo&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PaintedWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">700</span>, <span class="hljs-number">20</span>);<br>    painter.<span class="hljs-built_in">setPen</span>(Qt::red);<br>    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>);<br>    painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(Qt::green, <span class="hljs-number">5</span>));<br>    painter.<span class="hljs-built_in">setBrush</span>(Qt::blue);<br>    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>, <span class="hljs-number">40</span>);<br>    <span class="hljs-comment">// painter.drawRect(120, 50, 50, 400);</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    PaintedWidget paintMap;<br>    paintMap.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827184613.png"></p><p>在构造函数中，我们仅仅设置了窗口的大小和标题。而<code>paintEvent()</code>函数则是绘制的代码。</p><p>首先，我们在栈上创建了一个<code>QPainter</code>对象，也就是说，每次运行<code>paintEvent()</code>函数的时候，都会重建这个<code>QPainter</code>对象。注意，这一点可能会引发某些细节问题：由于我们每次重建<code>QPainter</code>，因此第一次运行时所设置的画笔颜色、状态等，第二次再进入这个函数时就会全部丢失。有时候我们希望保存画笔状态，就必须自己保存数据，否则的话则需要将<code>QPainter</code>作为类的成员变量。</p><p><code>paintEvent()</code>作为重绘函数，会在需要重绘时由 Qt 自动调用。“需要重绘”可能发生在很多地方，比如组件刚刚创建出来的时候就需要重绘；<strong>组件最大化、最小化的时候也需要重新绘制</strong>；组件由遮挡变成完全显示的时候也需要等等。</p><p><code>QPainter</code>接收一个<code>QPaintDevice</code>指针作为参数。<code>QPaintDevice</code>有很多子类，比如<code>QImage</code>，以及<code>QWidget</code>。注意回忆一下，<code>QPaintDevice</code>可以理解成要在哪里去绘制，而现在我们希望画在这个组件，因此传入的是 <code>this</code> 指针。</p><p>我们还需要注意绘制的顺序，直线-矩形 - 椭圆，所以直线位于最下方，以此类推。</p><p>如果了解 <code>OpenGL</code>，肯定听说过这么一句话：<code>OpenGL</code> 是一个状态机。所谓状态机，就是说，<code>OpenGL</code> 保存的只是各种状态。比如，将画笔颜色设置成红色，那么，除非你重新设置另外的颜色，它的颜色会一直是红色。<code>QPainter</code>也是这样，它的状态不会自己恢复，除非你使用了各种设置函数。因此，如果在上面的代码中，我们在椭圆绘制之后再画一个矩形，它的样式还会是绿色<code>5</code>像素的轮廓线以及蓝色的填充，除非你显式地调用了设置函数进行状态的更新。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827184538.png"></p><p>这是大多数绘图系统的实现方式，包括 <code>OpenGL</code>、<code>QPainter</code>以及 <code>Java2D</code>。正因为<code>QPainter</code>是一个状态机，才会引出我们前面曾经介绍过的一个细节问题：<strong>由于<code>paintEvent()</code>是需要重复进入的，因此，需要注意第二次进入时，<code>QPainter</code>的状态是不是和第一次一致，否则的话可能会造成闪烁的现象</strong>。这个闪烁并不是由于双缓冲的问题，而是由于绘制状态的快速切换。</p><h2 id="画刷和画笔"><a href="#画刷和画笔" class="headerlink" title="画刷和画笔"></a>画刷和画笔</h2><p>画刷和画笔。前者使用<code>QBrush</code>描述，大多用于填充；后者使用<code>QPen</code>描述，大多用于绘制轮廓线。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PaintedWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">700</span>, <span class="hljs-number">20</span>);<br>    painter.<span class="hljs-built_in">setPen</span>(Qt::red);<br>    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>);<br>    painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(Qt::green, <span class="hljs-number">5</span>));<br>    painter.<span class="hljs-built_in">setBrush</span>(Qt::blue);<br>    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>, <span class="hljs-number">40</span>);<br>    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">120</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">400</span>);<br>    <span class="hljs-comment">///////////////////画笔与笔刷</span><br>    <span class="hljs-function">QLinearGradient <span class="hljs-title">gradient</span><span class="hljs-params">(QPointF(<span class="hljs-number">180</span>, <span class="hljs-number">50</span>), QPointF(<span class="hljs-number">230</span>, <span class="hljs-number">400</span>))</span></span>;<br>    gradient.<span class="hljs-built_in">setColorAt</span>(<span class="hljs-number">0</span>, Qt::black);<br>    gradient.<span class="hljs-built_in">setColorAt</span>(<span class="hljs-number">1</span>, Qt::red);<br>    gradient.<span class="hljs-built_in">setSpread</span>(QGradient::PadSpread);<br><br>    <span class="hljs-function">QBrush <span class="hljs-title">brush</span><span class="hljs-params">(gradient)</span></span>;<br><br>    <span class="hljs-function">QPen <span class="hljs-title">pen</span><span class="hljs-params">(Qt::green, <span class="hljs-number">3</span>, Qt::DashDotLine, Qt::RoundCap, Qt::RoundJoin)</span></span>;<br>    <span class="hljs-comment">// painter.setPen(pen);</span><br>    painter.<span class="hljs-built_in">setBrush</span>(brush);<br>    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">180</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">400</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827190208.png"></p><p>画刷的<code>style()</code>定义了填充的样式，使用<code>Qt::BrushStyle</code>枚举，默认值是<code>Qt::NoBrush</code>，也就是不进行任何填充。我们可以从下面的图示中看到各种填充样式的区别：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827190421.png"></p><p>画刷的<code>gradient()</code>定义了渐变填充。这个属性只有在样式是<code>Qt::LinearGradientPattern</code>、<code>Qt::RadialGradientPattern</code>或者<code>Qt::ConicalGradientPattern</code>之一时才有效。渐变可以由<code>QGradient</code>对象表示。<code>Qt</code> 提供了三种渐变：<code>QLinearGradient</code>、<code>QConicalGradient</code>和<code>QRadialGradient</code>，它们都是<code>QGradient</code>的子类。</p><p>本文以<code>QLinearGradient</code>为例，两个坐标分别为起点与重点坐标。<code>setColorAt</code>设置渐变颜色，<code>0</code>表示开始，<code>1</code>表示结束。意思就是从黑色渐变到红色。<code>setSpread</code>设置显示方式为平铺。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QLinearGradient <span class="hljs-title">gradient</span><span class="hljs-params">(QPointF(<span class="hljs-number">180</span>, <span class="hljs-number">50</span>), QPointF(<span class="hljs-number">230</span>, <span class="hljs-number">400</span>))</span></span>;<br>gradient.<span class="hljs-built_in">setColorAt</span>(<span class="hljs-number">0</span>, Qt::black);<br>gradient.<span class="hljs-built_in">setColorAt</span>(<span class="hljs-number">1</span>, Qt::red);<br>gradient.<span class="hljs-built_in">setSpread</span>(QGradient::PadSpread);<br></code></pre></td></tr></table></figure><p>默认的画笔属性是纯黑色，0 像素，方形笔帽（<code>Qt::SquareCap</code>），斜面型连接（<code>Qt::BevelJoin</code>）。</p><p>画笔样式有一下几种，<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827191748.png"></p><p>你也可以使用<code>setDashPattern()</code>函数自定义样式，例如如下代码片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QVector&lt;qreal&gt; dashes;<br>qreal space = <span class="hljs-number">4</span>;<br><br>dashes &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; space &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; space &lt;&lt; <span class="hljs-number">9</span> &lt;&lt; space<br>        &lt;&lt; <span class="hljs-number">27</span> &lt;&lt; space &lt;&lt; <span class="hljs-number">9</span> &lt;&lt; space;<br>pen.<span class="hljs-built_in">setColor</span>(Qt::black);<br>pen.<span class="hljs-built_in">setDashPattern</span>(dashes);<br>painter.<span class="hljs-built_in">setPen</span>(pen);<br>painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-number">30</span>, <span class="hljs-number">300</span>, <span class="hljs-number">600</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827193722.png"></p><p><code>pen.setCapStyle(Qt::RoundCap)</code>笔帽定义了画笔末端的样式，例如：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827193821.png"></p><p><code>pen.setJoinStyle(Qt::RoundJoin)</code>连接样式定义了两条线连接时的样式，例如：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827193833.png"></p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><p>我们在光栅图形显示器上绘制非水平、非垂直的直线或多边形边界时，或多或少会呈现锯齿状外观。这是因为直线和多边形的边界是连续的，而光栅则是由离散的点组成。在光栅显示设备上表现直线、多边形等，必须在离散位置采样。由于采样不充分重建后造成的信息失真，就叫走样；用于减少或消除这种效果的技术，就称为反走样。也就是常说的防锯齿现象。因为性能方面的考虑，Qt 默认关闭反走样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">///////////////////对比反走样效果</span><br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(Qt::black, <span class="hljs-number">5</span>, Qt::DashDotLine, Qt::RoundCap));<br>    painter.<span class="hljs-built_in">setBrush</span>(Qt::yellow);<br>    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">550</span>, <span class="hljs-number">150</span>, <span class="hljs-number">200</span>, <span class="hljs-number">150</span>);<br><br>    painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<br>    painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(Qt::black, <span class="hljs-number">5</span>, Qt::DashDotLine, Qt::RoundCap));<br>    painter.<span class="hljs-built_in">setBrush</span>(Qt::yellow);<br>    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">300</span>, <span class="hljs-number">150</span>, <span class="hljs-number">200</span>, <span class="hljs-number">150</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830192414.png"></p><p>我们可以明显观察到右边的椭圆轮廓是有锯齿现象的，这两个椭圆除了位置位置不同，唯一的区别就是右边的开启了反锯齿。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>虽然反走样比不反走样的图像质量高很多，但是，没有反走样的图形绘制还是有很大用处的。首先，就像前面说的一样，在一些对图像质量要求不高的环境下，或者说性能受限的环境下，比如嵌入式和手机环境，一般是不进行反走样的。另外，在一些必须精确操作像素的应用中，也是不能进行反走样的。</p><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p>在 Qt 的坐标系统中，每个像素占据 <code>1x1</code> 的空间。你可以把它想象成一张方格纸，每个小格都是 1 个像素。方格的焦点定义了坐标，也就是说，像素 <code>(x, y)</code> 的中心位置其实是在<code>(x + 0.5, y + 0.5)</code>的位置上。这个坐标系统实际上是一个“半像素坐标系”。我们可以通过下面的示意图来理解这种坐标系：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830195728.png"></p><p>我们使用一个像素的画笔进行绘制，可以看到，每一个绘制像素都是以坐标点为中心的矩形。注意，这是坐标的逻辑表示，实际绘制则与此不同。因为在实际设备上，像素是最小单位，我们不能像上面一样，在两个像素之间进行绘制。所以在实际绘制时，Qt 的定义是，绘制点所在像素是逻辑定义点的右下方的像素。</p><p>接下来，我们探究 Qt 绘制图像的坐标情况，<br>对于画笔大小为一个像素的情况比较容易理解，当我们绘制矩形左上角 <code>(1, 2)</code> 时，实际绘制的像素是在右下方。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830195744.png"></p><p>当画笔大小超过 1 个像素时，就略显复杂了。如果绘制像素是偶数，则实际绘制会包裹住逻辑坐标值；如果是奇数，则是包裹住逻辑坐标值，再加上右下角一个像素的偏移。具体请看下面的图示：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830200442.png"></p><p>从上图可以看出，如果实际绘制是偶数像素，则会将逻辑坐标值夹在相等的两部分像素之间；如果是奇数，则会在右下方多出一个像素。</p><p>Qt 的这种处理，带来的一个问题是，我们可能获取不到真实的坐标值。由于历史原因，<code>QRect::right()</code>和<code>QRect::bottom()</code>的返回值并不是矩形右下角点的真实坐标值：<code>QRect::right()</code>返回的是<code>left() + width() - 1</code>；<code>QRect::bottom()</code>则返回 <code>top() + height() - 1</code>，上图的绿色点指出了这两个函数的返回点的坐标。</p><p>为避免这个问题，我们建议是使用<code>QRectF。QRectF</code>使用浮点值，而不是整数值，来描述坐标。这个类的两个函数<code>QRectF::right()</code>和<code>QRectF::bottom()</code>是正确的。如果你不得不使用<code>QRect</code>，那么可以利用 <code>x() + width()</code> 和 <code>y() + height()</code>来替代 <code>right()</code>和<code>bottom()</code>函数。</p><p>对于反走样，实际绘制会包裹住逻辑坐标值：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830201429.png"></p><p>前面说过，<code>QPainter</code>是一个状态机。那么，有时我想保存下当前的状态：当我临时绘制某些图像时，就可能想这么做。当然，我们有最原始的办法：将可能改变的状态，比如画笔颜色、粗细等，在临时绘制结束之后再全部恢复。对此，<code>QPainter</code>提供了内置的函数：<code>save()</code>和<code>restore()</code>。<code>save()</code>就是保存下当前状态；<code>restore()</code>则恢复上一次保存的结果。这两个函数必须成对出现：<code>QPainter</code>使用栈来保存数据，每一次<code>save()</code>，将当前状态压入栈顶，<code>restore()</code>则弹出栈顶进行恢复。</p><p>在了解了这两个函数之后，我们就可以进行示例代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//绘制一个网格背景</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CoordinateWidget::paintGrid</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> win_width = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">width</span>();<br>    <span class="hljs-keyword">size_t</span> win_height = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">height</span>();<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> x = <span class="hljs-number">0</span>; x &lt; win_width; x += <span class="hljs-number">25</span>)<br>    &#123;<br>        painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-built_in">QPoint</span>(x, <span class="hljs-number">1</span>), <span class="hljs-built_in">QPoint</span>(x, win_height));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> y = <span class="hljs-number">0</span>; y &lt; win_height; y += <span class="hljs-number">25</span>)<br>    &#123;<br>        painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-built_in">QPoint</span>(<span class="hljs-number">1</span>, y), <span class="hljs-built_in">QPoint</span>(win_width, y));<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CoordinateWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">paintGrid</span>();<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, Qt::red);<br>    painter.<span class="hljs-built_in">save</span>();<br>    painter.<span class="hljs-built_in">translate</span>(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 向右平移 100px</span><br>    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, Qt::yellow);<br>    painter.<span class="hljs-built_in">restore</span>();<br>    painter.<span class="hljs-built_in">save</span>();<br>    painter.<span class="hljs-built_in">translate</span>(<span class="hljs-number">300</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 向右平移 300px</span><br>    painter.<span class="hljs-built_in">rotate</span>(<span class="hljs-number">30</span>);        <span class="hljs-comment">// 顺时针旋转 30 度</span><br>    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, Qt::green);<br>    painter.<span class="hljs-built_in">restore</span>();<br>    painter.<span class="hljs-built_in">save</span>();<br>    painter.<span class="hljs-built_in">translate</span>(<span class="hljs-number">400</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 向右平移 400px</span><br>    painter.<span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);       <span class="hljs-comment">// 横坐标单位放大 2 倍，纵坐标放大 3 倍</span><br>    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, Qt::blue);<br>    painter.<span class="hljs-built_in">restore</span>();<br>    painter.<span class="hljs-built_in">save</span>();<br>    painter.<span class="hljs-built_in">translate</span>(<span class="hljs-number">600</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 向右平移 600px</span><br>    painter.<span class="hljs-built_in">shear</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);       <span class="hljs-comment">// 横向不变，纵向扭曲 1 倍</span><br>    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, Qt::cyan);<br>    painter.<span class="hljs-built_in">restore</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Qt 提供了四种坐标变换：平移 <code>translate</code>，旋转 <code>rotate</code>，缩放 <code>scale</code> 和扭曲 <code>shear</code>。在这段代码中，我们首先在 <code>(10, 10)</code> 点绘制一个红色的 <code>50x100</code> 矩形。保存当前状态，将坐标系平移到 <code>(100, 0)</code>，绘制一个黄色的矩形。注意，<code>translate()</code>操作平移的是坐标系，不是矩形。因此，我们还是在<code>(10, 10)</code> 点绘制一个 <code>50x100</code> 矩形，现在，它跑到了右侧的位置。然后恢复先前状态，也就是把坐标系重新设为默认坐标系（相当于进行<code>translate(-100, 0)</code>），再进行下面的操作。之后也是类似的。由于我们只是保存了默认坐标系的状态，因此我们之后的<code>translate()</code>横坐标值必须增加，否则就会覆盖掉前面的图形。所有这些操作都是针对坐标系的，因此在绘制时，我们提供的矩形的坐标参数都是不变的。</p><p>为了更直观的查看绘制坐标，先在背景画了一个网格。</p><p>运行结果如下：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830201720.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 入门 - 计算机基础</title>
    <link href="/2021/08/26/RISC-V%E5%85%A5%E9%97%A8-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/08/26/RISC-V%E5%85%A5%E9%97%A8-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机硬件基础"><a href="#计算机硬件基础" class="headerlink" title="计算机硬件基础"></a>计算机硬件基础</h3><p>两大硬件架构</p><ul><li><p>冯诺依曼架构</p><ul><li><p>一根总线，开销小，控制逻辑实现简单</p></li><li><p>执行效率低</p></li></ul></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211529332.png"></p><ul><li><p>哈佛架构</p><ul><li>与上一架构相反</li></ul></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211529619.png"></p><h3 id="程序的存储与执行"><a href="#程序的存储与执行" class="headerlink" title="程序的存储与执行"></a>程序的存储与执行</h3><p><code>.c</code>文件经过编译链接，生成<code>.out</code>文件。加载到内存中，到控制单元运行。进行取值，译码，执行。</p><p>晶振发出脉冲。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211621792.png"></p><h3 id="语言的设计与进化"><a href="#语言的设计与进化" class="headerlink" title="语言的设计与进化"></a>语言的设计与进化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211735861.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211736944.png"><br>上图是冯诺依曼架构，特点就是指令与数据放在一起。黄色部分表示指令，绿色部分表示数据。我们来看看指令是如何执行的。<br><code>ProgramCounter</code>指到右图内存的第一条指令，程序开始执行。将第一条 指令读入指令寄存器。然后将指令解码，根据之前的规定，我们可以知道这条指令是将<code>0100(二进制即 5)</code>位置的数据，<code>00(load)</code>到<code>00(Register 0)</code>中。下面的指令一次类推，每次取指，<code>Program Counter</code>移动一次。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211743999.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211719114.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 单步调试 QEMU</title>
    <link href="/2021/08/24/VSCode%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95QEMU/"/>
    <url>/2021/08/24/VSCode%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95QEMU/</url>
    
    <content type="html"><![CDATA[<p>了解了如何在<a href="https://dunky-z.github.io/2021/08/23/VSCode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/">VSCode 中调试程序</a>，接下来我们在 VSCode 中搭建调试 QEMU 的环境。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先我们需要<a href="https://dunky-z.github.io/2021/07/23/QEMU%E5%88%9D%E8%AF%86/">下载和编译 QEMU 源码</a></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span> <span class="hljs-params">--enable-debug</span> <span class="hljs-params">--target-list=riscv32-softmmu</span>,riscv32-linux-user <span class="hljs-params">--enable-kvm</span><br></code></pre></td></tr></table></figure><p>一定要加上<code>--enable-debug</code>，编译出的程序才带有调试信息，不用设置安装路径，编译时会自动在 qemu 文件夹下自动创建一个<code>build</code>文件夹，编译后的程序也在<code>build</code>文件夹下。</p><p>用 VSCode 打开<code>qemu-6.X.X</code>文件夹，<code>Ctrl+Shift+D</code>打开调试配置。如果参考过<a href="https://dunky-z.github.io/2021/08/23/VSCode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/">VSCode 中调试程序</a>这篇文章，接下来就很容易。我们只需要将<code>launch.jason</code>文件中的<code>program</code>属性改为<code>$&#123;workspaceFolder&#125;/build/qemu-system-riscv32</code>即可。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>打开<code>qemu-6.X.X/softmmu/main.c</code>文件，在<code>main</code>函数入口处打上断点，即可开始调试。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824194442.png"></p><p>现在只需要点击屏幕上的图标，就可以快速的进行单步调试。</p><p>如果需要进行命令行操作，在屏幕下方打开<code>DEBUG CONSOLE</code>，输入<code>-exec+正常命令行下的命令</code>即可在命令行中进行更多的调试。如查看断点信息<code>-exec info breakpoints</code></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824201427.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>VSCode</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 模仿登录界面-页面反转效果</title>
    <link href="/2021/08/24/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E9%A1%B5%E9%9D%A2%E5%8F%8D%E8%BD%AC%E6%95%88%E6%9E%9C/"/>
    <url>/2021/08/24/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E9%A1%B5%E9%9D%A2%E5%8F%8D%E8%BD%AC%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>设置一个旋转效果，将登录界面旋转翻个面，设置一些网络参数。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826100416.gif"></p><h2 id="网络参数设置界面布局"><a href="#网络参数设置界面布局" class="headerlink" title="网络参数设置界面布局"></a>网络参数设置界面布局</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824144033.png"></p><h2 id="网络参数设置界面"><a href="#网络参数设置界面" class="headerlink" title="网络参数设置界面"></a>网络参数设置界面</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//loginnetsetwindow.cpp</span><br><span class="hljs-comment">//初始化标题</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginNetSetWindow::initMyTitle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> m_titleBar-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br> m_titleBar-&gt;<span class="hljs-built_in">raise</span>();<br> m_titleBar-&gt;<span class="hljs-built_in">setBackgroundColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br> m_titleBar-&gt;<span class="hljs-built_in">setButtonType</span>(MIN_BUTTON);<br> m_titleBar-&gt;<span class="hljs-built_in">setTitleWidth</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>());<br> m_titleBar-&gt;<span class="hljs-built_in">setMoveParentWindowFlag</span>(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginNetSetWindow::initWindow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> QLabel* pBack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QLabel</span>(<span class="hljs-keyword">this</span>);<br> QMovie *movie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QMovie</span>();<br> movie-&gt;<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;:/Resources/NetSetWindow/headBack.gif&quot;</span>);<br> pBack-&gt;<span class="hljs-built_in">setMovie</span>(movie);<br> movie-&gt;<span class="hljs-built_in">start</span>();<br> pBack-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br> <span class="hljs-built_in">connect</span>(ui.pButtonOk, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">rotateWindow</span>()));<br> <span class="hljs-built_in">connect</span>(ui.pButtonCancel, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">rotateWindow</span>()));<br> <br>    ui.comboBoxNetType-&gt;<span class="hljs-built_in">addItem</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;不使用代理&quot;</span>));<br> ui.comboBoxServerType-&gt;<span class="hljs-built_in">addItem</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;不使用高级选项&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginNetSetWindow::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// 绘制背景图;</span><br> <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br> QPainterPath pathBack;<br> pathBack.<span class="hljs-built_in">setFillRule</span>(Qt::WindingFill);<br> pathBack.<span class="hljs-built_in">addRoundedRect</span>(<span class="hljs-built_in">QRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>(), <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>()), <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br> painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<br> painter.<span class="hljs-built_in">fillPath</span>(pathBack, <span class="hljs-built_in">QBrush</span>(<span class="hljs-built_in">QColor</span>(<span class="hljs-number">235</span>, <span class="hljs-number">242</span>, <span class="hljs-number">249</span>)));<br> <br> QPainterPath pathBottom;<br> pathBottom.<span class="hljs-built_in">setFillRule</span>(Qt::WindingFill);<br> pathBottom.<span class="hljs-built_in">addRoundedRect</span>(<span class="hljs-built_in">QRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">300</span>, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>(), <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() - <span class="hljs-number">300</span>), <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br> painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<br> painter.<span class="hljs-built_in">fillPath</span>(pathBottom, <span class="hljs-built_in">QBrush</span>(<span class="hljs-built_in">QColor</span>(<span class="hljs-number">205</span>, <span class="hljs-number">226</span>, <span class="hljs-number">242</span>)));<br><br> painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(<span class="hljs-built_in">QColor</span>(<span class="hljs-number">160</span> , <span class="hljs-number">175</span> , <span class="hljs-number">189</span>)));<br> painter.<span class="hljs-built_in">drawRoundedRect</span>(<span class="hljs-built_in">QRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>(), <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>()), <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>initMyTitle()</code>就不多说了，和正面登录界面差不多。</p><h3 id="QPainterPath类"><a href="#QPainterPath类" class="headerlink" title="QPainterPath类"></a><code>QPainterPath</code>类</h3><p>它是由一些图形如曲线、矩形、椭圆组成的对象。主要的用途是，能保存已经绘制好的图形。实现图形元素的构造和复用；图形状只需创建一次，然后调用<code>QPainter::drawPath()</code> 函数多次绘制。<code>painterpath</code>可以加入闭合或不闭合的图形 ( 如：矩形、椭圆和曲线) 。<code>QPainterPath</code> 可用于填充，描边，clipping。</p><h4 id="setFillRule-设置填充模式"><a href="#setFillRule-设置填充模式" class="headerlink" title="setFillRule()设置填充模式"></a><code>setFillRule()</code>设置填充模式</h4><p>不是很理解<br> <a href="https://doc.qt.io/qt-5/qt.html#FillRule-enum">https://doc.qt.io/qt-5/qt.html#FillRule-enum</a></p><h4 id="addRoundedRect-QRect-0-0-this-gt-width-this-gt-height-3-3-圆角矩形"><a href="#addRoundedRect-QRect-0-0-this-gt-width-this-gt-height-3-3-圆角矩形" class="headerlink" title="addRoundedRect(QRect(0, 0, this-&gt;width(), this-&gt;height()), 3, 3)圆角矩形"></a><code>addRoundedRect(QRect(0, 0, this-&gt;width(), this-&gt;height()), 3, 3)</code>圆角矩形</h4><ul><li><code>QRect(0, 300, this-&gt;width(), this-&gt;height() - 300)</code>设置了矩形的位置及大小</li><li><code>(3,3)</code>表示倒圆角的大小</li></ul><h3 id="setRenderHint-开启反走样"><a href="#setRenderHint-开启反走样" class="headerlink" title="setRenderHint()开启反走样"></a><code>setRenderHint()</code>开启反走样</h3><ul><li><code>QPainter::Antialiasing</code>           告诉绘图引擎应该在可能的情况下进行边的反锯齿绘制</li><li><code>QPainter::TextAntialiasing</code>       尽可能的情况下文字的反锯齿绘制</li><li><code>QPainter::SmoothPixmapTransform</code> 使用平滑的 pixmap 变换算法 (双线性插值算法),而不是近邻插值算</li></ul><h2 id="初始化旋转窗口"><a href="#初始化旋转窗口" class="headerlink" title="初始化旋转窗口"></a>初始化旋转窗口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化旋转的窗口;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RotateWidget::initRotateWindow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> m_loginWindow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LoginWindow</span>(<span class="hljs-keyword">this</span>);<br> <span class="hljs-comment">// 这里定义了两个信号，需要自己去发送信号;</span><br> <span class="hljs-built_in">connect</span>(m_loginWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">rotateWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onRotateWindow</span>()));<br> <span class="hljs-built_in">connect</span>(m_loginWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">closeWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">close</span>()));<br> <span class="hljs-built_in">connect</span>(m_loginWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">hideWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onHideWindow</span>()));<br><br> m_loginNetSetWindow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LoginNetSetWindow</span>(<span class="hljs-keyword">this</span>);<br> <span class="hljs-built_in">connect</span>(m_loginNetSetWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">rotateWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onRotateWindow</span>()));<br> <span class="hljs-built_in">connect</span>(m_loginNetSetWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">closeWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">close</span>()));<br> <span class="hljs-built_in">connect</span>(m_loginNetSetWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">hideWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onHideWindow</span>()));<br><br> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">addWidget</span>(m_loginWindow);<br> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">addWidget</span>(m_loginNetSetWindow);<br><br> <span class="hljs-comment">// 这里宽和高都增加，是因为在旋转过程中窗口宽和高都会变化;</span><br> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setFixedSize</span>(<span class="hljs-built_in">QSize</span>(m_loginWindow-&gt;<span class="hljs-built_in">width</span>() + <span class="hljs-number">20</span>, m_loginWindow-&gt;<span class="hljs-built_in">height</span>() + <span class="hljs-number">100</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>对正面和反面分别定义了信号槽，当对应的面接收到信号时，执行对应的动作。因为是旋转一百八十度，所以选择函数可以公用。</p><h2 id="旋转窗口"><a href="#旋转窗口" class="headerlink" title="旋转窗口"></a>旋转窗口</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824182705.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 开始旋转窗口;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RotateWidget::onRotateWindow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// 如果窗口正在旋转，直接返回;</span><br> <span class="hljs-keyword">if</span> (m_isRoratingWindow)<br> &#123;<br>  <span class="hljs-keyword">return</span>;<br> &#125;<br> m_isRoratingWindow = <span class="hljs-literal">true</span>;<br> m_nextPageIndex = (<span class="hljs-built_in">currentIndex</span>() + <span class="hljs-number">1</span>) &gt;= <span class="hljs-built_in">count</span>() ? <span class="hljs-number">0</span> : (<span class="hljs-built_in">currentIndex</span>() + <span class="hljs-number">1</span>);<br> QPropertyAnimation *rotateAnimation = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPropertyAnimation</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;rotateValue&quot;</span>);<br> <span class="hljs-comment">// 设置旋转持续时间;</span><br> rotateAnimation-&gt;<span class="hljs-built_in">setDuration</span>(<span class="hljs-number">1500</span>);<br> <span class="hljs-comment">// 设置旋转角度变化趋势;</span><br> rotateAnimation-&gt;<span class="hljs-built_in">setEasingCurve</span>(QEasingCurve::InCubic);<br> <span class="hljs-comment">// 设置旋转角度范围;</span><br> rotateAnimation-&gt;<span class="hljs-built_in">setStartValue</span>(<span class="hljs-number">0</span>);<br> rotateAnimation-&gt;<span class="hljs-built_in">setEndValue</span>(<span class="hljs-number">180</span>);<br> <span class="hljs-built_in">connect</span>(rotateAnimation, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">valueChanged</span>(QVariant)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">repaint</span>()));<br> <span class="hljs-built_in">connect</span>(rotateAnimation, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">finished</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onRotateFinished</span>()));<br> <span class="hljs-comment">// 隐藏当前窗口，通过不同角度的绘制来达到旋转的效果;</span><br> <span class="hljs-built_in">currentWidget</span>()-&gt;<span class="hljs-built_in">hide</span>();<br> rotateAnimation-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-comment">// 旋转结束;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RotateWidget::onRotateFinished</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> m_isRoratingWindow = <span class="hljs-literal">false</span>;<br> <span class="hljs-built_in">setCurrentWidget</span>(<span class="hljs-built_in">widget</span>(m_nextPageIndex));<br> <span class="hljs-built_in">repaint</span>();<br>&#125;<br>/ 绘制旋转效果;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RotateWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m_isRoratingWindow)<br>    &#123;<br>        <span class="hljs-comment">// 小于 90 度时;</span><br>        <span class="hljs-keyword">int</span> rotateValue = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">property</span>(<span class="hljs-string">&quot;rotateValue&quot;</span>).<span class="hljs-built_in">toInt</span>();<br>        <span class="hljs-keyword">if</span> (rotateValue &lt;= <span class="hljs-number">90</span>)<br>        &#123;<br>            <span class="hljs-function">QPixmap <span class="hljs-title">rotatePixmap</span><span class="hljs-params">(currentWidget()-&gt;size())</span></span>;<br>            <span class="hljs-built_in">currentWidget</span>()-&gt;<span class="hljs-built_in">render</span>(&amp;rotatePixmap);<br>            <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>            painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing);<br>            QTransform transform;<br>            transform.<span class="hljs-built_in">translate</span>(<span class="hljs-built_in">width</span>() / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>            transform.<span class="hljs-built_in">rotate</span>(rotateValue, Qt::YAxis);<br>            painter.<span class="hljs-built_in">setTransform</span>(transform);<br>            painter.<span class="hljs-built_in">drawPixmap</span>(<span class="hljs-number">-1</span> * <span class="hljs-built_in">width</span>() / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, rotatePixmap);<br>        &#125;<br>        <span class="hljs-comment">// 大于 90 度时</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            QPixmap <span class="hljs-built_in">rotatePixmap</span>(<span class="hljs-built_in">widget</span>(m_nextPageIndex)-&gt;<span class="hljs-built_in">size</span>());<br>            <span class="hljs-built_in">widget</span>(m_nextPageIndex)-&gt;<span class="hljs-built_in">render</span>(&amp;rotatePixmap);<br>            <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>            painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing);<br>            QTransform transform;<br>            transform.<span class="hljs-built_in">translate</span>(<span class="hljs-built_in">width</span>() / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>            transform.<span class="hljs-built_in">rotate</span>(rotateValue + <span class="hljs-number">180</span>, Qt::YAxis);<br>            painter.<span class="hljs-built_in">setTransform</span>(transform);<br>            painter.<span class="hljs-built_in">drawPixmap</span>(<span class="hljs-number">-1</span> * <span class="hljs-built_in">width</span>() / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, rotatePixmap);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> QStackedWidget::<span class="hljs-built_in">paintEvent</span>(event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="QPropertyAnimation动画类"><a href="#QPropertyAnimation动画类" class="headerlink" title="QPropertyAnimation动画类"></a><code>QPropertyAnimation</code>动画类</h3><p><code>QPropertyAnimation *rotateAnimation = new QPropertyAnimation(this, &quot;rotateValue&quot;)</code></p><ul><li><code>rotateValue</code>就是这个动画的属性，我们这个动画中变化的就是旋转值，也就是旋转角度。这个属性名完全自己起，也可以改成<code>rotateAngle</code>等等，或者说想做一个平移的动画，也可以取一个<code>moveDist</code>等名字。</li></ul><p>下面这一串就是标准的一套动画流程</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// 设置旋转持续时间;</span><br><span class="hljs-function"><span class="hljs-title">rotateAnimation</span>-&gt;</span>setDuration(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 设置旋转角度变化趋势;</span><br><span class="hljs-function"><span class="hljs-title">rotateAnimation</span>-&gt;</span>setEasingCurve(QEasingCurve::InCubic);<br><span class="hljs-comment">// 设置旋转角度范围;</span><br><span class="hljs-function"><span class="hljs-title">rotateAnimation</span>-&gt;</span>setStartValue(<span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-title">rotateAnimation</span>-&gt;</span>setEndValue(<span class="hljs-number">180</span>);<br><span class="hljs-comment">//开始动画</span><br><span class="hljs-function"><span class="hljs-title">rotateAnimation</span>-&gt;</span>start();<br></code></pre></td></tr></table></figure><h3 id="paintEvent绘图事件"><a href="#paintEvent绘图事件" class="headerlink" title="paintEvent绘图事件"></a><code>paintEvent</code>绘图事件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;rotatewidget.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    RotateWidget w;<br>    w.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们<code>main</code>函数得知，最开始显示的窗口就是<code>RotateWidget</code>。在实例化一个<code>RotateWidget</code>类后，进行了标题栏的初始化工作，然后开始执行<code>w.show()</code>显示，但是此时窗口是不显示的。这是因为我们在<code>RotateWidget</code>的构造函数中进行了设置不显示窗口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setWindowFlags</span>(Qt::FramelessWindowHint | <br>Qt::WindowStaysOnTopHint | <br>Qt::WindowMinimizeButtonHint);<br></code></pre></td></tr></table></figure><p>当运行到<code>return a.exec()</code>时，Qt 会自动调用<code>void RotateWidget::paintEvent()</code>。此时开始正式绘制窗口，但是因为我们还没哟点击登录页面的网络设置按钮，所以<code>m_isRoratingWindow=0</code>。会调用父类的绘图事件，<code>QStackedWidget::paintEvent()</code>，最后也就是<code>BaseWindow::paintEvent()</code>。会将登录页面先绘制出来。</p><p>当我们点击网络设置按钮时，<code>m_isRoratingWindow=1</code>开始绘制旋转画面。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 操作系统-系统初始化</title>
    <link href="/2021/08/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2021/08/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><h3 id="x86-架构概述"><a href="#x86-架构概述" class="headerlink" title="x86 架构概述"></a>x86 架构概述</h3><p><strong>CPU（Central Processing Unit）</strong>：中央处理器，计算机所有设备都围绕它展开工作。</p><ul><li>运算单元：只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。</li><li>数据单元：运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了数据单元。数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。</li><li>控制单元：有了放数据的地方，也有了算的地方，还需要有个指挥到底做什么运算的地方，这就是控制单元。控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。</li></ul><p><strong>内存（Memory）</strong>：CPU 本身不能保存大量数据，许多复杂的计算需要将中间结果保存下来就必须用到内存。</p><p><strong>总线（Bus）</strong>：CPU 和其他设备连接，就靠总线，其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。</p><ul><li>地址总线：传输地址数据（我想拿内存中哪个位置的数据）</li><li>数据总线：传输真正的数据</li></ul><p>总线就像 CPU 和内存之间的高速公路，总线多少位就类似高速公路多少个车道，但两种总线的位数意义不同。</p><p>地址总线的位数决定了访问地址范围有多广，数据总线位数决定了一次能拿多少数据进来。那么 CPU 中总线的位数有没有标准呢？如果没有标准，那操作系统作为软件就很难办了，因为软件层没办法实现通用的运算逻辑。早期每家公司的 CPU 架构都不同，后来历史将 x86 平台推到了<strong>开放，统一，兼容</strong>的位置。</p><h4 id="8086-架构图"><a href="#8086-架构图" class="headerlink" title="8086 架构图"></a>8086 架构图</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721092854.png"></p><p><strong>数据单元：</strong> 8086 处理器内部共有 8 个 16 位的通用寄存器，分别是 数据寄存器（AX、BX、CX、DX）、指针寄存器（SP、BP）、变址寄存器（SI、DI）。其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。</p><p><strong>控制单元：</strong> IP 寄存器（Instruction Pointer Register）就是指令指针寄存器，它指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。</p><p>如果需要切换进程呢？每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS、DS、SS、ES。</p><p>其中，<strong>CS</strong> 就是代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置；<strong>DS</strong> 是数据段的寄存器（Data Segment Register），通过它可以找到数据在内存中的位置。<strong>SS</strong> 是栈寄存器（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则。<strong>ES</strong>是扩展段寄存器（Extra Segment Register）顾名思义。</p><p>如果 CPU 运算中需要加载内存中的数据，需要通过 DS 找到内存中的数据，加载到通用寄存器中，应该如何加载呢？对于一个段，有一个起始的地址，而段内的具体位置，我们称为<strong>偏移量（Offset）</strong>。在 CS 和 DS 中都存放着一个段的起始地址。<strong>代码段的偏移量在 IP 寄存器中</strong>，<strong>数据段的偏移量会放在通用寄存器中</strong>。因为段寄存器都是 16 位的，而地址总线是 20 位的，所以通过 *<em>起始地址 <em>16+ 偏移量</em></em> 的方式，将寻址位数都变成 20 位，也就是将 CS 和 DS 的值左移 4 位。</p><p>对于只有 20 位地址总线的 8086 来说，寻址空间最大也就是$2^{20}=1\text{M}$，超过这个位置就访问不到了，一个段因为偏移量只有 16 位，所以一个段最大是$2^{16}=64\text{k}$。</p><h4 id="32-位处理器"><a href="#32-位处理器" class="headerlink" title="32 位处理器"></a>32 位处理器</h4><p>随着计算机发展，内存越来越大，总线也越来越宽。在 32 位处理器中，有 32 根地址总线，可以访问 $2^{32}=4\text{G}$ 的内存。使用原来的模式肯定不行了，但是又不能完全抛弃原来的模式，因为这个架构是<strong>开放的</strong>。那么在开发架构的基础上如何保持兼容呢？</p><p>首先，通用寄存器有扩展，可以将 8 个 16 位的扩展到 8 个 32 位的，但是依然可以保留 16 位的和 8 位的使用方式。其中，指向下一条指令的指令指针寄存器 IP，就会扩展成 32 位的，同样也兼容 16 位的。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721103205.png"></p><p>段寄存器改动较大，新的段寄存器都改成了 32 位的，每个寄存器又分为<strong>段描述符缓存器（Segment Descriptor）</strong>，和<strong>段选择子寄存器（Selector）</strong> ,现在的段寄存器不在是段的起始地址，段的起始地址保存在表格一样的段描述符缓冲器中，段选择子寄存器保存地址在段描述符缓存器中的哪一项。这样，将一个从段寄存器直接拿到的段起始地址，就变成了<strong>先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。</strong></p><p>虽然现在的这种模式和之前的模式不兼容，但是后面这种模式灵活的非常高，可以保持一直兼容下去。在 32 位的系统架构下，将前一种模式称为<strong>实模式（Real Pattern）</strong>，后一种模式称为<strong>保护模式（Protected Pattern）</strong> 。当系统刚刚启动的时候，CPU 是处于实模式的，这个时候和原来的模式是兼容的。也就是说，哪怕你买了 32 位的 CPU，也支持在原来的模式下运行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721104550.png"></p><blockquote><p>汇编命令学习<br>mov,<br>call, jmp, int, ret, add, or, xor, shl, shr, push, pop, inc, dec, sub, cmp。</p></blockquote><h3 id="BIOS-与-BootLoader"><a href="#BIOS-与-BootLoader" class="headerlink" title="BIOS 与 BootLoader"></a>BIOS 与 BootLoader</h3><p>BIOS：基本输入输出系统</p><p>ROM：只读存储器</p><p>RAM：随机存取存储器</p><p>在我们按下电脑电源键的那一刻，主板就加电了，CPU 就要开始执行指令了，但是刚开始操作系统都没，CPU 执行什么指令呢？这就有了<code>BIOS</code>，它相当于一个指导手册，告诉 CPU 接下来要干啥。</p><p>刚开机时，系统初始化代码从 ROM 读取，将 <code>CS</code> 设置为 <code>0xFFFF</code>，将 <code>IP</code> 设置为 <code>0x0000</code>，所以第一条指令就会指向 <code>0xFFFF0</code>，初始化完成后确定访问指令位置。</p><p>接下来 BIOS 会检查各个硬件是否正常，检测内容显卡等关键部件的存在于工作状态，设备初始化，执行系统 BIOS 进行系统检测，更新 CMOS 中的扩展系统配置数据 ESCD。这期间也会建立中断向量表和中断服务程序，因为要使用键盘鼠标都需要中断进行。</p><p>下一步 BIOS 就得要找操作系统了，操作系统一般安装在硬盘上，但是 BIOS 得先找到启动盘，启动盘一般安装在第一个扇区，占 512 字节，会包含启动的相关代码。在 Linux 中，可以通过<code>Grub2</code>配置这些代码。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">grub2-mkconfig -o <span class="hljs-regexp">/boot/g</span>rub2/grub.cfg<br></code></pre></td></tr></table></figure><p><code>grub2</code>第一个要安装的就是<code>boot.img</code>。它由 <code>boot.S</code>编译而成，一共 <code>512</code> 字节，正式安装到启动盘的第一个扇区。这个扇区通常称为<code>MBR</code>（Master Boot Record，主引导记录 / 扇区）。</p><p><code>BIOS</code> 完成任务后，会将 <code>boot.img</code> 从硬盘加载到内存中的 <code>0x7c00</code>来运行。</p><p>由于 <code>512</code> 个字节实在有限，<code>boot.img</code> 做不了太多的事情。它能做的最重要的一个事情就是加载<code>grub2</code> 的另一个镜像 <code>core.img</code>。</p><p><code>core.img</code> 由<code>lzma_decompress.img</code>、<code>diskboot.img</code>、<code>kernel.img</code> 和一系列的模块组成，功能比较丰富，能做很多事情。</p><p><code>boot.img</code> 先加载的是 <code>core.img</code> 的第一个扇区。如果从硬盘启动的话，这个扇区里面是<code>diskboot.img</code>，对应的代码是 <code>diskboot.S</code>。</p><p><code>boot.img</code> 将控制权交给 <code>diskboot.img</code> 后，<code>diskboot.img</code> 的任务就是将<code>core.img</code> 的其他部分加载进来，先是解压缩程序 <code>lzma_decompress.img</code>，再往下是 <code>kernel.img</code>，最后是各个模块<code>module</code>对应的映像。这里需要注意，它不是 Linux 的内核，而是<code>grub</code> 的内核。</p><p>在这之前，我们所有遇到过的程序都非常非常小，完全可以在实模式下运行，但是随着我们加载的东西越来越大，实模式这<code>1M</code> 的地址空间实在放不下了，所以在真正的解压缩之前，<code>lzma_decompress.img</code> 做了一个重要的决定，就是调用 <code>real_to_prot</code>，切换到<strong>保护模式</strong>，这样就能在更大的寻址空间里面，加载更多的东西。</p><p><code>BIOS</code>将加载程序从硬盘的引导扇区加载到指定位置，再跳转到指定位置，将控制权转交给加载程序。加载程序将操作系统代码读取到内存，并将控制权转到操作系统。</p><blockquote><p>Q：BIOS-操作系统，中间经过加载程序。为何不直接读取？<br>A：磁盘文件系统多种多样，硬盘出厂时不能限制只能用一种文件系统，而 BIOS 也不能加上识别所有文件系统的代码。所有为了灵活性只读取磁盘的一块，由加载程序来识别磁盘的文件系统。</p></blockquote><p>切换到保护模式后，将会做以下这些事，大多数都与内存访问方式有关。</p><p>首先<strong>启动分段</strong>，就是在内存里面<strong>建立段描述符表</strong>，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。</p><p>接着是<strong>启动分页</strong>。能够管理的内存变大了，就需要将内存分成相等大小的块。</p><p><strong>打开 Gate20</strong>，也就是第 21 根地址线的控制线。因为在实模式 8086 下，一共就 20 根地址线，最大访问<code>1M</code>的地址空间。切换保护模式的函数<code>DATA32 call real_to_prot</code>会打开<code>Gate A20</code>。</p><p>现在好了，有的是空间了。接下来我们要对压缩过的 <strong>kernel.img 进行解压缩</strong>，然后跳转到 <code>kernel.img</code> 开始运行。</p><h3 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h3><ul><li>start_kernel()<ul><li>INIT_TASK(init_task)</li><li>trap_init()</li><li>mm_init()</li><li>sched_init()</li><li>rest_init()<ul><li>kernel_thread(kernel_init, NULL,CLONE_FS)</li><li>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)</li></ul></li></ul></li></ul><p>内核的启动从入口函数<code>start_kernel()</code> 开始。在 <code>init/main.c</code> 文件中，<code>start_kernel</code> 相当于内核的 <code>main</code> 函数。打开这个函数，我们会发现，里面是各种各样初始化函数 <code>XXXX_init</code>。</p><p>在操作系统里面，先要有个<strong>创始进程</strong>，有一行指令 <code>set_task_stack_end_magic(&amp;init_task)</code>。这里面有一个参数 <code>init_task</code>，它的定义是 <code>struct task_struct init_task = INIT_TASK(init_task)</code>。它是系统创建的第一个进程，我们称为<code>0</code>号进程。这是唯一一个没有通过<code>fork</code> 或者<code>kernel_thread</code> 产生的进程，是进程列表的第一个。</p><p><code>trap_init()</code>里设置了很多**中断门 (Interrupt Gate)**处理各种中断。</p><p><code>mm_init()</code>初始化内存管理模块，<code>sched_init()</code>初始化调度模块。</p><p><code>vfs_caches_init()</code> 会用来初始化基于内存的文件系统 <code>rootfs</code>。在这个函数里面，会调用 <code>mnt_init()-&gt;init_rootfs()</code>。这里面有一行代码，<code>register_filesystem(&amp;rootfs_fs_type)</code>。在 VFS 虚拟文件系统里面注册了一种类型，我们定义为 <code>struct file_system_type rootfs_fs_type</code>。为了兼容各种各样的文件系统，我们需要将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一的接口，这个抽象层就是 <code>VFS（Virtual File System）</code>，虚拟文件系统。</p><p>最后<code>start_kernel()</code>调用<code>rest_init()</code>来做其他方面的初始化，如初始化 1 号进程，内核态与用户态转化等。</p><p><code>rest_init</code> 的第一大工作是，用 <code>kernel_thread(kernel_init, NULL, CLONE_FS)</code>创建第二个进程，这个是<strong>1 号进程</strong>。这对操作系统意义非凡，因为他将运行第一个用户进程，一旦有了用户进程，运行模式也将发生改变，之前所有资源都是给一个进程用，现在有了用户进程，就会出现抢夺资源的现象。资源也分核心和非核心资源，具有不同权限的进程可以获取不同的资源。<code>x86</code>提供了分层的权限机制，分成四个<code>Ring</code>，越往里权限越高。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210727192141.png"></p><p>操作系统很好地利用了这个机制，将能够访问关键资源的代码放在 <code>Ring0</code>，我们称为<strong>内核态</strong>（Kernel Mode）；将普通的程序代码放在 <code>Ring3</code>，我们称为<strong>用户态</strong>（User Mode）。</p><p>继续探究<code>kernel_thread()</code>这个函数，它的一个参数有一个函数<code>kernel_init</code>，在这个函数里会调用<code>kernel_init_freeable()</code>，里面有这样一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!ramdisk_execute_command)<br>    ramdisk_execute_command = <span class="hljs-string">&quot;/init&quot;</span>;<br></code></pre></td></tr></table></figure><p>先不管<code>ramdisk</code> 是啥，我们回到 <code>kernel_init</code> 里面。这里面有这样的代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ramdisk_execute_command) &#123;<br>  ret = run_init_process(ramdisk_execute_command);<br>....<br>&#125;<br>....<br><span class="hljs-keyword">if</span> (!try_to_run_init_process(<span class="hljs-string">&quot;/sbin/init&quot;</span>) ||<br>    !try_to_run_init_process(<span class="hljs-string">&quot;/etc/init&quot;</span>) ||<br>    !try_to_run_init_process(<span class="hljs-string">&quot;/bin/init&quot;</span>) ||<br>    !try_to_run_init_process(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>我们可以发现，1 号进程运行的是一个文件，如果我们打开<code>run_init_process</code>函数，会发现它调用的是<code>do_execve</code>。</p><p>前面讲系统调用的时候，<code>execve</code> 是一个系统调用，它的作用是运行一个执行文件。加一个 <code>do_</code> 的往往是内核系统调用的实现。没错，这就是一个系统调用，它会尝试运行 <code>ramdisk</code> 的“<code>/init”</code>，或者普通文件系统上的<code>“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”</code>。不同版本的 Linux 会选择不同的文件启动，但是只要有一个起来了就可以。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run_init_process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *init_filename)</span></span><br><span class="hljs-function"></span>&#123;<br>  argv_init[<span class="hljs-number">0</span>] = init_filename;<br>  <span class="hljs-keyword">return</span> do_execve(getname_kernel(init_filename),<br>    (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *<span class="hljs-keyword">const</span> __user *)argv_init,<br>    (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *<span class="hljs-keyword">const</span> __user *)envp_init);<br>&#125;<br></code></pre></td></tr></table></figure><p>如何利用执行 <code>init</code> 文件的机会，从内核态回到用户态呢？</p><p>我们从系统调用的过程可以得到启发，“用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态”，然后接着运行。而咱们刚才运行<code>init</code>，是调用 <code>do_execve</code>，正是上面的过程的后半部分，从内核态执行系统调用开始。</p><p><code>do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler</code>，这里面会调用这段内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search_binary_handler</span><span class="hljs-params">(struct linux_binprm *bprm)</span></span><br><span class="hljs-function"></span>&#123;<br>  ......<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> *<span class="hljs-title">fmt</span>;</span><br>  ......<br>  retval = fmt-&gt;load_binary(bprm);<br>  ......<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，我要运行一个程序，需要加载这个二进制文件，这就是我们常说的项目执行计划书。它是有一定格式的。Linux 下一个常用的格式是 ELF（Executable and Linkable Format，可执行与可链接格式）。于是我们就有了下面这个定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> <span class="hljs-title">elf_format</span> =</span> &#123;<br>.<span class="hljs-keyword">module</span>  = THIS_MODULE,<br>.load_binary  = load_elf_binary,<br>.load_shlib  = load_elf_library,<br>.core_dump  = elf_core_dump,<br>.min_coredump  = ELF_EXEC_PAGESIZE,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这其实就是先调用 <code>load_elf_binary</code>，最后调用 <code>start_thread</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">start_thread</span><span class="hljs-params">(struct pt_regs *regs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> new_ip, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> new_sp)</span></span><br><span class="hljs-function"></span>&#123;<br>set_user_gs(regs, <span class="hljs-number">0</span>);<br>regs-&gt;fs  = <span class="hljs-number">0</span>;<br>regs-&gt;ds  = __USER_DS;<br>regs-&gt;es  = __USER_DS;<br>regs-&gt;ss  = __USER_DS;<br>regs-&gt;cs  = __USER_CS;<br>regs-&gt;ip  = new_ip;<br>regs-&gt;sp  = new_sp;<br>regs-&gt;flags  = X86_EFLAGS_IF;<br>force_iret();<br>&#125;<br>EXPORT_SYMBOL_GPL(start_thread);<br></code></pre></td></tr></table></figure><p><code>struct pt_regs</code>，看名字里的 <code>register</code>，就是寄存器啊！这个结构就是在系统调用的时候，内核中保存用户态运行上下文的，里面将用户态的代码段 <code>CS</code>设置为 <code>__USER_CS</code>，将用户态的数据段 <code>DS</code> 设置为 <code>__USER_DS</code>，以及<code>指令指针寄存器 IP</code>、<code>栈指针寄存器 SP</code>。这里相当于补上了原来系统调用里，保存寄存器的一个步骤。</p><p>最后的 <code>iret</code> 是干什么的呢？它是用于从系统调用中返回。这个时候会恢复寄存器。从哪里恢复呢？按说是从进入系统调用的时候，保存的寄存器里面拿出。好在上面的函数补上了寄存器。<code>CS</code> 和指令指针寄存器 <code>IP</code> 恢复了，指向用户态下一个要执行的语句。<code>DS</code> 和函数栈指针 <code>SP</code> 也被恢复了，指向用户态函数栈的栈顶。所以，下一条指令，就从用户态开始运行了。</p><p>init 终于从内核到用户态了。一开始到用户态的是 ramdisk 的 init，后来会启动真正根文件系统上的 init，成为所有用户态进程的祖先。</p><p>为什么会有 ramdisk 这个东西呢？还记得上一节咱们内核启动的时候，配置过这个参数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">initrd16</span> /boot/initramfs-<span class="hljs-number">3</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span>-<span class="hljs-number">862</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.img<br></code></pre></td></tr></table></figure><p>就是这个东西，这是一个基于内存的文件系统。为啥会有这个呢？</p><p>是因为刚才那个 init 程序是在文件系统上的，文件系统一定是在一个存储设备上的，例如硬盘。Linux 访问存储设备，要有驱动才能访问。如果存储系统数目很有限，那驱动可以直接放到内核里面，反正前面我们加载过内核到内存里了，现在可以直接对存储系统进行访问。</p><p>但是存储系统越来越多了，如果所有市面上的存储系统的驱动都默认放进内核，内核就太大了。这该怎么办呢？</p><p>我们只好先弄一个基于内存的文件系统。内存访问是不需要驱动的，这个就是 <code>ramdisk</code>。这个时候，<code>ramdisk</code> 是根文件系统。</p><p>然后，我们开始运行 <code>ramdisk</code> 上的 <code>/init</code>。等它运行完了就已经在用户态了。<code>/init</code> 这个程序会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。有了真正的根文件系统，<code>ramdisk</code>上的 <code>/init</code> 会启动文件系统上的 <code>init</code>。</p><p>接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了。</p><p>至此，用户态进程有了一个祖宗，那内核态的进程呢？这就是<code>rest_init</code>接下来要做的是，<strong>创建 2 号线程</strong>。</p><p><code>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)</code>又一次使用 <code>kernel_thread</code> 函数创建进程。这里的函数 <code>kthreadd</code>，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>Linux 提供了<code>glibc</code>这个库封装了系统调用，方便用户使用。那么在打开一个文件时，<code>glibc</code>是如何调用内核的<code>open</code>的呢？</p><p>在 <code>glibc</code> 的源代码中，有个文件<code>syscalls.list</code>，里面列着所有 <code>glibc</code> 的函数对应的系统调用，就像下面这个样子：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># File <span class="hljs-type">name</span> Caller  Syscall <span class="hljs-type">name</span>    Args    Strong <span class="hljs-type">name</span> Weak names<br><span class="hljs-keyword">open</span>    -  <span class="hljs-keyword">open</span>    Ci:siv  __libc_open __open <span class="hljs-keyword">open</span><br></code></pre></td></tr></table></figure><p>另外，<code>glibc</code> 还有一个脚本 <code>make-syscall.sh</code>，可以根据上面的配置文件，对于每一个封装好的系统调用，生成一个文件。这个文件里面定义了一些宏，例如 <code>#define SYSCALL_NAME open</code>。</p><p><code>glibc</code> 还有一个文件 <code>syscall-template.S</code>，使用上面这个宏，定义了这个系统调用的调用方式。</p><p>对于任何一个系统调用，会调用<code>DO_CALL</code>。这也是一个宏，这个宏 32 位和 64 位的定义是不一样的。</p><h4 id="32-位系统调用过程"><a href="#32-位系统调用过程" class="headerlink" title="32 位系统调用过程"></a>32 位系统调用过程</h4><p>i386 目录下的<code>sysdep.h</code> 文件</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs llvm">/* Linux takes system <span class="hljs-keyword">call</span> arguments in registers:<br>  syscall number  <span class="hljs-variable">%eax</span>       <span class="hljs-keyword">call</span>-clobbered<br>  arg <span class="hljs-number">1</span>    <span class="hljs-variable">%ebx</span>       <span class="hljs-keyword">call</span>-saved<br>  arg <span class="hljs-number">2</span>    <span class="hljs-variable">%ecx</span>       <span class="hljs-keyword">call</span>-clobbered<br>  arg <span class="hljs-number">3</span>    <span class="hljs-variable">%edx</span>       <span class="hljs-keyword">call</span>-clobbered<br>  arg <span class="hljs-number">4</span>    <span class="hljs-variable">%esi</span>       <span class="hljs-keyword">call</span>-saved<br>  arg <span class="hljs-number">5</span>    <span class="hljs-variable">%edi</span>       <span class="hljs-keyword">call</span>-saved<br>  arg <span class="hljs-number">6</span>    <span class="hljs-variable">%ebp</span>       <span class="hljs-keyword">call</span>-saved<br>......<br>*/<br>#<span class="hljs-keyword">define</span> DO_CALL(syscall_name<span class="hljs-punctuation">,</span> args)                           <br>    PUSHARGS_##args                             <br>    DOARGS_##args                                <br>    movl $SYS_ify (syscall_name)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%eax</span><span class="hljs-comment">;                          </span><br>    ENTER_KERNEL                                 <br>    POPARGS_##args<br></code></pre></td></tr></table></figure><p>这里，我们将请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器 <code>eax</code> 里面，然后执行 <code>ENTER_KERNEL</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> ENTER_KERNEL int $0x80</span><br></code></pre></td></tr></table></figure><p><code>ENTER_KERNEL</code>就是一个软中断，通过它可以陷入 (trap) 内核。</p><p>在内核启动的时候，还记得有一个 <code>trap_init()</code>，这是一个软中断的陷入门。当接到一个系统调用时，<code>trap_init()</code>就会调用<code>entry_INT80_32</code>。</p><p>通过 <code>push</code> 和 <code>SAVE_ALL</code> 将当前用户态的寄存器，保存在 <code>pt_regs</code> 结构里面，然后调用 <code>do_syscall_32_irqs_on</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210809163844.png"></p><h4 id="64-位系统调用过程"><a href="#64-位系统调用过程" class="headerlink" title="64 位系统调用过程"></a>64 位系统调用过程</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210809170711.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210809171554.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Linux 操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 调试 RISC-V 程序</title>
    <link href="/2021/08/23/VSCode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/08/23/VSCode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>本文主要涉及 VSCode 的相关配置，编译及调试工具需要提前安装好。</p><ul><li>已经安装好<code>riscv-toolchain</code>，包括<code>riscv64-unknown-elf-gcc</code>，<code>riscv64-unknown-elf-gdb</code></li><li>已经安装好<code>qemu</code>，包括<code>riscv32-softmmu,riscv32-linux-user,riscv64-softmmu,riscv64-linux-user</code></li><li>已经安装好<code>g++</code>,<code>gdb</code></li></ul><h2 id="调试流程简介"><a href="#调试流程简介" class="headerlink" title="调试流程简介"></a>调试流程简介</h2><p>对于我这样的新手，要调试一个项目源码最怕的就是开始，也就是怎么能把项目跑起来。</p><p>我们以一个简单的<code>test</code>项目，看看在 VSCode 里怎么跑起来。</p><p>拿到源码后，将其以文件夹形式，加入到 VSCode 中，<code>文件 - 打开文件夹 - 选择 test 项目文件夹</code>。项目就会在 VSCode 中打开，但是此时我们还无法编译运行，我们需要在 VSCode 上<br>构建出一个 C 语言的编译与调试环境。</p><p>首先得安装一个插件<code>C/C++</code>，打开插件中心<code>Ctrl+Shit+X</code>，搜索，安装。</p><p>然后输入<code>F5</code>，会弹出对话框，选择<code>C++(GDB)</code>，继续选择<code>g++</code>。VSCode 会自动创建<code>.vscode</code>文件夹，已经两个文件<code>launch.json</code>和<code>tasks.json</code>。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210823193157.png"></p><p><code>launch.json</code>用来配置调试环境，<code>tasks.json</code>主要用来配置编译环境，当然也可以配置其他任务。<code>task.json</code>里配置的每个任务其实就相当于多开一个控制台。</p><h2 id="配置tasks-json"><a href="#配置tasks-json" class="headerlink" title="配置tasks.json"></a>配置<code>tasks.json</code></h2><p>因为我们先要编译源码，生成<code>.out</code>或者<code>.exe</code>文件，才能调试，所以先进行编译任务配置。</p><p>自动生成的文件是个配置模板，我们可以根据自己的实际情况进行配置，也有一部分可以保持默认。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// tasks.json</span><br>&#123;<br>    <span class="hljs-comment">// https://code.visualstudio.com/docs/editor/tasks</span><br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>        &#123;<br>             <span class="hljs-comment">// 任务的名字，注意是大小写区分的</span><br>             <span class="hljs-comment">//会在launch中调用这个名字</span><br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++: g++ build active file&quot;</span>, <br>             <span class="hljs-comment">// 任务执行的是shell</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>, <br>             <span class="hljs-comment">// 命令是g++</span><br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;g++&quot;</span>, <br>             <span class="hljs-comment">//g++ 后面带的参数</span><br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;&#x27;-Wall&#x27;&quot;</span>,<br>                <span class="hljs-string">&quot;-g&quot;</span>,           <span class="hljs-comment">// 生成调试信息，否则无法进入断点</span><br>                <span class="hljs-string">&quot;&#x27;-std=c++17&#x27;&quot;</span>,     <span class="hljs-comment">//使用c++17标准编译</span><br>                <span class="hljs-string">&quot;&#x27;$&#123;file&#125;&#x27;&quot;</span>,        <span class="hljs-comment">//当前文件名</span><br>                <span class="hljs-string">&quot;-o&quot;</span>,               <span class="hljs-comment">//对象名，不进行编译优化</span><br>                <span class="hljs-string">&quot;&#x27;$&#123;fileBasenameNoExtension&#125;.exe&#x27;&quot;</span>,  <span class="hljs-comment">//当前文件名（去掉扩展名）</span><br>            ],<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>如果项目是通过 Makefile 编译的，那就更加简单，只需要配置一个任务即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>    &#123;<br>       <span class="hljs-comment">//任务的名字方便执行</span><br>      <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Make Project&quot;</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>      <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>,<br>      <span class="hljs-attr">&quot;args&quot;</span>:[<br>          <span class="hljs-comment">//8线程编译</span><br>          <span class="hljs-string">&quot;-j8&quot;</span>,<br>      ],<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>运行该任务时就会执行<code>make</code>命令进行编译。</p><h2 id="配置launch-json"><a href="#配置launch-json" class="headerlink" title="配置launch.json"></a>配置<code>launch.json</code></h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// launch.json</span><br><br>&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-comment">//调试任务的名字</span><br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;g++ - Build and debug active file&quot;</span>, <br>            <span class="hljs-comment">//在launch之前运行的任务名，这个名字一定要跟tasks.json中的任务名字大小写一致</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;C/C++: g++ build active file&quot;</span>,  <br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-comment">//需要运行的是当前打开文件的目录中，</span><br>            <span class="hljs-comment">//名字和当前文件相同，但扩展名为exe的程序</span><br>            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>, <br>            <span class="hljs-attr">&quot;args&quot;</span>: [],<br>            <span class="hljs-comment">// 选为true则会在打开控制台后停滞，暂时不执行程序</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-comment">// 当前工作路径：当前文件所在的工作空间</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;</span>: [],<br>            <span class="hljs-comment">// 是否使用外部控制台</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,  <br>            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;<br>            ]<br>        &#125;]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>经过以上配置后，我们打开<code>main.cpp</code>文件，在<code>cout</code>处打一个断点，按<code>F5</code>，即可编译，运行，调试。一定要打开<code>main.cpp</code>文件，不能随便打开文件就开始哦。因为我们在配置时使用了一些预定义，比如<code>$&#123;file&#125;</code>表示当前文件，所以只有打开需要调试的文件才能开始。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210823201621.png"></p><p>程序将会在<code>cout</code>语句停下来。</p><p>我们可以注意一下界面下方的控制台，可以更直观了解<code>launch.jason</code>和<code>tasks.jason</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210823202012.png"></p><p>右边的框，就是我们在<code>tasks.jason</code>中配置的任务，左边的框就是我们在<code>tasks.jason</code>中<code>command</code>以及<code>args</code>的内容，他就是帮我们提前写好编译的选项。然后在 shell 中运行。</p><h2 id="编译调试-RISC-V-程序"><a href="#编译调试-RISC-V-程序" class="headerlink" title="编译调试 RISC-V 程序"></a>编译调试 RISC-V 程序</h2><p>了解以上这些，就可以按需配置所需的环境了。我们还是从<code>tasks.jason</code>开始。因为开发用的电脑是<code>x86</code>的，所以先要编译出<code>riscv</code>的程序，再用模拟器模拟出<code>rsicv</code>的环境，然后在模拟的环境中运行程序，最后才能开始调试。</p><p>假设已经安装好开头所提到的工具。首先配置<code>tasks.jason</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-comment">// 编译当前代码</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++(RISCV): Build active file&quot;</span>,<br>            <span class="hljs-comment">// 编译器的位置</span><br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;/opt/riscv/bin/riscv64-unknown-elf-g++&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-Wall&quot;</span>, <span class="hljs-comment">// 开启所有警告</span><br>                <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-comment">// 生成调试信息s</span><br>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>,<br>                <span class="hljs-string">&quot;-o&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span> <span class="hljs-comment">// 我选择将可执行文件放在debug目录下</span><br>            ],<br>            <span class="hljs-comment">// 当前工作路径：执行当前命令时所在的路径</span><br>            <span class="hljs-attr">&quot;options&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>            &#125;,<br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span>: [<br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-comment">// 启动qemu供调试器连接</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Run Qemu Server(RISCV)&quot;</span>,<br>            <span class="hljs-attr">&quot;dependsOn&quot;</span>: <span class="hljs-string">&quot;C/C++(RISCV): Build active file&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;qemu-system-riscv64&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-g&quot;</span>,<br>                <span class="hljs-string">&quot;65500&quot;</span>, <span class="hljs-comment">// gdb端口，自己定义</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>            ],<br>        &#125;,<br>        &#123;<br>            <span class="hljs-comment">// 有时候qemu有可能没法退出，故编写一个任务用于强行结束qemu进程</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Kill Qemu Server(RISCV)&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;ps -C qemu-riscv64 --no-headers | cut -d \\  -f 1 | xargs kill -9&quot;</span>,<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tasks.jason</code>是可以配置多个任务的，第一个任务用来编译成<code>riscv</code>架构下的程序，第二个任务用来启动 qemu，让程序在 qemu 上运行起来。</p><p>第一个任务中，<code>command</code>就是配置编译器<code>riscv64-unkonown-elf-gcc</code>的属性，第二个任务中，<code>command</code>是配置 qemu 模拟器<code>qemu-system-riscv32</code>的属性。第三个任务中，用来配置结束 qemu 模拟器的命令。</p><p>接下来配置<code>launch.jason</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;</span>: [<br>        &#123; <br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;C/C++(RISCV) - Debug Active File&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [],<br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;</span>: [],<br>            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;<br>            ],<br>            <span class="hljs-comment">// RISC-V工具链中的gdb</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;/opt/riscv/bin/riscv64-unknown-elf-gdb&quot;</span>, <br>            <span class="hljs-comment">// 这里需要与task.json中定义的端口一致</span><br>            <span class="hljs-attr">&quot;miDebuggerServerAddress&quot;</span>: <span class="hljs-string">&quot;localhost:65500&quot;</span> <br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在配置<code>x86</code>下的调试环境时，<code>launch.jason</code>中有个<code>&quot;preLaunchTask&quot;: &quot;C/C++: g++ build active file&quot;</code>，属性，这个属性的目的是在启动调试之前，先执行任务名字为<code>&quot;C/C++: g++ build active file&quot;</code>任务，也是就编译的任务。</p><p>因为启动 qemu 会导致阻塞，所以这里没有加<code>preLaunchTask</code>，在启动调试之前，先把 qemu 运行起来。输入<code>Ctrl+Shift+P</code>，打开 VSCode 命令行。输入<code>Run Task</code>，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824094556.png"></p><p>点击第一个，选择任务，我们可以看到出现的三个任务就是我们在<code>tasks.jason</code>中配置的三个任务。选择第一个 Build，编译出程序，再重复操作，选择第三个执行 QEMU 任务。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824094609.png"></p><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><p><a href="https://code.visualstudio.com/docs/editor/variables-reference#_predefined-variables">官网</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能 VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GDB</tag>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信（IPC）之信号量（Semaphore）</title>
    <link href="/2021/08/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89/"/>
    <url>/2021/08/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。</p><p>信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即<code>P</code>) 和发送（即<code>V</code>) 信息操作。最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。</p><p>由于信号量只能进行两种操作等待和发送信号，即 P(sv) 和 V(sv),他们的行为是这样的：</p><p><code>P(sv)</code>：如果<code>sv</code>的值大于零，就给它减 1；如果它的值为零，就挂起该进程的执行</p><p><code>V(sv)</code>：如果有其他进程因等待<code>sv</code>而被挂起，就让它恢复运行，如果没有进程因等待<code>sv</code>而挂起，就给它加 1.</p><p>举个例子，就是两个进程共享信号量<code>sv</code>，一旦其中一个进程执行了<code>P(sv)</code>操作，它将得到信号量，并可以进入临界区，使<code>sv</code>减 1。而第二个进程将被阻止进入临界区，因为当它试图执行<code>P(sv)</code>时，<code>sv</code>为 0，它会被挂起以等待第一个进程离开临界区域并执行<code>V(sv)</code>释放信号量，这时第二个进程就可以恢复执行。</p><p>本文<a href="https://github.com/Dunky-Z/learning-linux/blob/main/IPC/Semaphore/main.c">代码同步在这里</a>。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>Linux 提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件 sys/sem.h 中。</p><h3 id="semget"><a href="#semget" class="headerlink" title="semget()"></a><code>semget()</code></h3><p>它的作用是创建一个新信号量或取得一个已有信号量，原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">int</span> num_sems, <span class="hljs-keyword">int</span> sem_flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>key</code>是整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用<code>semget()</code>函数并提供一个键，再由系统生成一个相应的信号标识符（<code>semget()</code>函数的返回值），只有<code>semget()</code>函数才直接使用信号量键，所有其他的信号量函数使用由<code>semget()</code>函数返回的信号量标识符。如果多个程序使用相同的<code>key</code>值，<code>key</code>将负责协调工作。</p></li><li><p><code>num_sems</code>指定需要的信号量数目，它的值几乎总是 1。</p></li><li><p><code>sem_flags</code>是一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值<code>IPC_CREAT</code>做按位或操作。设置了<code>IPC_CREAT</code>标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而<code>IPC_CREAT | IPC_EXCL</code>则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。</p></li></ul><p><code>semget()</code>函数成功返回一个相应信号标识符（非零），失败返回<code>-1</code>.</p><h3 id="semop"><a href="#semop" class="headerlink" title="semop()"></a><code>semop()</code></h3><p>它的作用是改变信号量的值，原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, struct sembuf *sem_opa, <span class="hljs-keyword">size_t</span> num_sem_ops)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>sem_id</code>是由<code>semget()</code>返回的信号量标识符，<code>sembuf</code>结构的定义如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span>&#123;</span><br>    <span class="hljs-keyword">short</span> sem_num; <span class="hljs-comment">// 除非使用一组信号量，否则它为0</span><br>    <span class="hljs-keyword">short</span> sem_op;  <span class="hljs-comment">// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即 P（等待）操作，</span><br>                <span class="hljs-comment">// 一个是+1，即V（发送信号）操作。</span><br>    <span class="hljs-keyword">short</span> sem_flg; <span class="hljs-comment">// 通常为 SEM_UNDO，使操作系统跟踪信号，</span><br>                <span class="hljs-comment">// 并在进程没有释放该信号量而终止时，操作系统释放信号量</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><code>num_sem_ops</code>：操作<code>sops</code>中的操作个数，通常取值为 1</p></li></ul><h3 id="semctl"><a href="#semctl" class="headerlink" title="semctl()"></a><code>semctl()</code></h3><p>该函数用来直接控制信号量信息，它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, <span class="hljs-keyword">int</span> sem_num, <span class="hljs-keyword">int</span> command, ...)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>如果有第四个参数，它通常是一个<code>union semum</code>结构，定义如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">semun</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semid_ds</span> *<span class="hljs-title">buf</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *arry;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>前两个参数与前面一个函数中的一样，<code>command</code>通常是下面两个值中的其中一个</p></li><li><p><code>SETVAL</code>：用来把信号量初始化为一个已知的值。p 这个值通过 union semun 中的 val 成员设置，其作用是在信号量第一次使用前对它进行设置。</p></li><li><p><code>IPC_RMID</code>：用于删除一个已经无需继续使用的信号量标识符。</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信（IPC）之消息队列（MessageQueue）</title>
    <link href="/2021/08/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MessageQueue%EF%BC%89/"/>
    <url>/2021/08/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MessageQueue%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。</p><p>每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p><p>本文<a href="https://github.com/Dunky-Z/learning-linux/tree/main/IPC/MessageQueue">代码同步在这里</a>。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="msgget"><a href="#msgget" class="headerlink" title="msgget()"></a><code>msgget()</code></h3><p>该函数用来创建和访问一个消息队列。它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msgget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span>, key, <span class="hljs-keyword">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>key</code>：与其他的 IPC 机制一样，程序<strong>必须提供一个键</strong>来命名某个特定的消息队列。</li><li><code>msgflg</code>是一个权限标志，表示消息队列的<strong>访问权限</strong>，它与文件的访问权限一样。<code>msgflg</code>可以与<code>IPC_CREAT</code>做或操作，表示当 key 所命名的消息队列不存在时创建一个消息队列，如果 key 所命名的消息队列存在时，<code>IPC_CREAT</code>标志会被忽略，而只返回一个标识符。</li></ul><p>它返回一个以<code>key</code>命名的消息队列的标识符（非零整数），失败时返回<code>-1</code>.</p><h3 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd()"></a><code>msgsnd()</code></h3><p>该函数用来把消息添加到消息队列中。它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msgsend</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *msg_ptr, <span class="hljs-keyword">size_t</span> msg_sz, <span class="hljs-keyword">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>msgid</code>是由<code>msgget</code>函数返回的消息队列标识符。</p></li><li><p><code>msg_ptr</code>是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针<code>msg_ptr</code>所指向的消息结构一定要是以一个<strong>长整型成员变量开始的结构体</strong>，接收函数将用这个成员来确定消息的类型。所以消息结构要定义成这样：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_message</span> &#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> message_type;<br>    <span class="hljs-comment">/* The data you wish to transfer */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><code>msg_sz</code> 是<code>msg_ptr</code>指向的消息的长度</p></li><li><p><code>msgflg</code> 用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情</p></li><li><p>如果调用成功，消息数据的副本将被放到消息队列中，并返回<code>0</code>，失败时返回<code>-1</code>.</p></li></ul><h3 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv()"></a><code>msgrcv()</code></h3><p>该函数用来从一个消息队列获取消息，它的原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msgrcv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid, <span class="hljs-keyword">void</span> *msg_ptr, <span class="hljs-keyword">size_t</span> msg_st, <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> msgtype, <span class="hljs-keyword">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>前三个参数参照前面的解释</li><li><code>msgtype</code> 可以实现一种简单的接收优先级。如果<code>msgtype</code>为<code>0</code>，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。如果它小于零，就获取类型等于或小于<code>msgtype</code>的绝对值的第一个消息。</li><li><code>msgflg</code> 用于控制当队列中没有相应类型的消息可以接收时将发生的事情。</li><li>调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由<code>msg_ptr</code>指向的用户分配的缓存区中，然后删除消息队列中的对应消息。失败时返回<code>-1</code>。</li></ul><h3 id="msgctl"><a href="#msgctl" class="headerlink" title="msgctl()"></a><code>msgctl()</code></h3><p>该函数用来控制消息队列，它与共享内存的shmctl函数相似，它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msgctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid, <span class="hljs-keyword">int</span> command, struct msgid_ds *buf)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>msgid</code>同上</p></li><li><p><code>command</code>是将要采取的动作，它可以取3个值:</p><ul><li><code>IPC_STAT</code>：把<code>msgid_ds</code>结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖<code>msgid_ds</code>的值。</li><li><code>IPC_SET</code>：如果进程有足够的权限，就把消息列队的当前关联值设置为msgid_ds结构中给出的值</li><li><code>IPC_RMID</code>：删除消息队列</li></ul></li><li><p><code>buf</code>是指向<code>msgid_ds</code>结构的指针，它指向消息队列模式和访问权限的结构。<code>msgid_ds</code>结构至少包括以下成员：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgid_ds</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">uid_t</span> shm_perm.uid;<br>    <span class="hljs-keyword">uid_t</span> shm_perm.gid;<br>    <span class="hljs-keyword">mode_t</span> shm_perm.mode;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>成功时返回 0，失败时返回 -1.</p></li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//msgsnd</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TXT 512</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> msg_type;<br>    <span class="hljs-keyword">char</span> msg[MAX_TXT];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> <span class="hljs-title">message</span>;</span><br>    <span class="hljs-keyword">int</span> msgid = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span> buffer[BUFSIZ];<br>    <span class="hljs-keyword">key_t</span> msgKey = ftok(<span class="hljs-string">&quot;./msgsnd.c&quot;</span>, <span class="hljs-number">0</span>);<br>    msgid = msgget(msgKey, <span class="hljs-number">0666</span> | IPC_CREAT);<br><br>    <span class="hljs-keyword">if</span> (msgid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;masget failed error: %d\n&quot;</span>, errno);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter some text: \n&quot;</span>);<br>        fgets(buffer, BUFSIZ, <span class="hljs-built_in">stdin</span>);<br>        message.msg_type = <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意 2</span><br>        <span class="hljs-built_in">strcpy</span>(message.msg, buffer);<br><br>        <span class="hljs-comment">// 向队列里发送数据</span><br>        <span class="hljs-keyword">if</span> (msgsnd(msgid, (<span class="hljs-keyword">void</span> *)&amp;message, MAX_TXT, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgsnd failed\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-comment">// 输入 end 结束输入</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(buffer, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//msgrcv</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TXT 512</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> msg_type;<br>    <span class="hljs-keyword">char</span> msg[MAX_TXT];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> <span class="hljs-title">message</span>;</span><br>    <span class="hljs-keyword">int</span> msgid = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> msgtype = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">key_t</span> msgKey = ftok(<span class="hljs-string">&quot;./msgsnd.c&quot;</span>, <span class="hljs-number">0</span>);<br>    msgid = msgget(msgKey, <span class="hljs-number">0666</span> | IPC_CREAT);<br><br>    <span class="hljs-keyword">if</span> (msgid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;masget failed error: %d\n&quot;</span>, errno);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (msgrcv(msgid, (<span class="hljs-keyword">void</span> *)&amp;message, BUFSIZ, msgtype, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgsnd failed\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You wrote: %s\n&quot;</span>, message.msg);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(message.msg, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210819142858.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210819142913.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(Ubuntu) 环境下安装 VSCode</title>
    <link href="/2021/08/19/Linux-Ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85VSCode/"/>
    <url>/2021/08/19/Linux-Ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85VSCode/</url>
    
    <content type="html"><![CDATA[<p>本来不想写这一篇的，安装 VSCode 时随便搜一下就 OK 了，但是因为 APT 源中没有 VSCode，所以需要找下载网址，几次的安装经历下来，找下载网址也经历了一番折腾。今天又要安装一遍，就顺手记录一下吧。以后翻自己记录总比翻全网记录方便。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>其实最完备安装教程在<a href="https://code.visualstudio.com/docs/setup/linux">官方文档</a>里。本文也算是对官方文档的一个翻译版吧。</p><h2 id="基于-Debian-和-Ubuntu-的发行版"><a href="#基于-Debian-和-Ubuntu-的发行版" class="headerlink" title="基于 Debian 和 Ubuntu 的发行版"></a>基于 Debian 和 Ubuntu 的发行版</h2><p>如果<a href="https://go.microsoft.com/fwlink/?LinkID=760868">下载了.deb 安装包</a>，那么只需要一个命令就可以完成安装了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> ./&lt;<span class="hljs-keyword">file</span>&gt;.deb<br></code></pre></td></tr></table></figure><p>无奈的是，我需要在开发机安装，无法下载安装包，但是我又不想用<code>ftp</code>传来传去，要是<code>apt</code>能完成，绝不单独下载安装包。</p><p>可以使用以下脚本手动安装存储库和密钥</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -qO- https:<span class="hljs-regexp">//</span>packages.microsoft.com<span class="hljs-regexp">/keys/mi</span>crosoft.asc | gpg --dearmor &gt; packages.microsoft.gpg<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo install -o root -g root -m <span class="hljs-number">644</span> packages.microsoft.gpg /etc/apt/<span class="hljs-keyword">trusted</span>.gpg.d/<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sudo sh -c &#x27;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main&quot;</span> &gt; <span class="hljs-string">/etc/apt/sources.list.d/vscode.list</span>&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> packages.microsoft.gpg<br></code></pre></td></tr></table></figure><p>更新与安装</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">sudo apt install apt-transport-https<br>sudo apt update<br>sudo apt install <span class="hljs-keyword">code</span> # or <span class="hljs-keyword">code</span>-insiders<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 操作系统-内存管理</title>
    <link href="/2021/08/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h2><p>计算机所谓的“计算”指的是：</p><ul><li>进程和线程对于 CPU 的使用</li><li>对内存的管理</li></ul><h3 id="独享内存空间的原理"><a href="#独享内存空间的原理" class="headerlink" title="独享内存空间的原理"></a>独享内存空间的原理</h3><p>每个进程都独享一段内存空间，并且真实物理内存地址对进程不可见，操作系统会给进程分配一个虚拟地址，每个进程看到的内存地址都是从 0 开始。操作系统会将不同进程的虚拟地址和不同内存的物理地址做映射。当程序访问虚拟地址时，由内核的数据结构进行转换，转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址。</p><h3 id="规划虚拟地址空间"><a href="#规划虚拟地址空间" class="headerlink" title="规划虚拟地址空间"></a>规划虚拟地址空间</h3><p>通过以上的原理，我们可以看出，操作系统的内存管理，主要分为三个方面。</p><ol><li>物理内存的管理；</li><li>虚拟地址的管理；</li><li>虚拟地址和物理地址如何映射；</li></ol><p>进程获取了一段独立的虚拟内存空间后，可以不用管其他进程，“任意”使用这片内存，但是也有一点规则。这篇内存需要存放内核态和用户态的内容。高地址存放内核态的内容，低地址存放用户态的内容。具体分界线 64 位与 32 位不同，暂不深究。</p><p>我们从最低位开始排起，先是<strong>Text Segment、Data Segment 和 BSS Segment</strong>。Text Segment 是存放二进制可执行代码的位置，Data Segment 存放静态常量，BSS Segment 存放未初始化的静态变量。是不是觉得这几个名字很熟悉？没错，咱们前面讲 ELF 格式的时候提到过，在二进制执行文件里面，就有这三个部分。这里就是把二进制执行文件的三个部分加载到内存里面。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129170110.png"></p><p>接下来是<strong>堆</strong>（Heap）<strong>段</strong>。堆是往高地址增长的，是用来动态分配内存的区域，<code>malloc</code> 就是在这里面分配的。<br>接下来的区域是<strong>Memory Mapping Segment</strong>。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将 so 文件映射到了内存中。<br>再下面就是<strong>栈</strong>（Stack）<strong>地址段</strong>。主线程的函数调用的函数栈就是用这里的。</p><p>普通进程不能访问内核空间，如果需要进行更高权限的工作，就需要系统调用进入内核。每一段进程的内存空间存放的内容各不相同，但是进入内核后看到的都是同一个内核空间，同一个进程列表。</p><p>内核的代码访问内核的数据结构，大部分的情况下都是使用虚拟地址的，虽然内核代码权限很大，但是能够使用的虚拟地址范围也只能在内核空间，也即内核代码访问内核数据结构。</p><p>接下来，我们需要知道，如何将其映射成为物理地址呢？</p><p>咱们前面讲 x86 CPU 的时候，讲过分段机制，咱们规划虚拟空间的时候，也是将空间分成多个段进行保存。我们来看看分段机制的原理。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129182908.png"></p><p>分段机制下的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。段选择子就保存在咱们前面讲过的段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。段表里面保存的是这个段的<strong>基地址</strong>、<strong>段的界限</strong>和<strong>特权等级</strong>等。虚拟地址中的段内偏移量应该位于 0 和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</p><p>例如，我们将上面的虚拟空间分成以下 4 个段，用 0～3 来编号。每个段在段表中有一个项，在物理空间中，段的排列如下图的右边所示。如果要访问段 2 中偏移量 600 的虚拟地址，我们可以计算出物理地址为，段 2 基地址 2000 + 偏移量 600 = 2600。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129183334.png"></p><p>在 Linux 里面，段表全称<strong>段描述符表</strong>（segment descriptors），放在<strong>全局描述符表 GDT</strong>（Global Descriptor Table）里面，会有下面的宏来初始化段描述符表里面的表项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GDT_ENTRY_INIT(flags, base, limit) &#123; &#123; &#123; \</span><br><span class="hljs-meta">    .a = ((limit) &amp; 0xffff) | (((base) &amp; 0xffff) &lt;&lt; 16), \</span><br><span class="hljs-meta">    .b = (((base) &amp; 0xff0000) &gt;&gt; 16) | (((flags) &amp; 0xf0ff) &lt;&lt; 8) | \</span><br><span class="hljs-meta">      ((limit) &amp; 0xf0000) | ((base) &amp; 0xff000000), \</span><br><span class="hljs-meta">  &#125; &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>一个段表项由段基地址 base、段界限 limit，还有一些标识符组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = &#123; .gdt = &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_X86_64</span><br>  [GDT_ENTRY_KERNEL32_CS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc09b</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_KERNEL_CS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xa09b</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_KERNEL_DS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc093</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER32_CS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0fb</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_DS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0f3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_CS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xa0fb</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  [GDT_ENTRY_KERNEL_CS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc09a</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_KERNEL_DS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc092</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_CS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0fa</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_DS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0f2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125; &#125;;<br>EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);<br></code></pre></td></tr></table></figure><p>这里面对于 64 位的和 32 位的，都定义了内核代码段、内核数据段、用户代码段和用户数据段。另外，还会定义下面四个段选择子，指向上面的段描述符表项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __KERNEL_CS      (GDT_ENTRY_KERNEL_CS*8)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __KERNEL_DS      (GDT_ENTRY_KERNEL_DS*8)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __USER_DS      (GDT_ENTRY_DEFAULT_USER_DS*8 + 3)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __USER_CS      (GDT_ENTRY_DEFAULT_USER_CS*8 + 3)</span><br></code></pre></td></tr></table></figure><p>通过分析，我们发现，所有的段的起始地址都是一样的，都是 0。所以，在 Linux 操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。<br>其实 Linux 倾向于另外一种从虚拟地址到物理地址的转换方式，称为<strong>分页</strong>（Paging）。对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以<strong>暂时写到硬盘上</strong>，称为<strong>换出</strong>。一旦需要的时候，再<strong>加载进来</strong>，叫作<strong>换入</strong>。这样可以扩大可用物理内存的大小，提高物理内存的利用率。</p><p>这个换入和换出都是以页为单位的。页面的大小一般为 4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129185728.png"></p><p>虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。</p><p>32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了。</p><p>页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。</p><p>那怎么办呢？我们可以试着将页表再分页，4G 的空间需要 4M 的页表来存储映射。我们把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K。</p><p>页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置。</p><p>这样加起来正好 32 位，也就是用前 10 位定位到页目录表中的一项。将这一项对应的页表取出来共 1k 项，再用中间 10 位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后 12 位定位到页中的具体位置访问数据。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129192245.png"></p><p>你可能会问，如果这样的话，映射 4GB 地址空间就需要 4MB+4KB 的内存，这样不是更大了吗？当然如果页是满的，当时是更大了，但是，我们往往不会为一个进程分配那么多内存。</p><p>比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省多了。</p><p>当然对于 64 位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。</p><h2 id="进程空间管理"><a href="#进程空间管理" class="headerlink" title="进程空间管理"></a>进程空间管理</h2><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><h2 id="用户态内存映射"><a href="#用户态内存映射" class="headerlink" title="用户态内存映射"></a>用户态内存映射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GDT_ENTRY_INIT(flags, base, limit) &#123; &#123; &#123; \</span><br><span class="hljs-meta">  .a = ((limit) &amp; 0xffff) | (((base) &amp; 0xffff) &lt;&lt; 16), \</span><br><span class="hljs-meta">  .b = (((base) &amp; 0xff0000) &gt;&gt; 16) | (((flags) &amp; 0xf0ff) &lt;&lt; 8) | \</span><br><span class="hljs-meta">    ((limit) &amp; 0xf0000) | ((base) &amp; 0xff000000), \</span><br><span class="hljs-meta">  &#125; &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>通过分析，我们发现，所有的段的起始地址都是一样的，都是 0。这算哪门子分段嘛！所以，在 Linux 操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。</p><p>其实 Linux 倾向于另外一种从虚拟地址到物理地址的转换方式，称为分页（Paging）。</p><p>对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为换出。一旦需要的时候，再加载进来，叫作换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Linux 操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 模仿登录界面-交互响应</title>
    <link href="/2021/08/18/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E4%BA%A4%E4%BA%92%E5%93%8D%E5%BA%94/"/>
    <url>/2021/08/18/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E4%BA%A4%E4%BA%92%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820152215.gif"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820152316.gif"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820153546.gif"></p><h2 id="设置窗口拖动"><a href="#设置窗口拖动" class="headerlink" title="设置窗口拖动"></a>设置窗口拖动</h2><p>因为这个项目中没有将登录界面直接继承<code>MainWindow</code>，而是继承的<code>Dialog</code>类，所以它是不能直接移动的，需要我们自己添加相应的方法。这里实现了三种方法，点击，拖动，释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//mytitlebar.cpp</span><br><span class="hljs-comment">// 以下通过 mousePressEvent、mouseMoveEvent、mouseReleaseEvent 三个事件实现了鼠标拖动标题栏移动窗口的效果;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (m_buttonType == MIN_MAX_BUTTON)<br> &#123;<br>  <span class="hljs-comment">// 在窗口最大化时禁止拖动窗口;</span><br>  <span class="hljs-keyword">if</span> (m_pButtonMax-&gt;<span class="hljs-built_in">isVisible</span>())<br>  &#123;<br>   m_isPressed = <span class="hljs-literal">true</span>;<br>   m_startMovePos = event-&gt;<span class="hljs-built_in">globalPos</span>();<br>  &#125;<br> &#125;<br> <span class="hljs-keyword">else</span><br> &#123;<br>  m_isPressed = <span class="hljs-literal">true</span>;<br>  m_startMovePos = event-&gt;<span class="hljs-built_in">globalPos</span>();<br> &#125;<br> <br> <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">mousePressEvent</span>(event);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::mouseMoveEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (m_isPressed &amp;&amp; m_isMoveParentWindow)<br> &#123;<br>  QPoint movePoint = event-&gt;<span class="hljs-built_in">globalPos</span>() - m_startMovePos;<br>  QPoint widgetPos = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">parentWidget</span>()-&gt;<span class="hljs-built_in">pos</span>() + movePoint;<br>  m_startMovePos = event-&gt;<span class="hljs-built_in">globalPos</span>();<br>  <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">parentWidget</span>()-&gt;<span class="hljs-built_in">move</span>(widgetPos.<span class="hljs-built_in">x</span>(), widgetPos.<span class="hljs-built_in">y</span>());<br> &#125;<br> <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">mouseMoveEvent</span>(event);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::mouseReleaseEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br> m_isPressed = <span class="hljs-literal">false</span>;<br> <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">mouseReleaseEvent</span>(event);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="globalPos-获取全局的坐标"><a href="#globalPos-获取全局的坐标" class="headerlink" title="globalPos()获取全局的坐标"></a><code>globalPos()</code>获取全局的坐标</h3><p><code>event-&gt;globalPos()</code>是获取全局的坐标，全局是相对于整个屏幕而言的。还有一个函数<code>pos()</code>获取的是局部坐标，相对于一个<code>widget</code>窗口而言。</p><h3 id="move-移动窗口"><a href="#move-移动窗口" class="headerlink" title="move()移动窗口"></a><code>move()</code>移动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QPoint &amp;)</span></span>;<br></code></pre></td></tr></table></figure><p>其中<code>move</code>的原点是父窗口的左上角，如果没有父窗口，则桌面即为父窗口。x 往右递增，y 往下递增</p><p><code>mouseMoveEvent()</code>这个函数里有一点需要注意的是，<code>m_startMovePos = event-&gt;globalPos()</code>这条语句。每次移动窗口之前，先把鼠标移动后的位置记录下来，作为下一次移动的起点。</p><h2 id="设置最小化，关闭"><a href="#设置最小化，关闭" class="headerlink" title="设置最小化，关闭"></a>设置最小化，关闭</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//mytitlebar.cpp</span><br><span class="hljs-comment">// 信号槽的绑定;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::initConnections</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">connect</span>(m_pButtonMin, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonMinClicked</span>()));<br> <span class="hljs-built_in">connect</span>(m_pButtonClose, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonCloseClicked</span>()));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::onButtonMinClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-function">emit <span class="hljs-title">signalButtonMinClicked</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::onButtonCloseClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-function">emit <span class="hljs-title">signalButtonCloseClicked</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>标题栏是在<code>basewindow</code>中 new 出来的，<code>mytitlebar</code>类只负责发送信号，真正处理信号的是在<code>basewindow</code>类中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//basewindow.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BaseWindow::initTitleBar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">createMyTitle</span>(<span class="hljs-keyword">this</span>);<br> m_titleBar-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br> <br> <span class="hljs-built_in">connect</span>(m_titleBar, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalButtonMinClicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonMinClicked</span>()));<br> <span class="hljs-built_in">connect</span>(m_titleBar, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalButtonCloseClicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonCloseClicked</span>()));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BaseWindow::onButtonMinClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (Qt::Tool == (<span class="hljs-built_in">windowFlags</span>() &amp; Qt::Tool))<br> &#123;<br>  <span class="hljs-built_in">hide</span>();<br> &#125;<br> <span class="hljs-keyword">else</span><br> &#123;<br>  <span class="hljs-built_in">showMinimized</span>();<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BaseWindow::onButtonCloseClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在初始化标题栏时，就把点击信号与相关的槽函数绑定。当有最小化点击信号发生时，就会调用最小化操作。</p><h3 id="和窗口相关的几个函数"><a href="#和窗口相关的几个函数" class="headerlink" title="和窗口相关的几个函数"></a>和窗口相关的几个函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">showMinimized</span>()     <span class="hljs-comment">//最小化</span><br><span class="hljs-built_in">showNormal</span>()        <span class="hljs-comment">//从最小化或者最大化窗口恢复到正常窗口</span><br><span class="hljs-built_in">showMaximized</span>()     <span class="hljs-comment">//最大化</span><br><span class="hljs-built_in">show</span>()              <span class="hljs-comment">//显示窗口，可以显示模态窗口也可以显示非模态</span><br><span class="hljs-built_in">hide</span>()              <span class="hljs-comment">//隐藏窗口</span><br><span class="hljs-built_in">isVisible</span>()         <span class="hljs-comment">//判断是否可见</span><br><span class="hljs-built_in">isMinimized</span>()       <span class="hljs-comment">//判断是否处于最小化状态</span><br><span class="hljs-built_in">close</span>()             <span class="hljs-comment">//关闭窗口</span><br></code></pre></td></tr></table></figure><h2 id="切换用户及删除用户"><a href="#切换用户及删除用户" class="headerlink" title="切换用户及删除用户"></a>切换用户及删除用户</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//loginwindow.cpp</span><br><span class="hljs-comment">// 初始化用户登录信息;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initAccountList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 设置代理;</span><br>    m_Accountlist = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QListWidget</span>(<span class="hljs-keyword">this</span>);<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setModel</span>(m_Accountlist-&gt;<span class="hljs-built_in">model</span>());<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setView</span>(m_Accountlist);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        AccountItem *account_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AccountItem</span>();<br>        account_item-&gt;<span class="hljs-built_in">setAccountInfo</span>(i, <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;Dominic%1号&quot;</span>).<span class="hljs-built_in">arg</span>(i), <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/headImage/head_%1.png&quot;</span>).<span class="hljs-built_in">arg</span>(i));<br>        <span class="hljs-built_in">connect</span>(account_item, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalShowAccountInfo</span>(<span class="hljs-keyword">int</span>, QString)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onShowAccountInfo</span>(<span class="hljs-keyword">int</span>, QString)));<br>        <span class="hljs-built_in">connect</span>(account_item, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalRemoveAccount</span>(<span class="hljs-keyword">int</span>)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onRemoveAccount</span>(<span class="hljs-keyword">int</span>)));<br>        QListWidgetItem *list_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QListWidgetItem</span>(m_Accountlist);<br>        m_Accountlist-&gt;<span class="hljs-built_in">setItemWidget</span>(list_item, account_item);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//将选项文本显示在 QComboBox 当中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onShowAccountInfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, QString accountName)</span></span><br><span class="hljs-function"></span>&#123;<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setEditText</span>(accountName);<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">hidePopup</span>();<br><br>    <span class="hljs-comment">// 更换用户头像;</span><br>    QString fileName = <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/headImage/head_%1.png&quot;</span>).<span class="hljs-built_in">arg</span>(index);<br>    ui-&gt;userHead-&gt;<span class="hljs-built_in">setPixmap</span>(<span class="hljs-built_in">QPixmap</span>(fileName).<span class="hljs-built_in">scaled</span>(ui-&gt;userHead-&gt;<span class="hljs-built_in">width</span>(), ui-&gt;userHead-&gt;<span class="hljs-built_in">height</span>()));<br>&#125;<br><br><span class="hljs-comment">// 移除当前登录列表中某一项;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onRemoveAccount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; m_Accountlist-&gt;<span class="hljs-built_in">count</span>(); row++)<br>    &#123;<br>        AccountItem* itemWidget = (AccountItem*)m_Accountlist-&gt;<span class="hljs-built_in">itemWidget</span>(m_Accountlist-&gt;<span class="hljs-built_in">item</span>(row));<br>        <span class="hljs-keyword">if</span> (itemWidget != <span class="hljs-literal">NULL</span> &amp;&amp; itemWidget-&gt;<span class="hljs-built_in">getItemWidgetIndex</span>() == index)<br>        &#123;<br>            m_Accountlist-&gt;<span class="hljs-built_in">takeItem</span>(row);<br>            itemWidget-&gt;<span class="hljs-built_in">deleteLater</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>initAccountList()</code>中，初始化好了三个账户信息，当接收到显示用户信息的信号<code>signalShowAccountInfo</code>后，就会调用<code>onShowAccountInfo</code>槽函数显示用户信息。在这个函数中，将下拉框的内容设置成切换后的用户名，然后隐藏下拉框<code>hidPopup</code>。更改头像。</p><p>当接收到删除信号时，调用<code>onRemoveAccount</code>槽函数，删除指定的用户信息。</p><h3 id="hidPopup-隐藏下拉框"><a href="#hidPopup-隐藏下拉框" class="headerlink" title="hidPopup()隐藏下拉框"></a><code>hidPopup()</code>隐藏下拉框</h3><p>文章开头的效果图是隐藏下拉框的效果，每次切换用户下拉框隐藏，我们再来看一下不隐藏什么效果就容易理解了。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820105158.gif"></p><h3 id="takeItem-删除部件"><a href="#takeItem-删除部件" class="headerlink" title="takeItem()删除部件"></a><code>takeItem()</code>删除部件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QListWidgetItem *<span class="hljs-title">QListWidget::takeItem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row)</span></span><br></code></pre></td></tr></table></figure><p>从下拉菜单中选择一行部件删除。</p><h3 id="deleteLater-稍后删除对象"><a href="#deleteLater-稍后删除对象" class="headerlink" title="deleteLater()稍后删除对象"></a><code>deleteLater()</code>稍后删除对象</h3><p><code>deletelater</code>的原理是 <code>QObject::deleteLater()</code>并没有将对象立即销毁，而是向主消息循环发送了一个<code>event</code>，下一次主消息循环收到这个<code>event</code>之后才会销毁对象。</p><h2 id="切换登录状态"><a href="#切换登录状态" class="headerlink" title="切换登录状态"></a>切换登录状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//loginwindow.cpp</span><br><span class="hljs-comment">// 选择了新的用户登录状态;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onLoginStateClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_loginStateMemu = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QMenu</span>();<br>    QAction *pActionOnline = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_online.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;我在线上&quot;</span>));<br>    QAction *pActionActive = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_Qme.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;Q 我吧&quot;</span>));<br>    m_loginStateMemu-&gt;<span class="hljs-built_in">addSeparator</span>();<br>    QAction *pActionAway = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_away.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;离开&quot;</span>));<br>    QAction *pActionBusy = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_busy.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;忙碌&quot;</span>));<br>    QAction *pActionNoDisturb = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_notdisturb.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;请勿打扰&quot;</span>));<br>    m_loginStateMemu-&gt;<span class="hljs-built_in">addSeparator</span>();<br>    QAction *pActionHide = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_hide.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;隐身&quot;</span>));<br>    <span class="hljs-comment">// 设置状态值;</span><br>    pActionOnline-&gt;<span class="hljs-built_in">setData</span>(ONLINE);<br>    pActionActive-&gt;<span class="hljs-built_in">setData</span>(ACTIVE);<br>    pActionAway-&gt;<span class="hljs-built_in">setData</span>(AWAY);<br>    pActionBusy-&gt;<span class="hljs-built_in">setData</span>(BUSY);<br>    pActionNoDisturb-&gt;<span class="hljs-built_in">setData</span>(NOT_DISTURB);<br>    pActionHide-&gt;<span class="hljs-built_in">setData</span>(HIDE);<br><br><br>    <span class="hljs-built_in">connect</span>(m_loginStateMemu, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">triggered</span>(QAction *)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onMenuClicked</span>(QAction*)));<br><br>    QPoint pos = ui-&gt;loginState-&gt;<span class="hljs-built_in">mapToGlobal</span>(<span class="hljs-built_in">QPoint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) + <span class="hljs-built_in">QPoint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br>    m_loginStateMemu-&gt;<span class="hljs-built_in">exec</span>(pos);<br>&#125;<br><br><span class="hljs-comment">// 用户状态菜单点击;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onMenuClicked</span><span class="hljs-params">(QAction * action)</span></span><br><span class="hljs-function"></span>&#123;<br>    ui-&gt;loginState-&gt;<span class="hljs-built_in">setIcon</span>(action-&gt;<span class="hljs-built_in">icon</span>());<br>    <span class="hljs-comment">// 获取状态值;</span><br>    m_loginState = (LoginState)action-&gt;<span class="hljs-built_in">data</span>().<span class="hljs-built_in">toInt</span>();<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;onMenuClicked&quot;</span> &lt;&lt; m_loginState;<br>&#125;<br></code></pre></td></tr></table></figure><p>在接收到点击状态按钮信号时，调用<code>onLoginStateClicked</code>槽函数，改变用户登录状态。切换的下拉菜单用的是<code>QMenu</code>。</p><h3 id="addSeparator-添加分割线"><a href="#addSeparator-添加分割线" class="headerlink" title="addSeparator()添加分割线"></a><code>addSeparator()</code>添加分割线</h3><p>Q 我吧和离开状态之间的分割线。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820113856.png"></p><h3 id="mapToGlobal-映射成全局坐标"><a href="#mapToGlobal-映射成全局坐标" class="headerlink" title="mapToGlobal()映射成全局坐标"></a><code>mapToGlobal()</code>映射成全局坐标</h3><p>弹出登录状态菜单<code>m_loginStateMemu</code>是我们自己 new 出来的，默认显示是从左上角开始显示，这样当然不行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820140445.png"></p><p> <code>mapToGlobal()</code>的作用就是将控件的坐标映射成全局坐标。代码里的意思就是将<code>loginState</code>控件里面的坐标用全局坐标表示。然后再向下偏移<code>20</code>个单位。再把得到的全局坐标作为<code>m_loginStateMemu</code>显示起始坐标。</p><p>下图是未偏移的结果，<br> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820141408.png"></p><p>向下偏移<code>20</code>个单位的效果，因为我们<code>mapToGlobal(QPoint(0, 0))</code>的参数是<code>(0,0)</code>为起点。如果我们<code>mapToGlobal(QPoint(0, 20))</code>的参数是<code>(0,20)</code>，就不用再加上偏移了。<br> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820141521.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 模仿登录界面-窗口布局及样式</title>
    <link href="/2021/08/17/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80%E5%8F%8A%E6%A0%B7%E5%BC%8F/"/>
    <url>/2021/08/17/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80%E5%8F%8A%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="框架类图"><a href="#框架类图" class="headerlink" title="框架类图"></a>框架类图</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827120419.png"></p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210818130510.gif"><br>完整项目及资源文件请在<a href="https://github.com/Dunky-Z/learning-qt/tree/main/Demo/login">Github</a>查看。</p><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820101857.png"></p><h2 id="初始化标题栏"><a href="#初始化标题栏" class="headerlink" title="初始化标题栏"></a>初始化标题栏</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化标题栏;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initMyTitle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 因为这里有控件层叠了，所以要注意控件 raise() 方法的调用顺序;</span><br>    m_titleBar-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    m_titleBar-&gt;<span class="hljs-built_in">raise</span>();<br>    m_titleBar-&gt;<span class="hljs-built_in">setBackgroundColor</span>(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    m_titleBar-&gt;<span class="hljs-built_in">setButtonType</span>(MIN_BUTTON);<br>    m_titleBar-&gt;<span class="hljs-built_in">setTitleWidth</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>());<br>    <span class="hljs-comment">// 这里需要设置成 false，不允许通过标题栏拖动来移动窗口位置，否则会造成窗口位置错误;</span><br>    m_titleBar-&gt;<span class="hljs-built_in">setMoveParentWindowFlag</span>(<span class="hljs-literal">false</span>);<br>    ui-&gt;pButtonArrow-&gt;<span class="hljs-built_in">raise</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="raise-将控件置于顶层"><a href="#raise-将控件置于顶层" class="headerlink" title="raise()将控件置于顶层"></a><code>raise()</code>将控件置于顶层</h3><p>程序在打开后一般都在所有窗体的顶层，打开其他程序后之前的程序就会被放到下一层，在这里，当设置完<code>my_titleBar</code>后对其他控件操作就会把<code>my_titleBar</code>控件覆盖。所有要用<code>raise()</code>方法将其置于顶层。</p><h2 id="初始化窗口"><a href="#初始化窗口" class="headerlink" title="初始化窗口"></a>初始化窗口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化窗口;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initWindow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//背景 GIG 图;</span><br>    QLabel* pBack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QLabel</span>(<span class="hljs-keyword">this</span>);<br>    QMovie *movie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QMovie</span>();<br>    movie-&gt;<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/back.gif&quot;</span>);<br>    pBack-&gt;<span class="hljs-built_in">setMovie</span>(movie);<br>    movie-&gt;<span class="hljs-built_in">start</span>();<br>    pBack-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//文本框内提示</span><br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setEditable</span>(<span class="hljs-literal">true</span>);<br>    QLineEdit* lineEdit = ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">lineEdit</span>();<br>    lineEdit-&gt;<span class="hljs-built_in">setPlaceholderText</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;QQ 号码/手机/邮箱&quot;</span>));<br>    <span class="hljs-function">QRegExp <span class="hljs-title">regExp</span><span class="hljs-params">(<span class="hljs-string">&quot;[A-Za-z0-9_]&#123;6,30&#125;&quot;</span>)</span></span>; <span class="hljs-comment">//正则表达式限制用户名输入不能输入汉字</span><br>    lineEdit-&gt;<span class="hljs-built_in">setValidator</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QRegExpValidator</span>(regExp,<span class="hljs-keyword">this</span>));<br>    ui-&gt;passwordEdit-&gt;<span class="hljs-built_in">setPlaceholderText</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;密码&quot;</span>));<br><br>    <span class="hljs-comment">//密码框中的小键盘按钮;</span><br>    m_keyboardButton = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>();<br>    m_keyboardButton-&gt;<span class="hljs-built_in">setObjectName</span>(<span class="hljs-string">&quot;pButtonKeyboard&quot;</span>);<br>    m_keyboardButton-&gt;<span class="hljs-built_in">setFixedSize</span>(<span class="hljs-built_in">QSize</span>(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>));<br>    m_keyboardButton-&gt;<span class="hljs-built_in">setCursor</span>(<span class="hljs-built_in">QCursor</span>(Qt::PointingHandCursor));<span class="hljs-comment">//鼠标放上去变成手形</span><br><br>    QHBoxLayout* passwordEditLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>    passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>();<br>    passwordEditLayout-&gt;<span class="hljs-built_in">addWidget</span>(m_keyboardButton);<br>    passwordEditLayout-&gt;<span class="hljs-built_in">setSpacing</span>(<span class="hljs-number">0</span>);<br>    passwordEditLayout-&gt;<span class="hljs-built_in">setContentsMargins</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br><br>    ui-&gt;passwordEdit-&gt;<span class="hljs-built_in">setLayout</span>(passwordEditLayout);<br>    <span class="hljs-comment">//设置密码达到最长时最后一个字符离小键盘图标的距离（12）</span><br>    ui-&gt;passwordEdit-&gt;<span class="hljs-built_in">setTextMargins</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m_keyboardButton-&gt;<span class="hljs-built_in">width</span>() + <span class="hljs-number">12</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//设置头像以及状态图标</span><br>    ui-&gt;userHead-&gt;<span class="hljs-built_in">setPixmap</span>(<span class="hljs-built_in">QPixmap</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/HeadImage.png&quot;</span>));<br>    ui-&gt;loginState-&gt;<span class="hljs-built_in">setIcon</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_online.png&quot;</span>));<br>    ui-&gt;loginState-&gt;<span class="hljs-built_in">setIconSize</span>(<span class="hljs-built_in">QSize</span>(<span class="hljs-number">13</span>, <span class="hljs-number">13</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>lineEdit-&gt;setPlaceholderText<br>QStringLiteral:如果该 QString 不会修改的话，那使用 QStringLiteral</p><h3 id="setPlaceholderText-设置文本提示"><a href="#setPlaceholderText-设置文本提示" class="headerlink" title="setPlaceholderText()设置文本提示"></a><code>setPlaceholderText()</code>设置文本提示</h3><p>该方法可以设置文本框中的默认文字提示，如图片中的 QQ 号码/手机/邮箱。</p><h3 id="setCursor-设置鼠标形态"><a href="#setCursor-设置鼠标形态" class="headerlink" title="setCursor()设置鼠标形态"></a><code>setCursor()</code>设置鼠标形态</h3><p>共有以下 19 种鼠标形态：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820150422.png"></p><p>图片来自<a href="https://blog.csdn.net/taiyang1987912/article/details/35281407">这里</a></p><h3 id="addStretch-布局加入弹簧"><a href="#addStretch-布局加入弹簧" class="headerlink" title="addStretch()布局加入弹簧"></a><code>addStretch()</code>布局加入弹簧</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QHBoxLayout* passwordEditLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>();<br>passwordEditLayout-&gt;<span class="hljs-built_in">addWidget</span>(m_keyboardButton);<br></code></pre></td></tr></table></figure><p><code>addStretch()</code>用来在布局中平分布局，他就是个弹簧的作用。如果不加参数，就是等于加个弹簧，会把小键盘图标挤到边上。如图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817143033.png"></p><p>如果将代码改一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QHBoxLayout* passwordEditLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>(<span class="hljs-number">1</span>);<br>passwordEditLayout-&gt;<span class="hljs-built_in">addWidget</span>(m_keyboardButton);<br>passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>意思就是将除了小键盘图标以外的空间分成两份，那么刚好小键盘图标就是在中间位置，就像两遍各防止了一个弹簧。效果如下：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817143135.png"></p><p><code>setSpacing()</code>设置空间之间上下距离，还有一个容易混淆的设置<code>setMargin()</code>表示设置空间与窗口边缘的左右距离。</p><p><code>setContentsMargins</code>设置左侧、顶部、右侧和底部边距，以便在布局周围使用。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817144359.png"></p><p>现在我们设置的是<code>setContentsMargins(0, 0, 8, 0)</code>，现在我们设置大一点看看效果。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817144532.png"></p><p><code>QLineEdit.setTextMargins(left=,top=,right=,bottom=)</code>设置文本边距，这里主要为了设置密码输入过长时，最后一个字符距离小键盘图标有一定间隙。</p><h2 id="初始化用户登录信息"><a href="#初始化用户登录信息" class="headerlink" title="初始化用户登录信息"></a>初始化用户登录信息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//accountitem.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initAccountList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br> &#123;<br>  AccountItem *account_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AccountItem</span>();<br>  account_item-&gt;<span class="hljs-built_in">setAccountInfo</span>(i, <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;Dominic_%1号&quot;</span>).<span class="hljs-built_in">arg</span>(i), <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/headImage/head_%1.png&quot;</span>).<span class="hljs-built_in">arg</span>(i));<br>  QListWidgetItem *list_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QListWidgetItem</span>(m_Accountlist);<br>  m_Accountlist-&gt;<span class="hljs-built_in">setItemWidget</span>(list_item, account_item);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 操作系统-进程间通信</title>
    <link href="/2021/08/14/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/08/14/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong>。</p><h2 id="进程间通信概述"><a href="#进程间通信概述" class="headerlink" title="进程间通信概述"></a>进程间通信概述</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>在学 Linux 命令时就有管道在这个概念，比如下面这个命令</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">ps -ef  | <span class="hljs-type">-grep</span> root | <span class="hljs-type">xargs</span> kill <span class="hljs-number">-9</span><br></code></pre></td></tr></table></figure><p>将上一个命令的输出作为下一个命令的输入，数据只能向一个方向流动；双方需要互相通信时，需要建立起两个管道。</p><p>管道有两种类型：匿名管道和命名管道。上面提到的命令中<code>|</code>表示的管道即<strong>匿名管道 pipe</strong>。用完即销毁，自动创建，自动销毁。</p><p>使用<code>mkfifo</code>显示创建的是<strong>命名管道 fifo</strong>，</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mkfifo hello</span><br></code></pre></td></tr></table></figure><p><code>hello</code>即是管道名称，类型为<code>p</code>，就是<code>pipe</code>，接下来就可以在管道里写入东西，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span> &gt; hello</span><br></code></pre></td></tr></table></figure><p>光写入还不行，只有有另一个进程读取了内容才完成一次信息交换，才完成一次通信，</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># cat &lt; hello </span><br><span class="hljs-attribute">hello</span> world<br></code></pre></td></tr></table></figure><p>这种方式通信效率低，无法频繁通信。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>类似于日常沟通使用的邮件，有一定格式，有个收件列表，列表上的用户都可以反复在原邮件基础上回复，达到频繁交流的目的。这种模型就是<strong>消息队列模型</strong>。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。</p><p>每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存空间映射到不同的物理内存中去。这个进程访问 A 地址和另一个进程访问 A 地址，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p>但是，咱们是不是可以变通一下，<strong>拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。</p><p>使用<code>shmget</code>函数创建一个共享内存，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//key_t key:  唯一定位一个共享内存对象</span><br><span class="hljs-comment">//size_t size: 共享内存大小</span><br><span class="hljs-comment">//int flag: 如果是 IPC_CREAT 表示创建新的共享内存空间</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> flag)</span></span>;<br></code></pre></td></tr></table></figure><p>创建完毕之后，我们可以通过 <code>ipcs</code> 命令查看这个共享内存。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#ipcs ­­--shmems</span><br> <br>------ <span class="hljs-keyword">Shared </span>Memory Segments ------ ­­­­­­­­<br>key        <span class="hljs-keyword">shmid </span>   owner perms    <span class="hljs-keyword">bytes </span>nattch status<br><span class="hljs-number">0x00000000</span> <span class="hljs-number">19398656</span> marc  <span class="hljs-number">600</span>    <span class="hljs-number">1048576</span> <span class="hljs-number">2</span>      dest<br></code></pre></td></tr></table></figure><p>进程通过<code>shmat</code>，就是<code>attach</code>的意思，将内存加载到自己虚拟地址空间某个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//int shm_id:</span><br><span class="hljs-comment">//const void *addr: 加载的地址，通常设为 NULL，让内核选一个合适地址</span><br><span class="hljs-comment">//int flag:</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">shmat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">int</span> flag)</span></span>;<br></code></pre></td></tr></table></figure><p>如果共享内存使用完毕，可以通过 <code>shmdt</code> 解除绑定，然后通过 <code>shmctl</code>，将 <code>cmd</code> 设置为 <code>IPC_RMID</code>，从而删除这个共享内存对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmdt</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;<br></code></pre></td></tr></table></figure><p>共享内存的最大不足之处在于，由于多个进程对同一块内存区具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>如果两个进程同时向一个共享内存读写数据，很可能就会导致冲突。所以需要有一种保护机制，使得同一个共享资源同时只能被一个进程访问。在进程间通信机制中，<strong>信号量</strong>（Semaphore）就是用来实现进程间互斥与同步的。它其实是个<strong>计数器</strong>，只不过不是用来记录进程间通信数据的。</p><p>我们可以将信号量初始化为一个数值，来代表某种资源的总体数量。对于信号量来讲，会定义两种原子操作，一个是<code>P</code> 操作，我们称为<strong>申请资源操作</strong>。这个操作会申请将信号量的数值<strong>减去</strong> N，表示这些数量被他申请使用了，其他人不能用了。另一个是<code>V</code>操作，我们称为<strong>归还资源操作</strong>，这个操作会申请将信号量<strong>加上</strong> M，表示这些数量已经还给信号量了，其他人可以使用了。</p><p>所谓<strong>原子操作</strong>（Atom Operation）就是不可被中断的一个或一系列操作。</p><p>使用<code>semget</code><strong>创建</strong>信号量，第一个参数表示唯一标识，第二个参数表示可以创建多少个信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">int</span> num_sems, <span class="hljs-keyword">int</span> sem_flags)</span></span>;<br></code></pre></td></tr></table></figure><p>接下来，我们需要<strong>初始化</strong>信号量的总的资源数量。通过<code>semctl</code> 函数，第一个参数 <code>semid</code>是这个信号量组的<code>id</code>，第二个参数 <code>semnum</code> 才是在这个信号量组中某个信号量的<code>id</code>，第三个参数是命令，如果是初始化，则用 <code>SETVAL</code>，第四个参数是一个 <code>union</code>。如果初始化，应该用里面的<code>val</code>设置资源总量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> semid, <span class="hljs-keyword">int</span> semnum, <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">union</span> semun args)</span></span>;<br> <br> <br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">semun</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">int</span> val;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semid_ds</span> *<span class="hljs-title">buf</span>;</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seminfo</span> *__<span class="hljs-title">buf</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>无论是 P 操作还是 V 操作，我们统一用 semop 函数。第一个参数还是信号量组的 id，一次可以操作多个信号量。第三个参数 numops 就是有多少个操作，第二个参数将这些操作放在一个数组中。</p><p>数组的每一项是一个 <code>struct sembuf</code>，里面的第一个成员是这个操作的对象是哪个信号量。第二个成员就是要对这个信号量做多少改变。如果 <code>sem_op &lt; 0</code>，就请求 <code>sem_op</code> 的绝对值的资源。如果相应的资源数可以满足请求，则将该信号量的值减去 <code>sem_op</code> 的绝对值，函数成功返回。</p><p>当相应的资源数不能满足请求时，就要看<code>sem_flg</code> 了。如果把 <code>sem_flg</code> 设置为<code>IPC_NOWAIT</code>，也就是没有资源也不等待，则 <code>semop</code> 函数出错返回 <code>EAGAIN</code>。如果 <code>sem_flg</code> 没有指定<code>IPC_NOWAIT</code>，则进程挂起，直到当相应的资源数可以满足请求。若 <code>sem_op &gt; 0</code>，表示进程归还相应的资源数，将 <code>sem_op</code> 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则唤醒它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> semid, struct sembuf semoparray[], <span class="hljs-keyword">size_t</span>  numops)</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> </span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">short</span> sem_num; <span class="hljs-comment">// 信号量组中对应的序号，0～sem_nums-1</span><br>  <span class="hljs-keyword">short</span> sem_op;  <span class="hljs-comment">// 信号量值在一次操作中的改变量</span><br>  <span class="hljs-keyword">short</span> sem_flg; <span class="hljs-comment">// IPC_NOWAIT, SEM_UNDO</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>以上提到的通信方式，都是常规状态下的工作模式，而信号一般是由<strong>错误</strong>产生的。</p><p>信号没有特别复杂的数据结构，就是用一个代号一样的数字。Linux 提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Linux 操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-rename 批量重命名</title>
    <link href="/2021/08/13/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-rename%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/"/>
    <url>/2021/08/13/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-rename%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">rename</span> [<span class="hljs-meta">options</span>] <span class="hljs-string">&quot;s/oldname/newname/&quot;</span> <span class="hljs-meta">file</span><br></code></pre></td></tr></table></figure><p>格式就很容易看出来怎么用的，就是<code>/</code>不能丢。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-v 将重命名的内容都打印到标准输出，v 可以看成 verbose</span><br><span class="hljs-deletion">-n 测试会重命名的内容，将结果都打印，但是并不真正执行重命名的过程</span><br><span class="hljs-deletion">-f force 会覆盖本地已经存在的文件</span><br><span class="hljs-deletion">-h -m -V 分别为帮助，帮助，版本</span><br><span class="hljs-deletion">-e 比较复杂，可以通过该选项，写一些脚本来做一些复杂的事情</span><br></code></pre></td></tr></table></figure><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="替换文件名中的特定字段"><a href="#替换文件名中的特定字段" class="headerlink" title="替换文件名中的特定字段"></a>替换文件名中的特定字段</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/AA/aa/&quot;</span> *  <span class="hljs-comment"># 把文件名中的AA替换成aa</span><br></code></pre></td></tr></table></figure><h3 id="修改文件后缀"><a href="#修改文件后缀" class="headerlink" title="修改文件后缀"></a>修改文件后缀</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/.html/.php/&quot;</span> *     <span class="hljs-comment"># 把.html 后缀的改成 .php后缀</span><br><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/.png/.jpg/&quot;</span> *      <span class="hljs-comment"># 将 png 改为 jpg</span><br></code></pre></td></tr></table></figure><h3 id="添加后缀"><a href="#添加后缀" class="headerlink" title="添加后缀"></a>添加后缀</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/$/.txt/&quot;</span> *     <span class="hljs-comment"># 把所有的文件名都以txt结尾</span><br></code></pre></td></tr></table></figure><p><code>$</code>正则表达式中表示结尾。</p><h3 id="保留部分文件名"><a href="#保留部分文件名" class="headerlink" title="保留部分文件名"></a>保留部分文件名</h3><p>假如需要在批量修改的时候保留部分文件名，可以使用引用<code>\1</code> ，比如有下面格式的文件，只想保留日期部分。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Screenshot</span> from <span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span> <span class="hljs-number">15</span>-<span class="hljs-number">56</span>-<span class="hljs-number">49</span>.jpg<br><span class="hljs-attribute">rename</span> -n <span class="hljs-string">&quot;s/Screenshot from ([0-9\\- ]+).jpg/\1.jpg/&quot;</span> *<br></code></pre></td></tr></table></figure><p>将<code>()</code> 匹配的内容取出来放到替换部分。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-apt 安装卸载软件</title>
    <link href="/2021/08/12/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-apt%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/"/>
    <url>/2021/08/12/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-apt%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>这个命令应该是我们平时用的最多的命令之一了，应该早就拿出来讲一下的。但是平时用的太多，总感觉自己都会用了，但是仔细看了所有命令，还是有一些比较实用但是没记住的命令。</p><p><code>apt</code>的全称是<code>Advanced Packaging Tool</code>是 Linux 系统下的一款安装包管理工具。APT 可以自动下载、配置和安装二进制或源代码格式软件包，简化了 Unix 系统上管理软件的过程。</p><p>APT 主要由以下几个命令组成：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">apt-<span class="hljs-keyword">get</span><br>apt-cache<br>apt-<span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><h3 id="搜索软件包"><a href="#搜索软件包" class="headerlink" title="搜索软件包"></a>搜索软件包</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">apt <span class="hljs-built_in">search</span> <span class="hljs-keyword">python3</span><br></code></pre></td></tr></table></figure><h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">apt</span> install python<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> update<br></code></pre></td></tr></table></figure><h3 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h3><p>执行完 update 命令后，就可以使用 apt upgrade 来升级软件包了。执行命令后系统会提示有几个软件需要升级。在得到你的同意后，系统即开始自动下载安装软件包。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> upgrade<br></code></pre></td></tr></table></figure><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">remove</span> python3  <span class="hljs-comment"># 移除软件包，但是保留配置文件</span><br>apt purge python3 <span class="hljs-comment">#移除软件包并移除配置</span><br>apt autoremove <span class="hljs-comment"># 移除孤立的并不被依赖的软件包</span><br></code></pre></td></tr></table></figure><h3 id="列出软件清单"><a href="#列出软件清单" class="headerlink" title="列出软件清单"></a>列出软件清单</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">apt list</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 添加资源文件（QtCreator）</title>
    <link href="/2021/08/12/Qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%88QtCreator%EF%BC%89/"/>
    <url>/2021/08/12/Qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%88QtCreator%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>QtCreator➜新建文件或项目➜Qt➜Qt Resource File</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812102544.png"></p><p>点击<code>Choose</code>，设置资源文件名和路径。资源文件是一系列文件的集合，比如我要建立一个图片的资源文件，我可以设置<code>img</code>为资源文件名，将来所有图片类资源，都放到这个资源文件里，加入还有音频类的文件，我可以新建一个<code>audio</code>的资源文件，以后所有音频类的文件都放到这个资源文件下。</p><p>而不是我想要添加的文件名。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812103024.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812103101.png"></p><p>右侧编辑器下方有个<code>Add Prefix</code>(添加前缀)，我们首先要添加文件前缀，前缀就是存放文件的文件夹名，然后添加需要的文件。添加完以后看效果就知道啥意思了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812104121.png"></p><p>这么做带来的一个问题是，如果以后我们要更改文件名，比如将 <code>xbl.png</code> 改成 <code>xiabanle.png</code>，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：</p><p>这样，我们可以直接使用<code>:/images/avatar</code>用到这个资源，无需关心图片的真实文件名。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-kill 这个进程</title>
    <link href="/2021/08/11/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-kill%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B/"/>
    <url>/2021/08/11/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-kill%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>对于在前台运行的程序，我们可以用<code>Ctrl+C</code>来终止运行，但是在后台的程序就必须用<code>kill</code>命令来终止了。</p><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class="hljs-deletion">-a  当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="hljs-deletion">-p  指定 kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="hljs-deletion">-s  指定发送信号</span><br><span class="hljs-deletion">-u  指定用户</span><br></code></pre></td></tr></table></figure><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="查看所有信号"><a href="#查看所有信号" class="headerlink" title="查看所有信号"></a>查看所有信号</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos">➜   <span class="hljs-keyword">kill</span> -<span class="hljs-keyword">l</span><br>HUP INT <span class="hljs-keyword">QUIT</span> ILL TRAP ABRT BUS FPE <span class="hljs-keyword">KILL</span> USR1 <br>SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP <br>TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS<br></code></pre></td></tr></table></figure><p>常用信号</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HUP</span>    <span class="hljs-number">1</span>    终端断线<br><span class="hljs-attribute">INT</span>     <span class="hljs-number">2</span>    中断（同 Ctrl + C）<br><span class="hljs-attribute">QUIT</span>    <span class="hljs-number">3</span>    退出（同 Ctrl + \）<br><span class="hljs-attribute">TERM</span>   <span class="hljs-number">15</span>    终止<br><span class="hljs-attribute">KILL</span>    <span class="hljs-number">9</span>    强制终止<br><span class="hljs-attribute">CONT</span>   <span class="hljs-number">18</span>    继续（与 STOP 相反， fg/bg 命令）<br><span class="hljs-attribute">STOP</span>    <span class="hljs-number">19</span>    暂停（同 Ctrl + Z）<br></code></pre></td></tr></table></figure><h3 id="用-ps-查找进程，然后用-kill-杀掉"><a href="#用-ps-查找进程，然后用-kill-杀掉" class="headerlink" title="用 ps 查找进程，然后用 kill 杀掉"></a>用 ps 查找进程，然后用 kill 杀掉</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">ps -ef | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;program&#x27;</span><br><span class="hljs-keyword">kill</span> PID<br></code></pre></td></tr></table></figure><h3 id="无条件彻底杀死进程"><a href="#无条件彻底杀死进程" class="headerlink" title="无条件彻底杀死进程"></a>无条件彻底杀死进程</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> –<span class="hljs-number">9</span> PID<br></code></pre></td></tr></table></figure><h3 id="杀死指定用户所有进程"><a href="#杀死指定用户所有进程" class="headerlink" title="杀死指定用户所有进程"></a>杀死指定用户所有进程</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">kill -<span class="hljs-number">9</span> <span class="hljs-constructor">$(<span class="hljs-params">ps</span> -<span class="hljs-params">ef</span> | <span class="hljs-params">grep</span> <span class="hljs-params">username</span>)</span><br>kill -u username<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信（IPC）之信号（Signal）</title>
    <link href="/2021/08/11/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E4%BF%A1%E5%8F%B7%EF%BC%88Signal%EF%BC%89/"/>
    <url>/2021/08/11/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E4%BF%A1%E5%8F%B7%EF%BC%88Signal%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>关于进程间通信的概述可以查看<a href="https://dunky-z.github.io/2021/08/10/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">Linux 操作系统 - 进程间通信</a>，<a href="https://github.com/Dunky-Z/learning-linux/tree/main/IPC/SharedMemory">代码同步在这里</a>。</p><p>本文通过实例介绍通过共享内存实现进程间通信。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>信号就像实际生产过程中的应急预案，发生了某个异常就会启动特定的应急预案，为了响应各类异常情况，所以就定义了很多个信号，信号的名称是在头文件<code>signal.h</code>中定义的，信号都以<code>SIG</code>开头，常用的信号并不多，常用的信号如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SIGALRM</span>     <span class="hljs-comment">#时钟定时信号, 计算的是实际的时间或时钟时间</span><br>SIGHUP      <span class="hljs-comment">#终端的挂断或进程死亡</span><br>SIGINT      <span class="hljs-comment">#来自键盘的中断信号</span><br>SIGKILL     <span class="hljs-comment">#用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。</span><br>SIGPIPE     <span class="hljs-comment">#管道破裂</span><br>SIGTERM     <span class="hljs-comment">#程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理</span><br>SIGUSR1,SIGUSR2     <span class="hljs-comment">#留给用户使用</span><br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nOps! - I got signal %d\n&quot;</span>, sig);<br><br>    <span class="hljs-comment">// 恢复终端中断信号 SIGINT 的默认行为</span><br>    (<span class="hljs-keyword">void</span>)signal(SIGINT, SIG_DFL);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 改变终端中断信号 SIGINT 的默认行为，使之执行 ouch 函数</span><br>    <span class="hljs-comment">// 而不是终止程序的执行</span><br>    (<span class="hljs-keyword">void</span>)signal(SIGINT, signalHandler);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以用<code>signal()</code>函数处理指定的信号，主要通过忽略和恢复其默认行为来工作。signal() 函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> (*signal(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">int</span>)))(<span class="hljs-keyword">int</span>);<br></code></pre></td></tr></table></figure><p>这是一个相当复杂的声明，耐心点看可以知道 signal 是一个带有<code>sig</code>和<code>func</code>两个参数的函数，<code>func</code>是一个类型为<code>void (*)(int)</code>的函数指针。该函数返回一个与<code>func</code>相同类型的指针，指向先前指定信号处理函数的函数指针。准备捕获的信号的参数由<code>sig</code>给出，接收到的指定信号后要调用的函数由参数<code>func</code>给出。其实这个函数的使用是相当简单的，通过下面的例子就可以知道。注意信号处理函数的原型必须为<code>void func（int）</code>，或者是下面的特殊值：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">SIG_IGN : 忽略信号<br>SIG_DFL : 恢复信号的默认行为<br></code></pre></td></tr></table></figure><p>我们程序的目的是想要捕获键盘输入<code>Ctrl+C</code>，这个中断。通过表里可以查到，我们使用<code>SIGINT</code>这个信号，当我们的程序出现<code>SIGINT</code>信号时，让程序接下来干啥呢？正常情况下，我们的<code>Ctrl+C</code>会中断当前运行的程序，但是现在我们做了一些更改，更改的内容在我们自己编写的<code>signalHandler</code>中。我们让程序输出一行字符串加上信号值。然后再把信号的行为恢复原样。此时我们运行程序可以得到如下</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210811143147.png"></p><p>在我们第一输入<code>Ctrl+C</code>时，程序没有中断，而是调用了<code>signalHanlder</code>函数，因为我们更改了信号的行为。但是第二次输入<code>Ctrl+C</code>时，程序中断了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信（IPC）之共享内存 (SharedMemory)</title>
    <link href="/2021/08/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88SharedMemory%EF%BC%89/"/>
    <url>/2021/08/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88SharedMemory%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>关于进程间通信的概述可以查看<a href="https://dunky-z.github.io/2021/08/10/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">Linux 操作系统 - 进程间通信</a>，<a href="https://github.com/Dunky-Z/learning-linux/tree/main/IPC/SharedMemory">代码同步在这里</a>。</p><p>本文通过实例介绍通过共享内存实现进程间通信。</p><h2 id="shmget-得到一个共享内存标识符或创建一个共享内存对象"><a href="#shmget-得到一个共享内存标识符或创建一个共享内存对象" class="headerlink" title="shmget(得到一个共享内存标识符或创建一个共享内存对象)"></a>shmget(得到一个共享内存标识符或创建一个共享内存对象)</h2><p>我们可以通过<code>shmget</code>函数创建或打开共享内存，通过函数签名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//key_t key:  唯一定位一个共享内存对象</span><br><span class="hljs-comment">//size_t size: 共享内存大小</span><br><span class="hljs-comment">//int flag: 如果是 IPC_CREAT 表示创建新的共享内存空间</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> flag)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>第一个参数是共享内存的唯一标识，是需要我们指定的。那么如何指定<code>key</code>呢？如何保证唯一性呢？我们可以指定一个文件，<code>ftok</code>会根据这个文件的 <code>inode</code>，生成一个近乎唯一的 <code>key</code>。只要在这个消息队列的生命周期内，这个文件不要被删除就可以了。只要不删除，无论什么时刻，再调用 <code>ftok</code>，也会得到同样的<code>key</code>。</li><li>第二个参数是申请的空间大小，我们就申请 1024B。</li><li>第三个参数是权限标识，<code>IPC_CREAT</code>表示创建共享内存，<code>0644</code>表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。</li></ul><h2 id="shmat-把共享内存区对象映射到调用进程的地址空间"><a href="#shmat-把共享内存区对象映射到调用进程的地址空间" class="headerlink" title="shmat(把共享内存区对象映射到调用进程的地址空间)"></a>shmat(把共享内存区对象映射到调用进程的地址空间)</h2><p>第一次创建完共享内存时，它还不能被任何进程访问，<code>shmat()</code>函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。它的签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">shmat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *shm_addr, <span class="hljs-keyword">int</span> shmflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>第一个参数就是上文产生的唯一标识。</li><li>第二个参数，<code>shm_addr</code>指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</li><li>第三个参数，<code>shm_flg</code>是一组标志位，通常为 0。<br>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</li></ul><p><code>(void *) - 1</code>把<code>-1</code>转换为指针<code>0xFFFFFFFF</code>，有时也会用到<code>(void*)0</code>，表示一个空指针。</p><h2 id="shmdt-断开共享内存连接"><a href="#shmdt-断开共享内存连接" class="headerlink" title="shmdt(断开共享内存连接)"></a>shmdt(断开共享内存连接)</h2><p>与 shmat 函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存</p><p>函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmdt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *shmaddr)</span></span><br></code></pre></td></tr></table></figure><ul><li>参数一<code>shmaddr</code>为连接共享内存的起始地址。</li></ul><p>需要注意的是，本函数调用并不删除所指定的共享内存区，而只是将先前用 shmat 函数连接（attach）好的共享内存脱离（detach）目前的进程。删除共享内存就需要下面的这个函数。</p><h2 id="shmctl-共享内存管理"><a href="#shmctl-共享内存管理" class="headerlink" title="shmctl(共享内存管理)"></a>shmctl(共享内存管理)</h2><p>完成对共享内存的控制，包括改变状态，删除共享内存等。</p><p>函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shmid, <span class="hljs-keyword">int</span> cmd, struct shmid_ds *buf)</span></span><br></code></pre></td></tr></table></figure><ul><li><code>shmid</code>共享内存唯一标识符</li><li><code>cmd</code>执行的操作，包括如下<ul><li><code>IPC_STAT</code>：得到共享内存的状态，把共享内存的<code>shmid_ds</code>结构复制到<code>buf</code>中</li><li><code>IPC_SET</code>：改变共享内存的状态，把<code>buf</code>所指的<code>shmid_ds</code>结构中的<code>uid</code>、<code>gid</code>、<code>mode</code>复制到共享内存的<code>shmid_ds</code>结构内</li><li><code>IPC_RMID</code>：删除这片共享内存</li></ul></li><li><code>buf</code>共享内存管理结构体。具体说明参见共享内存内核结构定义部分</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//server.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> shmid;<br>    <span class="hljs-keyword">key_t</span> shmkey;<br>    <span class="hljs-keyword">char</span> *shmptr;<br>    shmkey = ftok(<span class="hljs-string">&quot;./client.c&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 创建或打开内存共享区域</span><br>    shmid = shmget(shmkey, <span class="hljs-number">1024</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (shmid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmget error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将共享内存映射到当前进程的地址中，</span><br>    <span class="hljs-comment">//之后直接对进程中的地址 addr 操作就是对共享内存操作</span><br>    shmptr = (<span class="hljs-keyword">char</span> *)shmat(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (shmptr == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmat error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 把用户的输入存到共享内存区域中</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, shmptr);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//client.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> shmid;<br>    <span class="hljs-keyword">char</span> *shmptr;<br>    <span class="hljs-keyword">key_t</span> shmkey;<br>    shmkey = ftok(<span class="hljs-string">&quot;./client.c&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 创建或打开内存共享区域</span><br>    shmid = shmget(shmkey, <span class="hljs-number">1024</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (shmid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmget error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将共享内存映射到当前进程的地址中，</span><br>    <span class="hljs-comment">//之后直接对进程中的地址 addr 操作就是对共享内存操作</span><br>    shmptr = (<span class="hljs-keyword">char</span> *)shmat(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (shmptr == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;shmat error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 每隔 3 秒从共享内存中取一次数据并打印到控制台</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string:%s\n&quot;</span>, shmptr);<br>        sleep(<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在两个终端分别运行<code>client</code>和<code>server</code>，<code>client</code>会每三秒在终端打印出<code>server</code>输入的内容。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810205816.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810205830.png"></p><h3 id="如何手动删除共享内存？"><a href="#如何手动删除共享内存？" class="headerlink" title="如何手动删除共享内存？"></a>如何手动删除共享内存？</h3><p>列出所有的共享内存段：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dns">ipcs -m<br>------------ 共享内存段 --------------<br>键        shmid      拥有者  权限     字节     连接数  状态      <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">2</span>          dominic    <span class="hljs-number">600</span>        <span class="hljs-number">16384</span>      <span class="hljs-number">1</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">753668</span>     dominic    <span class="hljs-number">606</span>        <span class="hljs-number">10089696</span>   <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">622597</span>     dominic    <span class="hljs-number">600</span>        <span class="hljs-number">4194304</span>    <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">753670</span>     dominic    <span class="hljs-number">606</span>        <span class="hljs-number">10089696</span>   <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">688135</span>     dominic    <span class="hljs-number">600</span>        <span class="hljs-number">899976</span>     <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">8</span>          dominic    <span class="hljs-number">600</span>        <span class="hljs-number">524288</span>     <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">9</span>          dominic    <span class="hljs-number">600</span>        <span class="hljs-number">524288</span>     <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">753674</span>     dominic    <span class="hljs-number">600</span>        <span class="hljs-number">7127040</span>    <span class="hljs-number">2</span>          目标 <br><span class="hljs-number">0</span>x0000006f <span class="hljs-number">720918</span>     dominic    <span class="hljs-number">666</span>        <span class="hljs-number">1024</span>        <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们发现最后一个键值为<code>0x0000006f = 111</code>的共享内存段，就是我们创建的共享内存段。<br>删除指定共享内存段：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ipcrm</span> -m <span class="hljs-number">720918</span>  <br>或者 <br>ipcrm -M 0x0000006f  <br></code></pre></td></tr></table></figure><p>信号量和消息队列的操作，命令类似，只是参数不同。<br>查看命令：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">ipcs [-m|<span class="hljs-type">-q</span>|<span class="hljs-type">-s</span>]<br></code></pre></td></tr></table></figure><ul><li><code>-m</code> 输出有关共享内存 (shared memory) 的信息</li><li><code>-q</code> 输出有关信息队列 (message queue) 的信息</li><li><code>-s</code> 输出有关“信号量”(semaphore) 的信息</li></ul><p>删除命令</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">ipcrm [ -M<span class="hljs-built_in"> key</span> | -m<span class="hljs-built_in"> id</span> | -Q<span class="hljs-built_in"> key</span> | -q<span class="hljs-built_in"> id</span> | -S<span class="hljs-built_in"> key</span> | -s<span class="hljs-built_in"> id</span> ]<br></code></pre></td></tr></table></figure><ul><li><code>-M</code>用 shmkey 删除共享内存</li><li><code>-m</code>用 shmid 删除共享内存</li><li><code>-Q</code>用 msgkey 删除消息队列</li><li><code>-q</code>用 msgid 删除消息队列</li><li><code>-S</code>用 semkey 删除信号量</li><li><code>-s</code>用 semid 删除信号量</li></ul><h2 id="超过共享内存的大小限制"><a href="#超过共享内存的大小限制" class="headerlink" title="超过共享内存的大小限制"></a>超过共享内存的大小限制</h2><p>共享内存的总体大小是有限制的，这个大小通过 SHMMAX 参数来定义（以字节为单位），您可以通过执行以下命令来确定 SHMMAX 的值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmmax<br></code></pre></td></tr></table></figure><p>如果机器上创建的共享内存的总共大小超出了这个限制，在程序中使用标准错误<code>perror</code>可能会出现以下的信息：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">unable <span class="hljs-keyword">to</span> attach <span class="hljs-keyword">to</span> <span class="hljs-keyword">shared</span> memory<br></code></pre></td></tr></table></figure><p>1、设置 SHMMAX</p><p>　　SHMMAX 的默认值是 <code>32MB</code> 。一般使用下列方法之一种将 SHMMAX 参数设为 <code>2GB</code> ：<br>通过直接更改 <code>/proc</code> 文件系统，你不需重新启动机器就可以改变 SHMMAX 的默认设置。我使用的方法是将以下命令放入 <code>/&gt;etc/rc.local</code> 启动文件中：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-string">&quot;2147483648&quot;</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmmax<br></code></pre></td></tr></table></figure><p>  您还可以使用 <code>sysctl</code> 命令来更改 SHMMAX 的值：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sysctl -w kernel.<span class="hljs-attribute">shmmax</span>=2147483648<br></code></pre></td></tr></table></figure><p>最后，通过将该内核参数插入到<code>/etc/sysctl.conf</code> 启动文件中，您可以使这种更改永久有效：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;kernel.shmmax=2147483648&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>sysctl.conf<br></code></pre></td></tr></table></figure><p>  2、设置 SHMMNI</p><p>  我们现在来看 SHMMNI 参数。这个内核参数用于设置系统范围内共享内存段的最大数量。该参数的默认值是 <code>4096</code> 。这一数值已经足够，通常不需要更改。您可以通过执行以下命令来确定 SHMMNI 的值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmmni<br></code></pre></td></tr></table></figure><p>  3、设置 SHMALL</p><p>  最后，我们来看 SHMALL 共享内存内核参数。该参数控制着系统一次可以使用的共享内存总量（以页为单位）。简言之，该参数的值始终应该至少为：<code>ceil(SHMMAX/PAGE_SIZE)</code></p><p>SHMALL 的默认大小为 <code>2097152</code> ，可以使用以下命令进行查询：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmall<br></code></pre></td></tr></table></figure><p>　　SHMALL 的默认设置对于我们来说应该足够使用。注意：在 i386 平台上 Red Hat Linux 的 页面大小 为 <code>4096</code> 字节。但是，您可以使用 <code>bigpages</code> ，它支持配置更大的内存页面尺寸。</p><h2 id="多次进行-shmat-操作会出现什么问题"><a href="#多次进行-shmat-操作会出现什么问题" class="headerlink" title="多次进行 shmat 操作会出现什么问题"></a>多次进行 shmat 操作会出现什么问题</h2><p>一个进程是可以对同一个共享内存多次 shmat 进行挂载的，物理内存是指向同一块，如果 shmaddr 为 NULL，则每次返回的线性地址空间都不同。而且指向这块共享内存的引用计数会增加。也就是进程多块线性空间会指向同一块物理地址。这样，如果之前挂载过这块共享内存的进程的线性地址没有被<code>shmdt</code>掉，即申请的线性地址都没有释放，就会一直消耗进程的虚拟内存空间，很有可能会最后导致进程线性空间被使用完而导致下次 shmat 或者其他操作失败。</p><h2 id="shmget-创建共享内存，当-key-相同时，什么情况下会出错？"><a href="#shmget-创建共享内存，当-key-相同时，什么情况下会出错？" class="headerlink" title="shmget 创建共享内存，当 key 相同时，什么情况下会出错？"></a>shmget 创建共享内存，当 key 相同时，什么情况下会出错？</h2><p>当创建一个新的共享内存区时，size 的值必须大于 0；如果是访问一个已经存在的内存共享区，则置 size 为 0。</p><p>已经创建的共享内存的大小是可以调整的，但是已经创建的共享内存的大小只能调小，不能调大</p><p>当多个进程都能创建共享内存的时候，如果 key 出现相同的情况，并且一个进程需要创建的共享内存的大小要比另外一个进程要创建的共享内存小，共享内存大的进程先创建共享内存，共享内存小的进程后创建共享内存，小共享内存的进程就会获取到大的共享内存进程的共享内存，并修改其共享内存的大小和内容，从而可能导致大的共享内存进程崩溃。</p><h2 id="ftok-是否一定会产生唯一的-key-值？"><a href="#ftok-是否一定会产生唯一的-key-值？" class="headerlink" title="ftok 是否一定会产生唯一的 key 值？"></a>ftok 是否一定会产生唯一的 key 值？</h2><p>ftok 原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">key_t</span> <span class="hljs-title">ftok</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * pathname, <span class="hljs-keyword">int</span> proj_id)</span></span><br></code></pre></td></tr></table></figure><p><code>pathname</code>就时你指定的文件名，<code>proj_id</code>是子序号。在一般的 UNIX 实现中，是将文件的索引节点号取出，前面加上子序号得到<code>key_t</code>的返回值。如指定文件的索引节点号为 65538，换算成 16 进制为<code>0×010002</code>，而你指定的<code>proj_id</code>值为<code>38</code>，换算成 16 进制为<code>0×26</code>，则最后的<code>key_t</code>返回值为<code>0×26010002</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-ar 多文件归档为一个文件</title>
    <link href="/2021/08/10/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ar%E5%A4%9A%E6%96%87%E4%BB%B6%E5%BD%92%E6%A1%A3%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/"/>
    <url>/2021/08/10/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ar%E5%A4%9A%E6%96%87%E4%BB%B6%E5%BD%92%E6%A1%A3%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>现在我们有<code>solution.c</code>,<code>solution.h</code>两个文件，他们实现了某一个功能，自成一个模块。在其他项目中也可复用。我们就可以把它做成库文件。<code>ar</code>命令就可以将锁哥文件整合成一个库文件，也可以从一个库中单独提取出某一个文件。</p><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-d 　删除备存文件中的成员文件。</span><br><span class="hljs-deletion">-m 　变更成员文件在备存文件中的次序。</span><br><span class="hljs-deletion">-p 　显示备存文件中的成员文件内容。</span><br><span class="hljs-deletion">-q 　将文件附加在备存文件末端。</span><br><span class="hljs-deletion">-r 　将文件插入备存文件中。</span><br><span class="hljs-deletion">-t 　显示备存文件中所包含的文件。</span><br><span class="hljs-deletion">-x 　自备存文件中取出成员文件。</span><br></code></pre></td></tr></table></figure><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="打包文件"><a href="#打包文件" class="headerlink" title="打包文件"></a>打包文件</h3><p>将<code>solution.c solution.h</code>两个文件打包成<code>solution.bak</code>，并显示详细信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  ar rv solution<span class="hljs-selector-class">.bak</span> solution<span class="hljs-selector-class">.c</span> solution<span class="hljs-selector-class">.h</span><br>ar: 正在创建 solution<span class="hljs-selector-class">.bak</span><br><span class="hljs-selector-tag">a</span> - solution<span class="hljs-selector-class">.c</span><br><span class="hljs-selector-tag">a</span> - solution.h<br></code></pre></td></tr></table></figure><h3 id="显示打包文件内容"><a href="#显示打包文件内容" class="headerlink" title="显示打包文件内容"></a>显示打包文件内容</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  ar t solution<span class="hljs-selector-class">.bak</span> <br>solution<span class="hljs-selector-class">.c</span><br>solution.h<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日学命令-ps 显示进程状态</title>
    <link href="/2021/08/09/%E6%AF%8F%E6%97%A5%E5%AD%A6%E5%91%BD%E4%BB%A4-ps%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <url>/2021/08/09/%E6%AF%8F%E6%97%A5%E5%AD%A6%E5%91%BD%E4%BB%A4-ps%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p><code>ps</code>命令显示的信息类似于 Windows 的任务管理器。也是参数超级多的一个命令，所以就不列参数了，需要查看时直接搜索，这里列举一下实例。</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>显示当前执行的所有程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ ps -a<br>    PID TTY          TIME CMD<br>    879 tty2     00:03:43 Xorg<br>    990 tty2     00:00:00 gnome-session-b<br>   2653 pts/0    00:00:00 zsh<br>  12365 pts/0    00:00:00 ps<br><br></code></pre></td></tr></table></figure><p>显示所有程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ ps -A<br>    PID TTY          TIME CMD<br>      1 ?        00:00:01 systemd<br>      2 ?        00:00:00 kthreadd<br>      3 ?        00:00:00 rcu_gp<br>      4 ?        00:00:00 rcu_par_gp<br>      6 ?        00:00:00 kworker/0:0H-kblockd<br>      9 ?        00:00:00 mm_percpu_wq<br>     10 ?        00:00:00 ksoftirqd/0<br>     11 ?        00:00:02 rcu_sched<br>     12 ?        00:00:00 migration/0<br>     13 ?        00:00:00 idle_inject/0<br>     14 ?        00:00:00 cpuhp/0<br>     15 ?        00:00:00 kdevtmpfs<br>.<br>.<br>.<br></code></pre></td></tr></table></figure><p>显示指定用户的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ ps -u root<br></code></pre></td></tr></table></figure><p><code>a</code>显示现行终端机下的所有程序，包括其他用户的程序，<code>u</code>以用户为主的格式来显示程序状况，<code>x</code>显示所有程序，不以终端机来区分<br><code>USER</code>－运行该流程的用户。</p><p><code>%CPU</code>－进程 CPU 利用率。</p><p><code>%MEM</code>－进程驻留集大小占计算机物理内存的百分比。</p><p><code>VSZ</code>－KiB 中进程的虚拟内存大小。</p><p><code>RSS</code>－进程正在使用的物理内存的大小。</p><p><code>STAT</code>－进程状态代码，可以是 Z（zombie），S（休眠），R（运行）..等等。</p><p><code>START</code>－命令启动的时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ ps aux              <br>USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root           1  0.0  0.2 102084 11540 ?        Ss   09:09   0:01 /sbin/init splash<br>root           2  0.0  0.0      0     0 ?        S    09:09   0:00 [kthreadd]<br>root           3  0.0  0.0      0     0 ?        I&lt;   09:09   0:00 [rcu_gp]<br></code></pre></td></tr></table></figure><p>按 CPU 资源的使用量对进程进行排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ ps aux | sort -nk 3<br>avahi        492  0.0  0.0   8536  3260 ?        Ss   09:09   0:00 avahi-daemon: running [hanhan.local]<br>avahi        552  0.0  0.0   8352   332 ?        S    09:09   0:00 avahi-daemon: chroot helper<br>colord      1442  0.0  0.3 255144 14408 ?        Ssl  09:09   0:00 /usr/libexec/colord<br>dominic     1068  0.0  0.0  31244   364 ?        S    09:09   0:00 /usr/bin/VBoxClient --clipboard<br>dominic     1069  0.0  0.9 163512 39088 ?        Sl   09:09   0:00 /usr/bin/VBoxClient --clipboard<br>dominic     1080  0.0  0.0  31244   364 ?        S    09:09   0:00 /usr/bin/VBoxClient --seamless<br><br><span class="hljs-comment"># 其中`sort`命令中`-n`为按数值进行排序，`-k  3` 表示以输出结果的第三列来进行排序，</span><br><span class="hljs-comment"># 从上一个实例中看到，第三列为CPU使用率`%CPU`。</span><br><span class="hljs-comment"># 同理ps aux | sort -rnk 4 即按内存使用降序排序</span><br></code></pre></td></tr></table></figure><p>显示前 5 名最耗 CPU 的进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ ps aux --sort=-pcpu | head -5<br>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root         1  2.6  0.7  51396  7644 ?        Ss   02:02   0:03 /usr/lib/systemd/systemd --switched-root --system --deserialize 23<br>root      1249  2.6  3.0 355800 30896 tty1     Rsl+ 02:02   0:02 /usr/bin/X -background none :0 vt01 -nolisten tcp<br>root       508  2.4  1.6 248488 16776 ?        Ss   02:02   0:03 /usr/bin/python /usr/sbin/firewalld --nofor<br></code></pre></td></tr></table></figure><p>下面的命令会显示进程 id 为 3150 的进程的所有线程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ ps -p 3150 -L<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 OpenSSL SSL_connect: Connection was reset in connection to github.com:443</title>
    <link href="/2021/08/09/%E8%A7%A3%E5%86%B3OpenSSL-SSL-connect-Connection-was-reset-in-connection-to-github-com-443/"/>
    <url>/2021/08/09/%E8%A7%A3%E5%86%B3OpenSSL-SSL-connect-Connection-was-reset-in-connection-to-github-com-443/</url>
    
    <content type="html"><![CDATA[<p>在向 GitHub 推送博客时，推送失败报了这个错。也不知道是改了什么设置突然报错。SSL 的错之前遇到一次，就是刚开始配置 Git 时用的<code>https</code>协议，每次<code>push</code>都需要重新输入一次密码。改成<code>ssl</code>协议就 OK 了。当时把 Linux 环境的 Git 改了，但是现在的 Windows 下没改，猜测可能和这也有关，于是就把 URL 改了一下，结果还真好了。<br>在本地仓库的<code>.git</code>文件里找到<code>config</code>文件，打开后将<code>url</code>改为<code>ssl</code>协议，<code>git@github.com:XXX</code>格式的。</p><p>将 Hexo 的配置也改了，找到仓库下的<code>_config.yml</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> 改成ssl协议地址<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Bug</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 事件</title>
    <link href="/2021/08/09/Qt%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/08/09/Qt%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>本篇文章所涉及代码可在<a href="https://github.com/Dunky-Z/learning-qt/tree/main/Event">此处查看</a></p><h2 id="事件以及与信号的区别"><a href="#事件以及与信号的区别" class="headerlink" title="事件以及与信号的区别"></a>事件以及与信号的区别</h2><p><strong>事件</strong>（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p><p>事件和信号槽的区别</p><ul><li>信号是由具体对象发出，然后马上交给<code>connect</code>函数连接的槽进行处理，如果处理过程中产生了新的信号，将会继续执行新的信号，一直这样递归进行下去。而事件使用一个事件队列对发出的所有事件进行维护，当新的事件产生时会被加到事件队列的尾部。</li></ul><p>在运行过程中发现，刚启动时并不会显示任何内容，只有在点击一次后，平面才会显示信息。这是因为<code>QWidget</code>中有一个<code>mouseTracking</code>属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，<code>mouseMoveEvent()</code>才会发出。如果<code>mouseTracking</code>是 <code>false</code>（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出<code>mouseMoveEvent()</code>事件。如果<code>mouseTracking</code>为 <code>true</code>，则<code>mouseMoveEvent()</code>直接可以被发出。知道了这一点，我们就可以在<code>main()</code>函数中直接设置下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">EventLabel *label = new EventLabel;<br><span class="hljs-function"><span class="hljs-title">label</span>-&gt;</span>setWindowTitle(<span class="hljs-string">&quot;MouseEvent Demo&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">label</span>-&gt;</span>resize(<span class="hljs-number">300</span>, <span class="hljs-number">200</span>);<br><span class="hljs-function"><span class="hljs-title">label</span>-&gt;</span>setMouseTracking(<span class="hljs-literal">true</span>);<br><span class="hljs-function"><span class="hljs-title">label</span>-&gt;</span>show();<br></code></pre></td></tr></table></figure><h3 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210809102859.png"></p><h2 id="事件的接受与忽略"><a href="#事件的接受与忽略" class="headerlink" title="事件的接受与忽略"></a>事件的接受与忽略</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//custombutton.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDebug&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomButton</span> :</span> <span class="hljs-keyword">public</span> QPushButton<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onButtonClicked</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CustomButton</span>(QWidget *parent = <span class="hljs-number">0</span>);<br><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//custombutton.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;custombutton.h&quot;</span></span><br><br>CustomButton::<span class="hljs-built_in">CustomButton</span>(QWidget *parent) : <span class="hljs-built_in">QPushButton</span>(parent)<br>&#123;<br>    <span class="hljs-built_in">connect</span>(<span class="hljs-keyword">this</span>, &amp;CustomButton::clicked, <span class="hljs-keyword">this</span>, &amp;CustomButton::onButtonClicked);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CustomButton::onButtonClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;You clicked this!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main02.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;custombutton.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    CustomButton btn;<br>    btn.<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;This is a Button!&quot;</span>);<br>    btn.<span class="hljs-built_in">show</span>();<br><br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码运行结果就是点击按钮会在控制台输出：”You clicked this!”。</p><p>现在，我们在<code>CustomButton</code>类中再添加一个事件函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//custombutton.h</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//custombutton.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CustomButton::mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (event-&gt;<span class="hljs-built_in">button</span>() == Qt::LeftButton)<br>    &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Left&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        QPushButton::<span class="hljs-built_in">mousePressEvent</span>(event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时运行结果为点击按键输出”Left”。而没有再输出”You clicked this!”。说明我们把父类的实现覆盖了。<strong>当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！</strong>。这一定程度上说，我们的组件<strong>忽略</strong>了父类的事件。</p><p>通过调用父类的同名函数，我们可以把 Qt 的事件传递看成链状：如果子类没有处理这个事件，就会继续向其父类传递。<code>Qt</code> 的事件对象有两个函数：<code>accept()</code>和<code>ignore()</code>。正如它们的名字一样，前者用来告诉 Qt，这个类的事件处理函数想要处理这个事件；后者则告诉 Qt，这个类的事件处理函数不想要处理这个事件。在事件处理函数中，可以使用<code>isAccepted()</code>来查询这个事件是不是已经被接收了。具体来说：如果一个事件处理函数调用了一个事件对象的<code>accept()</code>函数，这个事件就不会被继续传播给其父组件；如果它调用了事件的<code>ignore()</code>函数，Qt 会从其父组件中寻找另外的接受者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//custombutton01.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDebug&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QVBoxLayout&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomButton</span> :</span> <span class="hljs-keyword">public</span> QPushButton<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CustomButton</span>(QWidget *parent) : <span class="hljs-built_in">QPushButton</span>(parent)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;CustomButton&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomButtonEx</span> :</span> <span class="hljs-keyword">public</span> CustomButton<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CustomButtonEx</span>(QWidget *parent) : <span class="hljs-built_in">CustomButton</span>(parent)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;CustomButtonEx&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomWidget</span> :</span> <span class="hljs-keyword">public</span> QWidget<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CustomWidget</span>(QWidget *parent) : <span class="hljs-built_in">QWidget</span>(parent)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;CustomWidget&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MainWindow</span>(QWidget *parent = <span class="hljs-number">0</span>) : <span class="hljs-built_in">QMainWindow</span>(parent)<br>    &#123;<br>        CustomWidget *widget = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CustomWidget</span>(<span class="hljs-keyword">this</span>);<br>        CustomButton *cbex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CustomButton</span>(widget);<br>        cbex-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;CustomButton&quot;</span>));<br>        CustomButtonEx *cb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CustomButtonEx</span>(widget);<br>        cb-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;CustomButtonEx&quot;</span>));<br>        QVBoxLayout *widgetLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QVBoxLayout</span>(widget);<br>        widgetLayout-&gt;<span class="hljs-built_in">addWidget</span>(cbex);<br>        widgetLayout-&gt;<span class="hljs-built_in">addWidget</span>(cb);<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setCentralWidget</span>(widget);<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;MainWindow&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//mai03.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;custombutton01.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    MainWindow win;<br>    win.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码在一个<code>MainWindow</code>中添加了一个<code>CustomWidget</code>，里面有两个按钮对象：<code>CustomButton</code>和<code>CustomButtonEx</code>。每一个类都重写了<code>mousePressEvent()</code>函数。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210809145445.png"></p><p>运行程序点击 <code>CustomButtonEx</code>，结果是</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">CustomButtonEx</span><br></code></pre></td></tr></table></figure><p>因为我们重写了<code>mousePressEvent()</code>，所以调用子类自己的函数，如果在<code>CustomButtonEx</code>的<code>mousePressEvent()</code>第一行增加一句<code>event-&gt;accept()</code>，重新运行，发现结果不变。正如我们前面所说，QEvent 默认是<code>accept</code>的，调用这个函数并没有什么区别。然后我们将<code>CustomButtonEx</code>的<code>event-&gt;accept()</code>改成<code>event-&gt;ignore()</code>。这次运行结果是</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">CustomButtonEx</span><br><span class="hljs-attribute">CustomWidget</span><br></code></pre></td></tr></table></figure><p><code>ignore()</code>说明我们想让事件继续传播，于是<code>CustomButtonEx</code>的父组件<code>CustomWidget</code>也收到了这个事件，所以输出了自己的结果。</p><p>同理，<code>CustomWidget</code>又没有调用父类函数或者显式设置<code>accept()</code>或<code>ignore()</code>，所以事件传播就此打住。</p><p>这里值得注意的是，<code>CustomButtonEx</code>的事件传播给了父组件<code>CustomWidget</code>，而不是它的父类<code>CustomButton</code>。<strong>事件的传播是在组件层次上面的，而不是依靠类继承机制</strong>。</p><p>在一个特殊的情形下，我们必须使用<code>accept()</code>和<code>ignore()</code>函数，那就是窗口关闭的事件。对于窗口关闭<code>QCloseEvent</code>事件，调用<code>accept()</code>意味着 Qt 会停止事件的传播，窗口关闭；调用<code>ignore()</code>则意味着事件继续传播，即阻止窗口关闭。<a href="https://github.com/Dunky-Z/learning-qt/blob/main/Dialog/mainwindow.cpp">回到我们前面写的简单的文本编辑器</a>。</p><h2 id="event-函数"><a href="#event-函数" class="headerlink" title="event() 函数"></a>event() 函数</h2><p>事件对象创建完毕后，Qt 将这个事件对象传递给<code>QObject</code>的<code>event()</code>函数。<code>event()</code>函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（<code>event handler</code>）。</p><p>如上所述，<code>event()</code>函数主要用于事件的分发。所以，如果你希望在事件分发之前做一些操作，就可以重写这个<code>event()</code>函数了。例如，我们希望在一个 QWidget 组件中监听 <code>tab</code> 键的按下，那么就可以继承 QWidget，并重写它的<code>event()</code>函数，来达到这个目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CustomWidget::event</span><span class="hljs-params">(QEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) <br>    &#123;<br>        QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(e);<br>        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) <br>        &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;You press tab.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">event</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CustomWidget</code>是一个普通的<code>QWidget</code>子类。我们重写了它的<code>event()</code>函数，这个函数有一个<code>QEvent</code>对象作为参数，也就是需要转发的事件对象。函数返回值是 <code>bool</code> 类型。如果传入的事件已被识别并且处理，则需要返回 <code>true</code>，否则返回 <code>false</code>。如果返回值是 <code>true</code>，并且，该事件对象设置了<code>accept()</code>，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。注意，在<code>event()</code>函数中，调用事件对象的<code>accept()</code>和<code>ignore()</code>函数是没有作用的，不会影响到事件的传播。</p><p>我们可以通过使用<code>QEvent::type()</code>函数可以检查事件的实际类型，其返回值是<code>QEvent::Type</code>类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 <code>true</code>，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的<code>event()</code>函数继续转发，否则这个组件就只能处理我们定义的事件了。为了测试这一种情况，我们可以尝试下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CustomTextEdit::event</span><span class="hljs-params">(QEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) &#123;<br>        QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(e);<br>        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;You press tab.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CustomTextEdit</code>是<code>QTextEdit</code>的一个子类。我们重写了其<code>event()</code>函数，却没有调用父类的同名函数。这样，我们的组件就只能处理 <code>Tab</code> 键，再也无法输入任何文本，也不能响应其它事件，比如鼠标点击之后也不会有光标出现。这是因为我们只处理的<code>KeyPress</code>类型的事件，并且如果不是<code>KeyPress</code>事件，则直接返回 <code>false</code>，鼠标事件根本不会被转发，也就没有了鼠标事件。</p><h2 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h2><p>有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。</p><p>通过前面的章节，我们已经知道，Qt 创建了<code>QEvent</code>事件对象之后，会调用<code>QObject</code>的<code>event()</code>函数处理事件的分发。显然，我们可以在<code>event()</code>函数中实现拦截的操作。由于<code>event()</code>函数是 <code>protected</code> 的，因此，需要继承已有类。如果组件很多，就需要重写很多个<code>event()</code>函数。这当然相当麻烦，更不用说重写<code>event()</code>函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。</p><p><code>QObject</code>有一个<code>eventFilter()</code>函数，用于建立事件过滤器。这个函数的签名如下：</p><p>这个函数正如其名字显示的那样，是一个“事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。想想做化学实验时用到的过滤器，可以将杂质留到滤纸上，让过滤后的液体溜走。事件过滤器也是如此：它会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 <code>bool</code> 类型，如果你想将参数 <code>event</code> 过滤出来，比如，不想让它继续转发，就返回 <code>true</code>，否则返回 <code>false</code>。事件过滤器的调用时间是目标对象（也就是参数里面的<code>watched</code>对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，<code>watched</code>对象以及以后所有的事件过滤器根本不会知道这么一个事件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">MainWindow</span>();<br> <span class="hljs-keyword">protected</span>:<br>     <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">eventFilter</span><span class="hljs-params">(QObject *obj, QEvent *event)</span></span>;<br> <span class="hljs-keyword">private</span>:<br>     QTextEdit *textEdit;<br> &#125;;<br><br> MainWindow::<span class="hljs-built_in">MainWindow</span>()<br> &#123;<br>     textEdit = <span class="hljs-keyword">new</span> QTextEdit;<br>     <span class="hljs-built_in">setCentralWidget</span>(textEdit);<br>     textEdit-&gt;<span class="hljs-built_in">installEventFilter</span>(<span class="hljs-keyword">this</span>);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">MainWindow::eventFilter</span><span class="hljs-params">(QObject *obj, QEvent *event)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (obj == textEdit) &#123;<br>         <span class="hljs-keyword">if</span> (event-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) &#123;<br>             QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(event);<br>             <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Ate key press&quot;</span> &lt;&lt; keyEvent-&gt;<span class="hljs-built_in">key</span>();<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// pass the event on to the parent class</span><br>         <span class="hljs-keyword">return</span> QMainWindow::<span class="hljs-built_in">eventFilter</span>(obj, event);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><code>MainWindow</code>是我们定义的一个类。我们重写了它的<code>eventFilter()</code>函数。为了过滤特定组件上的事件，首先需要判断这个对象是不是我们感兴趣的组件，然后判断这个事件的类型。在上面的代码中，我们不想让<code>textEdit</code>组件处理键盘按下的事件。所以，首先我们找到这个组件，如果这个事件是键盘事件，则直接返回 <code>true</code>，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回 <code>false</code>。对于其它的组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。</p><p><code>eventFilter()</code>函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用<code>QObject::installEventFilter()</code>函数。这个函数的签名如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QObject::installEventFilter</span> <span class="hljs-params">( QObject * filterObj )</span></span><br></code></pre></td></tr></table></figure><p>这个函数接受一个<code>QObject *</code>类型的参数。记得刚刚我们说的，<code>eventFilter()</code>函数是<code>QObject</code>的一个成员函数，因此，任意<code>QObject</code>都可以作为事件过滤器（问题在于，如果你没有重写<code>eventFilter()</code>函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过<code>QObject::removeEventFilter()</code>函数移除。</p><p>我们可以向一个对象上面安装多个事件处理器，只要调用多次<code>installEventFilter()</code>函数。如果一个对象存在多个事件过滤器，那么，<strong>最后一个安装的会第一个执行</strong>，也就是后进先执行的顺序。</p><p>还记得我们前面的那个例子吗？我们使用<code>event()</code>函数处理了 <code>Tab</code> 键：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CustomWidget::event</span><span class="hljs-params">(QEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) &#123;<br>        QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(e);<br>        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;You press tab.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">event</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FilterObject::eventFilter</span><span class="hljs-params">(QObject *object, QEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (object == target &amp;&amp; event-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) &#123;<br>        QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(event);<br>        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;You press tab.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，<code>installEventFilter()</code>函数是<code>QObject</code>的函数，<code>QApplication</code>或者<code>QCoreApplication</code>对象都是<code>QObject</code>的子类，因此，我们可以向<code>QApplication</code>或者<code>QCoreApplication</code>添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。因此，除非是不得不使用的情况，否则的话我们不应该这么做。</p><p><strong>注意，如果你在事件过滤器中 <code>delete</code> 了某个接收组件，务必将函数返回值设为 <code>true</code>。否则，Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃。</strong></p><p><strong>事件过滤器和被安装过滤器的组件必须在同一线程</strong>，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p><blockquote><p>事件过滤器和安装过滤器的组件必须在同一线程。Qt 里面，对象创建之后，可以使用 moveToThread() 函数将一个对象移动到另外的线程。在这种情形下（当然，事件过滤器必须在同一线程时才能被正确安装，这是第一句话说明的），在它们分属在不同线程时，事件过滤器也是不起作用的，只用当它们重新回到同一线程（使用 moveToThread() 或者是线程自然结束）时，过滤器才能重新工作</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-scp 远程拷贝文件</title>
    <link href="/2021/08/06/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-scp%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/"/>
    <url>/2021/08/06/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-scp%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>看到同事要安装自己编译一天的库，本想传授一下“踩坑经验”，结果他用<code>scp</code>命令直接从已经安装好的电脑里复制了一份。心里一万只 XXX 在奔腾。</p><p>早知道先学学这个命令了。</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">强制 scp 命令使用协议 ssh1</td></tr><tr><td align="center">-2</td><td align="center">强制 scp 命令使用协议 ssh2</td></tr><tr><td align="center">-4</td><td align="center">强制 scp 命令使用协议 ssh2</td></tr><tr><td align="center">-6</td><td align="center">强制 scp 命令只使用 IPv6 寻址</td></tr><tr><td align="center">-B</td><td align="center">使用批处理模式（传输过程中不询问传输口令或短语）</td></tr><tr><td align="center">-C</td><td align="center">允许压缩</td></tr><tr><td align="center">-p</td><td align="center">保留原文件的修改时间，访问时间和访问权限。</td></tr><tr><td align="center">-q</td><td align="center">不显示传输进度条</td></tr><tr><td align="center">-r</td><td align="center">递归复制整个目录</td></tr><tr><td align="center">-v</td><td align="center">详细方式显示输出</td></tr><tr><td align="center">-P</td><td align="center">注意是大写的 P, port 是指定数据传输用到的端口号</td></tr></tbody></table><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>复制文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp local_file rmot_usr<span class="hljs-variable">@rmot_ip</span><span class="hljs-symbol">:rmot_folder</span><br>scp /opt/soft/ root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.120</span>.<span class="hljs-number">204</span><span class="hljs-symbol">:/opt/soft/nginx-</span>0.<span class="hljs-number">5.38</span>.tar.gz <br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-grep 文本搜索</title>
    <link href="/2021/08/05/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-grep%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/08/05/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-grep%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><code>grep</code>全称<code>global search regular expression(RE) and print out the line</code>，全面搜索正则表达式并把行打印出来。这名字就怪吓人，如果熟练掌握正则表达式，配上这命令 Linux 里可以横着走了。</p><p>这个命令参数实在太多，加上正则表达式估计一张纸不够。那就直接上实例吧。</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>在当前目录中，查找后缀带有<code>cpp</code>字样的文中包含<code>test</code>字符串的文件，并打印所在行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-built_in">test</span> *cpp<br>grep --colorauto <span class="hljs-built_in">test</span> *cpp      <span class="hljs-comment"># 用颜色标记</span><br></code></pre></td></tr></table></figure><p>通过”-v”参数可以打印出不符合条件行的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -v <span class="hljs-built_in">test</span> *cpp<br></code></pre></td></tr></table></figure><p>系统报警显示了时间，但是日志文件太大无法直接 cat 查看。(查询含有特定文本的文件，并拿到这些文本所在的行)。<code>-n</code> 或 <code>--line-number</code> 可以显示符合样式的那一行之前，标示出该行的列数编号。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grep</span> -n &#x27;<span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">01</span>:<span class="hljs-number">11</span>&#x27; *.log<br></code></pre></td></tr></table></figure><p>grep 静默输出，不会输出任何信息，如果命令运行成功返回 0，失败则返回非 0 值。一般用于条件测试。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> -q <span class="hljs-string">&quot;test&quot;</span> filename<br></code></pre></td></tr></table></figure><p>在多级目录中对文本进行递归搜索</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">grep <span class="hljs-string">&quot;text&quot;</span> . -r -<span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure><p>配合管道，查找指定的进程信息</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> svn<br></code></pre></td></tr></table></figure><p>查找指定的进程个数，<code>-c</code>计数</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> svn -<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>常用正则表达式通配符<br>|  通配符   | 功能  |<br>| :—-:  | :—-:  |<br>| c*  | 将匹配 0 个（即空白）或多个字符 c（c 为任一字符） |<br>| .  | 将匹配任何一个字符，且只能是一个字符 |<br>| [xyz]  | 匹配方括号中的任意一个字符 |<br>| [^xyz]  | 匹配除方括号中字符外的所有字符 |<br>| ^  | 锁定行的开头 |<br>| $  | 锁定行的结尾 |</p><p>在<code>id.txt</code>中找到所有以 3207 开头的数据</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">grep</span><span class="hljs-regexp"> ^3207</span> id.txt<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 对话框</title>
    <link href="/2021/08/05/Qt%E5%AF%B9%E8%AF%9D%E6%A1%86/"/>
    <url>/2021/08/05/Qt%E5%AF%B9%E8%AF%9D%E6%A1%86/</url>
    
    <content type="html"><![CDATA[<p>本篇文章所涉及代码，可在<a href="https://github.com/Dunky-Z/learning-qt/tree/main/Dialog">此处查看</a></p><p>Qt 中使用 QDialog 类实现对话框。就像主窗口一样，我们通常会设计一个类继承 QDialog。QDialog（及其子类，以及所有 Qt::Dialog 类型的类）的对于其 parent 指针都有额外的解释：</p><p>如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。</p><p>顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。</p><p>对话框分为<strong>模态对话框</strong>和<strong>非模态对话框</strong>。所谓模态对话框，就是会阻塞同一应用程序中其它窗口的输入。模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。</p><p>与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。</p><p>Qt 支持模态对话框和非模态对话框。其中，Qt 有两种级别的模态对话框：<strong>应用程序级别的模态</strong>和<strong>窗口级别的模态</strong>，默认是应用程序级别的模态。应用程序级别的模态是指，当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。窗口级别的模态是指，该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。</p><h2 id="消息对话框-QMessageBox"><a href="#消息对话框-QMessageBox" class="headerlink" title="消息对话框 QMessageBox"></a>消息对话框 QMessageBox</h2><h2 id="文件对话框-QFileDialog"><a href="#文件对话框-QFileDialog" class="headerlink" title="文件对话框 QFileDialog"></a>文件对话框 QFileDialog</h2><h2 id="‘QTextEdit’-Does-not-name-a-type"><a href="#‘QTextEdit’-Does-not-name-a-type" class="headerlink" title="‘QTextEdit’ Does not name a type"></a>‘QTextEdit’ Does not name a type</h2><p>需要包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QTextEdit&gt;</span></span><br></code></pre></td></tr></table></figure><p>Qt 需要包含的头文件实在太多了。</p><p>可能添加了头文件仍然报同样的错，没有搜索到相关的解答。</p><p>我的做法是：</p><ol><li>确保在<code>.pro</code>文件中加入<code>QT += widgets</code>和<code>CONFIG += c++11</code></li><li>将包含库文件语句都放到头文件<code>.h</code>中</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 中添加 gitignore 并更新远程仓库</title>
    <link href="/2021/08/04/Git%E4%B8%AD%E6%B7%BB%E5%8A%A0gitignore%E5%B9%B6%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2021/08/04/Git%E4%B8%AD%E6%B7%BB%E5%8A%A0gitignore%E5%B9%B6%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="gitignore-的作用"><a href="#gitignore-的作用" class="headerlink" title="gitignore 的作用"></a>gitignore 的作用</h2><p>在使用<code>Git</code>版本控制时，必须要用<code>.gitignore</code>这个文件来告诉<code>Git</code>那些文件或目录不需要添加到版本控制中。通俗点说，就是不需要<code>git push</code>到远程仓库。</p><p>在平时开发过程中，开发目录下会有各种格式的文件，比如 C 语言除了<code>.c</code>源码，还会有<code>.o</code>目标文件，没有后缀的可执行程序等等，假如你要进行深度学习类的开发，如图像识别，需要训练大量数据，如果这些训练数据也到跟踪管理，那<code>push</code>一次就可以下班回家了。</p><p>但是我们怎么让<code>Git</code>知道哪些文件需要跟踪，哪些文件不需要呢，这时候<code>.gitignore</code>文件就起作用了。</p><h2 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h2><p>简单介绍一下常用的规则，虽然后面有现成的模板，但是我们还是了解一下常用规则，能看得懂<code>.gitignore</code>里写了啥。也方便自己编写一些规则适应自己的工作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/test/</span>              <span class="hljs-comment"># 过滤整个test文件夹</span><br>*.o                 <span class="hljs-comment"># 过滤所有.o文件</span><br><span class="hljs-regexp">/test/</span>hello.o       <span class="hljs-comment"># 过滤test文件夹下hello.o这个文件</span><br>!src/               <span class="hljs-comment"># 不过滤src这个文件夹</span><br>!*.c                <span class="hljs-comment"># 不过滤.c文件</span><br></code></pre></td></tr></table></figure><h2 id="通过-gitignore-文件更新远程仓库"><a href="#通过-gitignore-文件更新远程仓库" class="headerlink" title="通过 gitignore 文件更新远程仓库"></a>通过 gitignore 文件更新远程仓库</h2><p>上面说到我们在不同环境下需要制定不同的规则，但是每次都要重新写一遍，又或者不知道制定什么样的规则，还是挺麻烦的。</p><p>首先推荐一个<code>.gitignore</code><a href="https://github.com/github/gitignore">模板仓库</a>，在平时工作学习中遇到的各种语言环境下的模板都能找到。这是广大开发人员总结的一些规则。</p><p>最近在学习<code>Qt</code>，在所有模板中搜索关键字，找到了<code>Qt.gitignore</code>这个模板打开并复制，在自己本地仓库里新建一个<code>.gitignore</code>文件，将复制的内容粘贴进去。</p><p>现在就要解决如何更新远程仓库的内容，因为我在使用<code>.gitignore</code>文件之前已经向远程<code>push</code>过了，现在需要删除不需要的文件。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git rm -r <span class="hljs-comment">--cached .</span><br></code></pre></td></tr></table></figure><p><code>rm</code>就是<code>Linux</code>下常用的删除命令，<code>-r</code>表示递归删除，<code>--cached</code>表示需要在本地端（工作区）保留文件，<code>.</code>表示所有文件。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> .   <span class="hljs-meta"># 重新添加所有文件到暂存区，然后提交，推送</span><br>git commit -m <span class="hljs-string">&quot;update&quot;</span><br>git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 添加资源文件</title>
    <link href="/2021/08/04/Qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <url>/2021/08/04/Qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是学习【<a href="https://www.devbean.net/2012/08/qt-study-road-2-catelog/">Qt 学习之路</a>】的学习笔记，源码非原创。<a href="https://github.com/Dunky-Z/learning-qt/tree/main/MainWindow">Github</a>同步本文更改的代码。</p></blockquote><p>在建立 Qt 学习代码仓时，推送到远程的代码比较乱，所以用<code>gitignore</code>文件屏蔽了一些。相关方法在<a href="https://dunky-z.github.io/2021/08/04/Git%E4%B8%AD%E6%B7%BB%E5%8A%A0gitignore%E5%B9%B6%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/">这里</a>。</p><h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><p>Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也<strong>不需要担心这些文件的丢失</strong>。也就是说，如果你将资源以资源文件形式存储，它是会<strong>编译到可执行文件内部</strong>。</p><p>使用 QtCreator 的<a href="https://www.devbean.net/2012/08/qt-study-road-2-resource-files/">相关方法</a>，讲得也很清楚了，就不赘述了。</p><h2 id="不使用-QtCreator-添加资源文件"><a href="#不使用-QtCreator-添加资源文件" class="headerlink" title="不使用 QtCreator 添加资源文件"></a>不使用 QtCreator 添加资源文件</h2><p>在使用命令行编译运行时，并不能像在 QtCreator 中一样，可以自动的生成一个<code>.qrc</code>文件，这就需要我们自己去编写。从原文的讲解中我们也知道，它就是一个<code>XML</code>描述文件，里面定义了文件位置等信息。如原文中的<code>.qrc</code>文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RCC</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">qresource</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;/images&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;doc-open&quot;</span>&gt;</span>document-open.png<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">qresource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">RCC</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;RCC&gt;</span><br>    <span class="hljs-section">&lt;qresource&gt;</span><br><br>    <span class="hljs-section">&lt;/qresource&gt;</span><br><span class="hljs-section">&lt;/RCC&gt;</span><br></code></pre></td></tr></table></figure><p>是固定的标记，再往中间加东西。如果学过<code>html</code>语言就很容易理解。其中<code>prefix=&quot;/images&quot;</code>就是自动加上前缀<code>/images</code>，因为图片在<code>images</code>目录下，每次都加这个路径太麻烦，太长。</p><p><code>alias=&quot;doc-open&quot;</code>意思是将<code>document-open.png</code>这个文件起个别名，原来的太长了。下次再用<code>document-open.png</code>就只需要用<code>doc-open</code>就行了。</p><p>我们知道了这些，就可以编写一个自己的<code>.qrc</code>文件了。我也自己下载了一个打开文件的图标<code>open.png</code>，文件比较少，就和代码放在同一个目录下了。我们将其命名为<code>ico.qrc</code>，这个文件中以后都存放有关图标的资源，我们开始编写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RCC</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">qresource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>open.png<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">qresource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">RCC</span>&gt;</span><br></code></pre></td></tr></table></figure><p>因为添加资源后需要更新<code>.pro</code>文件才能正常编译，所以需要在<code>.pro</code>中加入<code>RESOURCES</code> 信息，就在<code>.pro</code>文件最后一行加入：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">RESOURCES +</span>=<span class="hljs-string"> ico.qrc</span><br></code></pre></td></tr></table></figure><p>然后输入命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">qmake MainWindow.<span class="hljs-keyword">pro</span><br><span class="hljs-keyword">make</span> clean #因为之前可能<span class="hljs-keyword">make</span>过，先清理一遍<br><span class="hljs-keyword">make</span><br>./MainWindow<br></code></pre></td></tr></table></figure><p>如果一切顺利，将会得到下面的窗口：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210804120719.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210804120739.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.devbean.net/2012/08/qt-study-road-2-action/">https://www.devbean.net/2012/08/qt-study-road-2-action/</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-cat 可以查看文件的小猫咪</title>
    <link href="/2021/08/04/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-cat%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%8C%AB%E5%92%AA/"/>
    <url>/2021/08/04/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-cat%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%8C%AB%E5%92%AA/</url>
    
    <content type="html"><![CDATA[<p><code>cat</code> 可以将文件的内容方便地输出到屏幕上。但是它的全称<code>concatenate</code>意为“连接”，连接文件也是它的重要功能之一，很多人可能都不常用。只记得输出文件内容了。</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">n 或 --number              <span class="hljs-comment">#由 1 开始对所有输出的行数编号。</span></span><br><span class="ruby"></span>-<span class="ruby">b 或 --number-nonblank     <span class="hljs-comment">#和 -n 相似，只不过对于空白行不编号。</span></span><br><span class="ruby"></span>-<span class="ruby">s 或 --squeeze-blank       <span class="hljs-comment">#当遇到有连续两行以上的空白行，就代换为一行的空白行。</span></span><br><span class="ruby"></span>-<span class="ruby">v 或 --show-nonprinting    <span class="hljs-comment">#使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</span></span><br><span class="ruby"></span>-<span class="ruby">E 或 --show-ends           <span class="hljs-comment"># 在每行结束处显示 $。</span></span><br><span class="ruby"></span>-<span class="ruby">T 或 --show-<span class="hljs-symbol">tabs:</span>          <span class="hljs-comment">#将 TAB 字符显示为 ^I。</span></span><br><span class="ruby"></span>-<span class="ruby">A, --show-all              <span class="hljs-comment">#等价于 -vET。</span></span><br><span class="ruby"></span>-<span class="ruby">e                          <span class="hljs-comment">#等价于&quot;-vE&quot;选项；</span></span><br><span class="ruby"></span>-<span class="ruby">t                          <span class="hljs-comment">#等价于&quot;-vT&quot;选项；</span></span><br></code></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>将文件内容输出到屏幕</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ cat test.txt <br>This <span class="hljs-keyword">is</span> firt <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> second <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> third <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> fourth <span class="hljs-type">line</span>!<br></code></pre></td></tr></table></figure><p>将<code>test.txt</code>的内容输入到<code>test01.txt</code>中</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ cat test.txt &gt; test01.txt<br>➜  ~ cat test01.txt <br>This <span class="hljs-keyword">is</span> firt <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> second <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> third <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> fourth <span class="hljs-type">line</span>!<br></code></pre></td></tr></table></figure><p>带行号输出</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ cat -n test.txt <br>     <span class="hljs-number">1</span> This <span class="hljs-keyword">is</span> firt <span class="hljs-type">line</span>!<br>     <span class="hljs-number">2</span> This <span class="hljs-keyword">is</span> second <span class="hljs-type">line</span>!<br>     <span class="hljs-number">3</span> This <span class="hljs-keyword">is</span> third <span class="hljs-type">line</span>!<br>     <span class="hljs-number">4</span> This <span class="hljs-keyword">is</span> fourth <span class="hljs-type">line</span>! <br></code></pre></td></tr></table></figure><p>将两个文件内容合并，再写入到第三个文件中</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ cat test.txt test01.txt &gt;&gt; test02.txt<br>➜  ~ cat test02.txt <br>This <span class="hljs-keyword">is</span> firt <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> second <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> third <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> fourth <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> firt <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> second <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> third <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> fourth <span class="hljs-type">line</span>!<br></code></pre></td></tr></table></figure><p>清空文件中的内容</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">➜  ~ <span class="hljs-keyword">cat</span> /dev/null &gt; <span class="hljs-keyword">test</span>.txt <br>➜  ~ <span class="hljs-keyword">cat</span> <span class="hljs-keyword">test</span>.txt <br>➜  ~ <br></code></pre></td></tr></table></figure><p>在类 Unix 系统中，/dev/null 称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个 EOF。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.runoob.com/linux/linux-comm-cat.html">https://www.runoob.com/linux/linux-comm-cat.html</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决/usr/bin/env:python:No such file or directory</title>
    <link href="/2021/08/03/%E8%A7%A3%E5%86%B3-usr-bin-env-python-No-such-file-or-directory/"/>
    <url>/2021/08/03/%E8%A7%A3%E5%86%B3-usr-bin-env-python-No-such-file-or-directory/</url>
    
    <content type="html"><![CDATA[<p>在执行的程序源码开头有这么一句<code>!#/usr/bin/env python</code>，<code>!#</code>这玩意叫<code>shebang</code>也叫<code>hashbang</code>。他用来指定脚本的解释器，也就是说这个程序指定<code>python</code>解释器。</p><p>再看这个错误提示，罪魁祸首就是这句命令，就是说在环境变量找不到<code>python</code>，通俗点说，假如我要能直接用<code>python</code>来跑这个程序，我在命令行直接输入<code>python</code>应该是可以进入<code>python</code>环境的，但是此时肯定不能。我们可以试试</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">dominic<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>python<br>Commond <span class="hljs-keyword">not</span> found xxxxxxxxxxx<br></code></pre></td></tr></table></figure><h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><p>系统里没有<code>python</code>还跑个锤子，先装上再说</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-builtin-name">get</span> install python3<br></code></pre></td></tr></table></figure><p>这时候可能就解决问题了</p><h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h2><p>有的人可能<code>python</code>早就装了，但是仍然有这个问题，但是我们在命令输入<code>python</code>仍然没法用，但是输入<code>python3</code>就可以</p><p>那<code>python3</code>可以，我直接将<code>python</code>改成<code>python3</code>不就完了。没错！</p><p>打开文件将<code>!#/usr/bin/env python</code>改成<code>!#/usr/bin/env python3</code></p><h2 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h2><p>如果了解软链接，那我们就可以不用去改源码了，源码最好还是保持原样。</p><p>既然找不到<code>python</code>这玩意，那我们给他建一个不就完了。</p><p>他要<code>python</code>就是用来解释程序的，我们本地装的<code>python3</code>就是他需要的东西</p><p>先找找我们的<code>python3</code>在哪</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">dominic@hanhan:~$ whereis python3<br>python3: <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python3.8 /u</span>sr<span class="hljs-regexp">/bin/</span>python3.<span class="hljs-number">8</span>-config <span class="hljs-regexp">/usr/</span>bin/python3 <br></code></pre></td></tr></table></figure><p>一般在<code>/usr/bin</code>目录下，然后我们在这个目录下给他创建一个软链接“快捷方式”，具体咋用的啥意思，可以<a href="https://dunky-z.github.io/2021/08/03/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/">参考这篇文章</a>。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln -s <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python3 /u</span>sr<span class="hljs-regexp">/bin/</span>python<br></code></pre></td></tr></table></figure><p>这样程序再找<code>python</code>时就会链接到<code>python3</code>，然后用<code>python3</code>去当解释器。</p><h2 id="解决方案四"><a href="#解决方案四" class="headerlink" title="解决方案四"></a>解决方案四</h2><p>可能在<code>root</code>目录下使用过<code>repo</code>，将其删除</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug 踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-ln 软硬链接</title>
    <link href="/2021/08/03/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <url>/2021/08/03/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。这有点像 Windows 环境下的快捷方式。介绍命令前了解一下软链接，硬链接具体是什么。</p><h2 id="硬链接-Hard-Link"><a href="#硬链接-Hard-Link" class="headerlink" title="硬链接 Hard Link"></a>硬链接 Hard Link</h2><p>在 Linux 系统中，每个文件对应一个 <code>inode</code>，文件的内容在存储在 <code>inode</code> 指向的 <code>data block</code> 中。要读取该文件的内容，需要通过文件所在的目录中记录的<strong>文件名</strong>找到文件的 <code>inode</code> 号，然后通过 <code>inode</code> 找到存储文件内容的 <code>data block</code>。当然多个<strong>文件名</strong>可以指向同一个<code>inode</code>。</p><p>使用<code>ll</code>命令显示文件的详细信息，<code>-i</code>参数显示其结点信息，其中最前面的一串数字就是<code>inode</code>信息。我们以<code>/opt/test.txt</code>文件为例，查看其结点信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dominic</span>@hanhan:/opt$ ll -i test.txt <br><span class="hljs-attribute">2498138</span> -rw-r--r-- <span class="hljs-number">1</span> root root <span class="hljs-number">4</span> <span class="hljs-number">8</span>月   <span class="hljs-number">3</span> <span class="hljs-number">12</span>:<span class="hljs-number">16</span> test.txt<br></code></pre></td></tr></table></figure><p>使用 <code>ln</code> 命令在<code>/opt/temp</code>目录下创建一个 <code>test.txt</code> 文件的硬链接，然后观察其文件属性：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dominic</span>@hanhan:/opt/temp$ sudo ln ../test.txt .<br><span class="hljs-attribute">dominic</span>@hanhan:/opt/temp$ ll -i ../test.txt test.txt <br><span class="hljs-attribute">2498138</span> -rw-r--r-- <span class="hljs-number">2</span> root root <span class="hljs-number">4</span> <span class="hljs-number">8</span>月   <span class="hljs-number">3</span> <span class="hljs-number">12</span>:<span class="hljs-number">16</span> ../test.txt<br><span class="hljs-attribute">2498138</span> -rw-r--r-- <span class="hljs-number">2</span> root root <span class="hljs-number">4</span> <span class="hljs-number">8</span>月   <span class="hljs-number">3</span> <span class="hljs-number">12</span>:<span class="hljs-number">16</span> test.txt<br></code></pre></td></tr></table></figure><p>我们再用<code>ll -i</code>命令查看结点信息，发现这两个文件名的结点信息是一样的。说明这两个文件名指向的是同一个文件。其中第三个字段是<strong>链接数</strong>，数字<code>2</code>，表示有两个文件名链接到同一个<code>inode</code>。</p><h4 id="硬链接的特点"><a href="#硬链接的特点" class="headerlink" title="硬链接的特点"></a>硬链接的特点</h4><ul><li>硬链接，以文件副本的形式存在。但不占用实际空间。<br>由于硬链接只是在目录中添加了一条包含文件名和 对应 inode 的记录，所以它几乎不会消耗额外的磁盘容量。</li><li>不允许给目录创建硬链接</li><li>硬链接只有在同一个文件系统中才能创建</li><li>只要还有一个文件名引用着文件，文件就不会被真正删除<br>删除硬链接所关联的文件时，其实只是删除了一条目录中的记录，真正的文件并不受影响。只有在删除最后一个硬链接时才会真正删除文件的内容数据。</li></ul><h2 id="软链接-Symbolic-Link"><a href="#软链接-Symbolic-Link" class="headerlink" title="软链接 Symbolic Link"></a>软链接 Symbolic Link</h2><p>软链接的实现方式与硬链接有本质上的不同。创建软链接时会创建一个新的文件 (分配一个<code>inode</code> 和对应的 <code>data block</code>)，新文件的 <code>data block</code> 中存储了目标文件的路径。</p><p>我们以<code>/opt/test.txt</code>为例，在<code>/opt/temp</code>目录中，为其创建一个软链接，然后查看其<code>inode</code>结点信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dominic</span>@hanhan:/opt/temp$ sudo ln -s ../test.txt test<span class="hljs-number">2</span>.txt<br><span class="hljs-attribute">dominic</span>@hanhan:/opt/temp$ ll -i ../test.txt test<span class="hljs-number">2</span>.txt <br><span class="hljs-attribute">2498139</span> lrwxrwxrwx <span class="hljs-number">1</span> root root <span class="hljs-number">11</span> <span class="hljs-number">8</span>月   <span class="hljs-number">3</span> <span class="hljs-number">14</span>:<span class="hljs-number">01</span> test<span class="hljs-number">2</span>.txt -&gt; ../test.txt<br><span class="hljs-attribute">2498138</span> -rw-r--r-- <span class="hljs-number">2</span> root root  <span class="hljs-number">4</span> <span class="hljs-number">8</span>月   <span class="hljs-number">3</span> <span class="hljs-number">12</span>:<span class="hljs-number">16</span> ../test.txt<br></code></pre></td></tr></table></figure><ul><li>第一个字段不同，说明是两个文件了</li><li>第二个字段表示权限，第一个字母表示文件类型，<code>l</code>说明书软链接文件</li><li>第三个字段表示链接数，仍然是<code>2</code>，说明软链接不增加源文件链接数</li><li>第六个字段是文件大小，新建的软链接文件时 11 字节，这就是<code>/opt/test.txt</code>的长度。</li></ul><h4 id="软链接特点"><a href="#软链接特点" class="headerlink" title="软链接特点"></a>软链接特点</h4><ul><li>软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式</li><li>软链接可以 跨文件系统，硬链接不可以</li><li>软链接可以对一个不存在的文件名进行链接</li><li>软链接可以对目录进行链接</li></ul><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>ln [参数][源文件或目录][目标文件或目录]<br>为文件<code>test.txt</code>创建一个硬链接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln test.txt <span class="hljs-regexp">/etc/</span><br></code></pre></td></tr></table></figure><p>删除<code>test.txt</code>的硬链接，因为是以副本形式存在的，所以直接用<code>rm</code>命令将其删除即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/etc/</span>test.txt <br></code></pre></td></tr></table></figure><p>为文件<code>test.txt</code>创建一个软链接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln -s test.txt <span class="hljs-regexp">/etc/</span>test2.txt<br></code></pre></td></tr></table></figure><p>删除软链接也一样，直接用<code>rm</code>命令删除软链接的名称即可。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.runoob.com/linux/linux-comm-ln.html">https://www.runoob.com/linux/linux-comm-ln.html</a></li><li><a href="https://www.cnblogs.com/lixuze/p/14248559.html">https://www.cnblogs.com/lixuze/p/14248559.html</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-ed 行编辑器</title>
    <link href="/2021/08/02/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ed%E8%A1%8C%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <url>/2021/08/02/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ed%E8%A1%8C%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><code>ed</code>命令是文本编辑器，用于文本编辑。</p><p><code>ed</code>是 Linux 中功能最简单的文本编辑程序，一次仅能编辑一行而非全屏幕方式的操作。很多命令和<code>vim</code>相似，平时开发中并不常用，但是在编辑大文本时还是会用到。</p><p>学学无妨毕竟这是 Unix 系统三大要件（编辑器，汇编器和 shell）之一。</p><p><code>ed</code>编辑器有两种模式：命令模式和输入模式。命令模式下输入<code>a</code>,<code>i</code>,<code>c</code>,<code>d</code>可以进入对应的编辑模式，接下来可以输入任何想要输入的内容，输入完毕或者要切换命令时，可以输入<code>.</code>退出输入模式。</p><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span>           <span class="hljs-comment">#添加到行</span><br>i           <span class="hljs-comment">#添加到行首</span><br>c           <span class="hljs-comment">#改变行</span><br>d           <span class="hljs-comment">#删除行</span><br></code></pre></td></tr></table></figure><h2 id="Line-Address"><a href="#Line-Address" class="headerlink" title="Line Address"></a>Line Address</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">. <span class="hljs-comment">#buffer 中 当前行</span><br>$ <span class="hljs-comment">#最后一行</span><br>n <span class="hljs-comment">#第 n 行，行的范围是 [0,$]</span><br>- or ^ <span class="hljs-comment">#前一行</span><br>-n or ^n <span class="hljs-comment">#前 n 行</span><br>+ or +n <span class="hljs-comment">#后一行及后n行</span><br>, or % <span class="hljs-comment">#全部行，等同于 1,$</span><br>; <span class="hljs-comment">#当前行到最后一行 .,$</span><br><span class="hljs-regexp">/re/</span> <span class="hljs-comment">#下一个包含正则 re 的行</span><br>?re? <span class="hljs-comment">#上一个包含正则 re 的行</span><br></code></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs applescript">dominic@hanhan:~$ ed                <span class="hljs-comment"># 进入编辑模式</span><br>This <span class="hljs-keyword">is</span> a test <span class="hljs-built_in">text</span>!                <span class="hljs-comment"># 输入文本</span><br>.               <span class="hljs-comment"># 结束输入命令</span><br>This <span class="hljs-keyword">is</span> a test <span class="hljs-built_in">text</span>!                <span class="hljs-comment"># 回显当前行</span><br>n               <span class="hljs-comment"># 显示行号命令</span><br><span class="hljs-number">1</span> This <span class="hljs-keyword">is</span> a test <span class="hljs-built_in">text</span>!        <span class="hljs-comment"># 回显当前行并显示行号</span><br>c               <span class="hljs-comment"># 改变行命令</span><br>This <span class="hljs-keyword">is</span> changed <span class="hljs-built_in">text</span>!               <span class="hljs-comment"># 输入更改后的内容</span><br>.               <span class="hljs-comment"># 结束输入命令</span><br>n               <span class="hljs-comment"># 显示行号命令</span><br><span class="hljs-number">1</span> This <span class="hljs-keyword">is</span> changed <span class="hljs-built_in">text</span>!       <span class="hljs-comment"># 回显当前行并显示行号</span><br>i               <span class="hljs-comment"># 在首行插入命令</span><br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">first</span> line!                 <span class="hljs-comment"># 输入插入内容</span><br>.               <span class="hljs-comment"># 结束输入命令</span><br>+               <span class="hljs-comment"># 后一行命令</span><br>This <span class="hljs-keyword">is</span> changed <span class="hljs-built_in">text</span>!               <span class="hljs-comment"># 回显后一行</span><br>d               <span class="hljs-comment"># 删除当前行 </span><br>.               <span class="hljs-comment"># 回显当前行命令</span><br>This <span class="hljs-keyword">is</span> firt line!                  <span class="hljs-comment"># 回显当前行</span><br>a<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">second</span> line!<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">third</span> line!<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">fourth</span> line!<br>w test.txt      <span class="hljs-comment"># 写入并保存文件</span><br>q               <span class="hljs-comment"># 退出编辑器</span><br><br>dominic@hanhan:~$ cat test.txt      <span class="hljs-comment"># 查看内容</span><br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">first</span> line!s<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">second</span> line!<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">third</span> line!<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">fourth</span> line!<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-wc 统计文件有多少字多少行</title>
    <link href="/2021/07/30/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-wc%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AD%97%E5%A4%9A%E5%B0%91%E8%A1%8C/"/>
    <url>/2021/07/30/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-wc%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AD%97%E5%A4%9A%E5%B0%91%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>想知道自己代码写了多少行，可以一个<code>wc</code>命令搞定。</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">-l：仅列出行；<br>-w：仅列出多少字 (英文单字)；<br>-m：多少字符<br></code></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>统计<code>hello.c</code>文件夹下文件总共多少行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">$ wc -l  hello.c<br>14 hello.c<br></code></pre></td></tr></table></figure><p>统计文件夹下文件的个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ls -l | grep <span class="hljs-string">&quot;^-&quot;</span> | wc -l<br><br></code></pre></td></tr></table></figure><p>统计当前目录下文件的个数（包括子目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ls -lR| grep <span class="hljs-string">&quot;^-&quot;</span> | wc -l<br><br></code></pre></td></tr></table></figure><p>查看目录下文件夹 (目录) 的个数（包括子目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ls -lR | grep <span class="hljs-string">&quot;^d&quot;</span> | wc -l<br></code></pre></td></tr></table></figure><ul><li>过滤<code>ls</code>的输出信息，只保留一般文件，只保留目录是<code>grep &quot;^d&quot;</code>。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更换 Ubuntu 软件更新源</title>
    <link href="/2021/07/30/Linux%E6%9B%B4%E6%8D%A2Ubuntu%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/"/>
    <url>/2021/07/30/Linux%E6%9B%B4%E6%8D%A2Ubuntu%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu 默认是国外的源，软件下载和更新都比较慢。两种方法将下载源换成国内的源。</p><h2 id="用”软件和更新”工具"><a href="#用”软件和更新”工具" class="headerlink" title="用”软件和更新”工具"></a>用”软件和更新”工具</h2><p>从 Ubuntu 菜单中找到<strong>软件和更新</strong>这个应用并打开。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210730112638.png"></p><p>找到<strong>下载自</strong>，选择<strong>其他 - 国内-aliyun</strong>，然后勾选前四个选项。关闭时会弹出对话框，点击<strong>更新</strong>。然后就能愉<strong>快</strong>的下载软件了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210730113029.png"></p><h2 id="修改sourcelist"><a href="#修改sourcelist" class="headerlink" title="修改sourcelist"></a>修改<code>sourcelist</code></h2><h3 id="备份原文件"><a href="#备份原文件" class="headerlink" title="备份原文件"></a>备份原文件</h3><p>这也算是系统文件的一部分，还是保险一点，出错了再改回来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup<br></code></pre></td></tr></table></figure><h3 id="打开并修改"><a href="#打开并修改" class="headerlink" title="打开并修改"></a>打开并修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vi /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p><code>vim</code>用的不习惯的估计会和我一样找全选内容怎么操作。教给你了<br>在命令模式下，就是按一下<code>esc</code>键，然后输入<code>ggvG</code>。具体什么含义看<code>VIM 笔记</code>吧，选择后直接<code>delete</code>删除，再把阿里云源粘贴进去。保存退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#阿里云</span><br>deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get dist-upgrade<br>sudo apt-get upgrade<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-find 查找文件</title>
    <link href="/2021/07/29/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-find%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/"/>
    <url>/2021/07/29/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-find%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">find <span class="hljs-selector-attr">[path]</span> <span class="hljs-selector-attr">[expression]</span><br></code></pre></td></tr></table></figure><p>在<code>path</code>下查找<code>expression</code>表示的文件</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>一般常见就是自己不知道写的某个文件或者文件夹放哪里了，又或者只记住部分文件名。以下几个命令就能帮到你。</p><h3 id="按文件名查找"><a href="#按文件名查找" class="headerlink" title="按文件名查找"></a>按文件名查找</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">find</span>  -name filename(查找结果显示路径)或者 <span class="hljs-builtin-name">find</span> filename(查找结果不显示路径)<br><br><span class="hljs-builtin-name">find</span> hello.cpp          #当前目录下精确查找hello.cpp文件<br><span class="hljs-builtin-name">find</span> hello              #当前目录下精确查找hello文件<br><span class="hljs-builtin-name">find</span> hello*             #当前目录下模糊查找以hello为前缀的文件<br></code></pre></td></tr></table></figure><h3 id="按类型查找"><a href="#按类型查找" class="headerlink" title="按类型查找"></a>按类型查找</h3><p>这就是为查找文件夹用的。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> -<span class="hljs-built_in">type</span> [fdlcb] <span class="hljs-built_in">name</span><br></code></pre></td></tr></table></figure><p><code>[fdlcb]</code>都是类型，<code>d</code>就是目录，文件夹类型。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">find / -<span class="hljs-keyword">type</span> <span class="hljs-type">d </span>-name <span class="hljs-string">&quot;helloworld&quot;</span>   #查找名为helloworld的文件夹<br></code></pre></td></tr></table></figure><h2 id="按文件名查找-1"><a href="#按文件名查找-1" class="headerlink" title="按文件名查找"></a>按文件名查找</h2><p>以下就详细介绍一些参数</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golo"><span class="hljs-keyword">find</span> -name <span class="hljs-string">&quot;hello.cpp&quot;</span>              <span class="hljs-comment"># 搜索文件名，大小写敏感</span><br><span class="hljs-keyword">find</span> -iname <span class="hljs-string">&quot;hello.cpp&quot;</span>             <span class="hljs-comment">#大小写不敏感</span><br></code></pre></td></tr></table></figure><h2 id="按文件大小查找"><a href="#按文件大小查找" class="headerlink" title="按文件大小查找"></a>按文件大小查找</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">find [path] -size <span class="hljs-number">50</span>M<br><br>find / -size <span class="hljs-number">10</span>M                # 查找系统中大小等于<span class="hljs-number">10</span>M的文件<br>find / -size +<span class="hljs-number">50</span>M               # 查找系统中大小大于<span class="hljs-number">50</span>M的文件<br>find  / -size <span class="hljs-number">-30</span>M              # 查找系统中大小小于<span class="hljs-number">30</span>M的文件<br></code></pre></td></tr></table></figure><h2 id="按时间来查找文件"><a href="#按时间来查找文件" class="headerlink" title="按时间来查找文件"></a>按时间来查找文件</h2><p>Linux 会存储下面的时间：</p><ul><li>Access time 上一次文件读或者写的时间</li><li>Modifica time 上一次文件被修改的时间</li><li>Change time 上一次文件 <code>inode meta</code> 信息被修改的时间</li></ul><p>在按照时间查找时，可以使用 <code>-atime</code>， <code>-mtime</code> 或者 <code>-ctime</code>，和之前 <code>size</code>参数一样可以使用 <code>+</code> 或者 <code>-</code>时间范围，下图表示<code>find</code>的时间轴。<code>+</code>表示超过多少天，<code>-</code>表示多少天以内。</p><p>此外，也可以换成<code>-amin</code>， <code>-mmin</code> 或者 <code>-cmin</code>参数，单位是分钟。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210729151915.png"></p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golo"><span class="hljs-keyword">find</span> / -mtime <span class="hljs-number">1</span>          <span class="hljs-comment"># 寻找修改时间超过一天的文件</span><br><span class="hljs-keyword">find</span> / -atime <span class="hljs-number">-1</span>         <span class="hljs-comment"># 寻找在一天时间内被访问的文件</span><br><span class="hljs-keyword">find</span> / -ctime +<span class="hljs-number">3</span>         <span class="hljs-comment"># 寻找 meta 信息被修改的时间超过 3 天的文件</span><br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><p><a href="http://c.biancheng.net/view/779.html">http://c.biancheng.net/view/779.html</a></p></li><li><p><a href="https://einverne.github.io/post/2018/02/find-command.html#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E6%97%B6%E9%97%B4%E8%B6%85%E8%BF%87-1-%E5%A4%A9%E7%9A%84%E6%96%87%E4%BB%B6">https://einverne.github.io/post/2018/02/find-command.html#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E6%97%B6%E9%97%B4%E8%B6%85%E8%BF%87-1-%E5%A4%A9%E7%9A%84%E6%96%87%E4%BB%B6</a></p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git clone 快速下载子模块</title>
    <link href="/2021/07/28/git-clone%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    <url>/2021/07/28/git-clone%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD%E5%AD%90%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>在<code>git clone</code>时候，如果遇到项目里有子模块通常会在下载时加上<code>--recursive</code>参数，一起下载。但是子模块较多，体积较大时大概率都会下载失败。</p><p>好在可以通过一些小技巧，下载国内镜像，进行加速。但是下载项目时，只是主体是国内的镜像，子模块仍然下载很慢。首先解决获取国内镜像的问题。有三个方法：</p><ul><li><p><strong>在码云 Gitee 上搜索下载</strong></p><p>  在码云上搜索同样的项目，然后用码云git 的地址下载。</p></li><li><p><strong>加上<code>.cnpmjs.org</code>后缀</strong></p><p>  在地址后面加上后缀，如<code>git clone https://github.com.cnpmjs.org/riscv/riscv-binutils-gdb.git</code>。</p></li><li><p><strong>使用油猴脚本获取镜像地址</strong></p><p>  如果你有油猴插件可以去<a href="https://greasyfork.org/zh-CN">greasyfork</a>搜索安装<strong>GitHub镜像访问，加速下载</strong>这个脚本，刷新GitHub仓库界面就会多出几个镜像地址，一般下载都会快好几倍。</p><p>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728155417.png"></p></li></ul><p>再来解决子模块下载速度慢的问题，下载项目时，先不加<code>--recursive</code>参数，只下载项目的本题。</p><p>下载完后找到<code>.gitmodules</code>文件，这是一个隐藏文件，需要显示隐藏文件，Linux 下使用快捷键<code>Ctrl+H</code>。用<code>vim</code>打开后可以得到：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728164406.png"></p><p>这个文件里写入了子模块的下载信息，<code>url</code>就是下载地址。我们把所有子模块中的 URL 地址同样加上<code>.cnpmjs.org</code>后缀。或者使用上述三种方式得到的镜像地址。</p><p>然后利用<code>git submodule sync</code>更新子项目对应的<code>url</code></p><p>最后再<code>git submodule update --init --recursive</code>，即可快速下载所有子项目。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 QEMU 上运行 64 位和 32 位 RISC-V-Linux</title>
    <link href="/2021/07/28/QEMU%E4%B8%8A%E8%BF%90%E8%A1%8C64%E4%BD%8D%E5%92%8C32%E4%BD%8DRISC-V-Linux/"/>
    <url>/2021/07/28/QEMU%E4%B8%8A%E8%BF%90%E8%A1%8C64%E4%BD%8D%E5%92%8C32%E4%BD%8DRISC-V-Linux/</url>
    
    <content type="html"><![CDATA[<h2 id="制作交叉工具链-riscv-gnu-toolchain"><a href="#制作交叉工具链-riscv-gnu-toolchain" class="headerlink" title="制作交叉工具链 riscv-gnu-toolchain"></a>制作交叉工具链 riscv-gnu-toolchain</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>这个仓库是我遇到的最难下载的一个仓库了，公司网慢和虚拟机性能差都脱不了干系。估计下载了五小时都不止，刚开始还指望一个命令所有子模块都下载完的，结果愣是等了半天中断了。试了两次后放弃了。如果各位看官能一次完成，那您是福大。</p><p>国内的码云平台有个<a href="https://gitee.com/organizations/mirrors/projects">Gitee 极速下载</a>项目，上面有 GitHub 的一些常用开源项目的镜像，可供加速下载。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># riscv-gnu-toolchain</span><br>https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-gnu-toolchain.git<br></code></pre></td></tr></table></figure><p>下载时问题出现了，如果下载子模块仍然会卡住，如果不加<code>--recursive</code>就只能下载主体内容，子模块都没有。（<strong>以下内容为第一安装时的方法，后续又找到了<a href="">git clone 快速下载子模块</a>的方法</strong>）</p><p>开始下载时不加<code>--recursive</code>参数，只下载<code>riscv-gnu-toolchain</code>的主体内容，然后进入到<code>riscv-gnu-toolchain</code>文件夹下，手动下载子模块的内容。</p><p>当下完<code>riscv-binutils</code>继续下载<code>riscv-gdb</code>时发现这两个项目是同一个项目，只是不同的分支。但是码云上并没有区分，但是我也没找到在码云上的对应分支。只能用油猴脚本了。</p><p>如果你有油猴插件可以去<a href="https://greasyfork.org/zh-CN">greasyfork</a>搜索安装<strong>GitHub 镜像访问，加速下载</strong>这个脚本，刷新 GitHub 仓库界面就会多出几个镜像地址，一般下载都会快好几倍。如果不用油猴插件的可以用我复制好的链接。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728155417.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># riscv-binutils</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-binutils-gdb.git<br><span class="hljs-comment"># riscv-gcc</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-gcc.git<br><span class="hljs-comment"># riscv-dejagnu</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-dejagnu.git<br><span class="hljs-comment"># riscv-glibc</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-glibc.git<br><span class="hljs-comment"># riscv-newlib</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-newlib.git<br><span class="hljs-comment"># riscv-gdb</span><br>git clone --depth=<span class="hljs-number">1</span> https:<span class="hljs-regexp">//</span>hub.fastgit.org<span class="hljs-regexp">/riscv/</span>riscv-binutils-gdb.git<br></code></pre></td></tr></table></figure><h3 id="编译-riscv-gnu-toolchain"><a href="#编译-riscv-gnu-toolchain" class="headerlink" title="编译 riscv-gnu-toolchain"></a>编译 riscv-gnu-toolchain</h3><p>提前安装如下软件：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install autoconf automake autotools-<span class="hljs-built_in">dev</span> curl python3 libmpc-<span class="hljs-built_in">dev</span> libmpfr-<span class="hljs-built_in">dev</span> libgmp-<span class="hljs-built_in">dev</span> gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-<span class="hljs-built_in">dev</span> libexpat-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>不听老人言，吃亏在眼前呀，本以为这是可选项，很多库都安装了，就没有操作这一步，结果就是编译半天结果还错了。如果报<code>make 错误 127</code>，那就老老实实把前置的这些库都装上。</p><p>建立<code>riscv-gnu-toolchain</code>安装目录<code>/opt/riscv64</code>。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">./configure --prefix=<span class="hljs-regexp">/opt/</span>riscv64 <br>sudo make linux -j8<br></code></pre></td></tr></table></figure><h3 id="导出安装路径"><a href="#导出安装路径" class="headerlink" title="导出安装路径"></a>导出安装路径</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:/opt/riscv64/bin&quot;</span><br></code></pre></td></tr></table></figure><p>出现一下信息表示安装成功。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">Using built-in specs.<br>COLLECT_GCC=riscv64-unknown-linux-gnu-gcc<br>COLLECT_LTO_WRAPPER=<span class="hljs-string">/opt/riscv64/libexec/gcc/riscv64-unknown-linux-gnu/10.2.0/lto-wrapper</span><br>Target: riscv64-unknown-linux-gnu<br>Configured with: <span class="hljs-string">/home/dominic/riscv64-linux/riscv-gnu-toolchain/riscv-gcc/configure</span> <span class="hljs-params">--target=riscv64-unknown-linux-gnu</span> <span class="hljs-params">--prefix=/opt/riscv64</span> <span class="hljs-params">--with-sysroot=/opt/riscv64/sysroot</span> <span class="hljs-params">--with-system-zlib</span> <span class="hljs-params">--enable-shared</span> <span class="hljs-params">--enable-tls</span> <span class="hljs-params">--enable-languages=c</span>,c++,fortran <span class="hljs-params">--disable-libmudflap</span> <span class="hljs-params">--disable-libssp</span> <span class="hljs-params">--disable-libquadmath</span> <span class="hljs-params">--disable-libsanitizer</span> <span class="hljs-params">--disable-nls</span> <span class="hljs-params">--disable-bootstrap</span> <span class="hljs-params">--src=</span><span class="hljs-string">.././riscv-gcc</span> <span class="hljs-params">--disable-multilib</span> <span class="hljs-params">--with-abi=lp64d</span> <span class="hljs-params">--with-arch=rv64imafdc</span> <span class="hljs-params">--with-tune=rocket</span> &#x27;CFLAGS_FOR_TARGET=-O2   -mcmodel=medlow&#x27; &#x27;CXXFLAGS_FOR_TARGET=-O2   -mcmodel=medlow&#x27;<br>Thread model: posix<br>Supported LTO compression algorithms: zlib<br>gcc <span class="hljs-keyword">version</span> 10.2.0 <span class="hljs-params">(GCC)</span> <br></code></pre></td></tr></table></figure><h2 id="制作内核"><a href="#制作内核" class="headerlink" title="制作内核"></a>制作内核</h2><h3 id="下载-Linux-内核"><a href="#下载-Linux-内核" class="headerlink" title="下载 Linux 内核"></a>下载 Linux 内核</h3><p>makefile</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-df/du查看磁盘剩余空间</title>
    <link href="/2021/07/28/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-df-du%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4/"/>
    <url>/2021/07/28/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-df-du%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p><code>df</code>全称<code>disk filesystem</code> ，以磁盘分区为单位查看文件系统，可以查看磁盘文件占用空间，磁盘剩余空间等信息。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">df <span class="hljs-selector-attr">[]</span> <span class="hljs-selector-attr">[]</span><br></code></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a      全部文件系统列表</span><br><span class="hljs-deletion">-h      方便阅读方式显示</span><br><span class="hljs-deletion">-H      等于“-h”，但是计算式，1K=1000，而不是 1K=1024</span><br><span class="hljs-deletion">-i      显示 inode 信息</span><br><span class="hljs-deletion">-k      区块为 1024 字节</span><br><span class="hljs-deletion">-l      只显示本地文件系统</span><br><span class="hljs-deletion">-m      区块为 1048576 字节</span><br><span class="hljs-deletion">--no-sync 忽略 sync 命令</span><br><span class="hljs-deletion">-P      输出格式为 POSIX</span><br><span class="hljs-deletion">--sync  在取得磁盘信息前，先执行 sync 命令</span><br><span class="hljs-deletion">-T      文件系统类型</span><br></code></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><code>df -T</code>显示包含文件系统，类型，可用大小，已用大小，挂载点等信息。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">dominic@hanhan:~$ df -T<br>文件系统       类型         1K-块      已用      可用 已用% 挂载点<br>udev           devtmpfs  <span class="hljs-number"> 1985056 </span>       <span class="hljs-number"> 0 </span> <span class="hljs-number"> 1985056 </span>   0% /dev<br>tmpfs          tmpfs      <span class="hljs-number"> 403036 </span>    <span class="hljs-number"> 1304 </span>  <span class="hljs-number"> 401732 </span>   1% /run<br>/dev/sda5      ext4     <span class="hljs-number"> 50824704 </span><span class="hljs-number"> 20826256 </span><span class="hljs-number"> 27386992 </span>  44% /<br>tmpfs          tmpfs     <span class="hljs-number"> 2015172 </span>       <span class="hljs-number"> 0 </span> <span class="hljs-number"> 2015172 </span>   0% /dev/shm<br>tmpfs          tmpfs        <span class="hljs-number"> 5120 </span>       <span class="hljs-number"> 4 </span>    <span class="hljs-number"> 5116 </span>   1% /run/lock<br>tmpfs          tmpfs     <span class="hljs-number"> 2015172 </span>       <span class="hljs-number"> 0 </span> <span class="hljs-number"> 2015172 </span>   0% /sys/fs/cgroup<br>/dev/loop0     squashfs    <span class="hljs-number"> 56832 </span>   <span class="hljs-number"> 56832 </span>       <span class="hljs-number"> 0 </span> 100% /snap/core18/1988<br>/dev/loop1     squashfs    <span class="hljs-number"> 56832 </span>   <span class="hljs-number"> 56832 </span>       <span class="hljs-number"> 0 </span> 100% /snap/core18/2074<br></code></pre></td></tr></table></figure><hr><p><code>du</code>全称<code>disk usage</code>可以查看文件，文件夹占用情况。</p><h2 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">du <span class="hljs-selector-attr">[opt]</span> <span class="hljs-selector-attr">[filename]</span><br></code></pre></td></tr></table></figure><h2 id="可选参数-1"><a href="#可选参数-1" class="headerlink" title="可选参数"></a>可选参数</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">a或-all                    <span class="hljs-comment">#显示目录中个别文件的大小。</span></span><br><span class="ruby"></span>-<span class="ruby">b或-bytes                  <span class="hljs-comment">#显示目录或文件大小时，以byte为单位。</span></span><br><span class="ruby"></span>-<span class="ruby">c或--total                 <span class="hljs-comment">#除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</span></span><br><span class="ruby"></span>-<span class="ruby">D或--dereference-args      <span class="hljs-comment">#显示指定符号连接的源文件大小。</span></span><br><span class="ruby"></span>-<span class="ruby">h或--human-readable        <span class="hljs-comment">#以K，M，G为单位，提高信息的可读性。</span></span><br><span class="ruby"></span>-<span class="ruby">H或--si                    <span class="hljs-comment">#与-h参数相同，但是K，M，G是以1000为换算单位。</span></span><br><span class="ruby"></span>-<span class="ruby">k或--kilobytes             <span class="hljs-comment">#以1024 bytes为单位。</span></span><br><span class="ruby"></span>-<span class="ruby">l或--count-links           <span class="hljs-comment">#重复计算硬件连接的文件。</span></span><br><span class="ruby"></span>-<span class="ruby">L&lt;符号连接&gt;或-</span><br><span class="ruby"></span>-<span class="ruby">dereference&lt;符号连接&gt;          <span class="hljs-comment">#显示选项中所指定符号连接的源文件大小。</span></span><br><span class="ruby"></span>-<span class="ruby">m或--megabytes                 <span class="hljs-comment">#以1MB为单位。</span></span><br><span class="ruby"></span>-<span class="ruby">s或--summarize                 <span class="hljs-comment">#仅显示总计。</span></span><br><span class="ruby"></span>-<span class="ruby">S或--separate-dirs             <span class="hljs-comment">#显示个别目录的大小时，并不含其子目录的大小。</span></span><br><span class="ruby"></span>-<span class="ruby">x或--one-file-xystem           <span class="hljs-comment">#以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</span></span><br><span class="ruby"></span>-<span class="ruby">X&lt;文件&gt;或--exclude-from=&lt;文件&gt;  <span class="hljs-comment">#在&lt;文件&gt;指定目录或文件。</span></span><br><span class="ruby"></span>-<span class="ruby">-exclude=&lt;目录或文件&gt;           <span class="hljs-comment">#略过指定的目录或文件。</span></span><br><span class="ruby"></span>-<span class="ruby">-max-depth=&lt;目录层数&gt;           <span class="hljs-comment">#超过指定层数的目录后，予以忽略。</span></span><br><span class="ruby"></span>-<span class="ruby">-help          <span class="hljs-comment">#显示帮助。</span></span><br><span class="ruby"></span>-<span class="ruby">-version       <span class="hljs-comment">#显示版本信息</span></span><br></code></pre></td></tr></table></figure><h2 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h2><p>查看当前目录使用情况</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">dominic@hanhan:~/learning-linux$ du<br><span class="hljs-number">56</span> .<span class="hljs-regexp">/.git/</span>hooks<br><span class="hljs-number">8</span> .<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>heads<br><span class="hljs-number">8</span> .<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes/origin<br><span class="hljs-number">12</span> .<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes<br><span class="hljs-number">24</span> .<span class="hljs-regexp">/.git/</span>logs/refs<br><span class="hljs-number">32</span> .<span class="hljs-regexp">/.git/</span>logs<br><span class="hljs-number">8</span> .<span class="hljs-regexp">/.git/i</span>nfo<br></code></pre></td></tr></table></figure><p>以易读的方式查看使用情况</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">dominic@hanhan:~/learning-linux$ du -h<br><span class="hljs-number">56</span>K .<span class="hljs-regexp">/.git/</span>hooks<br><span class="hljs-number">8.0</span>K .<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>heads<br><span class="hljs-number">8.0</span>K .<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes/origin<br><span class="hljs-number">12</span>K .<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes<br><span class="hljs-number">24</span>K .<span class="hljs-regexp">/.git/</span>logs/refs<br><span class="hljs-number">32</span>K .<span class="hljs-regexp">/.git/</span>logs<br><span class="hljs-number">8.0</span>K .<span class="hljs-regexp">/.git/i</span>nfo<br></code></pre></td></tr></table></figure><p>只输出当前目录占用总空间，同上<code>-h</code>命令就是以人读的方式（加上了数据单位）</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">dominic<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:~/learning-linux</span><span class="hljs-variable">$ </span>du -hs<br><span class="hljs-number">264</span>K .<br></code></pre></td></tr></table></figure><p>查看当前目录及其指定深度目录的大小</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">不深入子目录，就是当前文件夹所占用大小<br>dominic<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:~/learning-linux</span><span class="hljs-variable">$ </span>du -h --max-depth=0<br><span class="hljs-number">264</span>K .<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">深入一层<br>dominic@hanhan:~/learning-linux$ du -h --max-depth=<span class="hljs-number">2</span><br><span class="hljs-number">56</span>K .<span class="hljs-regexp">/.git/</span>hooks<br><span class="hljs-number">32</span>K .<span class="hljs-regexp">/.git/</span>logs<br><span class="hljs-number">8.0</span>K .<span class="hljs-regexp">/.git/i</span>nfo<br><span class="hljs-number">28</span>K .<span class="hljs-regexp">/.git/</span>objects<br><span class="hljs-number">4.0</span>K .<span class="hljs-regexp">/.git/</span>branches<br><span class="hljs-number">28</span>K .<span class="hljs-regexp">/.git/</span>refs<br><span class="hljs-number">180</span>K ./.git<br><span class="hljs-number">24</span>K .<span class="hljs-regexp">/helloworld/</span>c<br><span class="hljs-number">44</span>K .<span class="hljs-regexp">/helloworld/</span>shell<br><span class="hljs-number">72</span>K ./helloworld<br><span class="hljs-number">264</span>K .<br></code></pre></td></tr></table></figure><p>忽略<code>helloworld</code>这个文件夹</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gradle">dominic@hanhan:~/learning-linux$ du --<span class="hljs-keyword">exclude</span>=helloworld<br><span class="hljs-number">56</span> .<span class="hljs-regexp">/.git/</span>hooks<br><span class="hljs-number">8</span> .<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>heads<br><span class="hljs-number">8</span> .<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes/origin<br><span class="hljs-number">12</span> .<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes<br><span class="hljs-number">24</span> .<span class="hljs-regexp">/.git/</span>logs/refs<br><span class="hljs-number">32</span> .<span class="hljs-regexp">/.git/</span>logs<br><span class="hljs-number">8</span> .<span class="hljs-regexp">/.git/i</span>nfo<br><span class="hljs-number">4</span> .<span class="hljs-regexp">/.git/</span>objects/info<br><span class="hljs-number">20</span> .<span class="hljs-regexp">/.git/</span>objects/pack<br><span class="hljs-number">28</span> .<span class="hljs-regexp">/.git/</span>objects<br><span class="hljs-number">4</span> .<span class="hljs-regexp">/.git/</span>branches<br><span class="hljs-number">8</span> .<span class="hljs-regexp">/.git/</span>refs/heads<br><span class="hljs-number">4</span> .<span class="hljs-regexp">/.git/</span>refs/tags<br><span class="hljs-number">8</span> .<span class="hljs-regexp">/.git/</span>refs<span class="hljs-regexp">/remotes/</span>origin<br><span class="hljs-number">12</span> .<span class="hljs-regexp">/.git/</span>refs/remotes<br><span class="hljs-number">28</span> .<span class="hljs-regexp">/.git/</span>refs<br><span class="hljs-number">180</span> ./.git<br><span class="hljs-number">192</span> .<br></code></pre></td></tr></table></figure><h2 id="Refernece"><a href="#Refernece" class="headerlink" title="Refernece"></a>Refernece</h2><ol><li><a href="https://einverne.github.io/post/2018/03/du-find-out-which-fold-take-space.html">https://einverne.github.io/post/2018/03/du-find-out-which-fold-take-space.html</a></li><li><a href="https://www.runoob.com/linux/linux-comm-du.html">https://www.runoob.com/linux/linux-comm-du.html</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>每天学命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(Ubuntu) 环境下安装 Qt</title>
    <link href="/2021/07/27/Linux-Ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Qt/"/>
    <url>/2021/07/27/Linux-Ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Qt/</url>
    
    <content type="html"><![CDATA[<p>真蠢，之前费那么大劲，只要一句命令就完事了</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> qtcreator<br></code></pre></td></tr></table></figure><p>但是在用命令行构建 project 时可能会报错</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">qmake -<span class="hljs-keyword">project</span><br>could not <span class="hljs-keyword">find</span> a Qt installation of <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>这时候需要</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">sudo apt-<span class="hljs-keyword">get</span> install qt5-<span class="hljs-keyword">default</span> <br></code></pre></td></tr></table></figure><p>好了可以愉快玩耍了。</p><hr><p>瞎折腾</p><h2 id="下载-Qt"><a href="#下载-Qt" class="headerlink" title="下载 Qt"></a>下载 Qt</h2><p>从 Qt5.15.0 起，对于开源用户，Qt 官方不再提供独立安装文件，且不再有 bug 修复版本（比如 Qt5.15.1），如果从官网下载，需要自己编译。虽然想试试编译，但是虚拟机刚开始开的空间太小了，还是另寻他法吧。以后有机会再来编译试试新功能。若读者有兴趣可以从<a href="https://download.qt.io/archive/qt/">官网</a>下载源码并编译。或者参考<a href="https://wiki.qt.io/Building_Qt_5_from_Git#Getting_the_source_code">官方的编译教程</a>，从 GitHub 上下载。</p><p>国内有一些镜像站，提供 qt 镜像下载：<br>清华大学：<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/">https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/</a><br>中国科学技术大学：<a href="http://mirrors.ustc.edu.cn/qtproject/">http://mirrors.ustc.edu.cn/qtproject/</a><br>北京理工大学：<a href="https://mirrors.cnnic.cn/qt/">https://mirrors.cnnic.cn/qt/</a></p><p>以清华大学的镜像为例，找到<code>archive/qt/5.14/5.14.0/qt-opensource-linux-x64-5.14.0.run</code>，点击即可开始下载。</p><blockquote><p>qt 5.15 已经不提供安装包，想要最新版本，只能下 5.14，但是 5.14.2 下载没资源，下不动，如果遇到下不动的情况换一个版本吧</p></blockquote><h2 id="安装-Qt"><a href="#安装-Qt" class="headerlink" title="安装 Qt"></a>安装 Qt</h2><p>下载的<code>.run</code>文件双击是无法安装的，因为它还没有可执行的权限，需要我们赋给它执行权限，打开终端进入安装包的目录。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">chmod +<span class="hljs-meta">x</span> <span class="hljs-meta">filename</span>.run<br></code></pre></td></tr></table></figure><p><code>chmod</code>命令是控制用户对文件的权限修改的命令，<code>x</code>是可执行权限的参数。<br>执行以上命令后就可以直接双击安装了。</p><p>网上一些教程可以跳过登录，我没找到跳过按钮，需要注册一个账号才能继续安装。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728092743.png"></p><p>安装目录一般选择在<code>/opt</code>目录下<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728092813.png"></p><p>安装的附加组件最好都选择，以免后期使用再安装麻烦。Qt Creator 肯定要装的。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728093014.png"></p><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-builtin-name">get</span> install g++<br>apt-<span class="hljs-builtin-name">get</span> install libgl1-mesa-dev<br>apt-<span class="hljs-builtin-name">get</span> install libqt4-dev<br>apt-<span class="hljs-builtin-name">get</span> install build-essential # Build Essential，它是一个元软件包，可让您在Ubuntu中安装和使用c ++工具。<br>sudo apt install qt5-default # 如果要将Qt 5用作默认的Qt Creator版本需要安装，否则会报 qmake: could <span class="hljs-keyword">not</span> <span class="hljs-builtin-name">find</span> a Qt installation of <span class="hljs-string">&#x27;&#x27;</span>的错误<br></code></pre></td></tr></table></figure><h2 id="使用-Qt-Creator-创建第一个程序"><a href="#使用-Qt-Creator-创建第一个程序" class="headerlink" title="使用 Qt Creator 创建第一个程序"></a>使用 Qt Creator 创建第一个程序</h2><h3 id="使用-Qt-Creator-创建"><a href="#使用-Qt-Creator-创建" class="headerlink" title="使用 Qt Creator 创建"></a>使用 Qt Creator 创建</h3><p>首先我们先创建一个不带窗口的 HelloWorld 程序，测试安装是否成功，打开 Qt Creator-文件 - 新建文件或项目，选择 Non-Qt Project-Plain C++ Application。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728102920.png"><br>接下来就设置项目名等，一直下一步。完成后就可以在编辑器看到如下<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728103424.png"></p><p>点击左下角运行按钮就可以得到如下：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728103540.png"></p><p>再创建一个带窗口的 HelloWorld，在选择模板时选择 Application-Qt Widgets Application。一路点下一步就可以完成创建，运行后就可得到一个灰白的 HelloWorld 窗口。</p><h3 id="命令行编译第一个-Qt-程序"><a href="#命令行编译第一个-Qt-程序" class="headerlink" title="命令行编译第一个 Qt 程序"></a>命令行编译第一个 Qt 程序</h3><p>首先创建工作目录<code>HelloWorldQt</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir HelloWorld<br></code></pre></td></tr></table></figure><p>进入项目目录下，新建一个<code>main.cpp</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> HelloWorldQt<br>vim main.cpp<br></code></pre></td></tr></table></figure><p>编辑以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QLabel&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QWidget&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[ ])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    <span class="hljs-function">QLabel <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-string">&quot;&lt;center&gt;Welcome to my first Qt program&lt;/center&gt;&quot;</span>)</span></span>;<br>    hello.<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-string">&quot;My First Qt Program&quot;</span>);<br>    hello.<span class="hljs-built_in">resize</span>(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>);<br>    hello.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>建立 QtProject 文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">qmake -<span class="hljs-keyword">project</span><br></code></pre></td></tr></table></figure><p>用<code>vim</code>打开<code>HelloWorldQt.pro</code>文件，添加以下内容</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">QT +</span>=<span class="hljs-string"> gui widgets</span><br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210730095602.png"><br>运行<code>qmake</code>，使项目 platform-specific，会得到一个<code>Makefile</code>文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">qmake <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HelloWorldQt</span>.</span></span>pro <br></code></pre></td></tr></table></figure><p>使用<code>make</code>命令将<code>Makefile</code>编译为可执行程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜  HelloWorldQt make<br>g++ -c -pipe -O2 -Wall -W -D_REENTRANT -fPIC -DQT_DEPRECATED_WARNINGS / <br>-DQT_NO_DEBUG -DQT_WIDGETS_LIB /<br>-DQT_GUI_LIB -DQT_CORE_LIB -I. / <br>-I. -isystem / <br><span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/x86_64-linux-gnu/</span>qt5 -isystem / <br><span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/x86_64-linux-gnu/</span>qt5<span class="hljs-regexp">/QtWidgets /</span><br>-isystem <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/x86_64-linux-gnu/</span>qt5<span class="hljs-regexp">/QtGui /</span><br>-isystem <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/x86_64-linux-gnu/</span>qt5<span class="hljs-regexp">/QtCore -I. /</span><br>-I<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>qt5<span class="hljs-regexp">/mkspecs/</span>linux-g++ -o main.o main.cpp<br>g++ -Wl,-O1 -o HelloWorldQt main.o  /<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libQt5Widgets.so /<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libQt5Gui.so / <br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libQt5Core.so /<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libGL.so -lpthread <br></code></pre></td></tr></table></figure><p>如果一切顺利，执行可以得到如下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./HelloWorldQt</span> <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728112155.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU 文档</title>
    <link href="/2021/07/27/QEMU%E6%96%87%E6%A1%A3/"/>
    <url>/2021/07/27/QEMU%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="调用文档"><a href="#调用文档" class="headerlink" title="调用文档"></a>调用文档</h1><p><code>qemu-system-x86_64 [options] [disk_image] </code><br><code>disk_image</code>是 IDE 硬盘 0 的原始硬盘映像。某些目标不需要磁盘映像。</p><h2 id="标准参数-Standard-options"><a href="#标准参数-Standard-options" class="headerlink" title="标准参数 Standard options"></a>标准参数 Standard options</h2><h3 id="h"><a href="#h" class="headerlink" title="-h"></a><code>-h</code></h3><ul><li><p>功能<br>显示帮助信息并退出</p></li><li><p>子参数</p></li><li><p>调用实例</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-riscv<span class="hljs-number">32</span> -h<br></code></pre></td></tr></table></figure></li></ul><h3 id="version"><a href="#version" class="headerlink" title="-version"></a><code>-version</code></h3><ul><li><p>功能<br>显示 qemu 版本信息并退出</p></li><li><p>子参数</p></li><li><p>调用实例</p>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qemu-<span class="hljs-keyword">system</span>-riscv32 -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="machine-type-name-prop-value"><a href="#machine-type-name-prop-value" class="headerlink" title="-machine [type=]name[,prop=value[,...]]"></a><code>-machine [type=]name[,prop=value[,...]]</code></h3><ul><li><p>功能<br>通过名称选择模拟器。使用 <code>-machine help</code> 可以查看可用的模拟器。<br>对于支持跨版本实时迁移兼容性的架构，每个版本都会引入一个新的版本化模拟器类型。例如，2.8.0 版本为 <code>x86_64/i686</code> 架构引入了<code>“pc-i440fx-2.8”</code>和<code>“pc-q35-2.8”</code>。</p></li><li><p>子参数<br>为了允许用户从 QEMU 2.8.0 版实时迁移到 QEMU 2.9.0 版，2.9.0 版也必须支持<code>“pc-i440fx-2.8”</code>和<code>“pc-q35-2.8”</code>机器。为了允许用户在升级时实时迁移 VMs 跳过多个中间版本，QEMU 的新版本将支持多个以前版本的机器类型。<br>支持的机器属性有：</p><ul><li><code>accel=accels1[:accels2[:...]]</code><br>This is used to enable an accelerator. Depending on the target architecture, kvm, xen, hax, hvf, nvmm, whpx or tcg can be available. By default, tcg is used. If there is more than one accelerator specified, the next one is used if the previous one fails to initialize.</li><li><code>vmport=on|off|auto</code><br>Enables emulation of VMWare IO port, for vmmouse etc. auto says to select the value based on accel. For accel=xen the default is off otherwise the default is on.</li><li><code>dump-guest-core=on|off</code><br>Include guest memory in a core dump. The default is on.</li><li><code>mem-merge=on|off</code><br>Enables or disables memory merge support. This feature, when supported by the host, de-duplicates identical memory pages among VMs instances (enabled by default).</li><li><code>aes-key-wrap=on|off</code><br>Enables or disables AES key wrapping support on s390-ccw hosts. This feature controls whether AES wrapping keys will be created to allow execution of AES cryptographic functions. The default is on.</li><li><code>dea-key-wrap=on|off</code><br>Enables or disables DEA key wrapping support on s390-ccw hosts. This feature controls whether DEA wrapping keys will be created to allow execution of DEA cryptographic functions. The default is on.</li><li><code>nvdimm=on|off</code><br>Enables or disables NVDIMM support. The default is off.</li><li><code>memory-encryption=</code><br>Memory encryption object to use. The default is none.</li><li><code>hmat=on|off</code><br>Enables or disables ACPI Heterogeneous Memory Attribute Table (HMAT) support. The default is off.</li><li><code>memory-backend=&#39;id&#39;</code><br>An alternative to legacy -mem-path and mem-prealloc options. Allows to use a memory backend as main RAM.<br>For example: <code>:: -object memory-backend-file,id=pc.ram,size=512M,mem-path=/hugetlbfs,prealloc=on,share=on -machine memory-backend=pc.ram -m 512M</code><br>Migration compatibility note: a) as backend id one shall use value of ‘default-ram-id’, advertised by machine type (available via query-machines QMP command), if migration to/from old QEMU (&lt;5.0) is expected. b) for machine types 4.0 and older, user shall use x-use-canonical-path-for-ramblock-id=off backend option if migration to/from old QEMU (&lt;5.0) is expected. For example: :: -object memory-backend-ram,id=pc.ram,size=512M,x-use-canonical-path-for-ramblock-id=off -machine memory-backend=pc.ram -m 512M</li></ul></li><li><p>调用实例：</p>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qemu-<span class="hljs-keyword">system</span>-riscv32 -machine virt,mem-<span class="hljs-built_in">merge</span>=<span class="hljs-keyword">on</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="cpu-model"><a href="#cpu-model" class="headerlink" title="-cpu model"></a><code>-cpu model</code></h3><ul><li>功能<br>选择 CPU 型号（<code>-cpu help</code>显示帮助列表和附加功能的选项）</li></ul><blockquote><p>默认情况会给客户机提供 qemu64 或 qemu32 的基本 CPU 模型。这样做可以对 CPU 特性提供一些高级的过滤功能，让客户机在同一组硬件平台上的动态迁移会更加平滑和安全。<br>在客户机中查看 CPU 信息 (cat /proc/cpuinfo)，model name 就是当前 CPU 模型的名称。</p></blockquote><ul><li><p>调用实例</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-riscv<span class="hljs-number">32</span> -cpu rv<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="accel-name-prop-value"><a href="#accel-name-prop-value" class="headerlink" title="accel name[,prop=value[,...]]"></a><code>accel name[,prop=value[,...]]</code></h3><ul><li>功能<br>This is used to enable an accelerator. Depending on the target architecture, kvm, xen, hax, hvf, nvmm, whpx or tcg can be available. By default, tcg is used. If there is more than one accelerator specified, the next one is used if the previous one fails to initialize.</li><li>子参数<ul><li><code>igd-passthru=on|off</code><br>When Xen is in use, this option controls whether Intel integrated graphics devices can be passed through to the guest (default=off)</li><li><code>kernel-irqchip=on|off|split</code><br>Controls KVM in-kernel irqchip support. The default is full acceleration of the interrupt controllers. On x86, split irqchip reduces the kernel attack surface, at a performance cost for non-MSI interrupts. Disabling the in-kernel irqchip completely is not recommended except for debugging purposes.</li><li><code>kvm-shadow-mem=size</code><br>Defines the size of the KVM shadow MMU.</li><li><code>split-wx=on|off</code><br>Controls the use of split w^x mapping for the TCG code generation buffer. Some operating systems require this to be enabled, and in such a case this will default on. On other operating systems, this will default off, but one may enable this for testing or debugging.</li><li><code>tb-size=n</code><br>Controls the size (in MiB) of the TCG translation block cache.</li><li><code>thread=single|multi</code><br>Controls number of TCG threads. When the TCG is multi-threaded there will be one thread per vCPU therefore taking advantage of additional host cores. The default is to enable multi-threading where both the back-end and front-ends support it and no incompatible TCG features have been enabled (e.g. icount/replay).</li><li><code>dirty-ring-size=n</code><br>When the KVM accelerator is used, it controls the size of the per-vCPU dirty page ring buffer (number of entries for each vCPU). It should be a value that is power of two, and it should be 1024 or bigger (but still less than the maximum value that the kernel supports). 4096 could be a good initial value if you have no idea which is the best. Set this value to 0 to disable the feature. By default, this feature is disabled (dirty-ring-size=0). When enabled, KVM will instead record dirty pages in a bitmap.</li></ul></li></ul><h3 id="smp-cpus-n-maxcpus-maxcpus-sockets-sockets-dies-dies-cores-cores-threads-threads"><a href="#smp-cpus-n-maxcpus-maxcpus-sockets-sockets-dies-dies-cores-cores-threads-threads" class="headerlink" title="smp [[cpus=]n][,maxcpus=maxcpus][,sockets=sockets][,dies=dies][,cores=cores][,threads=threads]"></a><code>smp [[cpus=]n][,maxcpus=maxcpus][,sockets=sockets][,dies=dies][,cores=cores][,threads=threads]</code></h3><ul><li><p>功能<br>配置客户机的 SMP（Symmetric Multi-Processing），对称多处理机</p></li><li><p>子参数</p><ul><li><code>[cpus=]n</code><br>设置客户机中使用逻辑的 CPU 数量（默认值是 1）。</li><li><code>[,maxcpus=cpus]</code><br>设置客户机最大可能被使用的 CPU 数量（可以用热插拔 hot-plug 添加 CPU，不能超过 maxcpus 上限）。</li><li><code>[,cores=cores]</code><br>设置每个 CPU socket 上的 core 数量（默认值是 1）。</li><li><code>[,threads=threads]</code><br>设置每个 CPU core 上的线程数（默认值是 1）。</li><li><code>[,sockets=sockets]</code><br>设置客户机中总的 CPU socket 数量。</li></ul></li><li><p>调用实例</p></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>  -smp <span class="hljs-number">1</span>,sockets=<span class="hljs-number">1</span>,cores=<span class="hljs-number">2</span>,threads=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="numa-node-mem-size-cpus-firstcpu-lastcpu-nodeid-node-initiator-initiator"><a href="#numa-node-mem-size-cpus-firstcpu-lastcpu-nodeid-node-initiator-initiator" class="headerlink" title="-numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]"></a><code>-numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]</code></h3><h3 id="numa-node-memdev-id-cpus-firstcpu-lastcpu-nodeid-node-initiator-initiator"><a href="#numa-node-memdev-id-cpus-firstcpu-lastcpu-nodeid-node-initiator-initiator" class="headerlink" title="-numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]"></a><code>-numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]</code></h3><h3 id="numa-dist-src-source-dst-destination-val-distance"><a href="#numa-dist-src-source-dst-destination-val-distance" class="headerlink" title="-numa dist,src=source,dst=destination,val=distance"></a><code>-numa dist,src=source,dst=destination,val=distance</code></h3><h3 id="numa-cpu-node-id-node-socket-id-x-core-id-y-thread-id-z"><a href="#numa-cpu-node-id-node-socket-id-x-core-id-y-thread-id-z" class="headerlink" title="-numa cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]"></a><code>-numa cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]</code></h3><h3 id="numa-hmat-lb-initiator-node-target-node-hierarchy-hierarchy-data-type-tpye-latency-lat-bandwidth-bw"><a href="#numa-hmat-lb-initiator-node-target-node-hierarchy-hierarchy-data-type-tpye-latency-lat-bandwidth-bw" class="headerlink" title="-numa hmat-lb,initiator=node,target=node,hierarchy=hierarchy,data-type=tpye[,latency=lat][,bandwidth=bw]"></a><code>-numa hmat-lb,initiator=node,target=node,hierarchy=hierarchy,data-type=tpye[,latency=lat][,bandwidth=bw]</code></h3><h3 id="numa-hmat-cache-node-id-node-size-size-level-level-associativity-str-policy-str-line-size"><a href="#numa-hmat-cache-node-id-node-size-size-level-level-associativity-str-policy-str-line-size" class="headerlink" title="-numa hmat-cache,node-id=node,size=size,level=level[,associativity=str][,policy=str][,line=size]"></a><code>-numa hmat-cache,node-id=node,size=size,level=level[,associativity=str][,policy=str][,line=size]</code></h3><ul><li>功能</li><li>子参数</li><li>调用实例</li></ul><h3 id="add-fd-fd-fd-set-set-opaque-opaque"><a href="#add-fd-fd-fd-set-set-opaque-opaque" class="headerlink" title="-add-fd fd=fd,set=set[,opaque=opaque]"></a><code>-add-fd fd=fd,set=set[,opaque=opaque]</code></h3><ul><li>功能</li><li>子参数</li><li>调用实例</li></ul><h3 id="set-group-id-arg-value"><a href="#set-group-id-arg-value" class="headerlink" title="-set group.id.arg=value"></a><code>-set group.id.arg=value</code></h3><ul><li>功能</li><li>子参数</li><li>调用实例</li></ul><h3 id="global-driver-prop-value"><a href="#global-driver-prop-value" class="headerlink" title="-global driver.prop=value"></a><code>-global driver.prop=value</code></h3><ul><li>功能</li><li>子参数</li><li>调用实例</li></ul><h3 id="global-driver-driver-property-property-value-value"><a href="#global-driver-driver-property-property-value-value" class="headerlink" title="-global driver=driver,property=property,value=value"></a><code>-global driver=driver,property=property,value=value</code></h3><ul><li>功能</li><li>子参数</li><li>调用实例</li></ul><h3 id="boot-order-drives-once-drives-menu-on-off-splash-sp-name-splash-time-sp-time-reboot-timeout-rb-timeout-strict-on-off"><a href="#boot-order-drives-once-drives-menu-on-off-splash-sp-name-splash-time-sp-time-reboot-timeout-rb-timeout-strict-on-off" class="headerlink" title="-boot [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]"></a><code>-boot [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]</code></h3><ul><li>功能<br>设置客户机启动顺序</li></ul><blockquote><p>在 qemu 模拟的 x86 平台中，用”a”、”b”分别表示第一和第二软驱，用”c”表示第一个硬盘，用”d”表示 CD-ROM 光驱，用”n”表示从网络启动。<br>默认从硬盘启动。</p></blockquote><ul><li><p>子参数</p><ul><li><code>[order=drives]</code><br>设置启动顺序。</li><li><code>[,once=drives]</code><br>只设置下一次启动的顺序，再重启后无效。</li><li><code>[,menu=on|off]</code><br>只要固件/BIOS 支持，就可以启用交互式引导菜单/提示。默认为非交互式引导。</li><li><code>[,splash=sp_name]</code><br>如果固件/BIOS 支持选项 splash=sp_name 和 menu=on，则可以将启动画面传递给 bios，使用户能够将其显示为徽标。目前 Seabios for X86 系统支持它。限制：启动文件可以是 24 BPP 格式（真彩色）的 jpeg 文件或 BMP 文件。分辨率应该是 SVGA 模式支持的，推荐 320x240、640x480、800x640。</li><li><code>[,splash-time=sp_time]</code></li><li><code>[,reboot-timeout=rb_timeout]</code><br>引导失败时，客户机将暂停 <code>rb_timeout</code> 毫秒，然后重新启动。如果 <code>rb_timeout</code> 为 ‘-1’，客户机不会重启，qemu 默认将 ‘-1’ 传递给 bios。目前 Seabios for X86 系统支持它。</li><li><code>[,strict=on|off]</code><br>只要固件/BIOS 支持，就通过严格启动。这仅在 bootindex 选项更改引导优先级时有效。默认为非严格引导。</li></ul></li><li><p>调用实例</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 尝试先从网络启动，然后从硬盘启动</span><br><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> -boot order=nc<br><span class="hljs-comment"># 先从光驱启动，重启后切换回默认顺序</span><br><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> -boot once=d<br><span class="hljs-comment"># 5 秒钟的启动画面。</span><br><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> -boot menu=<span class="hljs-literal">on</span>,splash=/root/boot.bmp,splash-time=<span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="m-size-megs-slots-n-maxmem-size"><a href="#m-size-megs-slots-n-maxmem-size" class="headerlink" title="-m [size=]megs[,slots=n,maxmem=size]"></a><code>-m [size=]megs[,slots=n,maxmem=size]</code></h3><ul><li><p>功能<br>将客户机内存设置为 <code>megs</code> M字节。默认值为 <code>128 MiB</code>。或者，也可以使用“M”或“G”的后缀。齐。</p></li><li><p>子参数</p><ul><li><code>[size=]megs</code><br>将客户机内存设置为 <code>megs</code> M字节</li><li><code>[,slots=n,maxmem=size]</code><br>可用于设置可热插拔内存插槽的数量和最大内存数量。<code>maxmem</code> 必须与页面大小对</li></ul></li><li><p>调用实例<br>以下命令行将客户机启动 RAM 大小设置为 1GB，创建 3 个插槽以热插拔额外内存，并将客户机可以达到的最大内存设置为 4GB：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> -m <span class="hljs-number">1</span>G,slots=<span class="hljs-number">3</span>,maxmem=<span class="hljs-number">4</span>G<br></code></pre></td></tr></table></figure><p>  如果未指定 <code>slot</code> 和 <code>maxmem</code>，则不会启用内存热插拔，并且客户机内存永远不会增加。</p></li></ul><h3 id="mem-path-path"><a href="#mem-path-path" class="headerlink" title="-mem-path path"></a><code>-mem-path path</code></h3><ul><li>功能<br>使用huge page。对于内存访问密集型的应用，使用<code>huge page</code>是可以比较明显地提高客户机性能。 使用<code>huge page</code>的内存不能被换出（swap out），也不能使用<code>ballooning</code>方式自动增长。</li><li>子参数</li><li>调用实例</li></ul><h3 id="mem-prealloc"><a href="#mem-prealloc" class="headerlink" title="-mem-prealloc"></a><code>-mem-prealloc</code></h3><ul><li>功能<br>使宿主机在客户机启动时就全部分配好客户机的内存</li><li>子参数</li><li>调用实例</li></ul><h3 id="k-language"><a href="#k-language" class="headerlink" title="-k language"></a><code>-k language</code></h3><ul><li><p>功能<br>设置键盘布局语言，默认为<code>en-us</code></p></li><li><p>子参数<br>可用布局：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ar</span>  de-ch  es  <span class="hljs-keyword">fo</span>     fr-<span class="hljs-keyword">ca</span>  hu  ja  <span class="hljs-keyword">mk</span>     <span class="hljs-keyword">no</span>  <span class="hljs-keyword">pt</span>-<span class="hljs-keyword">br</span>  <span class="hljs-keyword">sv</span><br>da  <span class="hljs-keyword">en</span>-gb  et  fr     fr-ch  <span class="hljs-keyword">is</span>  <span class="hljs-keyword">lt</span>  nl     pl  <span class="hljs-keyword">ru</span>     <span class="hljs-keyword">th</span><br>de  <span class="hljs-keyword">en</span>-us  fi  fr-<span class="hljs-keyword">be</span>  hr     it  <span class="hljs-keyword">lv</span>  nl-<span class="hljs-keyword">be</span>  <span class="hljs-keyword">pt</span>  <span class="hljs-keyword">sl</span>     <span class="hljs-keyword">tr</span><br></code></pre></td></tr></table></figure></li><li><p>调用实例</p></li></ul><h2 id="块设备参数-Block-device-options"><a href="#块设备参数-Block-device-options" class="headerlink" title="块设备参数 Block device options"></a>块设备参数 Block device options</h2><h3 id="fda-file"><a href="#fda-file" class="headerlink" title="fda file"></a><code>fda file</code></h3><ul><li>功能<br>为客户机指定软盘设备，指定客户机的第一个软盘设备，在客户机中显示为<code>/dev/fd0</code></li><li>子参数</li><li>调用实例</li></ul><h3 id="fdb-file"><a href="#fdb-file" class="headerlink" title="fdb file"></a><code>fdb file</code></h3><ul><li>功能<br>为客户机指定软盘设备，指定客户机的第一个软盘设备，在客户机中显示为<code>/dev/fd1</code></li><li>子参数</li><li>调用实例</li></ul><h3 id="hda-file"><a href="#hda-file" class="headerlink" title="hda file"></a><code>hda file</code></h3><h3 id="hdb-file"><a href="#hdb-file" class="headerlink" title="hdb file"></a><code>hdb file</code></h3><h3 id="hdc-file"><a href="#hdc-file" class="headerlink" title="hdc file"></a><code>hdc file</code></h3><h3 id="hdd-file"><a href="#hdd-file" class="headerlink" title="hdd file"></a><code>hdd file</code></h3><ul><li>功能<br>为客户机指定块存储设备，指定客户机种的第一个 IDE 设备</li><li>子参数<br>若客户机使用<code>PIIX_IDE</code>驱动，显示为<code>/dev/hda</code>设备；<br>若客户机使用<code>ata_piix</code>驱动，显示为<code>/dev/sda</code>设备。<br>若没有使用<code>-hdx</code>的参数，则默认使用<code>-hda</code>参数；<br>可以将宿主机的一块硬盘作为<code>-hda</code>的参数使用；<br>若文件名包含逗号，应使用两个连续的逗号进行转义。</li><li>调用实例</li></ul><h3 id="cdrom-file"><a href="#cdrom-file" class="headerlink" title="-cdrom file"></a><code>-cdrom file</code></h3><ul><li>功能<br>为客户机指定光盘 CD-ROM。可以将宿主机的光驱<code>/dev/cdrom</code>设备作为<code>-cdrom</code>参数使用。<code>-cdrom</code>参数不能与<code>-hdc</code>参数同时使用，因为<code>-cdrom</code>就是客户机里的第三个 IDE 设备</li><li>子参数</li><li>调用实例</li></ul><h3 id="blockdev-option-option-option"><a href="#blockdev-option-option-option" class="headerlink" title="-blockdev option[,option[,option[,...]]]"></a><code>-blockdev option[,option[,option[,...]]]</code></h3><ul><li><p>功能</p></li><li><p>子参数</p></li><li><p>调用实例</p></li></ul><h3 id="drive-option-option-option"><a href="#drive-option-option-option" class="headerlink" title="-drive option[,option[,option[,...]]]"></a><code>-drive option[,option[,option[,...]]]</code></h3><ul><li>功能<br>定义一个存储驱动器</li><li>子参数<ul><li><code>[file=file]</code><br>加载<code>file</code>镜像文件到客户机的驱动器中。</li><li><code>[,if=type]</code><br>指定驱动器使用的接口类型：可用的类类型有：<code>ide</code>、<code>scsi</code>、<code>virtio</code>、<code>sd</code>、<code>floopy</code>、<code>pflash</code>等。</li><li><code>[,bus=n]</code><br>设置驱动器在客户机中的总线编号。</li><li><code>[,unit=m]</code><br>设置驱动器在客户机中的单元编号。</li><li><code>[,media=d]</code><br>设置驱动器中媒介的类型，值为 disk 或 cdrom。</li><li><code>[,index=i]</code><br>设置在通一种接口的驱动器中的索引编号。</li><li><code>[,snapshot=on|off]</code><br>当值为 on 时，qemu 不会将磁盘数据的更改写回到镜像文件中，而是写到临时文件中，可以在 qemu moinitor 中使用 commit 命令强制将磁盘数据保存回镜像文件中。</li><li><code>[,cache=writethrough|writeback|none|directsync|unsafe]</code><br>设置宿主机对块设备数据访问的 cache 模式。，<br><code>writethrough</code>（直写模式）：调用 write 写入数据的同时将数据写入磁盘缓存和后端块设备中。<br><code>writeback</code>（回写模式）：调用 write 写入数据时只将数据写入到磁盘缓存中，当数据被换出缓存时才写入到后端存储中。优点写入数据块，缺点系统掉电数据无法恢复。</li><li><code>[,aio=threads|native]</code><br>选择异步 IO 的方式</li><li><code>threads</code><br>为 aio 参数的默认值，让一个线程池去处理异步 IO；</li><li><code>native</code><br>只适用于 cache=none 的情况，使用的是 Linux 原生的 AIO。</li><li><code>[,format=f]</code><br>指定使用的磁盘格式，默认是 QEMU 自动检测磁盘格式的。</li><li><code>[,serial=s]</code><br>指定分配给设备的序列号。</li><li><code>[,addr=A]</code><br>分配给驱动器控制器的 PCI 地址，只在使用 virtio 接口时适用。</li><li><code>[,id=name]</code><br>设置驱动器的 ID，可以在 QEMU monitor 中用 info block 看到。<br><code>[,readonly=on|off]</code><br>设置驱动器是否只读。</li></ul></li><li>调用实例</li></ul><h2 id="USB-参数-USB-convenience-options"><a href="#USB-参数-USB-convenience-options" class="headerlink" title="USB 参数 USB convenience options"></a>USB 参数 USB convenience options</h2><h2 id="显示参数-Display-options"><a href="#显示参数-Display-options" class="headerlink" title="显示参数 Display options"></a>显示参数 Display options</h2><h2 id="仅限-i386-架构的参数-i386-target-only"><a href="#仅限-i386-架构的参数-i386-target-only" class="headerlink" title="仅限 i386 架构的参数 i386 target only"></a>仅限 i386 架构的参数 i386 target only</h2><h2 id="网络参数-Network-options"><a href="#网络参数-Network-options" class="headerlink" title="网络参数 Network options"></a>网络参数 Network options</h2><h2 id="字符设备参数-Character-device-options"><a href="#字符设备参数-Character-device-options" class="headerlink" title="字符设备参数 Character device options"></a>字符设备参数 Character device options</h2><h2 id="TPM-设备-TPM-device-options"><a href="#TPM-设备-TPM-device-options" class="headerlink" title="TPM 设备 TPM device options"></a>TPM 设备 TPM device options</h2><h2 id="指定启动指引-Linux-Multiboot-boot-specific"><a href="#指定启动指引-Linux-Multiboot-boot-specific" class="headerlink" title="指定启动指引 Linux/Multiboot boot specific"></a>指定启动指引 Linux/Multiboot boot specific</h2><p>当使用该调用参数时，你可以使用给定的 Linux 或者多重引导内核，而不需要安装内核到一个光盘中。这样可以更方便地测试不同内核。</p><ul><li><p><code>-kernel bzImage</code></p><ul><li>功能<br>用 bzImage 作为内核镜像，也可以使用其他启动格式。</li></ul></li><li><p><code>-append cmdline</code></p><ul><li>功能<br>用<code>cmd</code>命令行，作为内核的命令行</li></ul></li><li><p><code>-initrd file</code></p><ul><li>功能<br>用文件作为初始化 ram</li></ul></li><li><p><code>-initrd &quot;file1 arg=foo,file2&quot;</code></p><ul><li>功能<br>此语法仅适用于多重引导<br>使用 <code>file1</code> 和 <code>file2</code> 作为模块并将 <code>arg=foo</code> 作为参数传递给第一个模块</li></ul></li><li><p><code>-dtb file</code></p><ul><li>功能<br>将文件用作设备树二进制 (dtb) 映像并在启动时将其传递给内核</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 踩坑记录</title>
    <link href="/2021/07/23/git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/07/23/git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="创建仓库时没有加入-gitignore-文件，上传了不需要的文件，后添加了-gitignore-文件如何同步远程与本地的文件（自动删除不需要的文件）"><a href="#创建仓库时没有加入-gitignore-文件，上传了不需要的文件，后添加了-gitignore-文件如何同步远程与本地的文件（自动删除不需要的文件）" class="headerlink" title="创建仓库时没有加入 gitignore 文件，上传了不需要的文件，后添加了 gitignore 文件如何同步远程与本地的文件（自动删除不需要的文件）"></a>创建仓库时没有加入 gitignore 文件，上传了不需要的文件，后添加了 gitignore 文件如何同步远程与本地的文件（自动删除不需要的文件）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 注意有个点“.”</span><br>取消版本控制<br>git rm -r --cached .<br>重新添加<br>git add -A<br>重新提交<br>git commit -m &quot;update .gitignore&quot;<br></code></pre></td></tr></table></figure><h2 id="Git-rm-和-rm-–cached-区别"><a href="#Git-rm-和-rm-–cached-区别" class="headerlink" title="Git rm 和 rm –cached 区别"></a>Git rm 和 rm –cached 区别</h2><p><code>rm</code> ：当需要删除暂存区或分支上的文件，同时工作区不需要这个文件</p><p><code>rm --cached</code>：当需要删除暂存区或分支上的文件，同时工作区需要这个文件，但是不需要被版本控制。就是本地需要保留，但是远程不保留</p><h2 id="推送空文件夹到远程仓库"><a href="#推送空文件夹到远程仓库" class="headerlink" title="推送空文件夹到远程仓库"></a>推送空文件夹到远程仓库</h2><p>在需要推送的空文件下创建”.gitkeep”文件<br>在”.gitignore”文件中编写规则<br><code>!.gitkeep</code></p><h2 id="克隆指定分支代码"><a href="#克隆指定分支代码" class="headerlink" title="克隆指定分支代码"></a>克隆指定分支代码</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span>  <span class="hljs-title">-b</span> <span class="hljs-keyword">master</span> <span class="hljs-title">https</span>://github.com/Dunky-Z/Dunky-Z.github.io.git<br></code></pre></td></tr></table></figure><p><code>master</code>就是分支名</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU 初识</title>
    <link href="/2021/07/23/QEMU%E5%88%9D%E8%AF%86/"/>
    <url>/2021/07/23/QEMU%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>QEMU 是一款开源的模拟器及虚拟机监管器 (Virtual Machine Monitor, VMM)。QEMU 主要提供两种功能给用户使用。一是作为用户态模拟器，利用动态代码翻译机制来执行不同于主机架构的代码。二是作为虚拟机监管器，模拟全系统，利用其他 VMM(Xen, KVM, etc) 来使用硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="使用包管理安装"><a href="#使用包管理安装" class="headerlink" title="使用包管理安装"></a>使用包管理安装</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install qemu<br></code></pre></td></tr></table></figure><h3 id="使用源码安装"><a href="#使用源码安装" class="headerlink" title="使用源码安装"></a>使用源码安装</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> wget https://download.qemu.org/qemu-<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-rc<span class="hljs-number">3</span>.tar.xz<br><span class="hljs-attribute">tar</span> xvJf qemu-<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-rc<span class="hljs-number">3</span>.tar.xz<br><span class="hljs-attribute">cd</span> qemu-<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-rc<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="安装相关库"><a href="#安装相关库" class="headerlink" title="安装相关库"></a>安装相关库</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">apt-get <span class="hljs-keyword">install </span>libglib2.<span class="hljs-number">0</span>-dev<br>apt-get <span class="hljs-keyword">install </span>ninja-<span class="hljs-keyword">build</span><br><span class="hljs-keyword"></span>apt <span class="hljs-keyword">install </span>g++<br>apt <span class="hljs-keyword">install </span>libpixman<span class="hljs-number">-1</span>-dev<br>apt <span class="hljs-keyword">install </span>libsdl2-dev -y<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>通过<code>./configure --help</code> 的查看编译时的选项，<code>--target-list</code>选项为可选的模拟器，默认全选。<br><code>--target-list</code> 中的 <code>xxx-soft</code> 和 <code>xxx-linux-user</code> 分别指系统模拟器和应用程序模拟器，生成的二进制文件名字为<code>qemu-system-xxx</code>和 <code>qemu-xxx</code><br>本文使用如下配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">./configure <span class="hljs-attribute">--prefix</span>=XXX --enable-<span class="hljs-builtin-name">debug</span> <span class="hljs-attribute">--target-list</span>=riscv32-softmmu,riscv32-linux-user,riscv64-linux-user,riscv64-softmmu --enable-kvm<br><span class="hljs-comment"># --prefix 选项设置qemu的安装位置绝对路径，之后若要卸载删除qemu只要删除该文件夹即可，--enable-kvm开启kvm</span><br><span class="hljs-comment"># config完，可以在指定的qemu安装文件夹下面找到config-host.mak文件，</span><br><span class="hljs-comment"># 该文件记录着qemu配置的选项，可以和自己设置的进行对比，确保配置和自己已知</span><br></code></pre></td></tr></table></figure><p>接着进行编译</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">make</span> -j<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>直接<code>make</code>会很慢，第一次编译时默认安装说有模拟器，编译了三四个小时。加上<code>-j8</code>可以进行多线程编译</p><h2 id="创建与使用"><a href="#创建与使用" class="headerlink" title="创建与使用"></a>创建与使用</h2><h3 id="创建虚拟镜像"><a href="#创建虚拟镜像" class="headerlink" title="创建虚拟镜像"></a>创建虚拟镜像</h3><p>使用虚拟镜像来模拟虚拟机的硬盘，在启动虚拟机之前需要创建一个镜像文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># qemu-img create -f qcow2 qmtest.img 10G</span><br>Formatting <span class="hljs-string">&#x27;qmtest.img&#x27;</span>, fmt=qcow2 size=<span class="hljs-number">10737418240</span> encryption=off cluster_size=<span class="hljs-number">65536</span> lazy_refcounts=off <br>root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># ls</span><br>qmtest.img<br></code></pre></td></tr></table></figure><p><code>-f</code>选项用于指定镜像的格式，<code>qcow2</code>格式是 QEMU 最常用的镜像格式，采用写时复制技术来优化性能。<code>qmtest.img</code>是镜像文件的名字，<code>10G</code>是镜像文件大小。</p><p>镜像文件创建完成后，可使用<code>qemu-system-x86</code>来启动<code>x86</code>架构的虚拟机：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> qmtest.img<br></code></pre></td></tr></table></figure><p>qmtest.img 中还未安装操作系统，所以会提示“No bootable device”的错误。</p><h3 id="准备操作系统镜像"><a href="#准备操作系统镜像" class="headerlink" title="准备操作系统镜像"></a>准备操作系统镜像</h3><p>下载需要的 Linux 发行版镜像文件，<a href="https://launchpad.net/ubuntu/+cdmirrors">https://launchpad.net/ubuntu/+cdmirrors</a>，找到想要下载的镜像，这里以交通大学的镜像为例<br>右击链接复制地址：<a href="https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso">https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso</a></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># wget https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso</span><br></code></pre></td></tr></table></figure><h3 id="检查-KVM-是否可用"><a href="#检查-KVM-是否可用" class="headerlink" title="检查 KVM 是否可用"></a>检查 KVM 是否可用</h3><p>QEMU 使用 KVM 来提升虚拟机性能，如果不启用 KVM 会导致性能损失。要使用 KVM，首先要检查硬件是否有虚拟化支持：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># grep -E &#x27;vmx|svm&#x27; /proc/cpuinfo</span><br></code></pre></td></tr></table></figure><p>如果有输出则表示硬件有虚拟化支持。其次要检查 kvm 模块是否已经加载：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># lsmod | grep kvm</span><br>kvm_intel             <span class="hljs-number">142999</span>  0 <br>kvm                   <span class="hljs-number">444314</span>  <span class="hljs-number">1</span> kvm_intel<br></code></pre></td></tr></table></figure><p>如果<code>kvm_intel/kvm_amd</code>、<code>kvm</code>模块被显示出来，则<code>kvm</code>模块已经加载。最后要确保 qemu 在编译的时候使能了<code>KVM</code>，即在执行<code>configure</code>脚本的时候加入了<code>–enable-kvm</code>选项。</p><h3 id="启动虚拟机安装操作系统"><a href="#启动虚拟机安装操作系统" class="headerlink" title="启动虚拟机安装操作系统"></a>启动虚拟机安装操作系统</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># qemu-system-x86_64 -m 2048 -enable-kvm qmtest.img -cdrom ./Fedora-Live-Desktop-x86_64-20-1.iso</span><br></code></pre></td></tr></table></figure><p><code>-m</code>指定虚拟机内存大小，默认单位是 MB，<code>-enable-kvm</code>使用 KVM 进行加速，<code>-cdrom</code>添加 fedora 的安装镜像。可在弹出的窗口中操作虚拟机，安装操作系统，安装完成后重起虚拟机便会从硬盘 (qmtest.img) 启动。之后再启动虚拟机只需要执行：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment">#  qemu-system-x86_64 -m 2048 -enable-kvm qmtest.img</span><br></code></pre></td></tr></table></figure><h2 id="退出-qemu"><a href="#退出-qemu" class="headerlink" title="退出 qemu"></a>退出 qemu</h2><p>在运行 qemu 后，关闭图形界面但是终端仍然是处于 qemu 环境中，可以直接关闭终端退出。如果不想关闭终端，可以另外打开一个终端 kill 进程</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">killall</span> qemu-system-riscv<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><p>如果记不清全称，可以输入大概名称回车后会列出相关的进程</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是驱动，驱动的作用又是什么？</title>
    <link href="/2021/07/21/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A9%B1%E5%8A%A8%EF%BC%8C%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>/2021/07/21/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A9%B1%E5%8A%A8%EF%BC%8C%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>任何一个计算机系统的运行都是系统中软硬件协作的结果，没有硬件的软件是空中楼阁，而没有软件的硬件则只是一堆废铁。–<a href="https://blog.csdn.net/yunfenglw/article/details/39337343">天朗 - 星空</a></p></blockquote><p>硬件是底层基础，所有软件代码的运行平台，相对固定不易改变，而软件是具体的应用，它灵活多变，可以应对用户的不同需求。</p><p>为尽可能快速地完成设计，应用软件工程师不想也不必关心硬件，而硬件工程师也难有足够的闲暇和能力来顾忌软件。譬如，应用软件工程师在调用套接字发送和接收数据包的时候，不必关心网卡上的寄存器、存储空间、I/O 端口、片选以及其他任何硬件层面的操作调度；在使用<code>printf()</code>函数输出信息的时候，他不用知道底层究竟是怎样把相应的信息输出到屏幕或者串口的具体硬件过程，需要的只是出现相应的显示效果。</p><p>也就是说，应用软件工程师需要看到一个没有硬件的纯粹的软件世界，硬件必须被透明地呈现给他们。谁来实现硬件对应用软件工程师的隐形？这个艰巨的任务就落在了驱动工程师的头上。</p><p>对设备驱动最通俗的解释就是“驱使硬件设备行动” 。设备驱动与底层硬件直接打交道，按照硬件设备的具体工作方式读写设备寄存器，完成设备的轮询、中断处理、DMA 通信，进行物理内存向虚拟内存的映射，最终使通信设备能够收发数据，使显示设备能够显示文字和画面，使存储设备能够记录文件和数据。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 搭建 GitHub 博客如何添加 README 文件</title>
    <link href="/2021/07/21/Hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0README%E6%96%87%E4%BB%B6/"/>
    <url>/2021/07/21/Hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0README%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>刚开始搭建的时候并没有为仓库添加 Readme 文件，但是后期添加也不能直接在仓库里直接添加，因为每次部署都会被自动删除。<br>添加方法：</p><ul><li>在博客根目录的<code>source</code>文件夹下新建<code>README.md</code>文件</li><li>在根目录的<code>_config.yml</code>文件中搜索<code>skip_render</code>，并做如下更改</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">skip_render:</span> <span class="hljs-string">README.md</span><br></code></pre></td></tr></table></figure><p>因为在每次<code>hexo g</code>时候，README 文件都会被自动渲染为 HTML 文件，所以在配置文件中告诉渲染器跳过这个文件不要渲染它。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>HEXO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU 学习记录</title>
    <link href="/2021/07/20/QEMU%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/07/20/QEMU%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="QEMU-学习记录"><a href="#QEMU-学习记录" class="headerlink" title="QEMU 学习记录"></a>QEMU 学习记录</h1><h2 id="什么是-KVM？"><a href="#什么是-KVM？" class="headerlink" title="什么是 KVM？"></a>什么是 KVM？</h2><p>基于内核的虚拟机 <code>Kernel-based Virtual Machine（KVM）</code>是一种内建于 Linux 中的开源虚拟化技术。具体而言，<code>KVM</code> 可帮助用户将 Linux 转变为虚拟机监控程序，使主机计算机能够运行多个隔离的虚拟环境，即虚拟客户机或虚拟机（VM）。</p><h2 id="什么是-QEMU？"><a href="#什么是-QEMU？" class="headerlink" title="什么是 QEMU？"></a>什么是 QEMU？</h2><p>Qemu 是一个完整的可以单独运行的软件，它可以用来模拟不同架构的机器，非常灵活和可移植。它主要通过一个特殊的’重编译器’将为特定处理器编写二进制代码转换为另一种。</p><h2 id="KVM-与-QEMU-的关系"><a href="#KVM-与-QEMU-的关系" class="headerlink" title="KVM 与 QEMU 的关系"></a>KVM 与 QEMU 的关系</h2><p>KVM 是 Linux 的一个模块。可以用<code>modprobe</code>去加载 KVM 模块。加载了模块后，才能进一步通过其他工具创建虚拟机。但仅有 KVM 模块是 远远不够的，因为用户无法直接控制内核模块去作事情：还必须有一个用户空间的工具才行。这个用户空间的工具，开发者选择了已经成型的开源虚拟化软件 QEMU。KVM 使用了 QEMU 的一部分，并稍加改造，就成了可控制 KVM 的用户空间工具了。所以你会看到，官方提供的 KVM 下载有两 大部分三个文件，分别是 KVM 模块、QEMU 工具以及二者的合集。也就是说，你可以只升级 KVM 模块，也可以只升级 QEMU 工具。</p><h2 id="QEMU-用户模式与系统模式"><a href="#QEMU-用户模式与系统模式" class="headerlink" title="QEMU 用户模式与系统模式"></a>QEMU 用户模式与系统模式</h2><p>QEMU 属于应用层的仿真程序，它支持两种操作模式：<strong>用户模式</strong>模拟和<strong>系统模式</strong>模拟。</p><ul><li><strong>用户模式仿真</strong> 利用动态代码翻译机制，可以在当前 CPU 上执行被编译为支持其他 CPU 的程序，如可以在 x86 机器上执行一个 ARM 二进制可执行程序。（执行主机 CPU 指令的动态翻译并相应地转换 Linux 系统调用）。</li><li><strong>系统模式仿真</strong> 利用其它 VMM(Xen, KVM) 来使用硬件提供的虚拟化支持，创建接近于主机性能的全功能虚拟机，包括处理器和配套的外围设备（磁盘，以太网等）。</li></ul><h3 id="用户模式"><a href="#用户模式" class="headerlink" title="用户模式"></a>用户模式</h3><p>支持的 CPU：x86 (32 and 64 bit), PowerPC (32 and 64 bit), ARM, MIPS (32 bit only), Sparc (32 and 64 bit), Alpha, ColdFire(m68k), CRISv32 和 MicroBlaze<br>下列操作系统支持 QEMU 的用户模式模拟：</p><ul><li>Linux (referred as qemu-linux-user)</li><li>BSD (referred as qemu-bsd-user)</li></ul><p>调用（<a href="https://qemu.readthedocs.io/en/latest/user/main.html">具体参数含义</a>）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">qemu-i386 <span class="hljs-selector-attr">[-h]</span> <span class="hljs-selector-attr">[-d]</span> <span class="hljs-selector-attr">[-L path]</span> <span class="hljs-selector-attr">[-s size]</span> <span class="hljs-selector-attr">[-cpu model]</span> <span class="hljs-selector-attr">[-g port]</span> <span class="hljs-selector-attr">[-B offset]</span> <span class="hljs-selector-attr">[-R size]</span> program <span class="hljs-selector-attr">[arguments...]</span><br></code></pre></td></tr></table></figure><p>用户模式模拟环境下运行速度要比系统模式模拟环境下快，但并不是完美模拟，比如程序读取<code>/proc/cpuinfo</code>内容时，由主机内核返回，因此返回的信息是描述主机 CPU 的，而不是模拟的 CPU。</p><h3 id="系统模式"><a href="#系统模式" class="headerlink" title="系统模式"></a>系统模式</h3><p>首先创建虚拟镜像，模拟硬盘空间：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># qemu-img create -f qcow2 qmtest.img 10G</span><br>Formatting <span class="hljs-string">&#x27;qmtest.img&#x27;</span>, fmt=qcow2 size=<span class="hljs-number">10737418240</span> encryption=off cluster_size=<span class="hljs-number">65536</span> lazy_refcounts=off <br>root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># ls</span><br>qmtest.img<br></code></pre></td></tr></table></figure><p><code>-f</code>选项用于指定镜像的格式，<code>qcow2</code>格式是 QEMU 最常用的镜像格式，采用写时复制技术来优化性能。<code>qmtest.img</code>是镜像文件的名字，<code>10G</code>是镜像文件大小。</p><p>镜像文件创建完成后，可使用<code>qemu-system-x86</code>来启动<code>x86</code>架构的虚拟机：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> qmtest.img<br></code></pre></td></tr></table></figure><p>qmtest.img 中还未安装操作系统，所以会提示“No bootable device”的错误。</p><p>其次，准备操作系统镜像<br>下载需要的 Linux 发行版镜像文件，<a href="https://launchpad.net/ubuntu/+cdmirrors">https://launchpad.net/ubuntu/+cdmirrors</a>，找到想要下载的镜像，这里以交通大学的镜像为例<br>右击链接复制地址：<a href="https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso">https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso</a></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># wget https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso</span><br></code></pre></td></tr></table></figure><p>最后，启动虚拟机安装操作系统</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># qemu-system-x86_64 -m 2048 -enable-kvm qmtest.img -cdrom ./Fedora-Live-Desktop-x86_64-20-1.iso</span><br></code></pre></td></tr></table></figure><p><code>-m</code>指定虚拟机内存大小，默认单位是 MB，<code>-enable-kvm</code>使用 KVM 进行加速，<code>-cdrom</code>添加 fedora 的安装镜像。</p><p>该模式下，要比用户模式模拟慢得多，因为模拟了目标内核，以及设备输入/输出、中断等。</p><h2 id="QEMU-工作原理"><a href="#QEMU-工作原理" class="headerlink" title="QEMU 工作原理"></a>QEMU 工作原理</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721140349.png"><br>单纯使用 qemu，采用的是完全虚拟化的模式。qemu 向 Guest OS 模拟 CPU，也模拟其他的硬件，GuestOS 认为自己和硬件直接打交道，其实是同 qemu 模拟出来的硬件打交道，qemu 会将这些指令转译给真正的硬件。由于所有的指令都要从 qemu 里面过一手，因而性能就会比较差。</p><p>完全虚拟化是非常慢的，所以要使用硬件辅助虚拟化技术 <code>Intel-VT</code>，<code>AMD-V</code>，所以需要 CPU 硬件开启这个标志位，一般在 BIOS 里面设置。当确认开始了标志位之后，通过<code>KVM</code>，GuestOS 的 CPU 指令不用经过 Qemu 转译，直接运行，大大提高了速度。所以，<code>KVM</code> 在内核里面需要有一个模块，来设置当前 CPU 是 Guest OS 在用，还是 Host OS 在用。</p><p>可以通过如下命令查看内核模块中是否有 KVM</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lsmod <span class="hljs-string">| grep kvm</span><br></code></pre></td></tr></table></figure><p>KVM 内核模块通过 <code>/dev/kvm</code> 暴露接口，用户态程序可以通过 <code>ioctl</code>来访问这个接口。Qemu 将 KVM 整合进来，将有关 CPU 指令的部分交由内核模块来做，就是 <code>qemu-kvm (qemu-system-XXX)</code>。</p><p>qemu 和 kvm 整合之后，CPU 的性能问题解决了。另外 Qemu 还会模拟其他的硬件，如网络和硬盘。同样，全虚拟化的方式也会影响这些设备的性能。</p><p>于是，qemu 采取半虚拟化的方式，让 Guest OS 加载特殊的驱动来做这件事情。</p><p>例如，网络需要加载 <code>virtio_net</code>，存储需要加载 <code>virtio_blk</code>，Guest 需要安装这些半虚拟化驱动，GuestOS 知道自己是虚拟机，所以数据会直接发送给半虚拟化设备，经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。</p><blockquote><p>Q : 系统模式和用户模式的区别？<br>系统模式 是 qemu 虚拟出一套完整的硬件环境，包含 CPU，内存，网卡，硬盘，对于虚拟机上运行的 OS 看到的和硬件和真实的是一样的。<br>用户模式是直接将可执行的文件进行指令翻译，只虚拟出 CPU。<br>假设有 KVM：host 是 x86，QEMU 虚拟出 x86 的系统模式 运行 Windows 系统。QEMU 会将 Windows 指令直接交给  host CPU 直接运行（这个功能是由 KVM 实现的，相当于直接调用 host CPU），性能损失小。内存，硬盘，网络等外设是由 qemu 虚拟出来的。<br>假设无 KVM：host 是 x86，QEMU 虚拟出 x86 的系统模式运行 Windows 系统。QEMU 会将 Windows 指令翻译成中间码，中间码再转成   host CPU 指令（这个功能是由 qemu TCG 实现的），性能损失大。内存，硬盘，网洛等外设是由 qemu 虚拟出来的。<br>假设有 KVM：host 是 x86，QEMU 虚拟出 RISC-V 的系统模式 运行 Linux 系统。QEMU 会将 Linux 指令翻译成中间码，中间码再转成 host CPU 指令（这个功能是由 qemu TCG 实现的），性能损失大。内存，硬盘，网洛等外设是由 qemu 虚拟出来的。<br>KVM 需要在虚拟机与宿主机架构相同时才生效。<br>此外，用户模式下调用 IO 硬件会报错。qemu 系统模式下会模拟出所有设备，但是模拟的 IO 设备效率低，所以后来有了半虚拟化。</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZH-Unix 是什么，为什么重要？</title>
    <link href="/2021/07/20/ZH-Unix%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%9F/"/>
    <url>/2021/07/20/ZH-Unix%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Unix-是什么，为什么重要？"><a href="#Unix-是什么，为什么重要？" class="headerlink" title="Unix 是什么，为什么重要？"></a>Unix 是什么，为什么重要？</h1><blockquote><p>Author：CHRIS HOFFMAN<br>译：<a href="https://www.howtogeek.com/182649/htg-explains-what-is-unix/">What Is Unix, and Why Does It Matter?</a></p></blockquote><p>大多数操作系统都可以分为两大类。除了微软基于 Windows NT 的操作系统之外，几乎所有其他系统的祖宗都是 Unix。</p><p>Linux、Mac OS X、Android、iOS、Chrome OS、PlayStation 4 上使用的 Orbis 操作系统，无论路由器上运行的是什么固件——所有这些操作系统通常都被称为“类 Unix”操作系统。</p><h2 id="Unix-的设计延续至今"><a href="#Unix-的设计延续至今" class="headerlink" title="Unix 的设计延续至今"></a>Unix 的设计延续至今</h2><p>19 世纪中后期 Unix 在贝尔实验室中被开发出来。最初版的 Unix 有许多重要的设计特性至今仍然在使用。</p><p>“Unix 哲学”之一就是，创建小型、模块化的程序，一个程序只做一件事并把它做好。如果你经常使用 Linux 终端，那么你应该对此很熟悉——系统提供了许多实用程序，这些程序可以通过管道和其他功能以不同方式组合以执行更复杂的任务。甚至图形程序也可能在后台调用更简单的实用程序来完成复杂的工作。这也使得创建 shell 脚本变得容易，将简单的工具串在一起来完成复杂的事情。</p><p>Unix 有一个程序之间通信用的单一文件系统。这就是为什么在 Linux 上“一切都是文件” ——包括硬件设备和提供系统信息或其他数据的特殊文件。这也是为什么只有 Windows 有驱动器号（C、D、E 盘）的原因，它是从 DOS 继承的——在其他操作系统上，系统上的每个文件都是单个目录层次结构的一部分。</p><h2 id="追寻-Unix-的后代"><a href="#追寻-Unix-的后代" class="headerlink" title="追寻 Unix 的后代"></a>追寻 Unix 的后代</h2><p>Unix 及其后代的历史错综复杂，简化起见，我们大致将 Unix 的后代分为两类。</p><p>一类 Unix 后代是在学术界发展起来的。第一个是 BSD（BerkeleySoftwareDistribution），一个开源、类 Unix 操作系统。BSD 通过 FreeBSD、NetBSD 和 OpenBSD 延续至今。NeXTStep 也是基于最初的 BSD 开发的，Apple 的 Mac OS X 是基于 NeXTStep 开发出来的，而 iOS 则基于 Mac OS X。还有一些操作系统，包括 PlayStation 4 上使用的 Orbis OS，都是从 BSD 操作系统衍生而来的。</p><p>Richard Stallman 的 GNU 项目也是为了应对 AT&amp;T 日益严格的 Unix 软件许可条款而启动的。MINIX 是一个为教育目的而创建的类 Unix 操作系统，Linux 的灵感来自于 MINIX。我们今天所知道的 Linux 实际上是 GNU/Linux，因为它由 Linux 内核和许多 GNU 实用程序组成。GNU/Linux 并非直接继承自 BSD，但它继承了 Unix 的设计并植根于学术界。当今的许多操作系统，包括 Android、ChromeOS、SteamOS 以及大量设备的嵌入式操作系统，都基于 Linux。</p><p>另一类就是商业 Unix 操作系统。AT&amp;T UNIX、SCO UnixWare、Sun Microsystems Solaris、HP-UX、IBM AIX、SGI IRIX——许多大公司想要创建他们自己的 Unix 版本。这些在今天并不常见，但其中一些仍然存在。</p><h2 id="DOS-和-Windows-NT-的崛起"><a href="#DOS-和-Windows-NT-的崛起" class="headerlink" title="DOS 和 Windows NT 的崛起"></a>DOS 和 Windows NT 的崛起</h2><p>许多人期望 Unix 成为行业标准操作系统，但 DOS 系统和“IBM PC 兼容”的计算机最终流行起来。Microsoft 的 DOS 成为其中最成功的 DOS 系统。DOS 系统完全不同于 Unix，这就是为什么 Windows 使用反斜杠作为文件路径，而其他一切都使用正斜杠。这个决定是在 DOS 系统早期做出的，后来的 Windows 版本继承了它，就像 BSD、Linux、Mac OS X 和其他类 Unix 操作系统继承了许多 Unix 的设计一样。</p><p>Windows 3.1、Windows 95、Windows 98 和 Windows ME 都基于底层的 DOS。当时，微软正在开发一种更现代、更稳定的操作系统，他们将其命名为 Windows NT——即“Windows  New Technology”。Windows NT 最终以 Windows XP 的形式出现在普通用户的计算机中，但在此之前，它以 Windows 2000 和 Windows NT 的形式供公司使用。</p><p>今天，微软的所有操作系统都基于 Windows NT 内核。Windows 7、Windows 8、Windows RT、Windows Phone 8、Windows Server 和 Xbox One 的操作系统都使用 Windows NT 内核。与大多数其他操作系统不同，Windows NT 并不是作为类 Unix 操作系统开发的。</p><p>当然，微软并不是完全重新开始。为了保持与 DOS 和旧的 Windows 软件的兼容性，Windows NT 继承了许多 DOS 约定，如驱动器号、文件路径的反斜杠和命令行的正斜杠。</p><blockquote><p>“在绝大多数地方，用的都是/（slash），包括 Mac/Linux，也包括 URL。你唯一需要记住的是，Microsoft 这个怪鸡在自己的操作系统里面偏要用\（backslash），使得自己与众不同。<br>在 Windows 中，正斜杠/表示除法，用来进行整除运算；反斜杠\用来表示目录。<br>在 Unix 系统中，/表示目录；\表示跳脱字符将特殊字符变成一般字符<br>Windows由于使用斜杠/作为DOS命令提示符的参数标志了，为了不混淆，所以采用反斜杠\作为路径分隔符。所以目前windows系统上的文件浏览器都是用反斜杠\作为路径分隔符。</p></blockquote><h2 id="为什么重要？"><a href="#为什么重要？" class="headerlink" title="为什么重要？"></a>为什么重要？</h2><p>你是否曾经看过 Mac OS X 终端或文件系统，并注意到它与 Linux 的相似之处，以及它们与 Windows 的不同之处？嗯，这就是为什么——Mac OSX 和 Linux 都是类 Unix 操作系统。</p><p>了解这段历史有助于您了解什么是“类 Unix”操作系统，以及为什么这么多操作系统看起来彼此如此相似而 Windows 似乎如此不同。这解释了为什么 Linux 极客会觉得 Mac OS X 上的终端如此熟悉，而 Windows 上的命令提示符和 PowerShell 与其他命令行环境如此不同。</p><p>这只是一个简短的历史，它将帮助您了解我们如何到达今天的位置，而不会陷入细节中。如果您想了解更多信息，可以找到有关 Unix 历史的整本书。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Translation</tag>
      
      <tag>Unix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 实时更新预览</title>
    <link href="/2021/07/20/Hexo%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E9%A2%84%E8%A7%88/"/>
    <url>/2021/07/20/Hexo%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E9%A2%84%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>在项目目录下安装 <code>hexo-browsersync</code> 插件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-<span class="hljs-keyword">browsersync </span>--save<br></code></pre></td></tr></table></figure><p><code>hexo s</code>启动服务后，每次保存 Markdown 文件都会实时更新页面。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>HEXO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 和 GitHub 搭建博客以及更换电脑同步博客</title>
    <link href="/2021/07/20/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/07/20/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>只要有<code>source</code>文件夹下所有源文件就可以重新部署，按照正常的搭建 Hexo 环境开始搭建，搭建好以后将<code>source</code>文件夹替换即可，需要应用主题就下载主题然后替换。</p><p>注意：</p><ul><li>主题更换需要更改<code>_config_yml</code>文件</li><li><code>_config_yml</code>文件中的部署配置，<code>branch:master</code>就是每次<code>hexo d</code>操作推送的分支。而在命令行每次<code>git push</code>推送的分支是设置的默认分支<code>hexo</code></li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> https:<span class="hljs-comment">//github.com/Dunky-Z/Dunky-Z.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/0b1fccce74e0">利用 Hexo 在多台电脑上提交和更新 GitHub pages 博客</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>HEXO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld</title>
    <link href="/2020/08/23/HelloWorld/"/>
    <url>/2020/08/23/HelloWorld/</url>
    
    <content type="html"><![CDATA[<p>这是博客的第一篇文章</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
