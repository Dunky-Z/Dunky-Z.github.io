<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DEBUG原理</title>
    <link href="/2022/08/14/DEBUG%E5%8E%9F%E7%90%86/"/>
    <url>/2022/08/14/DEBUG%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>了解调试原理时看到了一个质量比较高的视频，<a href="https://www.bilibili.com/video/BV1iN411Z7jk?spm_id_from=333.999.0.0&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">【蛋饼嵌入式】一起探究调试原理</a>。UP通俗，形象地讲解了DEBUG的一些原理，值得反复观看，但是视频不如文字查阅效率高，遂记录了以下文稿内容。</p><h2 id="什么是JTAG"><a href="#什么是JTAG" class="headerlink" title="什么是JTAG"></a>什么是JTAG</h2><p>1985年，几家半导体厂商为了解决板级测试的问题，成立了Joint Test Action Group（JTAG）联合测试行动小组，他们希望将测试点和测试电路集成在芯片内部引脚处。同时，留出一个统一协议的接口，大家都能通过这个接口来访问芯片的输入与输出状态。这样就省去了板级测试是的物理接触，同时还能进行逻辑性调试。后来IEEE组织，将这个方案制定成了标准IEEE 1149.1，这就是现在我们常听到的JTAG调试。</p><h2 id="边界扫描技术"><a href="#边界扫描技术" class="headerlink" title="边界扫描技术"></a>边界扫描技术</h2><p>实现JTAG调试最重要的一个技术就是边界扫描技术，核心思想是<strong>给芯片的每一个输入输出引脚，添加一个移位寄存器单元，也称为边界扫描单元</strong>（Boundary Scan Cell， BSC）。通过它一边可以实现对芯片输出数据的截取，另一边可以完成对输入数据的替代。正常运行状态下，这些寄存器又是透明般的存在。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208141648874.gif"></p><p>这些位于引脚边界的移位寄存器，还可以串在一起，形成一条边界扫描链，以串行的方式从外部更新扫描单元上的数据，以及对外输出边界扫描单元捕获的数据。如果板上有多个这样的芯片，他们还能以菊花链的形式串联在一起，这样就大大方便了测试的过程。 </p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208141654770.gif"></p><p>要实现对内部移位寄存器单元或者说对整个扫描链的访问和操作，便依赖于JTAG调试协议和相应的物理接口。JTAG标准接口包括以下几个部分：</p><ul><li>TDI(Test Data In)</li><li>TDO(Test Data Out)</li><li>TCLK(Test Clock)</li><li>TMS(Test Mode Select)</li><li>TRST(Test Reset)：可选，用于复位</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208141655524.png"></p><p>调试逻辑的实现，是通过芯片内部的TAP（Test Access Port）来完成的。模式状态信号TMS配合测试时钟信号TCLK，以一定的时序进入到TAP控制器后，由TAP控制器内部的状态机转化为相应的控制动作。从而完成数据的移位，引脚状态的捕获和更新。</p><p>设备ID寄存器构成的扫描链，板卡一连上调试器，通过对这条扫描链的访问，就能够识别到被调试芯片的信号。存放调试机制相关配置的数据寄存器，所构成的扫描链，后面断点和单步调试时就会用到。以及移位的BYPASS寄存器，当调试链路上有多个芯片连接时，来减少总调试链路的长度。</p><p>以上都属于数据寄存器构成扫描链，因为想要在他们之间进行切换，需要引入另外的指令寄存器，以及对应的扫描链，这样调试主机将不同的调试命令写到指令寄存器中，就可以选通需要调试的数据链路。数据与指令寄存器两种链路的切换，就通过TAP控制器完成。</p><blockquote><p>补充：<br>如果芯片支持JTAG调试，那么芯片上就必须有上述的四个接口，TDI，TDO，TCLK，TMS。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208141725205.png"><br>芯片外有个Adapter与之Pin to Pin连接，负责协议转换，把USB的JTAG控制信息按JTAG协议转换输出，满足协议定义的电气特性。<br>Adapter与Host连接，Host可以是我们的PC，也可以是另一个嵌入式调试器。<br>Host上通常需要运行一些软件，如OpenOCD，负责把GDB的高级别命令转换成JTAG命令，并通过特定Adapter的要求进行打包，调用OS提供的USB/ETH/PCI驱动发送出去。<br>GDB与OpenOCD通过一些远程协议，如TCP/IP，进行通信。这样就能够调试Chip。</p></blockquote><h2 id="断点是如何实现的？"><a href="#断点是如何实现的？" class="headerlink" title="断点是如何实现的？"></a>断点是如何实现的？</h2><p>通过以上JTAG调试接口，我们已经能够测试引脚的输入输出了，同时也获得了观察和改变芯片内部数据的机会，那么接下来我们如何进行调试呢？比如打个断点？</p><p>断点作为一种干预性调试，根据调试行为的不同，分为监控模式和中止模式。</p><ul><li>监控模式（软件断点）：会触发异常，交由相应的软件程序来处理，处理器仍然处于运行状态。</li><li>中止模式（硬件断点），使处理器进入非正常运行的调试状态。</li></ul><p>以ARM架构来说，最初工程师想到的办法是插入一条指令集中没有定义的无效指令，来<strong>替换掉希望打断指令处的源指令</strong>。这样内核运行到这条指令时，就会进入到无效指令的服务程序，在这个异常的服务程序中，我们再去做想要的调试操作，操作完成后，还原当时被替换的指令。并继续执行。</p><p>后来ARMv5开始引入专门用于调试的<code>BKPT</code>指令，类似与X86指令集的<code>INT3</code>指令，但不管是不是专用指令，他们都属于软件中断。这意味着我想要实时地添加这种断点，就要求能够随时地更改程序，插入断点指令，而一般只有程序运行在RAM上，才方便这样操作。那如果直接从FLASH上取址运行的程序，因为FLASH先擦后写的物理特性，是无法通过随意插入指令来实现断点的。更不要说从只读存储器上运行的程序，比如说固化在BIOS中上电自检POST程序，面对这种情况，需要的就是硬件断点。</p><p>硬件断点顾名思义，需要额外的硬件逻辑支持，主要起的作用就是<strong>暂存和比较</strong>，我们把这种实现特定逻辑的组合电路，称为<strong>宏单元</strong>（Macro Cell）。</p><p>还记得我们前面说过JTAG协议，支持自定义扩展扫描链吗？硬件断点宏单元的控制和比较两种数据寄存器，就可以作为两条拓展扫描链，加入到JTAG调试框架中。</p><p>你在调试软件中按下一个按钮，对应的那行代码地址，就会通过上述扫描链，被记录到断点宏单元相应的寄存器中，当然，调试器能够知道某行代码的地址，是依赖于编译时生成的ELF文件中的符号表信息。而当程序正常运行取址时，如果宏单元的寄存器，发现了总线上出现了记录过的地址，比较器就会发出调试状态信号，CPU接收到这个信号后暂停运行，进入调试模式或者异常。</p><p>因为每打一个断点，都需要宏单元相应的寄存器来保存地址信息。而寄存器数量是有限的，所以调试软件一旦和芯片建立起了连接，就会通过上述的另外一条控制寄存器获得该硬件断点宏单元所支持的最大断点数，这样你在调试过程中如果断点打多了，调试器就会报错。</p><h2 id="为什么调试器能够烧录程序呢？"><a href="#为什么调试器能够烧录程序呢？" class="headerlink" title="为什么调试器能够烧录程序呢？"></a>为什么调试器能够烧录程序呢？</h2><p>正常情况下，CPU内核通过内部的系统总线，从FLASH或者RAM中获取运行的指令，交换数据，并在一定的驱动程序下，实现对FLASH的擦除和写入操作。为了把指令和数据直接给CPU内核，我们还需要定义一条扫描链，这条扫描链直接在系统总线上开了一个口子，通过上位机的调试信号，把相关的操作指令直接传到总线上，供CPU内核取用。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208141752418.gif"></p><p>那么整个调试器的下载过程是这样的：</p><ul><li>第一，通过调试器使得CPU进入调试模式；</li><li>第二，通过总线扫描链将FLASH编程算法与即将被下载的用户程序放到RAM中；</li><li>第三，将CPU的PC指针指向刚刚搬运完成的RAM地址起始处，并退出调试状态；</li><li>第四，CPU将在正常状态下运行RAM中的FLASH编程算法。将用户代码烧录到确定位置上，执行完成后回到调试状态。</li></ul><p>如果RAM空间不够大，以上操作还需要重复多次执行。</p><p>需要注意的是，在第二步操作RAM时，是处于调试状态下，而调试时钟的速率是无法满足RAM或者FLASH的访问速率要求的，所以在这一过程中，CPU会频繁的在系统时钟与调试时钟之间切换</p><p>调试时钟下，总线扫描链先传递来要写入的数据和RAM地址，CPU先分别暂存在内部通用寄存器中，接着扫描链传递写入指令，并切换为系统时钟。CPU在正常状态下执行搬运指令，往RAM里写入数据，执行完成后回到调试状态，继续通过扫描链传递后面要写入的值，</p><h2 id="OpenOCD-Open-On-Chip-Debugger"><a href="#OpenOCD-Open-On-Chip-Debugger" class="headerlink" title="OpenOCD (Open On-Chip Debugger)"></a>OpenOCD (Open On-Chip Debugger)</h2><p>OpenOCD（Open On-Chip Debugger）开源片上调试器，是一款开源软件，最初是由Dominic Rath同学还在大学期间发起的（2005年）项目。OpenOCD旨在提供针对嵌入式设备的调试、系统编程和边界扫描功能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1iN411Z7jk?spm_id_from=333.999.0.0&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">【蛋饼嵌入式】饮茶先？DEBUG先！一起探究调试原理_哔哩哔哩_bilibili</a><br><a href="https://zhuanlan.zhihu.com/p/125145986">浅谈RISC-V的DEBUG系统及其仿真 - 知乎</a><br><a href="https://www.bilibili.com/video/BV1s54y1Z7Zj/?spm_id_from=333.788&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">ESP32 JTAG Debug 01: JTAG接口简介_哔哩哔哩_bilibili</a>+</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>GDB</tag>
      
      <tag>芯片开发</tag>
      
      <tag>嵌入式</tag>
      
      <tag>硬件</tag>
      
      <tag>JTAG</tag>
      
      <tag>OpenOCD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保持SSH连接</title>
    <link href="/2022/08/13/%E4%BF%9D%E6%8C%81SSH%E8%BF%9E%E6%8E%A5/"/>
    <url>/2022/08/13/%E4%BF%9D%E6%8C%81SSH%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>SSH 总是被强行中断，尤其是用VSCode代码写的好好的，突然刷新窗口，不仅效率低，更惹人恼火。</p><p>可以通过配置服务端或客户端的SSH来保持SSH链接：</p><h2 id="方法一：配置服务端"><a href="#方法一：配置服务端" class="headerlink" title="方法一：配置服务端"></a>方法一：配置服务端</h2><p>可以在服务端配置，让 server 每隔 30 秒向 client 发送一个 keep-alive 包来保持连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ClientAliveInterval 30<br>ClientAliveCountMax 60<br></code></pre></td></tr></table></figure><p>第二行配置表示如果发送 keep-alive 包数量达到 60 次，客户端依然没有反应，则服务端 sshd 断开连接。如果什么都不操作，该配置可以让连接保持 30s*60 ， 30 min</p><p>重启本地 ssh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo service ssh restart<br></code></pre></td></tr></table></figure><p>如果找不到 ssh,”Failed to restart ssh.service: Unit ssh.service not found.” ，需要安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure><h2 id="方法二：配置客户端"><a href="#方法二：配置客户端" class="headerlink" title="方法二：配置客户端"></a>方法二：配置客户端</h2><p>如果服务端没有权限配置，或者无法配置，可以配置客户端 ssh，使客户端发起的所有会话都保持连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/ssh/ssh_config<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ServerAliveInterval 30<br>ServerAliveCountMax 60<br></code></pre></td></tr></table></figure><p>本地 ssh 每隔 30s 向 server 端 sshd 发送 keep-alive 包，如果发送 60 次，server 无回应断开连接。</p><p>在VSCode里可以直接添加配置，效果一样：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208132040474.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host 11.22.33.44<br>  HostName 11.22.33.44<br>  User user<br>  Port 112343<br>  ServerAliveInterval 30<br>  ServerAliveCountMax 60<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VSCode隐藏编辑页面右上角的按钮</title>
    <link href="/2022/08/02/VSCode%E9%9A%90%E8%97%8F%E7%BC%96%E8%BE%91%E9%A1%B5%E9%9D%A2%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E6%8C%89%E9%92%AE/"/>
    <url>/2022/08/02/VSCode%E9%9A%90%E8%97%8F%E7%BC%96%E8%BE%91%E9%A1%B5%E9%9D%A2%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E6%8C%89%E9%92%AE/</url>
    
    <content type="html"><![CDATA[<p>随着插件越装越多，标签栏右侧的按钮也越来越多，严重缩小了标题栏显示范围。这片按钮区域又有最大长度的限制，当按钮太多，就会隐藏到下拉菜单里（最右侧的三个点）。这样就会导致一些常用的按钮被隐藏，而不常用的按钮又占地方。那么怎样才能隐藏不需要的按钮呢？</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220802131549.png"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;gitlens.menus&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;editorGroup&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;blame&quot;</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">&quot;compare&quot;</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jellyfin打造本地影音库</title>
    <link href="/2022/08/01/Jellyfin%E6%89%93%E9%80%A0%E6%9C%AC%E5%9C%B0%E5%BD%B1%E9%9F%B3%E5%BA%93/"/>
    <url>/2022/08/01/Jellyfin%E6%89%93%E9%80%A0%E6%9C%AC%E5%9C%B0%E5%BD%B1%E9%9F%B3%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>周末花了一整天，是在没精力了。占坑。得空慢慢补！</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Syncthing多端丝滑同步与备份</title>
    <link href="/2022/08/01/%E4%BD%BF%E7%94%A8Syncthing%E5%A4%9A%E7%AB%AF%E4%B8%9D%E6%BB%91%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A4%87%E4%BB%BD/"/>
    <url>/2022/08/01/%E4%BD%BF%E7%94%A8Syncthing%E5%A4%9A%E7%AB%AF%E4%B8%9D%E6%BB%91%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="折腾背景"><a href="#折腾背景" class="headerlink" title="折腾背景"></a>折腾背景</h2><p>一直想找一个能够快速同步手机与电脑数据的工具，因为手机云服务的空间少的可怜，所以习惯隔一段时间将手机里的照片、视频还有一些文件导出到电脑上。但是每次备份文件都得连接数据线，并且没法增量备份，得手动挑选，也还挺麻烦的。</p><p>逛GitHub时，无意间发现了Syncthing，几乎符合了我所有的预期。</p><ul><li>开源，免费，自己电脑就可以当服务器，以后入了NAS，可以自己搭建本地服务器。</li><li>同步速度快，取决WIFI的速度，目前使用30M/s，基本满速。</li><li>多端支持，除了IOS（反正我也没有IOS设备，嘿嘿），几乎全平台支持，包括NAS及路由器。</li><li>增量同步，再也不用挑文件备份了。</li></ul><p>话不多说，开整。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>直接进入<a href="https://syncthing.net/">Syncthing</a>官网，下载安装。在 Ubuntu 下安装<a href="https://apt.syncthing.net/">参考这里</a>。Android版本下载<a href="https://f-droid.org/packages/com.nutomic.syncthingandroid/">Syncthing</a>。</p><p>接下来以Windows与Android手机同步为例，下载安装后，打开<code>syncthing.exe</code>，即可打开管理界面，或者浏览器输入<code>http://127.0.0.1:8384</code>也可进入管理界面。</p><p>Windows界面：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131917716.png"></p><p>Android界面：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131920202.png"></p><h2 id="设备配对"><a href="#设备配对" class="headerlink" title="设备配对"></a>设备配对</h2><p>Windows管理页面-&gt;操作-&gt;显示ID，会显示本机的二维码：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131922624.png"></p><p>Android手机打开应用，切换到<strong>设备</strong>界面，点击右上角<strong>加号</strong>，点击二维码标识，即可扫描二维码，完成设备添加。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131927893.png"></p><p>如果正确添加，Windows管理界面会显示Android设备：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131928172.png"></p><h2 id="Android同步至Windows"><a href="#Android同步至Windows" class="headerlink" title="Android同步至Windows"></a>Android同步至Windows</h2><p>打开Android应用，切换到<strong>文件夹</strong>界面，点击右上角<strong>加号</strong>，配置同步的文件夹：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131931912.png"></p><p>根据下图提示，配置应用，记得保存：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131934895.png"><br>目录列表显示刚刚的配置：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131937682.png"></p><p>点击打开，开启与远程设备Windows同步：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131938899.png"></p><p>当返回时，Windows端将会弹出通知，提示有Android设备的文件要分享到电脑，点击<strong>添加</strong>：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131939273.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131941549.png"></p><p>至此，Android同步至Windows完成。此时在Android设备的文件夹中添加任意文件，都会同步到Windows。</p><h2 id="Windows同步至Android"><a href="#Windows同步至Android" class="headerlink" title="Windows同步至Android"></a>Windows同步至Android</h2><p>Windows管理界面，添加文件夹：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131945074.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131947601.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131948844.png"></p><p>点击保存后，与之前类似，Android会提示有Windows设备的文件要分享到Android，点击<strong>添加</strong>：</p><blockquote><p>如果Android设备没有弹出提示添加共享文件夹，那么打开应用侧边栏-&gt;网页管理页面，将会有弹窗，如下图</p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208132019765.png"></p><p>点击添加，配置文件夹目录等与之前类似。</p><p>至此，Windows同步至Android完成。此时在Windows设备的文件夹中添加任意文件，都会同步到Android。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="Syncthing-支持三种工作模式"><a href="#Syncthing-支持三种工作模式" class="headerlink" title="Syncthing 支持三种工作模式"></a>Syncthing 支持三种工作模式</h3><ul><li>发送和接收，Send &amp; Receive Folder，这是文件夹的默认模式，对文件夹的修改会发送，其他设备的修改也会同步回来。</li><li>仅发送 Send Only，这种模式表示仅仅将当前设备上的文件夹的改动发送到其他设备，用来隐式地表示其他同步设备上的文件不会被修改，或者其他设备上的修改可以被忽略。这种模式非常适合，将当前设备设定为工作设备，然后设定一台设备作为此设备的备份。<ul><li>在 Send Only 模式下，集群中其他设备的修改都会被忽略，修改依然会接收，文件夹可能会出现 「out of sync」，但是没有修改会被应用到本地。</li><li>当 Send Only 文件夹出现 out of sync，那么一个红色的 Override Changes 会出现在文件夹详情中，点击该按钮会强制将当前主机的状态同步到其他剩余节点。任何对文件的修改，都会被当前主机上的版本所覆盖，任何不存在于当前主机节点的文件都会被删除，其他类似。</li></ul></li><li>仅接收 Receive Only，这种模式下所有的修改都会被接收并应用，然后重新分发给其他使用 send-receive 模式的设备。但是本地的修改不会被分发给其他设备。这种模式适合于建立备份镜像（replication mirrors），或者备份目的主机的场景，这些情况下不期望有本地修改或者本地的修改是不允许的<ul><li>当本地文件被删除时，Syncthing 会显示一个 Revert Local Changes 按钮。使用这个按钮会将本地的修改回撤，所有添加的文件会被删除，修改或删除的文件会重新从其他节点同步，比较容易理解，但是假如 A 设备设置仅发送，B 设备设置发送和接收，A 是不会同步 B 的更改的！</li></ul></li></ul><h3 id="忽略特定文件、目录"><a href="#忽略特定文件、目录" class="headerlink" title="忽略特定文件、目录"></a>忽略特定文件、目录</h3><p>忽略列表，和 gitignore 类似。每一台设备上的 <code>.stignore</code> 都是分别设置的，不会进行同步。</p><p>如果A的<code>.stignore</code>忽略了 <code>test</code> ，而B没有这样做，实际上会发生这样的事情：</p><ul><li>A 不会扫描和通知B（广播）关于test的变动；</li><li>B 对关于test的变动持开放的姿态，但不会收到任何关于A上面test的变动信息（可能接收到其它同步设备的）；</li><li>B 会扫描test以及推送其关于test变动的信息，但会被A忽略，A也会忽略其它同步设备关于test的信息；</li><li>B 会接收来自其它同步设备推送的关于test的信息；</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.einverne.info/post/2019/10/syncthing.html">Syncthing 又一款同步工具 | Verne in GitHub</a></p><p><a href="https://docs.syncthing.net/users/foldertypes.html">Folder Types — Syncthing documentation</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>效率</tag>
      
      <tag>同步</tag>
      
      <tag>备份</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决提交gerrit missing Change-Id</title>
    <link href="/2022/07/30/%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BA%A4gerrit-missing-Change-Id/"/>
    <url>/2022/07/30/%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BA%A4gerrit-missing-Change-Id/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">remote: Resolving deltas: 100% (114/114)<br>remote: Processing changes: refs: 1,<span class="hljs-keyword">done</span>   <br>remote: ERROR: missing Change-Idincommit message footer<br>remote:<br>remote: Hint: To automatically insert Change-Id,installthe hook:<br>remote:   gitdir=$(git rev-parse --git-dir);scp-p -P XX XX@gerrit.xxxxx.com:hooks/commit-msg<span class="hljs-variable">$&#123;gitdir&#125;</span>/hooks/<br>remote: And <span class="hljs-keyword">then</span> amend the commit:<br>remote:   git commit --amend<br></code></pre></td></tr></table></figure><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><h3 id="理解change-id"><a href="#理解change-id" class="headerlink" title="理解change-id"></a>理解change-id</h3><p>代码审核是要对一个完整的变更进行审核，比如一次Bug修复，有多次提交Commit，每次的Commit Id都不同，那么如何将多个不同的Commit ID 关联到同一个Chanege-Id呢？我们需要将Change-Id添加到Commit的footer（最后一行）中，这样就可以将多个Commit关联到同一个Change-Id了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207301909075.png"><br>Change-Id 为避免与提交 Id 冲突，通常以大写字母I为前缀。此外，我们需要明确，Change-Id 是Gerrit的概念，不是Git的概念。你只有用Gerrit才会有Change-Id，而Git只有提交 Id。</p><p>那么这个Change-Id是怎么生成的呢？</p><h3 id="理解git-hooks"><a href="#理解git-hooks" class="headerlink" title="理解git hooks"></a>理解git hooks</h3><p>我在<a href="https://dunky-z.github.io/2022/05/30/Git-hooks%E9%92%A9%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/">Git hooks钩子的使用</a>中有详细解释。在这里简单的介绍一下，钩子(hooks)是一些在<code>.git/hooks</code>目录的脚本, 在被特定的事件触发后被调用。比如执行<code>git commit</code>，<code>git push</code>，<code>git pull</code>等命令时，脚本会被调用。</p><p>Gerrit也提供了一个标准的<code>commit-msg</code>钩子，当我们在执行<code>git commit</code>时，会被调用。会自动生成<code>Change-Id</code>，并将其添加到<code>commit</code>的footer中。</p><p>通常我们从远程下载代码后，会自动下载<code>commit-msg</code>钩子，并将其添加到<code>.git/hooks</code>目录中。正常来说<code>hooks</code>是不会加入代码仓库的，这应该取决于Gerrit的配置。</p><p>这次错误应该是我在测试钩子的时候，将Gerrit标准钩子删除了，导致无法正确生成Change-Id。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>报错时其实已经提供了解决方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 提示让我们安装远程的钩子</span><br>remote: Hint: To automatically insert Change-Id,installthe hook:<br><br><span class="hljs-comment"># 在命令行输入以下两条命令：</span><br><span class="hljs-comment"># 这条命令将找到该项目的 git 目录,并将其赋值给 gitdir 这个变量</span><br>gitdir=$(git rev-parse --git-dir)<br><span class="hljs-comment"># 执行 scp 命令,从 gerrit 代码服务器将钩子脚本文件 commit-msg 下载到项目的钩子目录下 (一般是 .git/hooks/)</span><br>scp-p -P XX XX@gerrit.xxxxx.com:hooks/commit-msg<span class="hljs-variable">$&#123;gitdir&#125;</span>/hooks/<br></code></pre></td></tr></table></figure><p>安装完之后重新<code>git commit --amend</code>，就可以正常生成Change-Id了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gerrit批量添加抄送提醒</title>
    <link href="/2022/07/29/Gerrit%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%8A%84%E9%80%81%E6%8F%90%E9%86%92/"/>
    <url>/2022/07/29/Gerrit%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%8A%84%E9%80%81%E6%8F%90%E9%86%92/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司使用Gerrit作为Review平台，但是每次提交代码都需要手动添加Reviewer，还要抄送组内成员，这种重复性劳动，程序员是绝不能容忍的。gerrit提供了发送邮件的功能。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>官方示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git push ssh:<span class="hljs-regexp">//</span>john.doe@git.example.com:<span class="hljs-number">29418</span><span class="hljs-regexp">/kernel/</span>common HEAD:refs<span class="hljs-regexp">/for/</span>experimental%r=a@a.com,cc=b@o.com<br></code></pre></td></tr></table></figure><p>最后的<code>%</code>是个分隔符，<code>r=&#39;a@a.com</code>表示Reviewer是<code>a@a.com</code>，<code>cc=b@o.com</code>表示抄送组内成员是<code>b@o.com</code>。</p><blockquote><p>注意！邮箱之间不能有空格！</p></blockquote><p>以一个仓库为例：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git push origin HEAD:refs/for/branch_dev_name<span class="hljs-variable">%cc</span><span class="hljs-operator">=</span>zhangsan<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>lisi<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>wangerma<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>chenwu<span class="hljs-title">@qq.com</span><br></code></pre></td></tr></table></figure><p>但是要这么写，岂不是把操作搞更复杂了。</p><p>终极办法，打开项目路径下的<code>.git</code>目录。编辑<code>config</code>文件：</p><p>原文件里有如下字段：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[core]</span><br><span class="hljs-attr">repositoryformatversion</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">filemode</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">bare</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">logallrefupdates</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">ignorecase</span> = <span class="hljs-literal">true</span><br><span class="hljs-section">[remote &quot;origin&quot;]</span><br><span class="hljs-attr">url</span> = git@github.com:Dunky-Z/Dunky-Z.github.io.git<br><span class="hljs-attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*<br></code></pre></td></tr></table></figure><p>我们可以将远程仓库名换成容易区分的名字，自己随意：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[core]</span><br><span class="hljs-attr">repositoryformatversion</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">filemode</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">bare</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">logallrefupdates</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">ignorecase</span> = <span class="hljs-literal">true</span><br><span class="hljs-section">[remote &quot;origin&quot;]</span><br><span class="hljs-attr">url</span> = git@github.com:Dunky-Z/Dunky-Z.github.io.git<br><span class="hljs-attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*<br><span class="hljs-comment"># 以下为新增内容</span><br><span class="hljs-section">[remote &quot;review&quot;]</span><br><span class="hljs-attr">url</span> = git@github.com:Dunky-Z/Dunky-Z.github.io.git<br><span class="hljs-attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*<br><span class="hljs-attr">push</span> = HEAD:refs/for/%cc=zhangsan@qq.com,<br><span class="hljs-attr">cc</span>=lisi@qq.com,<br><span class="hljs-attr">cc</span>=wangerma@qq.com,<br><span class="hljs-attr">cc</span>=chenwu@qq.com<br></code></pre></td></tr></table></figure><p>下次想要推送需要review的代码，就直接执行<code>git push review</code>，其中<code>push</code>就相当于：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">push HEAD:refs/for/<span class="hljs-variable">%cc</span><span class="hljs-operator">=</span>zhangsan<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>lisi<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>wangerma<span class="hljs-title">@qq.com</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">cc</span><span class="hljs-operator">=</span>chenwu<span class="hljs-title">@qq.com</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://gerrit-review.googlesource.com/Documentation/user-upload.html#push_create,">Gerrit Code Review - Uploading Changes</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Makefile确定宏定义</title>
    <link href="/2022/07/27/Makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <url>/2022/07/27/Makefile%E7%A1%AE%E5%AE%9A%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>有时需要通过<code>make</code>编译命令时确定代码中的宏定义，如编译不同的版本只需要使用不同的编译命令即可，而不需要修改内部代码。</p><p>当前的需求是代码中有一部分代码通过宏定义来确定编译的是DIE0版本还是DIE1版本，如果定义了<code>DIE_ORDINAL_0</code> 就使用DIE0的基地址，如果未定义就使用DIE1的基地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DIE_ORDINAL_0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DIE_ORDINAL_0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PERIPH_BASE (SYS_BASE_ADDR_DIE0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PERIPH_BASE (SYS_BASE_ADDR_DIE1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>gcc命令支持<code>-D</code>宏定义，相当于C中的全局<code>#define</code>，在Makefile中我们可以通过宏定义来控制源程序的编译。只要在Makefile中的CFLAGS中通过选项-D来指定你于定义的宏即可。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">CFLAGS += -D DIE_ORDINAL_0<br><span class="hljs-comment"># 在编译的时候加上此选项就可以了</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>这样的话，相当于设置了<code>DIE_ORDINAL_0</code>这个宏定义。但是我们想通过命令行的参数来决定是否使用这个宏定义，可以通过一些简单的方法获取：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(DIE0)</span>, y)<br>  CFLAGS +=-DDIE_ORDINAL_0<br><span class="hljs-keyword">else</span><br>  CFLAGS +=-DDIE_ORDINAL_1<br><span class="hljs-keyword">endif</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>从命令行找到<code>DIE0</code>这个参数，如果它等于<code>y</code>表示使用<code>DIE_ORDINAL_0</code>。如果不等于<code>y</code>则使用<code>DIE_ORDINAL_1</code>，因为我们代码里没有<code>DIE_ORDINAL_1</code>，所以就相当于没有定义<code>DIE_ORDINAL_0</code>。</p><p>命令行示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 编译DIE0</span><br>make DIE0=<span class="hljs-string">&quot;y&quot;</span><br><span class="hljs-comment"># 编译DIE1</span><br>make DIE0=<span class="hljs-string">&quot;n&quot;</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-生成指定大小文件</title>
    <link href="/2022/07/23/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6/"/>
    <url>/2022/07/23/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>在测试下载速度，或者测试加解密文件，亦或者制作文件系统时都需要一些指定大小的文件。Linux有一些命令可以快速完成这样的任务。接下来介绍几个好用的命令。</p><h3 id="空洞文件"><a href="#空洞文件" class="headerlink" title="空洞文件"></a>空洞文件</h3><p>在Unix文件操作中，操作文件的位移量可以大于文件的当前长度，在下一次写操作时，就会把文件撑大（Extend），在文件里创建空洞（Hole），没有被实际写入的部分都是0。空洞文件是否占用实际磁盘空间由文件系统觉得，<strong>Linux中空洞文件不占用实际磁盘空间</strong>。</p><h2 id="fallocate"><a href="#fallocate" class="headerlink" title="fallocate"></a>fallocate</h2><p><code>fallocate</code>用于将块预分配给文件。对于支持<code>fallocate</code>系统调用的文件系统，这可以通过分配块并将其标记为未初始化来快速完成，因此不需要对数据块进行I/O操作。这是创建文件而不是用零填充的更快的方法。大文件几乎可以立即创建，而不必等待任何I/O操作完成。</p><p>语法： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate [-n] [-o offset] -l length filename<br></code></pre></td></tr></table></figure><ul><li><code>d</code>: 检测零并替换为空洞。</li><li><code>-n</code>：指定文件的大小，单位为字节。</li><li><code>-o</code>：指定文件的偏移量，可以跟二进制$2^{N}$后缀<code>KiB</code>，<code>MiB</code>，<code>GiB</code>，<code>TiB</code>，<code>PiB</code>和<code>EiB</code>（<code>iB</code>为可选，例如，<code>K</code>的含义与<code>KiB</code>的含义相同或后缀<code>KB</code>，<code>MB</code>，<code>GB</code>，<code>PB</code>和<code>EB</code>的十进制（$10^{N}$）。</li><li><code>-l</code>：指定文件的大小，单位同上。</li><li><code>-p, --punch-hole</code>: 将某个范围替换为空洞(连带打开 -n)。</li><li><code>filename</code>：指定文件名。</li></ul><p>示例：<br>分配一个大小为<code>512MB</code>的文件，文件名为<code>efi.img</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate -l 512M efi.img<br></code></pre></td></tr></table></figure><p>将<code>efi.img</code>文件中的<code>0</code>替换为空洞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate -d efi.img<br></code></pre></td></tr></table></figure><p>从偏移128M的位置挖一个10M大小的洞</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate -p -o 128M  -l 10M  efi.img<br></code></pre></td></tr></table></figure><h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>Linux <code>dd</code> 命令用于读取、转换并输出数据。<code>dd</code> 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出</p><blockquote><p>dd的原意为data duplicator，但由于 dd 属于较低阶的资料处理工具，通常都会以管理者（root）权限来执行，如果稍有不慎，也很容易造成严重的后果（例如整颗硬碟的资料不见等等），所以有些人也把 dd 取名为data destroyer。<a href="https://blog.gtwang.org/linux/dd-command-examples/">dd 指令教学与实用范例，备份与回复资料的小工具- GT Wang</a></p></blockquote><ul><li><code>if=FILE </code>     : 指定输入文件，若不指定则从标注输入读取。这里指定为/dev/zero是Linux的一个伪文件，它可以产生连续不断的null流（二进制的0）。</li><li><code>of=FILE</code>      : 指定输出文件，若不指定则输出到标准输出。</li><li><code>bs=BYTES</code>     : 每次读写的字节数，可以使用单位K、M、G等等。另外输入输出可以分别用ibs、obs指定，若使用bs，则表示是ibs和obs都是用该参数。</li><li><code>count=BLOCKS</code> : 读取的block数，block的大小由ibs指定。</li></ul><p>示例：<br>生成一个<code>1g</code>大小的文件，内容全为<code>0</code>，块大小为<code>1M</code>，文件名为<code>efi.img</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dd <span class="hljs-keyword">if</span>=/dev/zero of=efi.img bs=1M count=1024<br></code></pre></td></tr></table></figure><p>生成一个<code>1g</code>大小的文件，内容为随机数，块大小为<code>10M</code>，文件名为<code>efi.img</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dd <span class="hljs-keyword">if</span>=/dev/urandom of=efi.img bs=10M count=1024<br></code></pre></td></tr></table></figure><h2 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h2><ul><li><code>-s</code>：指定文件的大小，可以跟二进制$2^{N}$后缀<code>KiB</code>，<code>MiB</code>，<code>GiB</code>，<code>TiB</code>，<code>PiB</code>和<code>EiB</code>（<code>iB</code>为可选，例如，<code>K</code>的含义与<code>KiB</code>的含义相同或后缀<code>KB</code>，<code>MB</code>，<code>GB</code>，<code>PB</code>和<code>EB</code>的十进制（$10^{N}$）。</li></ul><p>示例：<br>生成一个100M大小的文件，文件名为<code>efi.img</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">truncate -s 100M efi.img<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://lrita.github.io/images/posts/filesystem/Linux_File_Hole_And_Sparse_Files.pdf">Linux文件空洞与稀疏文件</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>理解虚拟内存</title>
    <link href="/2022/07/17/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2022/07/17/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要虚拟内存？"><a href="#为什么需要虚拟内存？" class="headerlink" title="为什么需要虚拟内存？"></a>为什么需要虚拟内存？</h2><p>CPU访问内存的最自然的方式就是使用物理地址，这种方式称为<strong>物理寻址</strong>。1，计算机中并不是只有一个程序在运行，如果它们都是用物理寻址的方式，那么所有程序必须在链接之前确定好自己所用到的内存范围，否则两个程序就可能会发生冲突。2，程序大于内存的问题早在上世纪六十年代就出现，后来出现了<strong>覆盖技术</strong>（Overlay），把程序分割成许多片段。程序开始执行时，将覆盖管理模块装入内存，该管理模块立即装入并运行覆盖0。执行完成后，覆盖0通知管理模块装入覆盖1，或者占用覆盖0的上方位置（如果有空间），或者占用覆盖0（如果没有空间）。把一个大程序分割成小的、模块化的片段是非常费时和枯燥的，并且易于出错。很少程序员擅长使用覆盖技术。</p><p>为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟内存</strong>(VM)。主要有三个功能：</p><ul><li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它<strong>高效地使用了主存</strong>。</li><li>它为每个进程提供了一致的地址空间，从而<strong>简化了内存管理</strong>。</li><li>它<strong>保护了每个进程</strong>的地址空间不被其他进程破坏。</li></ul><h2 id="什么是虚拟寻址？"><a href="#什么是虚拟寻址？" class="headerlink" title="什么是虚拟寻址？"></a>什么是虚拟寻址？</h2><p>如果主存被分为长度为$M$的单字节大小的数组，每个字节都对应一个物理地址，CPU通过这个唯一的地址访问主存，这样的方式就是<strong>物理寻址</strong>。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207212125636.png"><br>现代处理器使用<strong>虚拟寻址</strong>的方式。CPU通过生成的<strong>虚拟地址</strong>来访问内存，这个地址在送到内存之前会被转换成<strong>物理地址</strong>。这个过程称为<strong>地址翻译</strong>。CPU 芯片上叫做<strong>内存管理单元</strong>（Memory Management Unit, MMU）的专用硬件，利用存放在主存中的<strong>查询表</strong>来动态翻译虚拟地址，该表的内容由操作系统管理。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207212128486.png"></p><h2 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h2><p>概念上而言，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是<strong>字节数组</strong>。每个字节都有一个唯一的虚拟地址作为数组的索引。磁盘上活动的数组内容被缓存在主存中。在存储器结构中，较低层次上的磁盘的数据被分割成块，这些块作为和较高层次的主存之间的传输单元。<strong>主存作为虚拟内存的缓存</strong>。</p><p>虚拟内存被分割为大小固定的块，这些块叫<strong>虚拟页</strong>（Virtual Page，VP），类似的物理内存也有<strong>物理页</strong>(Physical Page, PP)。虚拟页有三种不同的状态：</p><ul><li>未分配：VM 系统还未分配(或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就<strong>不占用任何磁盘空间</strong>。</li><li>已缓存：当前已缓存在物理内存中的已分配页。</li><li>未缓存：未缓存在物理内存中的已分配页。</li></ul><p>为了有助于清晰理解存储层次结构中不同的缓存概念，我们将使用术语<strong>SRAM</strong>缓存来表示位于 CPU 和主存之间的 Ll、L2 和 L3 <strong>高速缓存</strong>，并且用术语 <strong>DRAM</strong> 缓存来表示<strong>虚拟内存系统的缓存</strong>，它在主存中缓存虚拟页。</p><p>在存储层次结构中，DRAM 缓存的位置对它的组织结构有很大的影响。回想一下，DRAM 比 SRAM 要慢大约 10 倍，而磁盘要比 DRAM 慢大约 100000 多倍。因此，<strong>DRAM 缓存中的不命中比起 SRAM 缓存中的不命中要昂贵得多</strong>。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。（这些替换算法超出了我们的讨论范围）。最后，因为对磁盘的访问时间很长，<strong>DRAM 缓存总是使用写回，而不是直写</strong>。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟内存系统可以完成以下这些功能，</p><ul><li>判定一个虚拟页是否缓存在 DRAM 中的某个地方；</li><li>可以确定这个虚拟页存放在哪个物理页中；</li><li>如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。</li></ul><p>这些功能是由<strong>软硬件联合提供的</strong>，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和一个<strong>存放在物理内存中叫做页表</strong>（page table）的数据结构。页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p><p>图 9-4 展示了一个页表的基本组织结构。页表就是一个页表条目（Page Table Entry，PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p><p>PTE由两部分组成：</p><ul><li>有效位：表明了该虚拟页当前是否被缓存在 DRAM 中；</li><li>地址：表示 DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208122157633.png"></p><h3 id="页命中与缺页"><a href="#页命中与缺页" class="headerlink" title="页命中与缺页"></a>页命中与缺页</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208130940717.png">l</p><p>当CPU访问已被缓存的地址时，就叫做<strong>页命中</strong>。如访问上图VP2，虚拟地址索引到PTE2，此时有效位为1，地址翻译硬件就知道该地址被缓存了。</p><p>当CPU访问未被缓存的地址时，会导致<strong>缺页</strong>。如访问上图的VP3，虚拟地址索引到PTE3，此时有效位为0，地址翻译硬件就知道该地址未被缓存，需要从磁盘中读取。</p><p>这时会触发一个<strong>缺页异常</strong>。<strong>缺页异常调用内核中的缺页异常处理程序</strong>，该程序会选择一个牺牲页，在此例中就是存放在 PP 3 中的 VP 4。如果 VP 4 已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改 VP 4 的页表条目，反映出 VP 4 不再缓存在主存中这一事实。</p><p>接下来，内核从磁盘复制 VP 3 到内存中的 PP 3，更新 PTE 3，随后返回。当异常处理程序返回时，它会<strong>重新启动导致缺页的指令</strong>，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP 3 已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图 9-7 展示了在缺页之后我们的示例页表的状态。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131434643.png"></p><p>在虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做<strong>交换</strong>（swapping）或者<strong>页面调度</strong>（paging）。页从磁盘换入（或者页面调入）DRAM 和从 DRAM 换出（或者页面调出）磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度（demand paging）。</p><h2 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h2><p>之前我们只讨论了一个页表的情况，但是实际上操作系统为<strong>每个进程都分配了一个独立的页表</strong>。多个虚拟页面可以映射到同一个共享物理页面上。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131441255.png"></p><p>按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。特别地，VM 简化了链接和加载、代码和数据共享，以及应用程序的内存分配。</p><ul><li><strong>简化链接</strong>。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而<strong>不管代码和数据实际存放在物理内存的何处</strong>。例如，一个给定的 Linux 系统上的每个进程都使用类似的内存格式。对于 64 位地址空间，代码段总是从虚拟地址 0x400000 开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，<strong>允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的</strong>。</li><li><strong>简化加载</strong>。虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中 .text 和 .data 节加载到一个新创建的进程中，Linux 加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。有趣的是，加载器从不从磁盘到内存实际复制任何数据。在每个页初次被引用时，要么是 CPU 取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作内存映射（memory mapping）。Linux 提供一个称为 mmap 的系统调用，允许应用程序自己做内存映射。</li><li><strong>简化共享</strong>。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。</li><li><strong>简化内存分配</strong>。虚拟内存为向用户进程提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如调用 malloc 的结果），<strong>操作系统分配一个适当数字（例如 k）个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的 k 个任意的物理页面</strong>。由于页表工作的方式，操作系统没有必要分配 k 个连续的物理内存页面。<strong>页面可以随机地分散在物理内存中</strong>。</li></ul><h2 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h2><p>操作系统中的用户程序不应该修改只读的代码段，也不应该读取或者修改内核中的代码和数据结构或者访问私有的以及其他的进程的内存，如果无法对用户进程的内存访问进行限制，攻击者就可以访问和修改其他进程的内存影响系统的安全。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131522719.png"></p><p>通过在页表中添加页面的保护属性，可以让操作系统在页面被访问时进行检查，如果页面被保护为只读，则操作系统会报错。</p><p>在图9-10这个示例中，每个 PTE 中已经添加了三个许可位。SUP 位表示进程是否必须运行在内核（超级用户）模式下才能访问该页。运行在内核模式中的进程可以访问任何页面，但是运行在用户模式中的进程只允许访问那些 SUP 为 0 的页面。READ 位和 WRITE 位控制对页面的读和写访问。例如，如果进程 i 运行在用户模式下，那么它有读 VP 0 和读写 VP 1 的权限。然而，不允许它访问 VP 2。</p><p>如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell 一般将这种异常报告为<strong>段错误</strong>（segmentation fault）。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>基本参数</p><table><thead><tr><th align="left">符号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$$\small N=2^n$$</td><td align="left">虚拟地址空间中的地址数量</td></tr><tr><td align="left">$$\small M=2^m$$</td><td align="left">物理地址空间中的地址数量</td></tr><tr><td align="left">$$\small P=2^p$$</td><td align="left">页的大小（字节）</td></tr></tbody></table><p>虚拟地址（VA）的组成部分</p><table><thead><tr><th align="left">符号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">VPO</td><td align="left">虚拟页面偏移量（字节）</td></tr><tr><td align="left">VPN</td><td align="left">虚拟页号</td></tr><tr><td align="left">TLBI</td><td align="left">TLB 索引</td></tr><tr><td align="left">TLBT</td><td align="left">TLB 标记</td></tr></tbody></table><p>物理地址（PA）的组成部分</p><table><thead><tr><th align="left">符号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">PPO</td><td align="left">物理页面偏移量（字节）</td></tr><tr><td align="left">PPN</td><td align="left">物理页号</td></tr><tr><td align="left">CO</td><td align="left">缓冲块内的字节偏移量</td></tr><tr><td align="left">CI</td><td align="left">高速缓存索引</td></tr><tr><td align="left">CT</td><td align="left">高速缓存标记</td></tr></tbody></table><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131527131.png"></p><p>图 9-12 展示了 MMU 如何利用页表来实现地址翻译。CPU 中的一个控制寄存器，<strong>页表基址寄存器</strong>（Page Table Base Register，PTBR）指向当前页表。$n$ 位的虚拟地址包含两个部分：一个 $p$ 位的<strong>虚拟页面偏移</strong>（Virtual Page Offset，VPO）和一个$\small (n-p)$位的<strong>虚拟页号</strong>（Virtual Page Number，VPN）。MMU 利用 VPN 来选择适当的 PTE。例如，VPN 0 选择 PTE 0，VPN 1 选择 PTE 1，以此类推。将页表条目中<strong>物理页号</strong>（Physical Page Number，PPN）和虚拟地址中的 VP。串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是 P 字节的，所以<strong>物理页面偏移（Physical Page Offset，PPO）和 VPO 是相同的</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131527491.png"></p><p>图 9-13a 展示了当页面命中时，CPU 硬件执行的步骤。</p><ul><li>第 1 步：处理器生成一个<br>虚拟地址，并把它传送给 MMU。</li><li>第 2 步：MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。</li><li>第 3 步：高速缓存/主存向 MMU 返回 PTE。</li><li>第 4 步：MMU 构造物理地址，并把它传送给高速缓存/主存。</li><li>第 5 步：高速缓存/主存返回所请求的数据字给处理器。</li></ul><p>页面命中完全是由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成，如图 9-13b 所示。</p><ul><li>第 1 - 3 步：和图 9-13a 中的第 1 步到第 3 步相同。</li><li>第 4 步：PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。</li><li>第 5 步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>第 6 步：缺页处理程序页面调入新的页面，并更新内存中的 PTE。</li><li>第 7 步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给 MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，在 MMU 执行了图 9-13b 中的步骤之后，主存就会将所请求字返回给处理器。</li></ul><h3 id="利用TLB加速地址翻译"><a href="#利用TLB加速地址翻译" class="headerlink" title="利用TLB加速地址翻译"></a>利用TLB加速地址翻译</h3><p>每次 CPU 访问一个虚拟地址，MMU 就必须查找 PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。如果 PTE 碰巧缓存在 L1 中，那么开销就下降到 1 个或 2 个周期。为了消除这样的开销，在 MMU 中包括了一个关于 PTE 的小的缓存，称为<strong>翻译后备缓冲器</strong>（Translation Lookaside Buffer，TLB）。</p><p>TLB 是一个小的、虚拟寻址的缓存，其中<strong>每一行都保存着一个由单个 PTE 组成的块</strong>。TLB 通常有高度的相联度。如图 9-15 所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果 TLB 有$\small T = 2^t$个组，那么 <strong>TLB 索引</strong>（TLBI）是由 VPN 的 $t$ 个最低位组成的，而 <strong>TLB 标记</strong>（TLBT）是由 VPN 中剩余的位组成的。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131546427.png"></p><p>图 9-16a 展示了当 TLB 命中时（通常情况）所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的 MMU 中执行的，因此非常快。</p><ul><li>第 1 步：CPU 产生一个虚拟地址。</li><li>第 2 - 3 步：MMU 从 TLB 中取出相应的 PTE。</li><li>第 4 步：MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</li><li>第 5 步：高速缓存/主存将所请求的数据字返回给 CPU。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131547576.png"></p><p>当 TLB 不命中时，MMU 必须从 L1 缓存中取出相应的 PTE，如图 9-16b 所示。新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了 。</p><p>页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。</p><p>那怎么办呢？我们可以试着将页表再分页，4G 的空间需要 4M 的页表来存储映射。我们把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K。</p><p>页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置。</p><p>这样加起来正好 32 位，也就是用前 10 位定位到页目录表中的一项。将这一项对应的页表取出来共 1k 项，再用中间 10 位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后 12 位定位到页中的具体位置访问数据。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129192245.png"></p><p>你可能会问，如果这样的话，映射 4GB 地址空间就需要 4MB+4KB 的内存，这样不是更大 了吗？ 当然如果页是满的，当时是更大了，但是，我们往往不会为一个进程分配那么多内 存。<br>比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完 整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配， 占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省多了</p><p>当然对于 64 位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间<br>页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。也就是一级页表，二级页表，三级页表，四级页表。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208131820091.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>虚拟内存</tag>
      
      <tag>TLB</tag>
      
      <tag>页表</tag>
      
      <tag>多级页表</tag>
      
      <tag>MMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言getopt()函数的用法</title>
    <link href="/2022/07/16/C%E8%AF%AD%E8%A8%80getopt-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2022/07/16/C%E8%AF%AD%E8%A8%80getopt-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在做<a href="https://dunky-z.github.io/2022/07/11/CSAPP-LAB-Cache-Lab/">CSAPP_LAB-Cache Lab</a>时，实验要求对输入参数进行处理，如程序<code>csim</code>执行需要4个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim -s 4 -E 6 -b 4 -t &lt;tracefile&gt;<br></code></pre></td></tr></table></figure><p>原先想通过字符串解析，一个个处理，但是看到了其他参考代码后发现了一个更简单的方法，可以通过<code>getopt()</code>函数来解析参数。</p><p>函数的功能： 解析命令行参数。<br>头文件 <code>#include &lt;unistd.h&gt;</code></p><p>在学习函数前需要了解与该函数相关的四个变量：</p><ul><li><p><code>int opterr</code>：控制是否输出错误；<br>如果此变量的值非零，则 <code>getopt</code> 在遇到未知选项字符或缺少必需参数的选项时将错误消息打印到标准错误流(终端)。该值默认为非零。如果将此变量设置为零，<code>getopt</code> 不会打印任何消息，但仍会返回问号<code>?</code>提示错误。</p></li><li><p><code>int optopt</code>：保存未知的选项；<br>当 <code>getopt</code> 遇到未知选项字符或缺少必需参数的选项时，它将该选项字符存储在此变量中。</p></li><li><p><code>int optind</code>：指向下一个要处理的参数；<br>此变量由 <code>getopt</code> 设置为要处理的 <code>argv</code> 数组的下一个元素的索引。一旦 <code>getopt</code> 找到所有选项参数，就可以使用此变量来确定其余非选项参数的开始位置。该变量的初始值为 1。</p></li><li><p> <code>char * optarg</code>：保存选项参数；<br>对于那些接受参数的选项，此变量由 <code>getopt</code> 设置为指向选项参数的值。</p></li></ul><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * options)</span></span>;<br></code></pre></td></tr></table></figure><p>参数解析：</p><ul><li>参数<code>argc</code> 和<code>argv</code> 是由<code>main()</code>传递的参数个数和内容。</li><li><code>options</code> 参数是一个字符串，它指定对该程序有效的选项字符。此字符串中的选项字符后面可以跟一个冒号（<code>:</code>），表示它需要一个<strong>必需的参数</strong>，这个参数可以与选项连写也可以空格分开，如<code>-a13 or  -a 13</code>。如果选项字符后跟两个冒号（<code>::</code>），则其参数是<strong>可选的</strong>，如果有参数，那么参数不能与选项分割，如只能写成<code>-a13</code>而不能写成<code>-a 13</code>；这是一个 GNU 扩展。</li></ul><p>实例：</p><p>下面是一个示例，展示了通常如何使用 <code>getopt</code>。需要注意的关键点是：</p><ul><li>通常，<code>getopt</code> 在循环中被调用。当 <code>getopt</code> 返回 <code>-1</code> 表示没有更多选项存在时，循环终止。</li><li><code>switch</code> 语句用于调度 <code>getopt</code> 的返回值。在典型使用中，每种情况只设置一个稍后在程序中使用的变量。</li><li>第二个循环用于处理剩余的非选项参数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> aflag = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> bflag = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">char</span> *cvalue = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">int</span> index;<br>  <span class="hljs-keyword">int</span> c;<br><br>  opterr = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> ((c = getopt (argc, argv, <span class="hljs-string">&quot;abc:&quot;</span>)) != <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">switch</span> (c)<br>      &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>        aflag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>        bflag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>        cvalue = optarg;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (optopt == <span class="hljs-string">&#x27;c&#x27;</span>)<br>          <span class="hljs-built_in">fprintf</span> (<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Option -%c requires an argument.\n&quot;</span>, optopt);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isprint</span> (optopt))<br>          <span class="hljs-built_in">fprintf</span> (<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unknown option `-%c&#x27;.\n&quot;</span>, optopt);<br>        <span class="hljs-keyword">else</span><br>          <span class="hljs-built_in">fprintf</span> (<span class="hljs-built_in">stderr</span>,<br>                   <span class="hljs-string">&quot;Unknown option character `\\x%x&#x27;.\n&quot;</span>,<br>                   optopt);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">abort</span> ();<br>      &#125;<br><br>  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;aflag = %d, bflag = %d, cvalue = %s\n&quot;</span>,<br>          aflag, bflag, cvalue);<br><br>  <span class="hljs-keyword">for</span> (index = optind; index &lt; argc; index++)<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Non-option argument %s\n&quot;</span>, argv[index]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>以下是一些示例，展示了该程序使用不同的参数组合打印的内容：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C">% testopt<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br><br><span class="hljs-comment">// 选项可以用空格分割</span><br>% testopt -a -b<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">1</span>, cvalue = (null)<br><br><span class="hljs-comment">// 也可以连写</span><br>% testopt -ab<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">1</span>, cvalue = (null)<br><br><span class="hljs-comment">// 必选参数，可以用空格分割</span><br>% testopt -c foo<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = foo<br><br><span class="hljs-comment">// 必选参数，可以连写</span><br>% testopt -cfoo<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = foo<br><br><span class="hljs-comment">// 没有对应的选项</span><br>% testopt arg1<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument arg1<br><br><span class="hljs-comment">// -a选项没有需要处理的参数，所以arg1无法处理</span><br>% testopt -a arg1<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument arg1<br><br>% testopt -c foo arg1<br>aflag = <span class="hljs-number">0</span>, bflag = <span class="hljs-number">0</span>, cvalue = foo<br>Non-option argument arg1<br><br>% testopt -a -- -b<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument -b<br><br>% testopt -a -<br>aflag = <span class="hljs-number">1</span>, bflag = <span class="hljs-number">0</span>, cvalue = (null)<br>Non-option argument -<br></code></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/huangxiaohu_coder/article/details/7475156">原来命令行参数处理可以这么写-getopt？_huangxiaohu_coder的博客-CSDN博客</a><br><a href="https://www.cnblogs.com/qingergege/p/5914218.html">Linux下getopt()函数的简单使用 - 青儿哥哥 - 博客园</a><br><a href="http://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html">Using Getopt (The GNU C Library)</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决VS Code终端使用git bash时中文乱码</title>
    <link href="/2022/07/16/%E8%A7%A3%E5%86%B3VS-Code%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8git-bash%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <url>/2022/07/16/%E8%A7%A3%E5%86%B3VS-Code%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8git-bash%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>Windows环境下，使用VSCode的终端时，中文显示为乱码，如使用<code>git status</code>命令查看修改文件时，中文文件名就无法正常显示：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207162158602.png"></p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>因为终端被替换成了 <code>git bash</code>，它对所有非英文的字符进行了转义。</p><p><a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-corequotePath">官方文档提到</a>：</p><p>输出路径的命令（例如<code> ls-files</code>、<code>diff</code>）将通过将路径名括在双引号中并以与 C 转义控制字符相同的方式用反斜杠转义这些字符来引用路径名中的异常字符（例如<code>\t</code>用于 <code>TAB </code>, <code>\n</code> 表示<code> LF</code>，<code>\\ </code>表示反斜杠）或值大于 <code>0x80</code> 的字节（例如，八进制 <code>\302\265</code> 表示 UTF-8 中的“micro”）。如果此变量设置为 <code>false</code>，则高于 <code>0x80</code> 的字节不再被视为异常。无论此变量的设置如何，双引号、反斜杠和控制字符总是被转义。一个简单的空格字符不被认为是异常的。许多命令可以使用 <code>-z</code> 选项完全逐字输出路径名。默认值是true。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>命令行输入，取消转义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOC(net-on-chip)总线互联构架</title>
    <link href="/2022/07/12/NOC-net-on-chip-%E6%80%BB%E7%BA%BF%E4%BA%92%E8%81%94%E6%9E%84%E6%9E%B6/"/>
    <url>/2022/07/12/NOC-net-on-chip-%E6%80%BB%E7%BA%BF%E4%BA%92%E8%81%94%E6%9E%84%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><blockquote><p>转载自^[<a href="https://blog.csdn.net/pieces_thinking/article/details/77938041">片上网络（NoC）技术的背景、意义以及发展_碎碎思的博客-CSDN博客</a>]</p></blockquote><p>在过去的几十年里，集成电路制造工艺技术、封装与测试技术、设计方法学和 EDA 工具等微电子相关技术始终保持着快速的发展。根据<a href="https://zh.wikipedia.org/zh-sg/%E5%9B%BD%E9%99%85%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE">国际半导体技术发展路线图</a>（International Technology Roadmap for Semiconductors, ITRS）预测，到 2024 年 IC 制造技术将达到 2 nm。但是，全局互连线的性能提升程度明显低于晶体管性能提升程度。受到亚阈值漏电流功耗、动态功耗、器件可靠性以及全局互连线等影响，<strong>通过提升单个处理器核的性能来提升系统整体性能已变得非常难以实现</strong>，同时芯片设计的难度和复杂度也在进一步增加。片上系统（System on Chip, SoC）具有集成度高、功耗低、成本低、体积小等优点，已经成为超大规模集成电路系统设计的主流方向。随着片上系统 SoC 的应用需求越来越丰富、越来越复杂，片上多核 MPSoC (MultiprocessorSystem on Chip, MPSoC) 已经成为发展的必然趋势，同时 MPSoC 上集成的 IP 核数量也将会按照摩尔定律继续发展。目前，MPSoC 已经逐渐应用于网络通信、多媒体等嵌入式电子设备中。半导体工艺技术的快速发展为集成电路设计提供了很大的发展空间，同时也带来了一系列新的问题和挑战，如芯片的性能、功耗、可靠性、可扩展性等等。  </p><p>随着系统性能需求越来越高，处理器核之间的互连架构必须能够提供具有较低延迟和高吞吐率的服务，并且具有良好的可扩展性。传统的基于总线的集中式互连架构已经难以满足现今系统的性能需求，而基于报文交换的<strong>片上网络（Network on Chip, NoC）</strong>逐渐成为片上多核间通讯的首选互连架构。在 NoC 中，路由节点之间通过局部互连线相连接，每一个路由节点通过网络接口 NI 与一个本地 IP 核相连接，源路由节点和目的路由节点之间的数据通讯需要经过多个跳步来实现。因此，NoC 技术的出现使得片上系统 SoC 的设计也将从以计算为中心逐渐过渡到以通讯为中心。  </p><p>传统的 SoC 系统采用总线互连结构，如 所示。虽然人们已经提出了很多改进的总线结构，例如将共享总线改进为桥接多总线结构、层次化总线结构等更复杂的结构。但是当进入 MPSoC 时代，单芯片上集成的处理器核数越来越多时，总线结构在通讯性能、功耗、全局时钟同步、信号完整性以及信号可靠性等方面面临着巨大的挑战，这些复杂的改进型总线结构仍无法解决片上多核间通信所面临的问题。因此，<strong>MPSoC 上多核间的通讯问题</strong>已经成为制约系统性能提升的<strong>主要瓶颈</strong>。  </p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713101328.png"></p><p>NoC 的概念是由 Agarwal（1999 年）、Guerrier 和 Greiner（2000 年）、Dally 和 Towles（2001 年）、Benini 和 Micheli（2002 年）、Jantsch 和 Tenhunen（2003 年）等人逐步提出的。目前，对于 NoC 还没有一个统一的定义，大多数 NoC 研究者认为 NoC 是 SoC 系统的通讯子集，并且应该引入互联网络技术来解决片上多核的通讯问题。  </p><h2 id="NoC-的意义"><a href="#NoC-的意义" class="headerlink" title="NoC 的意义"></a>NoC 的意义</h2><blockquote><p>转载自^[<a href="https://blog.csdn.net/pieces_thinking/article/details/77938041">片上网络（NoC）技术的背景、意义以及发展_碎碎思的博客-CSDN博客</a>]</p></blockquote><p>随着单芯片上集成的处理器核数越来越多，片上互连架构经历了从专用互连线，Bus，Crossbar 到 NoC。NoC 借鉴了分布式计算系统的通讯方式，采用数据路由和分组交换技术替代传统的总线结构，从体系结构上解决了 SoC 总线结构由于地址空间有限导致的可扩展性差，分时通讯引起的通讯效率低下，以及全局时钟同步引起的功耗和面积等问题。与传统的总线互连技术相比，片上网络具有如下优点：  </p><p>第一，<strong>网络带宽</strong>。总线结构互连多个 IP 核，共享一条数据总线，其缺点是同一时间只能有一对 IP 进行通信。随着系统规模的逐渐增大，总线结构的通信效率必然成为限制系统性能提升的瓶颈。片上网络具有非常丰富的信道资源，为系统提供了一个网络化的通信平台。网络中的多个节点可以同时利用网络中的不同物理链路进行信息交换，支持多个 IP 核并发地进行数据通信。随着网络规模的增大，网络上的信道资源也相应增多。因此，<strong>NoC 技术相对于 Bus 互连技术具有较高的带宽</strong>，以及更高的通信效率。当并发进行数据通信时网络会产生竞争，即会存在请求同一条物理链路的节点对。NoC 的路由节点通过分时复用物理链路来解决竞争，<strong>与 Bus 结构相比，NoC 能够降低竞争发生的概率</strong>。  </p><p>第二，<strong>可扩展性和设计成本</strong>。总线结构需要针对不同的系统需求单独进行设计，当系统功能扩展时，需要对现有的设计方案重新设计，从而严重影响设计的周期和资本投入。<strong>NoC 中每个路由节点和本地 IP 核通过网络接口（NetworkInterface, NI）相连，当系统需要升级扩展新功能时，只需要将新增加的处理器核通过网络接口 NI 接入到网络中的路由节点即可，无需重新设计网络。</strong>因此，片上网络具有良好的可扩展性。片上网络作为一个独立的片上互连结构，能够满足不同系统的应用需求，当网络中节点数量增加时，仅需要按照相应的拓扑结构规则继续增大网络的规模即可，缩短了产品的设计周期，节约了设计成本。  </p><p>第三，<strong>功耗</strong>。随着 SoC 规模的不断增大，总线上每次信息交互都需要驱动全局互连线，因此总线结构所消耗的功耗将显著增加，并且随着集成电路工艺的不断发展，想要保证全局时钟同步也将变得难以实现。而在 NoC 中，信息交互消耗的功耗与进行通讯的路由节点之间的距离密切相关，距离较近的两个节点进行通讯时消耗的功耗就比较低。  </p><p>第四，<strong>信号完整性和信号延迟</strong>。随着集成电路特征尺寸的不断减小，电路规模的不断增大，互连线的宽度和间距也在不断地减小，线间耦合电容相应增大，长的全局并行总线会引起较大的串扰噪声，从而影响信号的完整性以及信号传输的正确性。同时，互连线上的延迟将成为影响信号延迟的主要因素，总线结构全局互连线上的延迟将大于一个时钟周期，从而使得时钟的偏移很难管理。  </p><p>第五，<strong>全局同步</strong>。总线结构采用全局同步时钟，随着芯片集成度的提高，芯片的工作频率也在不断提高，在芯片内会形成很庞大的时钟树，因此很难实现片上各个模块的全局同步时钟。采用时钟树（Clock Tree）优化的方法可以改善由时钟翻转引起的时钟偏差和时钟抖动，但同步时钟网络所产生的动态功耗甚至可达总功耗的 40% 以上。为了提高系统的时钟频率，只能对全局互连线采用分布式流水线结构，或者采用全局异步局部同步（Global Asynchronous Local Synchronous,GALS）的时钟策略。 </p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>NOC</tag>
      
      <tag>总线互联构架</tag>
      
      <tag>芯片设计</tag>
      
      <tag>SoC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建和测试RISC-V架构下启用ACPI的内核</title>
    <link href="/2022/07/12/%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E5%90%AF%E7%94%A8ACPI%E7%9A%84%E5%86%85%E6%A0%B8/"/>
    <url>/2022/07/12/%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E5%90%AF%E7%94%A8ACPI%E7%9A%84%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考自<a href="https://github.com/riscv-non-isa/riscv-acpi/wiki/PoC-:-How-to-build-and-test-ACPI-enabled-kernel">PoC : How to build and test ACPI enabled kernel · riscv-non-isa/riscv-acpi Wiki</a></p></blockquote><h2 id="准备环境及工具链"><a href="#准备环境及工具链" class="headerlink" title="准备环境及工具链"></a>准备环境及工具链</h2><ol><li><p>安装RISCV工具链，需下载原发行版。好在apt可以安装。</p><blockquote><p>如果报错：riscv64-linux-gnu-gcc: error: unrecognized command line option ‘-mno-relax’; did you mean ‘-Wno-vla’?，多半是工具链原因，请按照以下方法安装！！！</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt remove gcc-riscv64-linux-gnu<br>sudo apt install gcc-8-riscv64-linux-gnu<br></code></pre></td></tr></table></figure></li><li><p>安装必要的三方库，以下为Ubuntu下的命令，其他平台可以参考<a href="https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html#prerequisites">这个文档</a>。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \<br>                gawk build-essential bison flex texinfo gperf libtool patchutils bc \<br>                zlib1g-dev libexpat-dev git<br></code></pre></td></tr></table></figure></li></ol><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>可能无法一次搭建成功，一些环境变量会经常用到，所以干脆把所有环境变量放到<code>.bashrc</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">vim ~/.bashrc<br><span class="hljs-comment"># 添加以下内容</span><br><span class="hljs-built_in">export</span> WORK_DIR=~/riscv64-acpi<br><span class="hljs-built_in">export</span> GCC5_RISCV64_PREFIX=riscv64-unknown-elf-<br><span class="hljs-built_in">export</span> MAINSPACE=~/riscv64-acpi/tianocore<br><span class="hljs-built_in">export</span> PACKAGES_PATH=<span class="hljs-variable">$MAINSPACE</span>/edk2:<span class="hljs-variable">$MAINSPACE</span>/edk2-platforms<br><span class="hljs-built_in">export</span> EDK_TOOLS_PATH=<span class="hljs-variable">$MAINSPACE</span>/edk2/BaseTools<br><br></code></pre></td></tr></table></figure><p>首先，创建一个工作目录，我们将在其中下载并构建所有源代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">source</span> ~/.bashrc<br>WORK_DIR=<span class="hljs-variable">$PWD</span>/riscv64-acpi<br>mkdir -p <span class="hljs-variable">$WORK_DIR</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span><br></code></pre></td></tr></table></figure><p>然后下载所有需要的源，它们是：<a href="https://github.com/ventanamicro/qemu/tree/dev-upstream">qemu</a>、<a href="https://github.com/ventanamicro/opensbi/tree/dev-upstream">opensbi</a>、<a href="https://github.com/ventanamicro/edk2/tree/dev-upstream">edk2</a>、<a href="https://github.com/ventanamicro/edk2-platforms/tree/dev-upstream">edk2-platforms</a>、<a href="https://github.com/ventanamicro/linux/tree/dev-upstream">linux</a>。</p><p>下载地址更换成了加速镜像源，原来地址下载太慢，容易中断。下载地址更换成了加速镜像源，原来地址下载太慢，容易中断。有两个项目包含子模块，下载容易出错，所以<code>--depth=1</code>舍弃了多余的提交记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">clone</span> --branch dev-upstream  https://hub.fastgit.xyz/ventanamicro/qemu.git qemu<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream  https://hub.fastgit.xyz/ventanamicro/opensbi.git opensbi<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream --recurse-submodules --depth=1  https://hub.fastgit.xyz/ventanamicro/edk2.git tianocore/edk2<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream --recurse-submodules --depth=1  https://hub.fastgit.xyz/ventanamicro/edk2-platforms.git  tianocore/edk2-platforms<br>git <span class="hljs-built_in">clone</span> --branch dev-upstream  https://hub.fastgit.xyz/ventanamicro/linux.git linux<br></code></pre></td></tr></table></figure><h2 id="编译构建"><a href="#编译构建" class="headerlink" title="编译构建"></a>编译构建</h2><h3 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/qemu<br>./configure --target-list=riscv64-softmmu<br>make -j $(nproc)<br></code></pre></td></tr></table></figure><h3 id="OPENSBI"><a href="#OPENSBI" class="headerlink" title="OPENSBI"></a>OPENSBI</h3><blockquote><p>此处我们使用以<code>riscv64-unknown-elf-</code>为前缀的版本，则表示该版本GCC工具链会使用newlib作为C运行库。原文使用<code>riscv64-linux-gnu-</code>，表示GCC工具链会使用Linux的Glibc作为C运行库。但是本人未编译成功。故后面编译工具均使用<code>riscv64-unknown-elf-</code>，与原文不同。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/opensbi<br>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- make PLATFORM=generic<br></code></pre></td></tr></table></figure><h3 id="EDK2-固件"><a href="#EDK2-固件" class="headerlink" title="EDK2 固件"></a>EDK2 固件</h3><blockquote><p>此处原文里设置了一些环境变量在开头我们设置了，请不要重新设置，尤其不能<code>export WORKSPACE=pwd</code>，因为与源码脚本的WORKSPACE冲突。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/tianocore<br><span class="hljs-built_in">source</span> edk2/edksetup.sh<br>make -C edk2/BaseTools clean<br>make -C edk2/BaseTools<br>make -C edk2/BaseTools/Source/C<br><span class="hljs-built_in">source</span> edk2/edksetup.sh BaseTools<br><span class="hljs-comment"># 原文使用 -buildtarget RELEASE。但是提示Not supported target RELEASE</span><br>build -a RISCV64 -b DEBUG -D FW_BASE_ADDRESS=0x80200000 -D EDK2_PAYLOAD_OFFSET -p Platform/Qemu/RiscvVirt/RiscvVirt.dsc -t GCC5<br></code></pre></td></tr></table></figure><h4 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h4><ol><li><p><strong>StoreCurrentConfiguration:7: no such file or directory: /home/user/riscv64-acpi/tianocore/Conf/BuildEnv.sh</strong></p><p> 不要设置<code>export WORKSPACE=pwd</code>！！！如果所有方法都不可行，直接把路径写死<code>export CONF_PATH=$WORK_DIR/tianocore/edk2/Conf</code></p></li><li><p><strong>uuid/uuid.h: No such file or directory</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install uuid-dev<br></code></pre></td></tr></table></figure></li><li><p><strong>Not supported target RELEASE</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 将build命令改为如下，使用DEBUG版本。</span><br>build -a RISCV64 -b DEBUG -D FW_BASE_ADDRESS=0x80200000 -D EDK2_PAYLOAD_OFFSET -p Platform/Qemu/RiscvVirt/RiscvVirt.dsc -t GCC5<br></code></pre></td></tr></table></figure></li></ol><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/linux<br>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- defconfig<br>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-elf- -j $(nproc)<br></code></pre></td></tr></table></figure><h3 id="Rootfs"><a href="#Rootfs" class="headerlink" title="Rootfs"></a>Rootfs</h3><p>您可以使用您选择的任何 rootfs。此示例使用 buildroot。</p><blockquote><p>此步耗时较久，与网络环境有关，如果网络不好可能按小时算。容易中断，需要重新下载。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/<br>git <span class="hljs-built_in">clone</span> https://hub.fastgit.xyz/buildroot/buildroot.git<br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$WORK_DIR</span>/buildroot<br>make qemu_riscv64_virt_defconfig<br>make rootfs-cpio<br></code></pre></td></tr></table></figure><h2 id="创建-EFI-分区并复制文件"><a href="#创建-EFI-分区并复制文件" class="headerlink" title="创建 EFI 分区并复制文件"></a>创建 EFI 分区并复制文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash">fallocate -l 512M efi.img<br>sgdisk -n 1:34: -t 1:EF00 <span class="hljs-variable">$WORK_DIR</span>/efi.img<br>sudo losetup -fP <span class="hljs-variable">$WORK_DIR</span>/efi.img<br>loopdev=`losetup -j <span class="hljs-variable">$WORK_DIR</span>/efi.img | awk -F: <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`<br>efi_part=<span class="hljs-string">&quot;<span class="hljs-variable">$loopdev</span>&quot;</span>p1<br>sudo mkfs.msdos <span class="hljs-variable">$efi_part</span><br>mkdir -p /tmp/mnt<br>sudo mount <span class="hljs-variable">$efi_part</span> /tmp/mnt/<br>sudo cp <span class="hljs-variable">$WORK_DIR</span>/linux/arch/riscv/boot/Image /tmp/mnt/<br>sudo umount /tmp/mnt<br>sudo losetup -D <span class="hljs-variable">$loopdev</span><br></code></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="使用-virtio-blk-磁盘"><a href="#使用-virtio-blk-磁盘" class="headerlink" title="使用 virtio-blk 磁盘"></a>使用 virtio-blk 磁盘</h3><blockquote><p>原文参数<code>-drive file=$WORK_DIR/buildroot/output/images/rootfs.ext2,format=raw,id=hd0 </code>需要更改如下。因为在编译Rootfs时的命令是<code>make rootfs-cpio</code>所以生成的是<code>rootfs.cpio</code>。无法找到<code>rootfs.ext2</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-variable">$WORK_DIR</span>/qemu/build/qemu-system-riscv64 -nographic \<br>-machine virt,aclint=on,aia=aplic-imsic,acpi=on -cpu rv64,sscofpmf=<span class="hljs-literal">true</span> -smp 8  -m 2G  \<br>-bios <span class="hljs-variable">$WORK_DIR</span>/opensbi/build/platform/generic/firmware/fw_jump.elf \<br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd  \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.cpio,format=raw,id=hd0 \<br>-device virtio-blk-device,drive=hd0 \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/efi.img,format=raw,id=hd1 \<br>-device virtio-blk-device,drive=hd1 \<br>-device virtio-net-device,netdev=usernet \<br>-netdev user,id=usernet,hostfwd=tcp::9990-:22<br></code></pre></td></tr></table></figure><h4 id="ERROR-1"><a href="#ERROR-1" class="headerlink" title="ERROR"></a>ERROR</h4><ol><li><p>无法找到<code>rootfs.ext2</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 因为在编译Rootfs时的命令是make rootfs-cpio所以生成的是rootfs.cpio</span><br><span class="hljs-comment"># 原文参数</span><br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.ext2,format=raw,id=hd0 \<br><span class="hljs-comment"># 修改为</span><br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.cpio,format=raw,id=hd0 \<br></code></pre></td></tr></table></figure></li><li><p>无法找到<code>RISCVVIRT.fd</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 因为编译EDK2固件时，参数是-b DEBUG版本，原文是RELEASE版本，这两个版本路径不一样，所以找不到</span><br><span class="hljs-comment"># 原文参数</span><br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/RELEASE_GCC5/FV/RISCVVIRT.fd  \<br><span class="hljs-comment"># 修改为</span><br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd  \<br></code></pre></td></tr></table></figure></li></ol><p>At EFI Shell:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Shell&gt; fs0:\Image root=/dev/vdb console=ttyS0 rootwait earlycon<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713153915.bmp"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713153932.bmp"></p><h3 id="使用-virtio-scsi-磁盘"><a href="#使用-virtio-scsi-磁盘" class="headerlink" title="使用 virtio-scsi 磁盘"></a>使用 virtio-scsi 磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-variable">$WORK_DIR</span>/qemu/build/qemu-system-riscv64 -nographic \<br>-machine virt,aclint=on,aia=aplic-imsic,acpi=on -cpu rv64,ssofpmf=<span class="hljs-literal">true</span> -smp 8  -m 2G \<br>-bios <span class="hljs-variable">$WORK_DIR</span>/opensbi/build/platform/generic/firmware/fw_jump.elf \<br>-kernel <span class="hljs-variable">$WORK_DIR</span>/tianocore/Build/RiscvVirt/DEBUG_GCC5/FV/RISCVVIRT.fd  \<br>-device virtio-scsi-pci,id=scsi0,num_queues=4 \<br>-device scsi-hd,drive=drive0,bus=scsi0.0,channel=0,scsi-id=0,lun=0 \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/buildroot/output/images/rootfs.cpio,format=raw,<span class="hljs-keyword">if</span>=none,id=drive0 \<br>-device virtio-scsi-pci,id=scsi1,num_queues=4 \<br>-device scsi-hd,drive=drive1,bus=scsi0.0,channel=0,scsi-id=1,lun=0 \<br>-drive file=<span class="hljs-variable">$WORK_DIR</span>/efi.img,format=raw,<span class="hljs-keyword">if</span>=none,id=drive1 \<br>-device virtio-net-device,netdev=usernet \<br>-netdev user,id=usernet,hostfwd=tcp::9990-:22<br></code></pre></td></tr></table></figure><p>At EFI Shell:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Shell&gt; fs0:\Image root=/dev/sda console=ttyS0 rootwait earlycon<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>RISC-V</tag>
      
      <tag>ACPI</tag>
      
      <tag>Kernel</tag>
      
      <tag>内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-LAB-Cache Lab</title>
    <link href="/2022/07/11/CSAPP-LAB-Cache-Lab/"/>
    <url>/2022/07/11/CSAPP-LAB-Cache-Lab/</url>
    
    <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>开始这个实验前，需要学习《CSAPP第六章-存储器层次结构》的相关内容，与缓存相关的内容，我也做了相关的<a href="https://dunky-z.github.io/2022/07/10/CPU-Cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/">CPU Cache高速缓存学习记录</a>可以参考。</p><p>实验相关的文件可以从<a href="http://csapp.cs.cmu.edu/3e/labs.html">CS:APP3e, Bryant and O’Hallaron</a>下载。</p><p>其中，</p><ul><li>README：介绍实验目的和实验要求，以及实验的相关文件。需要注意的是，必须在64-bit x86-64 system上运行实验。需要安装Valgrind工具。</li><li>Writeup：实验指导。</li><li>Release Notes：版本发布信息。</li><li>Self-Study Handout：<strong>需要下载的压缩包</strong>，里面包含了待修改的源码文件等。</li></ul><p>下载Self-Study Handout并解压，得到如下文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── cachelab.c    <span class="hljs-comment"># 一些辅助函数，如打印输出等，不需要修改</span><br>├── cachelab.h    <span class="hljs-comment"># 同上</span><br>├── csim.c        <span class="hljs-comment"># 需要完善的主文件，需要在这里模拟Cache</span><br>├── csim-ref      <span class="hljs-comment"># 已经编译好的程序，我们模拟的Cache需要与这个程序运行的结果保持一致</span><br>├── driver.py     <span class="hljs-comment"># 驱动程序，运行 test-csim 和 test-trans</span><br>├── Makefile      <span class="hljs-comment"># 用来编译csim程序</span><br>├── README        <span class="hljs-comment"># </span><br>├── test-csim     <span class="hljs-comment"># 测试缓存模拟器</span><br>├── test-trans.c  <span class="hljs-comment"># 测试转置功能</span><br>├── tracegen.c    <span class="hljs-comment"># test-trans 辅助程序</span><br>├── traces        <span class="hljs-comment"># test-csim.c 使用的跟踪文件</span><br>│   ├── dave.trace<br>│   ├── long.trace<br>│   ├── trans.trace<br>│   ├── yi2.trace<br>│   └── yi.trace<br>└── trans.c<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711145159.png"></p><h2 id="Part-A-——-Writing-A-Cache-Simulator"><a href="#Part-A-——-Writing-A-Cache-Simulator" class="headerlink" title="Part A —— Writing A Cache Simulator"></a>Part A —— Writing A Cache Simulator</h2><p>在 Part A，我们将在 <code>csim.c</code> 中编写一个缓存模拟器，它将 <code>valgrind</code> 内存跟踪作为输入，在此跟踪上模拟高速缓存的命中/未命中行为，并输出命中、未命中和驱逐的总数。</p><p>这里的输入由<code>valgrind</code>通过以下命令生成的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l<br></code></pre></td></tr></table></figure><p><code>--log-fd=1</code>表示将输出输出到标准输出；<br><code>--tool=lackey</code>：Lackey是一个简单的Valgrind工具，可进行各种基本程序测量；<br><code>--trace-mem=yes</code>：Lackey的一个参数，启用后，Lackey会打印程序几乎所有内存访问的大小和地址；<br><code>ls -l</code>：是一个简单的程序，可以查看当前目录下的文件列表。<br>也就是检测<code>ls -l</code>程序在运行时访问内存的情况。</p><p>执行结果像下面的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># [space]operation address,size</span><br>I  0400639c,4<br> L 1ffeffec00,8<br>I  040063a0,2<br> S 1ffeffea50,8<br>I  040063a2,4<br> L 1ffeffebf0,8<br>I  040063a6,3<br>I  040063a9,3<br> L 1ffeffebf8,4<br>I  040063ac,7<br></code></pre></td></tr></table></figure><p>操作字段表示内存访问的类型：<code>I</code>表示指令加载，<code>L</code>表示数据加载，<code>S</code>表示数据存储，<code>M</code>表示数据修改（即，数据加载后跟数据存储） ）。每个<code>I</code>之前都没有空格。每个<code>M</code>、<code>L</code>和<code>S</code>之前总是有一个空格。地址字段指定一个 <code>64</code> 位的十六进制内存地址。 <code>size</code> 字段指定操作访问的字节数。</p><p>了解这些基础后，<strong>我们最主要的是要明确，我们需要实现一个什么样的程序，这个程序具体有哪些参数，怎么执行的</strong>。<code>csim-ref</code>是已经完成的可执行文件，它的用法是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;<br></code></pre></td></tr></table></figure><ul><li><code>-h</code>：打印帮助信息；</li><li><code>-v</code>：显示详细信息，如是I，L还是M；</li><li><code>-s &lt;s&gt;</code>：组索引位数（$S=2^{s}$组个数）；</li><li><code>-E &lt;E&gt;</code>：关联性（每组的行数）；</li><li><code>-b &lt;b&gt;</code>：块位数（$B=2^{b}$ 是块大小）；</li><li><code>-t &lt;tracefile&gt;</code>：valgrind 生成的文件；</li></ul><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace<br>hits:4 misses:5 evictions:3<br></code></pre></td></tr></table></figure><p>如果显示详细信息可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace<br>L 10,1 miss<br>M 20,1 miss hit<br>L 22,1 hit<br>S 18,1 hit<br>L 110,1 miss eviction<br>L 210,1 miss eviction<br>M 12,1 miss eviction hit<br>hits:4 misses:5 evictions:3<br></code></pre></td></tr></table></figure><p>我们的目的就是要完善<code>csim.c</code>，使其能够使用上面相同的参数，得到与<code>csim-ref</code>相同的结果。<br><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">Cache Lab Implementa/on and Blocking</a>这份PPT里有一些实验指导，可以参考。<br>首先需要解决的就是如何处理输入的参数，我们可以使用PPT里提到的<code>getopt</code>库来解决。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;cachelab.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;getopt.h&quot;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> S; <span class="hljs-comment">// 组个数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s; <span class="hljs-comment">// 组占的位数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> E;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> B;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> hits = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> misses = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> evictions = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CacheLine</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> tag;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CacheLine</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CacheLine</span> *<span class="hljs-title">prev</span>;</span><br>&#125; CacheLine;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Cache</span> &#123;</span><br>    CacheLine *head;<br>    CacheLine *tail;<br>    <span class="hljs-keyword">int</span> *size;<br>&#125; Cache;<br><br><span class="hljs-keyword">static</span> Cache *cache;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parse_option</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **fileName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> option;<br>    <span class="hljs-keyword">while</span> ((option = getopt(argc, argv, <span class="hljs-string">&quot;s:E:b:t:&quot;</span>)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">switch</span> (option) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>            s = atoi(optarg);<br>            <span class="hljs-comment">// 传入的参数为占用的bit，需要转换为10进制</span><br>            S = <span class="hljs-number">1</span> &lt;&lt; s;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>            E = atoi(optarg);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>            B = atoi(optarg);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            <span class="hljs-built_in">strcpy</span>(*fileName, optarg);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialize_cache</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cache = <span class="hljs-built_in">malloc</span>(S * <span class="hljs-keyword">sizeof</span>(*cache));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<br>        cache[i].head = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CacheLine));<br>        cache[i].tail = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CacheLine));<br><br>        cache[i].head-&gt;next = cache[i].tail;<br>        cache[i].tail-&gt;prev = cache[i].head;<br>        (cache[i].size) = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>        *(cache[i].size) = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * @breif Add a new CacheLine to the Cache first line</span><br><span class="hljs-comment"> * @param nodeToDel CacheLine to be deleted</span><br><span class="hljs-comment"> * @param curLru  Current Cache</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert_first_line</span><span class="hljs-params">(CacheLine *node, Cache *curLru)</span></span><br><span class="hljs-function"></span>&#123;<br>    node-&gt;next = curLru-&gt;head-&gt;next;<br>    node-&gt;prev = curLru-&gt;head;<br><br>    curLru-&gt;head-&gt;next-&gt;prev = node;<br>    curLru-&gt;head-&gt;next = node;<br><br>    *(curLru-&gt;size) = *(curLru-&gt;size) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evict</span><span class="hljs-params">(CacheLine *nodeToDel, Cache *curLru)</span></span><br><span class="hljs-function"></span>&#123;<br>    nodeToDel-&gt;next-&gt;prev = nodeToDel-&gt;prev;<br>    nodeToDel-&gt;prev-&gt;next = nodeToDel-&gt;next;<br>    *(curLru-&gt;size) = *(curLru-&gt;size) - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> address)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0xFFFFFFFF</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> maskSet = mask &gt;&gt; (<span class="hljs-number">32</span> - s);<br>    <span class="hljs-comment">// 取出组索引</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> targetSet = ((maskSet) &amp; (address &gt;&gt; B));<br>    <span class="hljs-comment">// 取出标记</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> targetTag = address &gt;&gt; (s + B);<br><br>    Cache curLru = cache[targetSet];<br><br>    <span class="hljs-comment">// 查找是否存与当前标记位相同的缓存行</span><br>    CacheLine *cur = curLru.head-&gt;next;<br>    <span class="hljs-keyword">bool</span> found = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur != curLru.tail) &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;tag == targetTag) &#123;<br>            found = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (found) &#123;<br>        hits++;<br>        evict(cur, &amp;curLru);<br>        insert_first_line(cur, &amp;curLru);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; hit!, set: %d \n&quot;</span>, targetSet);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        CacheLine *newNode = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CacheLine));<br>        newNode-&gt;tag = targetTag;<br>        <span class="hljs-keyword">if</span> (*(curLru.size) == E) &#123; <span class="hljs-comment">// 如果缓存已满，则删除最后一个缓存行</span><br>            evict(curLru.tail-&gt;prev, &amp;curLru);<br>            insert_first_line(newNode, &amp;curLru);<br>            evictions++;<br>            misses++;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; evic &amp;&amp; miss set:%d\n&quot;</span>, targetSet);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            misses++;<br>            insert_first_line(newNode, &amp;curLru);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; miss %d\n&quot;</span>, targetSet);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cache_simulate</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fileName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 分配并初始化S组缓存</span><br>    initialize_cache();<br><br>    FILE *file = fopen(fileName, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">char</span> op;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(file, <span class="hljs-string">&quot; %c %x,%d&quot;</span>, &amp;op, &amp;address, &amp;size) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c, %x %d\n&quot;</span>, op, address, size);<br>        <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>            update(address);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:<br>            update(address);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>            update(address);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *fileName = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br><br>    parse_option(argc, argv, &amp;fileName);<br>    cache_simulate(fileName);<br>    printSummary(hits, misses, evictions);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>CSAPP-Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
      <tag>Linux</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU Cache高速缓存</title>
    <link href="/2022/07/10/CPU-Cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/"/>
    <url>/2022/07/10/CPU-Cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081652018.png"></p><p>从Cache、内存，到SSD和HDD硬盘，一台现代计算机中，就用上了所有这些存储器设备。其中，容量越小的设备速度越快，而且，CPU并不是直接和每一种存储器设备打交道，而是每一种存储器设备，只和它相邻的存储设备打交道。比如，CPUCache是从内存里加载而来的，或者需要写回内存，并不会直接写回数据到硬盘，也不会直接从硬盘加载数据到CPUCache中，而是先加载到内存，再从内存加载到Cache中。</p><p>这样，各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降，也就构成了我们日常所说的存储器层次结构。</p><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>缓存不是CPU的专属功能，可以把它当成一种策略，任何时候想要增加数据传输性能，都可以通过加一层缓存试试。</p><p>存储器层次结构的中心思想是，对于每个$k$，位于$k$层的更快更小的存储设备作为位于$k+1$层的更大更慢的存储设备的缓存。<a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86">下图</a>展示了存储器层次结构中缓存的一般性概念。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711145943.png"></p><div id="存储器层次结构中基本的缓存原理"></div><p>数据总是以块<code>block</code>为单位，在层与层之间来回复制。</p><p>说回高速缓存，按照摩尔定律，CPU的访问速度每18个月便会翻一翻，相当于每年增长60%。内存的访问速度虽然不断增长，却远没有那么快，每年只增长7%左右。这样就导致CPU性能和内存访问的差距不断拉大。为了弥补两者之间差异，现代CPU引入了<strong>高速缓存</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220708092012.png"></p><p>CPU的读（load）实质上就是从缓存中读取数据到寄存器（register）里，在多级缓存的架构中，如果缓存中找不到数据（Cache miss），就会层层读取二级缓存三级缓存，一旦所有的缓存里都找不到对应的数据，就要去内存里寻址了。寻址到的数据首先放到寄存器里，其副本会驻留到CPU的缓存中。</p><p>CPU的写（store）也是针对缓存作写入。并不会直接和内存打交道，而是通过某种机制实现数据从缓存到内存的写回（write back）。</p><p>缓存到底如何与CPU和主存数据交换的？CPU如何从缓存中读写数据的？缓存中没有读的数据，或者缓存写满了怎么办？我们先从CPU如何读取数据说起。</p><h2 id="缓存读取"><a href="#缓存读取" class="headerlink" title="缓存读取"></a>缓存读取</h2><p>CPU发起一个读取请求后，返回的结果会有如下几种情况：</p><ul><li>缓存命中(cache hit)<br>要读取的数据刚好在缓存中，叫做<strong>缓存命中</strong>。</li><li>缓存不命中(cache miss)<br>发送缓存不命中，缓存就得执行一直<strong>放置策略</strong>(placement policy)，比如LRU。来决定从主存中取出的数据放到哪里。<ul><li><strong>强制性不命中</strong>(compulsory miss)/冷不命中(cold miss)：缓存中没有要读取的数据，需要从主存读取数据，并将数据放入缓存。</li><li><strong>冲突不命中</strong>(conflict miss)：缓存中有要读的数据，在采取放置策略时，从主存中取数据放到缓存时发生了冲突，这叫做冲突不命中。</li></ul></li></ul><h3 id="高速缓存存储器组织结构"><a href="#高速缓存存储器组织结构" class="headerlink" title="高速缓存存储器组织结构"></a>高速缓存存储器组织结构</h3><p>整个Cache被划分为1个或多个<strong>组</strong> (Set)，$S$ 表示组的个数。每个组包含1个或多个<strong>缓存行</strong>(Cache line)，$E$ 表示一个组中缓存行的行数。每个缓存行由三部分组成：<strong>有效位</strong>(valid)，<strong>标记位</strong>（tag），<strong>数据块</strong>（cache block）。</p><ul><li>有效位：该位等于1，表示这个行数据有效。</li><li>标记位：唯一的标识了存储在高速缓存中的块，标识目标数据是否存在当前的缓存行中。</li><li>数据块：一部分内存数据的副本。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711171136.png"></p><p>Cache的结构可以由元组$(S,E,B,m)$表示。不包括有效位和标记位。Cache的大小为 $C=S \times E \times B$.</p><p>接下来看看Cache是如何工作的，当CPU执行数据加载指令，从内存地址A读取数据时，根据存储器层次原理，如果Cache中保存着目标数据的副本，那么就立即将数据返回给CPU。那么Cache如何知道自己保存了目标数据的副本呢？</p><p>假设目标地址的数据长度为$m$位，这个地址被参数 $S$ 和 $B$ 分成了三个字段：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711174416.png"></p><p>首先通过长度为$s$的<strong>组索引</strong>，确定目标数据保存在哪一个组(Set)中，其次通过长度为$t$的<strong>标记</strong>，确定在哪一行，需要注意的是此时有效位必须等于1，最后根据长度为$b$的<strong>块偏移</strong>，来确定目标数据在数据块中的确切位置。</p><blockquote><p>Q：既然读取Cache第一步是组选择，为什么不用高位作为组索引，而使用中间的为作为组索引？<br>A：如果使用了高位作索引，那么一些连续的内存块就会映射到相同的高速缓存块。如图前四个块映射到第一个缓存组，第二个四个块映射到第二个组，依次类推。如果一个程序有良好的空间局部性，顺序扫描一个数组的元素，那么在任何时候，缓存中都只保存在一个块大小的数组内容。这样对缓存的使用率很低。相比而言，如果使用中间的位作为组索引，那么相邻的块总是映射到不同的组，图中的情况能够存放整个大小的数组片。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711185819.png"></p></blockquote><h3 id="直接映射高速缓存-Direct-Mapped-Cache"><a href="#直接映射高速缓存-Direct-Mapped-Cache" class="headerlink" title="直接映射高速缓存 Direct Mapped Cache"></a>直接映射高速缓存 Direct Mapped Cache</h3><p>根据每个组的缓存行数 $E$ 的不同，Cache被分为不同的类。每个组只有一行$E=1$的高速缓存被称为<strong>直接映射高速缓存</strong>(direct-mapped cache)。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711190845.png"></p><p>当一条加载指令指示CPU从主存地址A中读取一个字w时，会将该主存地址A发送到高速缓存中，则高速缓存会根据<strong>组选择</strong>，<strong>行匹配</strong>和<strong>字抽取</strong>三步来判断地址A是否命中。</p><p><strong>组选择</strong>(set selection)：根据组索引值来确定属于哪一个组，如图中索引长度为5位，可以检索32个组($2^5=32$)。当$s=0$时，此时组选择的结果为<code>set 0</code>，当$s=1$时，此时组选择的结果为<code>set 1</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711191708.png"></p><p>**行匹配(line match)**：首先看缓存行的有效位，此时有效位为1，表示当前数据有效。然后对比缓存行的标记<code>0110</code>与地址中的标记<code>0110</code>是否相等，如果相等，则表示目标数据在当前的缓存行中（缓存命中）。如果不一致或者有效位为0，则表示目标数据不在当前的缓存行中（缓存不命中）。如果命中，就可以进行下一步字抽取。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711192435.png"></p><p>**字抽取(word extraction)**：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于<code>100</code>时，表示目标数据起始地址位于字节4处。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711192757.png"></p><p>下面通过一个例子来解释清除这个过程。假设我们有一个直接映射高速缓存，描述为$(S,E,B,m) = (4,1,2,4)$。换句话说，高速缓存有4个组，每个组1行，每个数据块2个字节，地址长度为4位。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711194256.png"></p><p>从图中可以看出，8个内存块，但只有4个高速缓存组，所以会有多个块映射到同一个高速缓存组中。例如，块0和块4都会被映射到组0。</p><p>下面我们来模拟当CPU执行一系列读的时候，高速缓存的执行情况，我们假设每次CPU读1个字节的字。</p><p><strong>读地址0(0000)的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711193901.gif"></p><p><strong>读地址1(0001)的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711194838.gif"></p><p><strong>读地址13(1101)的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711195108.gif"></p><p><strong>读地址8(1000)的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711200054.gif"></p><p><strong>读地址0(0000)的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711200409.gif"></p><h3 id="组相联高速缓存-Set-Associative-Cache"><a href="#组相联高速缓存-Set-Associative-Cache" class="headerlink" title="组相联高速缓存 Set Associative Cache"></a>组相联高速缓存 Set Associative Cache</h3><p>由于直接映射高速缓存的组中只有一行，所以容易发生冲突不命中。组相联高速缓存(Set associative cache)运行有多行缓存行。但是缓存行最大不能超过 $C/B$。 </p><p>如图一个组中包含了两行缓存行，这种我们称为2路相联高速缓存。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220712160513.png"></p><p><strong>组选择</strong>：与直接映射高速缓存的组选择过程一样。</p><p><strong>行匹配</strong>：因为一个组有多行，所以需要遍历所有行，找到一个有效位为1，并且标记为与地址中的标记位相匹配的一行。如果找到了，表示缓存命中。</p><p><strong>字抽取</strong>：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于<code>100</code>时，表示目标数据起始地址位于字节4处。</p><p>如果不命中，那么就需要从主存中取出需要的数据块，但是将数据块放在哪一行缓存行呢？如果存在空行($valid=0$)，那就放到空行里。如果没有空行，就得选择一个非空行来替换，同时希望CPU不会很快引用这个被替换的行。这里介绍几个替换策略。</p><p>最简单的方式就是随机选择一行来替换，其他复杂的方式就是利用局部性原理，使得接下来CPU引用替换的行概率最小。如</p><ul><li>最不常使用(LFU, Least Frequently Used)，选择使用次数最少的行。</li><li>最近最少使用(LRU, Least Recently Used)，选择最近使用最少的行。</li></ul><h3 id="全相联高速缓存-Fully-Associative-Cache"><a href="#全相联高速缓存-Fully-Associative-Cache" class="headerlink" title="全相联高速缓存 Fully Associative Cache"></a>全相联高速缓存 Fully Associative Cache</h3><p>整个Cache只有一个组，这个组包含了所有的缓存行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713165007.png"></p><p><strong>组选择</strong>：因为只有一个组，所有默认总是选择set 0。实际上这不就直接可以忽略了，访问的地址也就只需要划分为标记和偏移。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220713165209.png"></p><p><strong>行匹配</strong>：同组相联高速缓存。</p><p><strong>字抽取</strong>：同组相联高速缓存。</p><p>由于硬件实现及成本等原因，全相联高速缓存只适合做小规模的缓存。例如虚拟内存中的TLB（翻译备用缓存器，Translation Lookaside Buffer）。</p><h3 id="缓存写入"><a href="#缓存写入" class="headerlink" title="缓存写入"></a>缓存写入</h3><p>写入Cache的性能比写入主内存要快，那么写入数据到底是写入Cache还是写入主内存呢？如果直接写入主内存里，Cache里面的数据是否会失效呢？</p><h4 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h4><p>写直达策略（Write-Through）：当数据要写入主内存里面，写入前，会先去判断数据是否已经在Cache里面了。如果数据已经在Cache里了，先把数据写入更新到Cache里面，再写入到主内存里面；如果数据不在Cache里，就只更新主内存。</p><h4 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h4><p>写回策略（Write-Back）：如果发现要写入的数据，就在CPU Cache里面，那么就只是更新CPU Cache里面的数据。同时，会标记CPU Cache里的这个Block是脏（Dirty）的，表示CPU Cache里面的这个Block的数据，和主内存是不一致的。如果发现，要写入的数据所对应的Cache Block里，放的是别的内存地址的数据，那么就要看一看，那个Cache Block里面的数据有没有标记成脏的。如果是脏的话，要先把这个Cache Block里面的数据，写入到主内存里面。然后，再把当前要写入的数据，写入到Cache里，同时把Cache Block标记成脏的。如果Block里面的数据没有被标记成脏的话，那么直接把数据写入到Cache里面，然后再把Cache Block标记成脏的就好了。</p><p>在用了写回这个策略之后，在加载内存数据到 Cache 里面的时候，也要多出一步同步脏 Cache 的动作。如果加载内存里面的数据到 Cache 的时候，发现 Cache Block 里面有脏标记，也要先把 Cache Block 里的数据写回到主内存，才能加载数据覆盖掉 Cache。</p><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p><a href="https://dunky-z.github.io/2022/05/29/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7MESI%E5%8D%8F%E8%AE%AE/">CPU缓存一致性MESI协议 - 如云泊</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html">C/C++中volatile关键字详解 - chao_yu - 博客园</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/41806033">volatile能解决cache的数据一致性吗？答案是不能_天才2012的博客-CSDN博客_volatilewritecache</a><br><a href="https://www.cnblogs.com/xmzJava/p/11417943.html">cpu缓存和volatile - XuMinzhe - 博客园</a><br><a href="https://www.bilibili.com/video/BV18L411t7zY/?spm_id_from=333.788&vd_source=7ff88341de4b5111bdf3db48b4e9ca44">【CSAPP-深入理解计算机系统】6-5. 直接映射高速缓存_哔哩哔哩_bilibili</a><br><a href="https://cloud.tencent.com/developer/article/1815375">24张图7000字详解计算机中的高速缓存 - 腾讯云开发者社区-腾讯云</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>缓存一致性</tag>
      
      <tag>Cache</tag>
      
      <tag>组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码管理器-KeePass</title>
    <link href="/2022/07/09/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8-KeePass/"/>
    <url>/2022/07/09/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8-KeePass/</url>
    
    <content type="html"><![CDATA[<h2 id="KeePass安装"><a href="#KeePass安装" class="headerlink" title="KeePass安装"></a><strong>KeePass安装</strong></h2><p><strong>下载与安装</strong></p><p>官网： <a href="https://keepass.info/download.html">https://keepass.info/download.html</a></p><p>下载完成后进行安装，默认安装位置是：<code>C:\Program Files (x86)\KeePass Password Safe 2</code>文件夹下，可以根据自己需要选择安装路径。</p><p><strong>更改中文语言</strong></p><p>中文语言包： <a href="https://www.keepass.com.cn/language#:~:text=%E5%9C%A8keepass%E4%B8%AD%EF%BC%8C%E5%8D%95%E5%87%BB,%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8Keepass%E3%80%82">KeePass-Chinese_Simplified</a></p><p>将语言包下载后复制到安装路径下的<strong>Languages</strong>文件夹下，默认为：<strong>C:\Program Files (x86)\KeePass Password Safe 2\Languages。<strong><strong>重启软件</strong></strong>。</strong></p><p>点击 <strong>View</strong>-&gt;<strong>Change Language</strong>. 选择中文简体（Chinese-Simplified）。<strong>重启软件</strong>，即可完成语言更改。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091913508.png"></p><p>中文界面：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091913034.png"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h2><p>1.创建一个数据库</p><p>点击 文件-》新建。弹出对话框为数据库创建管理密码。这个密码是唯一需要记忆的密码。当然如果追求更高的安全性，可以点击<strong>显示高级选项</strong>，提供更多的密码选项。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091913919.png"></p><p>2.添加记录</p><p>点击添加记录，在弹出的窗口填入相关信息。即可完成密码添加。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091914888.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091914656.png"></p><p>如果是第一次使用的网站，第一次注册密码。可以通过密码生成器，生成一个高强度的密码来添加记录。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091914597.png"></p><p>3.创建一个密码生成模板</p><p>正常国内的网站可以使用的密码长度6-16位，可以使用大小写，数字，下划线。我们把这些选项勾选，密码长度设置16位。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091915434.png"></p><p>点击保存并给模板设置个名字方便下次使用</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091915338.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091915241.png"></p><p>如果保存后想更改一下，比如再加个可以使用空格，可以重新勾选刚刚的选项，保存时点击小三角，选择刚刚保存的方案就可以覆盖。</p><p><strong>导入Chrome已保存的密码</strong></p><p>很多小伙伴在使用KeePass之前肯定在Chrome等浏览器里也保存了很多密码。想将其导入KeePass方便管理。Chrome是可以导出密码的，KeePass也可以导入密码。</p><p>点击浏览器右上角，打开设置界面。找到<strong>密码</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091915807.png"></p><p>找到已保存的密码-》导出密码。选择方便找到的路径，保存密码记录。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091915014.png"></p><p>打开KeePass，点击文件-》导入，选择Chrome浏览器的格式。点击文件夹图标找到刚刚导出的密码文件。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091916436.png"></p><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><h3 id="KeePass搭配坚果云实现云同步"><a href="#KeePass搭配坚果云实现云同步" class="headerlink" title="KeePass搭配坚果云实现云同步"></a><strong>KeePass搭配坚果云实现云同步</strong></h3><p><a href="https://www.jianguoyun.com/">登录坚果云</a>创建个人同步文件夹，若没有先注册。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091916293.png"></p><p>最好单独建一个专门的文件夹</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091916684.png"></p><p>将已经生成的数据库上传到这个文件夹下</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091916021.png"></p><p>点击右上角进入<strong>账户信息，</strong>点击<strong>安全选项：</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091916935.png"></p><p>点击添加应用</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091917760.png"></p><p>输入应用名称，应用名称只是方便区分作用，所以和要同步的应用名称一致就好：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091917877.png"></p><p>点击<strong>生成密码</strong>：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091917649.png"></p><p>此时云盘端配置完成，切回到KeePass进行客户端配置。点击<strong>文件</strong>-》<strong>同步</strong>-》<strong>与网址（URL）同步</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091917478.png"></p><p><strong>网址：</strong> <a href="https://dav.jianguoyun.com/dav/">https://dav.jianguoyun.com/dav/</a><strong>KeePass</strong>/**keepassData.kdbx **</p><p><strong>注意：红色部分是个人同步文件夹的名称，绿色部分是上传的数据库全称，一定别忘了后缀</strong></p><p><strong>用户名：</strong>你的坚果云登录名（邮箱或者手机号）</p><p><strong>密码</strong>：生成应用的密码，（<strong>不是登录坚果云的密码</strong>）</p><p>点击确定，此时已经可以完成同步，但是每次同步仍然需要手动确定。参考了<a href="https://post.smzdm.com/p/660417/">什么值得买上小乐CSN</a>的方法，通过触发器实现自动同步。</p><p>触发器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;TriggerCollection xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;<br>        &lt;Triggers&gt;<br>                &lt;Trigger&gt;<br>                        &lt;Guid&gt;L2euC7Mr/EKh7nPjueuZvQ==&lt;/Guid&gt;<br>                        &lt;Name&gt;SaveSync&lt;/Name&gt;<br>                        &lt;Events&gt;<br>                                &lt;Event&gt;<br>                                        &lt;TypeGuid&gt;s6j9/ngTSmqcXdW6hDqbjg==&lt;/TypeGuid&gt;<br>                                        &lt;Parameters&gt;<br>                                                &lt;Parameter&gt;1&lt;/Parameter&gt;<br>                                                &lt;Parameter&gt;kdbx&lt;/Parameter&gt;<br>                                        &lt;/Parameters&gt;<br>                                &lt;/Event&gt;<br>                        &lt;/Events&gt;<br>                        &lt;Conditions /&gt;<br>                        &lt;Actions&gt;<br>                                &lt;Action&gt;<br>                                        &lt;TypeGuid&gt;tkamn96US7mbrjykfswQ6g==&lt;/TypeGuid&gt;<br>                                        &lt;Parameters&gt;<br>                                                &lt;Parameter&gt;SaveSync&lt;/Parameter&gt;<br>                                                &lt;Parameter&gt;0&lt;/Parameter&gt;<br>                                        &lt;/Parameters&gt;<br>                                &lt;/Action&gt;<br>                                &lt;Action&gt;<br>                                        &lt;TypeGuid&gt;Iq135Bd4Tu2ZtFcdArOtTQ==&lt;/TypeGuid&gt;<br>                                        &lt;Parameters&gt;<br>                                                &lt;Parameter&gt;https://dav.jianguoyun.com/dav/keePass/passwordSync.kdbx&lt;/Parameter&gt;<br>                                                &lt;Parameter&gt;123456&lt;/Parameter&gt;<br>                                                &lt;Parameter&gt;123456&lt;/Parameter&gt;<br>                                        &lt;/Parameters&gt;<br>                                &lt;/Action&gt;<br>                                &lt;Action&gt;<br>                                        &lt;TypeGuid&gt;tkamn96US7mbrjykfswQ6g==&lt;/TypeGuid&gt;<br>                                        &lt;Parameters&gt;<br>                                                &lt;Parameter&gt;SaveSync&lt;/Parameter&gt;<br>                                                &lt;Parameter&gt;1&lt;/Parameter&gt;<br>                                        &lt;/Parameters&gt;<br>                                &lt;/Action&gt;<br>                        &lt;/Actions&gt;<br>                &lt;/Trigger&gt;<br>        &lt;/Triggers&gt;<br>&lt;/TriggerCollection&gt;<br></code></pre></td></tr></table></figure><p>复制触发器代码，点击<strong>工具</strong>-》<strong>触发器</strong>，点击<strong>工具</strong>-》<strong>从剪切板粘贴触发器</strong>：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091918521.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091918858.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091918743.png"></p><p>导入成功后，在触发器页面会多一个触发器：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091918790.png"></p><p>双击打开<strong>SaveSync</strong>,打开最后一个<strong>动作</strong>窗口：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091918061.png"></p><p>双击中间的条目：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091919250.png"></p><p>将信息换成同步云盘的信息：</p><p><strong>文件/网址：</strong> <a href="https://dav.jianguoyun.com/dav/">https://dav.jianguoyun.com/dav/</a><strong>KeePass</strong>/**keepassData.kdbx **</p><p><strong>注意：红色部分是个人同步文件夹的名称，绿色部分是上传的数据库全称，一定别忘了后缀</strong></p><p><strong>IO 连接-用户名：</strong>你的坚果云登录名（邮箱或者手机号）</p><p><strong>IO 连接-密码</strong>：生成应用的密码，（<strong>不是登录坚果云的密码</strong>）</p><p>点击确定，回到主页面，点击<strong>工具</strong>-》<strong>选项</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091919251.png"></p><p>找到 <strong>高级</strong>，向下翻，在<strong>文件输入/输出连接</strong> 栏目里找到 <strong>写入数据库时使用文件交换</strong> 此项不勾选</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091919398.png"></p><p>点击确定，返回主页面。此时点击保存按钮或者Ctrl+S。即可与云盘进行同步。</p><h3 id="Chrome上使用插件实现密码自动填充与同步"><a href="#Chrome上使用插件实现密码自动填充与同步" class="headerlink" title="Chrome上使用插件实现密码自动填充与同步"></a><strong>Chrome上使用插件实现密码自动填充与同步</strong></h3><p>在KeePass客户端安装<a href="https://github.com/kee-org/keepassrpc/releases">KeePassRPC插件</a>：</p><p>将其放入安装目录（.\KeePass\Plugins）文件夹下，退出软件，重启即可自动安装。</p><p>在浏览器客户端安装<a href="https://chrome.google.com/webstore/detail/kee-password-manager/mmhlniccooihdimnnjhamobppdhaolme">浏览器插件</a>Kee,若无法科学上网，可能需要自行百度搜索Kee插件</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091919168.png"></p><p>安装完成后会跳出窗口提示授权，将KeePass客户端跳出的窗口中的红色授权码填入即可连接浏览器：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091920270.png"></p><p>使用Kee</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091920016.png"></p><p>再次使用浏览器填写密码是可以看到文本框会有logo，Kee会自动填写已保存的密码。如果第一次登陆，在登录后可以点击浏览器插件图标，找到Save latest login，保存刚刚输入的密码。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091920687.png"></p><p>密码管理器的重要作用之一就是生成高强度密码，可以用KeePass客户端来生成，也可以是Kee这个插件的一个生成密码功能生成。英文版的是<strong>Generate new password</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207091920769.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>volatile能否解决缓存一致性问题</title>
    <link href="/2022/07/08/volatile%E8%83%BD%E5%90%A6%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/08/volatile%E8%83%BD%E5%90%A6%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="volatile能否解决缓存一致性问题"><a href="#volatile能否解决缓存一致性问题" class="headerlink" title="volatile能否解决缓存一致性问题"></a>volatile能否解决缓存一致性问题</h1><p>为何会产生这样的疑问，还得从一个工作中的Bug说起。在使用PMP（Physical Memory Protect）对物理内存进行保护时，无法成功保护，简单来说PMP可以对一段物理内存设置保护，如保护这段内存不可写。测试时，先对这段内存写入<code>0x1234</code>，再读取这段内存。如果读取的值为<code>0x0</code>表示保护成功，但实际总能成功读取<code>0x1234</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> test;<br>test = read(<span class="hljs-number">0xFF740000</span>);<br>print(<span class="hljs-string">&quot;Before = %x\n&quot;</span>, test); <span class="hljs-comment">// 保护之前数据 Before = 0x1111 </span><br>PMP(<span class="hljs-number">0xFF740000</span>, <span class="hljs-number">0x400</span>);       <span class="hljs-comment">// 保护这段内存不可写</span><br>write(<span class="hljs-number">0xFF740000</span>, <span class="hljs-number">0x1234</span>);    <span class="hljs-comment">// 写入数据</span><br>test = read(<span class="hljs-number">0xFF740000</span>);<br>print(<span class="hljs-string">&quot;After = %x\n&quot;</span>, test);  <span class="hljs-comment">// 预期读取为0x0，实际总能成功读取0x1234</span><br></code></pre></td></tr></table></figure><p>因为读取的变量<code>test</code>设置为<code>volatile</code>，所以按照以往的理解，系统总是重新从它所在的内存读取数据，这里应该能正确读取出数据。</p><p>但是忽略了一点，当使用<code>volatile</code>变量时，CPU只是不再使用寄存器中的值，直接去内存中读取数据，这里的内存实际上是包括Cache的。</p><p>所以当数据被Cached之后，当再次读取时，CPU可能会直接读取Cached的数据，而不是去读取真正内存中的数据。因此，<strong>volatile不能解决缓存一致性问题</strong>。</p><p>关于Cache的详细信息，请参考<a href="https://dunky-z.github.io/2022/07/10/CPU-Cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/">CPU Cache高速缓存 - 如云泊</a>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>缓存一致性</tag>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZH-CS可视化-常用的Git命令</title>
    <link href="/2022/07/07/ZH-CS%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%B8%B8%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/07/ZH-CS%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%B8%B8%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="CS可视化-常用的Git命令"><a href="#CS可视化-常用的Git命令" class="headerlink" title="CS可视化-常用的Git命令"></a>CS可视化-常用的Git命令</h1><blockquote><p>Author：Lydia Hallie<br>译 ：<a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1">🌳🚀 CS Visualized: Useful Git Commands - DEV Community</a></p></blockquote><p>尽管 Git 是一个非常强大的工具，但我想大多数人都会同意，当我说它也可能是……一场彻头彻尾的噩梦当我执行某个命令时分支交互，它将如何影响历史记录？当我在<code>master</code>分支执行<code>hard reset</code>、<code>force push</code>到 <code>origin</code>、在<code>.git</code>文件夹执行<code>rimraf</code>的时候，为什么我的同事都哭了？</p><p>我认为这将是创建一些最常见和最有用命令的可视化示例的完美用例！我介绍的许多命令都有可选参数，您可以使用这些参数来更改它们的行为。在我的示例中，我将介绍命令的默认行为，而不添加（太多）配置选项！</p><h2 id="Merging"><a href="#Merging" class="headerlink" title="Merging"></a>Merging</h2><p>拥有多个分支非常方便，可以将新更改彼此分开，并确保您不会意外地将未经批准或损坏的更改推送到生产环境。一旦更改获得批准，我们希望在我们的生产分支中获得这些更改！</p><p>将更改从一个分支转移到另一个分支的一种方法是执行 <code>git merge</code>！ Git 可以执行两种类型的合并：<code>fast-forward</code> 或​​ <code>no-fast-forward</code>。</p><p>现在这可能没有多大意义，所以让我们看看差异！</p><h3 id="Fast-forward-ff"><a href="#Fast-forward-ff" class="headerlink" title="Fast-forward (--ff)"></a>Fast-forward (<code>--ff</code>)</h3><p>如果当前分支与即将合并过来的分支相比，没有额外的提交，这种就是<code>fast-forward</code>合并。Git 很会偷懒，它会首先尝试最简单的方案，即<code>fast-forward</code>。这种合并方式不会创建新的提交，只是把另一个分支的提交记录直接合并到当前分支。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707163529.gif"></p><p>完美的！我们现在可以在 <code>master</code> 分支上使用在 <code>dev</code> 分支上所做的所有更改。那么，<code>no-fast-forward</code> 到底是什么？</p><h3 id="No-fast-foward-no-ff"><a href="#No-fast-foward-no-ff" class="headerlink" title="No-fast-foward (--no-ff)"></a>No-fast-foward (<code>--no-ff</code>)</h3><p>如果与您要合并的分支相比，您当前的分支没有任何额外的提交，那就太好了，但不幸的是，这种情况很少见！如果我们在当前分支上提交了我们想要合并的分支没有的更改，Git 将执行 <code>no-fast-forward</code> 合并。</p><p>使用 <code>no-fast-forward</code> 合并，Git 在活动分支上创建一个新的<strong>合并提交</strong>。提交的父提交指向活动分支和我们要合并的分支！</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164009.gif"></p><p>没什么大不了的，完美的合并！ <code>master</code> 分支现在包含我们在 <code>dev</code> 分支上所做的所有更改。</p><h3 id="Merge-Conflicts"><a href="#Merge-Conflicts" class="headerlink" title="Merge Conflicts"></a>Merge Conflicts</h3><p>尽管 Git 擅长决定如何合并分支和向文件添加更改，但它不能总是自己做出这个决定。当我们尝试合并的两个分支在同一个文件的同一行上发生更改时，可能会发生这种情况，或者如果一个分支删除了另一个分支修改的文件，等等。</p><p>在这种情况下，Git 会要求您帮助决定我们要保留两个选项中的哪一个！假设在两个分支上，我们编辑了 <code>README.md</code> 中的第一行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164137.png"></p><p>如果我们想将 <code>dev</code> 合并到 <code>master</code> 中，这将导致合并冲突：您希望标题是 <code>Hello!</code> 还是 <code>Hey!</code>？</p><p>当试图合并分支时，Git 会告诉你冲突发生在哪里。我们可以手动删除不想保留的更改，保存更改，再次添加更改的文件，然后提交更改</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164314.gif"></p><p>耶！尽管合并冲突通常很烦人，但它完全有道理：Git 不应该自己决定选择哪一个更改。</p><h2 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h2><p>我们刚刚看到了如何通过执行 <code>git merge</code> 将更改从一个分支应用到另一个分支。另一种将更改从一个分支添加到另一个的方法是执行<code>git rebase</code>。</p><p><code>git rebase</code> <em>复制</em>当前分支的提交，并将这些复制的提交放在指定分支的顶部。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164518.gif"></p><p>完美，我们现在可以在 <code>dev</code> 分支上使用在 <code>master</code> 分支上所做的所有更改！</p><p>与合并相比，一个很大的区别是 Git 不会尝试找出要保留和不保留的文件。我们正在变基的分支总是有我们想要保留的最新更改！通过这种方式，您不会遇到任何合并冲突，并保持良好的线性 Git 历史记录。</p><p>这个例子展示了基于 <code>master</code> 分支的变基。然而，在更大的项目中，您通常不想这样做。 <code>git rebase</code> <strong>改变了项目的历史</strong>，因为为复制的提交创建了新的哈希！</p><p>每当您在功能分支上工作并且主分支已更新时，重新定基都很棒。您可以获得分支上的所有更新，这将防止未来的合并冲突！</p><h3 id="Interactive-Rebase"><a href="#Interactive-Rebase" class="headerlink" title="Interactive Rebase"></a>Interactive Rebase</h3><p>在重新提交提交之前，我们可以修改它们！我们可以使用 <em>interactive rebase</em> 来做到这一点。交互式变基对于您当前正在处理的分支也很有用，并且想要修改一些提交。</p><p>我们可以对我们正在变基的提交执行 6 项操作：</p><ul><li><code>reword</code>: Change the commit message</li><li><code>edit</code>: Amend this commit</li><li><code>squash</code>: Meld commit into the previous commit</li><li><code>fixup</code>: Meld commit into the previous commit, without keeping the commit’s log message</li><li><code>exec</code>: Run a command on each commit we want to rebase</li><li><code>drop</code>: Remove the commit</li></ul><p>惊人的！这样，我们可以完全控制我们的提交。如果我们想删除一个提交，我们可以直接 <code>drop</code> 它。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164621.gif"></p><p>或者，如果我们想将多个提交压缩在一起以获得更清晰的历史记录，没问题！</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707164900.gif"></p><p>交互式变基使您可以对尝试变基的提交进行大量控制，即使在当前活动分支上也是如此！</p><h2 id="Resetting"><a href="#Resetting" class="headerlink" title="Resetting"></a>Resetting</h2><p>我们可能会提交我们以后不想要的更改。也许它是一个<code>WIP</code>提交，或者是一个引入错误的提交！在这种情况下，我们可以执行 <code>git reset</code>。</p><p><code>git reset</code> 会删除所有当前暂存的文件，并让我们控制 <code>HEAD</code> 应该指向的位置。</p><h3 id="Soft-reset"><a href="#Soft-reset" class="headerlink" title="Soft reset"></a>Soft reset</h3><p><em>软重置</em>将 <code>HEAD</code> 移动到指定的提交（或提交的索引与 <code>HEAD</code> 相比），而不会消除随后在提交中引入的更改！</p><p>假设我们不想保留添加了<code>style.css</code>文件的提交<code>9e78i</code>，也不想保留添加了<code>index.js</code>文件的提交<code>035cc</code>。但是，我们确实希望保留新添加的 <code>style.css</code> 和 <code>index.js</code> 文件！软重置的完美用例。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707165037.gif"></p><p>输入 <code>git status</code> 时，您会看到我们仍然可以访问对先前提交所做的所有更改。这很棒，因为这意味着我们可以修复这些文件的内容并在以后再次提交它们！</p><h3 id="Hard-reset"><a href="#Hard-reset" class="headerlink" title="Hard reset"></a>Hard reset</h3><p>有时，我们不想保留某些提交引入的更改。与软重置不同，我们不再需要访问它们。 Git 应该简单地将其状态重置回指定提交时的状态：这甚至包括工作目录和暂存文件中的更改！</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707165117.gif"></p><p>Git 丢弃了在 <code>9e78i</code> 和 <code>035cc</code> 上引入的更改，并将其状态重置为提交 <code>ec5be</code> 时的状态。</p><h3 id="Reverting"><a href="#Reverting" class="headerlink" title="Reverting"></a>Reverting</h3><p>撤消更改的另一种方法是执行<code>git revert</code>。通过恢复某个提交，我们创建了一个包含恢复的更改的新提交！</p><p>假设 <code>ec5be</code> 添加了一个 <code>index.js</code> 文件。后来，我们实际上意识到我们不再希望这次提交引入的这种变化！让我们恢复 <code>ec5be</code> 提交。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707165159.gif"></p><p>完美的！提交<code>9e78i</code>恢复了由<code>ec5be</code>提交引入的更改。执行 <code>git revert</code> 非常有用，可以撤消某个提交，而无需修改分支的历史记录。</p><h2 id="Cherry-picking"><a href="#Cherry-picking" class="headerlink" title="Cherry-picking"></a>Cherry-picking</h2><p>当某个分支包含在活动分支上引入了我们需要的更改的提交时，我们可以 <code>cherry-pick</code> 该命令！通过 <code>cherry-pick</code> 提交，我们在活动分支上创建了一个新提交，其中包含由 <code>cherry-pick</code> 提交所引入的更改。</p><p>假设 <code>dev</code> 分支上的提交 <code>76d12</code> 添加了我们想要在 <code>master</code> 分支中的 <code>index.js</code> 文件的更改。我们不想要<em>整个</em>，我们只关心这一次提交！</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707170039.gif"></p><p>很酷，<code>master</code> 分支现在包含了 <code>76d12</code> 引入的更改！</p><h2 id="Fetching"><a href="#Fetching" class="headerlink" title="Fetching"></a>Fetching</h2><p>如果我们有一个远程 Git 分支，例如 Github 上的一个分支，则可能会发生远程分支具有当前分支没有的提交！也许另一个分支被合并了，你的同事推送了一个快速修复，等等。</p><p>我们可以通过在远程分支上执行 <code>git fetch</code> 在本地获取这些更改！它不会以任何方式影响您的本地分支：<code>fetch</code> 只是下载新数据。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707170120.gif"></p><p>我们现在可以看到自上次推送以来所做的所有更改！既然我们在本地拥有新数据，我们就可以决定要如何处理这些数据。</p><h2 id="Pulling"><a href="#Pulling" class="headerlink" title="Pulling"></a>Pulling</h2><p>虽然 <code>git fetch</code> 对于获取分支的远程信息非常有用，但我们也可以执行 <code>git pull</code>。 <code>git pull</code> 实际上是两个命令合二为一：<code>git fetch</code> 和 <code>git merge</code>。当我们从源中提取更改时，我们首先像使用 <code>git fetch</code> 一样获取所有数据，之后最新的更改会自动合并到本地分支中。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707170157.gif"></p><p>太棒了，我们现在与远程分支完美同步，并拥有所有最新更改！</p><h2 id="Reflog"><a href="#Reflog" class="headerlink" title="Reflog"></a>Reflog</h2><p>每个人都会犯错，这完全没关系！有时你可能会觉得你把你的 <code>git repo</code> 搞砸了，以至于你只想完全删除它。</p><p><code>git reflog</code> 是一个非常有用的命令，用于显示所有已采取的操作的日志！这包括合并、重置、恢复：基本上是对分支的任何更改。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707170250.gif"></p><p>如果您犯了错误，您可以根据 <code>reflog</code> 提供给我们的信息通过重置 <code>HEAD</code> 轻松地重做此操作！</p><p>假设我们实际上并不想合并 <code>origin</code> 分支。当我们执行 <code>git reflog</code> 命令时，我们看到合并前 repo 的状态是在 <code>HEAD@&#123;1&#125;</code>。让我们执行 <code>git reset</code> 将 HEAD 指向它在 <code>HEAD@&#123;1&#125;</code> 上的位置！</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220707170316.gif"></p><p>我们可以看到最新的action已经推送到<code>reflog</code>了！</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言数组/结构体/结构体数组/联合体初始化</title>
    <link href="/2022/06/30/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84-%E7%BB%93%E6%9E%84%E4%BD%93-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-%E8%81%94%E5%90%88%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2022/06/30/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84-%E7%BB%93%E6%9E%84%E4%BD%93-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-%E8%81%94%E5%90%88%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">6</span>] = &#123; [<span class="hljs-number">0</span>]=<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>, [<span class="hljs-number">3</span>] =<span class="hljs-number">10</span>, [<span class="hljs-number">4</span>]=<span class="hljs-number">11</span> &#125;; 或<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">6</span>] = &#123; [<span class="hljs-number">0</span>]=<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, [<span class="hljs-number">3</span>] =<span class="hljs-number">10</span>, <span class="hljs-number">11</span> &#125;; 或<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">6</span>] = &#123; [<span class="hljs-number">3</span>] =<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, [<span class="hljs-number">0</span>]=<span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;; (指定顺序可变)<br>均等效于：<span class="hljs-keyword">int</span> arr[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>Note: </p><ol><li>若在某个指定初始化项目后跟有不至一个值，如<code>[3]=10,11</code>。则多出的数值用于对后续的数组元素进行初始化，即数值11用来初始化arr[4]。</li><li>C数组初始化一个或多个元素后，未初始化的元素将被自动地初始化为0或NULL(针对指针变量)。未经过任何初始化的数组，所有元素的值都是不确定的。</li></ol><p>GNU C还支持<code>[first … last]=value</code>(<code>…</code><strong>两侧有空格</strong>)的形式，将该范围内的若干元素初始化为相同值。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> arr[]=&#123; [<span class="hljs-number">0</span> ... <span class="hljs-number">3</span>]=<span class="hljs-number">1</span>, [<span class="hljs-number">4</span> ... <span class="hljs-number">5</span>]=<span class="hljs-number">2</span>, [<span class="hljs-number">6</span> ... <span class="hljs-number">9</span>] =<span class="hljs-number">3</span>&#125;; 或<br><span class="hljs-keyword">int</span> arr[]=&#123; [<span class="hljs-number">0</span> ... <span class="hljs-number">3</span>]=<span class="hljs-number">1</span>, [<span class="hljs-number">4</span> ... <span class="hljs-number">5</span>]=<span class="hljs-number">2</span>, [<span class="hljs-number">6</span> ... <span class="hljs-number">8</span>] =<span class="hljs-number">3</span>, [<span class="hljs-number">9</span>] =<span class="hljs-number">3</span>&#125;;<br>均等效于：<span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><p>对于结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span>&#123;</span> <span class="hljs-keyword">int</span> a; <span class="hljs-keyword">int</span> b; &#125;; 或<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span>&#123;</span> <span class="hljs-keyword">int</span> a, b; &#125;;<br></code></pre></td></tr></table></figure><p>有以下几种初始化方式：<br>用<code>.fieldname=指定待初始化成员名</code>(成员初始化顺序可变)，<strong>推荐使用的方式</strong>，该方式初始化时不必严格按照定义时的顺序，灵活性很高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span> <span class="hljs-title">tStct</span> =</span> &#123;<br>    .a = <span class="hljs-number">1</span>,<br>    .b = <span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>用<code>fieldname:指定待初始化成员名</code>(成员初始化顺序可变)，GCC 2.5已废除，但仍接受</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span> <span class="hljs-title">tStct</span> =</span> &#123;<br>    a : <span class="hljs-number">1</span>,<br>    b : <span class="hljs-number">2</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>用初始化列表初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span> <span class="hljs-title">tStct</span> =</span> &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br></code></pre></td></tr></table></figure><h2 id="结构体数组初始化"><a href="#结构体数组初始化" class="headerlink" title="结构体数组初始化"></a>结构体数组初始化</h2><p>方法一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Structure</span> <span class="hljs-title">ptStct</span>[10] =</span> &#123;<br>     [<span class="hljs-number">2</span>].b = <span class="hljs-number">0x2B</span>, [<span class="hljs-number">2</span>].a = <span class="hljs-number">0x2A</span>,<br>     [<span class="hljs-number">0</span>].a = <span class="hljs-number">0x0A</span> &#125;;<br></code></pre></td></tr></table></figure><p>方法二：该方法可以用于清除结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">memset</span>(ptStct, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct Structure) * <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="联合体初始化"><a href="#联合体初始化" class="headerlink" title="联合体初始化"></a>联合体初始化</h2><p>可用<code>.fieldname</code>(或已废弃的<code>fieldname:</code>)指示符来指定使用联合体的哪个元素，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">UnionT</span> &#123;</span> <span class="hljs-keyword">int</span> i; <span class="hljs-keyword">double</span> d; &#125;;<br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">UnionT</span> <span class="hljs-title">tUnion</span> =</span> &#123; .d = <span class="hljs-number">4</span> &#125;;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-watch周期执行命令</title>
    <link href="/2022/06/09/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-watch%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/06/09/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-watch%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>  watch命令的功能如其名，可以监视命令的执行结果。它实现的原理就是每隔一段时间执行一次命令，然后显示结果。他的用途很广，具体怎么用就靠想象力了。</p><h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">n <span class="hljs-comment"># 或--interval  watch默认每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。</span></span><br><span class="ruby"></span>-<span class="ruby">d <span class="hljs-comment"># 或--differences  用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。</span></span><br><span class="ruby"></span>-<span class="ruby">t <span class="hljs-comment"># 或-no-title  会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。</span></span><br><span class="ruby"></span>-<span class="ruby">h <span class="hljs-comment"># 或--help # 查看帮助文档</span></span><br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">watch</span> -d <span class="hljs-string">&#x27;ls -l | grep tmp&#x27;</span>       <span class="hljs-comment"># 监测当前目录中 scf&#x27; 的文件的变化</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git hooks钩子的使用</title>
    <link href="/2022/05/30/Git-hooks%E9%92%A9%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/05/30/Git-hooks%E9%92%A9%E5%AD%90%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-huoks"><a href="#Git-huoks" class="headerlink" title="Git huoks"></a>Git huoks</h1><h2 id="Git-hooks简介"><a href="#Git-hooks简介" class="headerlink" title="Git hooks简介"></a>Git hooks简介</h2><p>Git 能在特定的重要动作发生时触发自定义脚本。比如，<code>commit</code>之前检查<code>commit message</code>是否符合约定的格式，<code>push</code>之前检查代码格式是否正确，是否编译通过等等。Git就提供了<code>hooks</code>这样的机制。</p><p>我们在哪能找到<code>hooks</code>呢？在初始化代码仓库<code>git init</code>时，Git会自动为我们创建一个<code>.git/hooks</code>目录，里面存放了所有的钩子。因为<code>.git</code>是隐藏目录，显示隐藏目录后就可以找到<code>hooks</code>这个目录。</p><p>在VSCode里一般默认把<code>.git</code>目录排除显示，所以打开项目目录时不会显示该目录，我们可以收到在VSCode显示<code>.git</code>目录：</p><p>打开设置界面，搜索<code>exclude</code>找到图中的设置，将<code>.git</code>目录从排除列表中移除，即可在VSCode中显示<code>.git</code>目录。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220530134106.png"></p><p>现在我们找到了<code>hooks</code>，该如何使用呢？</p><p>所有默认的<code>hooks</code>都是以<code>.sample</code>为后缀，只需要移除<code>.sample</code>即可激活<code>hooks</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220530154954.png"></p><p>随便打开一个<code>hooks</code>文件，我们可以发现，实际是<code>hooks</code>就是一个个<code>shell</code>脚本。这些脚本会在特定的动作发生时被执行。示范的这些<code>hooks</code>都是<code>shell</code>脚本，<strong>实际上只要是文件名正确的可执行脚本都可以使用</strong>，如将<code>pre-push</code>内容改为<code>python, Ruby</code>等等脚本都可以。</p><h2 id="使用一个hooks"><a href="#使用一个hooks" class="headerlink" title="使用一个hooks"></a>使用一个hooks</h2><p>以<code>pre-commit</code>这个<code>hooks</code>为例，来示范一下如何使用Git hooks。</p><ul><li>打开<code>.git/hooks/pre-commit.sample</code>，这个<code>hooks</code>的大体功能是检查文件名是否包含非<code>ASCII</code>字符，如果包含，则无法执行<code>commit</code>操作，并提示用户修改文件名。</li><li>删除<code>pre-commit.sample</code>的后缀  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜ mv .git<span class="hljs-regexp">/hooks/</span>pre-commit.sample .git<span class="hljs-regexp">/hooks/</span>pre-commit<br></code></pre></td></tr></table></figure></li><li>添加一个有汉字的文件名，如<code>测试.md</code>  <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">➜  touch 测试.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure></li><li>将新文件提交  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">➜ git <span class="hljs-built_in">add</span> 测试.md<br>➜ git commit -m <span class="hljs-string">&quot;测试&quot;</span><br>Error: Attempt <span class="hljs-built_in">to</span> <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> non-ASCII <span class="hljs-built_in">file</span> name.<br><br>This can cause problems <span class="hljs-keyword">if</span> you want <span class="hljs-built_in">to</span> work <span class="hljs-keyword">with</span> people <span class="hljs-keyword">on</span> <span class="hljs-title">other</span> <span class="hljs-title">platforms</span>.<br><br>To be portable <span class="hljs-keyword">it</span> is advisable <span class="hljs-built_in">to</span> <span class="hljs-built_in">rename</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span>.<br><br>If you know what you are doing you can disable this check <span class="hljs-keyword">using</span>:<br><br>git config hooks.allownonascii <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>如果无法执行<code>pre-commit</code>可能未被赋予执行权限，修改一下权限即可：<code>chmod +x .git/hooks/pre-commit</code></p></blockquote></li></ul><p>我们可以发现，在进行<code>commit</code>操作时被中断了，会提示用户修改文件名。其他的<code>hooks</code>用法类似，我们可以自定义在什么时候可以<code>push</code>，什么时候可以<code>rebase</code>等等。</p><p><code>hooks</code>通常会被用来做提交代码前的一个检查，比如风格是否统一，编译是否通过等等。如果团队合作时，这样的检查最好能够与成员保持一致，但是<code>hooks</code>所在的<code>.git</code>目录是不会被Git自己版本管理的，换句话说，它不能推送到远端与成员共享。那么如何解决这个问题呢？</p><h2 id="如何同步hooks文件"><a href="#如何同步hooks文件" class="headerlink" title="如何同步hooks文件"></a>如何同步hooks文件</h2><h3 id="方案一：与源码放在一起"><a href="#方案一：与源码放在一起" class="headerlink" title="方案一：与源码放在一起"></a>方案一：与源码放在一起</h3><p>代码仓库中新建一个<code>hooks</code>目录，将该目录同步到远程。其他成员下载代码时也会下载<code>hooks</code>目录，通过脚本的方式将<code>hooks</code>目录覆盖本地的<code>.git/hooks</code>目录。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/bin/bash</span><br>cp -r .<span class="hljs-regexp">/hooks/</span> .git<span class="hljs-regexp">/hooks/</span><br>chmod +x -R .git/hooks<br>echo <span class="hljs-string">&#x27;Hooks sync to remote success!&#x27;</span><br><span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="方案二：使用pre-commit框架"><a href="#方案二：使用pre-commit框架" class="headerlink" title="方案二：使用pre_commit框架"></a>方案二：使用pre_commit框架</h3><p><code>pre_commit</code> 是 <code>pre-commit</code> 同名的开源应用，使用<code>pre_commit</code>，代码仓库里只需要有一个配置文件，所有成员都可以根据配置文件，使用<code>pre_commit</code>生成统一的<code>hooks</code>。</p><p><code>pre_commit</code>随着发展，已经不单单只能用于<code>git hooks的pre-commit</code>阶段，而是能作用于所有<code>git hooks</code>的所有阶段，如上面说的<code>prepare-commit-msg</code>, <code>commit-msg</code>, <code>post-commi</code>等。</p><p>安装pre_commit</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pre-commit<br></code></pre></td></tr></table></figure><p>添加配置文件 <code>.pre-commit-config.yaml</code> </p><ul><li><p>首先了解配置的格式</p><ul><li>顶层有一个参数名为 <code>repos</code></li><li><code>repos</code> 中每个元素为 <code>repo</code> ，代表一个代码库，一般是<code>github</code>或<code>gitlab</code>链接。在使用时会从对应地址下载，如果出现下载慢的情况，可以在<code>gitee</code>搜索是否有相关镜像。</li><li>每个 <code>repo</code> 中有一个或多个 <code>hook</code> ，每个 <code>hook</code> 代表一个任务。</li><li>每个任务里可理解为一个命令行指令，例如<code>flake8/yapf/black</code>。</li></ul></li><li><p><code>pre_commit</code>官方提供了<a href="https://pre-commit.com/hooks.html">各种配置</a>，我们可以根据需要选择一个合适的。比如我需要一个格式化C语言代码的配置，选择了<a href="https://github.com/pocc/pre-commit-hooks">pocc/pre-commit-hooks</a></p>  <figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-attribute">fail_fast</span>: <span class="hljs-literal">false</span><br><span class="hljs-attribute">repos</span>:<br>- <span class="hljs-attribute">repo</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/pocc/pre-commit-hooks</span><br>    <span class="hljs-attribute">rev</span>: master<br>    <span class="hljs-attribute">hooks</span>:<br>    - <span class="hljs-attribute">id:</span><span class="hljs-string"> clang</span>-format<br>        <span class="hljs-attribute">args</span>: [--style=Google]<br>    - <span class="hljs-attribute">id:</span><span class="hljs-string"> clang</span>-tidy<br>    - <span class="hljs-attribute">id:</span><span class="hljs-string"> oclint</span><br>    - <span class="hljs-attribute">id:</span><span class="hljs-string"> uncrustify</span><br>    - <span class="hljs-attribute">id:</span><span class="hljs-string"> cppcheck</span><br>    - <span class="hljs-attribute">id:</span><span class="hljs-string"> cpplint</span><br>    - <span class="hljs-attribute">id:</span><span class="hljs-string"> include</span>-what-you-use<br></code></pre></td></tr></table></figure><p>  参数的含义可以参考<a href="https://pre-commit.com/#pre-commit-configyaml---top-level">pre-commit</a>的文档。</p></li><li><p>根据配置文件安装<code>hooks</code><br>  在项目根目录下运行：</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pre-commit <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure></li><li><p>在执行<code>git commit</code>命令时将会自动检查。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/irving512/article/details/124377109">C++ 项目中使用 Pre-commit 协助实现代码规范检查_清欢守护者的博客-CSDN博客</a><br><a href="https://www.jianshu.com/p/7951ff907ccb">git push之前自动编译验证 - 简书</a><br><a href="https://blog.csdn.net/irving512/article/details/108701017">使用 pre-commit 实现代码检查_清欢守护者的博客-CSDN博客</a><br><a href="https://pre-commit.com/#pre-commit-configyaml---top-level">pre-commit</a><br><a href="https://www.bilibili.com/video/BV1eZ4y1G7hh/?spm_id_from=333.788">Git基本原理介绍(32)——git hook和python_哔哩哔哩_bilibili</a></p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU缓存一致性MESI协议</title>
    <link href="/2022/05/29/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7MESI%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/05/29/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7MESI%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要缓存一致"><a href="#为什么需要缓存一致" class="headerlink" title="为什么需要缓存一致"></a>为什么需要缓存一致</h2><p>目前主流电脑的CPU都是多核心的，多核心的有点就是在不能提升CPU主频后，通过增加核心来提升CPU吞吐量。每个核心都有自己的L1 Cache和L2 Cache，只是共用L3 Cache和主内存。每个核心操作是独立的，每个核心的Cache就不是同步更新的，这样就会带来缓存一致性（Cache Coherence）的问题。</p><p>举个例子，如图：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205291536919.gif"></p><p>有2个CPU，主内存里有个变量<code>x=0</code>。CPU A中有个需要将变量<code>x</code>加<code>1</code>。CPU A就将变量<code>x</code>加载到自己的缓存中，然后将变量<code>x</code>加<code>1</code>。因为此时CPU A 还未将缓存数据写回主内存，CPU B再读取变量<code>x</code>时，变量<code>x</code>的值依然是<code>0</code>。</p><p>这里的问题就是所谓的缓存一致性问题，因为CPU A的缓存与CPU B的缓存是不一致的。</p><h2 id="如何解决缓存一致性问题"><a href="#如何解决缓存一致性问题" class="headerlink" title="如何解决缓存一致性问题"></a>如何解决缓存一致性问题</h2><h3 id="通过在总线加LOCK锁的方式"><a href="#通过在总线加LOCK锁的方式" class="headerlink" title="通过在总线加LOCK锁的方式"></a>通过在总线加LOCK锁的方式</h3><p>在锁住总线上加一个LOCK标识，CPU A进行读写操作时，锁住总线，其他CPU此时无法进行内存读写操作，只有等解锁了才能进行操作。</p><p>该方式因为锁住了整个总线，所以效率低。</p><h3 id="缓存一致性协议MESI"><a href="#缓存一致性协议MESI" class="headerlink" title="缓存一致性协议MESI"></a>缓存一致性协议MESI</h3><p>该方式对单个缓存行的数据进行加锁，不会影响到内存其他数据的读写。</p><p>在学习MESI协议之前，简单了解一下总线嗅探机制（Bus Snooping）。要对自己的缓存加锁，需要通知其他CPU，多个 CPU 核心之间的数据传播问题。最常见的一种解决方案就是总线嗅探。</p><p>这个策略，本质上就是把所有的读写请求都通过总线广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。MESI就是基于总线嗅探机制的缓存一致性协议。</p><p>MESI 协议的由来是对Cache Line 的四个不同的标记，分别是：</p><table><thead><tr><th align="center"><div style="width:50px">状态</div></th><th align="center"><div style="width:100px">状态</div></th><th><div style="width:200px">描述</div></th><th><div style="width:200px">监听任务</div></th></tr></thead><tbody><tr><td align="center">Modified</td><td align="center">已修改</td><td>该 Cache Line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中</td><td>Cache Line 必须时刻监听所有试图读该 Cache Line 相对于主存的操作，这种操作必须在缓存将该 Cache Line 写回主存并将状态改为S状态之前，被延迟执行</td></tr><tr><td align="center">Exclusive</td><td align="center">独享，互斥</td><td>该 Cache Line 有效，数据和内存中的数据一直，数据只存在于本 Cache</td><td>Cache Line 必须监听其他缓存读主存中该 Cache Line 的操作，一旦有这种操作，该 Cache Line 需要改为S状态</td></tr><tr><td align="center">Shared</td><td align="center">共享的</td><td>该 Cache Line 有效，数据和内存中的数据一直，数据存在于很多个 Cache 中</td><td>Cache Line 必须监听其他  Cache Line 使该 Cache Line 无效或者独享该 Cache Line 的请求，并将 Cache Line 改为I状态</td></tr><tr><td align="center">Invalid</td><td align="center">无效的</td><td>该 Cache Line 无效</td><td>无</td></tr></tbody></table><p>整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把各个状态之间的流转用表格总结了一下：</p><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:300px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">M</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">M</td></tr><tr><td align="center">M</td><td align="center">Local Write</td><td>修改cache数据，状态不变</td><td align="center">M</td></tr><tr><td align="center">M</td><td align="center">Remote Read</td><td>这行数据被写到内存中，使其他核能使用到最新数据，状态变为S</td><td align="center">S</td></tr><tr><td align="center">M</td><td align="center">Remote Write</td><td>这行数据被写入内存中，其他核可以获取到最新数据，由于其他CPU修改该条数据，则本地Cache变为I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">E</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">E</td></tr><tr><td align="center">E</td><td align="center">Local Write</td><td>修改数据，状态改为M</td><td align="center">M</td></tr><tr><td align="center">E</td><td align="center">Remote Read</td><td>数据和其他CPU共享，变为S</td><td align="center">S</td></tr><tr><td align="center">E</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,text-align: center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">S</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">S</td></tr><tr><td align="center">S</td><td align="center">Local Write</td><td>修改数据，状态改为M，其他CPU的Cache Line状态改为I</td><td align="center">M</td></tr><tr><td align="center">S</td><td align="center">Remote Read</td><td>数据和其他CPU共享，状态不变</td><td align="center">S</td></tr><tr><td align="center">S</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">I</td><td align="center">Local Read</td><td>1. 如果其他CPU没有这份数据，直接从内存中加载数据，状态变为E；<br> 2. 如果其他CPU有这个数据，且Cache Line状态为M，则先把Cache Line中的内容写回到主存。本地Cache再从内存中读取数据，这时两个Cache Line的状态都变为S；<br>3. 如果其他Cache Line有这份数据，并且状态为S或者E，则本地Cache Line从主存读取数据，并将这些Cache Line状态改为S</td><td align="center">E或者S</td></tr><tr><td align="center">I</td><td align="center">Local Write</td><td>1. 先从内存中读取数据，如果其他Cache Line中有这份数据，且状态为M，则现将数据更新到主存再读取，将Cache Line状态改为M；<br> 2. 如果其他Cache Line有这份数据，且状态为E或者S，则其他Cache Line状态改为I</td><td align="center">M</td></tr><tr><td align="center">I</td><td align="center">Remote Read</td><td>数据和其他CPU共享，状态不变</td><td align="center">S</td></tr><tr><td align="center">I</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为I</td><td align="center">I</td></tr></tbody></table><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>计算机组成原理</tag>
      
      <tag>CPU</tag>
      
      <tag>MESI协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode设置终端为Gitbash</title>
    <link href="/2022/05/24/VSCode%E8%AE%BE%E7%BD%AE%E7%BB%88%E7%AB%AF%E4%B8%BAGitbash/"/>
    <url>/2022/05/24/VSCode%E8%AE%BE%E7%BD%AE%E7%BB%88%E7%AB%AF%E4%B8%BAGitbash/</url>
    
    <content type="html"><![CDATA[<h2 id="设置终端为Gitbash"><a href="#设置终端为Gitbash" class="headerlink" title="设置终端为Gitbash"></a>设置终端为Gitbash</h2><p>用惯了Linux终端的命令，Windows的shell真的太不顺手了，但是Gitbash很多命令相似，可以将默认的shell换成Gitbash。</p><p>打开<code>settings.json</code>配置文件，添加如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;terminal.integrated.profiles.windows&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;PowerShell -NoProfile&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;source&quot;</span>: <span class="hljs-string">&quot;PowerShell&quot;</span>,<br>      <span class="hljs-attr">&quot;args&quot;</span>: [<br>        <span class="hljs-string">&quot;-NoProfile&quot;</span><br>      ]<br>    &#125;,<br>    <span class="hljs-attr">&quot;Git-Bash&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;D:\\Software\\Git\\bin\\bash.exe&quot;</span>, <span class="hljs-comment">//bin路径下的bash，不是git-bash.exe。否则会打开外部窗口</span><br>      <span class="hljs-attr">&quot;args&quot;</span>: []<br>    &#125;<br>  &#125;,<br><span class="hljs-string">&quot;terminal.integrated.defaultProfile.windows&quot;</span>: <span class="hljs-string">&quot;Git-Bash&quot;</span>,<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301517302.png"></p><h2 id="修改终端配色"><a href="#修改终端配色" class="headerlink" title="修改终端配色"></a>修改终端配色</h2><p>打开<a href="https://glitchbone.github.io/vscode-base16-term/#/">Base16 Terminal Colors for Visual Studio Code</a>，选择一款配置复制</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301515778.png"></p><p>打开VScode<code>settings.json</code>，替换如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;workbench.colorCustomizations&quot;</span>: &#123;<br>       <span class="hljs-attr">&quot;terminal.background&quot;</span>:<span class="hljs-string">&quot;#1C2023&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.foreground&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminalCursor.background&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminalCursor.foreground&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBlack&quot;</span>:<span class="hljs-string">&quot;#1C2023&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBlue&quot;</span>:<span class="hljs-string">&quot;#AE95C7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightBlack&quot;</span>:<span class="hljs-string">&quot;#747C84&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightBlue&quot;</span>:<span class="hljs-string">&quot;#AE95C7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightCyan&quot;</span>:<span class="hljs-string">&quot;#95AEC7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightGreen&quot;</span>:<span class="hljs-string">&quot;#95C7AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightMagenta&quot;</span>:<span class="hljs-string">&quot;#C795AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightRed&quot;</span>:<span class="hljs-string">&quot;#C7AE95&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightWhite&quot;</span>:<span class="hljs-string">&quot;#F3F4F5&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiBrightYellow&quot;</span>:<span class="hljs-string">&quot;#AEC795&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiCyan&quot;</span>:<span class="hljs-string">&quot;#95AEC7&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiGreen&quot;</span>:<span class="hljs-string">&quot;#95C7AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiMagenta&quot;</span>:<span class="hljs-string">&quot;#C795AE&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiRed&quot;</span>:<span class="hljs-string">&quot;#C7AE95&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiWhite&quot;</span>:<span class="hljs-string">&quot;#C7CCD1&quot;</span>,<br>       <span class="hljs-attr">&quot;terminal.ansiYellow&quot;</span>:<span class="hljs-string">&quot;#AEC795&quot;</span><br>   &#125;,<br></code></pre></td></tr></table></figure><p>修改后效果</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301517302.png"></p><h2 id="修改终端字体"><a href="#修改终端字体" class="headerlink" title="修改终端字体"></a>修改终端字体</h2><p>方法一：打开VScode<code>settings.json</code>，加上下面这个配置，字体改成自己电脑上的字体</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-string">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="hljs-string">&quot;JetBrains Mono&quot;</span>,<br><br></code></pre></td></tr></table></figure><p>方法二：打开设置页面，搜索<code>terminal font</code> </p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220524142319.png"></p><p>修改后的效果</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220524142612.png"></p><h2 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Git</tag>
      
      <tag>Gitbash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU亲和性与中断亲和性</title>
    <link href="/2022/05/23/CPU%E4%BA%B2%E5%92%8C%E6%80%A7%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%BA%B2%E5%92%8C%E6%80%A7/"/>
    <url>/2022/05/23/CPU%E4%BA%B2%E5%92%8C%E6%80%A7%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%BA%B2%E5%92%8C%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是CPU亲和性"><a href="#什么是CPU亲和性" class="headerlink" title="什么是CPU亲和性"></a>什么是CPU亲和性</h2><p>CPU的亲和性(Affinity)，属于一种调度属性，可以绑定进程到指定CPU上。 换句话说，就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器。</p><p>为何会出现这种技术？在SMP(Symmetric Multi-Processing对称多处理)架构下，调度器会试图保持进程在相同的CPU上运行，这意味着进程通常不会在处理器之间频繁迁移，进程迁移的频率小就意味着产生的负载小。</p><p>又如，每个CPU本身自己会有缓存，缓存着进程使用的信息，而进程可能会被操作系统调度到其他CPU上，如此，CPU 缓存命中率就低了，当绑定CPU后，程序就会一直在指定的CPU跑，不会由操作系统调度到其他CPU上，性能有一定的提高。</p><p>软亲和性（affinity）:  就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，Linux 内核进程调度器天生就具有被称为 软 CPU 亲和性（affinity） 的特性，这意味着进程通常不会在处理器之间频繁迁移。这种状态正是我们希望的，因为进程迁移的频率小就意味着产生的负载小。</p><p>硬亲和性（affinity）：简单来说就是利用linux内核提供给用户的API，强行将进程或者线程绑定到某一个指定的cpu核运行。</p><h2 id="硬亲和性"><a href="#硬亲和性" class="headerlink" title="硬亲和性"></a>硬亲和性</h2><p>**<a href="https://mp.weixin.qq.com/s/HwDqCk8vtMdSEVSCLHAsbg">超线程技术(Hyper-Threading)</a>**：就是利用特殊的硬件指令，把两个逻辑内核(CPU core)模拟成两个物理芯片，<br>让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。<br>我们常听到的双核四线程/四核八线程指的就是支持超线程技术的CPU.</p><p><strong>物理CPU</strong>：机器上安装的实际CPU, 比如说你的主板上安装了一个8核CPU,那么物理CPU个数就是1个,所以物理CPU个数就是主板上安装的CPU个数。</p><p><strong>逻辑CPU</strong>：一般情况，我们认为一颗CPU可以有多核，加上intel的超线程技术(HT), 可以在逻辑上再分一倍数量的CPU core出来；</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">逻辑<span class="hljs-meta">CPU</span>数量 = 物理<span class="hljs-meta">CPU</span>数量 x <span class="hljs-meta">CPU</span> cores x <span class="hljs-number">2</span>(如果支持并开启HT) //前提是<span class="hljs-meta">CPU</span>的型号一致，如果不一致只能一个一个的加起来，不用直接乘以物理<span class="hljs-meta">CPU</span>数量<br>//比如你的电脑安装了一块<span class="hljs-number">4</span>核<span class="hljs-meta">CPU</span>，并且支持且开启了超线程（HT）技术，那么逻辑<span class="hljs-meta">CPU</span>数量 = <span class="hljs-number">1</span> × <span class="hljs-number">4</span> × <span class="hljs-number">2</span> = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="linux命令实现硬亲和性"><a href="#linux命令实现硬亲和性" class="headerlink" title="linux命令实现硬亲和性"></a>linux命令实现硬亲和性</h3><p><strong>Linux下查看CPU相关信息</strong>, CPU的信息主要都在<code>/proc/cupinfo</code>中,</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># 查看物理CPU个数<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;physical id&quot;</span>|<span class="hljs-keyword">sort</span> -u|wc -l<br><span class="hljs-number">32</span><br><br># 查看每个物理CPU中core的个数(即核数)<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;cpu cores&quot;</span>|uniq<br><span class="hljs-number">1</span><br># 或者<br>➜    cat <span class="hljs-regexp">/proc/</span>cpuinfo | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;process&#x27;</span> | <span class="hljs-keyword">sort</span> | uniq | wc -l<br><span class="hljs-number">1</span><br><br># 查看逻辑CPU的个数<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;processor&quot;</span>|wc -l<br><span class="hljs-number">32</span><br><br># 查看CPU的名称型号<br>➜  ~ cat <span class="hljs-regexp">/proc/</span>cpuinfo|<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;name&quot;</span>|cut -f2 -d:|uniq<br>Intel Xeon Processor (Skylake, IBRS)<br></code></pre></td></tr></table></figure><p><strong>Linux查看某个进程运行在哪个逻辑CPU上</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk">ps -eo pid,args,psr<br><span class="hljs-comment"># 参数的含义：</span><br><span class="hljs-comment"># pid  - 进程ID</span><br><span class="hljs-comment"># args - 该进程执行时传入的命令行参数</span><br><span class="hljs-comment"># psr  - 分配给进程的逻辑CPU</span><br><br>例子:<br>➜  ~ ps -eo pid,args,psr | grep firefox<br><span class="hljs-number">20118</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -n  <span class="hljs-number">13</span><br><span class="hljs-number">20208</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c   <span class="hljs-number">9</span><br><span class="hljs-number">20266</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">29</span><br><span class="hljs-number">20329</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">24</span><br><span class="hljs-number">20499</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c   <span class="hljs-number">7</span><br><span class="hljs-number">20565</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">15</span><br><span class="hljs-number">20596</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">24</span><br><span class="hljs-number">20760</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">18</span><br><span class="hljs-number">22110</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">27</span><br><span class="hljs-number">25857</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">28</span><br><span class="hljs-number">26347</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">19</span><br><span class="hljs-number">26899</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/firefox/</span>firefox -c  <span class="hljs-number">29</span><br></code></pre></td></tr></table></figure><p><strong>Linux查看线程的TID</strong></p><p>TID就是Thread ID,他和POSIX中pthread_t表示的线程ID完全不是同一个东西.</p><p>Linux中的POSIX线程库实现的线程其实也是一个轻量级进程(LWP),这个TID就是这个线程的真实PID.</p><p>但是又不能通过<code>getpid()</code>函数获取，Linux中定义了<code>gettid()</code>这个接口，但是通常都是未实现的，所以需要使用下面的方式获取TID。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">//program</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;  </span></span><br>pid_t tid;<br>tid = syscall(<span class="hljs-variable">__NR_gettid</span>);<span class="hljs-comment">// or syscall(SYS_gettid)  </span><br><br><span class="hljs-comment">//command-line 3种方法(推荐第三种方法)</span><br>➜  ~ ps -efL | grep prog_name<br>➜  ~ ls /proc/pid/task            <span class="hljs-comment">//文件夹名即TID</span><br>➜  ~ ps -<span class="hljs-keyword">To</span> <span class="hljs-string">&#x27;pid,lwp,psr,cmd&#x27;</span> -p PID<br></code></pre></td></tr></table></figure><h4 id="使用taskset命令设置CPU亲和性"><a href="#使用taskset命令设置CPU亲和性" class="headerlink" title="使用taskset命令设置CPU亲和性"></a>使用<code>taskset</code>命令设置CPU亲和性</h4><p><strong>命令行形式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">taskset <span class="hljs-selector-attr">[options]</span> <span class="hljs-attribute">mask</span> command <span class="hljs-selector-attr">[arg]</span>...<br>taskset <span class="hljs-selector-attr">[options]</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-selector-attr">[mask]</span> pid<br></code></pre></td></tr></table></figure><p><strong>参数解析</strong><br>[OPTIONS]taskset的可选参数</p><ul><li><p>-a, –all-tasks (旧版本中没有这个选项)　　　　　　　　</p><pre><code class="hljs">  这个选项涉及到了linux中TID的概念,他会将一个进程中所有的TID都执行一次CPU亲和性设置.　　　　　　　　  TID就是Thread ID,他和POSIX中pthread_t表示的线程ID完全不是同一个东西.　　　　　　　　  Linux中的POSIX线程库实现的线程其实也是一个进程(LWP),这个TID就是这个线程的真实PID.</code></pre></li><li><p>-p, –pid</p><pre><code class="hljs">  操作已存在的PID,而不是加载一个新的程序</code></pre></li><li><p>-c, –cpu-list</p><pre><code class="hljs">        声明CPU的亲和力使用数字表示而不是用位掩码表示. 例如 0,5,7,9-11.</code></pre></li><li><p>-h, –help</p><pre><code class="hljs">  显示帮助信息</code></pre></li><li><p>-V, –version</p><pre><code class="hljs">  显示版本信息</code></pre></li><li><p>mask : cpu亲和性,当没有-c选项时, 其值前无论有没有0x标记都是16进制的,　　　　　　　　当有-c选项时,其值是十进制的.　　　　</p></li><li><p>command : 命令或者可执行程序</p></li><li><p>pid : 进程ID,可以通过ps/top/pidof等命令获取</p></li></ul><p>[arg]command的参数　</p><p><strong>实例</strong></p><ol><li>使用指定的CPU亲和性运行一个新程序<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskset [-c] mask <span class="hljs-built_in">command</span> [arg]...<br><span class="hljs-comment"># 举例: 使用CPU0运行ls命令显示/etc/init.d下的所有内容</span><br>taskset -c 0 ls -al /etc/init.d/<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li>显示已经运行的进程的CPU亲和性<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskset -p pid<br><span class="hljs-comment"># 举例:查看init进程(PID=1)的CPU亲和性</span><br>taskset -p 1<br></code></pre></td></tr></table></figure></li><li>改变已经运行进程的CPU亲和性<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq">taskset -p[c] mask pid<br>举例:打开<span class="hljs-number">2</span>个终端,在第一个终端运行<span class="hljs-built_in">top</span>命令,第二个终端中<br> 　　首先运行:[~]# ps -eo pid,args,psr | <span class="hljs-type">grep</span> <span class="hljs-built_in">top</span> #获取<span class="hljs-built_in">top</span>命令的pid和其所运行的CPU号<br> 　　其次运行:[~]# taskset -cp 新的CPU号 pid       #更改<span class="hljs-built_in">top</span>命令运行的CPU号<br> 　　最后运行:[~]# ps -eo pid,args,psr | <span class="hljs-type">grep</span> <span class="hljs-built_in">top</span> #查看是否更改成功<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">ps</span> <span class="hljs-string">-eo</span> <span class="hljs-string">pid,args,psr</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">top</span><br><span class="hljs-number">2501 </span><span class="hljs-string">nautilus-desktop</span>             <span class="hljs-number">24</span><br><span class="hljs-number">2634</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">18</span><br><span class="hljs-number">2658</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">11</span><br><span class="hljs-number">23848</span> <span class="hljs-string">top</span>                           <span class="hljs-number">6</span><br><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">taskset</span> <span class="hljs-string">-cp</span> <span class="hljs-number">10</span> <span class="hljs-number">23848</span><br><span class="hljs-string">pid</span> <span class="hljs-number">23848</span><span class="hljs-string">&#x27;s current affinity list: 0-31</span><br><span class="hljs-string">pid 23848&#x27;</span><span class="hljs-attr">s new affinity list:</span> <span class="hljs-number">10</span><br><span class="hljs-string">➜</span>  <span class="hljs-string">~</span> <span class="hljs-string">ps</span> <span class="hljs-string">-eo</span> <span class="hljs-string">pid,args,psr</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">top</span><br> <span class="hljs-number">2501 </span><span class="hljs-string">nautilus-desktop</span>             <span class="hljs-number">24</span><br> <span class="hljs-number">2634</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">18</span><br> <span class="hljs-number">2658</span> <span class="hljs-string">/usr/libexec/xdg-desktop-po</span>  <span class="hljs-number">11</span><br><span class="hljs-number">23848</span> <span class="hljs-string">top</span>                          <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li></ol><p>      </p><blockquote><p> 一个用户要设定一个进程的CPU亲和性,如果目标进程是该用户的,则可以设置,如果是其他用户的,则会设置失败,提示 Operation not permitted.当然root用户没有任何限制.<br>任何用户都可以获取任意一个进程的CPU亲和性.</p></blockquote><h3 id="程序API实现硬亲和性"><a href="#程序API实现硬亲和性" class="headerlink" title="程序API实现硬亲和性"></a>程序API实现硬亲和性</h3><p>参见<a href="https://www.cnblogs.com/lubinlew/p/cpu_affinity.html">Linux中CPU亲和性(affinity) - LubinLew - 博客园</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span> <span class="hljs-comment">//for pthread functions(last 4) 注意&lt;pthread.h&gt;包含&lt;sched.h&gt;</span></span><br><br><span class="hljs-comment">/* MACRO */</span><br>    <span class="hljs-comment">/* The following macros are provided to operate on the CPU set set */</span><br>        <span class="hljs-comment">/* Clears set, so that it contains no CPUs */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_ZERO</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_ZERO_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">/* Add CPU cpu to set */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_SET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_SET_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">/* Remove CPU cpu from set */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_CLR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_CLR_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">/* Test to see if CPU cpu is a member of set */</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_ISSET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_ISSET_S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <br>        <span class="hljs-comment">/* Return the number of CPUs in set */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_COUNT</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_COUNT_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br>    <br>    <span class="hljs-comment">/* The following macros perform logical operations on CPU sets */</span><br>        <span class="hljs-comment">/* Store the logical AND of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_AND</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_AND_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Store the logical OR of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_OR</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_OR_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Store  the logical XOR of the sets srcset1 and srcset2 in destset (which may be one of the source sets). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_XOR</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_XOR_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *destset, <span class="hljs-keyword">cpu_set_t</span> *srcset1, <span class="hljs-keyword">cpu_set_t</span> *srcset2)</span></span>;<br>        <br>        <span class="hljs-comment">/* Test whether two CPU set contain exactly the same CPUs. */</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_EQUAL</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *set1, <span class="hljs-keyword">cpu_set_t</span> *set2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_EQUAL_S</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> setsize, <span class="hljs-keyword">cpu_set_t</span> *set1, <span class="hljs-keyword">cpu_set_t</span> *set2)</span></span>;<br>    <br>    <span class="hljs-comment">/* The following macros are used to allocate and deallocate CPU sets: */</span><br>        <span class="hljs-comment">/* Allocate a CPU set large enough to hold CPUs in the range 0 to num_cpus-1 */</span><br>        <span class="hljs-function"><span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-title">CPU_ALLOC</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num_cpus)</span></span>;<br>    <br>        <span class="hljs-comment">/* Return the size in bytes of the CPU set that would be needed to  hold  CPUs  in the  range 0 to num_cpus-1. </span><br><span class="hljs-comment">           This macro provides the value that can be used for the setsize argument in the CPU_*_S() macros */</span><br>        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">CPU_ALLOC_SIZE</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num_cpus)</span></span>;<br>        <br>        <span class="hljs-comment">/* Free a CPU set previously allocated by CPU_ALLOC(). */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_FREE</span><span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br><br><span class="hljs-comment">/* API */</span><br>    <span class="hljs-comment">/* Set the CPU affinity for a task */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sched_setaffinity</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *mask)</span></span>;<br>    <span class="hljs-comment">/* Get the CPU affinity for a task */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sched_getaffinity</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *mask)</span></span>;<br>    <br>    <span class="hljs-comment">/* set CPU affinity attribute in thread attributes object */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_attr_setaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_attr_t</span> *attr, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">const</span> <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <span class="hljs-comment">/* get CPU affinity attribute in thread attributes object */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_attr_getaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_attr_t</span> *attr, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <br>    <span class="hljs-comment">/* set CPU affinity of a thread */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_setaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">const</span> <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br>    <span class="hljs-comment">/* get CPU affinity of a thread */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_getaffinity_np</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">size_t</span> cpusetsize, <span class="hljs-keyword">cpu_set_t</span> *cpuset)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="使用2种方式-带和不带-S后缀的宏-获取当前进程的CPU亲和性"><a href="#使用2种方式-带和不带-S后缀的宏-获取当前进程的CPU亲和性" class="headerlink" title="使用2种方式(带和不带_S后缀的宏)获取当前进程的CPU亲和性"></a>使用2种方式(带和不带_S后缀的宏)获取当前进程的CPU亲和性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> WITH_S</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WITH_S</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> *pmask;<br>    <span class="hljs-keyword">size_t</span> cpusize;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 获取逻辑CPU个数 */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br><br>    pmask = CPU_ALLOC(nrcpus);<br>    cpusize = CPU_ALLOC_SIZE(nrcpus);<br>    CPU_ZERO_S(cpusize, pmask);<br><br>    <span class="hljs-comment">/* 获取CPU亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, cpusize, pmask) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        CPU_FREE(pmask);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET_S(i, cpusize, pmask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    CPU_FREE(pmask);<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nrcpus;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> bitmask = <span class="hljs-number">0</span>;<br><br>    CPU_ZERO(&amp;mask);<br><br>    <span class="hljs-comment">/* 获取CPU亲和性 */</span><br>    <span class="hljs-keyword">if</span> (sched_getaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">cpu_set_t</span>), &amp;mask) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sched_getaffinity&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取逻辑CPU个数 */</span><br>    nrcpus = sysconf(_SC_NPROCESSORS_CONF);<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nrcpus; i++) &#123;<br>        <span class="hljs-keyword">if</span> (CPU_ISSET(i, &amp;mask)) &#123;<br>            bitmask |= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0x01</span> &lt;&lt; i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor #%d is set\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bitmask = %#lx\n&quot;</span>, bitmask);<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="什么是中断亲和性"><a href="#什么是中断亲和性" class="headerlink" title="什么是中断亲和性"></a>什么是中断亲和性</h2><p>计算机中，中断是一种电信号，由硬件产生并直接送到中断控制器上，再由中断控制器向 CPU 发送中断信号，CPU 检测到信号后，中断当前工作转而处理中断信号。CPU 会通知操作系统已经产生中断，操作系统就会对中断进行处理。<br>这里有篇推文：<a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247484717&idx=1&sn=2c1dd6c389c8476eb4fd178c714eaafc&scene=21#wechat_redirect">CPU明明8个核，网卡为啥拼命折腾一号核？</a>生动的解释了中断亲和性。</p><p>默认情况下，Linux 中断响应会被平均分配到所有 CPU 核心上，势必会发生写新的数据和指令缓存，并与 CPU 核心上原有进程产生冲突，造成中断响应延迟，影响进程处理时间。为了解决这个问题，可以将中断（或进程）绑定到指定 CPU 核心上，中断（或进程）所需要指令代码和数据有更大概率位于指定 CPU 本地数据和指令缓存内，而不必进行新的写缓存，从而提高中断响应（或进程）的处理速度。</p><h2 id="中断亲和性的使用场景"><a href="#中断亲和性的使用场景" class="headerlink" title="中断亲和性的使用场景"></a>中断亲和性的使用场景</h2><p>对于文件服务器、Web 服务器，把不同的网卡 IRQ 均衡绑定到不同的 CPU 上将会减轻某 CP 的负载，提高多个 CPU 整体处理中断的能力; 对于数据库服务器，把磁盘控制器绑到一个 CPU、把网卡绑定到另一个 CPU 将会提高数据库的响应时间、优化性能。<br>合理的根据自己的生产环境和应用的特点来平衡 IRQ 中断有助于提高系统的整体吞吐能力和性能。</p><h2 id="中断绑定流程"><a href="#中断绑定流程" class="headerlink" title="中断绑定流程"></a>中断绑定流程</h2><ol><li><p>关闭中断平衡守护进程<br>中断平衡守护进程（irqbalance daemon）会周期性地将中断平均地公平地分配给各个 CPU 核心，默认开启。为了实现中断绑定，首先需要将中断平衡守护进程关闭。</p><ul><li><code>systemctl status irqbalance</code>查看守护进程的运行状态</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ systemctl status irqbalance<br><br>● irqbalance.service - irqbalance daemon<br>Loaded: loaded (/lib/systemd/system/irqbalance.service; enabled; vendor preset: <span class="hljs-built_in">enable</span><br>Active: active (running) since Thu 2022-05-19 14:46:20 CST; 1 weeks 1 days ago<br>Main PID: 1062 (irqbalance)<br>    Tasks: 2 (<span class="hljs-built_in">limit</span>: 4915)<br>CGroup: /system.slice/irqbalance.service<br>        └─1062 /usr/sbin/irqbalance --foreground<br><br>5月 19 14:46:20 zdd systemd[1]: Started irqbalance daemon.<br></code></pre></td></tr></table></figure><ul><li><code>systemctl stop irqbalance</code>关闭中断平衡守护进程，中断响应默认都会由 CPU0 核心处理。或者<code>systemctl disable irqbalance</code>取消中断平衡守护进程开机重启。因为关闭中断平衡守护进程过于强硬，可以在不关闭中断平衡守护进程条件下，让某些 CPU 核心脱离中断平衡守护进程的管理。</li></ul></li><li><p>绑定中断<br>中断绑定时，需要关闭系统中断平衡守护进程<code>systemctl stop irqbalance</code>计算机当前各种中断响应情况在 <code>/proc/interrupts</code> 文件中。</p><p> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205281336182.png"><br> 第一列是中断 ID 号，CPU N 列是中断在第 n 个 CPU 核心上的响应次数，倒数第二列是中断类型，最后一列是描述。  </p><p> 利用 echo 命令将 CPU 掩码写入 <code>/proc/irq/中断 ID/smp_affinity</code> 文件中，即可实现修改某一中断的 CPU 亲和性。例如  </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> 0x0004 &gt; /proc/irq /50/smp_affinity<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/lubinlew/p/cpu_affinity.html">Linux中CPU亲和性(affinity) - LubinLew - 博客园</a><br><a href="https://blog.51cto.com/u_15302006/3075968">操作系统底层技术——CPU亲和性_mb60ed33cfc44fa的技术博客_51CTO博客</a><br><a href="https://blog.51cto.com/u_15484754/4907846">linux进程、线程与cpu的亲和性（affinity）_wx61d68abba262d的技术博客_51CTO博客</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&mid=2247484717&idx=1&sn=2c1dd6c389c8476eb4fd178c714eaafc&scene=21#wechat_redirect">CPU明明8个核，网卡为啥拼命折腾一号核？</a><br><a href="https://en.wikipedia.org/wiki/Processor_affinity">Processor affinity - Wikipedia</a><br><a href="https://mp.weixin.qq.com/s/HwDqCk8vtMdSEVSCLHAsbg">什么？一个核同时执行两个线程？</a></p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>CPU</tag>
      
      <tag>亲和性</tag>
      
      <tag>Affinity</tag>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SoC存储器比较</title>
    <link href="/2022/05/21/SoC%E5%AD%98%E5%82%A8%E5%99%A8%E6%AF%94%E8%BE%83/"/>
    <url>/2022/05/21/SoC%E5%AD%98%E5%82%A8%E5%99%A8%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>也就是内部存储器，主要用来运行程序的，典型的就是 RAM随机存储器（Random Access Memory），那么随机是什么意思？所谓随机，指的是当存储器中的数据被读取或写入时，所需要的时间与这段信息所在的位置无关（任何位置读写速度一样）。</p><p><strong>DRAM</strong>（Dynamic Random Access Memory，动态随机存储器）是最为常见的系统内存。我们使用的电脑和手机的运行内存都是DRAM。DRAM使用电容存储，DRAM 只能将数据保持很短的时间。为了保持数据，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。数据的存储，请参考数据存储模型。我们知道，电容中的电荷很容易变化，所以随着时间推移，电容中的电荷数会增加或减少，为了确保数据不会丢失，DRAM每隔一段时间会给电容刷新（充电或放电）。动态：定时刷新数据</p><p><strong>SRAM</strong>（Static Random Access Memory，静态随机存储器），它是一种具有静止存取功能的内存，其内部机构比DRAM复杂，可以做到不刷新电路即能保存它内部存储的数据。<strong>静态：不需要刷新</strong></p><p><strong>DDR SDRAM</strong>（Double Data Rate SDRAM）：为双信道同步动态随机存取内存，是新一代的SDRAM技术。DDR内存芯片的数据预取宽度（Prefetch）为2 bit（SDRAM的两倍）。</p><p><strong>DDR2 SDRAM</strong>（Double Data Rate Two SDRAM）：为双信道两次同步动态随机存取内存。DDR2内存Prefetch又再度提升至4 bit（DDR的两倍）</p><p><strong>DDR3 SDRAM</strong>（Double Data Rate Three SDRAM）：为双信道三次同步动态随机存取内存。DDR3内存Prefetch提升至8 bit，即每次会存取8 bits为一组的数据。运算频率介于 800MHz -1600MHz之间。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205211606655.png"></p><h2 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h2><p>外部存储器 ，通常用来存储文件的，一般也叫 ROM （<strong>Read-only memory</strong>）只读存储器。</p><p>CPU连接内存和外存的连接方式不同。内存需要直接地址访问，所以是通过地址总线&amp;数据总线的总线式访问方式连接的（好处是直接访问，随机访问；坏处是占用CPU的地址空间，大小受限）；外存是通过CPU的外存接口来连接的（好处是不占用CPU的地址空间，坏处是访问速度没有总线式快，访问时序较复杂）</p><blockquote><p>我们平时用的硬盘，SD卡都属于ROM，但是他们却可以写入？ROM严格意义来讲确实是只读的，但是随着储存器的发展，出现了可擦可编程只读存储器（EPROM）、电可擦可编程只读存储器（EEPROM）形式的半导体存储器，以及flash。他们都是可写的。ROM就不再单单只表示只读存储器了，一般来说与RAM相对，掉电不易失的存储器都被当做ROM。</p></blockquote><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p>ROM（Read Only Memory）只读存储器，这种存储器（Memory）的内容任何情况下都不会改变，电脑与用户只能读取保存在这里的指令，和使用存储在ROM的资料，但不能变更或存入资料。ROM被存储在一个非易失性芯片上，也就是说，即使在关机之后记忆的内容仍可以被保存，所以这种存储器多用来存储特定功能的程序，如<a href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E4%BB%B6">固件</a>。ROM存储用来启动电脑的程序（如<a href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a>），电脑引导的时候BIOS提供一连串的指令对中央处理器（<a href="https://zh.wikipedia.org/wiki/CPU">CPU</a>）等组件进行初始化，在初始化过程中，BIOS程序初始化并检查<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">RAM</a>。</p><h3 id="NorFlash"><a href="#NorFlash" class="headerlink" title="NorFlash"></a>NorFlash</h3><p>总线式访问，接到SROM bank，优点是可以直接总线访问，一般用来启动。</p><h3 id="NandFlash"><a href="#NandFlash" class="headerlink" title="NandFlash"></a>NandFlash</h3><p>SLC：容量小，价格高，稳定性高</p><p>MLC：容量大，价格低，稳定性差，易出坏块</p><p><strong>iNand</strong><br>SanDisk公司出产的eMMC</p><p><strong>moviNand</strong><br>三星公司出产的eMMC</p><p><strong>oneNAND</strong><br>三星公司出的一种Nand，价格贵，用的少</p><p><strong>SD卡（Secure Digital Memory Card）</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205192308956.png"></p><p><strong>TF卡（TransFLash Card, MicroSD）</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205192309547.png"></p><p><strong>MMC卡</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205192312777.png"></p><p><strong>eMMC卡（embeded MMC）</strong><br>嵌入式的MMC，可以当成一种芯片，内部做了坏块处理</p><p><strong>SATA硬盘</strong></p><p>特点：机械式访问、磁存储原理、SATA是接口。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>SoC</tag>
      
      <tag>固件开发</tag>
      
      <tag>芯片开发</tag>
      
      <tag>存储器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interlaken协议</title>
    <link href="/2022/05/18/Interlaken%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/05/18/Interlaken%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对Interlaken协议文档的翻译加了一些自己的理解；</p></blockquote><p><strong>8b/10b编码</strong>：在串行通道上传输时，将 8bits数据编码为10bits数据，做一个转换，使各位数据之间有更多的 1到0 和 0到1 的跳变，以便接收设备检测这些跳变，能更容易地恢复时钟。<strong>64B/67B 编码</strong>编码的原因也是类似的。这样，在串行通道上传输10位数据，实际上只传输了8位。</p><h2 id="协议层（Protocol-Layer）"><a href="#协议层（Protocol-Layer）" class="headerlink" title="协议层（Protocol Layer）"></a>协议层（Protocol Layer）</h2><h3 id="传输格式"><a href="#传输格式" class="headerlink" title="传输格式"></a>传输格式</h3><p>数据通过可配置数量的 SerDes 通道（Lane），再由 Interlaken 接口传输。在本文档中，通道被定义为两个 IC 之间的单工串行链路（simplex serial link）。该协议旨在与任意数量的通道一起运行（1个或多个，没有上限）。实际实现时会固定一个数值，不会设计为可变值。</p><p>接口发送数据的基本单位是一个 8 字节的字（Word）。用8字节是为了符合<strong>64B/67B 编码</strong>，用于描述突发（Burst）的控制字的大小也是8字节。通过使基本传输单元与控制字大小相等，可以<strong>很容易地调整接口的宽度</strong>。</p><p>数据和控制字按顺序在通道上传输，从通道 0 开始，到通道 M 结束，并在下一个数据块中重复。图 4 说明了该过程</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517120049.png"></p><p>64B/67B编码在每个通道上独立进行。传输通过两种基本数据类型实现：数据字和控制字，他们通过64B/67B 帧位（framing bits）进行区分。这两种数据字类型的格式如下图所示：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517120402.png"></p><p>数据和控制信息都是以位66～0的顺序传输的，框架层引入了4个附加控制字，详细信息后面将描述。</p><h3 id="Burst-结构（Burst-Structure）"><a href="#Burst-结构（Burst-Structure）" class="headerlink" title="Burst 结构（Burst Structure）"></a>Burst 结构（Burst Structure）</h3><h4 id="数据传输流程"><a href="#数据传输流程" class="headerlink" title="数据传输流程"></a>数据传输流程</h4><p>Interlaken接口的带宽在支持的通道上被划分为Bursts。数据包通过一个或多个Burst在接口上传输。Burst通过一个或多个控制字来描述。为了将任意大小的数据包分割成Burst，定义以下两个参数：</p><ul><li>BurstMax：Burst的最大大小（64Bytes的倍数）</li><li>BurstShort：Burst的最小大小（最小32Bytes，增量为8Bytes）</li></ul><p>该接口通常通过发送一个 BurstMax 长度的数据突发来运行，然后是一个控制字。发送设备中的调度逻辑可以自由选择信道服务的顺序，<strong>受流控状态的约束</strong>。Burst在每个通道上传输，直到数据包完全传输，此时该通道上的新数据包传输才开始。</p><p>因为接口是信道化的，数据包的结束可能会在几个信道上连续地出现，每个信道上的剩余数据量非常小。由于发射器和接收器的存储器可能被理想地设计成宽数据通路，它们需要以非常高的速率来处理这种情况。为了减少接收器和发射器的负担，BurstShort参数保证了连续的Burst控制字之间的最小间隔。最小的BurstShort间隔是32字节，更大的值可以以8字节为增量。</p><blockquote><p>如果没有最小Burst的限制，那么数据包太小的话，发送器或者接收器就会频繁收到end-of-packet，这就增加了处理负担。</p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517142438.png" alt="示意如何保证 BurstShort 最小间隔。 BurstShort 通过在下一个Burst控制字之前添加额外的空闲控制字来保证最小Burst的大小。图中，Idle Control Word 1 的 EOP_Format 指示 EOP 和Last Data Word的适当大小，Idle Control Word 1 的 CRC24 涵盖了Last Data Word和Idle Control Word 1 。插入Idle Control Word 2 和Idle Control Word 3 BurstShort来保证BurstShort为32字节，随后的 Burst 控制字属于下一轮发送的数据。"></p><h4 id="控制字格式"><a href="#控制字格式" class="headerlink" title="控制字格式"></a>控制字格式</h4><p>突发通过一个 8 字节的控制字来描述。控制字在数据流中通过使用位 [66:64] 的“0x10”控制代码和位 [63] = ‘1’ 来标识突发和空闲控制字格式如第 16 页的图 7 所示： </p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517182706.png"></p><h3 id="流控（Flow-Control）"><a href="#流控（Flow-Control）" class="headerlink" title="流控（Flow Control）"></a>流控（Flow Control）</h3><p>Interlaken 的一个关键特性是能够传达每个通道背压（backpressure）。为了提供此功能，指定了两个选项：<strong>带外流控接口和带内通道</strong>。从语义上讲，流控制信息<strong>使用简单的开关机制来表示允许在特定通道上传输</strong>。</p><p>开关流控制状态与每个通道的单个状态位进行通信。按照惯例，“1”标识“XON”状态，表示允许发送器在该通道上发送数据。 “0”标识“XOFF”状态，表示发送器不允许在该通道上发送数据。</p><p>该协议没有Credits的概念；一旦通道被指示为 XON，发送器可以在该通道上发送尽可能多的数据，直到流控制状态更改为 XOFF。接收器选择在 XON 和 XOFF 状态之间切换的阈值是留给用户的可编程选项，取决于支持的通道数量、接收缓冲区的深度和给定环境的流控制延迟。</p><p>流控制通道可以选择映射到calendar，从而流控制可以映射到任何一组calendar entry。例如，这些可以包括通道到calendar entry的一对一映射、一对多映射或插入空字段以匹配具有不同通道定义的设备。</p><blockquote><p>Channel Calendar 将通道映射到流控状态槽</p></blockquote><p>这个Calendar 结构也可以用来提供链路级的流控制，Calendar 中的一个bit代表了在整个接口上传输数据的权限。链路状态的极性将与通道状态的极性相同：“1”表示允许传输，“0”表示立即停止传输。要启用此功能，可以为每个Calendar entry配置通道信息或链接信息。为了促进低延迟链路状态，接口需要提供足够的Calendar entry，以便在每个突发/空闲控制字的相同位位置编程链路状态。例如，使用超过 16 个通道，这可以通过以下设置执行：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517165148.png"></p><p>使用此方法，link status将始终出现在突发/空闲控制字的位[55]中。</p><h4 id="带外流控"><a href="#带外流控" class="headerlink" title="带外流控"></a>带外流控</h4><p>为了支持需要单工操作的系统，定义了带外流量控制选项。这是作为一个源同步接口实现的，并由以下信号指定:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>型号名称</td><td>功能</td></tr><tr><td>FC_CLK</td><td>与流控数据同步的时钟</td></tr><tr><td>FC_DATA</td><td>流量控制状态信息(单比特)</td></tr><tr><td>FC_SYNC</td><td>一种同步信号，用于标识流控制calendar的开头</td></tr></tbody></table><p>每个信号的pad技术可以是LVDS或LVCMOS。这些信号的逻辑时序关系如下图所示：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517165803.png"></p><p>带外流控制通道由4位CRC计算保护，该CRC计算覆盖了多达64位的流控制数据。根据^[P. Koopman and T. Chakravarty, Cyclic Redundancy Code (CRC) Polynomial Selection<br>for Embedded Networks, The International Conference on Dependable Networks and<br>Systems, DSN-2004.]中的建议，CRC4多项式为：</p><p>$$<br>x^4+x+1<br>$$</p><h4 id="带内流控"><a href="#带内流控" class="headerlink" title="带内流控"></a>带内流控</h4><p>当使用此选项时，接收器利用通过接口发送的控制字中的流控制状态，作为正常数据传输的一部分。提供此选项的目的是，需要最少数量的外部信号引脚的全双工实现。  </p><p>如Figure 7所示，控制字的流控制字段为16位，位于bit[55:40]。控制字的位[31:24]也可以用于流控制的另外8位，总共24位。这些状态位表示每个Interlaken Calendar通道的ON-OFF流控制状态，当前Calendar Entry X在位[55]，Calendar Entry X + 1在位[54]，依此类推。为了同步calendar的开始，在空闲/突发控制字中提供了“reset calendar”位。当该位为“1”时，calendar entry 0的状态将出现在位[55]中。当“reset calendar”为“ 0”时，calendar将从上一个控制字中保留的位置开始继续。当所有通道的流控状态被传输完，发送器将重置复位calendar，然后重复上一轮顺序操作。Calendar最后一个控制字中不需要的bit（即，当通道数目不是状态数目的倍数时）被发送端置0，接收端忽略。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>Interlaken</tag>
      
      <tag>协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AMBA总线协议-AXI协议</title>
    <link href="/2022/05/17/AMBA%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE-AXI%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/05/17/AMBA%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE-AXI%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="AXI"><a href="#AXI" class="headerlink" title="AXI"></a>AXI</h2><p>组成部分：</p><p>AXI4协议中包含五种信道，通道之间相互独立且存在差别，通过通道进行通信之前需要使用VALID/READY 进行握手，Read和Write根据Master定义：</p><ul><li>读地址信道（Read Address Channel）</li><li>写地址信道（Write Address Channel）</li><li>读数据信道（Read Data Channel）</li><li>写数据信道（Write Data Channel）</li><li>写响应信道（Write Response Channel）</li></ul><p>还有两种Component</p><ul><li>Master component</li><li>Slave component</li></ul><p>通信由Master发起，Master可以对Slave进行读数据（read）或写（write）数据。每次读写操作都需要一个地址，读地址信道（Read Address Channel）和写地址信道（Write Address Channel）用于传输地址。在写完数据后，Master需要确认Slave有没有收完数据，Slave收到完整数据后，会通过写响应信道（Write Response Channel）给Master一个反馈（completion），表示写操作已经完成。</p><h3 id="VALID-READY-握手机制"><a href="#VALID-READY-握手机制" class="headerlink" title="VALID/READY 握手机制"></a>VALID/READY 握手机制</h3><p>AXI五个信道相互独立，但是使用同一个握手机制来实现信息传递。</p><p>在握手机制中，通信双方分别扮演<strong>发送方</strong>(Source)和<strong>接收方</strong>（Destination），两者的操作（技能）并不相同。</p><p><strong>发送方</strong>置高 <strong>VALID</strong> 信号表示发送方已经将数据，地址或者控制信息已经就绪，并保持于消息总线上。</p><p><strong>接收方</strong>置高 <strong>READY</strong> 信号表示接收方已经做好接收的准备。</p><p>当双方的 VALID/READY 信号同时为高，在时钟 ACLK 上升沿，完成一次数据传输。所有数据传输完毕后，双方同时置低自己的信号。</p><p>每个通道都有自己的 VALID /READY 握手信号对：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516200137.png"></p><p>在握手过程中，还会用到LAST信号。LAST信号存在Write Data Channel和Read Data Channel中，分别表示为WLAST和RLAST，用于标记burst的最后一次数据传输，当slave接收到LAST信号后，说明本次数据传输完成。</p><h4 id="双向流控"><a href="#双向流控" class="headerlink" title="双向流控"></a>双向流控</h4><p>所谓的<strong>双向流控</strong>机制，指的是发送方通过置起 VALID 信号控制发送的时机与速度，接收方也可以通过 READY 信号的置起与否控制接收速度。</p><p>发送方拥有传输的主动权，但接收方在不具备接收能力时，也能够置低信号停止传输，反压发送方。</p><h4 id="握手过程分析"><a href="#握手过程分析" class="headerlink" title="握手过程分析"></a>握手过程分析</h4><blockquote><p>图中INFORMATION信号无底色区域表示此时数据已经准备好，已经有新的数据到达。</p></blockquote><p><strong>VALID信号先到</strong></p><p>发送方 VALID 信号早早就到了，但是接收方的READY信号在T2之前都没有发送。可能接收方在接收其他数据，或者被堵在数据通路上。</p><p>过了T2后，READY信号到来，此时开始传输，直到T3结束，传输完成。</p><p>这里也体现了双向流控机制，发送方的VALID信号只要置高，再握手完成之前都不能置低，必须等到接收方READY信号置高。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201556.png"></p><p><strong>READY信号先到</strong></p><p>READY 信号很自由，可以等待 VALID 信号到来再做响应，但也完全可以在 VALID 信号到来前就置高，表示接收端已经做好准备了。</p><p>而且，READY 信号与 VALID 不同，接收方可以置起 READY 之后在VALID置高之前都可以随时再置低READY信号。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201616.png"></p><p><strong>信号同时同时到达</strong></p><p>这个最简单，两个信号都等着一个时钟上升沿就完成传输了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516201647.png"></p><h4 id="握手信号之间的依赖关系"><a href="#握手信号之间的依赖关系" class="headerlink" title="握手信号之间的依赖关系"></a>握手信号之间的依赖关系</h4><p>为了防止死锁发生，信号之间要遵循一些规矩，举例来说，如上面提到的READY信号依赖VALID信号，但是VALID信号不能根据READY信号来判断是否数据已准备好，否则将会造成死锁。下面详细解释读写过程中需要遵循的依赖关系。</p><ul><li>单箭头指向的两个信号，信号的置高，低没有顺序要求。</li><li>双箭头表示箭头所指对象应迟于箭头出发信号发送。</li></ul><p><strong>Read transaction dependencies</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517100503.png"></p><ul><li>Master不得等待Slave置高 ARREADY</li><li>Slave可以在置高ARREADY 之前等待 ARVALID 置高</li><li>Slave能够在ARVALID置高之前先置高ARREADY</li><li>Slave必须等待 ARVALID 和 ARREADY 都被置高，然后才置高RVALID 以表示有效数据可用</li><li>在置高 RVALID 之前，Slave不得等待Master置高 RREADY</li><li>Master可以在置高RREADY 之前等待 RVALID 被置高</li><li>Master可以在 RVALID 被置高之前置高RREADY</li></ul><p><strong>Write transaction dependencies</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220517100647.png"></p><ul><li>在置高AWVALID 或 WVALID 之前，Master不得等待Slave置高 AWREADY 或 WREADY</li><li>Slave可以在置高 AWREADY 之前等待 AWVALID 或 WVALID，或两者都等待</li><li>Slave可以在 AWVALID 或 WVALID 或两者都被置高之前置高 AWREADY</li><li>在置高 WREADY 之前，Slave可以等待 AWVALID 或 WVALID，或两者都等待</li><li>Slave可以在 AWVALID 或 WVALID 或两者都被置高之前置高WREADY</li><li>在置高 BVALID 之前，Slave必须等待 WVALID 和 WREADY 都被置高<ul><li>Slave还必须在置高 BVALID 之前等待 WLAST 被置高，因为写入响应 BRESP 必须在写入事务的最后一次数据传输之后才发出信号</li></ul></li><li>在置高 BVALID 之前，Slave不得等待Master置高 BREADY</li><li>Master可以在置高 BREADY 之前等待 BVALID</li><li>Master可以在 BVALID 被置高之前置高 BREADY</li></ul><h3 id="地址结构（Address-structure）"><a href="#地址结构（Address-structure）" class="headerlink" title="地址结构（Address structure）"></a>地址结构（Address structure）</h3><p>AXI协议是基于Burst的，地址结构里声明了一些传输过程中需要的信号，如起始地址，burst传输长度，传输模式等等。</p><h4 id="Burst"><a href="#Burst" class="headerlink" title="Burst"></a>Burst</h4><p>在介绍Burst transfer之前，需要解释一下什么是Burst。在手册的术语表中，与 AXI 传输相关的有三个概念，分别是 transfer(beat)、burst、transaction。</p><ul><li><strong>AXI Transaction</strong>：the complete set of required operations on the AXI bus form the AXI Transaction.表示传输一段数据(AXI burst)所需的一整套操作；</li><li><strong>AXI Burst</strong>：any required payload data is transferred as an AXI Burst.表示AXI待传数据；</li><li><strong>AXI Beats</strong>：a burst can comprise multiple data transfers, or AXI Beats.表示AXI burst的组成，一个Beat就是一个transfer。</li></ul><p>三者的关系：在 AXI 传输事务（Transaction）中，数据以突发传输（Burst）的形式组织。一次突发传输中可以包含一至多个数据（Transfer）。每个 transfer 因为使用一个周期，又被称为一拍数据（Beat）。</p><p>$$<br>\text{Transaction} = M * \text{Burst} ,M \geq 1 \<br>\text{Burst} = N * \text{Transfer( or Beat)} ,N \geq 1<br>$$</p><p>在地址通道中有三个信号控制进行控制，包括：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516151233.png"></p><p><strong>ARLEN(Burst Length)</strong></p><p>指一次突发传输中包含的数据传输(transfer)数量，在协议中使用 AxLen 信号控制。在 AXI4 中，INCR 类型最大支持长度为 256，其他类型最大长度为 16。而 AXI3 中这一数字无论何种模式均为 16。因此 AXI4 中 AxLen 信号位宽为 8bit，AXI3 中的 AxLen 则仅需要 4bit。</p><p><strong>ARSIZE(Burst Size)</strong></p><p>指传输中的数据位宽，具体地，是每周期传输数据的字节数量，在协议中使用 AXSIZE 信号控制。<strong>突发传输数据宽度不能超过数据总线本身的位宽</strong>。而当数据总线位宽大于突发传输宽度时，将根据协议的相关规定，将数据在部分数据线上传输。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516154710.png"></p><p><strong>ARBURST(Burst Type)</strong></p><p>Burst Type：AXI协议中支持不同的Burst传输类型，主要分FIXED、INCR、WRAP。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516144318.png"></p><ul><li><strong>FIXED传输为地址固定传输</strong>，所有传输都会写在同一个地址中。主要应用在FIFO的传输中，因为FIFO为先入先出，只需要往同一个地址写数据即可。</li><li><strong>INCR传输为地址递增传输</strong>，可根据具体的配置有固定长度递增和非定长递增。<strong>大部分的数据传输都是使用这种方式</strong>，尤其是在内存访问中，可以大大提高效率。</li><li><strong>WRAP传输为地址回环传输</strong>，在一定长度后会回环到起始地址。主要应用在Cache操作中，因为cache是按照cache line进行操作，采用wrap传输可以方便的实现从内存中取回整个cache line。</li></ul><p>AXI burst读操作：<strong>master只需要发送burst的起始地址</strong>，slave会根据burst的起始地址与burst场地自动进行地址计算，将对应的数据与响应发送到master侧。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516143930.png"></p><p>AXI burst写操作中，<strong>也只需要发送burst写的起始地址</strong>，slave只需要接受起始地址，然后根据传输的长度将数据传输到对应的地址缓存中。  只需要进行一次握手就可以实现地址通道的请求传输，避免系统总线的占用。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516144030.png"></p><h3 id="数据结构（Data-read-and-write-structure）"><a href="#数据结构（Data-read-and-write-structure）" class="headerlink" title="数据结构（Data read and write structure）"></a>数据结构（Data read and write structure）</h3><p>读写数据结构中声明了几种数据传输方式。</p><p>在介绍这些传输方式之前，需要了解<strong>WSTRB(Write strobes)写选通信号</strong>。写选通信号 WSTRB 允许在写数据总线上进行 稀疏数据 传输。每个写选通信号对应写数据总线上的一个字节。当写选通断言时，表示写数据总线上对应的字节通道中包含将被更新到 memory 的有效信息。  </p><p>写数据总线上每 8 位具有一个写选通位，因此 WSTRB[n] 对应  WDATA[(8 x n) + 7 : (8 x n)]。默认情况下WSTRB = 0xFFFF。也就是所有通路都是通的。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516162105.png"></p><h4 id="Narrow-Transfer"><a href="#Narrow-Transfer" class="headerlink" title="Narrow Transfer"></a>Narrow Transfer</h4><p>当本次传输中数据位宽小于通道本身的数据位宽时，称为<strong>窄位宽数据传输</strong>，或者直接翻译成<strong>窄传输</strong>。如下图，传输总线为32bit，但是每次只传了8 bit。</p><p>窄传输就是<strong>通过STRB信号指定有效传输数据的位宽来实现</strong>。针对一些特定的寄存器读写，或者在不同数据位宽的总线传输中会使用窄传输操作。如图，第一次传输时，WSTRB信号为0x01，WSTRB = b’001，表示WDATA[7:0]数据有效。</p><p>需要注意<strong>在多笔连续的窄传输操作中，STRB会随着地址递增进行响应的变化</strong>，这样方便在系统设计使用中可以方便的将窄传输合并，从而提升系统传输效率。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516162805.png"></p><h4 id="Unaligned-Transfer"><a href="#Unaligned-Transfer" class="headerlink" title="Unaligned Transfer"></a>Unaligned Transfer</h4><p>AXI 协议规定单次 burst 传输中的数据，其地址不能跨越 4KB 边界。也就是在传输过程中会进行4K对齐。但是在某些时候，会期望在非对齐的地址开始一个突发，即非对齐传输。  </p><blockquote><p>协议中之所以规定一个burst不能跨越4K边界是为了避免一次burst 访问两个slave（每个slave的地址空间是4K/1K对齐的）。4K对齐最大原因是系统中定义一个page大小是4K，而所谓的4K边界是指低12bit为0的地址。</p></blockquote><p>非对齐传输是指<strong>有些传输指令不是按照word对齐，而是按照Byte对齐进行传输</strong>。起始地址可能是任意的地址。如下图中，起始地址为0x1，则在系统上需要按照非对齐的方式进行传输。<strong>第一次传输采用strb信号指定对应的Byte有效，后面的传输可以按照正常的传输进行</strong>。</p><p>下图是一些传输示例，有阴影的格子表示当前字节不会被传输。</p><p>图一为正常的对齐传输，传输起始地址为0x00。</p><p>图二为非对齐传输，起始地址为0x01，第一个格子对应的WSTRB = b’1110。</p><p>图三同上，只是Burst length为5。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516171247.png"></p><p>图四也为非对齐传输，起始地址为0x07。对应的WSTRB = b’1000。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220516171348.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AMBA总线协议</tag>
      
      <tag>AXI协议</tag>
      
      <tag>总线协议</tag>
      
      <tag>AMBA，协议</tag>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现简单有限状态机</title>
    <link href="/2022/05/15/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <url>/2022/05/15/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>常说的状态机是有限状态机FSM，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。<br>三个特征：</p><ul><li>状态总数（state）是有限的。</li><li>任一时刻，只处在一种状态之中。</li><li>某种条件下，会从一种状态转变（transition）到另一种状态。</li></ul><p>设计状态机的关键点：当前状态、外部输入、下一个状态。</p><h2 id="状态机分类"><a href="#状态机分类" class="headerlink" title="状态机分类"></a>状态机分类</h2><h3 id="Moore型状态机"><a href="#Moore型状态机" class="headerlink" title="Moore型状态机"></a>Moore型状态机</h3><p>Moore型状态机特点是：输出只与当前状态有关（与输入信号无关）。相对简单，考虑状态机的下一个状态时只需要考虑它的当前状态就行了。</p><h3 id="Mealy型状态机"><a href="#Mealy型状态机" class="headerlink" title="Mealy型状态机"></a>Mealy型状态机</h3><p>Mealy型状态机的特点是：输出不只和当前状态有关，还与输入信号有关。状态机接收到一个输入信号需要跳转到下一个状态时，状态机综合考虑2个条件（当前状态、输入值）后才决定跳转到哪个状态。</p><h2 id="实现一个简单的状态机"><a href="#实现一个简单的状态机" class="headerlink" title="实现一个简单的状态机"></a>实现一个简单的状态机</h2><p>代码参考<a href="https://github.com/AstarLight/FSM-framework">AstarLight/FSM-framework</a>。</p><p>以小明的一天设计出一个状态机，下图为状态转移图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205151353618.png"></p><p>首先，有限状态机的状态是有限的，我们可以定义一天中的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>GET_UP,<br>GO_TO_SCHOOL,<br>HAVE_LUNCH,<br>DO_HOMEWORK,<br>SLEEP,<br>&#125;;<br></code></pre></td></tr></table></figure><p>状态机在没有事件的驱动下就是一潭死水，所以我们还需要定义出一些会发生的事件，去驱动状态机的运转：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>EVENT1 = <span class="hljs-number">1</span>,<br>EVENT2,<br>EVENT3,<br>&#125;;<br></code></pre></td></tr></table></figure><p>再定义一些在某个状态下需要处理的动作，也就是函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetUp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// do something</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming gets up!\n&quot;</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Go2School</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// do something</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming goes to school!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HaveLunch</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// do something</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming has lunch!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoHomework</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// do something</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming does homework!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Go2Bed</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// do something</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xiao ming goes to bed!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个状态表结构，用来表示一个状态机的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FsmTable_s</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> event;              <span class="hljs-comment">//事件</span><br><span class="hljs-keyword">int</span> CurState;           <span class="hljs-comment">//当前状态</span><br><span class="hljs-keyword">void</span> (*eventActFun)();  <span class="hljs-comment">//函数指针</span><br><span class="hljs-keyword">int</span> NextState;          <span class="hljs-comment">//下一个状态</span><br>&#125;FsmTable_t;<br></code></pre></td></tr></table></figure><p>接下来，我们就可以这个结构定义一个状态表，状态机根据这个表进行状态的流转：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">FsmTable_t XiaoMingTable[] =<br>&#123;<br><span class="hljs-comment">//&#123;到来的事件，当前的状态，将要要执行的函数，下一个状态&#125;</span><br>&#123; EVENT1,  SLEEP,           GetUp,        GET_UP &#125;,<br>&#123; EVENT2,  GET_UP,          Go2School,    GO_TO_SCHOOL &#125;,<br>&#123; EVENT3,  GO_TO_SCHOOL,    HaveLunch,    HAVE_LUNCH &#125;,<br>&#123; EVENT1,  HAVE_LUNCH,      DoHomework,   DO_HOMEWORK &#125;,<br>&#123; EVENT2,  DO_HOMEWORK,     Go2Bed,       SLEEP &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>定义一个状态机结构，表示一个状态机：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FSM_s</span></span><br><span class="hljs-class">&#123;</span><br>FsmTable_t* FsmTable;   <span class="hljs-comment">//指向的状态表</span><br><span class="hljs-keyword">int</span> curState;           <span class="hljs-comment">//FSM当前所处的状态</span><br><br>&#125;FSM_t;<br></code></pre></td></tr></table></figure><p>有了这些基本的结构，就可以写主函数了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FSM_t fsm;                        <span class="hljs-comment">// 实例化一个状态机</span><br>InitFsm(&amp;fsm);                    <span class="hljs-comment">// 初始化状态机</span><br><span class="hljs-keyword">int</span> event = EVENT1;               <span class="hljs-comment">// 初始化事件，为了启动状态机流转，</span><br>                                      <span class="hljs-comment">// 因为状态机只有在有时间发生时才会改变状态</span><br><br><span class="hljs-comment">//小明的一天,周而复始的一天又一天，进行着相同的活动</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event %d is coming...\n&quot;</span>, event);<br>FSM_EventHandle(&amp;fsm, event); <span class="hljs-comment">// 有了初始事件，我们就需要处理这个事件，</span><br>                                      <span class="hljs-comment">// 再写一个处理事件的函数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fsm current state %d\n&quot;</span>, fsm.curState);<br>test(&amp;event); <br>Sleep(<span class="hljs-number">1</span>);                     <span class="hljs-comment">//休眠1秒，方便观察</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 测试用的，模拟事件的发生</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *event)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (*event == <span class="hljs-number">3</span>)<br>&#123;<br>*event = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>(*event)++;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>编写初始化状态机的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">int</span> g_state_max_num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 状态机的状态最大数量，根据状态表的大小来计算</span><br><span class="hljs-comment">// 初始化FSM</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitFsm</span><span class="hljs-params">(FSM_t* pFsm)</span></span><br><span class="hljs-function"></span>&#123;<br>g_state_max_num = <span class="hljs-keyword">sizeof</span>(XiaoMingTable) / <span class="hljs-keyword">sizeof</span>(FsmTable_t);<br>pFsm-&gt;curState = SLEEP; <span class="hljs-comment">// 初始状态为睡觉</span><br>    pFsm-&gt;FsmTable = XiaoMingTable;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写事件处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 事件处理 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSM_EventHandle</span><span class="hljs-params">(FSM_t* pFsm, <span class="hljs-keyword">int</span> event)</span></span><br><span class="hljs-function"></span>&#123;<br>FsmTable_t* pActTable = pFsm-&gt;FsmTable;<br><span class="hljs-keyword">void</span> (*eventActFun)() = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//函数指针初始化为空</span><br><span class="hljs-keyword">int</span> NextState;<br><span class="hljs-keyword">int</span> CurState = pFsm-&gt;curState;<br><br><span class="hljs-comment">/* 获取当前动作函数 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;g_max_num; i++)<br>&#123;<br><span class="hljs-comment">//当且仅当当前状态下来个指定的事件，我才执行它</span><br><span class="hljs-keyword">if</span> (event == pActTable[i].event &amp;&amp; CurState == pActTable[i].CurState)<br>&#123;<br>pActTable[i].eventActFun();                      <span class="hljs-comment">// 执行动作函数</span><br>            FSM_StateTransfer(pFsm, pActTable[i].NextState); <span class="hljs-comment">// 执行状态转移</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 状态迁移 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSM_StateTransfer</span><span class="hljs-params">(FSM_t* pFsm, <span class="hljs-keyword">int</span> state)</span></span><br><span class="hljs-function"></span>&#123;<br>pFsm-&gt;curState = state;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/skyfsm/p/7071386.html">Linux编程之有限状态机FSM的理解与实现 - Madcola - 博客园</a><br><a href="http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html">JavaScript与有限状态机 - 阮一峰的网络日志</a><br><a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">有限状态机 - 维基百科，自由的百科全书</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>FSM</tag>
      
      <tag>有限状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接脚本入门</title>
    <link href="/2022/05/08/%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/08/%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>位置无关编码(PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。</p><p>位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。</p><p>我们在设计一个程序时，会给这个程序指定一个运行地址（链接地址）。就是说我们在编译程序时其实心里是知道我们程序将来被运行时的地址（运行地址）的，而且必须给编译器链接器指定这个地址（链接地址）才行。最后得到的二进制程序理论上是和你指定的运行地址有关的，将来这个程序被执行时必须放在当时编译链接时给定的那个地址（链接地址）下才行，否则不能运行（就叫位置有关代码）。但是有个别特别的指令他可以跟指定的地址（链接地址）没有关系，也就是说这些代码实际运行时不管放在哪里都能正常运行。</p><p>运行地址：由运行时决定的（编译链接时是无法绝对确定运行时地址的）。</p><p>链接地址：由程序员在编译链接的过程中，通过<code>Makefile</code>中<code>-Ttext xxx</code>或者<strong>在链接脚本中指定</strong>的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。</p><p>举例：<br>linux中的应用程序。<code>gcc hello.c -o hello</code>，这时使用默认的链接地址就是<code>0x0</code>，所以应用程序都是链接在0地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享4G的虚拟地址空间。所以应用程序都可以链接到0地址，因为每个进程都是从0地址开始的。（编译时可以不给定链接地址而都使用<code>0x0</code>）</p><h2 id="编译链接过程"><a href="#编译链接过程" class="headerlink" title="编译链接过程"></a>编译链接过程</h2><h3 id="每个过程的作用"><a href="#每个过程的作用" class="headerlink" title="每个过程的作用"></a>每个过程的作用</h3><ul><li>预编译：预编译器执行。替换宏定义，删除注释等工作。</li><li>编译：编译器来执行。把源码<code>.c .S</code>编程机器码<code>.o</code>文件。</li><li>链接：链接器来执行。把<code>.o</code>文件中的各函数（段）按照一定规则（链接脚本来指定）累积在一起，形成可执行文件。</li><li>strip： strip是把可执行程序中的符号信息给拿掉，以节省空间。（Debug版本和Release版本）</li><li>objcopy：由可执行程序生成可烧录的镜像<code>bin</code>文件。</li></ul><h3 id="编译后生成的段"><a href="#编译后生成的段" class="headerlink" title="编译后生成的段"></a>编译后生成的段</h3><p>段就是程序的一部分，我们把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段放在合适的位置。</p><p>段名分为2种：一种是编译器链接器内部定好的，一种是程序员自己指定的、自定义的段名。<br>已有段名：</p><ul><li>代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西</li><li>数据段：（.data），数据段就是C语言中有显式初始化为非0的全局变量</li><li>bss段：（.bss），又叫ZI（zero initial）段，就是零初始化段，对应C语言中初始化为0的全局变量。<br>自定义段名：<br>  段名由程序员自己定义，段的属性和特征也由程序员自己定义。</li></ul><blockquote><p>C语言中全局变量如果未显式初始化，值是0。本质就是C语言把这类全局变量放在了bss段，从而保证了为0。</p></blockquote><blockquote><p>C运行时环境如何保证显式初始化为非0的全局变量的值在main之前就被赋值了？就是因为它把这类变量放在了.data段中，而.data段会在main执行之前被处理（初始化）。</p></blockquote><h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><h3 id="链接脚本做什么事？"><a href="#链接脚本做什么事？" class="headerlink" title="链接脚本做什么事？"></a>链接脚本做什么事？</h3><p>链接脚本其实是个规则文件，他是程序员用来指挥链接器工作的。链接器会参考链接脚本，并且使用其中规定的规则来处理<code>.o</code>文件中那些段，将其链接成一个可执行程序。</p><p>链接脚本的关键内容有2部分：段名 + 地址（作为链接地址的内存地址）。把段，放到一个地址的意思。</p><p>链接脚本就像是一个从上到下顺序执行的一个代码，</p><ul><li><code>.</code> 表示当前位置</li><li><code>=</code> 表示赋值</li><li><code>*</code> 表示通配符</li></ul><p>链接脚本里的符号，可以在汇编源码里引用。</p><p>一个简易示例：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">SECTIONS<br>&#123;<br>. = <span class="hljs-number">0xd0024000</span><span class="hljs-comment">; # 当前地址为0xd0024000</span><br><br><span class="hljs-meta">.text</span> : &#123;<br>start.o<br>* (<span class="hljs-meta">.text</span>)   <span class="hljs-comment"># 所有的text段</span><br>&#125;<br>    <br><span class="hljs-meta">.data</span> : &#123;<br>* (<span class="hljs-meta">.data</span>)<br>&#125;<br><br><span class="hljs-keyword">bss_start </span>= .<span class="hljs-comment">;  # bss_start的值为当前地址，是执行到这里的地址，不是最上面. = 0xd0024000的地址</span><br>.<span class="hljs-keyword">bss </span>: &#123;<br>* (.<span class="hljs-keyword">bss)</span><br><span class="hljs-keyword"></span>&#125;<br><br><span class="hljs-keyword">bss_end </span> = .;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h3><p><strong>任务：在SRAM中将代码从0xd0020010重定位到0xd0024000</strong>。</p><p>第一点：通过链接脚本将代码链接到0xd0024000<br>    重定位代码的作用就是：在PIC执行完之前（在代码中第一句位置有关码执行之前）必须将整个代码搬移到0xd0024000位置去执行，这就是重定位。</p><p>第二点：dnw下载时将bin文件下载到0xd0020010<br>    这样就能完成，下载代码与运行代码位置不同。</p><p>第三点：代码执行时通过代码前段的少量位置无关码将整个代码搬移到0xd0024000。</p><p>第四点：使用一个长跳转跳转到0xd0024000处的代码继续执行，重定位完成。</p><p><strong>长跳转</strong>：一种跳转指令，类似于分支指令B，BL等作用的指令，跳转指令通过给PC（r15）赋一个新值来完成代码跳转。当我们执行完重定位后，<strong>实际上SRAM中有两份代码的镜像</strong>（一份是我们下载到0xd0020010处的，一份是重定位到0xd0024000处的），这两份代码内容完全相同。</p><p><strong>短跳转</strong>： 短跳转指令可以实现向前或向后32MB的地址空间跳转。</p><p>当链接地址和运行地址相同是，短跳转和长跳转实际效果一样。但是当链接地址和运行地址不同时，短跳转和长跳转就有差异了，这时候段跳转执行的是运行地址处的那一份，而长跳转执行的是链接地址的那一份。</p><p>重定位实际就是在运行地址处执行一段位置无关码PIC，让这段PIC（也就是重定位代码）从运行地址处把整个程序镜像拷贝一份到链接地址处，完了之后使用一句长跳转指令从运行地址处直接跳转到链接地址处去执行同一个函数（led_blink），这样就实现了重定位之后的无缝连接。</p><p>汇编代码：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 文件名：led.s</span><br><span class="hljs-comment"> * 作者：朱老师（朱友鹏）</span><br><span class="hljs-comment"> * 描述：演示重定位（在SRAM内部重定位）</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">#define WTCON0xE2700000</span><br><br><span class="hljs-comment">#define SVC_STACK0xd0037d80</span><br><br><span class="hljs-symbol">.global</span> _start<span class="hljs-comment">// 把_start链接属性改为外部，这样其他文件就可以看见_start了</span><br><span class="hljs-symbol">_start:</span><br><span class="hljs-comment">// 第1步：关看门狗（向WTCON的bit5写入0即可）</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-symbol">=WTCON</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0x0</span><br><span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br><span class="hljs-comment">// 第2步：设置SVC栈</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-symbol">=SVC_STACK</span><br><br><span class="hljs-comment">// 第3步：开/关icache</span><br><span class="hljs-keyword">mrc</span> <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><span class="hljs-comment">;// 读出cp15的c1到r0中</span><br><span class="hljs-comment">//bic r0, r0, #(1&lt;&lt;12)// bit12 置0  关icache</span><br><span class="hljs-keyword">orr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>)<span class="hljs-comment">// bit12 置1  开icache</span><br>mcr <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><span class="hljs-comment">;</span><br><br><span class="hljs-comment">// 第4步：重定位</span><br><span class="hljs-keyword">adr</span> <span class="hljs-built_in">r0</span>, _start  <span class="hljs-comment">// adr加载时就叫短加载，此处adr指令用于加载_start当前运行地址，详解见正文</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-symbol">=_start</span>         <span class="hljs-comment">// ldr加载时如果目标寄存器是pc就叫长跳转，如果目标寄存器是r1等就叫长加载</span><br>                            <span class="hljs-comment">// 此处ldr指令用于加载_start的链接地址:0xd0024000</span><br><br><span class="hljs-comment">// bss段的起始地址</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r2</span>, <span class="hljs-symbol">=bss_start</span><span class="hljs-comment">// 就是我们重定位代码的结束地址，重定位只需重定位代码段和数据段即可</span><br>                        <span class="hljs-comment">// 该符号在链接脚本里定义</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r1</span><span class="hljs-comment">// 比较_start的运行时地址和链接地址是否相等</span><br><span class="hljs-keyword">beq</span> clean_bss<span class="hljs-comment">// 如果相等说明不需要重定位，所以跳过copy_loop，直接到clean_bss</span><br><span class="hljs-comment">// 如果不相等说明需要重定位，那么会顺序执行下面的copy_loop进行重定位</span><br><span class="hljs-comment">// 重定位完成后继续执行clean_bss。</span><br><br><span class="hljs-comment">// 用汇编来实现的一个while循环</span><br><span class="hljs-symbol">copy_loop:</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r3</span>, [<span class="hljs-built_in">r0</span>], <span class="hljs-number">#4</span>    <span class="hljs-comment">// 源   r0内容写入r3，然后r0自增4</span><br><span class="hljs-keyword">str</span> <span class="hljs-built_in">r3</span>, [<span class="hljs-built_in">r1</span>], <span class="hljs-number">#4</span><span class="hljs-comment">// 目的 r3内容写入r1，然后r1自增4</span><br>                        <span class="hljs-comment">// 这两句代码就完成了4个字节内容的拷贝</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r2</span><span class="hljs-comment">// r1和r2都是用ldr加载的，都是链接地址，所以r1不断+4总能等于r2</span><br><span class="hljs-keyword">bne</span> copy_loop<br><br><span class="hljs-comment">// 清bss段，其实就是在链接地址处把bss段全部清零</span><br><span class="hljs-symbol">clean_bss:</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-symbol">=bss_start</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-symbol">=bss_end</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r1</span><span class="hljs-comment">// 如果r0等于r1，说明bss段为空，直接继续执行下面的代码</span><br><span class="hljs-keyword">beq</span> run_on_dram<span class="hljs-comment">// 清除bss完之后的地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r2</span>, <span class="hljs-number">#0</span><br><br><span class="hljs-symbol">clear_loop:</span><br><span class="hljs-keyword">str</span> <span class="hljs-built_in">r2</span>, [<span class="hljs-built_in">r0</span>], <span class="hljs-number">#4</span><span class="hljs-comment">// 先将r2中的值放入r0所指向的内存地址（r0中的值作为内存地址），</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r1</span><span class="hljs-comment">// 然后r0 = r0 + 4</span><br><span class="hljs-keyword">bne</span> clear_loop<br><br><span class="hljs-comment">//清理完bss段后重定位就结束了。然后当前的状况是：</span><br><span class="hljs-comment">//1、当前运行地址还在0xd0020010开头的（重定位前的）那一份代码中运行着。</span><br><span class="hljs-comment">//2、此时SRAM中已经有了2份代码，1份在d0020010开头，另一份在d0024000开头的位置。</span><br><span class="hljs-comment">//然后就要长跳转了。</span><br><br><span class="hljs-symbol">run_on_dram:</span><br><span class="hljs-comment">// 长跳转到led_blink开始第二阶段</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=led_blink</span><span class="hljs-comment">// ldr指令实现长跳转，把led_blink的值，写入pc寄存器</span><br><br><span class="hljs-comment">// 从这里之后就可以开始调用C程序了</span><br><span class="hljs-comment">//bl led_blink// bl指令实现短跳转</span><br><br>    <span class="hljs-comment">// 汇编最后的这个死循环不能丢</span><br><span class="hljs-keyword">b</span> .<br><br></code></pre></td></tr></table></figure><p><code>adr</code>与ldr伪指令的区别：<code>ldr</code>和<code>adr</code>都是伪指令</p><ul><li><code>adr</code>短加载，指令加载符号地址，加载的是运行时地址；</li><li><code>ldr</code>长加载，指令在加载符号地址时，加载的是链接地址；</li></ul><p>重定位就是汇编代码中的<code>copy_loop</code>函数，代码的作用是使用循环结构来逐句复制代码到链接地址。<br>复制的源地址是SRAM的<code>0xd0020010</code>，复制目标地址是SRAM的<code>0xd0024000</code>，复制长度是<code>bss_start</code>减去<code>_start</code>，所以复制的长度就是整个重定位需要重定位的长度，也就是整个程序中代码段+数据段的长度。<code>bss</code>段（bss段中就是0初始化的全局变量）不需要重定位。</p><p>清除<code>bss</code>段是为了满足C语言的运行时要求（C语言要求显式初始化为0的全局变量，或者未显式初始化的全局变量的值为0，实际上C语言编译器就是通过清<code>bss</code>段来实现C语言的这个特性的）。一般情况下我们的程序是不需要负责清零<code>bss</code>段的（C语言编译器和链接器会帮我们的程序自动添加一段头程序，这段程序会在我们的main函数之前运行，这段代码就负责清除<code>bss</code>）。但是在我们代码重定位了之后，因为编译器帮我们附加的代码只是帮我们清除了运行地址那一份代码中的<code>bss</code>，而未清除重定位地址处开头的那一份代码的<code>bss</code>，所以重定位之后需要自己去清除<code>bss</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>链接</tag>
      
      <tag>编译</tag>
      
      <tag>动态链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-存储与IO系统</title>
    <link href="/2022/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E4%B8%8EIO%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E4%B8%8EIO%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><h4 id="SRAM（Static-Random-Access-Memory，静态随机存取存储器）"><a href="#SRAM（Static-Random-Access-Memory，静态随机存取存储器）" class="headerlink" title="SRAM（Static Random-Access Memory，静态随机存取存储器）"></a>SRAM（Static Random-Access Memory，静态随机存取存储器）</h4><p>CPU如果形容成人的大脑的话，那么CPU Cache (高速缓存)就好比人的记忆。它用的是SRAM芯片。</p><p>SRAM的“静态”的意思是，只要处于通电状态，里面的数据就保持存在，一旦断电，数据就会丢失。SRAM里1bit数据需要6-8个晶体管，所以SRAM的存储密度不高，同样的物理空间，能够存的数据有限。因为其电路简单，访问速度非常快。</p><p>在CPU里，通常会有L1、L2、L3这样三层高速缓存。每个CPU核心都有一块属于自己的L1高速缓存，通常分成指令缓存和数据缓存，分开存放CPU使用的指令和数据。</p><p>L2的Cache同样是每个CPU核心都有的，不过它往往不在CPU核心的内部。所以，L2 Cache 的访问速度会比L1稍微慢一些。而L3Cache，则通常是多个CPU核心共用的，尺寸会更大一些，访问速度自然也就更慢一些。</p><p>你可以把CPU中的L1Cache理解为我们的短期记忆，把L2/L3Cache理解成长期记忆，把内存当成我们拥有的书架或者书桌。当我们自己记忆中没有资料的时候，可以从书桌或者书架上拿书来翻阅。这个过程中就相当于，数据从内存中加载到CPU的寄存器和Cache中，然后通过“大脑”，也就是CPU，进行处理和运算。</p><h4 id="DRAM（Dynamic-Random-Access-Memory，动态随机存取存储器）"><a href="#DRAM（Dynamic-Random-Access-Memory，动态随机存取存储器）" class="headerlink" title="DRAM（Dynamic Random Access Memory，动态随机存取存储器）"></a>DRAM（Dynamic Random Access Memory，动态随机存取存储器）</h4><p>内存用的芯片和Cache有所不同，它用的是一种叫作DRAM的芯片，比起SRAM来说，它的密度更高，有更大的容量，而且它也比SRAM芯片便宜不少。</p><p>DRAM被称为“动态”存储器，是因为DRAM需要靠不断地“刷新”，才能保持数据被存储起来。DRAM的一个比特，只需要一个晶体管和一个电容就能存储。所以，DRAM在同样的物理空间下，能够存储的数据也就更多，也就是存储的“密度”更大。但是，因为数据是存储在电容里的，电容会不断漏电，所以需要定时刷新充电，才能保持数据不丢失。DRAM的数据访问电路和刷新电路都比SRAM更复杂，所以访问延时也就更长。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081652018.png"></p><p>从Cache、内存，到SSD和HDD硬盘，一台现代计算机中，就用上了所有这些存储器设备。其中，容量越小的设备速度越快，而且，CPU并不是直接和每一种存储器设备打交道，而是每一种存储器设备，只和它相邻的存储设备打交道。比如，CPUCache是从内存里加载而来的，或者需要写回内存，并不会直接写回数据到硬盘，也不会直接从硬盘加载数据到CPUCache中，而是先加载到内存，再从内存加载到Cache中。</p><p>这样，各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降，也就构成了我们日常所说的存储器层次结构。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="CPU-cache"><a href="#CPU-cache" class="headerlink" title="CPU cache"></a>CPU cache</h3><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>缓存不是CPU的专属功能，可以把它当成一种策略，任何时候想要增加数据传输性能，都可以通过加一层缓存试试。</p><p>存储器层次结构的中心思想是，对于每个$k$，位于$k$层的更快更小的存储设备作为位于$k+1$层的更大更慢的存储设备的缓存。<a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86">下图</a>展示了存储器层次结构中缓存的一般性概念。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711145943.png"></p><div id="存储器层次结构中基本的缓存原理"></div><p>数据总是以块<code>block</code>为单位，在层与层之间来回复制。</p><p>说回高速缓存，按照摩尔定律，CPU的访问速度每18个月便会翻一翻，相当于每年增长60%。内存的访问速度虽然不断增长，却远没有那么快，每年只增长7%左右。这样就导致CPU性能和内存访问的差距不断拉大。为了弥补两者之间差异，现代CPU引入了<strong>高速缓存</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220708092012.png"></p><p>CPU的读（load）实质上就是从缓存中读取数据到寄存器（register）里，在多级缓存的架构中，如果缓存中找不到数据（Cache miss），就会层层读取二级缓存三级缓存，一旦所有的缓存里都找不到对应的数据，就要去内存里寻址了。寻址到的数据首先放到寄存器里，其副本会驻留到CPU的缓存中。</p><p>CPU的写（store）也是针对缓存作写入。并不会直接和内存打交道，而是通过某种机制实现数据从缓存到内存的写回（write back）。</p><p>缓存到底如何与CPU和主存数据交换的？CPU如何从缓存中读写数据的？缓存中没有读的数据，或者缓存写满了怎么办？我们先从CPU如何读取数据说起。</p><h4 id="缓存读取"><a href="#缓存读取" class="headerlink" title="缓存读取"></a>缓存读取</h4><p>CPU发起一个读取请求后，返回的结果会有如下几种情况：</p><ul><li>缓存命中(cache hit)<br>要读取的数据刚好在缓存中，叫做<strong>缓存命中</strong>。</li><li>缓存不命中(cache miss)<br>发送缓存不命中，缓存就得执行一直<strong>放置策略</strong>(placement policy)，比如LRU。来决定从主存中取出的数据放到哪里。<ul><li><strong>强制性不命中</strong>(compulsory miss)/冷不命中(cold miss)：缓存中没有要读取的数据，需要从主存读取数据，并将数据放入缓存。</li><li><strong>冲突不命中</strong>(conflict miss)：缓存中有要读的数据，在采取放置策略时，从主存中取数据放到缓存时发生了冲突，这叫做冲突不命中。</li></ul></li></ul><h4 id="高速缓存存储器组织结构"><a href="#高速缓存存储器组织结构" class="headerlink" title="高速缓存存储器组织结构"></a>高速缓存存储器组织结构</h4><p>整个Cache被划分为1个或多个<strong>组</strong> (Set)，$S$ 表示组的个数。每个组包含1个或多个<strong>缓存行</strong>(Cache line)，$E$ 表示一个组中缓存行的行数。每个缓存行由三部分组成：<strong>有效位</strong>(valid)，<strong>标记位</strong>（tag），<strong>数据块</strong>（cache block）。</p><ul><li>有效位：该位等于1，表示这个行数据有效。</li><li>标记位：唯一的标识了存储在高速缓存中的块，标识目标数据是否存在当前的缓存行中。</li><li>数据块：一部分内存数据的副本。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711171136.png"></p><p>Cache的结构可以由元组$(S,E,B,m)$表示。不包括有效位和标记位。Cache的大小为 $C=S \times E \times B$.</p><p>接下来看看Cache是如何工作的，当CPU执行数据加载指令，从内存地址A读取数据时，根据存储器层次原理，如果Cache中保存着目标数据的副本，那么就立即将数据返回给CPU。那么Cache如何知道自己保存了目标数据的副本呢？</p><p>假设目标地址的数据长度为$m$位，这个地址被参数 $S$ 和 $B$ 分成了三个字段：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711174416.png"></p><p>首先通过长度为$s$的<strong>组索引</strong>，确定目标数据保存在哪一个组(Set)中，其次通过长度为$t$的<strong>标记</strong>，确定在哪一行，需要注意的是此时有效位必须等于1，最后根据长度为$b$的<strong>块偏移</strong>，来确定目标数据在数据块中的确切位置。</p><blockquote><p>Q：既然读取Cache第一步是组选择，为什么不用高位作为组索引，而使用中间的为作为组索引？<br>A：如果使用了高位作索引，那么一些连续的内存块就会映射到相同的高速缓存块。如图前四个块映射到第一个缓存组，第二个四个块映射到第二个组，依次类推。如果一个程序有良好的空间局部性，顺序扫描一个数组的元素，那么在任何时候，缓存中都只保存在一个块大小的数组内容。这样对缓存的使用率很低。相比而言，如果使用中间的位作为组索引，那么相邻的块总是映射到不同的组，图中的情况能够存放整个大小的数组片。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711185819.png"></p></blockquote><h5 id="直接映射高速缓存-Direct-Mapped-Cache"><a href="#直接映射高速缓存-Direct-Mapped-Cache" class="headerlink" title="直接映射高速缓存 Direct Mapped Cache"></a>直接映射高速缓存 Direct Mapped Cache</h5><p>根据每个组的缓存行数 $E$ 的不同，Cache被分为不同的类。每个组只有一行$E=1$的高速缓存被称为<strong>直接映射高速缓存</strong>(direct-mapped cache)。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711190845.png"></p><p>当一条加载指令指示CPU从主存地址A中读取一个字w时，会将该主存地址A发送到高速缓存中，则高速缓存会根据<strong>组选择</strong>，<strong>行匹配</strong>和<strong>字抽取</strong>三步来判断地址A是否命中。</p><p><strong>组选择</strong>(set selection)：根据组索引值来确定属于哪一个组，如图中索引长度为5位，可以检索32个组($2^5=32$)。当$s=0$时，此时组选择的结果为<code>set 0</code>，当$s=1$时，此时组选择的结果为<code>set 1</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711191708.png"></p><p>**行匹配(line match)**：首先看缓存行的有效位，此时有效位为1，表示当前数据有效。然后对比缓存行的标记<code>0110</code>与地址中的标记<code>0110</code>是否相等，如果相等，则表示目标数据在当前的缓存行中（缓存命中）。如果不一致或者有效位为0，则表示目标数据不在当前的缓存行中（缓存不命中）。如果命中，就可以进行下一步字抽取。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711192435.png"></p><p>**字抽取(word extraction)**：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于<code>100</code>时，表示目标数据起始地址位于字节4处。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711192757.png"></p><p>下面通过一个例子来解释清除这个过程。假设我们有一个直接映射高速缓存，描述为$(S,E,B,m) = (4,1,2,4)$。换句话说，高速缓存有4个组，每个组1行，每个数据块2个字节，地址长度为4位。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711194256.png"></p><p>从图中可以看出，8个内存块，但只有4个高速缓存组，所以会有多个块映射到同一个高速缓存组中。例如，块0和块4都会被映射到组0。</p><p>下面我们来模拟当CPU执行一系列读的时候，高速缓存的执行情况，我们假设每次CPU读1个字节的字。</p><p><strong>读地址0(0000)的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711193901.gif"></p><p><strong>读地址1(0001)的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711194838.gif"></p><p><strong>读地址13(1101)的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711195108.gif"></p><p><strong>读地址8(1000)的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711200054.gif"></p><p><strong>读地址0(0000)的字：</strong><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220711200409.gif"></p><h5 id="组相联高速缓存-Set-Associative-Cache"><a href="#组相联高速缓存-Set-Associative-Cache" class="headerlink" title="组相联高速缓存 Set Associative Cache"></a>组相联高速缓存 Set Associative Cache</h5><p>由于直接映射高速缓存的组中只有一行，所以容易发生冲突不命中。组相联高速缓存(Set associative cache)运行有多行缓存行。但是缓存行最大不能超过 $C/B$。 </p><p>如图一个组中包含了两行缓存行，这种我们称为2路相联高速缓存。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220712160513.png"></p><p><strong>组选择</strong>：与直接映射高速缓存的组选择过程一样。</p><p><strong>行匹配</strong>：因为一个组有多行，所以需要遍历所有行，找到一个有效位为1，并且标记为与地址中的标记位相匹配的一行。如果找到了，表示缓存命中。</p><p><strong>字抽取</strong>：根据偏移量$b$确定目标数据的确切位置，通俗来说就是从数据块的什么位置开始抽取位置。如当偏移块等于<code>100</code>时，表示目标数据起始地址位于字节4处。</p><p>如果不命中，那么就需要从主存中取出需要的数据块，但是将数据块放在哪一行缓存行呢？如果存在空行($valid=0$)，那就放到空行里。如果没有空行，就得选择一个非空行来替换，同时希望CPU不会很快引用这个被替换的行。这里介绍几个替换策略。</p><p>最简单的方式就是随机选择一行来替换，其他复杂的方式就是利用局部性原理，使得接下来CPU引用替换的行概率最小。如</p><h3 id="缓存一致性协议MESI"><a href="#缓存一致性协议MESI" class="headerlink" title="缓存一致性协议MESI"></a>缓存一致性协议MESI</h3><h4 id="为什么需要缓存一致"><a href="#为什么需要缓存一致" class="headerlink" title="为什么需要缓存一致"></a>为什么需要缓存一致</h4><p>目前主流电脑的CPU都是多核心的，多核心的有点就是在不能提升CPU主频后，通过增加核心来提升CPU吞吐量。每个核心都有自己的L1 Cache和L2 Cache，只是共用L3 Cache和主内存。每个核心操作是独立的，每个核心的Cache就不是同步更新的，这样就会带来缓存一致性（Cache Coherence）的问题。</p><p>举个例子，如图：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205291536919.gif"></p><p>有2个CPU，主内存里有个变量<code>x=0</code>。CPU A中有个需要将变量<code>x</code>加<code>1</code>。CPU A就将变量<code>x</code>加载到自己的缓存中，然后将变量<code>x</code>加<code>1</code>。因为此时CPU A 还未将缓存数据写回主内存，CPU B再读取变量<code>x</code>时，变量<code>x</code>的值依然是<code>0</code>。</p><p>这里的问题就是所谓的缓存一致性问题，因为CPU A的缓存与CPU B的缓存是不一致的。</p><h4 id="如何解决缓存一致性问题"><a href="#如何解决缓存一致性问题" class="headerlink" title="如何解决缓存一致性问题"></a>如何解决缓存一致性问题</h4><h5 id="通过在总线加LOCK锁的方式"><a href="#通过在总线加LOCK锁的方式" class="headerlink" title="通过在总线加LOCK锁的方式"></a>通过在总线加LOCK锁的方式</h5><p>在锁住总线上加一个LOCK标识，CPU A进行读写操作时，锁住总线，其他CPU此时无法进行内存读写操作，只有等解锁了才能进行操作。</p><p>该方式因为锁住了整个总线，所以效率低。</p><h5 id="缓存一致性协议MESI-1"><a href="#缓存一致性协议MESI-1" class="headerlink" title="缓存一致性协议MESI"></a>缓存一致性协议MESI</h5><p>该方式对单个缓存行的数据进行加锁，不会影响到内存其他数据的读写。</p><p>在学习MESI协议之前，简单了解一下总线嗅探机制（Bus Snooping）。要对自己的缓存加锁，需要通知其他CPU，多个 CPU 核心之间的数据传播问题。最常见的一种解决方案就是总线嗅探。</p><p>这个策略，本质上就是把所有的读写请求都通过总线广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。MESI就是基于总线嗅探机制的缓存一致性协议。</p><p>MESI 协议的由来是对Cache Line 的四个不同的标记，分别是：</p><table><thead><tr><th align="center"><div style="width:50px">状态</div></th><th align="center"><div style="width:100px">状态</div></th><th><div style="width:200px">描述</div></th><th><div style="width:200px">监听任务</div></th></tr></thead><tbody><tr><td align="center">Modified</td><td align="center">已修改</td><td>该 Cache Line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中</td><td>Cache Line 必须时刻监听所有试图读该 Cache Line 相对于主存的操作，这种操作必须在缓存将该 Cache Line 写回主存并将状态改为S状态之前，被延迟执行</td></tr><tr><td align="center">Exclusive</td><td align="center">独享，互斥</td><td>该 Cache Line 有效，数据和内存中的数据一直，数据只存在于本 Cache</td><td>Cache Line 必须监听其他缓存读主存中该 Cache Line 的操作，一旦有这种操作，该 Cache Line 需要改为S状态</td></tr><tr><td align="center">Shared</td><td align="center">共享的</td><td>该 Cache Line 有效，数据和内存中的数据一直，数据存在于很多个 Cache 中</td><td>Cache Line 必须监听其他  Cache Line 使该 Cache Line 无效或者独享该 Cache Line 的请求，并将 Cache Line 改为I状态</td></tr><tr><td align="center">Invalid</td><td align="center">无效的</td><td>该 Cache Line 无效</td><td>无</td></tr></tbody></table><p>整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把各个状态之间的流转用表格总结了一下：</p><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:300px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">M</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">M</td></tr><tr><td align="center">M</td><td align="center">Local Write</td><td>修改cache数据，状态不变</td><td align="center">M</td></tr><tr><td align="center">M</td><td align="center">Remote Read</td><td>这行数据被写到内存中，使其他核能使用到最新数据，状态变为S</td><td align="center">S</td></tr><tr><td align="center">M</td><td align="center">Remote Write</td><td>这行数据被写入内存中，其他核可以获取到最新数据，由于其他CPU修改该条数据，则本地Cache变为I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">E</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">E</td></tr><tr><td align="center">E</td><td align="center">Local Write</td><td>修改数据，状态改为M</td><td align="center">M</td></tr><tr><td align="center">E</td><td align="center">Remote Read</td><td>数据和其他CPU共享，变为S</td><td align="center">S</td></tr><tr><td align="center">E</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,text-align: center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">S</td><td align="center">Local Read</td><td>从 Cache 中读，状态不变</td><td align="center">S</td></tr><tr><td align="center">S</td><td align="center">Local Write</td><td>修改数据，状态改为M，其他CPU的Cache Line状态改为I</td><td align="center">M</td></tr><tr><td align="center">S</td><td align="center">Remote Read</td><td>数据和其他CPU共享，状态不变</td><td align="center">S</td></tr><tr><td align="center">S</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为I</td><td align="center">I</td></tr></tbody></table><table><thead><tr><th align="center"><div style="width:80px">当前状态</div></th><th align="center"><div style="width:80px">事件</div></th><th><div style="width:200px,center">行为</div></th><th align="center"><div style="width:80px">下个状态</div></th></tr></thead><tbody><tr><td align="center">I</td><td align="center">Local Read</td><td>1. 如果其他CPU没有这份数据，直接从内存中加载数据，状态变为E；<br> 2. 如果其他CPU有这个数据，且Cache Line状态为M，则先把Cache Line中的内容写回到主存。本地Cache再从内存中读取数据，这时两个Cache Line的状态都变为S；<br>3. 如果其他Cache Line有这份数据，并且状态为S或者E，则本地Cache Line从主存读取数据，并将这些Cache Line状态改为S</td><td align="center">E或者S</td></tr><tr><td align="center">I</td><td align="center">Local Write</td><td>1. 先从内存中读取数据，如果其他Cache Line中有这份数据，且状态为M，则现将数据更新到主存再读取，将Cache Line状态改为M；<br> 2. 如果其他Cache Line有这份数据，且状态为E或者S，则其他Cache Line状态改为I</td><td align="center">M</td></tr><tr><td align="center">I</td><td align="center">Remote Read</td><td>数据和其他CPU共享，状态不变</td><td align="center">S</td></tr><tr><td align="center">I</td><td align="center">Remote Write</td><td>数据被修改，本地缓存失效，变为I</td><td align="center">I</td></tr></tbody></table><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>计算机有五大组成部分，分别是：运算器、控制器、存储器、输入设备和输出设备。而内存就是其中的存储器。我们的数据和指令都需要先放到内存中，然后再被CPU执行。</p><p>操作系统中程序并不能直接访问物理内存，我们的内存需要被分成固定大小的页（Page），然后再通过<strong>虚拟内存地址（Virtual Address）到物理内存地址（Physical Address）的地址转换（Address Translation）</strong>，才能到达实际存放数据的物理内存位置。而我们的程序看到的内存地址，都是虚拟内存地址。那么如何进行转换的呢？</p><h3 id="简单页表"><a href="#简单页表" class="headerlink" title="简单页表"></a>简单页表</h3><p>最简单的方式，就是建立一张虚拟内存到物理内存的映射表，在计算机里叫做页表（Page Table）。页表这个地址转换的办法，会把一个内存地址分成页号（Directory）和偏移量（Offset）两个部分，是不是似曾相识，因为在前面的高速缓存里，缓存的结构也是这样的。</p><p>以一个32位地址举例，高20位是虚拟页号，可以从虚拟页表中找到物理页号的信息，低12位是偏移量，可以准确获得物理地址。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207161640968.png"></p><p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p><ul><li>把虚拟内存地址，切分成页号和偏移量的组合；</li><li>从页表里面，查询出虚拟页号，对应的物理页号；</li><li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202207161645714.png"></p><p>但是这样的页表有个问题，它需要记录$2^{20}$个物理页表，这个存储关系，就好比一个 $2^{20}$大小的数组。一个页号是完整的 32 位的 4 字节（Byte），这样一个页表就需要 4MB 的空间。并且每个进程都会有这样一个页表，现代电脑正常都有成百上千个进程，如果用这样的页表肯定行不通的。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>所以，<strong>在一个实际的程序进程里面，虚拟内存占用的地址空间，通常是两段连续的空间。而不是完全散落的随机的内存地址</strong>。而多级页表，就特别适合这样的内存地址分布。</p><p><a href="https://zhuanlan.zhihu.com/p/357648933">谈一谈内存管理，虚拟内存，多级页表 - 知乎</a></p><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><h3 id="内存保护-可执行空间保护"><a href="#内存保护-可执行空间保护" class="headerlink" title="内存保护-可执行空间保护"></a>内存保护-可执行空间保护</h3><h3 id="内存保护-地址空间布局随机化"><a href="#内存保护-地址空间布局随机化" class="headerlink" title="内存保护-地址空间布局随机化"></a>内存保护-地址空间布局随机化</h3><p>Address Space Layout Randomization</p><h2 id="总线：-计算机内部的高速公路"><a href="#总线：-计算机内部的高速公路" class="headerlink" title="总线： 计算机内部的高速公路"></a>总线： 计算机内部的高速公路</h2><p>计算机由控制器、运算器、存储器、输入设备以及输出设备五大部分组成。CPU所代表的控制器和运算器，要和存储器，也就是我们的主内存，以及输入和输出设备进行通信。那么计算机是用什么样的方式来完成，CPU和内存、以及外部输入输出设备的通信呢？答案就是通过总线来通信。</p><p>计算机里有不同的硬件设备，如果设备与设备之间都单独连接，那么就需要N*N的连线。那么怎么降低复杂度呢？与其让各个设备之间互相单独通信，不如我们去设计一个公用的线路。CPU想要和什么设备通信，通信的指令是什么，对应的数据是什么，都发送到这个线路上；设备要向CPU发送什么信息呢，也发送到这个线路上。这个线路就好像一个高速公路，各个设备和其他设备之间，不需要单独建公路，只建一条小路通向这条高速公路就好了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081510203.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081510711.png"></p><h3 id="三种线路和多总线架构"><a href="#三种线路和多总线架构" class="headerlink" title="三种线路和多总线架构"></a>三种线路和多总线架构</h3><p>首先，CPU和内存以及高速缓存通信的总线，这里面通常有两种总线。这种方式，我们称之为双独立总线（Dual Independent Bus，缩写为 DIB）。CPU里，有一个快速的本地总线（Local Bus），以及一个速度相对较慢的前端总线（Front-side Bus）。</p><p>现代的CPU里，通常有专门的高速缓存芯片。这里的高速本地总线，就是用来和高速缓存通信的。而前端总线，则是用来和主内存以及输入输出设备通信的。有时候，我们会把本地总线也叫作后端总线（Back-sideBus），和前面的前端总线对应起来。</p><p>除了前端总线呢，我们常常还会听到PCI总线、I/O总线或者系统总线（System Bus）。看到这么多总线的名字，你是不是已经有点晕了。这些名词确实容易混为一谈。其实各种总线的命名一直都很混乱，我们不如直接来看一看CPU的硬件架构图。对照图来看，一切问题就都清楚了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081513938.png"></p><p>CPU里面的北桥芯片，把我们上面说的前端总线，一分为二，变成了三个总线。我们的前端总线，其实就是系统总线。CPU里面的内存接口，直接和系统总线通信，然后系统总线再接入一个I/O桥接器（I/OBridge）。这个I/O桥接器，一边接入了我们的内存总线，使得我们的CPU和内存通信；另一边呢，又接入了一个I/O总线，用来连接I/O设备。</p><p>事实上，真实的计算机里，这个总线层面拆分得更细。根据不同的设备，还会分成独立的PCI总线、ISA总线等等。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081516341.png"></p><p>在物理层面，其实我们完全可以把总线看作一组“电线”。不过呢，这些电线之间也是有分工的，我们通常有三类线路。</p><ol><li>数据线（Data Bus），用来传输实际的数据信息，也就是实际上了公交车的“人”。</li><li>地址线（Address Bus），用来确定到底把数据传输到哪里去，是内存的某个位置，还是某一个I/O设备。这个其实就相当于拿了个纸条，写下了上面的人要下车的站点。</li><li>控制线（ControlBus），用来控制对于总线的访问。虽然我们把总线比喻成了一辆公交车。那么有人想要做公交车的时候，需要告诉公交车司机，这个就是我们的控制信号。</li></ol><p>尽管总线减少了设备之间的耦合，也降低了系统设计的复杂度，但同时也带来了一个新问题，那就是<strong>总线不能同时给多个设备提供通信功能</strong>。</p><p>我们的总线是很多个设备公用的，那多个设备都想要用总线，我们就需要有一个机制，去决定这种情况下，到底把总线给哪一个设备用。这个机制，就叫作<strong>总线裁决</strong>（Bus Arbitraction）</p><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>过去几年，计算机产业一直在为提升I/O设备的速度而努力，从机械硬盘HDD到固态硬盘SSD，从SATA协议到PCIE协议，虽然速度都几十上百倍的增加，但是仍然不够快。因为相比于CPU基本都是2GHz的频率（每秒会有 20 亿次的操作），SSD 硬盘的 IOPS 的 2 万次操作就显得微不足道。</p><p>如果我们对于 I/O 的操作，都是由 CPU 发出对应的指令，然后等待 I/O 设备完成操作之后返回，那 CPU 有大量的时间其实都是在等待 I/O 设备完成操作。特别是当传输的数据量比较大的时候，比如进行大文件复制，如果所有数据都要经过 CPU，实在是有点儿太浪费时间了。</p><p>因此，计算机工程师们，就发明了<strong>DMA 技术</strong>，也就是<strong>直接内存访问（Direct Memory Access）技术</strong>，来减少 CPU 等待的时间。</p><h3 id="什么是DMA"><a href="#什么是DMA" class="headerlink" title="什么是DMA"></a>什么是DMA</h3><p>本质上，DMA 技术就是我们在主板上放一块<strong>独立的芯片</strong>。在进行内存和 I/O 设备的数据传输的时候，我们不再通过 CPU 来控制数据传输，而直接通过DMA 控制器（DMA Controller，简称 DMAC）。这块芯片，我们可以认为它其实就是一个<strong>协处理器</strong>（Co-Processor）。</p><p>DMAC 最有价值的地方体现在，当我们要传输的数据特别大、速度特别快，或者传输的数据特别小、速度特别慢的时候。</p><p>比如说，我们用千兆网卡或者硬盘传输大量数据的时候，如果都用 CPU 来搬运的话，肯定忙不过来，所以可以选择 DMAC。而当数据传输很慢的时候，DMAC 可以等数据到齐了，再向CPU发起中断，让 CPU 去处理，而不是让 CPU 在那里忙等待。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202208152252016.png"></p><ol><li><p>首先，CPU 还是作为一个主设备，向 DMAC 设备发起请求。这个请求，其实就是在 DMAC 里面修改配置寄存器。</p></li><li><p>CPU 修改 DMAC 的配置的时候，会告诉 DMAC 这样几个信息：</p><ul><li>源地址的初始值：数据要从哪里传输过来。如果我们要从内存里面写入数据到硬盘上，那么就是要读取的数据在内存里面的地址。</li><li>传输时候的地址增减方式：数据是从大的地址向小的地址传输，还是从小的地址往大的地址传输。</li><li>传输的数据长度：也就是我们一共要传输多少数据</li></ul></li><li><p>设置完这些信息之后，DMAC 就会变成一个空闲的状态（Idle）。</p></li><li><p>如果我们要从硬盘上往内存里面加载数据，这个时候，硬盘就会向 DMAC 发起一个数据传输请求。这个请求并不是通过总线，而是通过一个额外的连线。</p></li><li><p>然后，我们的 DMAC 需要再通过一个额外的连线响应这个申请。</p></li><li><p>DMAC 这个芯片，就向硬盘的接口发起要总线读的传输请求。数据就从硬盘里面，读到了 DMAC 的控制器里面。</p></li><li><p>DMAC 再向我们的内存发起总线写的数据传输请求，把数据写入到内存里面。</p></li><li><p>DMAC 会反复进行上面第 6、7 步的操作，直到 DMAC 的寄存器里面设置的数据长度传输完成。</p></li><li><p>数据传输完成之后，DMAC 重新回到第 3 步的空闲状态。</p></li></ol><p>所以，整个数据传输的过程中，我们不是通过 CPU 来搬运数据，而是由 DMAC 这个芯片来搬运数据。但是 CPU 在这个过程中也是必不可少的。因为传输什么数据，从哪里传输到哪里，其实还是由 CPU 来设置的。这也是为什么，DMAC 被叫作 <strong>协处理器</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1cJ411K7HW?spm_id_from=333.999.0.0">【硬件科普】电脑主板右下角的散热片下面究竟隐藏着什么？详解主板南桥芯片组的功能和作用_哔哩哔哩_bilibili</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
      <tag>计算机组成原理</tag>
      
      <tag>虚拟内存</tag>
      
      <tag>页表</tag>
      
      <tag>DMA</tag>
      
      <tag>缓存</tag>
      
      <tag>总线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-处理器</title>
    <link href="/2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="建立数据通路：指令-运算-CPU"><a href="#建立数据通路：指令-运算-CPU" class="headerlink" title="建立数据通路：指令+运算=CPU"></a>建立数据通路：指令+运算=CPU</h2><p>指令周期</p><ul><li>Fetch（取得指令）：从内存里把指令加载到指令寄存器中。</li><li>Decode（指令译码）</li><li>Execute（执行指令）<br>重复操作这三步，这个循环称为指令周期。</li></ul><p>不同的步骤在不同组件内完成<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011556148.png"></p><p>机器周期/CPU周期：从内存里读取一条指令的最短时间。<br>时钟周期：就是机器的主频，一个CPU周期由多个时钟周期组成。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011607706.png"></p><p>操作元件：组合逻辑元件，ALU，功能是在特定的输入下，生成特定的输出。<br>存储元件：状态元件，寄存器。</p><p>将操作元件，操作原件通过数据总线的方式连接起来，就<strong>建立了数据通路</strong>了。</p><p>控制器： 循环执行取址-译码，产生控制信号交给ALU处理。电路特别复杂，CPU如果支持2000个指令，意味着控制器输出的信号有2000个不同的组合。</p><p>CPU需要的电路</p><ul><li>根据输入计算出结果的一个电路，ALU</li><li>能够进行状态读写的电路元件，寄存器</li><li>按照固定周期，不停实现PC寄存器自增的电路</li><li>译码电路，能够对于拿到的内存地址获取对应的数据或者指令</li></ul><blockquote><p>Q :  CPU 好像一个永不停歇的机器，一直在不停地读取下一条指令去运行。那 为什么 CPU 还会有满载运行和 Idle 闲置的状态呢？<br>A：CPU 还会有满载运行和 Idle 闲置的状态, 指的系统层面的状态。即使是Idle空闲状态，cpu也在执行循环指令。<br>操作系统内核有 idle 进程，优先级最低，仅当其他进程都阻塞时被调度器选中。idle 进程循环执行 HLT 指令，关闭 CPU 大部分功能以降低功耗，收到中断信号时 CPU 恢复正常状态。 CPU在空闲状态就会停止执行，即切断时钟信号，CPU主频会瞬间降低为0，功耗也会瞬间降为0。由于这个空闲状态是十分短暂的，所以你在任务管理器也只会看到CPU频率下降，不会看到降为0。 当CPU从空闲状态中恢复时，就会接通时钟信号，CPU频率就会上升。所以你会在任务管理器里面看到CPU的频率起伏变化。</p></blockquote><p>实现一个完整的CPU，除了<strong>组合逻辑电路</strong>，还需要<strong>时序逻辑电路</strong>。因为组合逻辑电路只是处理固定输入，得到固定输出，这种电路只能协助我们完成一些计算工作，干不了太复杂的工作。</p><p>时序逻辑电路可以解决这几个问题：</p><ul><li>自动运行问题<br>  时序电路接通之后可以<strong>不停地开启和关闭开关</strong>，进入一个自动运行的状态。这个使得我们上一讲说的，控制器不停地让 PC 寄存器自增读取下一条指令成为可能。</li><li>存储问题<br>  通过时序电路实现的触发器，<strong>能把计算结果存储在特定的电路里面</strong>， 而不是像组合逻辑电路那样，一旦输入有任何改变，对应的输出也会改变。</li><li><strong>时序协调问题</strong><br>  无论是程序实现的软件指令，还是到硬件层面，各种指令的操作都有<strong>先后的顺序</strong>要求。时序电路使得不同的事件按照时间顺序发生。</li></ul><p><strong>解决自动运行问题</strong><br>实现时序逻辑电路的第一步就需要一个时钟。CPU的主频是一个晶振来实现的，晶振生成的电路信号就是我们的时钟信号。</p><p>实现如图所示，我们在原先一般只放一个开关的信号输入端，放上了两个开 关。一个开关 A，一开始是断开的，由我们手工控制；另外一个开关 B，一开始是合上的，<br>磁性线圈对准一开始就合上的开关 B。</p><p>于是，一旦我们合上开关 A，磁性线圈就会通电，产生磁性，开关 B 就会从合上变成断 开。一旦这个开关断开了，电路就中断了，磁性线圈就失去了磁性。于是，开关 B 又会弹 回到合上的状态。这样一来，电路接通，线圈又有了磁性。我们的电路就会来回不断地在开<br>启、关闭这两个状态中切换。</p><p>这个不断切换的过程，对于下游电路来说，就是不断地产生新的 0 和 1 这样的信号。如果 你在下游的电路上接上一个灯泡，就会发现这个灯泡在亮和暗之间不停切换。这个按照固定的周期不断在 0 和 1 之间切换的信号，就是我们的时钟信号。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011740388.png"></p><p>一般这样产生的时钟信号，就像你在各种教科书图例中看到的一样，是一个振荡产生的 0、 1 信号。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011745410.png"></p><p>这种电路，其实就相当于把电路的输出信号作为输入信号，再回到当前电路。这样的电路构 造方式呢，我们叫作反馈电路（Feedback Circuit）。</p><p>上面这个反馈电路一般可以用下面这个示意图来表 示，其实就是一个输出结果接回输入的反相器（Inverter），也就是我们之前讲过的非门。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011746094.png"></p><p><strong>解决存储问题</strong></p><p>有了时钟信号，我们的系统里就有了一个像“自动门”一样的开关。利用这个开关和相同的 反馈电路，我们就可以构造出一个有“记忆”功能的电路。</p><p>我们先来看下面这个 <strong>RS 触发器</strong>电路。这个电路由两个或非门电路组成。我在图里面，把它 标成了 A 和 B。</p><p>或非门真值表：<br>|NOR|0| 1|<br>| —- | —- | —- |<br>|0|1|0|<br>|1|0|0|<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205011851028.png"></p><ol><li>在这个电路一开始，输入开关都是关闭的，所以或非门（NOR）A 的输入是 0 和 0。对 应到我列的这个真值表，输出就是 1。而或非门 B 的输入是 0 和 A 的输出 1，对应输出 就是 0。B 的输出 0 反馈到 A，和之前的输入没有变化，A 的输出仍然是 1。而整个电 路的输出 Q，也就是 0。</li><li>当我们把 A 前面的开关 R 合上的时候，A 的输入变成了 1 和 0，输出就变成了 0，对应 B 的输入变成 0 和 0，输出就变成了 1。B 的输出 1 反馈给到了 A，A 的输入变成了 1 和 1，输出仍然是 0。所以把 A 的开关合上之后，电路仍然是稳定的，不会像晶振那样 振荡，但是整个电路的输出 Q 变成了 1。</li><li>这个时候，如果我们再把 A 前面的开关 R 打开，A 的输入变成和 1 和 0，输出还是 0， 对应的 B 的输入没有变化，输出也还是 1。B 的输出 1 反馈给到了 A，A 的输入变成了 1 和 0，输出仍然是 0。这个时候，电路仍然稳定。开关 R 和 S 的状态和上面的第一步是一样的，但是最终的输出 Q 仍然是 1，和第 1 步里 Q 状态是相反的。我们的输入和刚才第二步的开关状态不一样，但是输出结果仍然保留在了第 2 步时的输出没有发生变 化。</li><li>这个时候，只有我们再去关闭下面的开关 S，才可以看到，这个时候，B 有一个输入必然是 1，所以 B 的输出必然是 0，也就是电路的最终输出 Q 必然是 0。</li></ol><p>这样一个电路，我们称之为触发器（Flip-Flop）。接通开关 R，输出变为 1，即使断开开 关，输出还是 1 不变。接通开关 S，输出变为 0，即使断开开关，输出也还是 0。也就是， <strong>当两个开关都断开的时候，最终的输出结果，取决于之前动作的输出结果，这个也就是我们说的记忆功能</strong>。</p><h2 id="面向流水线的指令设计"><a href="#面向流水线的指令设计" class="headerlink" title="面向流水线的指令设计"></a>面向流水线的指令设计</h2><h3 id="单指令周期处理器"><a href="#单指令周期处理器" class="headerlink" title="单指令周期处理器"></a>单指令周期处理器</h3><p>一条CPU指令的执行，有三步：取得指令，译码，执行。需要一个时钟周期。自然设计指令时，我们也希望一整条指令能在一个时钟周期内完成。这就是单指令周期处理器。</p><p>不过，时钟周期是固定的，但是指令的电路复杂程度是不同的，所以实际一条指令执行的时间是不同的。从前面的学习中也知道，随着门电路层数的增加，门延迟的存在，计算复杂的指令需要的时间更长。</p><p>不同指令的执行时间不同，但是我们需要让所有指令都在一个时钟周期内完成，那就只好<strong>把执行时间最长的那个指令和时钟周期设成一样</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205142125165.png"></p><p>所以，在单指令周期处理器里面，无论是执行一条用不到 ALU 的无条件跳转指令，还是一条计算起来电路特别复杂的浮点数乘法运算，我们都等要等满一个时钟周期。这样时钟频率就无法提高，因为太高了，有些复杂指令无法在一个时钟周期内运行完。</p><p>到这可能就有人发问了，之前不是说一个 CPU 时钟周期，可以认为是完成一条简单指令的时间。为什么单指令周期处理器上，却成了执行一条最复杂的指令的时间？</p><p>这是因为，无论是 PC 上使用的 Intel CPU，还是手机上使用的 ARM CPU，都不是单指令周期处理器，而是采用了一种叫作<strong>指令流水线</strong>（Instruction Pipeline）的技术。</p><h3 id="流水线设计"><a href="#流水线设计" class="headerlink" title="流水线设计"></a>流水线设计</h3><p>CPU执行指令的过程和我们做饭一样，我们不会等米饭蒸好再洗菜，不会等肉腌好再切菜，而是蒸饭时，可以洗菜，腌肉时可以切菜。</p><p>CPU 的指令执行过程，其实也是由各个电路模块组成的。我们在取指令的时候，需要一个译码器把数据从内存里面取出来，写入到寄存器中；在指令译码的时候，我们需要另外一个译码器，把指令解析成对应的控制信号、内存地址和数据；到了指令执行的时候，我们需要的则是一个完成计算工作的 ALU。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205142142974.png"></p><p>这样一来，我们就不用把时钟周期设置成整条指令执行的时间，而是拆分成完成这样的一个一个小步骤需要的时间。同时，每一个阶段的电路在完成对应的任务之后，也不需要等待整个指令执行完成，而是可以直接执行下一条指令的对应阶段。</p><p>如果我们把一个指令拆分成“取指令 - 指令译码 - 执行指令”这样三个部分，那这就是一个<strong>三级的流水线</strong>。如果我们进一步把“执行指令”拆分成“ALU 计算（指令执行）- 内存访问 - 数据写回”，那么它就会变成一个<strong>五级的流水线</strong>。</p><p>五级的流水线，就表示我们在同一个时钟周期里面，同时运行五条指令的不同阶段。这个时候，虽然<strong>执行一条指令的时钟周期变成了 5</strong>，但是我们可以把 CPU 的主频提得更高了。<strong>我们不需要确保最复杂的那条指令在时钟周期里面执行完成，而只要保障一个最复杂的流水线级的操作，在一个时钟周期内完成就好了</strong>。</p><p>如果某一个操作步骤的时间太长，我们就可以考虑把这个步骤，拆分成更多的步骤，让所有步骤需要执行的时间尽量都差不多长。</p><p>既然流水线可以增加我们的吞吐率，你可能要问了，为什么我们不把流水线级数做得更深 呢？为什么不做成 20 级，乃至 40 级呢？这个其实有很多原因，我在之后几讲里面会详细讲解。这里，我先讲一个最基本的原因，就是增加流水线深度，其实是有性能成本的。</p><p>我们用来同步时钟周期的，不再是指令级别的，而是流水线阶段级别的。每一级流水线对应 的输出，都要放到流水线寄存器（Pipeline Register）里面，然后在下一个时钟周期，交给下一个流水线级去处理。所以，每增加一级的流水线，就要多一级写入到流水线寄存器的操作。虽然流水线寄存器非常快，比如只有 20 皮秒（ps，10−12 秒）。</p><p>但是，如果我们不断加深流水线，这些操作占整个指令的执行时间的比例就会不断增加。最后，我们的性能瓶颈就会出现在这些 overhead 上。如果我们指令的执行有 3 纳秒，也就 是 3000 皮秒。我们需要 20 级的流水线，那流水线寄存器的写入就需要花费 400 皮秒， 占了超过 10%。如果我们需要 50 级流水线，就要多花费 1 纳秒在流水线寄存器上，占到25%。这也就意味着，单纯地增加流水线级数，不仅不能提升性能，反而会有更多的overhead 的开销。所以，设计合理的流水线级数也是现代 CPU 中非常重要的一点。</p><h2 id="FPGA-ASIC-TPU"><a href="#FPGA-ASIC-TPU" class="headerlink" title="FPGA/ASIC/TPU"></a>FPGA/ASIC/TPU</h2><h3 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h3><p>CPU 是由简单的门电路搭积木一样搭建出来的，那一个CPU里有多少个晶体管这样的电路开关呢？一个四核i7的Intel CPU，有 20亿个晶体管。那么问题来了，我们要设计一个CPU，就要想办法连接这20亿个晶体管。</p><p>连接一次已经很难了，我们还要根据问题重新调整连接。设计更简单的特定功能的芯片，少说要几个月。而设计一个CPU往往以年计。在这个过程中，硬件工程师要设计、验证各种各样的方案，可能会遇到各种BUG。如果每验证一个方案都要生产一块芯片，这代价太高了。</p><p>我们有没有什么办法，不用单独制造一块专门的芯片来验证 硬件设计呢？能不能设计一个硬件，通过不同的程序代码，来操作这个硬件之前的电路连线，通过“编程”让这个硬件 变成我们设计的电路连线的芯片呢？</p><p>这个，就是我们接下来要说的 <strong>FPGA</strong>，也就是<strong>现场可编程门阵列</strong>（Field-Programmable Gate Array）。</p><ul><li>P 代表 Programmable，也就是说这 是一个<strong>可以通过编程来控制的硬件</strong>。</li><li>G 代表 Gate ，它就代表芯片里面的门电路。我们能够去进行编程组合的就是这样一个一个<strong>门电路</strong>。</li><li>A 代表的 Array，叫作阵列，说的是在一块 FPGA 上，密密麻麻列了<strong>大量 Gate 这样的门电路</strong>。</li><li>F，不太容易理解。它其实是说，一块 FPGA 这样的板子，<strong>可以进行在“现场”多次地进行编程</strong>。它不像 PAL（Programmable Array Logic，可编程阵列逻辑） 这样更古老的硬件设备，只能“编程”一次，把预先写好的程序一次性烧录到硬件里面，之后就不能再修改了。</li></ul><p>我们之前说过，CPU 其实就是通过晶体管，来实现各 种组合逻辑或者时序逻辑。那么，<strong>我们怎么去“编程”连接这些线路呢</strong>？</p><p>FPGA的解决方案分三步：</p><p><strong>第一，用存储换功能实现组合逻辑</strong>。在实现 CPU 的功能的时候，我们需要完成各种各样的电路逻辑。在FPGA 里，这 些基本的电路逻辑，不是采用布线连接的方式进行的，而是 预先根据我们在软件里面设计的逻辑电路，算出对应的真值表，然后直接存到一个叫作 LUT（Look-Up Table，查找 表）的电路里面。这个 LUT 呢，其实就是一块存储空间，里面存储了“特定的输入信号下，对应输出 0 还是 1”。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081009007.png"></p><p><strong>第二，对于需要实现的时序逻辑电路，我们可以在 FPGA 里面直接放上 D 触发器，作为寄存器</strong>。这个和 CPU 里的触发器没有什么本质不同。不过，我们会把很多个 LUT 的电路和寄存器组合在一起，变成一个叫作逻辑簇（Logic Cluster）的东西。在 FPGA 里，这样组合了多个 LUT 和寄 存器的设备，也被叫做 CLB Configurable Logic Block，可配置逻辑块）。</p><p>可以把CLB想象成函数或者API，设计更复杂的功能，不用重新造轮子，只需要调用函数或者API即可。设计芯片也是一样，不用再从门电路开始搭建，可以通过CLB组合搭建。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202205081014661.png"></p><p><strong>第三，FPGA 是通过可编程逻辑布线，来连接各个不同的 CLB，最终实现我们想要实现的芯片功能</strong>。这个可编程逻辑布线，你可以把它当成我们的铁路网。整个铁路系统已经铺 好了，但是整个铁路网里面，设计了很多个道岔。我们可以 通过控制道岔，来确定不同的列车线路。在可编程逻辑布线 里面，“编程”在做的，就是拨动像道岔一样的各个电路开 关，最终实现不同CLB之间的连接，完成我们想要的芯片<br>功能。</p><h3 id="ASIC"><a href="#ASIC" class="headerlink" title="ASIC"></a>ASIC</h3><p>除了CPU，GPU以及FPGA，我们还需要用到很多其他芯片，比如除了音视频的芯片，或者专门用来挖矿的芯片。尽管CPU也能实现这些功能，但是有点大炮打蚊子的感觉。</p><p>于是针对一些特殊场景，单独设计一个芯片，我们称这些芯片为 ASIC（Application-Specific Integrated Circuit），专用集成电路。设计精简，制造成本低。</p><p>其实我们的FPGA也能做ASIC的事情，每次对FPGA进行编程，就是把FPGA电路编程了一个ASIC。但是如果全用FPGA，同样会浪费。因为每一个LUT电路，都可以实现与门以及或门，这比单纯连死的与门或者或门，用到的晶体管数量要多的多。自然功耗也要大得多，单片FPGA的生产制造成本也比ASIC要高。</p><table><thead><tr><th align="center"></th><th align="center">FPAG</th><th align="center">ASIC</th></tr></thead><tbody><tr><td align="center">一次性成本</td><td align="center">极低，约等于0</td><td align="center">高</td></tr><tr><td align="center">量产成本</td><td align="center">高</td><td align="center">低</td></tr><tr><td align="center">延迟</td><td align="center">低</td><td align="center">低</td></tr><tr><td align="center">开发周期</td><td align="center">短</td><td align="center">长</td></tr><tr><td align="center">市场风险</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">开发环境</td><td align="center">设置FPGA需要硬件知识，编程和配置门槛很高</td><td align="center">需要底层硬件变成，开发难度很高</td></tr></tbody></table><h2 id="TPU"><a href="#TPU" class="headerlink" title="TPU"></a>TPU</h2><p>TPU（Tensor Processing Unit） 张量处理器；</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>替换Gitee图床为腾讯云COS</title>
    <link href="/2022/04/09/%E6%9B%BF%E6%8D%A2Gitee%E5%9B%BE%E5%BA%8A%E4%B8%BA%E8%85%BE%E8%AE%AF%E4%BA%91COS/"/>
    <url>/2022/04/09/%E6%9B%BF%E6%8D%A2Gitee%E5%9B%BE%E5%BA%8A%E4%B8%BA%E8%85%BE%E8%AE%AF%E4%BA%91COS/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1964208">Gitee图床挂了</a>，但是各大云服务厂商提供的对象存储服务免费额度，对于个人小博客来说也够用了。下面介绍如何将图床更换为腾讯云COS。</p><h2 id="下载原有图片"><a href="#下载原有图片" class="headerlink" title="下载原有图片"></a>下载原有图片</h2><p>从<code>gitee</code>下载整个仓库。保持原有目录结构。</p><h2 id="配置腾讯云COS"><a href="#配置腾讯云COS" class="headerlink" title="配置腾讯云COS"></a>配置腾讯云COS</h2><p>注册腾讯云账号，创建 COS 存储桶，选择公有读私有写。创建 COS 存储桶地址：<a href="https://console.cloud.tencent.com/cos">https://console.cloud.tencent.com/cos</a> ，创建存储桶后可以在存储桶里打开防盗链设置。</p><p>创建桶–选择地域–填写名称–选择公有读私有写–点击创建。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091731554.png"></p><p>如果忘了设置读写权限可以按一下方法设置；<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727355.png"></p><p>选择<strong>菜单</strong>–<strong>文件列表</strong>。上传下载好的文件夹（整个仓库的文件夹）。鼠标放到<strong>选择文件</strong>出现<strong>上传文件夹选项</strong>，或者将文件夹<strong>拖入浏览器</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727353.png"></p><h2 id="配置Picgo"><a href="#配置Picgo" class="headerlink" title="配置Picgo"></a>配置Picgo</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727351.png"></p><p><strong>COS版本</strong>：V5<br><strong>设定Secreid，设定Secrekey，设定APPID：</strong> APPID、SecretID与SecretKey <a href="https://console.cloud.tencent.com/cam/capi">点此直达获取</a>。<br>选择继续使用–创建秘钥。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/202204091715578.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727352.png"></p><p><strong>设定存储空间名，设定存储区域：</strong> <a href="https://console.cloud.tencent.com/cos/bucket">点此获取存储空间名以及存储区域</a>。桶名称即存储空间名，所属区域：<code>ap-shanghai</code>即确认存储区域。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091727354.png"></p><p><strong>指定存储区域：</strong><br>指定上传到COS的目录，比如我原先从<code>gitee</code>下载来的图床的仓库名是<code>markdown_picbed</code>，图片又保存在<code>markdown_picbed/img</code>目录下，那么就指定<code>markdown_picbed/img</code>目录。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091722487.png"></p><h2 id="替换旧图床URL"><a href="#替换旧图床URL" class="headerlink" title="替换旧图床URL"></a>替换旧图床URL</h2><p>VSCode全局替换：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204091753809.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>图床</tag>
      
      <tag>腾讯云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员的自我修养笔记</title>
    <link href="/2022/03/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94/"/>
    <url>/2022/03/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。</p><h2 id="第三章-目标文件里有什么"><a href="#第三章-目标文件里有什么" class="headerlink" title="第三章 目标文件里有什么"></a>第三章 目标文件里有什么</h2><h3 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h3><p><strong>目标文件</strong>从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。</p><p>现在PC平台流形的可执行文件格式，主要是windows下的PE（Portable Executable）和Linux下的ELF（Executable Linkable Format）,它们都是COFF（Common file format）格式的变种。</p><p>指令和数据分开存放的好处：</p><ul><li><p>一方面当程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被设置成可读写和只读，这样可以防止程序的指令被有意或无意地改写。</p></li><li><p>另一方面是现代CPU有强大的缓存体系，由于缓存很重要，所以程序必须尽量提高缓存命中率。指令区和数据区分离有利于提高程序的局部性。现代CPU的缓存一般都被设计成数据缓存和指令缓存，所以程序的指令和数据分开存放对于CPU的缓存命中率提高有好处。</p></li><li><p>第三个原因，也是最重要的原因，就是当系统中运行着多个该进程副本时，他们的指令都是一样的，所以内存中只需要保存一份程序的指令部分。</p></li></ul><p><strong>真正了牛逼的程序员对自己的程序每一个字节都了如指掌。</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">objdump -h  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SimpleSsection</span>.</span></span>o  # 打印elf文件各个段的信息<br>size <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SimpleSsection</span>.</span></span>o           # 查看elf文件各个段的长度<br>objdump -s -d <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SimpleSsection</span>.</span></span>o # -s将所有段内容以十六进制打印，-d将所有包含指令的段反汇编<br></code></pre></td></tr></table></figure><table><thead><tr><th>段名称</th><th>内容</th></tr></thead><tbody><tr><td>.data</td><td>- 初始化的全局变量 <br> - 局部静态变量</td></tr><tr><td>.rodata</td><td>只读数据段，对这个段的任何修改都是非法的，保证了程序的安全性。 <br> 有时候编译器会把字符串放到data段<br> - 只读变量 const 修饰 <br> - 字符串常量</td></tr><tr><td>.bss</td><td>不占磁盘空间， <br>- 未初始化的全局变量 <br> - 未初始化的局部静态变量 <br> - 初始化为0的静态变量</td></tr><tr><td>.comment</td><td>存放编译器版本信息，比如字符串“GCC：（GNU）4.2.0”</td></tr><tr><td>.line</td><td>调试时的行号表，即源代码行号与编译后指令的对应表</td></tr><tr><td>.note</td><td>额外的编译器信息，如程序公司名，版本号</td></tr><tr><td>.symtab</td><td>Symbol Table符号表</td></tr><tr><td>.plt</td><td>动态链接的跳转表</td></tr><tr><td>.got</td><td>动态链接的全局入口表</td></tr></tbody></table><p>段名称都是<code>.</code>前缀，表示这些表名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名称。比如可以加入一个<code>music</code>段，里面存一首mp3音乐，运行起来后就会播放音乐，打算自定义段不能使用<code>.</code>作为前缀，以免与系统保留段名冲突。</p><blockquote><p>Q: 如何将一个二进制文件，如图片，MP3文件作为目标文件的一个段？<br>A: 可以使用objcopy工具，比如有一个图片 image..jpg，大小为0x2100字节：<br>$ objcopy -I binary -O elf32-i388 -B  i38 image.jpg image.o</p></blockquote><p>正常情况下编译出来的目标文件，代码会放到<code>.text</code>段，但是有时候你希望变量或者某些代码能放到你指定的段中去，以实现某些特定的功能。比如为了满足某些硬件的内存和IO地址布局。GCC提供了扩展机制，使得程序员可以指定变量所处的段：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">__attribute__((<span class="hljs-name">section</span>(<span class="hljs-string">&quot;FOO&quot;</span>))) int global = <span class="hljs-number">42</span><span class="hljs-comment">;</span><br>__attribute__((<span class="hljs-name">section</span>(<span class="hljs-string">&quot;BAR&quot;</span>))) void foo<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="ELF-文件结构"><a href="#ELF-文件结构" class="headerlink" title="ELF 文件结构"></a>ELF 文件结构</h3><p>使用<code>readelf</code>命令查看elf文件详细信息。</p><ul><li><p>ELF 魔数，确认文件类型。</p></li><li><p>文件类型</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>ET_REL</td><td>1</td><td>可重定位文件，一般问.o文件</td></tr><tr><td>ET_EXEC</td><td>2</td><td>可执行文件</td></tr><tr><td>ET_DYN</td><td>3</td><td>共享目标文件，一般为.so文件</td></tr></tbody></table></li><li><p>机器类型</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>EM_M32</td><td>1</td><td>AT&amp;T WE 32100</td></tr><tr><td>EM_SPARC</td><td>2</td><td>SPARC</td></tr><tr><td>EM_M386</td><td>3</td><td>Intel x86</td></tr><tr><td>EM_68K</td><td>4</td><td>Motorola 68000</td></tr><tr><td>EM_88K</td><td>5</td><td>Motorola 88000</td></tr><tr><td>EM_860</td><td>6</td><td>Intel 80860</td></tr></tbody></table></li></ul><p><strong>段表</strong>是保存各个段的基本属性的结构。段表是除文件头外最重要的结构。编译器，链接器和装载器都是依靠段表来定位和访问各个段的属性。</p><h3 id="链接的接口-符号"><a href="#链接的接口-符号" class="headerlink" title="链接的接口-符号"></a>链接的接口-符号</h3><h4 id="符号表结构"><a href="#符号表结构" class="headerlink" title="符号表结构"></a>符号表结构</h4><p>链接过程的本质就是要把多个不同的目标文件之间相互粘到一起。</p><p>目标文件B要用到目标文件A的函数<code>foo</code>，我们称目标文件A<strong>定义</strong>了函数<code>foo</code>，目标文件B<strong>引用</strong>了目标文件A的函数<code>foo</code>。</p><p>链接中，我们将函数和变量统称为<strong>符号</strong>，函数名或变量名就是符号名。、</p><p>每一个目标文件都会有一个相应的符号表，表里记录了目标文件中所用到的所有符号。每个符号都有一个对应值，叫符号值，对于变量和函数来说，符号值就是他们的地址。</p><p>符号类型：</p><ul><li>定义在本目标文件的全局符号，可以被其他目标引用。</li><li>在本目标文件中应用的全局符号，却没有定义在本目标文件。</li><li>段名称，也就是段起始地址。</li><li>局部符号，一些静态变量等。</li><li>行号信息。</li></ul><p>最重要的就是第一类和第二类。链接只关心全局符号的相互粘合，其他都是次要的。</p><p>可以使用 <code>readelf</code> <code>objdump</code> <code>nm</code>等命令查看符号信息。</p><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><p>一些特殊符号，没有在程序中定义，但是可以直接声明并引用它：</p><ul><li><code>__executable_start</code>，程序起始地址，不是入口地址，是程序最开始的地址。</li><li><code>__etext</code> <code>__etext</code>  <code>etext</code> 代码段结束地址，代码段最末尾的地址。</li><li><code>_edata</code> <code>edata</code> 数据段结束地址，数据段最末尾地址。</li><li><code>__end</code>  <code>end</code> 程序结束地址。</li></ul><h4 id="符号修饰"><a href="#符号修饰" class="headerlink" title="符号修饰"></a>符号修饰</h4><p>符号应与对应的函数或者变量同名，但是在C语言发明时，已经存在了很多库和目标文件，如果再用一样的函数或变量就会冲突为了避免冲突，C语言编译后符号名前会加上下划线<code>_</code>，如<code>foo</code>变成<code>_foo</code>，Fortran语言编译后会在符号前后加上下划线<code>_foo_</code>。</p><p>C++具有类，继承，重载等复杂机制，为了支持这些复杂特性，人们发明了<strong>符号修饰</strong>和<strong>符号改编</strong>。</p><p><strong>函数签名</strong>包含了一个函数的信息，包括函数名，参数类型，所在类和名称空间等信息。它用于识别不同的函数。在编译器和链接器处理符号时，使用某种名称修饰的方法，是的每个函数签名对应一个<strong>修饰后名称</strong>。</p><p>由于不同的编译器采用不同的名字修饰方式，必然导致由不同编译器编译产生的目标文件无法正常互相链接，这是导致不同编译器之间不能互操作的主要原因之一。</p><h4 id="extern-C"><a href="#extern-C" class="headerlink" title="extern C"></a>extern C</h4><p>C++为了兼容C，C++编译器会将在<code>extern C</code> 的大括号内部的代码当做C语言代码处理，这样就不会使用C++的名称修饰机制。（也就不会在编译的时候加上下划线）</p><p>但是C语言并不支持<code>extern C</code>关键字，又不能为同一个库函数写两套头文件，这时候就可以用C++的宏，<code>__cplusplus</code>。C++编译器会在编译C++的程序时默认定义这个宏，我们可以用条件宏来判断当前编译单元是不是C++代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">int</span> , <span class="hljs-keyword">size_t</span>)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="弱符号与强符号"><a href="#弱符号与强符号" class="headerlink" title="弱符号与强符号"></a>弱符号与强符号</h4><p>我们经常碰到符号重定义，多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候就会出现符号重定义的错误。比如在两个文件中定义了相同的全局变量。</p><p>对于C/C++来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。</p><p>也可以使用GCC的<code>__attribute__((weak))</code>来定义任何一个强符号为弱符号。</p><ul><li>不允许强符号被多次定义，如果多次定义，则链接器报重复定义错误；</li><li>如果一个符号在某文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</li><li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。</li></ul><h2 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a>第四章 静态链接</h2><h3 id="空间地址分配"><a href="#空间地址分配" class="headerlink" title="空间地址分配"></a>空间地址分配</h3><p>可执行文件中的代码段和数据段就是多个文件合并而来的，对于多个文件链接器如何将它们合并到输出文件？</p><p>按序叠加：最简单的方式，按照输入文件顺序依次合并。这会导致大量碎片，比如x86的硬件，段的装载地址和空间的对齐单位是页，也就是4096字节，那么如果一个段的长度只有1字节，它在内存里也要占用4096字节。</p><p>相似段合并：将所有相同性质的段合并在一起。</p><p>现在的链接器基本上采用第二种。使用这种方法的链接器都采用一种叫两步链接的方法。</p><p>第一步，空间与地址分配。扫描所有的输入目标文件，并且获得各个段的长度，属性和位置，并将输入目标文件中的符号表所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步，链接器将能够获得所有输入目标文件的段长度，并且将他们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。</p><p>第二部，符号解析与重定位。使用上面收集到的信息，读取输入文件中段的数据，重定位信息。并且进行符号解析与重定位，调整代码中的地址。</p><p>VMA （Virtual Memory Address）虚拟地址，LMA（Load Memory Address）加载地址。正常情况这两个值是一样的。</p><p>链接之前目标文件的所有短VMA都是0，因为虚拟空间还没有被分配，默认为0，链接之后各个段就会被分配相应的虚拟地址。</p><p>Linux下，ELF可执行文件默认从地址<code>0x8048000</code>开始分配。</p><h3 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">objdump</span> -d  查看代码段反汇编结果<br></code></pre></td></tr></table></figure><p>源代码在编译成目标文件时并不知道函数的调用地址。需要通过链接时重定位。</p><p>链接器如何知道哪些指令需要被调整？这就用到了<strong>重定位表</strong>。</p><p>重定位表就是ELF文件的一个段，所以其实重定位表也可以叫重定位段。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">objdump</span> -r 查看重定位表<br></code></pre></td></tr></table></figure><p>每个要被重定位的地方叫一个重定位入口（Relocation Entry）。</p><p>重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，或引用到定义在其他文件的符号。重定位过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，他就要确定这个符号的目标地址。这时候链接器就会取查找由所有输入目标文件的符号表组成的全局符号表，找到对应的符号进行重定位。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">readelf</span> -s 查看符号表<br></code></pre></td></tr></table></figure><p>对于32位x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种：</p><ul><li>绝对近址32位寻址</li><li>相对近址32位寻址</li></ul><p>x86基本重定位类型</p><table><thead><tr><th>宏定义</th><th>值</th><th>重定位修正方法</th></tr></thead><tbody><tr><td>R_386_32</td><td>1</td><td>绝对寻址修正 S+A</td></tr><tr><td>R_386_PC32</td><td>2</td><td>相对寻址修正 S+A-P</td></tr></tbody></table><p>A = 保存在被修正位置的值<br>P = 被修正的位置(相对于段开始的偏移量或者虚拟地址)，注意，该值可通过r_offset计算得到<br>S = 符号的实际地址，即由 <code>r_info</code>的高24位指定的符号的实际地址</p><h2 id="第六章-可执行文件的装载与进程"><a href="#第六章-可执行文件的装载与进程" class="headerlink" title="第六章 可执行文件的装载与进程"></a>第六章 可执行文件的装载与进程</h2><p>程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。</p><h3 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h3><blockquote><p>Q:在目标文件中，编译器为什么不直接把未初始化的全局变量也当做未初始化的局部静态变量一样处理，为它在BSS段分配空间，而是将其标记为一个COMMON类型的变量？<br>A:当编译器将一个编译单元编译成目标文件时，如果该编译单元包含了弱符号（未初始化的全局变量就是典型），那么该弱符号最终所占大小未知，因为有可能其他编译单元中该符号所占空间比当前的大所以编译器此时无法为该符号在BSS段分配空间。但链接器在链接过程中可以确定弱符号大小，因为当链接器读取所有输入目标文件后，任何一个弱符号大小都可以确定，所以它可以在最终输出文件的BSS段为其分配空间。总体来看，未初始化全局变量最终还是被放在BSS段。</p></blockquote><p>GCC的<code>-fno-common</code>吧所有未初始化的全局变量不以COMMON块形式处理。</p><p><code>__attribute__</code>扩展也可以实现，<code>int global __attribute__((nocommon))</code>。这样未初始化的全局变量就是强符号。</p><blockquote><p>Q: 为什么静态运行库里面一个目标文件只包含一个函数？比如libc.o里面printf.o只包含printf()函数，strlen.o只有strlen函数？<br>A:因为链接器在链接静态库时是以目标文件为单位的，比如我们引用了静态库中的printf函数，那么链接器就会把库中包含printf函数的那个目标文件链接进来，如果很多函数写在一个目标文件中，就将没用到的函数一起链接进了输出结果中。</p></blockquote><h3 id="链接的过程控制"><a href="#链接的过程控制" class="headerlink" title="链接的过程控制"></a>链接的过程控制</h3><h2 id="第6章-可执行文件的装载与进程"><a href="#第6章-可执行文件的装载与进程" class="headerlink" title="第6章 可执行文件的装载与进程"></a>第6章 可执行文件的装载与进程</h2><p>程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。</p><p><strong>可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件又被叫做映像文件(Image)。</strong></p><p>Segment 和 Section  很难从中文翻译上区分，ELF 文件按 Section 存储的，从装载的角度ELF 文件又可以按照 Segment划分。</p><h4 id="段地址对齐"><a href="#段地址对齐" class="headerlink" title="段地址对齐"></a>段地址对齐</h4><p>可执行文件需要被装载，装载一般通过虚拟内存页映射机制完成，页是映射的最小单位，对于x86处理器来说，默认页大小为4096字节，所以内存空间的长度必须是4096的整数倍，并且这段空间在物理内存和进程虚拟地址空间的起始地址必须是4096的整数倍。</p><h2 id="第7章-动态链接"><a href="#第7章-动态链接" class="headerlink" title="第7章 动态链接"></a>第7章 动态链接</h2><h2 id="第七章-动态链接"><a href="#第七章-动态链接" class="headerlink" title="第七章 动态链接"></a>第七章 动态链接</h2><h3 id="为什么要动态链接？"><a href="#为什么要动态链接？" class="headerlink" title="为什么要动态链接？"></a>为什么要动态链接？</h3><ul><li>内存和磁盘空间：如果两个程序都用到一个静态库，链接时就会有静态库的两个副本，运行时就会占用两份内存。</li><li>程序的开发与发布：一个程序用到的静态库如果有更新，那么程序就需要重新链接，发布给用户。</li></ul><p>要解决以上问题，最简单的方法就是把程序的模块相互分割开来，形成独立的文件，而不再将它们静态链接。就是不对目标文件进行链接，而等到程序运行时再链接。这就是<strong>动态链接的基本思想</strong>。</p><p>动态链接模块的装载地址是从<code>0x00000000</code>开始的。</p><p>共享对象的最终装载地址在编译时是不确定的。</p><h3 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h3><p>静态共享库： 将程序的各个模块交给操作系统管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。</p><p><strong>装载时重定位</strong>：程序在编译时被装载的目标地址为<code>0x1000</code>，但是在装载时操作系统发现<code>0x1000</code>这个地址已经被别的程序使用了，从<code>0x4000</code>开始有一块足够大的空间可以容纳，那么该程序就可以被装载至<code>0x4000</code>，程序指令和数据所有引用都只需要加上<code>0x3000</code>偏移量即可。因为他们在程序中的相对位置是不会改变的。</p><p>地址无关代码为了解决共享对象指令中对绝对地址的重定位问题，基本想法是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>模块中四类地址引用：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204092152653.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101004886.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101004869.png"></p><p><strong>模块内部调用或者跳转</strong><br>不需要重定位，本身就是地址无关的。</p><p><strong>模块内部数据访问</strong><br>指令中不能包含数据的绝对地址，所以使用相对寻址的方式。</p><p><strong>模块间数据访问</strong><br>把跟地址相关的部分放到数据段里面。ELF的做法是在数据段里面建立一个指向这些数据的指针数据，称为<strong>全局偏移表</strong>（GOT）。当代码需要引用全局变量时，可以通过GOT间接引用。</p><p>链接器在装载时会查找每个变量的地址，填充GOT每个项，当指令中需要访问变量时，程序会先找到GOT，根据GOT中对应的地址，找到对应的变量。GOT本身放在数据段，所以他可以在模块装载时被修改，并且每个进程有独立副本，相互不影响。</p><p>以访问变量b为例，程序首先计算出变量b的地址在GOT中的位置，即</p><p><code>0x10000000 + 0x454 + 0x118c + 0xfffffff8 = 0x100015d8</code></p><p><code>0xfffffff8</code>为<code>-8</code>的补码表示，然后使用寄存器间接寻址方式给变量b赋值2。</p><p><strong>模块间调用跳转</strong><br>类似于模块机数据访问，不同的是GOT中相应项保存的是目标函数的地址。</p><hr><p><strong>各种地址引用方式</strong></p><table><thead><tr><th></th><th>指令跳转，调用</th><th>数据访问</th></tr></thead><tbody><tr><td>模块内部</td><td>相对跳转和调用</td><td>相对地址访问</td></tr><tr><td>模块外部</td><td>间接跳转和调用（GOT）</td><td>间接访问（GOT）</td></tr></tbody></table><hr><blockquote><p>Q : -fpic和-fPIC的区别？<br>A: 都是GCC产生地址无关代码的参数。<code>-fpic</code>产生的代码较小，<code>-fPIC</code>产生的代码较大。因为地址无关代码和硬件平台相关，在一些平台上<code>-fpic</code>会受到限制，比如全局符号的数量或者代码长度等，而后者没有这样的限制。</p></blockquote><blockquote><p>Q: 如果一个共享对象lib.so中定义了一个全局变量G，进程A和进程B都是用了lib.so。那么当进程A改变这个全局变量时，进程B的G是否受到影响？<br>A: 不会，应当lib.so被加载时，它的数据段部分在每个进程都有独立的副本。如果是同一个进程里的线程A和线程B，那么他们是共享数据G的。</p></blockquote><p>如果代码不是地址无关的，它就不能被多个进程共享，就失去了节省内存的优点。但是装载是重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数是需要做一次计算当前地址以及间接地址寻址的过程。</p><h3 id="延迟绑定PLT"><a href="#延迟绑定PLT" class="headerlink" title="延迟绑定PLT"></a>延迟绑定PLT</h3><p>动态链接要比静态链接慢，一是因为动态链接下，对全局和静态数据的访问都要进行复杂的GOT定位，然后间接寻址。另外，程序开始执行时，动态链接器都要进行一次链接工作。</p><p>而在一个程序运行过程中，可能很多函数在程序执行完时都不会用到，如果一开始就把所有函数链接好实际就是一种浪费，所有ELF采用了一种叫做延迟绑定的做法，基本思想就是当函数<strong>第一次使用时</strong>才进行绑定（符号查找，重定位等）。</p><p>ELF使用PLT（Procedure Linkage Table）来实现延迟绑定。以调用<code>bar()</code>函数为例，之前的做法是通过GOT中的相应项进行跳转，而延迟绑定下，在这过程中间加了一层PLT间接跳转。每个外部函数在PLT中都有一个对应项，比如<code>bar()</code>在PLT中项的地址为<code>bar@plt</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">bar</span>@<span class="hljs-selector-tag">plt</span>:<br>    <span class="hljs-selector-tag">jmp</span> *(bar<span class="hljs-variable">@GOT</span>)<br>    <span class="hljs-selector-tag">push</span> <span class="hljs-selector-tag">n</span><br>    <span class="hljs-selector-tag">push</span> <span class="hljs-selector-tag">moduleID</span><br>    <span class="hljs-selector-tag">jump</span> <span class="hljs-selector-tag">_dl_runtime_resolve</span><br></code></pre></td></tr></table></figure><p>第一条是指令通过GOT间接跳转的指令，如果链接器在初始化阶段已经初始化该项，并将<code>bar()</code>地址填入该项，那么就能正确跳转到<code>bar()</code>。但是为了延迟绑定，链接器初始化时并没有将<code>bar()</code>地址填入，而是将第二条指令<code>push n</code>的地址填入了<code>bar@GOT</code>中，这一步不需要查找符号，代价很低。</p><p>第一条指令的效果就是跳转到第二条指令，第二条指令将数字<code>n</code>压入堆栈，这个数字是<code>bar</code>这个符号引用在重定位表<code>.rel.plt</code>中的下标。第三条指令将模块ID压入堆栈，最后跳转到<code>_dl_runtime_resolve</code>。</p><p><code>_dl_runtime_resolve</code>进行一系列工作后将<code>bar()</code>真正地址填入到<code>bar@GOT</code>。</p><p>一旦<code>bar()</code>这个函数被解析完，当面再次调用<code>bar@plt</code>时，第一条<code>jump</code>指令就能跳转到<code>bar()</code>的真正地址。<code>bar()</code>函数返回时根据堆栈里保存的<code>EIP</code>直接返回到调用者，而不会执行<code>bar@plt</code>中第二条指令。<strong>那段代码只会在符号未被解析时执行一次</strong>。</p><p>PLT在ELF文件中以独立段存在，段名通常叫做<code>.plt</code>，因为它本身是一些地址无关的代码，所以可以跟代码段合并成同一个可读可执行的Segment被装载入内存。</p><h3 id="动态链接相关结构"><a href="#动态链接相关结构" class="headerlink" title="动态链接相关结构"></a>动态链接相关结构</h3><p><strong>.interp段</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">objdump</span> -s a.out<br><br><span class="hljs-attribute">Contents</span> of section .interp:<br><span class="hljs-attribute">804811</span> <span class="hljs-number">2</span>f<span class="hljs-number">6</span>c<span class="hljs-number">6962</span> <span class="hljs-number">2</span>f<span class="hljs-number">6</span>c<span class="hljs-number">696</span>d <span class="hljs-number">6</span>c<span class="hljs-number">696</span>e<span class="hljs-number">78</span> <span class="hljs-number">782</span>e<span class="hljs-number">736</span>f  /lib/ld-linux.so.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>里面保存的就是可执行文件所需要的动态链接器的路径，在Linux下，可执行文件动态链接器几乎都是<code>/lib/ld-linux.so.2</code>。</p><p>这是个软链接，会他会指向系统中安装的动态链接器。当系统中的Glibc库更新时，软链接也会指向新的动态链接器，所以<code>.interp</code>段不需要修改。</p><p>可以通过以下命令查看可执行文件需要的动态链接器的路径:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ readelf -l a.out | grep interpreter<br>    [Requesting program interpreter: /lib/ld-linux.so.2]<br></code></pre></td></tr></table></figure><p><strong>.dynamic 段</strong></p><p>动态链接ELF中最重要的结构，这里保存了动态链接器所需要的基本信息，如依赖哪些共享对象，动态链接符号表的位置，动态链接重定位表的位置，共享对象初始化代码的地址等。</p><p><strong>动态符号表</strong></p><p><code>Program1</code>程序一来<code>Lib.so</code>，引用到了里面的<code>foobar()</code>函数，那么对于<code>Program1</code>来说，称<code>Program1</code>导入（Import）了<code>foobar</code>函数，<code>foobar</code>是<code>Program1</code>的导入函数。</p><p>而站在<code>Lib.so</code>角度来说，它定义了<code>foobar</code>函数，我们称<code>Lib.so</code>导出（Export）了<code>foobar</code>函数，<code>foobar</code>是<code>Lib.so</code>的导出函数。</p><p>为了表示动态链接这些模块之间的符号导入导出关系，ELF专门有一个叫做动态符号表的段来保存这些信息，段名通常叫<code>.dynsym</code>。</p><p><code>.dynsym</code>只保存与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。</p><p><strong>动态链接重定位表</strong></p><p>PIC模式的共享对象也需要重定位。</p><p>对于使用PIC技术的可执行文件或共享对象来说，虽然代码段不需要重定位，但是数据段还包含了绝对地址的引用，因为代码段中绝对地址相关的部分被分离出来，变成了GOT，而GOT实际上是数据段的一部分。</p><p>目标文件的重定位在静态链接时完成，共享对象的重定位在装载时完成。</p><p>目标文件里包含专门用于重定位信息的重定位表，比如<code>.rel.text</code>表示是代码段重定位表，<code>.rel.data</code>表示数据段重定位表。</p><p>共享对象里类似的重定位表叫做<code>.rel.dyn</code>和<code>.rel.plt</code>。<code>.rel.dyn</code>实际上是对数据引用的修正，它所修正的位置位于<code>.got</code>以及数据段；<code>.rel.plt</code>实际上是对代码引用的修正，它所修正的位置位于<code>.got.plt</code>。</p><p>用以下命令可以查看重定位表；</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101958979.png"></p><p><code>printf</code>这个重定位入口，它的类型为<code>R_386_JUMP_SLOT</code>，它的偏移为<code>0x000015d8</code>。它实际位于<code>.got.plt</code>中，前三项是被系统占用的，第四项开始才是真正存放导入函数地址的地方，刚好是<code>0x000015c8 + 4 * 3 = 0x000015d4</code>，即<code>__gmon_start__</code>。</p><p>当动态链接器要进行重定位时，先查找<code>printf</code>的地址，假设链接器在全局符号表中找到<code>printf</code>的地址为<code>0x08801234</code>，那么链接器就会将这个地址填入<code>.got.plt</code>中偏移为<code>0x000015d8</code>的位置。<strong>从而实现了地址重定位，即动态链接最关键的一步</strong>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204102010906.png"></p><h3 id="动态链接时进程堆栈初始化信息"><a href="#动态链接时进程堆栈初始化信息" class="headerlink" title="动态链接时进程堆栈初始化信息"></a>动态链接时进程堆栈初始化信息</h3><h3 id="动态链接的步骤和实现"><a href="#动态链接的步骤和实现" class="headerlink" title="动态链接的步骤和实现"></a>动态链接的步骤和实现</h3><p>动态链接分为三步：启动动态链接本身，装载所有的共享对象，重定位和初始化。</p><blockquote><p>Q： 动态链接器本身是动态链接还是静态链接？<br>A：动态链接器本身应该是静态链接的，它不能依赖于其他共享对象，动态链接器本身使用来帮助其他ELF文件解决共享对象依赖问题的，如果它也依赖其他共享对象，那就陷入矛盾了。</p></blockquote><blockquote><p>Q：动态链接器本身必须是PIC的吗？<br>A：动态链接器可以是PIC的也可以不是，但是往往用PIC会简单一些。</p></blockquote><blockquote><p>Q： 动态链接器可以被当做可执行文件运行，那么它的装载地址是多少？<br>A：ld.so的装载地址跟一般的共享对象一样，即<code>0x00000000</code>。这个装载地址是一个无效的装载地址，作为一个共享库，内核在装载它时会为其选择一个合适的装载地址。</p></blockquote><h3 id="显示运行时链接"><a href="#显示运行时链接" class="headerlink" title="显示运行时链接"></a>显示运行时链接</h3><h2 id="第10章-内存"><a href="#第10章-内存" class="headerlink" title="第10章 内存"></a>第10章 内存</h2><h3 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h3><p>在32位操作系统里，有4GB的寻址能力，大部分操作系统会将一部分挪给内核使用，应用程序无法直接访问这段内存。这部分称为内核空间。Windows默认将高地址的2GB分给内核，Linux默认分1GB给内核。</p><p>剩下的称为用户空间，在用户空间里也有一些特殊的地址区间：</p><ul><li>栈：维护函数调用上下文，通常在用户空间的最高地址处分配。</li><li>堆：用来容纳程序动态分配的内存区域，当使用malloc或者new分配内存时，得到的内存来自于堆。通常在栈下方。</li><li>可执行文件映像：存储可执行文件再内存里的映像，由装载器在装载时将可执行文件的内存读取活映射到这里。</li><li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。比如<code>NULL</code>。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301614683.png"></p><h3 id="栈与调用惯例"><a href="#栈与调用惯例" class="headerlink" title="栈与调用惯例"></a>栈与调用惯例</h3><p>栈保存了一个函数调用所需要的维护信息，通常这被称为栈帧。一般包括如下几个方面：</p><ul><li>函数的返回地址和参数</li><li>临时变量</li><li>保存的上下文</li></ul><p>一个函数的调用流程：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301632031.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301632216.png"></p><p>I386标准函数进入和退出指令序列，基本形式：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>, x<br>[<span class="hljs-keyword">push</span> reg1]<br>...<br>[<span class="hljs-keyword">push</span> regn]<br><br>函数实际内存<br><br>[<span class="hljs-keyword">pop</span> regn]<br>...<br>[<span class="hljs-keyword">pop</span> reg1]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><hr><p><strong>Hot Patch Prologue热补丁</strong><br>在Windows函数里，有些函数尽管使用了标准的进入指令序列，但是在这些指令之前却插入了一些特殊内容：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">mov</span> <span class="hljs-keyword">edi</span>,<span class="hljs-keyword">edi</span><br></code></pre></td></tr></table></figure><p>这条指令没有任何用，在汇编之后会成为一个占用2字节的机器码，纯粹为了占位符而存在，使用这条指令开头的函数整体看起来是这样的：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-symbol">FUNCTION:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>,<span class="hljs-built_in">edi</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br></code></pre></td></tr></table></figure><p>其中nop占1个字节，也是占位符，FUNCTION为一个标号，表示函数入口，本身不占空间。</p><p>设计成这样的函数在运行时可以很容易被其他函数替换掉，在上面的指令序列中调用的函数是FUNCTION，但是我们可以做一些修改，可以在运行时刻意改成调用函数REPLACEMENT_FUNCTION。首先在进程内存空间任意处写入REPLACEMENT_FUNCTION的定义：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">REPLACEMENT_FUNCTION:</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br>...<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>然后修改原函数的内容：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">LABEL:</span>         <span class="hljs-meta"># 标号不占字节</span><br><span class="hljs-keyword">jmp</span> REPLACEMENT_FUNCTION <span class="hljs-meta"># 占5字节，刚好五个nop</span><br><span class="hljs-symbol">FUNCTION:</span>      <span class="hljs-meta"># 函数入口标号，不占字节</span><br><span class="hljs-keyword">jmp</span> LABEL      <span class="hljs-meta"># 近跳指令，占2字节，跳跃到上方，即使截获失败也不影响原函数执行</span><br><span class="hljs-keyword">push</span> ebp<br><span class="hljs-keyword">mov</span> ebp, esp<br>...<br></code></pre></td></tr></table></figure><p>将5个<code>nop</code>换成一个<code>jmp</code>指令，然后将占用两个字节的<code>mov edi,edi</code>换成另一个<code>jmp</code>指令。因为这个<code>jmp</code>指令跳转的距离非常近，因此被汇编器翻译成了一个“近跳”指令，这种指令只占用两个字节。但<strong>只能跳跃到当前地址前后127个字节范围的目标位置</strong>。</p><p>这里的替换机制，可以实现一种叫做<em>钩子</em>（HOOK）的技术，允许用户在某时刻截获特定函数的调用。</p><hr><p>函数传递参数时压栈顺序，传递参数是寄存器传参还是栈传参等等都需要遵守一定的约定，否则函数将无法正确执行，这样的约定称为<strong>调用惯例</strong>。</p><p>一个调用惯例一般会规定如下几个方面：</p><ul><li>函数参数的传递顺序和方式<ul><li>调用方压栈，函数自己从栈用取参数</li><li>调用方压栈顺序：从左至右，还是从右至左？ </li></ul></li><li>栈的维护方式<ul><li>参数出栈，可以由调用方完成还是由函数自己完成？ </li></ul></li><li>名字修饰的策略<ul><li>为了链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰，不同调用惯例有不同的名字修饰策略</li><li>没有显示指定调用惯例的函数默认是<code>cdecl</code>惯例<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> _cdecl <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">float</span> m)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>_cdel是非标准关键字，在不同编译器中写法不同，在gcc中使用的是<code>__attribute__((cdecl))</code></p></blockquote></li></ul></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><table><thead><tr><th>英文名</th><th>Linux</th><th align="center">扩展名</th><th>英文名</th><th>Windows</th><th align="center">扩展名</th><th>功能</th></tr></thead><tbody><tr><td>DSO-Dynamic Shared Objects</td><td>ELF动态链接文件，动态共享对象，共享对象</td><td align="center">.so</td><td>DLL-Dynamic Linking Library</td><td>动态链接库</td><td align="center">.dll</td><td>1111</td></tr><tr><td>Static Shared Library</td><td>静态共享库</td><td align="center">2222</td><td>2222</td><td>2222</td><td align="center">2222</td><td>2222</td></tr><tr><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td></tr><tr><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td></tr><tr><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td><td>1111</td><td align="center">1111</td><td>1111</td></tr></tbody></table><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZH-什么是Die-to-Die接口</title>
    <link href="/2022/03/28/ZH-%E4%BB%80%E4%B9%88%E6%98%AFDie-to-Die%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/03/28/ZH-%E4%BB%80%E4%B9%88%E6%98%AFDie-to-Die%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是Die-to-Die接口"><a href="#什么是Die-to-Die接口" class="headerlink" title="什么是Die-to-Die接口"></a>什么是Die-to-Die接口</h1><blockquote><p>Author：Synopsys<br>译 ：<a href="https://www.synopsys.com/glossary/what-is-die-to-die-interface.html">What is a Die-to-Die Interface? – How it Works | Synopsys</a></p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>裸片到裸片（Die2Die）接口是一个功能块，它提供组装在同一封装中的两个硅管芯之间的数据接口。芯片到芯片接口利用非常短的通道连接封装内的两个芯片，以实现功率效率和非常高的带宽效率，这超出了传统芯片到芯片接口所能达到的效果。</p><p>Die2Die 接口通常由 PHY 和控制器块组成，控制器块在两个 die 上的内部互连结构之间提供无缝连接。 Die2Die的 PHY 使用高速 SerDes 架构或高密度并行架构实现，经过优化以支持多种先进的 2D、2.5D 和 3D 封装技术。</p><p>Die2Die接口是推动行业趋势从单片 SoC 设计转向同一封装中的多Die SoC 组件的关键推动力。这种方法减轻了人们对小型工艺节点的高成本/低产量日益增长的担忧，并提供了额外的产品模块化和灵活性。</p><h2 id="Die-to-Die-接口如何工作？"><a href="#Die-to-Die-接口如何工作？" class="headerlink" title="Die-to-Die 接口如何工作？"></a>Die-to-Die 接口如何工作？</h2><p>Die2Die的接口，就像任何其他芯片到芯片的接口一样，在两个芯片之间建立了可靠的数据链路。</p><p>接口在逻辑上分为物理层、链路层和事务层。它在芯片运行期间建立和维护链路，同时向应用程序提供连接到内部互连结构的标准化并行接口。</p><p>通过添加诸如前向纠错 (FEC) 和/或循环冗余码 (CRC) 和重试等错误检测和纠正机制来保证链路可靠性。</p><p>物理层架构可以是基于 SerDes 或基于并行的。</p><ul><li><p>基于 SerDes 的架构包括并行到串行（串行到并行）数据转换、阻抗匹配电路和时钟数据恢复或时钟转发功能。它可以支持更高带宽的 NRZ 信令或 PAM-4 信令，最高可达 112 Gbps。 SerDes 架构的主要作用是尽量减少简单 2D 类型封装（如有机基板）中的 I/O 互连数量。</p></li><li><p>基于并行的架构包括许多并行的低速简单收发器，每个收发器都由驱动器和具有转发时钟技术的接收器组成，以进一步简化架构。它支持 DDR 类型的信令。并行架构的主要作用是最大限度地降低密集 2.5D 型封装（如硅中介层）的功耗。</p></li></ul><h2 id="Die2Die的优势"><a href="#Die2Die的优势" class="headerlink" title="Die2Die的优势"></a>Die2Die的优势</h2><p>现代芯片实现趋向于基于在封装中组装多个裸片以提高模块化和灵活性的解决方案。当（单片）芯片尺寸接近全光罩尺寸时，这种多管芯方法还通过将功能分成几个管芯来提高产量，从而促进更具成本效益的解决方案。</p><p>Die 之间的接口必须满足此类系统的所有关键要求：</p><ul><li><p><strong>电源效率</strong>。多芯片系统实现应该与等效的单片实现一样节能。Die2Die链接使用短距离、低损耗的信道，没有明显的不连续性。 PHY 架构利用良好的通道特性来降低 PHY 复杂性并节省功耗。</p></li><li><p><strong>低延迟</strong>。将服务器或加速器 SoC 划分为多个Die不应导致内存架构不统一，因为访问不同Die中的内存具有显着不同的延迟。Die2Die接口实现了简化的协议，并直接连接到芯片互连结构，以最大限度地减少延迟。</p></li><li><p><strong>高带宽效率</strong>。高级服务器、加速器和网络交换机需要在Die之间传输大量数据。Die2Die接口必须能够支持所有需要的带宽，同时减少Die边缘的占用。通常使用两种替代方案来实现此目标：通过以非常高的每通道数据速率（高达 112 Gbps）部署 PHY 来最小化所需通道的数量，或者通过使用更精细的凸块间距（微凸块）来增加 PHY 的密度) 在大量并行化以实现所需带宽的低数据速率通道（高达 8 Gbps/通道）上。</p></li><li><p><strong>健壮的链接</strong>。 Die2Die 链接必须没有错误。该接口必须实现足够强大的低延迟错误检测和纠正机制，以检测所有错误并以低延迟纠正它们。这些机制通常包括 FEC 和重试协议。</p></li></ul><h2 id="Die-to-Die-接口用例"><a href="#Die-to-Die-接口用例" class="headerlink" title="Die-to-Die 接口用例"></a>Die-to-Die 接口用例</h2><p>通过将多个Die组合到一个封装中，小芯片提供了另一种扩展摩尔定律的方法，同时实现了产品模块化和工艺节点优化。小芯片用于计算密集型、工作负载繁重的应用程序，如高性能计算 (HPC)。</p><p>针对 HPC、网络、超大规模数据中心和人工智能 (AI) 等应用程序的 die-to-die 接口有四个主要用例：</p><h3 id="Scale-SoC"><a href="#Scale-SoC" class="headerlink" title="Scale SoC"></a>Scale SoC</h3><p>目标是通过虚拟（裸片到裸片）连接来连接裸片，从而提高计算能力并为服务器和 AI 加速器创建多个 SKU，从而实现裸片之间的紧密耦合性能。</p><h3 id="Split-SoC"><a href="#Split-SoC" class="headerlink" title="Split SoC"></a>Split SoC</h3><p>目标是启用非常大的 SoC。大型计算和网络交换机芯片正在接近光罩限制。将它们分成几个裸片会带来技术可行性、提高产量、降低成本并扩展摩尔定律。</p><h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><p>其目的是聚合在不同模具中实现的多种不同的功能，以利用每个功能的最佳工艺节点，降低功率，并改善FPGA、汽车和5G基站等应用的外形尺寸。</p><h3 id="Disaggregate"><a href="#Disaggregate" class="headerlink" title="Disaggregate"></a>Disaggregate</h3><p>目标是将中央芯片与 I/O 芯片分离，以便将中央芯片轻松迁移到高级工艺，同时将 I/O 芯片保持在保守节点中，以降低产品演进的风险/成本，实现重用并缩短时间在服务器、FPGA、网络交换机和其他应用程序中投放市场。</p><h2 id="Die-to-Die-接口和-Synopsys"><a href="#Die-to-Die-接口和-Synopsys" class="headerlink" title="Die-to-Die 接口和 Synopsys"></a>Die-to-Die 接口和 Synopsys</h2><p>Synopsys 结合了广泛的 Die2Die 112G USR/XSR 和 HBI PHY IP、控制器 IP 和中介层专业知识产品组合，提供全面的 die-to-die IP 解决方案，以支持芯片拆分、芯片分解、计算扩展和聚合的功能。基于 SerDes 的 112G USR/XSR PHY 和基于并行的 8G OpenHBI PHY 可用于高级 FinFET 工艺。可配置控制器使用具有重放和可选 (FEC) 功能的纠错机制，以最大限度地降低可靠芯片到芯片链接的误码率。它支持用于连贯和非连贯数据通信的 Arm® 特定接口。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li>PHY 架构</li><li>SerDes 架构</li><li>reticle<br><a href="https://www.zhihu.com/question/457213984">LCD厂掩膜版叫Mask,Fab里掩膜版叫reticle,两者有什么区别？ - 知乎</a></li></ul><h2 id="原文参考"><a href="#原文参考" class="headerlink" title="原文参考"></a>原文参考</h2><p><a href="https://www.synopsys.com/glossary/what-is-die-to-die-interface.html">What is a Die-to-Die Interface? – How it Works | Synopsys</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>Die2Die</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt编译后的程序放到指定目录，屏蔽qDebug输出</title>
    <link href="/2022/03/18/Qt%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%B1%8F%E8%94%BDqDebug%E8%BE%93%E5%87%BA/"/>
    <url>/2022/03/18/Qt%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%B1%8F%E8%94%BDqDebug%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="可执行程序放到指定目录"><a href="#可执行程序放到指定目录" class="headerlink" title="可执行程序放到指定目录"></a>可执行程序放到指定目录</h2><p>默认情况下QtCreator会将编译链接后的可执行程序与中间生成的文件防盗<code>build-***-</code>文件中，如何能将可执行文件生成在指定目录？</p><p>修改<code>.pro</code>:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">CONFIG(<span class="hljs-builtin-name">debug</span> ,<span class="hljs-builtin-name">debug</span>|release)&#123;<br>    DESTDIR = <span class="hljs-built_in">..</span>/<span class="hljs-builtin-name">debug</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    DESTDIR = <span class="hljs-built_in">..</span>/release<br>&#125;<br></code></pre></td></tr></table></figure><p><code>debug</code>版本放在<code>../debug</code>目录中，<code>release</code>版本放在<code>../release</code>目录中。</p><h2 id="屏蔽qDebug输出"><a href="#屏蔽qDebug输出" class="headerlink" title="屏蔽qDebug输出"></a>屏蔽qDebug输出</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">CONFIG(<span class="hljs-builtin-name">debug</span> ,<span class="hljs-builtin-name">debug</span>|release)&#123;<br>    DEFINES -= QT_NO_DEBUG_OUTPUT<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    DEFINES += QT_NO_DEBUG_OUTPUT<br>&#125;<br></code></pre></td></tr></table></figure><p><code>QT_NO_DEBUG_OUTPUT</code>即为屏蔽qDebug输出的宏定义，可以在<code>debug</code>版本中不屏蔽qDebug输出，<code>release</code>版本中屏蔽qDebug输出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_35173114/article/details/81037315">QT屏蔽qDebug()、qWarning()打印信息_qq_35173114的博客-CSDN博客_qwarning</a><br><a href="https://www.cxyzjd.com/article/amwha/115263253">QT 的QDebug无法输出日志_amwha的专栏-程序员宅基地_qdebug打印不出来 - 程序员宅基地</a><br><a href="https://blog.csdn.net/hebbely/article/details/66970821">Qt Creator中的.pro文件的详解_hebbely的博客-CSDN博客_qt的pro文件</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>QEMU源码分析-QOM</title>
    <link href="/2022/03/09/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-QOM/"/>
    <url>/2022/03/09/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-QOM/</url>
    
    <content type="html"><![CDATA[<h2 id="QOM简介"><a href="#QOM简介" class="headerlink" title="QOM简介"></a>QOM简介</h2><p>QOM(QEMU Object Model)是QEMU的一个模块，用于描述虚拟机的结构，包括虚拟机的CPU、内存、硬盘、网络、输入输出设备等。QEMU 为了方便整个系统的构建，实现了自己的一套的面向对象机制，也就是QOM(QEMU Object Model)。</p><h2 id="QOM中的面向对象"><a href="#QOM中的面向对象" class="headerlink" title="QOM中的面向对象"></a>QOM中的面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 QEMU 中通过 <strong>TypeInfo</strong> 来定义一个类。</p><p>例如 <code>x86_base_cpu_type_info</code> 就是一个 <code>class</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_base_cpu_type_info = &#123;<br>        .name = X86_CPU_TYPE_NAME(<span class="hljs-string">&quot;base&quot;</span>),<br>        .parent = TYPE_X86_CPU,<br>        .class_init = x86_cpu_base_class_init,<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>利用结构体包含来实现继承</strong>。这应该是所有的语言实现继承的方法，在 C++ 中，结构体包含的操作被语言内部实现了，而 C 语言需要自己实现。</p><p>例如 <code>x86_cpu_type_info</code> 的 <code>parent</code> 是 <code>cpu_type_info</code>, 他们的结构体分别是 <code>X86CPU</code> 和 <code>CPUState</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_cpu_type_info = &#123;<br>    .name = TYPE_X86_CPU,<br>    .parent = TYPE_CPU,<br><span class="hljs-comment">// ...</span><br>    .instance_size = <span class="hljs-keyword">sizeof</span>(X86CPU),<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo cpu_type_info = &#123;<br>    .name = TYPE_CPU,<br>    .parent = TYPE_DEVICE,<br><span class="hljs-comment">// ...</span><br>    .instance_size = <span class="hljs-keyword">sizeof</span>(CPUState),<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>X86CPU</code> 中包含一个 <code>CPUState</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPU</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    CPUState parent_obj;<br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br><br>    CPUNegativeOffsetState neg;<br></code></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态成员变量可以在类的多个对象中访问，但是要在类外声明。<strong>不同对象访问的其实是同一个实体，静态成员变量被多个对象共享</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo x86_cpu_type_info = &#123;<br>    .name = TYPE_X86_CPU,<br>    .parent = TYPE_CPU,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(X86CPU),<br>    .instance_init = x86_cpu_initfn,<br>    .instance_post_init = x86_cpu_post_initfn,<br><br>    .abstract = <span class="hljs-literal">true</span>,<br>    .class_size = <span class="hljs-keyword">sizeof</span>(X86CPUClass),<br>    .class_init = x86_cpu_common_class_init,<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中 <code>X86CPU</code> 描述的是非静态成员，而 <code>X86CPUClass</code> 描述的是静态的成员。也就是说<code>class_init</code>初始化静态成员，<code>instance_init</code>初始化非静态成员。</p><p>那么何时初始化静态成员呢？首先得告诉系统，咱有<code>class_init</code>这个初始化函数，等需要的时候随时可以调用它初始化，所有先解决如何将这个初始化函数注册到系统中？</p><p>在<code>target/i386/cpu.c</code>最后使用了<code>type_init</code>。在<code>qemu/include/qemu/module.h</code>中有一个<code>type_init</code>宏定义，除了<code>type_init</code>还有其他宏，比如<code>block_init</code>，<code>opts_init</code>等。每个宏都表示一类<code>module</code>，通过<code>module_init</code>构造出来。我们展开这个宏，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __attribute__((constructor))<br>do_qemu_init_x86_cpu_register_types(<span class="hljs-keyword">void</span>) &#123;<br>  register_module_init(x86_cpu_register_types, MODULE_INIT_QOM);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>gcc</code> 扩展属性<code>__attribute__((constructor))</code>可以让 <code>do_qemu_init_x86_cpu_register_types</code> 在运行 <code>main</code> 函数之前运行。 <code>register_module_init</code> 会让 <code>x86_cpu_register_types</code> 这个函数挂载到 <code>init_type_list[MODULE_INIT_QOM]</code> 这个链表上。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210907133931.svg"></p><p>到底，所有的 <code>TypeInfo</code> 通过 <code>type_init</code> 都被放到 <code>type_table</code> 上了，之后通过 <code>Typeinfo</code> 的名称调用 <code>type_table_lookup</code> 获取到 <code>TypeImpl</code> 了。</p><p>到这里，将<code>TYPE_X86_CPU</code>注册进类系统，包括其初始化函数，这部分也就是QEMU中类型的构造。那么何时调用静态成员初始化函数呢？也就是类型的初始化。</p><p>静态成员是所有的对象公用的，其初始化显然要发生在所有的对象初始化之前。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">main<br>    qemu_init <br>        select_machine <br>            object_class_get_list <br>                object_class_foreach <br>                    g_hash_table_foreach <br>                        object_class_foreach_tramp <br>                            type_initialize <br>                                type_initialize <br>                                    x86_cpu_common_class_init <br></code></pre></td></tr></table></figure><p><code>select_machine</code> 需要获取所有的 <code>TYPE_MACHINE</code> 的 <code>class</code>, 其首先会调用所有的<code> class_list</code>，其会遍历 <code>type_table</code>，遍历的过程中会顺带 <code>type_initialize</code> 所有的 <code>TypeImpl</code> 进而调用的 <code>class_init</code>。</p><p>说完类型的初始化，再讲一下对象的初始化，也就是初始化非静态成员，也就是<code>instance_init</code>在何时被调用？</p><p>对象初始化，通过调用 <code>object_new</code> 来实现初始化。</p><ul><li><code>object_initialize_with_type</code><ul><li>初始化一个空的 :<code> Object::properties</code></li><li><code>object_init_with_type</code><ul><li>如果 <code>object</code> 有 <code>parent</code>，那么调用 <code>object_init_with_type</code> 首先初始化 <code>parent</code> 的</li><li>调用<code> TypeImpl::instance_init</code></li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">main <br>    qemu_init <br>        qmp_x_exit_preconfig <br>            qemu_init_board <br>                machine_run_board_init <br>                    pc_init_v6_1 <br>                        pc_init1 <br>                            x86_cpus_init <br>                                x86_cpu_new <br>                                    object_new <br>                                        object_new_with_type <br>                                            object_initialize_with_type <br>                                                object_init_with_type <br>                                                    x86_cpu_initfn <br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。为了实现多态，QOM实现了一个非常重要的功能，就是动态类型转换。我们可以使用相关的函数，将一个<code>Object</code>的指针在运行时转换为子类对象的指针，可以将一个<code>ObjectClass</code>的指针在运行时转换为子类的指针。这样就可以调用子类中定义的函数指针来完成相应的功能。</p><p>QEMU 定义了一些列的宏封来进行动态类型转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//include/qom/object.h</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_INSTANCE_CHECKER:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the instance type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED InstanceType * \</span><br><span class="hljs-meta">    OBJ_NAME(const void *obj) \</span><br><span class="hljs-meta">    &#123; return OBJECT_CHECK(InstanceType, obj, TYPENAME); &#125;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_CLASS_CHECKERS:</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the class type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED ClassType * \</span><br><span class="hljs-meta">    OBJ_NAME##_GET_CLASS(const void *obj) \</span><br><span class="hljs-meta">    &#123; return OBJECT_GET_CLASS(ClassType, obj, TYPENAME); &#125; \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    static inline G_GNUC_UNUSED ClassType * \</span><br><span class="hljs-meta">    OBJ_NAME##_CLASS(const void *klass) \</span><br><span class="hljs-meta">    &#123; return OBJECT_CLASS_CHECK(ClassType, klass, TYPENAME); &#125;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DECLARE_OBJ_CHECKERS:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> * @TYPENAME: type name</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Direct usage of this macro should be avoided, and the complete</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE macro is recommended instead.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro will provide the three standard type cast functions for a</span><br><span class="hljs-comment"> * QOM type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_OBJ_CHECKERS(InstanceType, ClassType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_DECLARE_TYPE:</span><br><span class="hljs-comment"> * @InstanceType: instance struct name</span><br><span class="hljs-comment"> * @ClassType: class struct name</span><br><span class="hljs-comment"> * @MODULE_OBJ_NAME: the object name in uppercase with underscore separators</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This macro is typically used in a header file, and will:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   - create the typedefs for the object and class structs</span><br><span class="hljs-comment"> *   - register the type for use with g_autoptr</span><br><span class="hljs-comment"> *   - provide three standard type cast functions</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The object struct and class struct need to be declared manually.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_DECLARE_TYPE(InstanceType, ClassType, MODULE_OBJ_NAME) \</span><br><span class="hljs-meta">    typedef struct InstanceType InstanceType; \</span><br><span class="hljs-meta">    typedef struct ClassType ClassType; \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    G_DEFINE_AUTOPTR_CLEANUP_FUNC(InstanceType, object_unref) \</span><br><span class="hljs-meta">    \</span><br><span class="hljs-meta">    DECLARE_OBJ_CHECKERS(InstanceType, ClassType, \</span><br><span class="hljs-meta">                         MODULE_OBJ_NAME, TYPE_##MODULE_OBJ_NAME)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT:</span><br><span class="hljs-comment"> * @obj: A derivative of #Object</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Converts an object to a #Object.  Since all objects are #Objects,</span><br><span class="hljs-comment"> * this function will always succeed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT(obj) \</span><br><span class="hljs-meta">    ((Object *)(obj))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CLASS:</span><br><span class="hljs-comment"> * @class: A derivative of #ObjectClass.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Converts a class to an #ObjectClass.  Since all objects are #Objects,</span><br><span class="hljs-comment"> * this function will always succeed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CLASS(class) \</span><br><span class="hljs-meta">    ((ObjectClass *)(class))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CHECK:</span><br><span class="hljs-comment"> * @type: The C type to use for the return value.</span><br><span class="hljs-comment"> * @obj: A derivative of @type to cast.</span><br><span class="hljs-comment"> * @name: The QOM typename of @type</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A type safe version of @object_dynamic_cast_assert.  Typically each class</span><br><span class="hljs-comment"> * will define a macro based on this type to perform type safe dynamic_casts to</span><br><span class="hljs-comment"> * this object type.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If an invalid object is passed to this function, a run time assert will be</span><br><span class="hljs-comment"> * generated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CHECK(type, obj, name) \</span><br><span class="hljs-meta">    ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \</span><br><span class="hljs-meta">                                        __FILE__, __LINE__, __func__))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_CLASS_CHECK:</span><br><span class="hljs-comment"> * @class_type: The C type to use for the return value.</span><br><span class="hljs-comment"> * @class: A derivative class of @class_type to cast.</span><br><span class="hljs-comment"> * @name: the QOM typename of @class_type.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A type safe version of @object_class_dynamic_cast_assert.  This macro is</span><br><span class="hljs-comment"> * typically wrapped by each type to perform type safe casts of a class to a</span><br><span class="hljs-comment"> * specific class type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_CLASS_CHECK(class_type, class, name) \</span><br><span class="hljs-meta">    ((class_type *)object_class_dynamic_cast_assert(OBJECT_CLASS(class), (name), \</span><br><span class="hljs-meta">                                               __FILE__, __LINE__, __func__))</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * OBJECT_GET_CLASS:</span><br><span class="hljs-comment"> * @class: The C type to use for the return value.</span><br><span class="hljs-comment"> * @obj: The object to obtain the class for.</span><br><span class="hljs-comment"> * @name: The QOM typename of @obj.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function will return a specific class for a given object.  Its generally</span><br><span class="hljs-comment"> * used by each type to provide a type safe macro to get a specific class type</span><br><span class="hljs-comment"> * from an object.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJECT_GET_CLASS(class, obj, name) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(class, object_get_class(OBJECT(obj)), name)</span><br><br></code></pre></td></tr></table></figure><p>以<code>OBJECT_DECLARE_TYPE(X86CPU, X86CPUClass, X86_CPU)</code>为例，宏展开如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPU</span> <span class="hljs-title">X86CPU</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPUClass</span> <span class="hljs-title">X86CPUClass</span>;</span><br>G_DEFINE_AUTOPTR_CLEANUP_FUNC(X86CPU, object_unref)<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPU *<span class="hljs-title">X86_CPU</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPU *)object_dynamic_cast_assert(<br>      ((Object *)(obj)), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPUClass *<span class="hljs-title">X86_CPU_GET_CLASS</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPUClass *)object_class_dynamic_cast_assert(<br>      ((ObjectClass *)(object_get_class(((Object *)(obj))))), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> G_GNUC_UNUSED X86CPUClass *<span class="hljs-title">X86_CPU_CLASS</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *klass)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((X86CPUClass *)object_class_dynamic_cast_assert(<br>      ((ObjectClass *)(klass)), (TYPE_X86_CPU),<br>      <span class="hljs-string">&quot;~/core/vn/docs/qemu/res/qom-macros.c&quot;</span>, <span class="hljs-number">64</span>, __func__));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>OBJECT_DECLARE_TYPE</code>通常在头文件中使用，效果是：</p><ul><li>创建了<code>X86CPU</code>和<code>X86CPUClass</code>的<code>typedef</code></li><li>用<code>G_DEFINE_AUTOPTR_CLEANUP_FUNC</code>注册类型</li><li>创建了三个类型转换函数<ul><li><code>X86_CPU</code> : 将任何一个 <code>object</code> 指针 转换为 <code>X86CPU</code>（Object转子对象）</li><li><code>X86_CPU_GET_CLASS</code> : 根据 <code>object</code> 指针获取到 <code>X86CPUClass</code></li><li><code>X86_CPU_CLASS</code> : 根据 <code>ObjectClass</code> 指针转换到 <code>X86CPUClass</code>（基类转子类）</li></ul></li></ul><p>这里的转换依赖内存布局，子类型的第一个成员总是基类型。子类转基类就很容易，只需要强制类型转换就可以实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://martins3.github.io/qemu/qom.html#init">QEMU 中的面向对象 : QOM | Deep Dark Fantasy</a><br><a href="https://www.jianshu.com/p/4a9d26abb44d">浅谈QEMU的对象系统 - 简书</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RGB与YUV颜色空间</title>
    <link href="/2022/03/01/RGB%E4%B8%8EYUV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/03/01/RGB%E4%B8%8EYUV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>RGB和YUV都属于一种颜色编码方式，或者说颜色空间。</p><p>RGB色彩模式是工业界的一种颜色标准，是通过对红、绿、蓝三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。</p><p>在YUV空间中，Y代表亮度，其实Y就是图像的灰度值；UV代表色差，U和V是构成彩色的两个分量。在现代彩色电视系统中，通常采用三管彩色摄影机或彩色CCD摄影机进行取像，然后把取得的彩色图像信号经分色、分别放大校正后得到RGB，再经过矩阵变换电路得到亮度信号Y和两个色差信号B–Y(即U)、R–Y(即V)，最后发送端将亮度和色差三个信号分别进行编码，用同一信道发送出去。这种色彩的表示方法就是所谓的YUV色彩空间表示。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="RGB格式"><a href="#RGB格式" class="headerlink" title="RGB格式"></a>RGB格式</h3><h4 id="RGB16"><a href="#RGB16" class="headerlink" title="RGB16"></a>RGB16</h4><p>RGB16数据格式主要有二种：RGB565和RGB555。</p><p>RGB565,每个像素用16比特位表示，占2个字节，RGB分量分别使用5位、6位、5位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//获取高字节的5个bit</span><br>R = color &amp; <span class="hljs-number">0xF800</span>;<br><span class="hljs-comment">//获取中间6个bit</span><br>G = color &amp; <span class="hljs-number">0x07E0</span>;<br><span class="hljs-comment">//获取低字节5个bit</span><br>B = color &amp; <span class="hljs-number">0x001F</span>;<br></code></pre></td></tr></table></figure><p>RGB555,每个像素用16比特位表示，占2个字节，RGB分量都使用5位(最高位不用)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//获取高字节的5个bit</span><br>R = color &amp; <span class="hljs-number">0x7C00</span>;<br><span class="hljs-comment">//获取中间5个bit</span><br>G = color &amp; <span class="hljs-number">0x03E0</span>;<br><span class="hljs-comment">//获取低字节5个bit</span><br>B = color &amp; <span class="hljs-number">0x001F</span>;<br></code></pre></td></tr></table></figure><h4 id="RGB24"><a href="#RGB24" class="headerlink" title="RGB24"></a>RGB24</h4><p>RGB24图像每个像素用24比特位表示，占3个字节，注意：在内存中RGB各分量的排列顺序为：<strong>BGR BGR BGR</strong>。</p><h4 id="RGB32"><a href="#RGB32" class="headerlink" title="RGB32"></a>RGB32</h4><p>RGB32图像每个像素用32比特位表示，占4个字节，R，G，B分量分别用8个bit表示，存储顺序为B，G，R，最后8个字节保留。注意：在内存中RGB各分量的排列顺序为：<strong>BGRA BGRA BGRA</strong> ……。</p><p>本质就是带alpha通道的RGB24，与RGB32的区别在与，保留的8个bit用来表示透明，也就是alpha的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">R = color &amp; <span class="hljs-number">0x0000FF00</span>;<br>G = color &amp; <span class="hljs-number">0x00FF0000</span>;<br>B = color &amp; <span class="hljs-number">0xFF000000</span>;<br>A = color &amp; <span class="hljs-number">0x000000FF</span>;<br></code></pre></td></tr></table></figure><h3 id="YUV采样"><a href="#YUV采样" class="headerlink" title="YUV采样"></a>YUV采样</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220301170332.png"></p><ul><li>YUV444：一个像素就有YUV三个值，和RGB类似；一个YUV占8+8+8 = 24bits 3个字节。</li><li>YUV422：第一个像素有YUV三个值，第二个像素只有Y，与前一个像素共用UV；一个YUV占8+4+4 = 16bits 2个字节。</li><li>YUV420：上下四个像素共用一个UV。一个YUV占8+2+2 = 12bits 1.5个字节。</li></ul><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="YUV2RGB"><a href="#YUV2RGB" class="headerlink" title="YUV2RGB"></a>YUV2RGB</h3><p>$$<br>R = Y + 1.403 \times (V-128)\<br>G=Y-0.343 \times (U-128) - 0.714 \times (V-128)\<br>B=Y + 1.770 \times (U-128)<br>$$</p><h3 id="RGB2YUV"><a href="#RGB2YUV" class="headerlink" title="RGB2YUV"></a>RGB2YUV</h3><p>$$<br>Y = 0.299 \times R + 0.587 \times G + 0.114 \times B\<br>U = -0.169 \times R - 0.331 \times G + 0.500 \times B + 128\<br>V = 0.500 \times R - 0.419 \times G - 0.081 \times B + 128\<br>$$</p><p>浮点型运算比较耗时，将所有运算换成位运算，提高效率。具体推倒过程见<a href="https://blog.csdn.net/weixin_40647819/article/details/92619298">色彩转换系列之RGB格式与YUV格式互转原理及实现_小武的博客-CSDN博客_rgb yuv</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">Y= ((R &lt;&lt; <span class="hljs-number">6</span>) + (R &lt;&lt; <span class="hljs-number">3</span>) + (R &lt;&lt; <span class="hljs-number">2</span>) + R + (G &lt;&lt; <span class="hljs-number">7</span>) + (G &lt;&lt; <span class="hljs-number">4</span>) + (G &lt;&lt; <span class="hljs-number">2</span>) + (G &lt;&lt; <span class="hljs-number">1</span>) + (B &lt;&lt; <span class="hljs-number">4</span>) + (B &lt;&lt; <span class="hljs-number">3</span>) + (B &lt;&lt; <span class="hljs-number">2</span>) + B) &gt;&gt; <span class="hljs-number">8</span><br>U= (-((R &lt;&lt; <span class="hljs-number">5</span>) + (R &lt;&lt; <span class="hljs-number">3</span>) + (R &lt;&lt; <span class="hljs-number">1</span>)+ R) - ((G &lt;&lt; <span class="hljs-number">6</span>) + (G &lt;&lt; <span class="hljs-number">4</span>) + (G &lt;&lt; <span class="hljs-number">2</span>)+G) + (B &lt;&lt; <span class="hljs-number">7</span>) + <span class="hljs-number">32768</span>) &gt;&gt; <span class="hljs-number">8</span><br>V= ((R &lt;&lt; <span class="hljs-number">7</span>) - ((G &lt;&lt; <span class="hljs-number">6</span>) + (G &lt;&lt; <span class="hljs-number">5</span>) + (G &lt;&lt; <span class="hljs-number">3</span>) + (G &lt;&lt; <span class="hljs-number">3</span>) + G) - ((B &lt;&lt; <span class="hljs-number">4</span>) + (B &lt;&lt; <span class="hljs-number">2</span>) + B) + <span class="hljs-number">32768</span> )&gt;&gt; <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/cd7e73005ac4">RGB和YUV - 简书</a><br><a href="https://blog.csdn.net/fengbingchun/article/details/50216901">颜色空间YUV简介_网络资源是无限的-CSDN博客_yuv颜色空间</a><br><a href="https://blog.csdn.net/byhook/article/details/84262330">图解RGB565、RGB555、RGB16、RGB24、RGB32、ARGB32等格式的区别_handy周-CSDN博客_rgb565</a><br><a href="https://blog.csdn.net/byhook/article/details/84037338">图解YU12、I420、YV12、NV12、NV21、YUV420P、YUV420SP、YUV422P、YUV444P的区别_handy周-CSDN博客_yv12</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理-指令和运算</title>
    <link href="/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/"/>
    <url>/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机指令"><a href="#计算机指令" class="headerlink" title="计算机指令"></a>计算机指令</h2><p>上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0表示不打孔，1表示打孔），送入特殊的计算机中执行。</p><p>从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。</p><p>从软件的角度来看，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作<strong>机器语言</strong>（Machine Language）。</p><p>不同的 CPU 能够听懂的语言不太一样。也就是CPU支持的语言不一样，这里的语言叫<strong>指令集</strong>（Instruction Set）。</p><p>一个计算机程序由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作<strong>存储程序型计算机</strong>（Stored-program Computer）。</p><p>了解了计算机指令和计算机指令集，接下来我们来看看，平时编写的代码，到底是怎么变成一条条计算机指令，最后被 CPU 执行的呢？我们拿一小段真实的 C 语言程序来看看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; <br>  <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>  a = a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过编译器，可以将上述代码编译成汇编代码，再通过汇编器，将汇编代码编译成机器码，最后通过 CPU 执行。</p><p>在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -g -c test.c<br>$ objdump -d -M intel -S test.o<br><br>test.o:     file format elf64-x86-64<br>Disassembly of section .text:<br>0000000000000000 &lt;main&gt;:<br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br>   0:   55                      push   rbp<br>   1:   48 89 e5                mov    rbp,rsp<br>  int a = 1; <br>   4:   c7 45 <span class="hljs-built_in">fc</span> 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1<br>  int b = 2;<br>   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2<br>  a = a + b;<br>  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]<br>  15:   01 45 <span class="hljs-built_in">fc</span>                add    DWORD PTR [rbp-0x4],eax<br>&#125;<br>  18:   5d                      pop    rbp<br>  19:   c3                      ret    <br></code></pre></td></tr></table></figure><p>左侧有一堆数字，这些就是一条条机器码；右边有一系列的<code> push</code>、<code>mov</code>、<code>add</code>、<code>pop</code> 等，这些就是对应的汇编代码。</p><p>了解了这个过程，下面我们放大局部，来看看这一行行的汇编代码和机器指令，到底是什么意思。</p><p>常见的指令可以分成五大类。</p><p>第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。</p><p>第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。</p><p>第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。</p><p>第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。</p><p>最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。</p><h2 id="指令跳转"><a href="#指令跳转" class="headerlink" title="指令跳转"></a>指令跳转</h2><h3 id="CPU如何执行指令的"><a href="#CPU如何执行指令的" class="headerlink" title="CPU如何执行指令的"></a>CPU如何执行指令的</h3><p>代码经过软件层面的编译后就是一条条二进制指令，指令交由CPU中几百亿个晶体管去执行。我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。而寄存器就是 CPU 内部，由多个<strong>触发器</strong>（Flip-Flop）或者<strong>锁存器</strong>（Latches）组成的简单电路。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。</p><p><code>N</code> 个触发器或者锁存器，就可以组成一个<code>N</code>位（Bit）的寄存器，能够保存 <code>N </code>位的数据。比方说，我们用的<code>64</code>位 <code>Intel </code>服务器，寄存器就是<code> 64</code> 位的。</p><p>一个 CPU 里面会有很多种不同功能的寄存器。这里介绍三种比较特殊的。</p><ul><li><p>PC 寄存器（Program Counter Register），我们也叫<strong>指令地址寄存器</strong>（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。</p></li><li><p>指令寄存器（Instruction Register），用来存放当前正在执行的指令。</p></li><li><p>条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。</p></li></ul><p>除此之外还有<strong>整数寄存器</strong>、<strong>浮点数寄存器</strong>、<strong>向量寄存器</strong>和<strong>地址寄存器</strong>等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。</p><p>实际上，一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。</p><p>而有些特殊指令，比如上一讲我们讲到 <code>J</code> 类指令，也就是跳转指令，会修改 PC 寄存器里面的地址值。</p><h3 id="从-if…else-来看程序的执行和跳转"><a href="#从-if…else-来看程序的执行和跳转" class="headerlink" title="从 if…else 来看程序的执行和跳转"></a>从 if…else 来看程序的执行和跳转</h3><p>首先看如下的例程，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  srand(time(<span class="hljs-literal">NULL</span>));<br>  <span class="hljs-keyword">int</span> r = rand() % <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>)<br>  &#123;<br>    a = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    a = <span class="hljs-number">2</span>;<br>  &#125; <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -g -c test.c<br>$ objdump -d -M intel -S test.o <br></code></pre></td></tr></table></figure><p>编译后打印出汇编代码如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">if (r == <span class="hljs-number">0</span>)<br> 3b:   <span class="hljs-number">83</span> <span class="hljs-number">7d</span> fc <span class="hljs-number">00</span>             <span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>],<span class="hljs-number">0x0</span><br> 3f:   <span class="hljs-number">75</span> <span class="hljs-number">09</span>                   <span class="hljs-keyword">jne</span>    4a &lt;main+<span class="hljs-number">0x4a</span>&gt;<br>   &#123;<br>       a = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br> <span class="hljs-number">41</span>:   c7 <span class="hljs-number">45</span> f8 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>],<span class="hljs-number">0x1</span><br> <span class="hljs-number">48</span>:   eb <span class="hljs-number">07</span>                   <span class="hljs-keyword">jmp</span>    <span class="hljs-number">51</span> &lt;main+<span class="hljs-number">0x51</span>&gt;<br>   &#125;<br>   else<br>   &#123;<br>       a = <span class="hljs-number">2</span><span class="hljs-comment">;</span><br> 4a:   c7 <span class="hljs-number">45</span> f8 <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>],<span class="hljs-number">0x2</span><br> <span class="hljs-number">51</span>:   b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0</span><br>   &#125; <br></code></pre></td></tr></table></figure><p>可以看到，这里对于 <code>r == 0 </code>的条件判断，被编译成了 cmp 和 jne 这两条指令。</p><p><code>cmp</code> 指令比较了前后两个操作数的值，这里的<code> DWORD PTR</code> 代表操作的数据类型是 <code>32 </code>位的整数，而 <code>[rbp-0x4]</code> 则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量 <code>r</code> 的值。第二个操作数 <code>0x0</code> 就是我们设定的常量<code>0</code>的 <code>16</code> 进制表示。<code>cmp</code> 指令的比较结果，会存入到条件码寄存器当中去。</p><p>在这里，如果比较的结果是 <code>True</code>，也就是 <code>r == 0</code>，就把零标志条件码（对应的条件码是 <code>ZF</code>，<code>Zero Flag</code>）设置为 <code>1</code>。除了零标志之外，<code>Intel</code> 的 <code>CPU</code> 下还有进位标志（<code>CF</code>，<code>Carry Flag</code>）、符号标志（<code>SF</code>，<code>Sign Flag</code>）以及溢出标志（<code>OF</code>，<code>Overflow Flag</code>），用在不同的判断条件下。</p><p><code>cmp</code> 指令执行完成之后，<code>PC</code> 寄存器会自动自增，开始执行下一条 <code>jne</code> 的指令。</p><p>跟着的 <code>jne</code> 指令，是 <code>jump if not equal</code> 的意思，它会查看对应的零标志位。如果为<code> 0</code>，会跳转到后面跟着的操作数 <code>4a</code> 的位置。这个 <code>4a</code>，对应这里汇编代码的行号，也就是上面设置的 <code>else</code> 条件里的第一条指令。当跳转发生的时候，<code>PC</code> 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 <code>4a</code> 这个地址。这个时候，<code>CPU</code> 再把 <code>4a</code> 地址里的指令加载到指令寄存器中来执行。</p><p>跳转到执行地址为 <code>4a</code> 的指令，实际是一条 <code>mov</code> 指令，第一个操作数和前面的 <code>cmp</code> 指令一样，是另一个 <code>32</code> 位整型的寄存器地址，以及对应的 <code>2</code> 的<code> 16</code> 进制值 <code>0x2</code>。<code>mov</code> 指令把 <code>2</code> 设置到对应的寄存器里去，相当于一个赋值操作。然后，<code>PC </code>寄存器里的值继续自增，执行下一条 <code>mov</code> 指令。</p><p>这条 <code>mov</code> 指令的第一个操作数<code> eax</code>，代表累加寄存器，第二个操作数<code>0x0</code>则是 <code>16</code> 进制的<code>0</code>的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的 <code>if</code> 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 <code>jmp</code> 的无条件跳转指令。跳转的地址就是这一行的地址<code> 51</code>。我们的 <code>main</code> 函数没有设定返回值，而<code> mov eax</code>, <code>0x0</code> 其实就是给 <code>main</code> 函数生成了一个默认的为 <code>0</code> 的返回值到累加器里面。<code>if</code> 条件里面的内容执行完成之后也会跳转到这里，和 <code>else</code> 里的内容结束之后的位置是一样的。</p><h2 id="函数调用：为什么会发生Stack-Overflow"><a href="#函数调用：为什么会发生Stack-Overflow" class="headerlink" title="函数调用：为什么会发生Stack Overflow"></a>函数调用：为什么会发生Stack Overflow</h2><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>既然我们的程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在 Linux 下可以运行，而在 Windows 下却不行呢？反过来，Windows 上的程序在 Linux 上也是一样不能执行的。可是我们的 CPU 并没有换掉，它应该可以识别同样的指令呀？</p><p>将以下两个例程编译，然后通过 objdump 命令看看它们的汇编代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// add_lib.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-comment">// link_example.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> c = add(a, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %d\n&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -g -c add_lib.c link_example.c<br>$ objdump -d -M intel -S add_lib.o<br>$ objdump -d -M intel -S link_example.o<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">add_lib.o:</span>     file format elf64-x86-<span class="hljs-number">64</span><br>Disassembly of <span class="hljs-meta">section</span> .text:<br><span class="hljs-number">0000000000000000</span> &lt;<span class="hljs-keyword">add</span>&gt;:<br>   <span class="hljs-number">0</span>:   <span class="hljs-number">55</span>                      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbp</span><br>   <span class="hljs-number">1</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbp</span>,<span class="hljs-built_in">rsp</span><br>   <span class="hljs-number">4</span>:   <span class="hljs-number">89</span> <span class="hljs-number">7d</span> fc                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>],<span class="hljs-built_in">edi</span><br>   <span class="hljs-number">7</span>:   <span class="hljs-number">89</span> <span class="hljs-number">75</span> f8                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>],<span class="hljs-built_in">esi</span><br><span class="hljs-symbol">   a:</span>   8b <span class="hljs-number">55</span> fc                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>]<br><span class="hljs-symbol">   d:</span>   8b <span class="hljs-number">45</span> f8                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>]<br>  <span class="hljs-number">10</span>:   <span class="hljs-number">01</span> d0                   <span class="hljs-keyword">add</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">edx</span><br>  <span class="hljs-number">12</span>:   <span class="hljs-number">5d</span>                      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rbp</span><br>  <span class="hljs-number">13</span>:   c3                      <span class="hljs-keyword">ret</span>    <br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">link_example</span>.o:     file format elf<span class="hljs-number">64</span>-x<span class="hljs-number">86</span>-<span class="hljs-number">64</span><br><span class="hljs-attribute">Disassembly</span> of section .text:<br><span class="hljs-attribute">0000000000000000</span> &lt;main&gt;:<br>   <span class="hljs-attribute">0</span>:   <span class="hljs-number">55</span>                      push   rbp<br>   <span class="hljs-attribute">1</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e<span class="hljs-number">5</span>                mov    rbp,rsp<br>   <span class="hljs-attribute">4</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>             sub    rsp,<span class="hljs-number">0</span>x<span class="hljs-number">10</span><br>   <span class="hljs-attribute">8</span>:   c<span class="hljs-number">7</span> <span class="hljs-number">45</span> fc <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    mov    DWORD PTR<span class="hljs-meta"> [rbp-0x4],0xa</span><br><span class="hljs-meta">   f:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5</span><br><span class="hljs-meta">  16:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]</span><br>  <span class="hljs-attribute">19</span>:   <span class="hljs-number">8</span>b <span class="hljs-number">45</span> fc                mov    eax,DWORD PTR<span class="hljs-meta"> [rbp-0x4]</span><br>  <span class="hljs-attribute">1c</span>:   <span class="hljs-number">89</span> d<span class="hljs-number">6</span>                   mov    esi,edx<br>  <span class="hljs-attribute">1e</span>:   <span class="hljs-number">89</span> c<span class="hljs-number">7</span>                   mov    edi,eax<br>  <span class="hljs-attribute">20</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    eax,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><br>  <span class="hljs-attribute">25</span>:   e<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          call   <span class="hljs-number">2</span>a &lt;main+<span class="hljs-number">0</span>x<span class="hljs-number">2</span>a&gt;<br>  <span class="hljs-attribute">2a</span>:   <span class="hljs-number">89</span> <span class="hljs-number">45</span> f<span class="hljs-number">4</span>                mov    DWORD PTR<span class="hljs-meta"> [rbp-0xc],eax</span><br><span class="hljs-meta">  2d:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]</span><br>  <span class="hljs-attribute">30</span>:   <span class="hljs-number">89</span> c<span class="hljs-number">6</span>                   mov    esi,eax<br>  <span class="hljs-attribute">32</span>:   <span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">3</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    lea    rdi,[rip+<span class="hljs-number">0</span>x<span class="hljs-number">0</span>]        # <span class="hljs-number">39</span> &lt;main+<span class="hljs-number">0</span>x<span class="hljs-number">39</span>&gt;<br>  <span class="hljs-attribute">39</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    eax,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><br>  <span class="hljs-attribute">3e</span>:   e<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          call   <span class="hljs-number">43</span> &lt;main+<span class="hljs-number">0</span>x<span class="hljs-number">43</span>&gt;<br>  <span class="hljs-attribute">43</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    eax,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><br>  <span class="hljs-attribute">48</span>:   c<span class="hljs-number">9</span>                      leave  <br>  <span class="hljs-attribute">49</span>:   c<span class="hljs-number">3</span>                      ret    <br></code></pre></td></tr></table></figure><p>既然代码已经被我们“编译”成了指令，我们不妨尝试运行一下 <code>./link_example.o</code>。</p><p>然而我们并不能成功运行，会得到一条<code> cannot execute binary file: Exec format error</code> 的错误。</p><p>我们再仔细看一下 objdump 出来的两个文件的代码，<strong>会发现两个程序的地址都是从 0 开始的</strong>。如果地址是一样的，程序如果需要通过 <code>call</code> 指令调用函数的话，<strong>它怎么知道应该跳转到哪一个文件里呢？</strong></p><p>无论是这里的运行报错，还是 <code>objdump</code> 出来的汇编代码里面的重复地址，都是因为<code>add_lib.o</code>以及 <code>link_example.o</code> 并不是一个可执行文件（Executable Program），而是目标文件（Object File）。<strong>只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。</strong></p><p>通过 <code>gcc</code> 的<code>-o</code>参数，可以生成对应的可执行文件。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>gcc -o link-example add_lib.o link_example.o<br><span class="hljs-variable">$ </span>./link_example<br>c = <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203032207712.png"></p><p>链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203032209801.png"></p><p>在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。</p><p>为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。其中一个非常重要的原因就是，<strong>两个操作系统下可执行文件的格式不一样</strong>。</p><p>我们今天讲的是 Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作PE（Portable Executable Format）的文件格式。<strong>Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。</strong></p><p>如果我们有一个可以能够解析 PE 格式的装载器，我们就有可能在 Linux 下运行 Windows 程序了。这样的程序真的存在吗？没错，Linux 下著名的开源项目 Wine，就是通过兼容 PE 格式的装载器，使得我们能直接在 Linux 下运行 Windows 程序的。而现在微软的 Windows 里面也提供了 WSL，也就是 Windows Subsystem for Linux，可以解析和加载 ELF 格式的文件。</p><h2 id="程序装载"><a href="#程序装载" class="headerlink" title="程序装载"></a>程序装载</h2><h4 id="程序装载面临的挑战"><a href="#程序装载面临的挑战" class="headerlink" title="程序装载面临的挑战"></a>程序装载面临的挑战</h4><ul><li>可执行程序加载后占用的内存空间应该是连续的。<br>  这点很好理解，指令正常都是顺序执行的。</li><li>我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。<br>  计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用了。</li></ul><p>我们把指令里用到的内存地址叫作<strong>虚拟内存地址</strong>（Virtual Memory Address），实际在内存硬件里面的空间地址，我们叫<strong>物理内存地址</strong>（Physical Memory Address）。</p><p>程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了。对于任何一个程序来说，它看到的都是同样的内存地址。我们<strong>维护一个虚拟内存到物理内存的映射表</strong>，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。</p><h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><p>这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫<strong>分段</strong>（Segmentation）。这里的段，就是指系统分配出来的那个连续的内存空间。</p><p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处，第一个就是<strong>内存碎片</strong>（Memory Fragmentation）的问题。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203051544158.png"></p><p>我们可以通过<strong>内存交换</strong>（Memory Swapping）技术解决。</p><p>我们可以把 Python 程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里面。不过读回来的时候，我们不再把它加载到原来的位置，而是紧紧跟在那已经被占用了的 512MB 内存后面。这样，我们就有了连续的 256MB 内存空间，就可以去加载一个新的 200MB 的程序。</p><p>如果你自己安装过 Linux 操作系统，你应该遇到过分配一个 swap 硬盘分区的问题。这块分出来的磁盘空间，其实就是专门给 Linux 操作系统进行内存交换用的。</p><p>硬盘的访问速度要比内存慢很多，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。</p><h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p>既然问题出在内存碎片和内存交换的空间太大上，那么解决问题的办法就是，<strong>少出现一些内存碎片，并且让需要交换写入或者从磁盘装载的数据更少一点</strong>。于是就有了内存分页（Paging）。</p><p><strong>和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小</strong>。而对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。</p><p>从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。页的尺寸一般远远小于整个程序的大小。在 Linux 下，我们通常只设置成 4KB。</p><p><strong>由于内存空间都是预先划分好的，也就没有了不能使用的碎片</strong>，而只有被释放出来的很多 4KB 的页。即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，让整个机器被内存交换的过程给卡住。</p><p>分页的方式使得我们在加载程序的时候，<strong>不再需要一次性都把程序加载到物理内存中</strong>。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</p><p>实际上，我们的操作系统，的确是这么做的。当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的<strong>缺页错误</strong>（Page Fault）。我们的操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>如果我们有很多个程序都要通过装载器装载到内存里面，那里面链接好的同样的功能代码，也都需要再装载一遍，再占一遍内存空间。在一个运行上百个进程的系统中，这将会造成极大的资源浪费。</p><p>共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>（dynamic linking） 是由一个叫做<strong>动态链接器</strong>（dynamic linker）的程序来执行的。 Linux中为<code>.so</code>文件，windows中为<code>.dll</code>文件。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203061034401.png"></p><h3 id="PIC-（Position-Independent-Code）"><a href="#PIC-（Position-Independent-Code）" class="headerlink" title="PIC （Position-Independent Code）"></a>PIC （Position-Independent Code）</h3><p>要想要在程序运行的时候共享代码，也有一定的要求，就是这些机器码必须是“<strong>地址无关</strong>”的。也就是说，我们编译出来的共享库文件的指令代码，放在哪个内存地址都能正常运行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203061037029.png"></p><p>对于所有动态链接共享库的程序来讲，虽然我们的<strong>共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的</strong>。我们没办法、也不应该要求动态链接同一个共享库的不同程序，必须把这个共享库所使用的虚拟内存地址变成一致。如果这样的话，我们写的程序就必须明确地知道内部的内存地址分配。</p><p>如何才能实现地址无关？</p><p>动态代码库内部的变量和函数调用都很容易解决，我们只需要使用<strong>相对地址</strong>（Relative Address）就好了。各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。因为整个共享库是放在一段连续的虚拟内存地址中的，无论装载到哪一段地址，不同指令之间的相对地址都是不变的。</p><h3 id="PLT-和-GOT"><a href="#PLT-和-GOT" class="headerlink" title="PLT 和 GOT"></a>PLT 和 GOT</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// lib.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LIB_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIB_H</span><br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_me_the_money</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">// lib.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_me_the_money</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Show me USD %d from lib.c \n&quot;</span>, money);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// show_me_poor.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lib.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> money = <span class="hljs-number">5</span>;<br>    show_me_the_money(money);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal">$ gcc <span class="hljs-keyword">lib</span>.c -fPIC -shared -o <span class="hljs-keyword">lib</span>.so<br>$ gcc -o show_me_poor show_me_poor.c ./<span class="hljs-keyword">lib</span>.so<br></code></pre></td></tr></table></figure><p><code>-fpic</code> 选项指示编译器生成与位置无关的代码。<code>-shared</code>选项指示链接器创建一个共享的目标文件。</p><p>然后，我们再通过 <code>gcc</code> 编译 <code>show_me_poor</code> 动态链接了 <code>lib.so</code> 的可执行文件。在这些操作都完成了之后，我们把 <code>show_me_poor</code> 这个文件通过 <code>objdump</code> 出来看一下。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">$ objdump -d -M intel -S show_me_poor<br><br>……<br><span class="hljs-number">0000000000400540</span> &lt;show_me_the_money@plt-<span class="hljs-number">0x10</span>&gt;:<br>  <span class="hljs-number">400540</span>:       ff <span class="hljs-number">35</span> <span class="hljs-number">12</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">push</span>   <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x200512</span>]        # 600a58 &lt;_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x8</span>&gt;<br>  <span class="hljs-number">400546</span>:       ff <span class="hljs-number">25</span> <span class="hljs-number">14</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">jmp</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x200514</span>]        # 600a60 &lt;_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x10</span>&gt;<br>  40054c:       0f 1f <span class="hljs-number">40</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">nop</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0x0</span>]<br> <br><span class="hljs-number">0000000000400550</span> &lt;show_me_the_money@plt&gt;:<br>  <span class="hljs-number">400550</span>:       ff <span class="hljs-number">25</span> <span class="hljs-number">12</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">jmp</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x200512</span>]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x18</span>&gt;<br>  <span class="hljs-number">400556</span>:       <span class="hljs-number">68</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">push</span>   <span class="hljs-number">0x0</span><br>  40055b:       e9 e0 ff ff ff          <span class="hljs-keyword">jmp</span>    <span class="hljs-number">400540</span> &lt;_init+<span class="hljs-number">0x28</span>&gt;<br>……<br><span class="hljs-number">0000000000400676</span> &lt;main&gt;:<br>  <span class="hljs-number">400676</span>:       <span class="hljs-number">55</span>                      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbp</span><br>  <span class="hljs-number">400677</span>:       <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbp</span>,<span class="hljs-built_in">rsp</span><br>  40067a:       <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>             <span class="hljs-keyword">sub</span>    <span class="hljs-built_in">rsp</span>,<span class="hljs-number">0x10</span><br>  40067e:       c7 <span class="hljs-number">45</span> fc <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>],<span class="hljs-number">0x5</span><br>  <span class="hljs-number">400685</span>:       8b <span class="hljs-number">45</span> fc                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x4</span>]<br>  <span class="hljs-number">400688</span>:       <span class="hljs-number">89</span> c7                   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>,<span class="hljs-built_in">eax</span><br>  40068a:       e8 c1 fe ff ff          <span class="hljs-keyword">call</span>   <span class="hljs-number">400550</span> &lt;show_me_the_money@plt&gt;<br>  40068f:       c9                      <span class="hljs-keyword">leave</span>  <br>  <span class="hljs-number">400690</span>:       c3                      <span class="hljs-keyword">ret</span>    <br>  <span class="hljs-number">400691</span>:       <span class="hljs-number">66</span> 2e 0f 1f <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">nop</span>    <span class="hljs-built_in">WORD</span> <span class="hljs-built_in">PTR</span> <span class="hljs-built_in">cs</span>:[<span class="hljs-built_in">rax</span>+<span class="hljs-built_in">rax</span>*<span class="hljs-number">1</span>+<span class="hljs-number">0x0</span>]<br>  <span class="hljs-number">400698</span>:       <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  40069b:       0f 1f <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">nop</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>+<span class="hljs-built_in">rax</span>*<span class="hljs-number">1</span>+<span class="hljs-number">0x0</span>]<br>……<br></code></pre></td></tr></table></figure><p>在 <code>main</code> 函数调用 <code>show_me_the_money</code> 的函数的时候，对应的代码是这样的：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">call</span>   <span class="hljs-number">400550</span> &lt;show_me_the_money<span class="hljs-symbol">@plt</span>&gt;<br></code></pre></td></tr></table></figure><p>这里后面有一个<code> @plt</code> 的关键字，代表了我们需要从<code> PLT</code>，也就是<strong>过程链接表</strong>（Procedure Link Table）里面找要调用的函数。对应的地址呢，则是 <code>400550</code> 这个地址。</p><p>那当我们把目光挪到上面的 400550 这个地址，你又会看到里面进行了一次跳转，这个跳转指定的跳转地址，你可以在后面的注释里面可以看到，GLOBAL_OFFSET_TABLE+0x18。这里的 GLOBAL_OFFSET_TABLE，就是我接下来要说的全局偏移表。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">400550</span>:       ff <span class="hljs-number">25</span> <span class="hljs-number">12</span> <span class="hljs-number">05</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span>       jmp    QWORD PTR<span class="hljs-meta"> [rip+0x200512]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt;</span><br></code></pre></td></tr></table></figure><p>在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张<strong>全局偏移表</strong>（GOT，Global Offset Table）。<strong>虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的</strong>。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。</p><p>虽然不同的程序调用的同样的动态库，各自的内存地址是独立的，调用的又都是同一个动态库，但是不需要去修改动态库里面的代码所使用的地址，而是各个程序各自维护好自己的 GOT，能够找到对应的动态库就好了。</p><h2 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h2><p>原码表示法，左侧第一位是符号位，符号位为 1 时表示负数，为 0 时表示正数。<br>补码表示法，我们不再把这一位当成单独的符号位，在剩下几位计算出的十进制前加上正负号，而是在计算整个二进制值的时候，在左侧最高位前面加个负号。</p><p>比如，一个 4 位的二进制补码数值 1011，转换成十进制，就是<br>$-1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1  + 1 \times 2^0 = -5$</p><p>一个 4 位的二进制数，可以表示从 -8 到 7 这 16 个整数，不会白白浪费一位。</p><p>字符集：表示的可以是字符的一个集合。比如说“第一版《新华字典》里面出现的所有汉字”，这是一个中文字符集。比如，我们日常说的<code> Unicode</code>，其实就是一个字符集，包含了 150 种语言的 14 万个不同的字符。</p><p>字符编码：对于字符集里的这些字符，怎么一一用二进制表示出来的一个字典。我们上面说的 <code>Unicode</code>，就可以用<code> UTF-8</code>、<code>UTF-16</code>，乃至 <code>UTF-32</code> 来进行编码，存储成二进制。</p><p>同样的文本，采用不同的编码存储下来。如果另外一个程序，用一种不同的编码方式来进行解码和展示，就会出现乱码。</p><h3 id="锟斤拷-烫烫烫"><a href="#锟斤拷-烫烫烫" class="headerlink" title="锟斤拷 烫烫烫"></a>锟斤拷 烫烫烫</h3><p>Unicode编码一直持续在收录各种字元，这就可能会出现各种作业系统支援的Unicode字元不一样。这也就会导致A上的一个用Unicode编码的字元，在B上就会出现无法显示的情况。为了避免这种情况，在Unicode中定义了一个特殊字元�，它的Unicode编码为0xFFFD。</p><p>假如A支援特殊字元⬆，但是B并不支援这个⬆，那么在B中将会用�来代替。</p><p>这个字元用UTF-8编码后，十六进位表示为<code>0xEF 0XBF 0XBD</code>。如果连续出现两个⬆符号，那么用UTF-8编码后的十六进位则表示为<code>0xEF 0XBF 0XBD 0xEF 0XBF 0XBD</code>，这时候再转码成GBK，因为GBK中用两个位元组表示一个字元，那么上述的字元就成了锟（<code>0xEFBF</code>），斤（<code>0xBDEF</code>），拷（<code>0xBFBD</code>）。出现锟斤拷的原因就是UTF-8转码GBK的过程中出现了问题。当然如果想要出现锟斤拷，则至少需要两个字元出现乱码。</p><p>而“烫烫烫”，则是因为如果你用了 Visual Studio 的调试器，默认使用 MBCS 字符集。“烫”在里面是由 <code>0xCCCC</code> 来表示的，而 <code>0xCC</code> 又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。</p><h2 id="理解电路"><a href="#理解电路" class="headerlink" title="理解电路"></a>理解电路</h2><p>从以上的学习可以知道，最终执行的程序都是二进制的指令。那为何计算机最终选择了二进制呢？接下来看看计算机在硬件层面究竟是怎么表示二进制的，以此你就会明白，为什么计算机会选择二进制。</p><h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><h2 id="乘法器"><a href="#乘法器" class="headerlink" title="乘法器"></a>乘法器</h2><h2 id="浮点数和定点数"><a href="#浮点数和定点数" class="headerlink" title="浮点数和定点数"></a>浮点数和定点数</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决OpenSSL SSL_read: Connection was reset, errno 10054</title>
    <link href="/2022/02/16/%E8%A7%A3%E5%86%B3OpenSSL-SSL-read-Connection-was-reset-errno-10054/"/>
    <url>/2022/02/16/%E8%A7%A3%E5%86%B3OpenSSL-SSL-read-Connection-was-reset-errno-10054/</url>
    
    <content type="html"><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法一：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">http</span>.sslVerify <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> https<span class="hljs-variable">.sslVerify</span> <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure><p>方法三：<br>这可能是因为版本库的大小和git的默认缓冲区大小，所以通过下述操作（在git bash上），git的缓冲区大小会增加。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//在仓库init后，添加以下配置</span><br>git <span class="hljs-keyword">config</span> http<span class="hljs-variable">.postBuffer</span> <span class="hljs-number">524288000</span><br><span class="hljs-comment">//如果仓库不是自己的，可以添加以下配置</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> http<span class="hljs-variable">.postBuffer</span> <span class="hljs-number">524288000</span><br></code></pre></td></tr></table></figure><p>方法四：<br>网速太慢，换个网速快的环境。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://stackoverflow.com/questions/46232906/git-clone-error-rpc-failed-curl-56-openssl-ssl-read-ssl-error-syscall-errno">windows - git clone error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 - Stack Overflow</a><br><a href="https://chowdera.com/2021/08/20210816115836695u.html">解决OpenSSL SSL_read: Connection was reset, errno 10054問題</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的变长数组与零长数组</title>
    <link href="/2022/02/11/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84/"/>
    <url>/2022/02/11/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%B6%E9%95%BF%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>想必很多学习C语言的人都会在书上看到，<strong>数组在初始化时必须要确定长度（维度）</strong>，也就是说定义数组时，维度一定要用常量。但是在编程中很多人肯定发现了，及时像下面这样写，编译器也不会报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> n;             <br><span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[n];    <br></code></pre></td></tr></table></figure><p>这是怎么回事？难道以前我学的是错的吗？当然不是。最官方的解释应该是 C 语言的规范和编译器的规范说明了。</p><ul><li>在 ISO/IEC9899 标准的 <a href="http://busybox.net/~landley/c99-draft.html#6.7.5.2">6.7.5.2 Array declarators</a> 中明确说明了数组的长度可以为变量的，称为变长数组（VLA，variable length array）。（注：这里的变长指的是数组的长度是在运行时才能决定，但一旦决定在数组的生命周期内就不会再变。）</li><li>在 GCC 标准规范的 <a href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">6.19 Arrays of Variable Length</a> 中指出，作为编译器扩展，GCC 在 C90 模式和 C++ 编译器下遵守 ISO C99 关于变长数组的规范。</li></ul><p>原来这种语法确实是 C 语言规范，GCC 非常完美的支持了 ISO C99。但是在 C99 之前的 C 语言中，变长数组的语法是不存在的。</p><p>这种变长数组有什么好处呢？它可以实现与<code>alloca</code>函数一样的效果，在栈上进行动态的空间分配，并且在函数返回时自动释放内存，无需手动释放。</p><blockquote><p><code>alloca</code> 函数用来在栈上分配空间，当函数返回时自动释放，无需手动再去释放；</p></blockquote><p>可变数组示例：<br>所有可变修改 (VM) 类型的声明必须在块范围或函数原型范围内。使用 <code>static</code> 或 <code>extern</code> 存储类说明符声明的数组对象不能具有可变长度数组 (VLA) 类型。但是，使用静态存储类说明符声明的对象可以具有 <code>VM</code> 类型（即，指向 <code>VLA</code> 类型的指针）。最后，使用 <code>VM</code> 类型声明的所有标识符都必须是普通标识符，因此<strong>不能是结构或联合的成员</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> A[n];                       <span class="hljs-comment">// Error - file scope VLA.</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">int</span> <span class="hljs-params">(*p2)</span>[n]</span>;            <span class="hljs-comment">// Error - file scope VM.</span><br><span class="hljs-keyword">int</span> B[<span class="hljs-number">100</span>];                     <span class="hljs-comment">// OK - file scope but not VM.</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fvla</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> C[m][m])</span>   <span class="hljs-comment">// OK - VLA with prototype scope.</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> VLA[m][m]   <span class="hljs-comment">// OK - block scope typedef VLA.</span><br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> &#123;</span><br>                <span class="hljs-keyword">int</span> (*y)[n];        <span class="hljs-comment">// Error - y not ordinary identifier.</span><br>                <span class="hljs-keyword">int</span> z[n];           <span class="hljs-comment">// Error - z not ordinary identifier.</span><br>        &#125;;<br>        <span class="hljs-keyword">int</span> D[m];                   <span class="hljs-comment">// OK - auto VLA.</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> E[m];            <span class="hljs-comment">// Error - static block scope VLA.</span><br>        <span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> F[m];            <span class="hljs-comment">// Error - F has linkage and is VLA.</span><br>        <span class="hljs-keyword">int</span> (*s)[m];                <span class="hljs-comment">// OK - auto pointer to VLA.</span><br>        <span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">int</span> <span class="hljs-params">(*r)</span>[m]</span>;         <span class="hljs-comment">// Error - r had linkage and is</span><br>                                    <span class="hljs-comment">// a pointer to VLA.</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">int</span> <span class="hljs-params">(*q)</span>[m] </span>= &amp;B;    <span class="hljs-comment">// OK - q is a static block</span><br>                                    <span class="hljs-comment">// pointer to VLA.</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="零长数组"><a href="#零长数组" class="headerlink" title="零长数组"></a>零长数组</h2><p>GNU/GCC 在标准的 C/C++ 基础上做了有实用性的扩展, 零长度数组（Arrays of Length Zero） 就是其中一个知名的扩展。使用零长数组，把它作为结构体的最后一个元素非常有用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> &#123;</span><br>    <span class="hljs-keyword">int</span> length;<br>    <span class="hljs-keyword">char</span> contents[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> *<span class="hljs-title">thisline</span> =</span> (struct line *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span> (struct line) + this_length);<br>thisline-&gt;length = this_length;<br></code></pre></td></tr></table></figure><p>从上例就可以看出，零长数组在有固定头部的可变对象上非常适用，我们可以根据对象的大小动态地去分配结构体的大小。</p><p>在 <code>Linux</code> 内核中也有这种应用，例如由于 <code>PID</code> 命名空间的存在，每个进程 <code>PID</code> 需要映射到所有能看到其的命名空间上，但该进程所在的命名空间在开始并不确定（但至少为 <code>init</code> 命名空间），需要在运行是根据 <code>level</code> 的值来确定，所以在该结构体后面增加了一个长度为 <code>1</code> 的数组（因为至少在一个<code>init</code>命名空间上），使得该结构体 <code>pid</code> 是个可变长的结构体，在运行时根据进程所处的命名空间的 <code>level</code> 来决定 <code>numbers</code> 分配多大。（注：虽然不是零长度的数组，但用法是一样的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">atomic_t</span> count;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> level;<br>    <span class="hljs-comment">/* lists of tasks that use this pid */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span> <span class="hljs-title">tasks</span>[<span class="hljs-title">PIDTYPE_MAX</span>];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">upid</span> <span class="hljs-title">numbers</span>[1];</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="什么0长度数组不占用存储空间"><a href="#什么0长度数组不占用存储空间" class="headerlink" title="什么0长度数组不占用存储空间"></a>什么0长度数组不占用存储空间</h3><p>0长度数组与指针实现有什么区别呢, 为什么0长度数组不占用存储空间呢?</p><p>其实本质上涉及到的是一个C语言里面的数组和指针的区别问题. char a[1]里面的a和char *b的b相同吗？</p><p>《 Programming Abstractions in C》（Roberts, E. S.，机械工业出版社，2004.6）82页里面说。</p><blockquote><p>“arr is defined to be identical to &amp;arr[0]”.</p></blockquote><p>也就是说，<code>char a[1]</code>里面的<code>a</code>实际是一个常量，等于<code>&amp;a[0]</code>。而<code>char *b</code>是有一个实实在在的指针变量<code>b</code>存在。 所以，<code>a=b</code>是不允许的，而<code>b=a</code>是允许的。 </p><p>本质上因为数组名它只是一个偏移量， 数组名这个符号本身代 表了一个不可修改的<strong>地址常量</strong> （注意：数组名永远都不会是指针！ ），但对于这个数组的大小，我们可以进行动态分配,对于编译器而言，数组名仅仅是一个符号，它不会占用任何空间，它在结构体中，只是代表了一个偏移量，代表一个不可修改的地址常量！</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.cnblogs.com/hazir/p/variable_length_array.html">alloca 函数用来在栈上分配空间，当函数返回时自动释放，无需手动再去释放</a></p><p><a href="https://blog.csdn.net/gatieme/article/details/64131322">C语言0长度数组(可变数组/柔性数组)详解_OSKernelLAB(gatieme)-CSDN博客_柔性数组</a></p><p><a href="https://blog.csdn.net/weixin_43083491/article/details/112632310">零长数组（柔性数组、可变数组）的使用_禾仔仔的博客-CSDN博客</a></p><p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Zero-Length.html#Zero-Length">Zero Length - Using the GNU Compiler Collection (GCC)</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH原理</title>
    <link href="/2022/01/27/SSH%E5%8E%9F%E7%90%86/"/>
    <url>/2022/01/27/SSH%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>QEMU源码分析-内存虚拟化</title>
    <link href="/2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <url>/2022/01/25/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1.大部分转载自<a href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a><br>2.原文源码为QEMU1.2.0，版本较旧，部分源码内容根据QEMU6.2版本修改<br>3.部分内容根据自己理解补充添加</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：</p><ul><li>虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间；</li><li>虚拟机里面的物理内存（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存；</li><li>物理机的虚拟内存（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间；</li><li>物理机的物理内存（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。</li></ul><p>内存虚拟化的关键在于维护 <code>GPA</code> 到 <code>HVA</code> 的映射关系。</p><h2 id="页面分配和映射的两种方式"><a href="#页面分配和映射的两种方式" class="headerlink" title="页面分配和映射的两种方式"></a>页面分配和映射的两种方式</h2><p>要搞清楚QEMU system emulation的仿真架构，首先对于Host OS，将QEMU作为进程启动，然后对于QEMU进程，会仿真各种硬件和运行Guest OS，在这层OS上运行要全系统模拟的应用程序，因此对于Guest OS管理的内存要实现到QEMU进程的虚拟空间的转换需要softMMU（即需要对GPA到HVA进行转换）。从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。</p><h3 id="影子页表Shadow-Page-Table，SPT"><a href="#影子页表Shadow-Page-Table，SPT" class="headerlink" title="影子页表Shadow Page Table，SPT"></a>影子页表Shadow Page Table，SPT</h3><p>第一种方式就是软件的方式，影子页表 （Shadow Page Table）。</p><p>KVM 通过维护记录GVA-&gt;HPA的影子页表 SPT，减少了地址转换带来的开销，可以直接将 GVA 转换为 HPA。</p><p>内存映射要通过页表来管理，页表地址应该放在 CR3 寄存器里面。在软件虚拟化的内存转换中，GVA 到 GPA 的转换通过查询 CR3 寄存器来完成，CR3 中保存了 Guest 的页表基地址，然后载入 MMU 中进行地址转换。</p><p>在加入了 SPT 技术后，当 Guest 访问 CR3 时，KVM 会捕获到这个操作EXIT_REASON_CR_ACCESS，之后 KVM 会载入特殊的 CR3 和影子页表，欺骗 Guest 这就是真实的 CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。</p><blockquote><p>本来的过程是，客户机要通过 cr3 找到客户机的页表，实现从 GVA 到 GPA 的转换，然后在宿主机上，要通过 cr3 找到宿主机的页表，实现从 HVA 到 HPA 的转换。<br>为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。<br>在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。</p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124192700.png"></p><p>为了快速检索Guest页表对应的影子页表，KVM为每个客户机维护了一个hash表来进行客户机页表到影子页表之间的映射。 对于每一个Guest来说，其页目录和页表都有唯一的GPA，通过页目录/页表的GPA就可以在哈希链表中快速地找到对应的影子页目录/页表。</p><p>当Guest切换进程时，Guest会把待切换进程的页表基址载入 CR3，而 KVM 将会截获这一特权指令。KVM在哈希表中找到与此页表基址对应的影子页表基址，载入Guest CR3，使Guest在恢复运行时 CR3 实际指向的是新切换进程对应的影子页表。</p><p>影子页表的引入，减少了GVA-&gt;HPA的转换开销，但是缺点在于需要为 Guest 的每个进程都维护一个影子页表，这将带来很大的内存开销。同时影子页表的建立是很耗时的，如果 Guest 的进程过多，将导致影子页表频繁切换。</p><p>因此 Intel 和 AMD 在此基础上提供了基于硬件的虚拟化技术EPT。</p><h3 id="扩展页表Extent-Page-Table，EPT"><a href="#扩展页表Extent-Page-Table，EPT" class="headerlink" title="扩展页表Extent Page Table，EPT"></a>扩展页表Extent Page Table，EPT</h3><p>Intel 的 EPT（Extent Page Table）技术和 AMD 的 NPT（Nest Page Table）技术都对内存虚拟化提供了硬件支持。 这两种技术原理类似，都是在硬件层面上实现GVA到HPA之间的转换。 下面就以 EPT 为例分析一下 KVM 基于硬件辅助的内存虚拟化实现。</p><p>EPT 在原有客户机页表对客户机虚拟地址 GVA 到客户机物理地址 GPA 映射的基础上，又引入了 EPT 页表来实现客户机物理地址 GPA 到宿主机物理地址 HPA 的另一次映射。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。</p><p>即EPT 技术采用了在两级页表结构，即原有Guest OS页表对 <strong>GVA-&gt;GPA</strong> 映射的基础上，又引入了 EPT 页表来实现 <strong>GPA-&gt;HPA</strong> 的另一次映射，这<strong>两次地址映射都是由硬件自动完成</strong>。</p><p>有了 EPT，在<strong>GPA-&gt;HPA</strong>转换的过程中，缺页会产生 EPT 缺页异常。 KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。</p><p>KVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。</p><p>这里，我们重点看第二种方式。因为使用了 EPT 之后，客户机里面的页表映射，也即从 GVA 到 GPA 的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而 EPT 重点帮我们解决的就是从 GPA 到 HPA 的转换问题。因为要经过两次页表，所以 EPT 又 tdp(two dimentional paging)。</p><p>EPT 的页表结构也是分为四层，EPT Pointer （EPTP）指向 PML4 的首地址。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124194059.png"></p><h2 id="QEMU-的主要工作"><a href="#QEMU-的主要工作" class="headerlink" title="QEMU 的主要工作"></a>QEMU 的主要工作</h2><p>内存虚拟化的目的就是让虚拟机能够无缝的访问内存。有了 Intel EPT 的支持后，CPU 在 VMX non-root状态时进行内存访问会再做一次 EPT 转换。在这个过程中，QEMU 会负责以下内容：</p><p>首先需要从自己的进程地址空间中申请内存用于 Guest<br>需要将上一步中申请到的内存的虚拟地址（HVA）和 Guest 的物理地址之间的映射关系传递给 KVM（kernel），即 GPA-&gt;HVA<br>需要组织一系列的数据结构来管理虚拟内存空间，并在内存拓扑结构更改时将最新的内存信息同步至 KVM 中</p><h2 id="QEMU-和-KVM-的工作分界"><a href="#QEMU-和-KVM-的工作分界" class="headerlink" title="QEMU 和 KVM 的工作分界"></a>QEMU 和 KVM 的工作分界</h2><p>QEMU 和 KVM 之间是通过 KVM 提供的ioctl()接口进行交互的。在内核的kvm_vm_ioctl()中，<strong>设置虚拟机内存</strong>的系统调用【kernel就是一系列系统调用函数接口和处理逻辑，其中有个处理”创建/设置虚拟机内存“的系统调用接口】为  <code>VM_SET_USER_MEMORY_REGION</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">kvm_vm_ioctl</span><span class="hljs-params">(struct file *filp,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ioctl, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">case</span> KVM_SET_USER_MEMORY_REGION: &#123; <span class="hljs-comment">// 在 KVM 中注册用户空间传入的内存信息</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">kvm_userspace_mem</span>;</span><br><br>        r = -EFAULT;<br>         <span class="hljs-comment">// 将传入的数据结构复制到内核空间</span><br>        <span class="hljs-keyword">if</span> (copy_from_user(&amp;kvm_userspace_mem, argp, <span class="hljs-keyword">sizeof</span> kvm_userspace_mem))<br>            <span class="hljs-keyword">goto</span> out;<br><br>         <span class="hljs-comment">// 实际进行处理的函数</span><br>        r = kvm_vm_ioctl_set_memory_region(kvm, &amp;kvm_userspace_mem, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (r)<br>            <span class="hljs-keyword">goto</span> out;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里需要传递的参数类型为 <code>kvm_userspace_memory_region</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* for KVM_SET_USER_MEMORY_REGION */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;            <span class="hljs-comment">// slot 编号 [参考：https://www.cnblogs.com/LoyenWang/p/11922887.html]</span><br>    __u32 flags;           <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    __u64 guest_phys_addr; <span class="hljs-comment">// Guest 物理地址，即 GPA</span><br>    __u64 memory_size;     <span class="hljs-comment">// 内存大小，单位 bytes</span><br>    __u64 userspace_addr;  <span class="hljs-comment">// 从 QEMU 进程地址空间中分配内存的起始地址，即 HVA</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>KVM_SET_USER_MEMORY_REGION</code>这个 <code>ioctl</code> 主要目的就是设置<code>GPA-&gt;HVA</code>的映射关系，KVM 会继续调用<code>kvm_vm_ioctl_set_memory_region()</code>，在内核空间维护并管理 Guest 的内存。</p><h2 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h2><h3 id="AddressSpace"><a href="#AddressSpace" class="headerlink" title="AddressSpace"></a>AddressSpace</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>QEMU 用 AddressSpace 结构体表示 Guest 中 CPU/设备看到的内存【也就是Guest OS可以在QEMU进程虚存中用到的所有内存，是 MemoryRegion 的集合，即 GPA 的整体】，类似于物理机中地址空间的概念，但在这里表示的是 Guest 的一段地址空间，如内存地址空间 <code>address_space_memory</code> 、<code>I/O</code> 地址空间<code>address_space_io</code>，它在 QEMU 源码<code>memory.c</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSpace</span> &#123;</span><br>    <span class="hljs-comment">/* private: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-keyword">char</span> *name;<br>    MemoryRegion *root;<br><br>    <span class="hljs-comment">/* Accessed via RCU.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatView</span> *<span class="hljs-title">current_map</span>;</span><br><br>    <span class="hljs-keyword">int</span> ioeventfd_nb;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionIoeventfd</span> *<span class="hljs-title">ioeventfds</span>;</span><br>    QTAILQ_HEAD(, MemoryListener) listeners;<br>    QTAILQ_ENTRY(AddressSpace) address_spaces_link;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个 AddressSpace 一般包含一系列的 MemoryRegion：<code>root</code>指针指向根级 MemoryRegion，而root可能有自己的若干个 sub-regions（子节点），于是形成树状结构。这些 MemoryRegion 通过树连接起来，树的根即为 AddressSpace 的root域。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>另外，QEMU 中有两个全局的静态 AddressSpace，在memory.c中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> AddressSpace address_space_memory; <span class="hljs-comment">// 内存地址空间</span><br><span class="hljs-keyword">static</span> AddressSpace address_space_io;     <span class="hljs-comment">// I/O 地址空间</span><br></code></pre></td></tr></table></figure><p>其 root 域分别指向之后会提到的两个 MemoryRegion 类型变量：system_memory、system_io。</p><h3 id="MemoryRegion"><a href="#MemoryRegion" class="headerlink" title="MemoryRegion"></a>MemoryRegion</h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>MemoryRegion</code> 表示在 <code>Guest Memory Layout</code> 中的一段内存区域【也就是单元级GPA的概念，Guest OS可以管理到的那些Guest 物理内存单元】，它是联系 <code>GPA</code> 和 <code>RAMBlocks</code>（描述真实内存）之间的桥梁，在<code>memory.h</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> &#123;</span><br>    <span class="hljs-comment">/* All fields are private - violators will be prosecuted */</span><br>    <span class="hljs-keyword">const</span> MemoryRegionOps *ops;      <span class="hljs-comment">// 回调函数集合</span><br>    <span class="hljs-keyword">void</span> *opaque;<br>    MemoryRegion *parent;            <span class="hljs-comment">// 父 MemoryRegion 指针</span><br>    Int128 size;                     <span class="hljs-comment">// 该区域内存的大小</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> addr;         <span class="hljs-comment">// 在 Address Space 中的地址，即 HVA</span><br>    <span class="hljs-keyword">void</span> (*destructor)(MemoryRegion *mr);<br>    <span class="hljs-keyword">ram_addr_t</span> ram_addr;             <span class="hljs-comment">// MemoryRegion 的起始地址，即 GPA</span><br>    <span class="hljs-keyword">bool</span> subpage;<br>    <span class="hljs-keyword">bool</span> terminates;<br>    <span class="hljs-keyword">bool</span> readable;<br>    <span class="hljs-keyword">bool</span> ram;                        <span class="hljs-comment">// 是否表示 RAM</span><br>    <span class="hljs-keyword">bool</span> readonly; <span class="hljs-comment">/* For RAM regions */</span><br>    <span class="hljs-keyword">bool</span> enabled;                    <span class="hljs-comment">// 是否已经通知 KVM 使用这段内存</span><br>    <span class="hljs-keyword">bool</span> rom_device;<br>    <span class="hljs-keyword">bool</span> warning_printed; <span class="hljs-comment">/* For reservations */</span><br>    MemoryRegion *alias;             <span class="hljs-comment">// 是否为 MemoryRegion alias</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> alias_offset; <span class="hljs-comment">// 若为 alias，在原 MemoryRegion 中的 offset</span><br>    <span class="hljs-keyword">unsigned</span> priority;<br>    <span class="hljs-keyword">bool</span> may_overlap;<br>    QTAILQ_HEAD(subregions, MemoryRegion) subregions; <span class="hljs-comment">// 子区域链表头</span><br>    QTAILQ_ENTRY(MemoryRegion) subregions_link;       <span class="hljs-comment">// 子区域链表节点</span><br>    QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;       <span class="hljs-comment">// MemoryRegion 的名字，调试时使用</span><br>    <span class="hljs-keyword">uint8_t</span> dirty_log_mask; <span class="hljs-comment">// 表示哪一种 dirty map 被使用，共分三种</span><br>    <span class="hljs-keyword">unsigned</span> ioeventfd_nb;<br>    MemoryRegionIoeventfd *ioeventfds;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><p>在 QEMU 的exec.c中也定义了两个静态的 MemoryRegion 指针变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> MemoryRegion *system_memory; <span class="hljs-comment">// 内存 MemoryRegion，对应 address_space_memory</span><br><span class="hljs-keyword">static</span> MemoryRegion *system_io;     <span class="hljs-comment">// I/O MemoryRegion，对应 address_space_io</span><br></code></pre></td></tr></table></figure><p>与两个全局 AddressSpace 对应，即 AddressSpace 的root域指向这两个 MemoryRegion。</p><h4 id="MemoryRegion-的类型"><a href="#MemoryRegion-的类型" class="headerlink" title="MemoryRegion 的类型"></a>MemoryRegion 的类型</h4><p>MemoryRegion 有多种类型，可以表示一段 RAM、ROM、MMIO、alias(别名)。</p><p>若为 alias 则表示一个 MemoryRegion 的部分区域，例如 ，QEMU 会为pc.ram这个表示 RAM 的 MemoryRegion 添加两个 alias：ram-below-4g和ram-above-4g，之后会看到具体的代码实例。</p><p>另外，MemoryRegion 也可以表示一个 container，这就表示它只是其他若干个 MemoryRegion 的容器。</p><p>那么要如何创建不同类型的 <code>MemoryRegion</code> 呢？</p><p>在 QEMU 中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将 MemoryRegion 划分为以下三种类型：</p><ul><li>根级 MemoryRegion：直接通过memory_region_init初始化，没有自己的内存，用于管理 subregion，例如system_memory：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    mr-&gt;ops = <span class="hljs-literal">NULL</span>;<br>    mr-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    mr-&gt;size = int128_make64(size);<br>    <span class="hljs-keyword">if</span> (size == UINT64_MAX) &#123;<br>        mr-&gt;size = int128_2_64();<br>    &#125;<br>    mr-&gt;addr = <span class="hljs-number">0</span>;<br>    mr-&gt;subpage = <span class="hljs-literal">false</span>;<br>    mr-&gt;enabled = <span class="hljs-literal">true</span>;<br>    mr-&gt;terminates = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 非实体 MemoryRegion，搜索时会继续前往其 subregions</span><br>    mr-&gt;ram = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 根级 MemoryRegion 不分配内存</span><br>    mr-&gt;readable = <span class="hljs-literal">true</span>;<br>    mr-&gt;readonly = <span class="hljs-literal">false</span>;<br>    mr-&gt;rom_device = <span class="hljs-literal">false</span>;<br>    mr-&gt;destructor = memory_region_destructor_none;<br>    mr-&gt;priority = <span class="hljs-number">0</span>;<br>    mr-&gt;may_overlap = <span class="hljs-literal">false</span>;<br>    mr-&gt;alias = <span class="hljs-literal">NULL</span>;<br>    QTAILQ_INIT(&amp;mr-&gt;subregions);<br>    <span class="hljs-built_in">memset</span>(&amp;mr-&gt;subregions_link, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> mr-&gt;subregions_link);<br>    QTAILQ_INIT(&amp;mr-&gt;coalesced);<br>    mr-&gt;name = g_strdup(name);<br>    mr-&gt;dirty_log_mask = <span class="hljs-number">0</span>;<br>    mr-&gt;ioeventfd_nb = <span class="hljs-number">0</span>;<br>    mr-&gt;ioeventfds = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>可以看到mr-&gt;addr被设置为 0，而mr-&gt;ram_addr则并没有初始化。</li></ul><ul><li>实体 <code>MemoryRegion</code>：通过<code>memory_region_init_ram()</code>初始化，有自己的内存（从 QEMU 进程地址空间中分配），大小为<code>size</code>，例如<code>ram_memory</code>、 <code>pci_memory</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram, *option_rom_mr;<br>    <span class="hljs-comment">/* ...*/</span><br><br>    <span class="hljs-comment">/* Allocate RAM.  We allocate it as a single memory region and use</span><br><span class="hljs-comment">     * aliases to address portions of it, mostly for backwards compatibility</span><br><span class="hljs-comment">     * with older qemus that used qemu_ram_alloc().</span><br><span class="hljs-comment">     */</span><br>    ram = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram));<br>    <span class="hljs-comment">// 调用 memory_region_init_ram 对 ram_memory 进行初始化</span><br>    memory_region_init_ram(ram, <span class="hljs-string">&quot;pc.ram&quot;</span>, below_4g_mem_size + above_4g_mem_size);<br>    vmstate_register_ram_global(ram);<br>    *ram_memory = ram;<br><br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size);<br>    mr-&gt;ram = <span class="hljs-literal">true</span>;<br>    mr-&gt;terminates = <span class="hljs-literal">true</span>;<br>    mr-&gt;destructor = memory_region_destructor_ram;<br>    mr-&gt;ram_addr = qemu_ram_alloc(size, mr);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里是先调用了<code>memory_region_init()</code>，之后设置 <code>RAM</code> 属性，并继续调用<code>qemu_ram_alloc()</code>分配内存。</p><ul><li>别名 <code>MemoryRegion</code>：通过<code>memory_region_init_alias()</code> 初始化，没有自己的内存，表示实体 <code>MemoryRegion</code> 的一部分。通过 <code>alias</code> 成员指向实体 <code>MemoryRegion</code>，<code>alias_offset</code>为在实体 <code>MemoryRegion</code> 中的偏移量，例如<code>ram_below_4g</code>、<code>ram_above_4g</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram_below_4g, *ram_above_4g;<br>    <span class="hljs-comment">/* ... */</span><br>    ram_below_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_below_4g));<br>    <span class="hljs-comment">// 调用 memory_region_init_alias 对 ram_below_4g 进行初始化</span><br>    memory_region_init_alias(ram_below_4g, <span class="hljs-string">&quot;ram-below-4g&quot;</span>, ram, <span class="hljs-number">0</span>, below_4g_mem_size);<br>    <span class="hljs-comment">/* ..</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_alias</span><span class="hljs-params">(MemoryRegion *mr,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,</span></span><br><span class="hljs-params"><span class="hljs-function">                              MemoryRegion *orig,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">target_phys_addr_t</span> offset,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size);<br>    mr-&gt;alias = orig; <span class="hljs-comment">// 指向实体 MemoryRegion</span><br>    mr-&gt;alias_offset = offset; <span class="hljs-comment">//通过offset得到实体的某一个部分</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RAMBlock"><a href="#RAMBlock" class="headerlink" title="RAMBlock"></a>RAMBlock</h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>MemoryRegion</code> 用来描述一段逻辑层面上的内存区域，而记录实际分配的内存地址信息的结构体则是 <code>RAMBlock</code>，在<code>ramblock.h</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RAMBlock</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> *<span class="hljs-title">mr</span>;</span><br>    <span class="hljs-keyword">uint8_t</span> *host;<br>    <span class="hljs-keyword">uint8_t</span> *colo_cache; <span class="hljs-comment">/* For colo, VM&#x27;s ram cache */</span><br>    <span class="hljs-keyword">ram_addr_t</span> offset;<br>    <span class="hljs-keyword">ram_addr_t</span> used_length;<br>    <span class="hljs-keyword">ram_addr_t</span> max_length;<br>    <span class="hljs-keyword">void</span> (*resized)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">uint64_t</span> length, <span class="hljs-keyword">void</span> *host);<br>    <span class="hljs-keyword">uint32_t</span> flags;<br>    <span class="hljs-comment">/* Protected by iothread lock.  */</span><br>    <span class="hljs-keyword">char</span> idstr[<span class="hljs-number">256</span>];<br>    <span class="hljs-comment">/* RCU-enabled, writes protected by the ramlist lock */</span><br>    QLIST_ENTRY(RAMBlock) next;<br>    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;<br>    <span class="hljs-keyword">int</span> fd;<br>    <span class="hljs-keyword">size_t</span> page_size;<br>    <span class="hljs-comment">/* dirty bitmap used during migration */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *bmap;<br>    <span class="hljs-comment">/* bitmap of already received pages in postcopy */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *receivedmap;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * bitmap to track already cleared dirty bitmap.  When the bit is</span><br><span class="hljs-comment">     * set, it means the corresponding memory chunk needs a log-clear.</span><br><span class="hljs-comment">     * Set this up to non-NULL to enable the capability to postpone</span><br><span class="hljs-comment">     * and split clearing of dirty bitmap on the remote node (e.g.,</span><br><span class="hljs-comment">     * KVM).  The bitmap will be set only when doing global sync.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> this bitmap is different comparing to the other bitmaps</span><br><span class="hljs-comment">     * in that one bit can represent multiple guest pages (which is</span><br><span class="hljs-comment">     * decided by the `clear_bmap_shift&#x27; variable below).  On</span><br><span class="hljs-comment">     * destination side, this should always be NULL, and the variable</span><br><span class="hljs-comment">     * `clear_bmap_shift&#x27; is meaningless.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *clear_bmap;<br>    <span class="hljs-keyword">uint8_t</span> clear_bmap_shift;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * RAM block length that corresponds to the used_length on the migration</span><br><span class="hljs-comment">     * source (after RAM block sizes were synchronized). Especially, after</span><br><span class="hljs-comment">     * starting to run the guest, used_length and postcopy_length can differ.</span><br><span class="hljs-comment">     * Used to register/unregister uffd handlers and as the size of the received</span><br><span class="hljs-comment">     * bitmap. Receiving any page beyond this length will bail out, as it</span><br><span class="hljs-comment">     * could not have been valid on the source.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">ram_addr_t</span> postcopy_length;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>可以看到在 <code>RAMBlock</code> 中host和offset域分别对应了 <code>HVA</code> 和<code> GPA</code>，因此也可以说 <code>RAMBlock</code> 中存储了<code>GPA-&gt;HVA</code>的映射关系，另外每一个 <code>RAMBlock</code> 都会指向其所属的 <code>MemoryRegion</code>。</p><h4 id="全局变量-ram-list"><a href="#全局变量-ram-list" class="headerlink" title="全局变量 ram_list"></a>全局变量 ram_list</h4><p>QEMU 在<code>ramlist.h</code>中定义了一个全局变量<code>ram_list</code>，以链表的形式维护了所有的 <code>RAMBlock</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RAMList</span> &#123;</span><br>    QemuMutex mutex;<br>    RAMBlock *mru_block;<br>    <span class="hljs-comment">/* RCU-enabled, writes protected by the ramlist lock. */</span><br>    QLIST_HEAD(, RAMBlock) blocks;<br>    DirtyMemoryBlocks *dirty_memory[DIRTY_MEMORY_NUM];<br>    <span class="hljs-keyword">uint32_t</span> version;<br>    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;<br>&#125; RAMList;<br><span class="hljs-keyword">extern</span> RAMList ram_list;<br></code></pre></td></tr></table></figure><p>每一个新分配的 <code>RAMBlock</code> 都会被插入到<code>ram_list</code>的头部。如需查找地址所对应的 <code>RAMBlock</code>，则需要遍历<code>ram_list</code>，当目标地址落在当前<code>RAMBlock</code>的地址区间时，该 <code>RAMBlock</code> 即为查找目标。</p><h4 id="AS、MR、RAMBlock-之间的关系"><a href="#AS、MR、RAMBlock-之间的关系" class="headerlink" title="AS、MR、RAMBlock 之间的关系"></a>AS、MR、RAMBlock 之间的关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225155936.png"></p><h3 id="FlatView"><a href="#FlatView" class="headerlink" title="FlatView"></a>FlatView</h3><p>AddressSpace 的root域及其子树共同构成了 Guest 的物理地址空间，但这些都是在 QEMU 侧定义的。要传入 KVM 进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其<strong>转换为一个“平坦”的地址模</strong>型，也就是一个从零开始、只包含地址信息的数据结构，这在 QEMU 中通过 <strong>FlatView</strong> 来表示。每个 AddressSpace 都有一个与之对应的 FlatView 指针current_map，表示其对应的平面展开视图。</p><h4 id="结构体定义-3"><a href="#结构体定义-3" class="headerlink" title="结构体定义"></a>结构体定义</h4><p><code>FlatView</code> 在<code>memory.c</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* Flattened global view of current active memory hierarchy.  Kept in sorted</span><br><span class="hljs-comment"> * order.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatView</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-keyword">unsigned</span> ref;<br>    FlatRange *ranges;      <span class="hljs-comment">// 对应的 FlatRange 数组</span><br>    <span class="hljs-keyword">unsigned</span> nr;            <span class="hljs-comment">// FlatRange 的数目</span><br>    <span class="hljs-keyword">unsigned</span> nr_allocated;  <span class="hljs-comment">// 当前数组的项数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddressSpaceDispatch</span> *<span class="hljs-title">dispatch</span>;</span><br>    MemoryRegion *root;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，<code>ranges</code>是一个数组，记录了 <code>FlatView</code> 下所有的 <code>FlatRange</code>。</p><h4 id="FlatRange"><a href="#FlatRange" class="headerlink" title="FlatRange"></a>FlatRange</h4><p>在 <code>FlatView</code> 中，<code>FlatRange</code> 表示在 <code>FlatView</code> 中的一段内存范围，同样在<code>memory.c</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Range of memory in the global map.  Addresses are absolute. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlatRange</span> &#123;</span><br>    MemoryRegion *mr;           <span class="hljs-comment">// 指向所属的 MemoryRegion</span><br>    hwaddr offset_in_region;    <span class="hljs-comment">// 在全局 MemoryRegion 中的 offset，对应 GPA</span><br>    AddrRange addr;             <span class="hljs-comment">// 代表的地址区间，对应 HVA</span><br>    <span class="hljs-keyword">uint8_t</span> dirty_log_mask;<br>    <span class="hljs-keyword">bool</span> romd_mode;<br>    <span class="hljs-keyword">bool</span> readonly;<br>    <span class="hljs-keyword">bool</span> nonvolatile;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个 <code>FlatRange</code> 对应一段虚拟机物理地址区间，各个 <code>FlatRange</code> 不会重叠，<strong>按照地址的顺序保存在数组中</strong>，具体的地址范围由一个 <code>AddrRange</code> 结构来描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * AddrRange 用于表示 FlatRange 的起始地址及大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddrRange</span> &#123;</span><br>    Int128 start;<br>    Int128 size;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="MemoryRegionSection"><a href="#MemoryRegionSection" class="headerlink" title="MemoryRegionSection"></a>MemoryRegionSection</h3><h4 id="结构体定义-4"><a href="#结构体定义-4" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>在 <code>QEMU</code> 中，还有几个起到中介作用的结构体，<code>MemoryRegionSection</code> 就是其中之一。</p><p>之前介绍的 <code>FlatRange</code> 代表一个物理地址空间的片段，偏向于描述在 <code>Host</code> 侧即 <strong>AddressSpace 中的分布【Guest的物理空间】</strong>，而 <code>MemoryRegionSection</code> 则代表在 <code>Guest</code> 侧即 <strong>MemoryRegion 中的片段</strong>。<code>MemoryRegionSection</code> 在<code>memory.h</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MemoryRegionSection: describes a fragment of a #MemoryRegion</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @mr: the region, or %NULL if empty</span><br><span class="hljs-comment"> * @address_space: the address space the region is mapped in</span><br><span class="hljs-comment"> * @offset_within_region: the beginning of the section, relative to @mr&#x27;s start</span><br><span class="hljs-comment"> * @size: the size of the section; will not exceed @mr&#x27;s boundaries</span><br><span class="hljs-comment"> * @offset_within_address_space: the address of the first byte of the section</span><br><span class="hljs-comment"> *     relative to the region&#x27;s address space</span><br><span class="hljs-comment"> * @readonly: writes to this section are ignored</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//只是起到描述的作用，描述了是哪个AddressSpace的MemoryRegion，</span><br> <span class="hljs-comment">//并且在MemoryRegion中的offset，和在AddressSpace展开为平坦内存的offset</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionSection</span> &#123;</span>  <br>    MemoryRegion *mr;                               <span class="hljs-comment">// 所属的 MemoryRegion</span><br>    MemoryRegion *address_space;                    <span class="hljs-comment">// 关联的 AddressSpace</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> offset_within_region;        <span class="hljs-comment">// 在 MemoryRegion 内部的 offset</span><br>    <span class="hljs-keyword">uint64_t</span> size;                                  <span class="hljs-comment">// Section 的大小</span><br>    <span class="hljs-keyword">target_phys_addr_t</span> offset_within_address_space; <span class="hljs-comment">// 在 AddressSpace 内部的 offset</span><br>    <span class="hljs-keyword">bool</span> readonly;                                  <span class="hljs-comment">// 是否为只读</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>offset_within_region</code>：在所属 <code>MemoryRegion</code> 中的<code> offset</code>。一个<code>AddressSpace</code> 可能由多个 <code>MemoryRegion</code> 组成，因此该 <code>offset</code> 是局部的</li><li><code>offset_within_address_space</code>：在所属 <code>AddressSpace</code> 中的 <code>offset</code>，它是全局的</li></ul><h4 id="和其他数据结构之间的关系"><a href="#和其他数据结构之间的关系" class="headerlink" title="和其他数据结构之间的关系"></a>和其他数据结构之间的关系</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125110422.png"></p><ul><li><code>AddressSpace</code> 的<code>root</code>指向对应的根级<code>MemoryRegion</code>，<code>current_map</code>指向<code>AddressSpace</code> 的<code>root</code>通过<code>generate_memory_topology()</code>生成的 <code>FlatView</code></li><li><code>FlatView</code> 中的<code>ranges</code>数组表示该<code> MemoryRegion</code> 所表示的<code>Guest</code>地址区间【GPA的整个平坦物理空间】，并按照地址的顺序进行排列</li><li><code>MemoryRegionSection</code> 由<code>ranges</code>数组中的 <code>FlatRange</code> 对应生成，作为注册到 <code>KVM </code>中的基本单位</li></ul><hr><p><code>QEMU</code> 在用户空间申请内存后，需要将内存信息通过一系列系统调用传入内核空间的 <code>KVM</code>，由 <code>KVM</code> 侧进行管理，因此 <code>QEMU</code> 侧也定义了一些用于向 <code>KVM</code> 传递参数的结构体。</p><p>以下为<code>KVM</code>相关的数据结构。</p><h3 id="KVMSlot"><a href="#KVMSlot" class="headerlink" title="KVMSlot"></a>KVMSlot</h3><p><code>在kvm_init.h</code>中定义，是 <code>KVM</code> 中内存管理的基本单位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KVMSlot</span></span><br><span class="hljs-class">&#123;</span><br>    hwaddr start_addr; <span class="hljs-comment">// Guest 物理地址，GPA</span><br>    <span class="hljs-keyword">ram_addr_t</span> memory_size;        <span class="hljs-comment">// 内存大小</span><br>    <span class="hljs-keyword">void</span> *ram; <span class="hljs-comment">// QEMU 用户空间地址，HVA</span><br>    <span class="hljs-keyword">int</span> slot;  <span class="hljs-comment">// Slot 编号</span><br>    <span class="hljs-keyword">int</span> flags; <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    <span class="hljs-comment">/* Dirty bitmap cache for the slot */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *dirty_bmap;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> dirty_bmap_size;<br>    <span class="hljs-comment">/* Cache of the address space ID */</span><br>    <span class="hljs-keyword">int</span> as_id;<br>    <span class="hljs-comment">/* Cache of the offset in ram address space */</span><br>    <span class="hljs-keyword">ram_addr_t</span> ram_start_offset;<br>&#125; KVMSlot;<br></code></pre></td></tr></table></figure><p><code>KVMSlot</code> 类似于内存插槽的概念。</p><h3 id="kvm-userspace-memory-region"><a href="#kvm-userspace-memory-region" class="headerlink" title="kvm_userspace_memory_region"></a>kvm_userspace_memory_region</h3><p>调用<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>时需要向 <code>KVM</code> 传递的参数，在<code>kvm.h</code>中定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* for KVM_SET_USER_MEMORY_REGION */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;            <span class="hljs-comment">// slot 编号</span><br>    __u32 flags;           <span class="hljs-comment">// 标志位，例如是否追踪脏页、是否可用等</span><br>    __u64 guest_phys_addr; <span class="hljs-comment">// Guest 物理地址，GPA</span><br>    __u64 memory_size;     <span class="hljs-comment">// 内存大小，bytes</span><br>    __u64 userspace_addr;  <span class="hljs-comment">// 从 QEMU 进程空间分配的起始地址，HVA</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="MemoryListener"><a href="#MemoryListener" class="headerlink" title="MemoryListener"></a>MemoryListener</h3><h4 id="结构体定义-5"><a href="#结构体定义-5" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>为了监控虚拟机的物理地址访问，对于每一个 <code>AddressSpace</code>，都会有一个 <code>MemoryListener</code> 与之对应。每当物理映射<code>GPA-&gt;HVA</code>发生改变时，就会回调这些函数。<strong>MemoryListener</strong> 是对一些事件的<strong>回调函数合集</strong>，在<code>memory.h</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MemoryListener: callbacks structure for updates to the physical memory map</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Allows a component to adjust to changes in the guest-visible memory map.</span><br><span class="hljs-comment"> * Use with memory_listener_register() and memory_listener_unregister().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryListener</span> &#123;</span><br>    <span class="hljs-keyword">void</span> (*begin)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*commit)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*region_add)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*region_del)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*region_nop)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_start)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_stop)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_sync)(MemoryListener *listener, MemoryRegionSection *section);<br>    <span class="hljs-keyword">void</span> (*log_global_start)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*log_global_stop)(MemoryListener *listener);<br>    <span class="hljs-keyword">void</span> (*eventfd_add)(MemoryListener *listener, MemoryRegionSection *section,<br>                        <span class="hljs-keyword">bool</span> match_data, <span class="hljs-keyword">uint64_t</span> data, EventNotifier *e);<br>    <span class="hljs-keyword">void</span> (*eventfd_del)(MemoryListener *listener, MemoryRegionSection *section,<br>                        <span class="hljs-keyword">bool</span> match_data, <span class="hljs-keyword">uint64_t</span> data, EventNotifier *e);<br>    <span class="hljs-comment">/* Lower = earlier (during add), later (during del) */</span><br>    <span class="hljs-keyword">unsigned</span> priority;<br>    MemoryRegion *address_space_filter;<br>    QTAILQ_ENTRY(MemoryListener) link;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="全局变量-memory-listeners"><a href="#全局变量-memory-listeners" class="headerlink" title="全局变量 memory_listeners"></a>全局变量 memory_listeners</h4><p>所有的 <code>MemoryListener</code> 都会挂在全局变量<code>memory_listeners</code>链表上，在<code>memory.c</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">QTAILQ_HEAD</span><span class="hljs-params">(, MemoryListener)</span> memory_listeners</span><br><span class="hljs-function">    </span>= QTAILQ_HEAD_INITIALIZER(memory_listeners);<br></code></pre></td></tr></table></figure><p>在<code>memory.c</code>中枚举了<code> ListenerDirection</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ListenerDirection</span> &#123;</span> Forward, Reverse &#125;;<br></code></pre></td></tr></table></figure><h3 id="重要数据结构总览"><a href="#重要数据结构总览" class="headerlink" title="重要数据结构总览"></a>重要数据结构总览</h3><table><thead><tr><th align="center">结构体名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">AddressSpace</td><td align="left">VM 能看到的一段地址空间，偏向 Host 侧【注意指的是偏向】</td></tr><tr><td align="center">MemoryRegion</td><td align="left">地址空间中一段逻辑层面的内存区域，偏向 Guest 侧</td></tr><tr><td align="center">RAMBlock</td><td align="left">记录实际分配的内存地址信息，存储了GPA-&gt;HVA的映射关系</td></tr><tr><td align="center">FlatView</td><td align="left">MemoryRegion 对应的平面展开视图，包含一个 FlatRange 类型的 ranges 数组</td></tr><tr><td align="center">FlatRange</td><td align="left">对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中</td></tr><tr><td align="center">MemoryRegionSection</td><td align="left">表示 MemoryRegion 中的片段</td></tr><tr><td align="center">MemoryListener</td><td align="left">回调函数集合</td></tr><tr><td align="center">KVMSlot</td><td align="left">KVM 中内存管理的基本单位，表示一个内存插槽</td></tr><tr><td align="center">kvm_userspace_memory_region</td><td align="left">调用ioctl(KVM_SET_USER_MEMORY_REGION)时需要向 KVM 传递的参数</td></tr></tbody></table><h2 id="具体实现机制"><a href="#具体实现机制" class="headerlink" title="具体实现机制"></a>具体实现机制</h2><p>QEMU 的内存申请流程大致可分为三个部分：回调函数的注册、AddressSpace 的初始化、实际内存的分配。下面将根据在vl.c的main()函数中的调用顺序分别介绍。</p><h3 id="回调函数的注册"><a href="#回调函数的注册" class="headerlink" title="回调函数的注册"></a>回调函数的注册</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125133808.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">configure_accelerator</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       └─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">()</span>                                     <span class="hljs-comment">// 初始化 KVM</span></span><br><span class="hljs-function">            ├─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_ioctl</span><span class="hljs-params">(KVM_CREATE_VM)</span>                  <span class="hljs-comment">// 创建 VM</span></span><br><span class="hljs-function">            ├─ <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_arch_init</span><span class="hljs-params">()</span>                           <span class="hljs-comment">// 针对不同的架构进行初始化</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">()</span>               <span class="hljs-comment">// 注册 kvm_memory_listener</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">()</span> <span class="hljs-comment">// 调用 region_add 回调</span></span><br><span class="hljs-function">                      └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span>        <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">                           └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">                                └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                     └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br></code></pre></td></tr></table></figure><p>进入<code>configure_accelerator()</code>后，<code>QEMU </code>会先调用<code>configure_accelerator()</code>设置 <code>KVM</code> 的加速支持，之后进入<code>kvm_init()</code>。该函数主要完成对 KVM 的初始化，包括一些常规检查如 <code>CPU</code> 个数、<code>KVM</code> 版本等，之后通过<code>kvm_ioctl(KVM_CREATE_VM)</code>与内核交互，创建 <code>KVM</code> 虚拟机。在<code>kvm_init()</code>的最后，会调用<code>memory_listener_register()</code>注册<code>kvm_memory_listener</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">(MachineState *ms)</span></span><br><span class="hljs-function"></span>&#123;<br>    MachineClass *mc = MACHINE_GET_CLASS(ms);<br>    <span class="hljs-comment">// 打开/dev/kvm</span><br>    s-&gt;fd = qemu_open_old(<span class="hljs-string">&quot;/dev/kvm&quot;</span>, O_RDWR);<br>    <span class="hljs-comment">// 创建VM</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        ret = kvm_ioctl(s, KVM_CREATE_VM, type);<br>    &#125; <span class="hljs-keyword">while</span> (ret == -EINTR);<br><span class="hljs-comment">/* ... */</span><br>    ret = kvm_arch_init(s); <span class="hljs-comment">// 针对不同的架构进行初始化</span><br><br>    <span class="hljs-comment">// 对于以下 AddressSpace，设置其对应的 listener</span><br>    kvm_memory_listener_register(s, &amp;s-&gt;memory_listener,<br>                                 &amp;address_space_memory, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;kvm-memory&quot;</span>);<br>    memory_listener_register(&amp;kvm_coalesced_pio_listener,<br>                             &amp;address_space_io);<br><span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">(MemoryListener *listener, AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryListener *other = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* Only one of them can be defined for a listener */</span><br>    assert(!(listener-&gt;log_sync &amp;&amp; listener-&gt;log_sync_global));<br><br>    listener-&gt;address_space = as;<br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;memory_listeners)<br>        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;memory_listeners)-&gt;priority) &#123;<br>        QTAILQ_INSERT_TAIL(&amp;memory_listeners, listener, link);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        QTAILQ_FOREACH(other, &amp;memory_listeners, link) &#123;<br>            <span class="hljs-keyword">if</span> (listener-&gt;priority &lt; other-&gt;priority) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        QTAILQ_INSERT_BEFORE(other, listener, link);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;as-&gt;listeners)<br>        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;as-&gt;listeners)-&gt;priority) &#123;<br>        QTAILQ_INSERT_TAIL(&amp;as-&gt;listeners, listener, link_as);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        QTAILQ_FOREACH(other, &amp;as-&gt;listeners, link_as) &#123;<br>            <span class="hljs-keyword">if</span> (listener-&gt;priority &lt; other-&gt;priority) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        QTAILQ_INSERT_BEFORE(other, listener, link_as);<br>    &#125;<br><br>    listener_add_address_space(listener, as);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后的<code>listener_add_address_space()</code>主要是将listener注册到其对应的 <code>AddressSpace</code> 上，并根据 <code>AddressSpace</code> 对应的 <code>FlatRange</code> 数组，生成 <code>MemoryRegionSection</code>【<code>MemoryRegionSection</code>就像是为<code>FlatRange</code>数组设置的一种中介表示，便于传入<code>KVM</code>，因为传入<code>KVM</code>应该是对平坦内存的一种表示】，并注册到 <code>KVM</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">(MemoryListener *listener,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    FlatView *view;<br>    FlatRange *fr;<br><br>    <span class="hljs-keyword">if</span> (listener-&gt;begin) &#123;<br>        listener-&gt;begin(listener);<br>    &#125;<br>    <span class="hljs-comment">/* 开启内存脏页记录 */</span><br>    <span class="hljs-keyword">if</span> (global_dirty_tracking) &#123;<br>        <span class="hljs-keyword">if</span> (listener-&gt;log_global_start) &#123;<br>            listener-&gt;log_global_start(listener);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 遍历 AddressSpace 对应的 FlatRange 数组，并将其转换成 MemoryRegionSection */</span><br>    view = address_space_get_flatview(as);<br>    FOR_EACH_FLAT_RANGE(fr, view) &#123;<br>        MemoryRegionSection section = section_from_flat_range(fr, view);<br>        <span class="hljs-comment">/* 将 section 所代表的内存区域注册到 KVM 中 */</span><br>        <span class="hljs-keyword">if</span> (listener-&gt;region_add) &#123;<br>            listener-&gt;region_add(listener, &amp;section);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fr-&gt;dirty_log_mask &amp;&amp; listener-&gt;log_start) &#123;<br>            listener-&gt;log_start(listener, &amp;section, <span class="hljs-number">0</span>, fr-&gt;dirty_log_mask);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (listener-&gt;commit) &#123;<br>        listener-&gt;commit(listener);<br>    &#125;<br>    flatview_unref(view);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于此时 <code>AddressSapce</code> 尚未初始化，所以此处的循环为空，仅是在全局注册了<code>kvm_memory_listener</code>。最后调用了<code>kvm_memory_listener-&gt;region_add()</code>，对应的实现是<code>kvm_region_add()</code>，该函数最终会通过<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>，将 <code>QEMU</code> 侧申请的内存信息传入 <code>KVM</code> 进行注册，这里的流程会在下一部分进行分析。</p><h3 id="AddressSpace-的初始化"><a href="#AddressSpace-的初始化" class="headerlink" title="AddressSpace 的初始化"></a>AddressSpace 的初始化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125154841.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">void</span> <span class="hljs-title">cpu_exec_init_all</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       ├─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_map_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 初始化 system_memory/io 这两个全局 MemoryRegion</span></span><br><span class="hljs-function">       |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">set_system_memory_map</span><span class="hljs-params">()</span> <span class="hljs-comment">// address_space_memory-&gt;root = system_memory</span></span><br><span class="hljs-function">       |    |    └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_update_topology</span><span class="hljs-params">()</span>        <span class="hljs-comment">// 为 MemoryRegion 生成 FlatView</span></span><br><span class="hljs-function">       |    |         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">()</span>   <span class="hljs-comment">// as-&gt;current_map = new_view</span></span><br><span class="hljs-function">       |    |              └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    |                   └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span>        <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">       |    |                        └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">       |    |                             └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |    |                                  └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br><span class="hljs-function">       |    |</span><br><span class="hljs-function">       |    └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_listener_register</span><span class="hljs-params">()</span> <span class="hljs-comment">// 注册对应的 MemoryListener</span></span><br><span class="hljs-function">       |         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listener_add_address_space</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       |</span><br><span class="hljs-function">       └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io_mem_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_io</span><span class="hljs-params">()</span> <span class="hljs-comment">// ram/rom/unassigned/notdirty/subpage-ram/watch</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>第一部分在全局注册了<code>kvm_memory_listener</code>，但由于<code> AddressSpace</code> 尚未初始化，实际上并未向 <code>KVM</code> 中注册任何实际的内存信息。<code>QEMU</code> 在<code>main()</code>函数中会继续调用<code>cpu_exec_init_all()</code>对<code>AddressSpace</code>进行初始化，该函数实际上是对两个 <code>init</code> 函数的封装调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cpu_exec_init_all</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    qemu_mutex_init(&amp;ram_list.mutex);<br>    <span class="hljs-comment">/* The data structures we set up here depend on knowing the page size,</span><br><span class="hljs-comment">     * so no more changes can be made after this point.</span><br><span class="hljs-comment">     * In an ideal world, nothing we did before we had finished the</span><br><span class="hljs-comment">     * machine setup would care about the target page size, and we could</span><br><span class="hljs-comment">     * do this much later, rather than requiring board models to state</span><br><span class="hljs-comment">     * up front what their requirements are.</span><br><span class="hljs-comment">     */</span><br>    finalize_target_page_bits();<br>    io_mem_init();      <span class="hljs-comment">// 初始化六个I/O MemoryRegion</span><br>    memory_map_init(); <span class="hljs-comment">// 初始化两个全局 AddressSpace，以及对应的 MemoryRegion、FlatView</span><br>    qemu_mutex_init(&amp;map_client_list_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>先来看<code>memory_map_init()</code>，主要用来初始化两个全局的系统地址空间<code>system_memory</code>、<code>system_io</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_map_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    system_memory = g_malloc(<span class="hljs-keyword">sizeof</span>(*system_memory));<br>    <span class="hljs-comment">// 1. 初始化 system_memory</span><br>    memory_region_init(system_memory, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;system&quot;</span>, UINT64_MAX);<br>    <span class="hljs-comment">// 2. 设置 address_space_memory 关联 system_memory</span><br>    <span class="hljs-comment">// 这两个都是全局变量，也就是把内存地址空间和IO地址空间于对应的MemoryRegion联系起来 </span><br>    <span class="hljs-comment">//及其对应的 FlatView</span><br>    address_space_init(&amp;address_space_memory, system_memory, <span class="hljs-string">&quot;memory&quot;</span>);<br><br>    system_io = g_malloc(<span class="hljs-keyword">sizeof</span>(*system_io));<br>    <span class="hljs-comment">// 1. 初始化 system_io  </span><br>    memory_region_init_io(system_io, <span class="hljs-literal">NULL</span>, &amp;unassigned_io_ops, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;io&quot;</span>,<br>                          <span class="hljs-number">65536</span>);<br>    <span class="hljs-comment">// 2. 设置 address_space_io 关联 system_io </span><br>    <span class="hljs-comment">// 及其对应的 FlatView</span><br>    address_space_init(&amp;address_space_io, system_io, <span class="hljs-string">&quot;I/O&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里比较重要的是<code>address_space_init()</code>，先设置 <code>AddressSpace</code> 对应的 <code>MemoryRegion</code>，之后根据<code>system_memory</code>更新<code>address_space_memory</code>对应的 <code>FlatView</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">address_space_init</span><span class="hljs-params">(AddressSpace *as, MemoryRegion *root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_ref(root);<br>    <span class="hljs-comment">// 将 address_space_memory 的 root 域指向 system_memory</span><br>    as-&gt;root = root;        <br>    as-&gt;current_map = <span class="hljs-literal">NULL</span>;<br>    as-&gt;ioeventfd_nb = <span class="hljs-number">0</span>;<br>    as-&gt;ioeventfds = <span class="hljs-literal">NULL</span>;<br>    QTAILQ_INIT(&amp;as-&gt;listeners);<br>    QTAILQ_INSERT_TAIL(&amp;address_spaces, as, address_spaces_link);<br>    as-&gt;name = g_strdup(name ? name : <span class="hljs-string">&quot;anonymous&quot;</span>);<br>    <span class="hljs-comment">// 根据 system_memory 更新 address_space_memory 对应的 FlatView</span><br>    address_space_update_topology(as);  <br>    address_space_update_ioeventfds(as);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>address_space_update_topology()</code>会继续调用<code>generate_memory_topology()</code>生成 <code>AddressSpace</code> 对应的 <code>FlatView </code>视图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">(AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);<br><br>    flatviews_init();<br>    <span class="hljs-keyword">if</span> (!g_hash_table_lookup(flat_views, physmr)) &#123;<br>        generate_memory_topology(physmr);<br>    &#125;<br>    address_space_set_flatview(as);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>address_space_update_topology()</code>会先调用<code>generate_memory_topology()</code>生成<code>system_memory</code>更新后的视图<code>new_view</code>，再将<code>address_space_memory</code>的<code>current_map</code>指向这个<code>new_view</code>，最后销毁<code>old_view</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_set_flatview</span><span class="hljs-params">(AddressSpace *as)</span></span><br><span class="hljs-function"></span>&#123;<br>    FlatView *old_view = address_space_to_flatview(as);<br>    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);<br>    FlatView *new_view = g_hash_table_lookup(flat_views, physmr);<br><br>    assert(new_view);<br><br>    <span class="hljs-keyword">if</span> (old_view == new_view) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_ref(old_view);<br>    &#125;<br><br>    flatview_ref(new_view);<br><br>    <span class="hljs-keyword">if</span> (!QTAILQ_EMPTY(&amp;as-&gt;listeners)) &#123;<br>        FlatView tmpview = &#123; .nr = <span class="hljs-number">0</span> &#125;, *old_view2 = old_view;<br><br>        <span class="hljs-keyword">if</span> (!old_view2) &#123;<br>            old_view2 = &amp;tmpview;<br>        &#125;<br>        address_space_update_topology_pass(as, old_view2, new_view, <span class="hljs-literal">false</span>);<br>        address_space_update_topology_pass(as, old_view2, new_view, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Writes are protected by the BQL.  */</span><br>    qatomic_rcu_set(&amp;as-&gt;current_map, new_view);<br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_unref(old_view);<br>    &#125;<br><br>    <span class="hljs-comment">/* Note that all the old MemoryRegions are still alive up to this</span><br><span class="hljs-comment">     * point.  This relieves most MemoryListeners from the need to</span><br><span class="hljs-comment">     * ref/unref the MemoryRegions they get---unless they use them</span><br><span class="hljs-comment">     * outside the iothread mutex, in which case precise reference</span><br><span class="hljs-comment">     * counting is necessary.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (old_view) &#123;<br>        flatview_unref(old_view);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>address_space_update_topology_pass()</code>的最后，会调用<code>MEMORY_LISTENER_UPDATE_REGION</code>这个宏，触发<code>region_add</code>对应的回调函数<code>kvm_region_add()</code>。</p><p>这个宏在<code>memory.c</code>中定义，会将 <code>FlatView</code> 中的 <code>FlatRange</code> 转换为 <code>MemoryRegionSection</code>，作为入参传递给<code>kvm_region_add()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* No need to ref/unref .mr, the FlatRange keeps it alive.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...)  \</span><br><span class="hljs-meta">    do &#123;                                                                \</span><br><span class="hljs-meta">        MemoryRegionSection mrs = section_from_flat_range(fr,           \</span><br><span class="hljs-meta">                address_space_to_flatview(as));                         \</span><br><span class="hljs-meta">        MEMORY_LISTENER_CALL(as, callback, dir, &amp;mrs, ##_args);         \</span><br><span class="hljs-meta">    &#125; while(0)</span><br></code></pre></td></tr></table></figure><p>而<code>kvm_region_add()</code>实际上是对<code>kvm_set_phys_mem()</code>的封装调用。该函数比较复杂，会根据传入的<code>section</code>填充 KVMSlot，再传递给<code>kvm_set_user_memory_region()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">(KVMMemoryListener *kml, KVMSlot *slot, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">new</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    KVMState *s = kvm_state;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">mem</span>;</span><br>    <span class="hljs-keyword">int</span> ret;<br><br>    <span class="hljs-comment">// 根据 KVMSlot 填充 kvm_userspace_memory_region</span><br>    mem.slot = slot-&gt;slot | (kml-&gt;as_id &lt;&lt; <span class="hljs-number">16</span>);<br>    mem.guest_phys_addr = slot-&gt;start_addr;<br>    mem.userspace_addr = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)slot-&gt;ram;<br>    mem.flags = slot-&gt;flags;<br><br>    <span class="hljs-keyword">if</span> (slot-&gt;memory_size &amp;&amp; !<span class="hljs-keyword">new</span> &amp;&amp; (mem.flags ^ slot-&gt;old_flags) &amp; KVM_MEM_READONLY) &#123;<br>        <span class="hljs-comment">/* Set the slot size to 0 before setting the slot to the desired</span><br><span class="hljs-comment">         * value. This is needed based on KVM commit 75d61fbc. */</span><br>        mem.memory_size = <span class="hljs-number">0</span>;<br>        ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> err;<br>        &#125;<br>    &#125;<br>    mem.memory_size = slot-&gt;memory_size;<br>    ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>    slot-&gt;old_flags = mem.flags;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里又将 <code>KVMSlot</code> 转换为 <code>kvm_userspace_memory_region</code>，作为<code>ioctl()</code>的参数，交给内核中的 <code>KVM</code> 进行内存的注册【设置<code>GPA-&gt;HVA</code>的映射关系，在内核空间维护并管理 Guest 的内存】。</p><p>至此 QEMU 侧负责管理内存的数据结构均已完成初始化，<strong>可以参考下面的图片了解各数据结构之间的对应关系</strong></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127155506.png"></p><h3 id="实际内存的分配"><a href="#实际内存的分配" class="headerlink" title="实际内存的分配"></a>实际内存的分配</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127160121.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  └─ <span class="hljs-keyword">void</span> machine-&gt;<span class="hljs-title">init</span><span class="hljs-params">(ram_size, ...)</span></span><br><span class="hljs-function">       └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc_init_pci</span><span class="hljs-params">(ram_size, ...)</span> <span class="hljs-comment">// 初始化虚拟机</span></span><br><span class="hljs-function">            └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc_init1</span><span class="hljs-params">(system_memory, system_io, ram_size, ...)</span></span><br><span class="hljs-function">                 ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">(pci_memory, <span class="hljs-string">&quot;pci&quot;</span>, ...)</span> <span class="hljs-comment">// pci_memory, rom_memory</span></span><br><span class="hljs-function">                 └─ <span class="hljs-keyword">void</span> <span class="hljs-title">pc_memory_init</span><span class="hljs-params">()</span> <span class="hljs-comment">// 初始化内存，分配实际的物理内存地址</span></span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">()</span> <span class="hljs-comment">// 创建 pc.ram, pc.rom 并分配内存</span></span><br><span class="hljs-function">                      |    ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |    └─ <span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |         └─ <span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc_from_ptr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |</span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">vmstate_register_ram_global</span><span class="hljs-params">()</span> <span class="hljs-comment">// 将 MR 的 name 写入 RAMBlock 的 idstr</span></span><br><span class="hljs-function">                      |    └─ <span class="hljs-keyword">void</span> <span class="hljs-title">vmstate_register_ram</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |         └─ <span class="hljs-keyword">void</span> <span class="hljs-title">qemu_ram_set_idstr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                      |</span><br><span class="hljs-function">                      ├─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_alias</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 初始化 ram_below_4g, ram_above_4g</span></span><br><span class="hljs-function">                      └─ <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_add_subregion</span><span class="hljs-params">()</span> <span class="hljs-comment">// 在 system_memory 中添加 subregions</span></span><br><span class="hljs-function">                           └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_add_subregion_common</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_update_topology</span><span class="hljs-params">()</span> <span class="hljs-comment">// 为 MemoryRegion 生成 FlatView</span></span><br><span class="hljs-function">                                     └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology</span><span class="hljs-params">()</span> <span class="hljs-comment">// as-&gt;current_map = new_view</span></span><br><span class="hljs-function">                                          └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">address_space_update_topology_pass</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                               └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_region_add</span><span class="hljs-params">()</span> <span class="hljs-comment">// region_add 对应的回调实现</span></span><br><span class="hljs-function">                                                    └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_set_phys_mem</span><span class="hljs-params">()</span> <span class="hljs-comment">// 根据传入的 section 填充 KVMSlot</span></span><br><span class="hljs-function">                                                         └─ <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_set_user_memory_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function">                                                              └─ <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(KVM_SET_USER_MEMORY_REGION)</span></span><br></code></pre></td></tr></table></figure><p>之前的回调函数注册、AddressSpace 的初始化，实际上均没有对应的物理内存。【实际的内存是在RAMBlock中】</p><p>我们再回到 <code>qemu</code> 启动的 <code>main</code> 函数中。接下来的初始化过程会调用 <code>pc_init1</code>。在这里面，对于 <code>CPU</code> 虚拟化，我们会调用 <code>pc_cpus_init</code>。另外，<code>pc_init1</code> 还会调用<code> pc_memory_init</code>，进行内存的虚拟化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">pc_memory_init</span><span class="hljs-params">(MemoryRegion *system_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kernel_cmdline,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *initrd_filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> below_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">ram_addr_t</span> above_4g_mem_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion *rom_memory,</span></span><br><span class="hljs-params"><span class="hljs-function">                    MemoryRegion **ram_memory)</span></span><br><span class="hljs-function"></span>&#123;<br>    MemoryRegion *ram, *option_rom_mr;         <span class="hljs-comment">// 两个实体 MR: pc.ram, pc.rom</span><br>    MemoryRegion *ram_below_4g, *ram_above_4g; <span class="hljs-comment">// 两个别名 MR: ram_below_4g, ram_above_4g</span><br><br>    <span class="hljs-comment">/* Allocate RAM.  We allocate it as a single memory region and use</span><br><span class="hljs-comment">     * aliases to address portions of it, mostly for backwards compatibility</span><br><span class="hljs-comment">     * with older qemus that used qemu_ram_alloc().</span><br><span class="hljs-comment">     */</span><br>    ram = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram)); <span class="hljs-comment">// 创建 ram</span><br>    <span class="hljs-comment">// 分配具体的内存（实际上会创建一个 RAMBlock 并将其 offset 值写入 ram.ram_addr，对应 GPA）</span><br>    memory_region_init_ram(ram, <span class="hljs-string">&quot;pc.ram&quot;</span>, below_4g_mem_size + above_4g_mem_size);<br>    <span class="hljs-comment">// 将 MR 的 name 写入 RAMBlock 的 idstr</span><br>    vmstate_register_ram_global(ram);<br>    *ram_memory = ram;<br><br>    <span class="hljs-comment">// 创建 ram_below_4g 表示 4G 以下的内存</span><br>    ram_below_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_below_4g));<br>    memory_region_init_alias(ram_below_4g, <span class="hljs-string">&quot;ram-below-4g&quot;</span>, ram, <span class="hljs-number">0</span>, below_4g_mem_size);<br>    <span class="hljs-comment">// 将 ram_below_4g 挂在 system_memory 下</span><br>    memory_region_add_subregion(system_memory, <span class="hljs-number">0</span>, ram_below_4g);<br><br>    <span class="hljs-keyword">if</span> (above_4g_mem_size &gt; <span class="hljs-number">0</span>) &#123;<br>        ram_above_4g = g_malloc(<span class="hljs-keyword">sizeof</span>(*ram_above_4g));<br>        memory_region_init_alias(ram_above_4g, <span class="hljs-string">&quot;ram-above-4g&quot;</span>, ram, below_4g_mem_size, above_4g_mem_size);<br>        memory_region_add_subregion(system_memory, <span class="hljs-number">0x100000000</span>ULL, ram_above_4g);<br>    &#125;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的重点在于<code>memory_region_init_ram()</code>，它通过<code>qemu_ram_alloc()</code>获取ram这个 <code>MemoryRegion</code> 对应的 <code>RAMBlock</code> 的<code>offset</code>，并存入<code>ram.ram_addr</code>，这样就可以在<code>ram_list</code>中根据该字段查找 <code>MR</code> 对应的 <code>RAMBlock</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">memory_region_init_ram</span><span class="hljs-params">(MemoryRegion *mr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">uint64_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_region_init(mr, name, size); <span class="hljs-comment">// 填充字段，初始化默认值</span><br>    mr-&gt;ram = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示为 RAM</span><br>    mr-&gt;terminates = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示为实体 MemoryRegion</span><br>    mr-&gt;destructor = memory_region_destructor_ram;<br>    mr-&gt;ram_addr = qemu_ram_alloc(size, mr); <span class="hljs-comment">// 这里保存 RAMBlock 的 offset，即 GPA</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而qemu_ram_alloc()最终会调用qemu_ram_alloc_from_ptr()，创建一个对应大小 RAMBlock 并分配内存，返回对应的 GPA 地址存入mr-&gt;ram_addr中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">ram_addr_t</span> <span class="hljs-title">qemu_ram_alloc_from_ptr</span><span class="hljs-params">(<span class="hljs-keyword">ram_addr_t</span> size, <span class="hljs-keyword">void</span> *host,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   MemoryRegion *mr)</span></span><br><span class="hljs-function"></span>&#123;<br>    RAMBlock *new_block; <span class="hljs-comment">// 创建一个 RAMBlock</span><br><br>    size = TARGET_PAGE_ALIGN(size); <span class="hljs-comment">// 页对齐</span><br>    new_block = g_malloc0(<span class="hljs-keyword">sizeof</span>(*new_block)); <span class="hljs-comment">// 初始化 new_block</span><br><br>    new_block-&gt;mr = mr; <span class="hljs-comment">// 将 new_block-&gt; 指向入参的 MemoryRegion</span><br>    new_block-&gt;offset = find_ram_offset(size); <span class="hljs-comment">// 从 ram_list 中的 RAMBlock 之间找到一段可以满足 size 需求的 gap，并返回起始地址的 offset，对应 GPA</span><br>    <span class="hljs-keyword">if</span> (host) &#123; <span class="hljs-comment">// 新建的 RAMBlock host 字段为空，跳过</span><br>        new_block-&gt;host = host;<br>        new_block-&gt;flags |= RAM_PREALLOC_MASK;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mem_path) &#123; <span class="hljs-comment">// 未指定 mem_path</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined (__linux__) &amp;&amp; !defined(TARGET_S390X)</span><br>            new_block-&gt;host = file_ram_alloc(new_block, size, mem_path);<br>            <span class="hljs-keyword">if</span> (!new_block-&gt;host) &#123;<br>                new_block-&gt;host = qemu_vmalloc(size);<br>                qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;-mem-path option unsupported\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (xen_enabled()) &#123;<br>                xen_ram_alloc(new_block-&gt;offset, size, mr);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kvm_enabled()) &#123; <span class="hljs-comment">// 从这里继续</span><br>                <span class="hljs-comment">/* some s390/kvm configurations have special constraints */</span><br>                new_block-&gt;host = kvm_vmalloc(size); <span class="hljs-comment">// 实际上还是调用 qemu_vmalloc(size)</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                new_block-&gt;host = qemu_vmalloc(size); <span class="hljs-comment">// 从 QEMU 的线性空间中分配 size 大小的内存，返回 HVA</span><br>            &#125;<br>            qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);<br>        &#125;<br>    &#125;<br>    new_block-&gt;length = size; <span class="hljs-comment">// 将 length 设置为 size</span><br><br>    QLIST_INSERT_HEAD(&amp;ram_list.blocks, new_block, next); <span class="hljs-comment">// 将该 RAMBlock 插入 ram_list 头部</span><br><br>    ram_list.phys_dirty = g_realloc(ram_list.phys_dirty, <span class="hljs-comment">// 重新分配 ram_list.phys_dirty 的内存空间</span><br>                                       last_ram_offset() &gt;&gt; TARGET_PAGE_BITS);<br>    <span class="hljs-built_in">memset</span>(ram_list.phys_dirty + (new_block-&gt;offset &gt;&gt; TARGET_PAGE_BITS),<br>           <span class="hljs-number">0</span>, size &gt;&gt; TARGET_PAGE_BITS);<br>    cpu_physical_memory_set_dirty_range(new_block-&gt;offset, size, <span class="hljs-number">0xff</span>); <span class="hljs-comment">// 对该 RAMBlock 对应的内存标记为 dirty</span><br><br>    qemu_ram_setup_dump(new_block-&gt;host, size);<br><br>    <span class="hljs-keyword">if</span> (kvm_enabled())<br>        kvm_setup_guest_memory(new_block-&gt;host, size);<br><br>    <span class="hljs-keyword">return</span> new_block-&gt;offset;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来<code>ram</code>【其实就是<code>system memory</code>，整个<code>Guest</code>物理空间的大小】对应的 <code>RAMBlock</code> 中就分配好了 <code>GPA</code> 和 <code>HVA</code>，就可以<strong>将内存信息同步至 KVM 侧</strong>了。</p><p>最后回到<code>pc_memory_init()</code>中，在分配完实际内存后，会先调用<code>memory_region_init_alias()</code>初始化<code>ram_below_4g</code>、<code>ram_above_4g</code>这两个<code> alias</code>，之后调用<code>memory_region_add_subregion()</code>将这两个 <code>alias</code> 指向<code>ram</code>这个实体 <code>MemoryRegion</code>。如下图，该函数最终会触发<code>kvm_region_add()</code>回调，将实际的内存信息传入 <code>KVM</code> 注册。该过程如下图所示，与之前分析的流程相同，此处不再赘述。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163205.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟机的内存管理也是需要用户态的 <code>qemu</code> 和内核态的 <code>KVM</code> 共同完成。为了加速内存映射，需要借助硬件的 <code>EPT</code> 技术。</p><h3 id="QEMU-侧"><a href="#QEMU-侧" class="headerlink" title="QEMU 侧"></a>QEMU 侧</h3><ul><li><p>创建一系列 <code>MemoryRegion</code>，分别表示 <code>Guest</code> 中的 <code>RAM</code>、<code>ROM</code> 等区域。<code>MemoryRegion </code>之间通过 <code>alias</code> 或 <code>subregions</code> 的方式维护相互之间的关系，从而进一步细化区域的定义</p></li><li><p>对于一个实体 <code>MemoryRegion</code>（非 <code>alias</code>），在初始化内存的过程中 <code>QEMU</code> 会创建它所对应的 <code>RAMBlock</code>。该 <code>RAMBlock</code> 通过调用<code>qemu_ram_alloc_from_ptr()</code>从 <code>QEMU</code> 的进程地址空间中<strong>以 mmap 的方式分配内存</strong>，并负责<strong>维护该 MemoryRegion 对应内存的起始 GPA/HVA/size 等相关信息</strong>【在<code>qemu_ram_alloc_from_ptr</code>中创建的新<code>RAMBlock</code>有<code>offset</code>、<code>host</code>的赋值，即<code>GPA-&gt;HVA</code>的对应关系】</p></li><li><p><code>AddressSpace</code> 表示 <code>Guest</code> 的物理地址空间。如果 <code>AddressSpace</code> 中的 <code>MemoryRegion</code> 发生变化，则注册的 <code>listener</code> 会被触发，将所属的 <code>MemoryRegion</code> 树展开生成一维的 <code>FlatView</code>，比较 FlatRange 是否发生了变化。如果是，则调用相应的方法对 <code>MemoryRegionSection</code> 进行检查，更新 <code>QEMU</code> 中的 <code>KVMSlot</code>，同时填充<code>kvm_userspace_memory_region</code>结构体，作为<code>ioctl()</code>的参数更新 <code>KVM</code> 中的<code>kvm_memory_slot</code></p></li></ul><h3 id="KVM-侧"><a href="#KVM-侧" class="headerlink" title="KVM 侧"></a>KVM 侧</h3><ul><li><p>当 <code>QEMU</code> 通过<code>ioctl()</code>创建 <code>vcpu</code> 时，调用<code>kvm_mmu_create()</code>初始化 <code>MMU</code> 相关信息.<br>当 <code>KVM</code> 要进入 <code>Guest</code> 前，<code>vcpu_enter_guest()=&gt;kvm_mmu_reload()</code>会将根级页表地址加载到 <code>VMCS</code>，让 <code>Guest</code> 使用该页表</p></li><li><p>当发生<code> EPT Violation</code> 时，<code>VM-EXIT </code>到 <code>KVM</code> 中。如果是缺页，则根据 <code>GPA</code> 算出 <code>gfn</code>，再根据 <code>gfn</code> 找到对应的 <code>KVMSlot</code>，从中得到对应的 <code>HVA</code>。然后根据 <code>HVA</code> 算出对应的 <code>pfn</code>，确保该 <code>Page</code> 位于内存中。填好缺失的页之后，需要更新 <code>EPT</code>，完善其中缺少的页表项，逐层补全页表</p></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163418.png"></p><blockquote><p>虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即 <code>mmap</code> 分配的虚拟内存空间被访问的时候，先查看 <code>EPT</code> 页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。<br>如果没有映射过，则虚拟机会通过<code>VM-Exit</code>指令回到宿主机模式，通过 <code>handle_ept_violation</code> 补充页表映射。先是通过 <code>handle_mm_fault </code>为虚拟机的物理内存空间分配真正的物理页面，然后通过 <code>__direct_map</code> 添加 <code>EPT</code> 页表映射。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127171031.jpg"></p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://xudaxian.fun/2020/09/03/QEMU%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">“QEMU内存空间虚拟化及内存管理” - B10g | FΓom 许大仙</a><br><a href="https://www.cnblogs.com/LoyenWang/p/13943005.html">【原创】Linux虚拟化KVM-Qemu分析（五）之内存虚拟化 - LoyenWang - 博客园</a><br><a href="https://blog.csdn.net/xiongwenwu/article/details/58586013">KVM/Qemu 工作原理系列目录_xiongwenwu的专栏-CSDN博客_qemu目录结构</a><br><a href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决VSCode配置远程连接，过程试图写入的管道不存在</title>
    <link href="/2022/01/19/%E8%A7%A3%E5%86%B3VSCode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%87%E7%A8%8B%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8/"/>
    <url>/2022/01/19/%E8%A7%A3%E5%86%B3VSCode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%87%E7%A8%8B%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201192309069.png"></p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>本地记录的服务器信息和现有的产生了冲突</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>将<code>known_hosts</code>文件的内容全部删除。</p><p><code>C:\Users\user name\.ssh\known_hosts</code></p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>搜遍全网几乎都是上述方法，应该绝大部分人通过上述方法都能解决。如果你也跟我一样不走运，不管是重新生成公私钥，还是删除<code>hnow_hosts</code>都不行，那么可以尝试修改VSCode使用的<code>ssh.exe</code>。windows下默认使用的是环境变量里配置的<code>OpenSSH</code>提供的<code>ssh.exe</code>。你可以将环境变量里的<code>OpenSSH</code>删除。然后在<code>VSCode</code>设置里搜索<code>remote</code>，也就是设置插件<code>remote ssh</code>。</p><p>将Path强制设置成<code>Git</code>安装包内的<code>ssh.exe</code></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201192304598.png"></p><p>或者<code>mobaxterm</code>安装包内的<code>ssh.exe</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://codeantenna.com/a/8z5QCm29iy">Debug | VSCode | 过程试图写入的管道不存在 - CodeAntenna</a></p><p><a href="https://blog.csdn.net/weixin_42096901/article/details/105193366">VScode通过remote ssh连接虚拟机 &amp; 报错 过程试图写入的管道不存在（已解决）_Tasdily的博客-CSDN博客_vscode过程试图写入的管道不存在</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux帧缓冲</title>
    <link href="/2022/01/17/Linux%E5%B8%A7%E7%BC%93%E5%86%B2/"/>
    <url>/2022/01/17/Linux%E5%B8%A7%E7%BC%93%E5%86%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FrameBuffer 是内核当中的一种驱动程序接口。Linux是工作在保护模式下，所以用户态进程是无法象DOS那样使用显卡BIOS里提供的中断调用来实现直接写屏，Linux抽象出 FrameBuffer这个设备来供用户态进程实现直接写屏。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220118092227.png"></p><h2 id="帧缓冲主要结构"><a href="#帧缓冲主要结构" class="headerlink" title="帧缓冲主要结构"></a>帧缓冲主要结构</h2><ul><li><p>fb_info<br>  该结构体记录当前帧缓冲设备的状态信息，如果系统中有多个帧缓冲设备，就需要两个fb_info结构，这个结构只在内核中可以看到，对用户空间不可见。</p></li><li><p>fb_var_screeninfo<br>  该结构体记录指定的帧缓冲设备和显示模式中可以被修改的信息，其中包括显示器分辨率等信息。</p></li><li><p>fb_fix_screeninfo<br>  该结构体表示帧缓冲设备中一些不能修改的参数，包括特定的显示模式，屏幕缓冲区的物理地址，显示缓冲区的长度信息。</p></li><li><p>fb_ops<br>  LCD底层硬件操作接口集。比如<code>fb_open</code>、<code>fb_release</code>、<code>fb_read</code>、<code>fb_write</code>、<code>fb_ioctl</code>、<code>fb_mmap</code>等：</p></li></ul><ul><li>fb_cmap<br>  <code>fb_cmap</code>指定颜色映射，用于以内核可以理解的方式存储用户的颜色定义。</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220117192106.png"></p><h2 id="帧缓冲显示原理"><a href="#帧缓冲显示原理" class="headerlink" title="帧缓冲显示原理"></a>帧缓冲显示原理</h2><p>帧缓冲设备是一种显示抽象的设备，也可以被理解为它是一个内存区域，上面的应用程序可以直接对显示缓冲区进行读和写操作，就像访问文件的通用接口一样，用户可以认为帧缓冲是一块内存，能读取数据的内存块也可以向这个内存写入数据，因此显示器显示图形界面实际上根据根据的是指定的内存数据块内的数据。</p><p>帧缓冲的显示缓冲区位于Linux内核地址空间，应用程序不能直接访问内核地址空间，在Linux中，只有一个内存的内核地址空间映射到用户地址空间才可以由用户访问，内存的映射是通过<code>MMAP</code>函数实现的在Linux中。对于帧缓冲，虚拟地址是通过内存映射的方法将显示缓冲区内核地址映射到用户空间的，然后用户可以通过读和写这部分的虚拟地址来访问显示缓冲区，在屏幕上绘图。</p><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><p>使用帧缓冲之前应该首先确定Linux系统上已安装了帧缓冲驱动，可以在目录<code>/dev/</code>下查找<code>fb*</code>如，<code>/dev/fb0, /dev/fb1</code>等设备来确定是否安装。如果没有需要安装一个帧缓冲驱动的模块到内核，或者重新编译内核生成一个带帧缓冲模块的镜像。</p><p>使用帧缓冲需要进入控制台模式，即纯命令行的模式进行编程。一般可以通过快捷键<code>CTRL+ALT+F1</code>进入控制台模式，<code>CTRL+ALT+F7</code>切回图形窗口。如果控制台模式没有登录，可以<code>CTRL+ALT+F6</code>尝试登录。</p><p>因硬件显示设备的物理显示区是通过帧缓存区操作，而帧缓存区是处于内核空间，应用程序不能随意操作，此时可以通过系统调用<code>mmap</code>把帧缓存映射到用户空间，在用户空间中创建出帧缓存映射区（用户图像数据缓存区），以后只需把用户图像数据写入到帧缓存映射区就可在硬件设备上显示图像。</p><p>具体实现流程如下：</p><h3 id="打开帧缓冲设备-dev-f0。"><a href="#打开帧缓冲设备-dev-f0。" class="headerlink" title="打开帧缓冲设备/dev/f0。"></a>打开帧缓冲设备<code>/dev/f0</code>。</h3><p>在Linux的/dev目录的寻找b*设备文件然后使用读写模式打开它， Linux系统将使用通用的<code>open</code>系统调用来完成功能， <code>open</code>的功能原型如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>Path</code>是准备打开的文件或设备的路径参数；</li><li><code>oflags</code>指定打开文件时使用的参数；</li><li><code>flags</code>参数的指定，是通过组合文件访问模式和其他的可选模式一起的，可以支持多个模式或，参数必须是指定下列文件的访问模式。<ul><li>只读：O_RDONLLY</li><li>只写：O_WRONLY</li><li>读写：O_RDWR</li></ul></li></ul><p>简而言之， <code>open</code>函数建立设备文件的访问路径。如果操作成功，它返回一个文件描述符，只是一个文件描述符，它将不使用其他任何正在运行的进程共享。如果两个程序同时打开相同的文件，将得到两个不同的文件描述符。如果他们执行文件写入操作，他们将操作每个文件描述符，不会发生冲突，写完之后退出。他们的数据不会互相交织在一起的，但会互相的彼此覆盖(后写完的内容覆盖前面写的内容)，两个程序来读取和写入的文件位置看似一样但是有各自不同拷贝所以不会发生交织。如果<code>open</code>调用未能返回<code>1</code>，则将全局变量<code>errno</code>设置为指示失败的原因。</p><h3 id="通过系统调用ioctl函数获得帧设备相关信息"><a href="#通过系统调用ioctl函数获得帧设备相关信息" class="headerlink" title="通过系统调用ioctl函数获得帧设备相关信息"></a>通过系统调用<code>ioctl</code>函数获得帧设备相关信息</h3><p>通过顿缓冲文件描述符，屏幕的分辨率、颜色深度等信息可以被获得，帧缓冲驱动中存放了这些对应的信息，必须使用Linux系统调用<code>ioctl</code>首先将帧缓冲的文件描述符和<code>fb_var_screeninfo</code> 结构体对应起来。</p><p>结构体<code>fb_var_screeninfo</code>包含以下三个重要数据结构:</p><ul><li>屏幕的x方向分辨率，像素作为单位。</li><li>屏幕的Y方向分辨率，像素作为单位。</li><li>屏幕的像素颜色深度，每个像素用多少比特数表示。</li></ul><p><code>ioctl</code>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ioctl</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> __request, ...)</span> __THROW</span>;<br></code></pre></td></tr></table></figure><p><code>ioctl</code>调用实现访问设备驱动各种各样的配置信息功能，它提供了一个控制设备的行为和配置底层服务接口的驱动函数，各种设备驱动程序，例如套接字和系统终端，还有磁带机都有<code>ioctl</code>命令可以支持。</p><ul><li><code>__fd</code>：<code>ioctl</code>命令中是该帧缓冲的文件描述符；</li><li><code>__request</code>：<code>ioctl</code>函数将要执行的命令，实现参数给定的对象描述符中指定的函数操作，各种设备支持的功能是有差异的<ul><li><code>FBIOGET_VSCREENINFO</code>命令字返回与Framebuffer有关的固定的信息；</li><li><code>FBIOGET_VSCREENINFO</code>命令字返回与Framebuffer有关的可变的信息；</li></ul></li><li>第三个参数是一个指针用来指向结构体<code>fb_var_screeninfo</code>。</li></ul><p>最后使用者可以通过结构体<code>fb_var_screeninfo</code>来获得屏幕的分辨率和颜色位深和其他重要的屏幕信息。根据这些信息可以计算屏幕缓冲区的大小:屏幕缓冲区大小(以字节为单位) = 屏幕宽度x高度x屏幕颜色深度/8</p><h3 id="帧缓冲映射"><a href="#帧缓冲映射" class="headerlink" title="帧缓冲映射"></a>帧缓冲映射</h3><p>在进行帧缓冲的<code>MMAP</code>映射之前，要先得到帧缓冲文件描述符，才能像屏幕上面显示，必须首先将缓冲区的内核地址映射映射到用户地址空间。Linux系统将使用<code>MMAP</code>系统调用完成功能，<code>MMAP</code>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">mmap</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *__addr, <span class="hljs-keyword">size_t</span> __len, <span class="hljs-keyword">int</span> __prot,</span></span><br><span class="hljs-params"><span class="hljs-function">   <span class="hljs-keyword">int</span> __flags, <span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">__off_t</span> __offset)</span> __THROW</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>__addr</code>：返回一个指向<code>mmap</code>函数的内存区域的指针，与内容相关的文件指针，通过指针可以访问帧缓冲区的内存区域。</p></li><li><p><code>__len</code>：可以请求使用特定内存地址，通过设置地址参数，如果值为<code>0</code>，将自动分配指针，这是推荐的做法，否则会降低程序的可移植性，因为不同的系统可用的地址范围是不一样的。</p></li><li><p><code>__prot</code>：设置内存访问的权限设定，通过端口相关的参数定义，位的定义值如下:</p><ul><li><code>PORT_EXEC</code>:允许内存段的执行。</li><li><code>PORT_NONE</code>:无法访问内存段。</li><li><code>PORT_READ</code>:允许读取内存段。</li><li><code>PORT_WRITE</code>:允许编写内存段。</li></ul></li><li><p><code>__flags</code>：改变控制参数标志，能够影响该内存段的作用域，如下所示:</p><ul><li><code>MAP_FIXED</code>:内存段必须位于addr中指定的地址。</li><li><code>MAP_SHARED</code>:内存的修改保存到一个文件中。</li><li><code>MAP_PRIVATE</code>:内存段是私人的，变化仅在本地范围内有效。</li></ul></li><li><p> <code>__fd</code>：是通过一个<code>open</code>调用得到的访问文件的描述符。</p></li><li><p><code>offset</code>：用于指定访问数据的开始偏移量在内存段中，和访问普通文件使用方式是相同的，再指定文件描述符参数，以及访问的数据长度参数即可。</p></li></ul><h3 id="读写帧缓冲"><a href="#读写帧缓冲" class="headerlink" title="读写帧缓冲"></a>读写帧缓冲</h3><p><code>MMAP</code>返回的指针，可以访问到帧缓冲内存区，可以定位到屏幕缓冲区具体为每个显示像素的位置，通过读函数调用读取对应的位置数据在帧缓冲内存中，相反写操作对应于内存的写入数据可以显示内容写到屏幕上。</p><h3 id="解除帧缓冲映射"><a href="#解除帧缓冲映射" class="headerlink" title="解除帧缓冲映射"></a>解除帧缓冲映射</h3><p>在绘图完成后，帧缓冲文件描述符必须被释放之前，解除帧缓冲区的地址映射，使用Linux系统调用完成<code>mmap</code>函数的逆函数实现，即是<code>munmap</code>，函数的原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *__addr, <span class="hljs-keyword">size_t</span> __len)</span> __THROW</span>;<br></code></pre></td></tr></table></figure><p><code>addr</code>参数应该与调用<code>MMAP</code>时指定的参数值一致， <code>len</code>参数也应该与之前调用<code>MMAP</code>时指定的<code>len</code>参数保持一致。</p><p><code>mmap</code>调用返回<code>0</code>成功，失败则返回<code>1</code>，同时将全局变量<code>erno</code>设置为指示失败的原因。</p><h3 id="调用close关闭设备。"><a href="#调用close关闭设备。" class="headerlink" title="调用close关闭设备。"></a>调用<code>close</code>关闭设备。</h3><p>使用帧缓冲设备后，应关闭相应的文件描述符，使用Linux系统标准的函数完成关闭功能，<code>close</code>函数的原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">close</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> __fd)</span></span>;<br></code></pre></td></tr></table></figure><p><code>close</code>的参数和在开始调用<code>open</code>时指定的参数一致，文件描述符释放后可以重用，结束调用成功返回<code>0</code>，失败返回<code>1</code>。</p><h2 id="帧缓冲实例"><a href="#帧缓冲实例" class="headerlink" title="帧缓冲实例"></a>帧缓冲实例</h2><p>以下代码摘自<a href="https://github.com/xianjimli/linux-framebuffer-tools">xianjimli/linux-framebuffer-tools: linux framebuffer tool</a>，演示了帧缓冲设备的使用流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">fb_info_t</span> *<span class="hljs-title">linux_fb_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint32_t</span>                 size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">fb_info_t</span>               *fb   = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_fix_screeninfo</span> <span class="hljs-title">fix</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fb_var_screeninfo</span> <span class="hljs-title">var</span>;</span><br>    return_value_if_fail(filename != <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    fb = (<span class="hljs-keyword">fb_info_t</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">fb_info_t</span>));<br>    return_value_if_fail(fb != <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 打开帧缓冲设备，O_RDWR读写模式</span><br>    fb-&gt;fd = open(filename, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fb-&gt;fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        log_debug(<span class="hljs-string">&quot;open %s failed(%d)\n&quot;</span>, filename, errno);<br>        <span class="hljs-built_in">free</span>(fb);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">// 通过系统调用ioctl函数获得帧设备相关信息</span><br>    <span class="hljs-comment">// FBIOGET_FSCREENINFO命令字返回与Framebuffer有关的固定的信息</span><br>    <span class="hljs-keyword">if</span> (ioctl(fb-&gt;fd, FBIOGET_FSCREENINFO, &amp;fix) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> fail;<br>    <span class="hljs-comment">//命令字返回与Framebuffer有关的可变的信息</span><br>    <span class="hljs-keyword">if</span> (ioctl(fb-&gt;fd, FBIOGET_VSCREENINFO, &amp;var) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> fail;<br><br>    var.xoffset = <span class="hljs-number">0</span>;<br>    var.yoffset = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 显示</span><br>    ioctl(fb-&gt;fd, FBIOPAN_DISPLAY, &amp;(var));<br><br>    log_debug(<span class="hljs-string">&quot;fb_info_t: %s\n&quot;</span>, filename);<br>    log_debug(<span class="hljs-string">&quot;fb_info_t: xres=%d yres=%d bits_per_pixel=%d mem_size=%d\n&quot;</span>, var.xres, var.yres,<br>              var.bits_per_pixel, fb_size(fb));<br>    log_debug(<span class="hljs-string">&quot;fb_info_t: red(%d %d) green(%d %d) blue(%d %d)\n&quot;</span>, var.red.offset, var.red.length,<br>              var.green.offset, var.green.length, var.blue.offset, var.blue.length);<br><br>    fb-&gt;w           = var.xres;<br>    fb-&gt;h           = var.yres;<br>    fb-&gt;bpp         = var.bits_per_pixel / <span class="hljs-number">8</span>;<br>    fb-&gt;line_length = fix.line_length;<br><br>    size = fb_size(fb);<br>    <span class="hljs-comment">// 帧缓冲映射</span><br>    <span class="hljs-comment">// PROT_READ | PROT_WRITE:可读写</span><br>    <span class="hljs-comment">// MAP_SHARED：内存的修改保存到一个文件</span><br>    fb-&gt;data = (<span class="hljs-keyword">uint8_t</span> *)mmap(<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fb-&gt;fd, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (fb-&gt;data == MAP_FAILED)<br>    &#123;<br>        log_debug(<span class="hljs-string">&quot;map framebuffer failed.\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br><br>    log_debug(<span class="hljs-string">&quot;line_length=%d mem_size=%d\n&quot;</span>, fix.line_length, fb_size(fb));<br>    log_debug(<span class="hljs-string">&quot;xres_virtual =%d yres_virtual=%d xpanstep=%d ywrapstep=%d\n&quot;</span>, var.xres_virtual,<br>              var.yres_virtual, fix.xpanstep, fix.ywrapstep);<br><br>    <span class="hljs-keyword">return</span> fb;<br>fail:<br>    log_debug(<span class="hljs-string">&quot;%s is not a framebuffer.\n&quot;</span>, filename);<br>    close(fb-&gt;fd);<br>    <span class="hljs-built_in">free</span>(fb);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>感兴趣可以下载源码编译运行，其中<code>/bin/fbshow</code>可以使用帧缓冲设备显示图片。图形界面下直接运行可能提示无法运行，需要<code>Chrtl+Alt+F1</code>切换到控制台模式。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220120202118.png"></p><h2 id="LCD与Framebuffer的关系"><a href="#LCD与Framebuffer的关系" class="headerlink" title="LCD与Framebuffer的关系"></a>LCD与Framebuffer的关系</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225141549.jpg"></p><p>LCD控制器首先通过VDEN信号，使能。接下来根据VCLK时钟信号，在像素点上“喷涂”不同的颜色（打个比方），控制器有VD（video data）信号，传送不同颜色信息。每来一个时钟信号，就向右移动一个像素，根据行同步信号HSYNC，就从最右边移动到最左边。当移动到右下角时根据垂直同步信号VSYNC。</p><p>那么问题来了，不同颜色的信息从哪里来？就是从上文介绍的Framebuffer中来的。</p><p>很多人都会说操纵LCD显示就是操纵FrameBuffer，表面上来看是这样的。实际上是FrameBuffer就是linux内核驱动申请的一片内存空间，然后LCD内有一片sram，cpu内部有个LCD控制器，它有个单独的dma用来将FrameBuffer中的数据拷贝到LCD的sram中去 拷贝到LCD的sram中的数据就会显示在LCD上，LCD驱动和FrameBuffer驱动没有必然的联系，它只是驱动LCD正常工作的，比如有信号传过来，那么LCD驱动负责把信号转成显示屏上的内容，至于什么内容这就是应用层要处理的。</p><blockquote><p>静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。<br>DMA（Direct Memory Access），直接内存访问。使用DMA的好处就是它不需要CPU的干预而直接服务外设，这样CPU就可以去处理别的事务，从而提高系统的效率。</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://carlyleliu.github.io/2021/Linux%E9%A9%B1%E5%8A%A8%E4%B9%8BFramebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">Linux驱动之Framebuffer子系统 | 量子范式</a><br><a href="https://www.codenong.com/cs106598190/">Linux驱动开发（9）——- framebuffer驱动详解 | 码农家园</a><br><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201502&filename=1015587486.nh&uniplatform=NZKPT&v=KNvhApgKTzqH-mWxqP6f8BkbDR9mSjPHz8PfaxqDg2f1j30XqnHzSDsvwoqz-CbX">嵌入式系统中帧缓冲显示模块的设计与实现 - 中国知网</a><br><a href="https://github.com/tsuibin/research/tree/master/framebuffer/fivechess/fivechess-0.1">research/framebuffer/fivechess/fivechess-0.1 at master · tsuibin/research</a><br><a href="https://www.shangmayuan.com/a/f67d260756ce42258a9ed4ef.html">五子棋 framebuffer版 - 尚码园</a><br><a href="https://blog.csdn.net/yangwen123/article/details/12096483">FrameBuffer驱动程序分析_深入剖析Android系统-CSDN博客_framebuffer</a><br><a href="https://github.com/xianjimli/linux-framebuffer-tools">xianjimli/linux-framebuffer-tools: linux framebuffer tool</a><br><a href="https://www.bilibili.com/video/BV1HW411L76t?p=2">韦东山_嵌入式Linux_第2期_Linux高级驱动视频教程_免费试看版_哔哩哔哩_bilibili</a><br><a href="https://zhuanlan.zhihu.com/p/356443723">Linux LCD Frambuffer 基础介绍和使用（1） - 知乎</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>FrameBuffer</tag>
      
      <tag>LCD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决ssh permission denied(publickey)</title>
    <link href="/2022/01/13/%E8%A7%A3%E5%86%B3Git%20ssh%20permission%20denied(publickey)/"/>
    <url>/2022/01/13/%E8%A7%A3%E5%86%B3Git%20ssh%20permission%20denied(publickey)/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">linux&gt; ssh -p 2221 xxx@gerrit.com<br>xxx@gerrit.com: Permission denied(publickey)<br></code></pre></td></tr></table></figure><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>本次出错是在测试是否能连接gerrit时。连接github也可能会出现。只要用到ssh功能的都有可能。</p><p>出错的原因：</p><ul><li>网页（如gerrit,github）没有设置公钥，一般为<code>id_rsa.pub</code>内容；</li><li>本地生成了多个公私钥，配对配错了；</li><li>本地没有配置好<code>git</code>，比如<code>git config</code>时用户名或者邮箱填错；</li><li>需要开启ssh代理；</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>生成密钥<code>cd ~/.ssh &amp;&amp; ssh-keygen</code></li><li>复制公钥内容，添加到网页中<code>github</code>或者<code>gerrit</code>的设置里。<code>cat id_rsa.pub | xclip</code></li><li>配置<code>git</code>账户<ul><li><code>git config --global user.name &quot;bob&quot;</code></li><li><code>git config --global user.email bob@...</code></li></ul></li></ul><p>以上检查无误，仍然报错</p><ul><li>开启<code>ssh</code>代理<ul><li><code>eval $(ssh-agent -s)</code></li></ul></li><li>将私钥加入代理<ul><li><code>ssh-add ~/.ssh/id_rsa</code></li></ul></li></ul><h2 id="登陆用户时启动-ssh-agent"><a href="#登陆用户时启动-ssh-agent" class="headerlink" title="登陆用户时启动 ssh-agent"></a>登陆用户时启动 ssh-agent</h2><p>如果不幸你的问题就是需要开启<code>ssh-agent</code>，那么每次重启电脑都需要开启一次。这也是相当麻烦的，可以通过将以下配置添加到<code>~/.bashrc</code>中，让linux启动时自动开启<code>ssh-agent</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># Add following code at the end of ~/.bashrc</span><br><br><span class="hljs-comment"># Check if ~/.pid_ssh_agent exists.</span><br><span class="hljs-keyword">if</span> [ -f ~/.pid_ssh_agent ]; <span class="hljs-keyword">then</span><br><br>    <span class="hljs-built_in">source</span> ~/.pid_ssh_agent<br><br>    <span class="hljs-comment"># Check process of ssh-agent still exists.</span><br>    TEST=$(ssh-add -l)<br><br>    <span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$TEST</span>&quot;</span> ]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># Reinit if not.</span><br>        NEED_INIT=1<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">else</span><br>    NEED_INIT=1 <span class="hljs-comment"># PID file doesm&#x27;t exist, reinit it.</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># Try start ssh-agent.</span><br><span class="hljs-keyword">if</span> [ ! -z <span class="hljs-string">&quot;<span class="hljs-variable">$NEED_INIT</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> $(ssh-agent -s) | sed -e <span class="hljs-string">&#x27;s/echo[ A-Za-z0-9]*;//g&#x27;</span> &gt; ~/.pid_ssh_agent <span class="hljs-comment"># save the PID to file.</span><br>    <span class="hljs-built_in">source</span> ~/.pid_ssh_agent<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/2643502/git-how-to-solve-permission-denied-publickey-error-when-using-git">ssh - Git: How to solve Permission denied (publickey) error when using Git? - Stack Overflow</a></p><p><a href="https://fenying.net/post/2017/12/20/auto-init-ssh-agent/">Linux 登陆用户时启动 ssh-agent 并复用 - Fenying</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux安装nodejs以及hexo</title>
    <link href="/2022/01/10/Linux%E5%AE%89%E8%A3%85nodejs/"/>
    <url>/2022/01/10/Linux%E5%AE%89%E8%A3%85nodejs/</url>
    
    <content type="html"><![CDATA[<h2 id="安装nodejs过程"><a href="#安装nodejs过程" class="headerlink" title="安装nodejs过程"></a>安装nodejs过程</h2><p>进入该网站<a href="https://nodejs.org/zh-cn/download/">下载 | Node.js</a><br>也可以进入该网站下载历史版本，<a href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js</a></p><p>进入download目录，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> download<br><span class="hljs-attribute">wget</span> https://nodejs.org/dist/v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>/node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span>.tar.xz  -O nodejs.tar.xz<br></code></pre></td></tr></table></figure><p>解压</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -xvf node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span>.tar.xz<br></code></pre></td></tr></table></figure><p>改名nodejs</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> node-v<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">3</span>-linux-x<span class="hljs-number">64</span> nodejs<br></code></pre></td></tr></table></figure><p>将npm，node两个程序建立软连接，能够全局可用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ ln -s <span class="hljs-regexp">/download/</span>nodejs<span class="hljs-regexp">/bin/</span>npm <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span> <br><br>$ ln -s <span class="hljs-regexp">/download/</span>nodejs<span class="hljs-regexp">/bin/</span>node <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span><br></code></pre></td></tr></table></figure><p>检查是否安装</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br><br>npm -v<br></code></pre></td></tr></table></figure><h2 id="安装hexo过程"><a href="#安装hexo过程" class="headerlink" title="安装hexo过程"></a>安装hexo过程</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm i hexo-<span class="hljs-keyword">cli</span> -g<br>hexo -v<br></code></pre></td></tr></table></figure><p>如果出现命令未找到到错误，说明hexo还未加入全局变量。<br>将下面命令加入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim ~/.bashrc<br>export PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nodejs/</span>lib<span class="hljs-regexp">/node_modules/</span>hexo-cli<span class="hljs-regexp">/bin/</span>:<span class="hljs-variable">$PATH</span> <br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js</a><br><a href="https://learnku.com/articles/32767">Linux 安装 Node.js | F2E 前端技术论坛</a><br><a href="https://segmentfault.com/a/1190000024422534">Linux下安装node及npm - SegmentFault 思否</a><br><a href="https://zhuanlan.zhihu.com/p/35668237">超详细Hexo+Github博客搭建小白教程 - 知乎</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言__attribute__使用</title>
    <link href="/2022/01/08/C%E8%AF%AD%E8%A8%80-attribute-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/08/C%E8%AF%AD%E8%A8%80-attribute-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>__attribute__</code> 其实是个编译器指令，告诉编译器声明的特性，或者让编译器进行更多的错误检查和高级优化。</p><p><code>__attribute__</code> 可以设置<a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Function-Attributes.html#Function-Attributes">函数属性（Function Attribute）</a>、<a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Variable-Attributes.html#Variable-Attributes">变量属性（Variable Attribute）</a>和<a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Type-Attributes.html#Type-Attributes">类型属性（Type Attribute）</a>。每一类都包含数十种属性，本文不会逐一解释，只抛砖引玉，完整属性可以查看链接中的官方文档。</p><p>一个属性说明符的形式是<code>__attribute__ ((attribute-list))</code>。一个属性列表是一个可能为空的逗号分隔的属性序列，其中每个属性都是以下的一个。</p><ul><li>属性为空。空属性会被忽略。</li><li>一个单词（可能是未使用的标识符，也可能是 const 等保留字）。</li><li>一个单词，后面跟着括号中的属性参数。这些参数采用以下形式之一：<ul><li>一个标识符。例如，<code>mode</code>属性使用这种形式。</li><li>一个标识符，后跟一个逗号和一个以逗号分隔的非空表达式列表。例如，<code>format</code>属性使用这种形式。</li><li>一个可能是空的逗号分隔的表达式列表。例如，<code>format_arg</code>属性使用这种形式，该列表是一个单一的整数常量表达式，而<code>alias</code>属性也使用这种形式，该列表是一个单一的字符串常量。</li></ul></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><p>该属性可以设置函数的别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __f() &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;__attribute__ test\n&quot;</span>); &#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((weak, alias(<span class="hljs-string">&quot;__f&quot;</span>)))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  f();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*--- 输出 ---*/</span> <br><span class="hljs-comment">//__attribute__ test</span><br></code></pre></td></tr></table></figure><p>函数<code>f()</code>的别名为<code>__f()</code>，调用<code>f()</code>即调用<code>__f()</code>。</p><h4 id="alloc-size"><a href="#alloc-size" class="headerlink" title="alloc_size"></a>alloc_size</h4><p><code>alloc_size</code>属性用来告诉编译器，函数的返回值指向内存，其中的大小由一个或两个函数参数给出。GCC使用这些信息来提高<code>__builtin_object_size</code>的正确性。</p><p><code>alloc_size</code>后面可以跟一到二个参数，<code>alloc_size</code> 后面跟的参数是指定使用函数的第几个参数。</p><ul><li><p>函数的参数的个数只有一个，那么alloc_size的参数只能是1。通过<code>__builtin_object_size</code> 获取的值 就是传入的参数值。如图，我们给函数<code>my_malloc</code> 传入的值是<code>100</code> ，那么我们通过<code>__builtin_object_size</code> 获取的值就是<code>100</code>。</p></li><li><p>函数的参数的个数多余两个，那么<code>alloc_size</code> 的最多可以指定两个参数。传入两个参数，<code>__builtin_object_size</code>的值是这两个参数的乘积。传入一个参数，<code>__builtin_object_size </code>的值就是这个参数的值。如图，<code>my_callocd</code>函数指定的参数是<code>alloc_size(2,3)</code>，通过<code>__builtin_object_size</code>获取的值就是<code>my_callocd</code>传入的第二和三个参数的乘积（2*3=6）。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_calloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((alloc_size(<span class="hljs-number">1</span>)))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_realloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((alloc_size(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_calloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">my_realloc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> p = my_calloc(<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size : %ld\n&quot;</span>, __builtin_object_size(p, <span class="hljs-number">0</span>));<br><br>  <span class="hljs-keyword">void</span> *<span class="hljs-keyword">const</span> a = my_realloc(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size : %ld\n&quot;</span>, __builtin_object_size(a, <span class="hljs-number">1</span>));<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*--- 输出 ---*/</span> <br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure><h4 id="constructor-priority-destructor-priority"><a href="#constructor-priority-destructor-priority" class="headerlink" title="constructor (priority) / destructor (priority)"></a>constructor (priority) / destructor (priority)</h4><p><code>constructor</code>属性使该函数在执行进入<code>main()</code>之前被自动调用。同样地，<code>destructor</code>属性使函数在<code>main()</code>完成后或<code>exit()</code>被调用后被自动调用。具有这些属性的函数对于初始化将在程序执行过程中隐含使用的数据非常有用。</p><p><code>constructor</code> 和 <code>+load</code> 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。</p><p>若有多个 <code>constructor</code> 且想控制优先级的话，可以写成 <code>attribute((constructor(101)))</code>，里面的数字越小优先级越高，<code>1 ~ 100</code> 为系统保留。</p><h3 id="变量属性"><a href="#变量属性" class="headerlink" title="变量属性"></a>变量属性</h3><h4 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h4><p>该属性在变量作用域结束时，调用指定的一个函数。这个属性只能应用于自动函数范围的变量；它不能应用于参数或具有静态存储期限的变量。该函数必须接受一个参数，一个指向与变量兼容的类型的指针。函数的返回值（如果有的话）被忽略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_cleanup</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **str)</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after cleanup: %s\n&quot;</span>, *str);<br>  <span class="hljs-built_in">free</span>(*str);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br><br>  <span class="hljs-keyword">char</span> *str __attribute__((__cleanup__(test_cleanup))) = <span class="hljs-literal">NULL</span>;<br>  str = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>((<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)) * <span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;test&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;before cleanup : %s\n&quot;</span>, str);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*--- 输出 ---*/</span> <br><span class="hljs-comment">//before cleanup : test</span><br><span class="hljs-comment">//after cleanup: test</span><br></code></pre></td></tr></table></figure><p>作用域结束包括大括号结束、<code>return</code>、<code>goto</code>、<code>break</code>、<code>exception</code>等各种情况。在上面的实验中，<code>main</code>函数返回标志变量<code>str</code>作用域结束，所以最后才打印<code>after cleanup: test</code>。</p><h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><h4 id="aligned-alignment"><a href="#aligned-alignment" class="headerlink" title="aligned (alignment)"></a>aligned (alignment)</h4><p>这个属性指定了函数的最小对齐方式，以字节为单位。对齐的大小只能增加，不能减小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> &#123;</span><br>  <span class="hljs-keyword">char</span> sex;<br>  <span class="hljs-keyword">int</span> length;<br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">char</span> value[<span class="hljs-number">15</span>];<br>&#125; __attribute__((aligned(<span class="hljs-number">1</span>)));<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> <span class="hljs-title">my_stu</span>;</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d \n&quot;</span>, <span class="hljs-keyword">sizeof</span>(my_stu));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p,%p,%p \n&quot;</span>, &amp;my_stu, &amp;my_stu.length, &amp;my_stu.name,<br>         &amp;my_stu.value);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*---  __attribute__((aligned(1)));输出 ---*/</span> <br><span class="hljs-comment">//28 </span><br><span class="hljs-comment">//0x55af2ba25020 0x55af2ba25024,0x55af2ba25028,0x55af2ba2502a</span><br><span class="hljs-comment">/*---  __attribute__((aligned(4)));输出 ---*/</span> <br><span class="hljs-comment">//28 </span><br><span class="hljs-comment">//0x556fbce54020 0x556fbce54024,0x556fbce54028,0x556fbce5402a </span><br><span class="hljs-comment">/*---  __attribute__((aligned(8)));输出 ---*/</span> <br><span class="hljs-comment">//32 </span><br><span class="hljs-comment">//0x5646e130e040 0x5646e130e044,0x5646e130e048,0x5646e130e04a</span><br></code></pre></td></tr></table></figure><p>由以上代码实验结果发现，默认对齐代下为4字节，小于这个值就被忽略，大于4字节才生效。</p><h2 id="Refernece"><a href="#Refernece" class="headerlink" title="Refernece"></a>Refernece</h2><p><a href="https://www.jianshu.com/p/e2dfccc32c80"><strong>attribute</strong> 机制使用 - 简书</a><br><a href="https://blog.csdn.net/wangweixaut061/article/details/6549768">C语言复杂声明解析_wangweixaut061的专栏-CSDN博客_c语言复杂声明</a><br><a href="http://www.360doc.com/content/15/0305/15/14530056_452758913.shtml"><strong>attribute</strong> 你知多少？</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言typedef用法</title>
    <link href="/2022/01/07/C%E8%AF%AD%E8%A8%80typedef%E7%94%A8%E6%B3%95/"/>
    <url>/2022/01/07/C%E8%AF%AD%E8%A8%80typedef%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>typedef</code>为C语言的关键字，作用是为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char等）和自定义的数据类型（struct等）。在使用语法上类似与<code>static</code>，<code>extern</code>等。<br><code>typedef</code> 行为有点像 <code>#define</code> 宏，用其实际类型替代同义字。不同点是 <code>typedef </code>在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。</p><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><p>示例1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a; ———— 传统变量声明表达式<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">myint_t</span>; ———— 使用新的类型名<span class="hljs-keyword">myint_t</span>替换变量名a<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">myint_t</span>; ———— 在语句开头加上<span class="hljs-keyword">typedef</span>关键字，<span class="hljs-keyword">myint_t</span>就是我们定义的新类型<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> (*pfunA)(<span class="hljs-built_in">int</span> a); ———— 传统变量（函数）声明表达式<br><span class="hljs-built_in">void</span> (*PFUNA)(<span class="hljs-built_in">int</span> a); ———— 使用新的类型名PFUNA替换变量名pfunA<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">void</span> (*PFUNA)(<span class="hljs-built_in">int</span> a); ———— 在语句开头加上<span class="hljs-keyword">typedef</span>关键字，PFUNA就是我们定义的新类型<br></code></pre></td></tr></table></figure><p>促使我写这篇文章的原因不是如何去用<code>typedef</code>，而是在代码中看不懂如何简化了一个复杂声明。比如上文的</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef void (*<span class="hljs-type">PFUNA</span>)(int a);<br></code></pre></td></tr></table></figure><p>本以为是将<code>void</code>类型替换成了<code>(*PFUNA)(int a)</code>，但是语法上这明显讲不通啊。现在明白了，这就是将<code>void (*pfunA)(int a);</code>类型名换成了<code>PFUNA</code>。以后就可以用<code>PFUNA</code>来声明变量。比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PFUNA</span> arr[<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>表示声明了一个大小为<code>10</code>的数组，数组的元素是<code>PFUNA</code>类型。将<code>PFUNA</code>类型展开就是，这是一个函数指针，函数参数为<code>int</code>类型，返回值为<code>void</code>类型。完整的含义就是，<strong>声明了一个大小为<code>10</code>的数组，数组元素是函数指针，函数参数为<code>int</code>类型，返回值为<code>void</code>类型</strong>。</p><h2 id="代码简化"><a href="#代码简化" class="headerlink" title="代码简化"></a>代码简化</h2><p><code>typedef</code>可以为复杂的声明定义一个新的简单的别名。关于复杂声明，可以阅读这篇<a href="https://dunky-z.github.io/2021/10/22/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/">C语言复杂声明</a>。<br>方法是：在原来的声明里逐步用别名替换一部分复杂声明，递归操作，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例： </p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">//复杂声明</span><br>void <span class="hljs-comment">(*b[10]) (void (*)</span>());<br></code></pre></td></tr></table></figure><p>变量名为<code>b</code>，先替换右边部分括号里的，<code>pFunParam</code>为别名</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef void (*pFunParam)();<br></code></pre></td></tr></table></figure><p>再替换左边的变量<code>b</code>，<code>pFunx</code>为别名二：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef void (*pFunx)(pFunParam);<br></code></pre></td></tr></table></figure><p>简化后的声明：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pFunx <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[10]</span>;<br></code></pre></td></tr></table></figure><h2 id="减少错误"><a href="#减少错误" class="headerlink" title="减少错误"></a>减少错误</h2><p>定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 这多数不符合我们的意图，它只声明了一个指向字符变量的指针，<br><span class="hljs-regexp">//</span> 和一个字符变量；<br>char* pa, pb;<br></code></pre></td></tr></table></figure><p>以下则可行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span>* PCHAR;<br>PCHAR pa, pb;  <br></code></pre></td></tr></table></figure><p>这种用法很有用，特别是<code>char* pa, pb</code>的定义，初学者往往认为是定义了两个字符型指针，其实不是，而用<code>typedef char* PCHAR</code>就不会出现这样的问题，减少了错误的发生。</p><h2 id="直观简洁"><a href="#直观简洁" class="headerlink" title="直观简洁"></a>直观简洁</h2><p>声明<code>struct</code>新对象时，必须要带上<code>struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagPOINT1</span></span><br><span class="hljs-class"> &#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y; <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagPOINT1</span> <span class="hljs-title">p1</span>;</span><br></code></pre></td></tr></table></figure><p>在经常使用这个结构体时，就显得麻烦，可以用<code>typedef</code>简化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagPOINT</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>&#125;POINT;<br></code></pre></td></tr></table></figure><h2 id="定义平台无关的类型"><a href="#定义平台无关的类型" class="headerlink" title="定义平台无关的类型"></a>定义平台无关的类型</h2><p>当跨平台时，只要改下 <code>typedef</code> 本身就行，不用对其他源码做任何修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u_32t; <br></code></pre></td></tr></table></figure><h2 id="掩饰复合类型"><a href="#掩饰复合类型" class="headerlink" title="掩饰复合类型"></a>掩饰复合类型</h2><p><code>typedef</code> 还可以掩饰复合类型，如指针和数组。 </p><p>例如，你不用像下面这样重复定义有 81 个字符元素的数组： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> line[<span class="hljs-number">81</span>];<br></code></pre></td></tr></table></figure><p>定义一个 <code>typedef</code>，每当要用到相同类型和大小的数组时，可以这样： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> Line[<span class="hljs-number">81</span>]; <br></code></pre></td></tr></table></figure><p>此时Line类型即代表了具有81个元素的字符数组，使用方法如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Line text, secondline; <br></code></pre></td></tr></table></figure><p>同样，可以象下面这样隐藏指针语法： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> * pstr;<br></code></pre></td></tr></table></figure><p>这里将带我们到达第一个 <code>typedef</code> 陷阱。标准函数 <code>strcmp()</code>有两个<code>const char *</code>类型的参数。因此，它可能会误导人们象下面这样声明 <code>mystrcmp()</code>： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mystrcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pstr, <span class="hljs-keyword">const</span> pstr)</span></span>; <br></code></pre></td></tr></table></figure><p>用GNU的gcc和g++编译器，是会出现警告的，按照顺序，<code>const pstr</code>被解释为<code>char* const</code>（一个指向 <code>char</code> 的指针常量），两者表达的并非同一意思。为了得到正确的类型，应当如下声明： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pstr;<br></code></pre></td></tr></table></figure><h2 id="typedef-和存储类关键字"><a href="#typedef-和存储类关键字" class="headerlink" title="typedef 和存储类关键字"></a>typedef 和存储类关键字</h2><p><code>typedef</code> 就像 <code>auto</code>，<code>extern</code>，<code>mutable</code>，<code>static</code>，和 <code>register</code> 一样，是一个存储类关键字。这并不是说 <code>typedef</code> 会真正影响对象的存储特性；它只是说在语句构成上，<code>typedef</code> 声明看起来象 <code>static</code>，<code>extern</code> 等类型的变量声明。下面将带到第二个陷阱： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> FAST_COUNTER; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>编译通不过。问题出在你不能在声明中有多个存储类关键字。因为符号 <code>typedef</code> 已经占据了存储类关键字的位置，在 <code>typedef</code> 声明中不能用 <code>register</code>（或任何其它存储类关键字）。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/liitdar/article/details/80069638">typedef介绍_liitdar的博客-CSDN博客_typedef</a></p><p><a href="https://blog.csdn.net/wangqiulin123456/article/details/8284939">关于typedef的用法总结_IT民工-CSDN博客_typedef</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows批处理定时任务</title>
    <link href="/2022/01/05/Windows%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2022/01/05/Windows%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="折腾背景"><a href="#折腾背景" class="headerlink" title="折腾背景"></a>折腾背景</h2><p>一些常用的离线软件在重新安装，重装电脑或者更好环境时，调教好的配置总需要重新设置一遍，甚是麻烦。但是这些设置通常都保存在配置文件里，只要能备份好这些配置文件，下次重装后覆盖就可以恢复所需设置。</p><p>现在的问题就是如何备份这些配置文件，可以选择各类网盘，硬盘等等。但是这些多少都有点炮打蚊子，小题大做。而且定时备份也不是很方便。既然配置文件都很小，其实就是个文本文件，那有个万能免费存储地GitHub就派上用场了。我们只要把配置文件定时push到GitHub即可，以后随时可以clone下来。</p><p>首先建立一个私密仓库，用来专门存放配置文件。其次通过批处理命令，将配置文件复制到本地仓库的文件夹下。最后设置定时任务。</p><h2 id="折腾过程"><a href="#折腾过程" class="headerlink" title="折腾过程"></a>折腾过程</h2><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>这一步不用赘述了，主要就是要勾选私密仓库，保护隐私，一些配置文件可能会包含个人信息。</p><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>将仓库克隆到本地后就是个文件夹，这一步主要就是如何能把安装在不同位置的软件的配置文件，都汇集到这个仓库下。通过批处理命令可以快速，方便的完成。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-built_in">echo</span> <span class="hljs-built_in">Start</span> backup config files! # 打印这句话<br><br><span class="hljs-built_in">copy</span> D:\Tools\MouseInc\MouseInc.json  D:\Develop\fxxk-config\mouseinc # 将前者复制到后者<br><br><span class="hljs-built_in">copy</span> D:\Tools\JD\Config.ini  D:\Develop\fxxk-config\jd<br><br><span class="hljs-built_in">cd</span>  /d D:\Develop\fxxk-config # 切换目录<br><br># git推送的一些命令<br>git add .   <br>git commit -m &quot;update&quot;<br>git push<br><br># 防止窗口闪退<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>一些常用命令参考<a href="https://gist.github.com/675816156/7bcec2bc6f45faa64acdb75acfef6912">WindowDos批处理指导</a>。</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>控制面板-管理工具-任务计划程序<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201052247765.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201052247153.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201052247889.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201052248070.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201052248353.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决unable to install libpng12.so.0</title>
    <link href="/2022/01/05/%E8%A7%A3%E5%86%B3unable-to-install-libpng12-so-0/"/>
    <url>/2022/01/05/%E8%A7%A3%E5%86%B3unable-to-install-libpng12-so-0/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><code>apt</code>工具损坏了，在修复时使用了<code>sudo apt-get install -f</code>命令，中途会提示需要安装<code> libpng12-0</code>，但是始终无法安装，会提示如下错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Unpacking libpng12-0:amd64 (1.2.50-2+deb8u3) ... dpkg: error <br>processing archive libpng12-0_1.2.50-2+deb8u3_amd64.deb <br>(--install): unable to install new version of <span class="hljs-string">&#x27;/usr/lib/</span><br><span class="hljs-string">x86_64-linux-gnu/libpng12.so.0&#x27;</span>: No such file or directory <br>Errors were encountered <span class="hljs-keyword">while</span> processing: libpng12-0_1.2.50-2<br>+deb8u3_amd64.deb<br><br></code></pre></td></tr></table></figure><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>具体原因未知，网上答案众说纷纭。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>这个问题遇到的人还挺多的，解决方法也各不相同，我先说我自己最终解决的方法。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li>将软件源更换成中科院的源，使用Linux自带的<strong>软件和更新</strong>工具，具体方法参考<a href="https://dunky-z.github.io/2021/07/30/%E6%9B%B4%E6%8D%A2Ubuntu%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/">这篇文章</a>。更换完之后可以重新尝试安装，有人换源后即可成功安装。</li><li>如果未能安装成功，可能曾经手动添加过软件源，将其删除。 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 将所有内容注释</span><br>vim <span class="hljs-regexp">/etc/</span>apt/sources.list<br></code></pre></td></tr></table></figure></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li>下载已安装的库文件<code>libpng12.so.0</code>，可以从<a href="https://www.aliyundrive.com/s/pf9cAPjuqfn">该链接</a>下载。</li><li>将该文件复制到它本该安装的位置。 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> cp libpng<span class="hljs-number">12</span>.so.<span class="hljs-number">0</span> /usr/lib/x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>-linux-gnu/<br></code></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-built_in"> add-apt-repository </span>ppa:linuxuprising/libpng12<br>sudo apt update<br>sudo apt install libpng12-0<br></code></pre></td></tr></table></figure></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V入门（5）- 中断</title>
    <link href="/2022/01/04/RISC-V%E5%85%A5%E9%97%A8%EF%BC%885%EF%BC%89-%20%E4%B8%AD%E6%96%AD/"/>
    <url>/2022/01/04/RISC-V%E5%85%A5%E9%97%A8%EF%BC%885%EF%BC%89-%20%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><ul><li>本地（Local）中断<ul><li>软中断software interrupt</li><li>定时器中断timer interrupt</li></ul></li><li>全局（Global）中断<ul><li>外部中断externel interrupt</li></ul></li></ul><h2 id="RISC-V-中断编程中涉及的寄存器"><a href="#RISC-V-中断编程中涉及的寄存器" class="headerlink" title="RISC-V 中断编程中涉及的寄存器"></a>RISC-V 中断编程中涉及的寄存器</h2><table><thead><tr><th align="center">寄存器</th><th align="left">用途说明</th></tr></thead><tbody><tr><td align="center">mie <br> （Machine Interrupt Enable）</td><td align="left">用于进一步控制（打开和关闭）software interrupt/timer interrupt/external interrupt</td></tr><tr><td align="center">mip <br> （Machine Interrupt Pending）</td><td align="left">它列出目前已发生等待处理的中断。</td></tr></tbody></table><h3 id="mie-Machine-Interrupt-Enable"><a href="#mie-Machine-Interrupt-Enable" class="headerlink" title="mie(Machine Interrupt Enable)"></a>mie(Machine Interrupt Enable)</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042159268.png"></p><p>打开（1）或者关闭（0）M/S/U 模式下对应的 External/Timer/Software 中断。</p><h3 id="mip-Machine-Interrupt-Pending"><a href="#mip-Machine-Interrupt-Pending" class="headerlink" title="mip(Machine Interrupt Pending)"></a>mip(Machine Interrupt Pending)</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042200772.png"></p><p>获取当前 M/S/U 模式下对应的 External/Timer/Software 中断是否发生。</p><h2 id="中断处理流程"><a href="#中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程</h2><h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><ol><li>把 <code>mstatus</code> 的 <code>MIE</code> 值复制到 <code>MPIE</code> 中，清除 <code>mstatus</code> 中的 MIE 标志位，效果是中断被禁止。</li><li>当前的 <code>PC</code> 的下一条指令地址被复制到 <code>mepc</code> 中，同时 <code>PC</code> 被设置为<code>mtvec</code>。注意如果我们设置 <code>mtvec.MODE = vetcored</code>，<code>PC =mtvec.BASE + 4 × exception-code</code>。</li><li>根据 <code>interrupt</code> 的种类设置 <code>mcause</code>，并根据需要为 <code>mtval</code> 设置附加信息。</li><li>将 <code>trap</code> 发生之前的权限模式保存在 <code>mstatus</code> 的 <code>MPP</code> 域中，再把<code>hart</code> 权限模式更改为 <code>M</code>。</li></ol><h3 id="退出中断"><a href="#退出中断" class="headerlink" title="退出中断"></a>退出中断</h3><p>以在 M 模式下执行 mret 指令为例，会执行如下操作：</p><ul><li>当前 Hart 的权限级别 = mstatus.MPP; mstatus.MPP= U（如果 hart 不支持 U 则为 M）</li><li>mstatus.MIE = mstatus.MPIE; mstatus.MPIE = 1</li><li>pc = mepc</li></ul><h2 id="PLIC（Platform-Level-Interrupt-Controller）"><a href="#PLIC（Platform-Level-Interrupt-Controller）" class="headerlink" title="PLIC（Platform-Level Interrupt Controller）"></a>PLIC（Platform-Level Interrupt Controller）</h2><p>HART只能处理一个中断，PLIC相当于一个控制中心，它通过中断类型，优先级等等来选出一个需要处理的中断。协调多个中断，服务一个HART。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042206664.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART0_IRQ = <span class="hljs-number">10</span>, <span class="hljs-comment">//Interrupt Source ID</span><br>    RTC_IRQ = <span class="hljs-number">11</span>,<br>    VIRTIO_IRQ = <span class="hljs-number">1</span>, <span class="hljs-comment">/* 1 to 8 */</span><br>    VIRTIO_COUNT = <span class="hljs-number">8</span>,<br>    PCIE_IRQ = <span class="hljs-number">0x20</span>, <span class="hljs-comment">/* 32 to 35 */</span><br>    VIRTIO_NDEV = <span class="hljs-number">0x35</span> <span class="hljs-comment">/* Arbitrary maximum number of interrupts */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Interrupt Source ID 范围：1 ~ 53（0x35）</li><li>0 预留不用</li></ul><p><code>PLIC</code>本身也是一个外设，RISC-V 规范规定，<code>PLIC</code> 的寄存器编址采用内存映射（memory map）方式。每个寄存器的宽度为32-bit。</p><p>具体寄存器编址采用 <code>base + offset</code> 的格式，且 <code>base</code> 由各个特定<code>platform</code> 自己定义。针对 <code>QEMU-virt</code>，其 <code>PLIC</code> 的设计参考了<code>FU540-C000</code>，<code>base</code> 为 <code>0x0c000000</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> MemMapEntry virt_memmap[] = &#123;<br>    [VIRT_DEBUG] =       &#123;        <span class="hljs-number">0x0</span>,         <span class="hljs-number">0x100</span> &#125;,<br>    [VIRT_MROM] =        &#123;     <span class="hljs-number">0x1000</span>,        <span class="hljs-number">0xf000</span> &#125;,<br>    [VIRT_TEST] =        &#123;   <span class="hljs-number">0x100000</span>,        <span class="hljs-number">0x1000</span> &#125;,<br>    [VIRT_RTC] =         &#123;   <span class="hljs-number">0x101000</span>,        <span class="hljs-number">0x1000</span> &#125;,<br>    [VIRT_CLINT] =       &#123;  <span class="hljs-number">0x2000000</span>,       <span class="hljs-number">0x10000</span> &#125;,<br>    [VIRT_ACLINT_SSWI] = &#123;  <span class="hljs-number">0x2F00000</span>,        <span class="hljs-number">0x4000</span> &#125;,<br>    [VIRT_PCIE_PIO] =    &#123;  <span class="hljs-number">0x3000000</span>,       <span class="hljs-number">0x10000</span> &#125;,<br>    [VIRT_PLIC] =        &#123;  <span class="hljs-number">0xc000000</span>, VIRT_PLIC_SIZE(VIRT_CPUS_MAX * <span class="hljs-number">2</span>) &#125;,<br>    [VIRT_UART0] =       &#123; <span class="hljs-number">0x10000000</span>,         <span class="hljs-number">0x100</span> &#125;,<br>    [VIRT_VIRTIO] =      &#123; <span class="hljs-number">0x10001000</span>,        <span class="hljs-number">0x1000</span> &#125;,<br>    [VIRT_FW_CFG] =      &#123; <span class="hljs-number">0x10100000</span>,          <span class="hljs-number">0x18</span> &#125;,<br>    [VIRT_FLASH] =       &#123; <span class="hljs-number">0x20000000</span>,     <span class="hljs-number">0x4000000</span> &#125;,<br>    [VIRT_PCIE_ECAM] =   &#123; <span class="hljs-number">0x30000000</span>,    <span class="hljs-number">0x10000000</span> &#125;,<br>    [VIRT_PCIE_MMIO] =   &#123; <span class="hljs-number">0x40000000</span>,    <span class="hljs-number">0x40000000</span> &#125;,<br>    [VIRT_DRAM] =        &#123; <span class="hljs-number">0x80000000</span>,           <span class="hljs-number">0x0</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="PLIC-编程接口-寄存器"><a href="#PLIC-编程接口-寄存器" class="headerlink" title="PLIC 编程接口 - 寄存器"></a>PLIC 编程接口 - 寄存器</h2><h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><p>功能：设置某一路中断源的优先级<br>内存映射地址：<code>BASE + (interrupt-id) * 4</code></p><ul><li>每个 <code>PLIC</code> 中断源对应一个寄存器，用于配置该中断源的优先级。</li><li><code>QEMU-virt</code> 支持 7 个优先级。 0 表示对该中断源禁用中断。其余优先级，1 最低，7 最高。</li><li>如果两个中断源优先级相同，则根据中断源的 ID 值进一步区分优先级，ID 值越小的优先级越高。</li></ul><h3 id="Pending"><a href="#Pending" class="headerlink" title="Pending"></a>Pending</h3><p>功能：用于指示某一路中断源是否发生<br>内存映射地址：<code>BASE + 0x1000 + ((interrupt-id) / 32) * 4</code></p><ul><li>每个 <code>PLIC</code> 包含 2 个 32 位的 <code>Pending</code> 寄存器，因为总共有54个中断源，每一个 <code>bit</code> 对应一个中断源，如果为 1 表示该中断源上发生了中断（进入<code>Pending</code> 状态），有待 <code>hart</code> 处理，否则表示该中断源上当前无中断发生。</li><li><code>Pending</code> 寄存器中断的 <code>Pending</code> 状态可以通过<code>claim</code> 方式清除。</li><li>第一个 <code>Pending</code> 寄存器的第 0 位对应不存在的 0 号中断源，其值永远为 0。</li></ul><h3 id="Enable"><a href="#Enable" class="headerlink" title="Enable"></a>Enable</h3><p>功能：针对某个 <code>hart</code> 开启或者关闭某一路中断源<br>内存映射地址：<code>BASE + 0x2000 + (hart) * 0x80</code></p><ul><li>每个 <code>Hart</code> 有 2 个 <code>Enable</code> 寄存器 （<code>Enable1</code> 和 <code>Enable2</code>）用于针对该<code> Hart</code> 启动或者关闭某路中断源。</li><li>每个中断源对应 <code>Enable</code> 寄存器的一个 <code>bit</code>，其中<code>Enable1</code> 负责控制 1 ~ 31 号中断源；<code>Enable2</code> 负责控制 <code>32 ~ 53</code> 号中断源。 将对应的 <code>bit</code> 位设置为 1 表示使能该中断源，否则表示关闭该中断源。</li></ul><h3 id="Threshold"><a href="#Threshold" class="headerlink" title="Threshold"></a>Threshold</h3><p>功能：针对某个 hart 设置中断源优先级的阈值<br>内存映射地址：<code>BASE + 0x200000 + (hart) * 0x1000</code></p><ul><li>每个 <code>Hart</code> 有 1 个 <code>Threshold</code> 寄存器用于设置中断优先级的阈值。</li><li>所有小于或者等于（&lt;=）该阈值的中断源即使发生了也会被 <code>PLIC</code> 丢弃。特别地，当阈值为 0 时允许所有中断源上发生的中断；当阈值为 7 时丢弃所有中断源上发生的中断。</li></ul><h3 id="Claim-Complete"><a href="#Claim-Complete" class="headerlink" title="Claim/Complete"></a>Claim/Complete</h3><p>功能：如下<br>内存映射地址：<code>BASE + 0x200004 + (hart) * 0x1000</code></p><ul><li><code>Claim</code> 和 <code>Complete</code> 是同一个寄存器，每个 <code>Hart</code> 一个。</li><li>对该寄存器执行读操作称之为 <code>Claim</code>，即获取当前发生的最高优先级的中断源<code> ID</code>。<code>Claim</code> 成功后会清除对应的 <code>Pending</code> 位。</li><li>对该寄存器执行写操作称之为 <code>Complete</code>。所谓 <code>Complete </code>指的是通知<code> PLIC</code> 对该路中断的处理已经结束。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">external_interrupt_handler</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> irq = plic_claim(); <span class="hljs-comment">//</span><br><br><span class="hljs-keyword">if</span> (irq == UART0_IRQ)&#123;<br>      uart_isr();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (irq) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unexpected interrupt irq = %d\n&quot;</span>, irq);<br>&#125;<br><br><span class="hljs-keyword">if</span> (irq) &#123;<br>plic_complete(irq); <span class="hljs-comment">//</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CLINT-（Core-Local-INTerruptor）"><a href="#CLINT-（Core-Local-INTerruptor）" class="headerlink" title="CLINT （Core Local INTerruptor）"></a>CLINT （Core Local INTerruptor）</h2><p>定时器中断，属于本地中断的一种，由芯片内部<code>CLINT</code>设备产生的中断。</p><ul><li>RISC-V 规范规定，CLINT 的寄存器编址采用内存映射（memory map）方式。</li><li>具体寄存器编址采用<code>base + offset</code>的格式，且 <code>base</code> 由各个特定 <code>platform</code> 自己定义。针对 <code>QEMU-virt</code>，其 CLINT 的设计参考了 <code>SFIVE</code>，<code>base</code> 为 <code>0x2000000</code>。</li></ul><h2 id="CLINT-编程接口-寄存器-Timer-部分"><a href="#CLINT-编程接口-寄存器-Timer-部分" class="headerlink" title="CLINT 编程接口 - 寄存器 (Timer 部分)"></a>CLINT 编程接口 - 寄存器 (Timer 部分)</h2><h3 id="mtime"><a href="#mtime" class="headerlink" title="mtime"></a>mtime</h3><p>功能：<code>real-time</code> 计数器（counter）<br>内存映射地址：<code>BASE + 0xbff8</code></p><ul><li>由晶振产生，系统全局唯一，在 <code>RV32</code> 和 <code>RV64</code> 上都是 64-bit。系统必须保证该计数器的值始终按照一个固定的频率递增。</li><li>上电复位时，硬件负责将 <code>mtime</code> 的值恢复为 0。</li></ul><h3 id="mtimecmp"><a href="#mtimecmp" class="headerlink" title="mtimecmp"></a>mtimecmp</h3><p>功能：定时器比较寄存器<br>内存映射地址：<code>BASE + 0x4000 + (hart) * 8)</code></p><ul><li><p>每个 <code>hart</code> 一个 <code>mtimecmp</code> 寄存器，64-bit。</p></li><li><p>上电复位时，系统不负责设置 mt`imecmp 的初值。</p></li><li><p>当<code> mtime &gt;= mtimecmp</code> 时，<code>CLINT</code> 会产生一个 <code>timer</code> 中断。如果要使能该中断需要保证全局中断打开并且<code> mie.MTIE</code> 标志位置 <code>1</code>。</p></li><li><p>当 <code>timer</code> 中断发生时，<code>hart</code> 会设置 <code>mip.MTIP</code>，程序可以在 <code>mtimecmp</code> 中写入新的值清除<code> mip.MTIP</code>。</p></li></ul><h2 id="时钟节拍tick"><a href="#时钟节拍tick" class="headerlink" title="时钟节拍tick"></a>时钟节拍tick</h2><ul><li>操作系统中最小的时间单位；</li><li><code>Tick</code> 的单位（周期）由硬件定时器的周期决定<br>（通常为 1 ~ 100ms）；</li><li><code>Tick</code> 周期越小，也就是<code>1s</code>内产生的中断越多，系统的精度越高，但开销越大。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V入门（4）- Trap和Exception</title>
    <link href="/2021/12/30/RISC-V%E5%85%A5%E9%97%A8%EF%BC%884%EF%BC%89-%20Trap%E5%92%8CException/"/>
    <url>/2021/12/30/RISC-V%E5%85%A5%E9%97%A8%EF%BC%884%EF%BC%89-%20Trap%E5%92%8CException/</url>
    
    <content type="html"><![CDATA[<h2 id="控制流（Control-Flow）和-Trap"><a href="#控制流（Control-Flow）和-Trap" class="headerlink" title="控制流（Control Flow）和 Trap"></a>控制流（Control Flow）和 Trap</h2><ul><li>控制流（Control Flow）<br>从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列<br>$$a_0,a_1,\dotsb,a_{n-1}$$<br>每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。</li><li>异常控制流（Exceptional Control Flow）<br>系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。<ul><li>exception</li><li>interrupt</li></ul></li></ul><p>RISC-V 把 ECF 统称为 <code>Trap</code>。</p><h2 id="RISC-V-Trap-处理中涉及的寄存器"><a href="#RISC-V-Trap-处理中涉及的寄存器" class="headerlink" title="RISC-V Trap 处理中涉及的寄存器"></a>RISC-V Trap 处理中涉及的寄存器</h2><table><thead><tr><th align="center">寄存器</th><th align="left">用途说明</th></tr></thead><tbody><tr><td align="center">mtvec <br> （Machine Trap-Vector Base-Address）</td><td align="left">它保存发生异常时处理器需要跳转到的地址。</td></tr><tr><td align="center">mepc <br> （Machine Exception Program Counter）</td><td align="left">当 trap 发生时，hart 会将发生 trap 所对应的指令的地址值（pc）保存在mepc 中。</td></tr><tr><td align="center">mcause <br> （Machine Cause）</td><td align="left">当 trap 发生时，hart 会设置该寄存器通知我们 trap 发生的原因。</td></tr><tr><td align="center">mtval <br> （Machine Trap Value）</td><td align="left">它保存了 exception 发生时的附加信息：譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身，对于其他异常，它的值为0。</td></tr><tr><td align="center">mstatus <br> （Machine Status）</td><td align="left">用于跟踪和控制 hart 的当前操作状态（特别地，包括关闭和打开全局中断）。</td></tr><tr><td align="center">mscratch <br> （Machine Scratch）</td><td align="left">Machine 模式下专用寄存器，我们可以自己定义其用法，譬如用该寄存器保存当前在 hart 上运行的 task 的上下文（context）的地址。</td></tr></tbody></table><h3 id="mtvec（Machine-Trap-Vector-Base-Address）"><a href="#mtvec（Machine-Trap-Vector-Base-Address）" class="headerlink" title="mtvec（Machine Trap-Vector Base-Address）"></a>mtvec（Machine Trap-Vector Base-Address）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104173734.png"></p><ul><li>BASE：trap入口函数的基地址，必须保证四字节对齐；</li><li>MODE：进一步用于控制入口函数的地址配置方式：<ul><li>Direct，所有异常和中断发生后，PC都跳转到BASE指定的地址处；<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201041945310.png"><br>通常中断处理函数内部会有<code>switch case</code>条件语句，通过不同的中断采用不同的处理方式。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">reg_t</span> <span class="hljs-title">trap_handler</span><span class="hljs-params">(<span class="hljs-keyword">reg_t</span> epc, <span class="hljs-keyword">reg_t</span> cause)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">reg_t</span> return_pc = epc;<br>    <span class="hljs-keyword">reg_t</span> cause_code = cause &amp; <span class="hljs-number">0xfff</span>;<br>    <br>    <span class="hljs-keyword">if</span> (cause &amp; <span class="hljs-number">0x80000000</span>) &#123;<br>        <span class="hljs-comment">/* Asynchronous trap - interrupt */</span><br>        <span class="hljs-keyword">switch</span> (cause_code) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            uart_puts(<span class="hljs-string">&quot;software interruption!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>            uart_puts(<span class="hljs-string">&quot;timer interruption!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:<br>            uart_puts(<span class="hljs-string">&quot;external interruption!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            uart_puts(<span class="hljs-string">&quot;unknown async exception!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Synchronous trap - exception */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sync exceptions!, code = %d\n&quot;</span>, cause_code);<br>        panic(<span class="hljs-string">&quot;OOPS! What can I do!&quot;</span>);<br>        <span class="hljs-comment">//return_pc += 4;</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> return_pc;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>Vectored，异常的处理方式同上，但是中断的入口地址以数组方式排列；<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">trap_vector</span>:<br>    <span class="hljs-comment"># save context(registers).</span><br>    <span class="hljs-attribute">csrrw</span>t<span class="hljs-number">6</span>, mscratch, t<span class="hljs-number">6</span># swap t<span class="hljs-number">6</span> and mscratch<br>    <span class="hljs-attribute">reg_save</span> t<span class="hljs-number">6</span><br><br>    <span class="hljs-comment"># Save the actual t6 register, which we swapped into</span><br>    <span class="hljs-comment"># mscratch</span><br>    <span class="hljs-attribute">mv</span>t<span class="hljs-number">5</span>, t<span class="hljs-number">6</span># t<span class="hljs-number">5</span> points to the context of current task<br>    <span class="hljs-attribute">csrr</span>t<span class="hljs-number">6</span>, mscratch# read t<span class="hljs-number">6</span> back from mscratch<br>    <span class="hljs-attribute">sw</span>t<span class="hljs-number">6</span>, <span class="hljs-number">120</span>(t<span class="hljs-number">5</span>)# save t<span class="hljs-number">6</span> with t<span class="hljs-number">5</span> as base<br><br>    <span class="hljs-comment"># Restore the context pointer into mscratch</span><br>    <span class="hljs-attribute">csrw</span>mscratch, t<span class="hljs-number">5</span><br><br>    <span class="hljs-comment"># call the C trap handler in trap.c</span><br>    <span class="hljs-attribute">csrr</span>a<span class="hljs-number">0</span>, mepc<br>    <span class="hljs-attribute">csrr</span>a<span class="hljs-number">1</span>, mcause<br>    <span class="hljs-attribute">call</span>trap_handler<br><br>    <span class="hljs-comment"># trap_handler will return the return address via a0.</span><br>    <span class="hljs-attribute">csrw</span>mepc, a<span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># restore context(registers).</span><br>    <span class="hljs-attribute">csrr</span>t<span class="hljs-number">6</span>, mscratch<br>    <span class="hljs-attribute">reg_restore</span> t<span class="hljs-number">6</span><br><br>    <span class="hljs-comment"># return to whatever we were doing before trap.</span><br>    <span class="hljs-attribute">mret</span><br></code></pre></td></tr></table></figure>MODE可取值如下：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104174219.png"></li></ul></li></ul><p>采用<code>Vectored</code>方式效率更高。</p><h3 id="mepc（Machine-Exception-Program-Counter）"><a href="#mepc（Machine-Exception-Program-Counter）" class="headerlink" title="mepc（Machine Exception Program Counter）"></a>mepc（Machine Exception Program Counter）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201041958237.png"></p><p>当<code>trap</code>发生时，<code>pc</code>会被替换为 <code>mtvec </code>设定的地址，同时<code>hart</code> 会设置<code>mepc</code>为当前指令或者下一条指令的地址（处理异常时，mepc为当前指令的地址，处理中断时，mepc为下一条指令的地址）。</p><p>当我们需要退出<code> trap</code> 时可以调用特殊的 <code>mret</code> 指令，该指令会将<code>mepc</code>中的值恢复到<code>pc</code>中（实现返回的效果）；</p><p>在处理 <code>trap</code> 的程序中我们可以修改 <code>mepc</code> 的值达到改变<code>mret</code> 返回地址的目的。</p><h3 id="mcause（Machine-Cause）"><a href="#mcause（Machine-Cause）" class="headerlink" title="mcause（Machine Cause）"></a>mcause（Machine Cause）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042012549.png"></p><p>当 <code>trap</code> 发生时，<code>hart</code> 会设置该寄存器通知我们 <code>trap</code> 发生的原因。</p><p>最高位 <code>Interrupt</code> 为 1 时标识了当前 <code>trap</code> 为<code>interrupt</code>，否则是<code> exception</code>。</p><p>剩余的 <code>Exception Code</code> 用于标识具体的<code>interrupt</code>或者<code>exception</code> 的种类。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042014689.png"></p><h3 id="mtval（Machine-Trap-Value）"><a href="#mtval（Machine-Trap-Value）" class="headerlink" title="mtval（Machine Trap Value）"></a>mtval（Machine Trap Value）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042016744.png"></p><p>当 <code>trap</code> 发生时，除了通过<code> mcause</code> 可以获取<code> exception</code>的种类 <code>code</code> 值外，<code>hart</code> 还提供了 <code>mtval</code> 来提供<code>exception</code> 的其他信息来辅助我们执行更进一步的操作。</p><p>具体的辅助信息由特定的硬件实现定义，RISC-V 规范没有定义具体的值。但规范定义了一些行为，譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身等。</p><h3 id="mstatus（Machine-Status）"><a href="#mstatus（Machine-Status）" class="headerlink" title="mstatus（Machine Status）"></a>mstatus（Machine Status）</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042020644.png"></p><p>寄存器各个位可以大致分为以下三类，其中<code>x</code>可以为<code>U,S,M</code>。表示用户模式以及两种特权模式。</p><ul><li><p><code>xIE</code>（x=M/S/U）: 分别用于打开（1）或者关闭（0） M/S/U 模式下的全局中断。当 <code>trap</code> 发生时，<code>hart</code>会自动将 <code>xIE</code> 设置为 0。</p></li><li><p><code>xPIE</code>（x=M/S/U）:当 <code>trap</code> 发生时用于保存 <code>trap</code> 发生之前的 <code>xIE</code> 值。</p></li><li><p><code>xPP</code>（x=M/S）:当 <code>trap</code> 发生时用于保存 <code>trap</code> 发生之前的权限级别值。注意没有 <code>UPP</code>。因为异常只会从低权限向高权限跳转，通常低权限如<code>user</code>模式，会被置于上方，高权限如内核一般都会画在下方，这也解释了异常，中断处理为什么叫<code>trap</code>，因为是向下陷入的过程。</p></li><li><p>其他标志位涉及内存访问权限、虚拟内存控制等，暂不考虑。</p></li></ul><h2 id="Trap处理流程"><a href="#Trap处理流程" class="headerlink" title="Trap处理流程"></a>Trap处理流程</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将<code>trap</code>的基地址写入寄存器，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042053570.png"></p><h3 id="Top-Half"><a href="#Top-Half" class="headerlink" title="Top Half"></a>Top Half</h3><ol><li>把 <code>mstatus</code> 的 <code>MIE</code> 值复制到 <code>MPIE</code> 中，清除 <code>mstatus </code>中的 <code>MIE</code> 标志位，效果是中断被禁止。</li><li>设置<code>mepc</code>，同时<code>PC</code>被设置为 <code>mtvec</code>。（需要注意的是，对于<code>exception</code>， <code>mepc </code>指向导致异常的指令；对于 <code>interrupt</code>，它指向被中断的指令的下一条指令的位置。）</li><li>根据 <code>trap</code> 的种类设置 <code>mcause</code>，并根据需要为<code>mtval</code>设置附加信息。</li><li>将 <code>trap</code> 发生之前的权限模式保存在 <code>mstatus</code> 的 <code>MPP</code> 域中，再把<code>hart</code> 权限模式更改为 <code>M</code>（也就是说无论在任何 <code>Level</code> 下触发<code> trap</code>，<code>hart</code> 首先切换到 <code>Machine</code> 模式）。</li></ol><h3 id="Bottom-Half"><a href="#Bottom-Half" class="headerlink" title="Bottom Half"></a>Bottom Half</h3><ol><li>保存（save）当前控制流的上下文信息（利用 <code>mscratch</code>）；</li><li>调用 C 语言的 <code>trap handler</code>;</li><li>从 <code>trap handler</code> 函数返回，<code>mepc </code>的值有可能需要调整；</li><li>恢复（restore）上下文的信息；</li><li>执行<code>MRET</code>指令返回到 <code>trap</code>之前的状态。</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">trap_vector</span>:<br><span class="hljs-comment"># save context(registers).</span><br><span class="hljs-attribute">csrrw</span>t<span class="hljs-number">6</span>, mscratch, t<span class="hljs-number">6</span># swap t<span class="hljs-number">6</span> and mscratch<br><span class="hljs-attribute">reg_save</span> t<span class="hljs-number">6</span><br><br><span class="hljs-comment"># Save the actual t6 register, which we swapped into</span><br><span class="hljs-comment"># mscratch</span><br><span class="hljs-attribute">mv</span>t<span class="hljs-number">5</span>, t<span class="hljs-number">6</span># t<span class="hljs-number">5</span> points to the context of current task<br><span class="hljs-attribute">csrr</span>t<span class="hljs-number">6</span>, mscratch# read t<span class="hljs-number">6</span> back from mscratch<br><span class="hljs-attribute">sw</span>t<span class="hljs-number">6</span>, <span class="hljs-number">120</span>(t<span class="hljs-number">5</span>)# save t<span class="hljs-number">6</span> with t<span class="hljs-number">5</span> as base<br><br><span class="hljs-comment"># Restore the context pointer into mscratch</span><br><span class="hljs-attribute">csrw</span>mscratch, t<span class="hljs-number">5</span><br><br><span class="hljs-comment"># call the C trap handler in trap.c</span><br><span class="hljs-attribute">csrr</span>a<span class="hljs-number">0</span>, mepc<br><span class="hljs-attribute">csrr</span>a<span class="hljs-number">1</span>, mcause<br><span class="hljs-attribute">call</span>trap_handler<br><br><span class="hljs-comment"># trap_handler will return the return address via a0.</span><br><span class="hljs-attribute">csrw</span>mepc, a<span class="hljs-number">0</span><br><br><span class="hljs-comment"># restore context(registers).</span><br><span class="hljs-attribute">csrr</span>t<span class="hljs-number">6</span>, mscratch<br><span class="hljs-attribute">reg_restore</span> t<span class="hljs-number">6</span><br><br><span class="hljs-comment"># return to whatever we were doing before trap.</span><br><span class="hljs-attribute">mret</span><br></code></pre></td></tr></table></figure><h3 id="退出-trap-：编程调用-MRET-指令"><a href="#退出-trap-：编程调用-MRET-指令" class="headerlink" title="退出 trap ：编程调用 MRET 指令"></a>退出 trap ：编程调用 MRET 指令</h3><p>针对不同权限级别下如何退出 trap 有各自的返回指令<code>xRET</code>（x = M/S/U）。以在 <code>M</code> 模式下执行<code> mret</code> 指令为例，会执行如下操作：</p><ul><li>当前 Hart的权限级别 = mstatus.MPP；mstatus.MPP = U（如果 hart 不支持 U 则为 M）</li><li>mstatus.MIE = mstatus.MPIE; mstatus.MPIE = 1</li><li>pc = mepc<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</li></ul><p>=======</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>d653fe09ec3df98cb68542dae9cb2f376e3ef45f</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode使用sftp插件上传本地文件至局域网服务器</title>
    <link href="/2021/12/24/VSCode%E4%BD%BF%E7%94%A8sftp%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%87%B3%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2021/12/24/VSCode%E4%BD%BF%E7%94%A8sftp%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%87%B3%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>测试代码时经常需要上传文件至服务器端运行，每次上传都需要通过第三方传输工具如FileZilla，有了<code>SFTP</code>插件，可以直接在VSCode上编译成功后，一键上传本地文件。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>打开插件中心，搜索<code>sftp</code>，安装量最高的就是我们需要的插件，点击安装。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104114810.png"></p><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><p>插件安装完成后，输入快捷键<code>Control + Shift + P</code> 弹出命令面板，然后输入<code>sftp:config</code>，回车，当前工程的<code>.vscode</code>文件夹下就会自动生成一个<code>sftp.json</code>文件，我们需要在这个文件里配置的内容可以是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.xxx&quot;</span>, <span class="hljs-comment">//服务器ip</span><br>  <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp模式是22</span><br>  <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>  <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>  <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;ftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>  <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">&quot;privateKeyPath&quot;</span>: <span class="hljs-literal">null</span>,   <span class="hljs-comment">//存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件）</span><br>  <span class="hljs-attr">&quot;passphrase&quot;</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">&quot;passive&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;interactiveAuth&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;remotePath&quot;</span>: <span class="hljs-string">&quot;/root/node/build/&quot;</span>, <span class="hljs-comment">//服务器上的文件地址</span><br>  <span class="hljs-attr">&quot;context&quot;</span>: <span class="hljs-string">&quot;./server/build&quot;</span>,      <span class="hljs-comment">//本地的文件地址</span><br>  <span class="hljs-attr">&quot;uploadOnSave&quot;</span>: <span class="hljs-literal">true</span>,             <span class="hljs-comment">//监听保存并上传</span><br>  <span class="hljs-attr">&quot;syncMode&quot;</span>: <span class="hljs-string">&quot;update&quot;</span>,<br>  <span class="hljs-attr">&quot;watcher&quot;</span>: &#123;<br>    <span class="hljs-comment">//监听外部文件</span><br>    <span class="hljs-attr">&quot;files&quot;</span>: <span class="hljs-literal">false</span>,                 <span class="hljs-comment">//外部文件的绝对路径</span><br>    <span class="hljs-attr">&quot;autoUpload&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;autoDelete&quot;</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;ignore&quot;</span>: [<br>    <span class="hljs-comment">//指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹</span><br>    <span class="hljs-comment">//注意每一行后面有逗号，最后一行没有逗号</span><br>    <span class="hljs-comment">//忽略项</span><br>    <span class="hljs-string">&quot;**/.vscode/**&quot;</span>,<br>    <span class="hljs-string">&quot;**/.git/**&quot;</span>,<br>    <span class="hljs-string">&quot;**/.DS_Store&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><ul><li><p>可以直接右击文件，选择<code>Upload</code>，会将文件上传至配置好的<code>remotePath</code>。</p></li><li><p>可以<code>Control + Shift + P</code>输入<code>sftp</code>，选择想要执行的命令，命令都是字面意思，不多做解释。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104115716.png"></p></li><li><p>如果有多个IP需要配置，可以在<code>sftp.json</code>文件中，通过方括号<code>[]</code>添加。比如</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>    &#123;<br>    <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.01&quot;</span>, <span class="hljs-comment">//服务器ip</span><br>    <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp模式是22</span><br>    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>    <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;sftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>    <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>    &#125;,<br>    &#123;<br>    <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.02&quot;</span>, <span class="hljs-comment">//服务器ip</span><br>    <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp模式是22</span><br>    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>    <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;sftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>    <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>    &#125;,<br>    &#123;<br>    <span class="hljs-attr">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.xxx.03&quot;</span>, <span class="hljs-comment">//服务器ip</span><br>    <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">22</span>,               <span class="hljs-comment">//端口，sftp模式是22</span><br>    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//用户名</span><br>    <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,           <span class="hljs-comment">//密码</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;sftp&quot;</span>,       <span class="hljs-comment">//模式，sfpt 或者 ftp</span><br>    <span class="hljs-attr">&quot;agent&quot;</span>: <span class="hljs-literal">null</span>,<br>    &#125;<br>]<br></code></pre></td></tr></table></figure></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C程序内存区域分配</title>
    <link href="/2021/12/22/C%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D/"/>
    <url>/2021/12/22/C%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>ELF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>芯片启动过程全解析</title>
    <link href="/2021/12/18/%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/12/18/%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>内容总结自B站Up<a href="https://www.bilibili.com/video/BV1AN411R7Be/?spm_id_from=333.788.recommend_more_video.1">【蛋饼嵌入式】我提着鞋带拎自己？嵌入式芯片启动过程全解析，彻底理解bootloader</a></p><p>当你按下电源开关的那一瞬间，第一行代码如何在芯片上运行起来的呢？嵌入式软件代码需要一定的方式烧录到芯片中才能运行，除了物理刻蚀，无论是通讯端口的传输或者调试端口的烧录，都需要驱动程序的支持。所以说是<strong>程序烧录了程序，软件启动了软件</strong>。</p><p>这就像自己提着自己的鞋带，把自己拎起来。靴子（Boot）,鞋带（Strap），提鞋带（Loader）。这就是<code>Boot Strap Loader</code>的命名来源。通常称<code>BootLoader</code>，中文翻译为<strong>自举</strong>。</p><p><code>BootLoader</code>是芯片最初运行的代码吗？当然不是，其实每一块芯片在出厂时都在其内部的<code>ROM</code>中，烧录了它最基础的软件。CPU搬运并运行的第一条代码的默认位置，就在<code>ROM</code>的地址空间。所以一切的起始都在硬件上。</p><p>以X86架构的鼻祖8086芯片为例，按下开关的一瞬间，芯片Reset引脚接收到了电平跳变，在一连串电路的作用下，代码段寄存器<code>CS</code>恢复成<code>0XFFFF</code>，指令指针寄存器<code>IP</code>恢复成<code>0X0000</code>，他们组合成20位的地址正好等于ROM中存放第一条代码的位置。 之后取出这里的指令在跳转到别处。 </p><p>ARM架构的芯片也是类似的过程，对于32位的芯片，通电后，<code>PC</code>指针寄存器复位至零地址，随后从中断向量表表头的reset向量处获取下一个跳转的地址。这时候的代码已经以二进制形式存储，处理器可以直接搬到自身缓存中运行。有了这部分代码，就能跳转到存放有更多更复杂的代码的地址。执行硬件自检，基本的初始化操作，提供基础的输入输出支持。之后可以将操作系统从外部的存储空间加载到内部。代码就这样接力式的流转起来。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191002002.png"></p><p>所以我们把出厂就写在<code>ROM</code>里，负责启动后续用户软件的软件，称为<code>Boot ROM</code>或者<code>ROM Code</code>。现在不一定是用只读存储器（Read Only Memory），但是至少是一块掉电不易失的存储器，现在主要用<code>EEPROM</code>，<code>NOR Flash</code>。我们一般没有权限修改它，但是它也不完全是黑盒，大部分芯片都会有外部启动配置引脚，通常是以拨码快关的形式。对于PC机来说，<code>Boot ROM</code>就是我们常说的<code>BIOS</code>，它也有启动配置途径。而且提供了交互界面，用于配置部分功能和选择后续的引导设备。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191009985.png"></p><p>除了芯片自带的<code>Boot ROM</code>，还需要再给自己实际的应用程序，写一个二次引导代码或者N次引导代码，用作操作系统，文件系统加载等等。我们所说的<code>Bootloader</code>时，其实大多数就是这样的二次引导代码。</p><p>这些事其实<code>Boot ROM</code>它也能做，但是<code>Boot ROM</code>实现的功能和配置方法不灵活，但是<code>Bootloader</code>是开发人员可以而完全控制的引导代码。</p><p>在设计<code>Bootloader</code>时，<code>MCU</code>的引导步骤就开始和嵌入式Linux或者PC有所不同。这一定程度与芯片架构所采用的的存储方案有关。</p><p>先来说<code>MCU</code>，与<code>SOC</code>相比<code>MCU</code>的主要特征是单核和或多核同构的微处理器，单核或多核同构，主频 &lt; 1GHz，没有<code>MMU</code>内存管理单元，只能运行实时操作系统。常见<code>MCU</code>内核：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191051828.png"></p><p>程序的主要运行介质为<code>NOR Flash</code>，因为和<code>RAM</code>一样有分离的地址线和数据线。并且可以以字节长度精确寻址，所以程序不需要拷贝到<code>RAM</code>中运行的。</p><p>以英飞凌家的TC27x系列MCU为例，上电后的默认取址位置是<code>0x8FFF 8000</code>，这就是他的<code>Boot ROM</code>在<code>NorFlash</code>中的地址。并且这块<code>Boot Rom</code>分为<code>SSW</code>，<code>BSL</code>，<code>TF</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191055339.png"></p><p>SSW每次上电必须运行，他会根据写在<code>program flash</code>，<code>PFO</code>地址的前32byte中的配置字，来决定<code>SSW</code>执行完的跳转地址。我们可以选择一个合适的跳转地址，比如<code>0x80000020</code>，放上自己写的<code>Bootloader</code>。也可以选择不跳转，运行厂家提供的<code>Bootloader</code>（BSL）。</p><p><code>MCU</code>下的<code>Bootloader</code>主要完成的事情有以下：</p><ul><li>关闭看门狗,初始化中断和trap向量表,进行时钟和外设初始化,让芯片正常运行起来。</li><li>提供<code>CAN</code>,<code> UART</code>, <code>ETH</code>等用于通讯功能的驱动,能够接收外部数据传输请求。</li><li>提供<code>FLASH</code>的读写与擦除驱动,设计服务来对通讯端口接收到的更新代码进行校验、存储,以及跳转操作系统或后续应用程序代码。</li><li>如有必要,还会开发一些基础诊断服务,串口交互程序等等。</li></ul><p>那么运行Linux的<code>SOC</code>和PC的这一过程有何不同呢。还是先看存储方案，运行嵌入式Linux的SOC。一般将它的操作系统，文件系统和他的应用程序放在<code>nand flash</code>中。运行代码前，现将代码搬运到<code>SRAM</code>中，相比<code>MCU</code>多了一道步骤。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191101930.png"></p><p>对于<code>SOC</code>的<code>Boot ROM</code> 和PC的<code>BIOS</code>而言，他们结束运行前的最终任务，是将某些代码从<code>nand flash</code>搬运到<code>SRAM</code>中，其中最重要的内容就是<code>Boot Loader</code>。</p><p>而一般<code>SOC</code>的<code>Bootloader</code>，又分为<code>SPL</code>（Secondary Program Loader）和<code>uBOOT</code>两个阶段。<code>SPL</code>的Secondary就是相对于<code>BootROM</code>而言，他就像是接力赛中的第二棒选手。<code>SPL</code>会初始化更大空间的外部<code>DRAM</code>，再把<code>uBoot</code>搬运到外部<code>DRAM</code>中去运行。<code>uBoot</code>作为第三棒选手，开始运行它的初始化程序。之后再根据系统环境变量，将OS内核搬运到外部<code>DRAM</code>中去运行。OS再完成根文件系统的加载等等等等。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112191116399.gif"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bootloader</tag>
      
      <tag>Boot Rom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定时器Timer基础</title>
    <link href="/2021/12/15/%E5%AE%9A%E6%97%B6%E5%99%A8Timer%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/12/15/%E5%AE%9A%E6%97%B6%E5%99%A8Timer%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>定时器（Timer），又叫计时器，顾名思义，它的主要功能就是计时。因为CPU计时会占用大量资源，而定时器独立于CPU，专门用来计时。单核CPU好比人的大脑，一心不可二用，它只能知道自己当前要干什么。人可以用闹钟来提醒自己某个时间需要做某件事，而CPU就需要定时器来完成这样的工作。</p><p>当定时器被开启后，里面的计数器就以计数器时钟的频率开始运行，内部的计数值不断增加。例如一个时钟为<code>1MHz</code>的定时器，被开启后每隔<code>1us</code>计数值就会加1。但计数值不可能无限增加，最大值比如<code>65535</code>。将这个十进制数转为二进制数后应该是一个16位的二进制数<code>1111 1111 1111 1111</code>。所以我们需要有一个16位大小的存储空间来存储它。那这就是一个16位定时器。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>定时器可以让SOC在执行主程序的同时，可以(通过定时器)具有计时功能，到了一定时间(计时结束)后，定时器会产生中断提醒CPU，CPU会去处理中断并执行定时器中断的ISR，从而去执行预先设定好的事件。打个比方，定时器就像一个秘书，CPU就是老板。老板每天都有很多事要做，具体时间安排不想操心，就安排给秘书。秘书每天就是盯着表，到点就提醒老板要做某事。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>外设的工作频率是与它所挂载在的外设总线的时钟频率相同的。但工作频率不是时钟频率，工作频率到时钟频率需要进行一次分频。这个可调节的分频值使得定时器的计时更加灵活。这个分频值就是需要设置的第一个参数<strong>预分频系数</strong>。</p><p>$$<br>计数器时钟频率 = 工作频率/(预分频系数+1)<br>$$</p><p>$$<br>定时频率 = 计时器时钟频率/(自动重载值+1)<br>$$</p><p>假设定时器时钟频率为<code>1MHz</code>，那定时<code>1ms</code>该如何做？计数1000次即可。最大的计数值就是<strong>自动重载值</strong>，是我们需要设置的第二个参数。定时器被打开后，计数值就增加，一旦达到自动重载值就会出发定时器溢出中断，就实现了定时<code>1ms</code>。</p><h2 id="计数模式"><a href="#计数模式" class="headerlink" title="计数模式"></a>计数模式</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211214100956.png"></p><ul><li><p>中心计数：计数器从0开始计数到自动装入的值-1，产生一个计数器溢出事件，0然后向下计数到1并且产生一个计数器溢出事件，然后再从0开始重新计数。</p></li><li><p>向上计数：计数器从0计数到自动加载值(TIMx_ARR) ，然后重新从0开始计数并且产生一个计数器溢出事件。</p></li><li><p>向下计数：计数器从自动装入的值(TIMx_ARR)开始向下计数到0，然后从自动装入的值重新开始,并产生一个计数器向下溢出事件。</p></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211214140256.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Timer</tag>
      
      <tag>嵌入式</tag>
      
      <tag>外设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Qt-QObject::connect: Cannot queue arguments of type ‘QTextCursor’错误</title>
    <link href="/2021/12/04/%E8%A7%A3%E5%86%B3Qt-QObject-connect-Cannot-queue-arguments-of-type-%E2%80%98QTextCursor%E2%80%99%E9%94%99%E8%AF%AF/"/>
    <url>/2021/12/04/%E8%A7%A3%E5%86%B3Qt-QObject-connect-Cannot-queue-arguments-of-type-%E2%80%98QTextCursor%E2%80%99%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>我在线程中直接调用了 QTextEdit 的append函数时，候就会出现下面的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">QObject::connect: Cannot queue arguments of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;QTextCursor&#x27;</span><br> <br>(Make sure <span class="hljs-string">&#x27;QTextCursor&#x27;</span> is registered using qRegisterMetaType().)<br></code></pre></td></tr></table></figure><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>原因是**我们不能通过线程来修改UI，较为安全的修改用户界面的方式是向UI窗口发送信号(signal)**，较为简单的方式是使用 Qt threading类。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在窗口类中定义信号和槽，并声明和实现一个接口函数，这个接口函数由线程调用，在接口函数中emit一个信号，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//mainwindow.h</span><br>signals:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AppendText</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span>;<br><span class="hljs-keyword">private</span> slots:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SlotAppendText</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span>;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Append</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span>;<br><span class="hljs-comment">//mainwindow.cpp</span><br><span class="hljs-built_in">connect</span>(<span class="hljs-keyword">this</span>,<span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">AppendText</span>(QString)),<span class="hljs-keyword">this</span>,<span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">SlotAppendText</span>(QString)));<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClassName::Append</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">emit <span class="hljs-title">AppendText</span><span class="hljs-params">(<span class="hljs-string">&quot;ok: string1&quot;</span>)</span></span>;<br>&#125;<br><span class="hljs-comment">//thread.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ThreadClassName::SlotAppendText</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span><br><span class="hljs-function"></span>&#123;<br>    mText.<span class="hljs-built_in">append</span>(text);<br>&#125;<br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Linux启动出现fsck exited with status code 4</title>
    <link href="/2021/12/04/%E8%A7%A3%E5%86%B3Linux%E5%90%AF%E5%8A%A8%E5%87%BA%E7%8E%B0fsck-exited-with-status-code-4/"/>
    <url>/2021/12/04/%E8%A7%A3%E5%86%B3Linux%E5%90%AF%E5%8A%A8%E5%87%BA%E7%8E%B0fsck-exited-with-status-code-4/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112041102634.png"></p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>磁盘检测不能通过，可能是因为系统突然断电或其它未正常关闭系统导致。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>根据提示可以看到是<code>dev/sda5</code>这个扇区出现了异常，所以通过<code>fsck</code>命令修复文件系统。<a href="https://www.runoob.com/linux/linux-comm-fsck.html">详细命令解释</a>。</p><p>将<code>sda5</code>改为自己损坏的扇区即可，等待一段时间修复完成后，输入<code>exit</code>即可重启。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fsck -y  /dev/sda5<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt跨窗口，控件类传递数据</title>
    <link href="/2021/12/02/Qt%E8%B7%A8%E7%AA%97%E5%8F%A3%EF%BC%8C%E6%8E%A7%E4%BB%B6%E7%B1%BB%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/"/>
    <url>/2021/12/02/Qt%E8%B7%A8%E7%AA%97%E5%8F%A3%EF%BC%8C%E6%8E%A7%E4%BB%B6%E7%B1%BB%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p>本文基于<a href="https://blog.csdn.net/shihoongbo/article/details/48681979">【Qt】窗体间传递数据（跨控件跨类），三种情况与处理方法</a></p><p>已知三个窗体，A为B C的父控件，B与C互为兄弟控件<br>那么参数传递分三种情况：</p><ol><li>B向A（C向A）传递参数</li><li>B向C（C向B）传递参数</li><li>A向B（A向C）传递参数</li></ol><p>三个空间关系模型参考如下，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211208122116.png"></p><h2 id="B向A（C向A）传递参数"><a href="#B向A（C向A）传递参数" class="headerlink" title="B向A（C向A）传递参数"></a>B向A（C向A）传递参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//B.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>signals:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toA</span><span class="hljs-params">([ParamList])</span></span>;<br>&#125;<br><br><span class="hljs-comment">//B.cpp</span><br>B::<span class="hljs-built_in">B</span>()<br>&#123;<br>    <span class="hljs-function">emit <span class="hljs-title">toA</span><span class="hljs-params">([ParamList])</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//A.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>   B *b;<br><span class="hljs-keyword">private</span> slots:<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fromB</span><span class="hljs-params">([ParamList])</span></span>;<br>&#125;<br><br><span class="hljs-comment">//A.cpp</span><br>A::<span class="hljs-built_in">A</span>()<br>&#123;<br>    b = <span class="hljs-keyword">new</span> B;<br>    <span class="hljs-built_in">connect</span>(b, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">toA</span>([ParamList])), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">fromB</span>([ParamList])));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A::fromB</span><span class="hljs-params">([ParamList])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//get[ParamList]</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B向C（C向B）传递参数"><a href="#B向C（C向B）传递参数" class="headerlink" title="B向C（C向B）传递参数"></a>B向C（C向B）传递参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//A.h</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  B *b;<br>  C *c;<br>&#125;<br><br><span class="hljs-comment">//A.cpp</span><br>A::<span class="hljs-built_in">A</span>()<br>&#123;<br>  b = <span class="hljs-keyword">new</span> B;<br>  c = <span class="hljs-keyword">new</span> C;<br>  <span class="hljs-built_in">connect</span>(b, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">toC</span>([ParamList]), c, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">fromB</span>([ParamList])));<br>&#125;<br><br><span class="hljs-comment">//B.h</span><br>class B<br>&#123;<br>signals:<br> <span class="hljs-keyword">void</span> <span class="hljs-built_in">toC</span>([ParamList]);<br>&#125;<br><br><span class="hljs-comment">//B.cpp</span><br>B::<span class="hljs-built_in">B</span>()<br>&#123;<br>  emit <span class="hljs-built_in">toC</span>([ParamList]);<br>&#125;<br><br><span class="hljs-comment">//C.h</span><br>class C<br>&#123;<br><span class="hljs-keyword">private</span> slots:<br>  <span class="hljs-keyword">void</span> <span class="hljs-built_in">fromB</span>([ParamList]);<br>&#125;<br><br><span class="hljs-comment">//C.cpp</span><br><span class="hljs-keyword">void</span> C::<span class="hljs-built_in">fromB</span>([ParamList])<br>&#123;<br><span class="hljs-comment">//get[ParamList]</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A向B（A向C）传递参数"><a href="#A向B（A向C）传递参数" class="headerlink" title="A向B（A向C）传递参数"></a>A向B（A向C）传递参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//B.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fromA</span><span class="hljs-params">([ParamList])</span></span>;<br>&#125; <br><br><span class="hljs-comment">//B.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B::fromA</span><span class="hljs-params">([ParamList])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//get[ParamList]</span><br>&#125;<br><br><span class="hljs-comment">//A.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>   B *b;<br>&#125;<br><br><span class="hljs-comment">//A.cpp</span><br>A:<span class="hljs-built_in">A</span>()<br>&#123;<br>    b = <span class="hljs-keyword">new</span> B;<br>    b-&gt;<span class="hljs-built_in">fromA</span>([ParamList]);<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clang-Format格式化代码</title>
    <link href="/2021/12/01/Clang-Format%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/12/01/Clang-Format%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install clang-format<br></code></pre></td></tr></table></figure><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h3><p>Linux可以直接命令行，使用以LLVM代码风格格式化<code>main.cpp</code>, 结果直接写到<code>main.cpp</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang g-format -i main.cpp -style=LLVM<br></code></pre></td></tr></table></figure><h3 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h3><p>如果每次编码都命令行执行一遍那也太麻烦了，而且每次修改也不止一个文件。最好的方式就是每次保存文件时自动格式化。比如VSCode已经内置了<code>Clang-Format</code>稍作配置即可实现，接下来介绍几种常见IDE如何配置<code>Clang-Format</code>。</p><h4 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h4><p>VSCode最常用，因为内置了<code>Clang-Format</code>也最容易配置。</p><ul><li>安装<code>C/C++</code>插件，<code>Ctrl+Shift+X</code>打开应用商店，搜索<code>C/C++</code>找到下图插件，安装后会自动安装<code>Clang-Format</code>程序，无需单独下载。默认安装路径为:<br><code>C:\Users\(你的用户名)\.vscode\extensions\ms-vscode.cpptools-1.7.1\LLVM\bin\clang-format.exe</code>。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012311818.png"></li><li>打开设置页面（左下角齿轮-设置），搜索<code>format</code>，勾选<code>Format On Save</code>，每次保存文件时自动格式化文档。下方的设置是决定每次格式化是整个文档，还是做过修改的内容。默认是<code>file</code>，对整个文档进行格式化。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012304766.png"></li><li>仍在设置页面搜索<code>Clang</code>，配置如下。<code>.clang-format</code>文件最后详解。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012321838.png"></li><li>效果图<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112012327867.gif"></li></ul><h4 id="QtCreator"><a href="#QtCreator" class="headerlink" title="QtCreator"></a>QtCreator</h4><ul><li>安装<code>Beautifier</code>插件：帮助（<code>Help</code>）-关于插件（<code>About Plugins</code>）- <code>Beautifier</code>勾选，重启QtCreator。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202183720.png"></li><li>工具（Tool）- <code>Beautifier</code>，配置如图。该配置，保存文档时自动格式化，并选择<code>Clang-Format</code>作为格式化工具。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202184119.png"><br>配置<code>Clang-Format</code>程序路径，如果开头已经<code>apt install</code>安装过，这里会自动补全。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202184247.png"></li><li><code>Use predefined style</code>可以选择内置的一些代码风格，如<code>LLVM</code>，<code>Google</code>等。</li><li><code>Use customized style</code>使用自定义的一些代码风格。点击添加（<code>Add</code>）将配置文件粘贴进去即可，具体配置文件见最后。</li><li>别忘了点击<code>OK</code>保存。</li></ul><h4 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h4><ul><li>安装<code>cppstyle</code>插件：Help - Eclipse Marketplace - 搜索<code>cppstyle</code>。</li><li>下载<code>cpplint</code>。<br>  可以去github上下载<a href="https://github.com/google/styleguide">cpplint的源码</a>，下载完之后解压放到某个目录下。</li><li>在<code>Window</code> - <code>Preferences</code> - <code>C/C++</code> - <code>CppStyle</code>页面把<code>clang-format</code>的路径添加进去，然后把<code>cpplint</code>的目录指向刚才下载的<code>styleguide</code>目录下的<code>cpplint/cpplint.py</code>就可以了。勾选下面的<code>Enable cpplint</code>，<code>Run clang-format on file save</code>，然后点击<code>Apply and Close</code>保存修改并退出。如下图所示。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211202190912.png"></li><li>此时再保存代码，将会出现如下错误，因为我们还未给当前项目编写配置文件<code>.clang-format</code>。将最后一章提到的配置文件放到当前项目的下即可，程序会自动搜索。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Cannot find .clang-format or _clang-format configuration file under any level parent directories of path.<br>Clang-format will default to Google style.<br></code></pre></td></tr></table></figure></li></ul><h2 id="配置简介"><a href="#配置简介" class="headerlink" title="配置简介"></a>配置简介</h2><p>上文多次提到了<code>.clang-format</code>配置文件，该文件决定了代码如何格式化，现在来介绍如何使用该文件。</p><h3 id="导出-clang-format文件"><a href="#导出-clang-format文件" class="headerlink" title="导出.clang-format文件"></a>导出<code>.clang-format</code>文件</h3><p>如果重新编写一份配置文件，需要考虑的东西太多，<code>clang-format</code>内置了一些常见风格，我们可以根据已有的配置文件稍作修改，形成自己的代码风格。所以我们先导出一份内置的配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang-format -style=可选格式名 -dump-config &gt; .clang-format<br><span class="hljs-comment"># 可选格式最好写预设那那几个写最接近你想要的格式. 比如我想要接近google C++ style的。 我就写-style=google</span><br></code></pre></td></tr></table></figure><h3 id="各个选项的含义"><a href="#各个选项的含义" class="headerlink" title="各个选项的含义"></a>各个选项的含义</h3><p>这里给出了配置的含义，感兴趣也可以查看官方文档，还提供了一些有案例，描述更清晰。</p><p>一些比较明显的代码分格区别</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># 括号是分行，还是不分行，只有当BreakBeforeBraces设置为Custom时才有效<br>BraceWrapping:<br>  AfterCaseLabel:  <span class="hljs-literal">true</span><br>  # <span class="hljs-keyword">class</span>定义后面<br>  <span class="hljs-symbol">AfterClass:      <span class="hljs-symbol">true</span></span><br>  # 控制语句后面<br>  <span class="hljs-symbol">AfterControlStatement: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterEnum:       <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterFunction:   <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterNamespace:  <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterObjCDeclaration: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterStruct:     <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterUnion:      <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">AfterExternBlock: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">BeforeCatch:     <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">BeforeElse:      <span class="hljs-symbol">true</span></span><br>  # 缩进大括号，<span class="hljs-symbol">if</span> <span class="hljs-symbol">else</span>语句后面的括号缩进<br>  <span class="hljs-symbol">IndentBraces:    <span class="hljs-symbol">false</span></span><br>  <span class="hljs-symbol">SplitEmptyFunction: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">SplitEmptyRecord: <span class="hljs-symbol">true</span></span><br>  <span class="hljs-symbol">SplitEmptyNamespace: <span class="hljs-symbol">true</span></span><br><span class="hljs-symbol">BreakBeforeBinaryOperators: <span class="hljs-symbol">None</span></span><br><span class="hljs-symbol">BreakBeforeBraces: <span class="hljs-symbol">Custom</span></span><br><br># <span class="hljs-symbol">tab</span>宽度<br><span class="hljs-symbol">TabWidth:<span class="hljs-symbol">4</span></span><br><br># 换行缩进字符数<br><span class="hljs-symbol">IndentWidth:     <span class="hljs-symbol">4</span></span><br><br># 宏定义对齐<br><span class="hljs-symbol">AlignConsecutiveMacros: <span class="hljs-symbol">AcrossEmptyLinesAndComments</span></span><br></code></pre></td></tr></table></figure><p>基于LLVM代码风格修改的个人使用版本：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">Language:</span>        <span class="hljs-string">Cpp</span><br><span class="hljs-comment"># BasedOnStyle:  LLVM</span><br><span class="hljs-attr">AccessModifierOffset:</span> <span class="hljs-number">-2</span><br><span class="hljs-attr">AlignAfterOpenBracket:</span> <span class="hljs-string">Align</span><br><span class="hljs-comment"># 宏定义对齐</span><br><span class="hljs-attr">AlignConsecutiveMacros:</span> <span class="hljs-string">AcrossEmptyLinesAndComments</span><br><span class="hljs-attr">AlignConsecutiveAssignments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignConsecutiveDeclarations:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignConsecutiveBitFields:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignEscapedNewlines:</span> <span class="hljs-string">Right</span><br><span class="hljs-attr">AlignOperands:</span>   <span class="hljs-literal">true</span><br><span class="hljs-attr">AlignTrailingComments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowAllArgumentsOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowAllConstructorInitializersOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">AllowShortBlocksOnASingleLine:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 是否允许短方法单行，只有一行的函数将不会分行，直接写在函数名后</span><br><span class="hljs-attr">AllowShortFunctionsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">AllowShortLambdasOnASingleLine:</span> <span class="hljs-string">All</span><br><span class="hljs-attr">AllowShortIfStatementsOnASingleLine:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">AllowShortLoopsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">AlwaysBreakAfterDefinitionReturnType:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">AlwaysBreakAfterReturnType:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">AlwaysBreakTemplateDeclarations:</span> <span class="hljs-string">MultiLine</span><br><span class="hljs-attr">BinPackArguments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">BinPackParameters:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 括号是分行，还是不分行，只有当BreakBeforeBraces设置为Custom时才有效</span><br><span class="hljs-attr">BraceWrapping:</span><br>  <span class="hljs-attr">AfterCaseLabel:</span>  <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># class定义后面</span><br>  <span class="hljs-attr">AfterClass:</span>      <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 控制语句后面</span><br>  <span class="hljs-attr">AfterControlStatement:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterEnum:</span>       <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterFunction:</span>   <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterNamespace:</span>  <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterObjCDeclaration:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterStruct:</span>     <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterUnion:</span>      <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterExternBlock:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">BeforeCatch:</span>     <span class="hljs-literal">true</span><br>  <span class="hljs-attr">BeforeElse:</span>      <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 缩进大括号</span><br>  <span class="hljs-attr">IndentBraces:</span>    <span class="hljs-literal">false</span><br>  <span class="hljs-attr">SplitEmptyFunction:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">SplitEmptyRecord:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">SplitEmptyNamespace:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">BreakBeforeBinaryOperators:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">BreakBeforeBraces:</span> <span class="hljs-string">Custom</span><br><span class="hljs-attr">BreakBeforeInheritanceComma:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">BreakInheritanceList:</span> <span class="hljs-string">BeforeColon</span><br><span class="hljs-attr">BreakBeforeTernaryOperators:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">BreakConstructorInitializersBeforeComma:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">BreakConstructorInitializers:</span> <span class="hljs-string">BeforeColon</span><br><span class="hljs-attr">BreakAfterJavaFieldAnnotations:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">BreakStringLiterals:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">ColumnLimit:</span>     <span class="hljs-number">100</span><br><span class="hljs-attr">CommentPragmas:</span>  <span class="hljs-string">&#x27;^ IWYU pragma:&#x27;</span><br><span class="hljs-attr">CompactNamespaces:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">ConstructorInitializerAllOnOneLineOrOnePerLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">ConstructorInitializerIndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">ContinuationIndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">Cpp11BracedListStyle:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">DeriveLineEnding:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">DerivePointerAlignment:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">DisableFormat:</span>   <span class="hljs-literal">false</span><br><span class="hljs-attr">ExperimentalAutoDetectBinPacking:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">FixNamespaceComments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">ForEachMacros:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">foreach</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Q_FOREACH</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">BOOST_FOREACH</span><br><span class="hljs-attr">IncludeBlocks:</span>   <span class="hljs-string">Preserve</span><br><span class="hljs-attr">IncludeCategories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span>           <span class="hljs-string">&#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span><br>    <span class="hljs-attr">Priority:</span>        <span class="hljs-number">2</span><br>    <span class="hljs-attr">SortPriority:</span>    <span class="hljs-number">0</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span>           <span class="hljs-string">&#x27;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#x27;</span><br>    <span class="hljs-attr">Priority:</span>        <span class="hljs-number">3</span><br>    <span class="hljs-attr">SortPriority:</span>    <span class="hljs-number">0</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span>           <span class="hljs-string">&#x27;.*&#x27;</span><br>    <span class="hljs-attr">Priority:</span>        <span class="hljs-number">1</span><br>    <span class="hljs-attr">SortPriority:</span>    <span class="hljs-number">0</span><br><span class="hljs-attr">IncludeIsMainRegex:</span> <span class="hljs-string">&#x27;(Test)?$&#x27;</span><br><span class="hljs-attr">IncludeIsMainSourceRegex:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">IndentCaseLabels:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">IndentGotoLabels:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">IndentPPDirectives:</span> <span class="hljs-string">None</span><br><span class="hljs-comment"># 换行缩进字符数</span><br><span class="hljs-attr">IndentWidth:</span>     <span class="hljs-number">4</span><br><span class="hljs-attr">IndentWrappedFunctionNames:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">JavaScriptQuotes:</span> <span class="hljs-string">Leave</span><br><span class="hljs-attr">JavaScriptWrapImports:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">KeepEmptyLinesAtTheStartOfBlocks:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">MacroBlockBegin:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">MacroBlockEnd:</span>   <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">MaxEmptyLinesToKeep:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">NamespaceIndentation:</span> <span class="hljs-string">None</span><br><span class="hljs-attr">ObjCBinPackProtocolList:</span> <span class="hljs-string">Auto</span><br><span class="hljs-attr">ObjCBlockIndentWidth:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">ObjCSpaceAfterProperty:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">ObjCSpaceBeforeProtocolList:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">PenaltyBreakAssignment:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="hljs-number">19</span><br><span class="hljs-attr">PenaltyBreakComment:</span> <span class="hljs-number">300</span><br><span class="hljs-attr">PenaltyBreakFirstLessLess:</span> <span class="hljs-number">120</span><br><span class="hljs-attr">PenaltyBreakString:</span> <span class="hljs-number">1000</span><br><span class="hljs-attr">PenaltyBreakTemplateDeclaration:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">PenaltyExcessCharacter:</span> <span class="hljs-number">1000000</span><br><span class="hljs-attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="hljs-number">60</span><br><span class="hljs-attr">PointerAlignment:</span> <span class="hljs-string">Right</span><br><span class="hljs-attr">ReflowComments:</span>  <span class="hljs-literal">true</span><br><span class="hljs-attr">SortIncludes:</span>    <span class="hljs-literal">true</span><br><span class="hljs-attr">SortUsingDeclarations:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceAfterCStyleCast:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceAfterLogicalNot:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceAfterTemplateKeyword:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeAssignmentOperators:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeCpp11BracedList:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceBeforeCtorInitializerColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeInheritanceColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceBeforeParens:</span> <span class="hljs-string">ControlStatements</span><br><span class="hljs-attr">SpaceBeforeRangeBasedForLoopColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpaceInEmptyBlock:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceInEmptyParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesBeforeTrailingComments:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">SpacesInAngles:</span>  <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInConditionalStatement:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInContainerLiterals:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">SpacesInCStyleCastParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpacesInSquareBrackets:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">SpaceBeforeSquareBrackets:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">Standard:</span>        <span class="hljs-string">Latest</span><br><span class="hljs-attr">StatementMacros:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Q_UNUSED</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">QT_REQUIRE_VERSION</span><br><span class="hljs-attr">TabWidth:</span>        <span class="hljs-number">8</span><br><span class="hljs-attr">UseCRLF:</span>         <span class="hljs-literal">false</span><br><span class="hljs-attr">UseTab:</span>          <span class="hljs-string">Never</span><br><span class="hljs-string">...</span><br><br></code></pre></td></tr></table></figure><h3 id="格式化最新的commit代码"><a href="#格式化最新的commit代码" class="headerlink" title="格式化最新的commit代码"></a>格式化最新的commit代码</h3><p><code>clang-format</code>还提供一个<code>clang-format-diff.py</code>脚本，用来格式化<code>patch</code>，<code>code review</code>提交代码前，跑一遍下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 格式化最新的commit，并直接在原文件上修改<br>git diff -U0 HEAD^ | clang-format-diff.py -i -p1<br></code></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="如何看懂官方文档并编写配置文件"><a href="#如何看懂官方文档并编写配置文件" class="headerlink" title="如何看懂官方文档并编写配置文件"></a>如何看懂官方文档并编写配置文件</h4><p><a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">官方文档</a>里有各种设置的示例代码，即使不知道想要的格式化是哪个配置参数，翻一翻官方文档是示例大概率能找到。那么找到了想要的配置参数，如何在文件里配置呢？</p><p>以宏定义对齐为例。我们想要宏定义的值保持对齐的状态，如下一节图片所示。可以翻一遍官方文档，可以发现这个示例代码对应的参数可能是我们想要的，<code>AlignConsecutiveMacros </code>翻译为<strong>对齐连续的宏定义</strong>。那应该八九不离十了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112202021134.png"></p><p>找到了参数如何编写配置文件呢？可以继续看这个参数下面的更多示例，每一个示例都对应一个配置可能值<code>Possible values</code>。</p><ul><li><p><code>ACS_None</code> (in configuration: <code>None</code>)<br>Do not align macro definitions on consecutive lines.<br><code>ACS_None</code>为这个配置的缩写，<code>None</code>表示在配置文件里的值。该配置表示不对宏定义进行对齐操作，在配置文件里可以添加如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">AlignConsecutiveMacros:</span> None<br></code></pre></td></tr></table></figure></li><li><p><code>ACS_Consecutive</code> (in configuration: <code>Consecutive</code>)<br>Align macro definitions on consecutive lines. This will result in formattings like:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SHORT_NAME       42</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LONGER_NAME      0x007f</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EVEN_LONGER_NAME (2)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> foo(x) (x * x)</span><br><span class="hljs-comment">/* some comment */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bar(y, z) (y + z)</span><br></code></pre></td></tr></table></figure><p><code>ACS_Consecutive</code>为这个配置的缩写，<code>Consecutive</code>表示在配置文件里的值。该配置表示对连续的宏定义进行对齐，在配置文件里可以添加如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">AlignConsecutiveMacros:</span> Consecutive<br></code></pre></td></tr></table></figure></li></ul><h4 id="宏定义对齐失效"><a href="#宏定义对齐失效" class="headerlink" title="宏定义对齐失效"></a>宏定义对齐失效</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 宏定义对齐</span><br><span class="hljs-symbol">AlignConsecutiveMacros:</span> AcrossEmptyLinesAndComments<br></code></pre></td></tr></table></figure><p>使用宏定义对齐更详细的配置，可以<a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">参考官方文档</a>。使用该配置一定要使用等宽的字体，否则配置生效但是显示不正确。<br>比如我是用<strong>微软雅黑</strong>字体作为编码字体，因为该字体每个字符不等宽，导致格式化正确，但是显示不正确。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112201954096.png"></p><p>如果将字体换位等宽字体如常用的<strong>Consolas</strong>，就可以正常显示。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202112201958869.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Qt</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《代码整洁之道》读书笔记</title>
    <link href="/2021/11/29/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/11/29/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="代码整洁之道"><a href="#代码整洁之道" class="headerlink" title="代码整洁之道"></a>代码整洁之道</h1><h2 id="整洁代码"><a href="#整洁代码" class="headerlink" title="整洁代码"></a>整洁代码</h2><h3 id="整洁之道"><a href="#整洁之道" class="headerlink" title="整洁之道"></a>整洁之道</h3><ul><li><p>代码是我们最终用来表达需求的那种语言，代码永存；</p></li><li><p>时时保持代码整洁，稍后等于永不（<strong>Later equals never</strong>）；</p></li><li><p>整洁代码力求集中，每个函数、每个类和每个模块都全神贯注于一件事；</p></li><li><p>整洁代码简单直接，从不隐藏设计者的意图；</p></li><li><p>整洁代码应当有单元测试和验收测试。它使用有意义的命名，代码通过其字面表达含义；</p></li><li><p>消除重复代码，提高代码表达力。  </p></li></ul><h2 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><h3 id="避免误导"><a href="#避免误导" class="headerlink" title="避免误导"></a>避免误导</h3><ul><li><p>“一组账号”别用<code>accountList</code>表示，<code>List</code>对程序员有特殊含义，可以用 <code>accountGroup</code>、<code>bunchOfAccounts</code>、甚至是<code>accounts</code>；</p></li><li><p><strong>不使用区别较小的名称</strong>，<code>ZYXControllerForEfficientHandlingOfStrings</code>和 <code>ZYXControllerForEfficientStorageOfStrings</code>难以辨别；</p></li><li><p>不使用小写l、大写O作变量名，看起来像常量1、0。</p></li></ul><h3 id="做有意义的区分"><a href="#做有意义的区分" class="headerlink" title="做有意义的区分"></a>做有意义的区分</h3><ul><li><p><strong>不以数字系列命名</strong>(a1、a2、a3)，按照真实含义命名；</p></li><li><p><strong><code>Product/ProductInfo/ProductData</code></strong> 意思无区别，只统一用一个；</p></li><li><p>别写冗余的名字，变量名别带<code>variable</code>、表名别带<code>table</code>。</p></li></ul><h3 id="使用读得出来的名称"><a href="#使用读得出来的名称" class="headerlink" title="使用读得出来的名称"></a>使用读得出来的名称</h3><ul><li> <code>genymdhms</code>（生成日期，年、月、日、时、分、秒）肯定不如<code>generation timestamp</code>（生成时间戳）方便交流。</li></ul><h3 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a>使用可搜索的名称</h3><ul><li>单字母名称和数字常量很难在上下文中找出。名称长短应与其作用域大小相对应，越是频繁出现的变量名称得越容易搜索(越长)。</li></ul><h3 id="命名时避免使用编码"><a href="#命名时避免使用编码" class="headerlink" title="命名时避免使用编码"></a>命名时避免使用编码</h3><ul><li><p>把类型和作用域编码进名称里增加了解码负担。意味着新人除了了解代码逻辑之外，还需要学习这种<strong>编码语言</strong>；</p></li><li><p>别使用<strong>匈牙利语标记法</strong>(格式：**[Prefix]-BaseTag-Name** 其中BaseTag是数据类型的缩写，Name是变量名字)，纯属多余。例如，<code>szCmdLine</code>的前缀<code>sz</code>表示“以零结束的字符串”；</p></li><li><p>不必用<code>m_</code>前缀来表明成员变量；</p></li><li><p>接口和实现别在名称中编码。接口名<code>IShapeFactory</code>的<strong>前导”I”是废话</strong>。如果接口和实现必须选一个编码，宁可选实现，<code>ShapeFactoryImp</code>都比对接口名称编码来的好。</p></li></ul><h3 id="避免思维映射"><a href="#避免思维映射" class="headerlink" title="避免思维映射"></a>避免思维映射</h3><ul><li><p>不应当让读者在脑中把你的名称翻译为他们熟知的名称。例如，循环计数器自然有可能被命名为<code>i</code>或<code>j</code>或<code>k</code>，但千万别用字母<code>l</code>；</p></li><li><p>专业程序员了解，<strong>明确是王道</strong>，编写能方便他人理解的代码。</p></li></ul><h3 id="类名、方法名"><a href="#类名、方法名" class="headerlink" title="类名、方法名"></a>类名、方法名</h3><ul><li><strong>类名应当是名词</strong>或名词短语，<strong>方法名应当是动词</strong>或动词短语。</li></ul><h3 id="命名不要耍宝幽默"><a href="#命名不要耍宝幽默" class="headerlink" title="命名不要耍宝幽默"></a>命名不要耍宝幽默</h3><ul><li>言到意到，意到言到，不要在命名上展示幽默感。</li></ul><h3 id="每个概念用一个词"><a href="#每个概念用一个词" class="headerlink" title="每个概念用一个词"></a>每个概念用一个词</h3><ul><li><code>fetch</code>、<code>retrieve</code>、<code>get</code>约定一个一直用即可。</li></ul><h3 id="尽管使用计算机科学术语"><a href="#尽管使用计算机科学术语" class="headerlink" title="尽管使用计算机科学术语"></a>尽管使用计算机科学术语</h3><ul><li>只有程序员才会读你的代码，不需要按照问题所在邻域取名称。</li></ul><h3 id="别用双关语"><a href="#别用双关语" class="headerlink" title="别用双关语"></a>别用双关语</h3><ul><li><code>add</code>方法一般语义是：根据两个值获得一个新的值。<strong>如果要把单个值加入到某个集合</strong>，用<code>insert</code>或<code>append</code>命名更好，这里用<code>add</code>就是双关语了。</li></ul><h3 id="添加有意义的语境"><a href="#添加有意义的语境" class="headerlink" title="添加有意义的语境"></a>添加有意义的语境</h3><ul><li>很少有名称能自我说明，<strong>需要用良好命名的类、函数、或者命名空间来放置名称</strong>，给读者提供语境，如果做不到的话，给名称添加前缀就是最后一招了。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="越短越好"><a href="#越短越好" class="headerlink" title="越短越好"></a>越短越好</h3><ul><li><p>短小，20行封顶；</p></li><li><p><code>if/else/while</code>语句的代码块应该只有一行，该行应该是一个函数调用语句；</p></li><li><p>函数的缩进层级不应该多于一层或两层。</p></li></ul><h3 id="一个函数只做一件事"><a href="#一个函数只做一件事" class="headerlink" title="一个函数只做一件事"></a>一个函数只做一件事</h3><ul><li><p>如果函数只是做了该函数名下<strong>同一抽象层上的步骤</strong>，则函数只做了一件事；</p></li><li><p> 要判断函数是否不止做了一件事，就是要看是否能<strong>再拆出一个函数</strong>；</p></li></ul><h3 id="每个函数一个抽象层级"><a href="#每个函数一个抽象层级" class="headerlink" title="每个函数一个抽象层级"></a>每个函数一个抽象层级</h3><ul><li><strong>向下规则</strong>：让代码拥有自顶向下的阅读顺序。每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能循抽象层级向下阅读了。</li></ul><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><ul><li><strong>把switch埋在较低的抽象层级</strong>，一般可以放在抽象工厂底下，用于创建多态对象。</li></ul><h3 id="使用描述性的名称"><a href="#使用描述性的名称" class="headerlink" title="使用描述性的名称"></a>使用描述性的名称</h3><ul><li><p>函数越短小、功能越集中，就越便于取个好名字；</p></li><li><p>别害怕长名称，<strong>长而具有描述性的名称，要比短而令人费解的名称好，要比描述性的长注释好；</strong></p></li><li><p>别害怕花时间取名字。</p></li></ul><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li><p><strong>参数越少越好</strong>，0参数最好，尽量避免用三个以上参数；</p></li><li><p>参数越多，编写组合参数的测试用例就越困难；</p></li><li><p><strong>别用标识参数</strong>，向函数传入<code>bool</code>值是不好的，这意味着函数不止做一件事。可以将此函数拆成两个；</p></li><li><p>如果函数需要<strong>两个、三个或者三个以上参数</strong>，就说明其中<strong>一些参数应该封装成类了</strong>；</p></li><li><p><strong>将参数的顺序编码进函数名</strong>，减轻记忆参数顺序的负担，例如 <code>assertExpectedEqualsActual(expected, actual)</code>。</p></li></ul><h3 id="副作用-函数在正常工作任务之外对外部环境所施加的影响"><a href="#副作用-函数在正常工作任务之外对外部环境所施加的影响" class="headerlink" title="副作用(函数在正常工作任务之外对外部环境所施加的影响)"></a>副作用(函数在正常工作任务之外对外部环境所施加的影响)</h3><ul><li><p>检查密码并且初始化<code>session</code>的方法命名为<code>checkPasswordAndInitializeSession</code>而非 <code>checkPassword</code>，<strong>即使违反单一职责原则也不要有副作用</strong>；</p></li><li><p>避免使用”输出参数”，<strong>如果函数必须修改某种状态，就修改所属对象的状态吧</strong>。</p></li></ul><h3 id="设置-写-和查询-读-分离"><a href="#设置-写-和查询-读-分离" class="headerlink" title="设置(写)和查询(读)分离"></a>设置(写)和查询(读)分离</h3><ul><li>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;unclebob&quot;</span>)) <br>&#123; <br>    ... <br>&#125;<br></code></pre></td></tr></table></figure><p>  含义模糊不清。应该改为:</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (attributeExists(<span class="hljs-string">&quot;username&quot;</span>)) <br>&#123; <br>    setAttribute(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;unclebob&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="使用异常代替返回错误码"><a href="#使用异常代替返回错误码" class="headerlink" title="使用异常代替返回错误码"></a>使用异常代替返回错误码</h3><ul><li><p><strong>返回错误码</strong>会要求调用者立刻处理错误，从而<strong>引起深层次的嵌套结构</strong>；</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (deletePate(page) == E_OK) <br>&#123;<br>    <span class="hljs-keyword">if</span> (xxx() == E_OK) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (yyy() == E_OK) <br>        &#123;<br>            <span class="hljs-built_in">log</span>();<br>        &#125; <br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-built_in">log</span>();<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">log</span>();<br>    &#125;<br>&#125; <br><span class="hljs-keyword">else</span> <br>&#123;<br>    <span class="hljs-built_in">log</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>所以需要用<code>try catch</code>异常机制；</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">try</span> <br>&#123;<br>    deletePage();<br>    xxx();<br>    yyy();<br>    zzz();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) <br>&#123;<br>    <span class="hljs-built_in">log</span>(e-&gt;getMessage());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>try/catch</code>代码块丑陋不堪，所以最好把<code>try</code>和 <code>catch</code>代码块的主体抽离出来，单独形成函数。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">try</span> <br>&#123;<br>    <span class="hljs-keyword">do</span>();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) <br>&#123;<br>    handle();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="不要写重复代码"><a href="#不要写重复代码" class="headerlink" title="不要写重复代码"></a>不要写重复代码</h3><ul><li>重复是软件中一切邪恶的根源。当算法改变时需要修改多处地方。</li></ul><h3 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h3><ul><li><p>只要函数保持短小，偶尔出现的<code>return</code>、<code>break</code>、<code>continue</code>语句没有坏处，甚至还比单入单出原则更具有表达力。<code>goto</code>只有在大函数里才有道理，应该尽量避免使用。</p></li><li><p>并不需要一开始就按照这些规则写函数，没人做得到。想些什么就写什么，然后再打磨这些代码，按照这些规则组装函数。</p></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p>若编程语言足够有表现力，我们就不需要注释；</p></li><li><p>注释总是一种失败，因为我们无法找到不用注释就能表达自我的方法；</p></li><li><p>代码在演化，注释却不总是随之变动，会变得越来越不准确。</p></li></ul><h3 id="用代码来阐述"><a href="#用代码来阐述" class="headerlink" title="用代码来阐述"></a>用代码来阐述</h3><ul><li><p>创建一个与注释所言同一事物的函数即可，</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// check to see if the employee is eligible for full benefits </span><br><span class="hljs-keyword">if</span> ((employee.falgs &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; <span class="hljs-number">65</span>))<br></code></pre></td></tr></table></figure><p>应替换为</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (employee.isEligibleForFullBenefits())<br></code></pre></td></tr></table></figure></li></ul><h3 id="好注释"><a href="#好注释" class="headerlink" title="好注释"></a>好注释</h3><ul><li><p>法律信息，并且只要有可能就指向标准许可或者外部文档，而不是放全文；</p></li><li><p>提供基本信息，如解释某个<strong>抽象方法的返回值</strong>；</p></li><li><p>对意图的解释，反应了作者某个决定后面的意图；</p></li><li><p>阐释。把某些<strong>晦涩的参数或者返回值</strong>的意义<strong>翻译成可读的形式</strong>(更好的方法是让它们自身变得足够清晰，但是类似标准库的代码我们无法修改)；</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (b.compareTo(a) == <span class="hljs-number">1</span>) <span class="hljs-comment">//b &gt; a</span><br></code></pre></td></tr></table></figure></li><li><p>警示。<code>// don&#39;t run unless you have some time to kill</code>；</p></li><li><p><code>TODO</code>注释；</p></li><li><p>放大 一些看似不合理之物的重要性。</p></li></ul><h3 id="坏注释"><a href="#坏注释" class="headerlink" title="坏注释"></a>坏注释</h3><ul><li><p>自言自语；</p></li><li><p>多余的注释。<strong>把逻辑在注释里写一遍不能比代码提供更多信息</strong>，读它不比读代码简单。<strong>一目了然的成员变量别加注释</strong>，显得很多余；</p></li><li><p>误导性注释；</p></li><li><p>遵循规矩的注释。<strong>每个函数都加注释、每个变量都加注释是愚蠢的</strong>；</p></li><li><p>日志式注释。有了代码版本控制工具，不必在文件开头维护修改时间、修改人这类日志式的注释；</p></li><li><p><strong>能用函数或者变量表示就别用注释</strong>；</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// does the module from the global list &lt;mod&gt; </span><br><br><span class="hljs-comment">// depend on the subsystem we are part of?</span><br><span class="hljs-keyword">if</span> (smodule.getDependSubsystems().contains(subSysMod.getSubSystem())<br></code></pre></td></tr></table></figure><p>  可以改为：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList moduleDependees = smodule.getDependSubsystems();<br>String ourSubSystem = subSysMod.getSubSystem();<br><span class="hljs-keyword">if</span> (moduleDependees.contains(ourSubSystem))<br></code></pre></td></tr></table></figure></li><li><p>位置标记。<strong>标记多了会被我们忽略掉</strong>；</p><p><code>///////////////////// Actions //////////////////////////</code></p></li><li><p>右括号注释；</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">try</span> <br>&#123;<br>    <span class="hljs-keyword">while</span> () <br>    &#123;<br>        <span class="hljs-keyword">if</span> () <br>        &#123;<br>        ...<br>        &#125; <span class="hljs-comment">// if</span><br>        ...<br>    &#125; <span class="hljs-comment">// while</span><br>    ...<br>&#125; <span class="hljs-comment">// try</span><br></code></pre></td></tr></table></figure><p>如果你想标记右括号，其实应该做的是缩短函数</p></li><li><p>署名 <code>/* add by rick */</code> 源代码控制工具会记住你，<strong>署名注释跟不上代码的演变</strong>；</p></li><li><p>注释掉的代码。会导致看到这段代码其他人不敢删除，使用版本控制系统，可以大胆删除需要注释的代码；</p></li><li><p>信息过多。别在注释中添加有趣的历史话题或者无关的细节；</p></li><li><p>没解释清楚的注释。注释的作用是解释未能自行解释的代码，如果注释本身还需要解释就太遗憾了；</p></li><li><p>短函数的函数头注释。<strong>为短函数选个好名字比函数头注释要好</strong>；</p></li><li><p>非公共API函数的<code>javadoc/phpdoc</code>注释。</p></li></ul><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="垂直格式"><a href="#垂直格式" class="headerlink" title="垂直格式"></a>垂直格式</h3><ul><li><p>短文件比长文件更易于理解。<strong>平均200行，最多不超过500行的单个文件可以构造出色的系统</strong>；</p></li><li><p>像报纸一样排版，由略及详，层层递进；</p></li><li><p>区隔: 封包声明、导入声明、每个函数之间，都用空白行分隔开，<strong>空白行下面标识着新的独立概念</strong>，表示一个思路的开始</p></li><li><p>靠近: 紧密相关的代码应该互相靠近，例如<strong>一个类里的属性之间别用空白行隔开</strong>；</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReporterConfig</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">//The class name of the reporter listener</span><br>    <span class="hljs-keyword">private</span> String m_className;<br>    <span class="hljs-comment">//The properties of the reporter listener</span><br>    <span class="hljs-keyword">private</span> List&lt;Property&gt; m_properties = <span class="hljs-keyword">new</span> ArrayList&lt;Property&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addProperty</span><span class="hljs-params">(Property property)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        m_properties.add(property);<br>    &#125;<br>&#125;<br><span class="hljs-comment">///////////////////////对比////////////////////////////////////</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReporterConfig</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> String m_className;<br>    <span class="hljs-keyword">private</span> List&lt;Property&gt; m_properties = <span class="hljs-keyword">new</span> ArrayList&lt;Property&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addProperty</span><span class="hljs-params">(Property property)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        m_properties.add(property);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>变量声明应尽可能靠近其使用位置</strong>：循环中的控制变量应该总是在循环语句中声明；</p></li><li><p><strong>成员变量应该放在类的顶部声明</strong>，不要四处放置；</p></li><li><p><strong>如果某个函数调用了另外一个，就应该把它们放在一起</strong>。我们希望底层细节最后展现出来，不用沉溺于细节，所以<strong>调用者尽可能放在被调用者之上；</strong></p></li><li><p>执行同一基础任务的几个函数应该放在一起。</p></li></ul><h3 id="水平格式"><a href="#水平格式" class="headerlink" title="水平格式"></a>水平格式</h3><ul><li><p>一行代码不必死守80字符的上限，偶尔到达100字符不超过120字符即可；</p></li><li><p>区隔与靠近: 空格强调左右两边的分割。*<em>赋值运算符两边加空格，函数名与左圆括号之间不加空格，乘法运算符在与加减法运算符组合时不用加空格(a</em>b - c)**；</p></li><li><p>不必水平对齐。例如声明一堆成员变量时，各行不用每一个单词都对齐，代码自动格式化工具通常会把这类对齐消除掉；</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>　<span class="hljs-title">FitNesseExpediter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResponseSender</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span>　　 Socket　　　　　　　 socket;<br>    <span class="hljs-keyword">private</span>　　 InputStream　　　   input;<br>    <span class="hljs-keyword">private</span>　　 OutputStream　　　  output;<br>    <span class="hljs-keyword">private</span>　　 Request　　　　　　  request;<br>&#125;　　<br></code></pre></td></tr></table></figure></li><li><p>短小的<code>if</code>、<code>while</code>、函数里最好也不要违反缩进规则，不要这样:<code>if (xx == yy) z = 1</code>；</p></li><li><p><code>while</code>语句为空，最好分行写分号；</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="团队规则"><a href="#团队规则" class="headerlink" title="团队规则"></a>团队规则</h3><ul><li>团队绝对不要用各种不同的风格来编写源代码，这样会增加其复杂度。</li></ul><h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><ul><li>对象:暴露行为(接口),隐藏数据(私有变量)  ；</li><li>数据结构：没有明显的行为(接口),暴露数据。如<code>DTO</code>(Data Transfer Objects)、<code>Entity</code>；</li></ul><h3 id="数据，对象的反对称性"><a href="#数据，对象的反对称性" class="headerlink" title="数据，对象的反对称性"></a>数据，对象的反对称性</h3><ul><li><p>使用<strong>数据结构便于</strong>在不改动现在数据结构的前提下<strong>添加新函数</strong>；使用<strong>对象便于</strong>在不改动既有函数的前提下<strong>添加新类</strong>；</p></li><li><p>使用<strong>数据结构难以添加新数据结构</strong>，因为必须修改所有函数；使用<strong>对象难以添加新函数</strong>，因为必须修改所有类；</p></li><li><p>万物皆对象只是个传说，有时候我们也会在简单数据结构上做一些过程式的操作。</p></li></ul><h3 id="Law-of-Demeter"><a href="#Law-of-Demeter" class="headerlink" title="Law of Demeter"></a>Law of Demeter</h3><ul><li><p><strong>模块不应该了解它所操作对象的内部情形</strong>；</p></li><li><p><code>class C</code>的方法<code>f</code>只应该调用以下对象的方法:</p><ul><li><p><code>C</code></p></li><li><p> 在方法<code>f</code>里创建的对象</p></li><li><p>作为参数传递给方法<code>f</code>的对象</p></li><li><p><code>C</code>持有的对象</p></li></ul></li><li><p>方法不应调用 <strong>由任何函数返回的对象</strong> 的方法。下面的代码违反了demeter定律:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();<br></code></pre></td></tr></table></figure></li><li><p>一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p></li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>错误处理很重要，但是不能凌乱到打乱代码逻辑。</li></ul><h3 id="使用异常而不是返回错误码"><a href="#使用异常而不是返回错误码" class="headerlink" title="使用异常而不是返回错误码"></a>使用异常而不是返回错误码</h3><ul><li><p>如果使用错误码，调用者必须在函数返回时<strong>立刻处理错误</strong>，但这很容易被我们忘记；</p></li><li><p>错误码通常会导致<strong>嵌套</strong><code>if else</code>。</p></li></ul><h3 id="先写try-catch语句"><a href="#先写try-catch语句" class="headerlink" title="先写try-catch语句"></a>先写try-catch语句</h3><ul><li>当编写可能会抛异常的代码时，先写好<code>try-catch</code>再往里堆逻辑。</li></ul><h3 id="在catch里尽可能的记录"><a href="#在catch里尽可能的记录" class="headerlink" title="在catch里尽可能的记录"></a>在catch里尽可能的记录</h3><ul><li>在<code>catch</code>里尽可能的记录错误信息，记录失败的操作以及失败的类型</li></ul><h3 id="依调用者定义异常类"><a href="#依调用者定义异常类" class="headerlink" title="依调用者定义异常类"></a>依调用者定义异常类</h3><ul><li>对错误分类有很多方式。可以依其来源分类：是来自组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？</li></ul><h3 id="别返回null值"><a href="#别返回null值" class="headerlink" title="别返回null值"></a>别返回null值</h3><ul><li><p>返回<code>null</code>值只要一处没检查<code>null</code>，应用程序就会失败；</p></li><li><p>当想返回<code>null</code>值的时候，<strong>可以试试抛出异常，或者返回特例模式的对象。</strong></p></li></ul><h3 id="别传递null值"><a href="#别传递null值" class="headerlink" title="别传递null值"></a>别传递null值</h3><ul><li><p>在方法中传递<code>null</code>值是一种糟糕的做法，应该尽量避免；</p></li><li><p>在方法里用<code>if</code>或<code>assert</code>过滤<code>null</code>值参数，但是还是会出现运行时错误，没有良好的办法对付调动者意外传入的<code>null</code>值，恰当的做法就是<strong>禁止传入<code>null</code>值</strong>。</p></li></ul><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><h3 id="将第三方代码干净利落地整合进自己的代码中"><a href="#将第三方代码干净利落地整合进自己的代码中" class="headerlink" title="将第三方代码干净利落地整合进自己的代码中"></a>将第三方代码干净利落地整合进自己的代码中</h3><ul><li><p>避免公共API返回边界接口，或者将边界接口作为参数传递给API。将边界保留在近亲类中；</p></li><li><p>不要在生产代码中试验新东西，而是编写测试来理解第三方代码；</p></li><li><p>避免我们的代码过多地了解第三方代码中的特定信息。</p></li><li><p>学习性测试是一种精确试验，帮助我们增进对API的理解。</p></li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="TDD-Test-driven-development-三定律"><a href="#TDD-Test-driven-development-三定律" class="headerlink" title="TDD(Test-driven development)三定律"></a>TDD(Test-driven development)三定律</h3><ul><li><p><em>First Law: You may not write production code until you have written a failing unit test.</em></p></li><li><p><em>Second Law: You may not write more of a unit test than is sufficient to fail, and not compiling is failing.</em></p></li><li><p><em>Third Law: You may not write more production code than is sufficient to pass the currently failing test.</em></p></li></ul><h3 id="保持测试整洁"><a href="#保持测试整洁" class="headerlink" title="保持测试整洁"></a>保持测试整洁</h3><ul><li><p><strong>脏测试等同于没测试</strong>，测试代码越脏生产代码越难修改；</p></li><li><p>测试代码和生产代码一样重要；</p></li><li><p>整洁的测试代码最应具有的要素是：<strong>整洁性</strong>。<strong>测试代码中不要有大量重复代码的调用。</strong></p></li></ul><h3 id="每个测试一个断言"><a href="#每个测试一个断言" class="headerlink" title="每个测试一个断言"></a>每个测试一个断言</h3><ul><li><p>每个测试函数<strong>有且仅有一个断言语句</strong>；</p></li><li><p>每个测试函数中<strong>只测试一个概念</strong>。</p></li></ul><h3 id="整洁的测试依赖于FIRST规则"><a href="#整洁的测试依赖于FIRST规则" class="headerlink" title="整洁的测试依赖于FIRST规则"></a>整洁的测试依赖于FIRST规则</h3><ul><li><p><strong>fast</strong>: 测试代码应该<strong>能够快速运行</strong>，因为我们需要频繁运行它；</p></li><li><p><strong>independent</strong>: 测试应该<strong>相互独立</strong>，某个测试不应该依赖上一个测试的结果，测试可以以任何顺序进行；</p></li><li><p><strong>repeatable</strong>: 测试应可以在任何环境中通过；</p></li><li><p><strong>self-validating</strong>: 测试应该有<code>bool</code>值输出，不应通过查看日志来确认测试结果，不应手工对比两个文本文件确认测试结果；</p></li><li><p><strong>timely</strong>: 及时编写测试代码。<strong>单元测试应该在生产代码之前编写</strong>，否则生产代码会变得难以测试。</p></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的组织"><a href="#类的组织" class="headerlink" title="类的组织"></a>类的组织</h3><p>以下针对JAVA语言，其他语言类似，变量在前，方法在后，公有在前，私有在后。</p><ul><li><p>公共静态常量</p></li><li><p>私有静态变量</p></li><li><p>私有实体变量</p></li><li><p>公共函数</p></li><li><p>私有工具函数</p></li></ul><p>如果测试需要调用一个函数或变量，可以设为保护类型。</p><h3 id="类应该短小"><a href="#类应该短小" class="headerlink" title="类应该短小"></a>类应该短小</h3><ul><li><p>对于函数我们计算<strong>代码行数</strong>衡量大小，对于类我们使用<strong>权责</strong>来衡量；</p></li><li><p><strong>类的名称应当描述其权责</strong>。类的命名是判断类长度的第一个手段，如果无法为某个类命以准确的名称，这个类就太长了。类名包含模糊的词汇，如<code>Processor</code>、<code>Manager</code>、<code>Super</code>，这种现象就说明有不恰当的<strong>权责聚集</strong>情况；</p></li><li><p>单一权责原则（Single Responsibility Principle，SRP）: 类或者模块应该有一个权责——只有一条修改的理由(A class should have only one reason to change.)；</p></li><li><p>系统应该由许多短小的类而不是少量巨大的类组成；</p></li><li><p>类应该只有少量的实体变量，如果一个类中每个实体变量都被每个方法所使用，则说明该类具有<strong>最大的内聚性</strong>。创建最大化的内聚类不太现实，但是应该以高内聚为目标，<strong>内聚性越高说明类中的方法和变量互相依赖、互相结合形成一个逻辑整体</strong>；</p></li><li><p><strong>保持内聚性就会得到许多短小的类</strong>。如果你想把一个大函数的某一小部分拆解成单独的函数，拆解出的函数使用了大函数中的4个变量，不必<strong>将4个变量作为参数传递到新函数里</strong>，仅需<strong>将这4个变量提升为大函数所在类的实体变量</strong>，但是这么做却因为实体变量的增多而丧失了类的内聚性，更好多做法是<strong>让这4个变量拆出来，拥有自己的类</strong>。将大函数拆解成小函数往往是将类拆分为小类的时机。</p></li></ul><h3 id="为了修改而组织"><a href="#为了修改而组织" class="headerlink" title="为了修改而组织"></a>为了修改而组织</h3><ul><li><p>类应当对扩展开放，对修改封闭(开放闭合原则)；</p></li><li><p>在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。</p></li></ul><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><h3 id="将系统的构造与使用分开"><a href="#将系统的构造与使用分开" class="headerlink" title="将系统的构造与使用分开"></a>将系统的构造与使用分开</h3><ul><li>软件系统应将起始过程和之后的运行逻辑分开。</li></ul><h3 id="分解main"><a href="#分解main" class="headerlink" title="分解main"></a>分解main</h3><ul><li><p><strong>将全部构造过程搬迁到main</strong>或者被称之为<code>main</code>的模块中，涉及系统其余部分时，<strong>假设所有对象都已经正确构造</strong>；</p></li><li><p>依赖注入(DI)，控制反转(IoC)是分离构造与使用的强大机制。</p></li></ul><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><h3 id="表达力"><a href="#表达力" class="headerlink" title="表达力"></a>表达力</h3><ul><li><p>作者把代码写的越清晰，其他人理解代码就越快；</p></li><li><p>太多时候我们深入于要解决的问题中，写出能工作的代码之后，就转移到下一个问题上，没有下足功夫调整代码让后来者易于阅读。多少尊重一下我们的手艺，花一点点时间在每个函数和类上。</p></li></ul><h3 id="尽可能少的类和方法"><a href="#尽可能少的类和方法" class="headerlink" title="尽可能少的类和方法"></a>尽可能少的类和方法</h3><ul><li><p>为了保持类和函数的短小，我们可能会早出太多细小的类和方法；</p></li><li><p>类和方法数量太多，有时是由毫无意义的教条主义导致的。</p></li></ul><h3 id="以上4条规则优先级依次递减。重要的是测试、消除重复、表达意图"><a href="#以上4条规则优先级依次递减。重要的是测试、消除重复、表达意图" class="headerlink" title="以上4条规则优先级依次递减。重要的是测试、消除重复、表达意图"></a>以上4条规则优先级依次递减。重要的是测试、消除重复、表达意图</h3><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="为什么要并发编程"><a href="#为什么要并发编程" class="headerlink" title="为什么要并发编程"></a>为什么要并发编程</h3><ul><li><p>并发总能改进性能；</p></li><li><p>编写并发程序无需修改设计；</p></li><li><p>在采用<code>Web</code>或<code>EJB</code>容器的时候，理解并发问题并不重要。</p></li></ul><h3 id="防御并发代码问题的原则与技巧"><a href="#防御并发代码问题的原则与技巧" class="headerlink" title="防御并发代码问题的原则与技巧"></a>防御并发代码问题的原则与技巧</h3><ul><li><p>遵循单一职责原则。分离并发代码与非并发代码；</p></li><li><p>限制临界区数量、限制对共享数据的访问；</p></li><li><p>避免使用共享数据，使用对象的副本；</p></li><li><p>线程尽可能地独立，不与其他线程共享数据。</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git-git pull与git pull --rebase的区别</title>
    <link href="/2021/11/29/Git-git-pull%E4%B8%8Egit-pull-rebase%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/11/29/Git-git-pull%E4%B8%8Egit-pull-rebase%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull == git fetch + git merge<br>git pull --rebase == git fetch + git rebase<br></code></pre></td></tr></table></figure><p>拆解来看这两个命令就是在拉取远端代码后，是合并还是进行变基操作。</p><p>假设当前有三个提交<code>A,B,C</code>，并且分支<code>feature</code>都与远程代码同步。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129154905.png"></p><p>我们在<code>feature</code>上做了一些修改，并产生了<code>E</code>提交，远程也有用户进行了更新到了<code>D</code>提交。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129155138.png"></p><p>此时我们需要<code>git fetch</code>获取最新的代码，然后<code>git merge</code>解决冲突后重新<code>git add</code> <code>git commit</code>，得到<code>F</code>提交。最后<code>git push</code>即可成功推送，得到如下的关系</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129155544.png"></p><p>而使用<code>git rebase</code>将会创建一个新的提交<code>F</code>，<code>F</code>的文件内容和上面<code>F</code>的一样，但我们将E提交废除，当它不存在（图中用虚线表示）。由于这种删除，避免了菱形的产生，保持提交曲线为直线。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129162532.png"></p><p>在<code>rebase</code>的过程中，有时也会有冲突，这时Git会停止<code>rebase</code>并让用户去解决冲突，解决完冲突后，用<code>git add</code>添加修改的文件，然后不用执行<code>git commit</code>，直接执行<code>git rebase --continue</code>，这样git会继续apply余下的补丁。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git同一文件被多人修改了文件名该如何处理</title>
    <link href="/2021/11/28/Git%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E8%A2%AB%E5%A4%9A%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E6%96%87%E4%BB%B6%E5%90%8D%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <url>/2021/11/28/Git%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E8%A2%AB%E5%A4%9A%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E6%96%87%E4%BB%B6%E5%90%8D%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>用户一修改了文件名，并推送到了远端。用户二也修改了文件名，在进行推送时，就会被拒绝。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282158733.png"></p><p>拉取最新代码后发现有相同的文件，只是文件名不同。<code>index1.htm</code>和<code>index2.htm</code>两个文件内容是完全相同的。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282159666.png"></p><p>查看当前状态，可知有其他想把文件名修改为<code>index2.htm</code>。此时只需要根据提示，删除<code>index.htm</code>。协商后决定保留哪一个文件，比如我们决定保留<code>index1.htm</code>。那么删除<code>index2.htm</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282203900.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282204020.png"></p><p>最后在<code>commit</code>一次，即可顺利推送。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111282205646.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git他人同时修改了文件名和文件内容该如何处理</title>
    <link href="/2021/11/27/Git%E4%BB%96%E4%BA%BA%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E4%BA%86%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <url>/2021/11/27/Git%E4%BB%96%E4%BA%BA%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E4%BA%86%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>用户一修改了文件名，并提交远端。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272319842.png"></p><p>用户二修改了文件内容，也进行了推送，<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272320474.png"></p><p>当然会被无情拒绝，<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272321244.png"></p><p>解决这个问题也十分简单，Git可以智能的感知到只是文件名被修改，只需要一个<code>git pull</code>命令就可以解决。弹出弹窗可以直接保存退出，默认不变就行。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git不同人修改了相同文件的相同区域</title>
    <link href="/2021/11/27/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E7%9B%B8%E5%90%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%90%8C%E5%8C%BA%E5%9F%9F/"/>
    <url>/2021/11/27/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E7%9B%B8%E5%90%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%90%8C%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<p>不同人修改了文件的相同区域，如果向远端推送，肯定会被拒绝。这时候就需要解决冲突，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272217729.png"></p><p>首先拉取远端最新的代码，会提示有冲突的文件，<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272220539.png"></p><p>打开冲突的文件，git会对冲突区域进行标记，<code>&lt;&lt;&lt;&lt;&lt;&lt;</code>到<code>======</code>区域表示远端的代码。<code>======</code>到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>表示本地的代码。这时候就需要自己来判断需要哪些代码，也可以增删一些内容，修改完成后将这些标识符号删除，然后保存退出。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272221887.png"></p><p><code>git status</code>查看当前状态，提示还有未合并的路径，需要进行<code>commit</code>操作。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272256325.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111272256627.png"></p><p>及时<code>git push</code>当前代码。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件删除仍然在Trash目录下占用空间，该如何删除Trash下的文件</title>
    <link href="/2021/11/25/Linux%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E4%BB%8D%E7%84%B6%E5%9C%A8Trash%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Trash%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <url>/2021/11/25/Linux%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E4%BB%8D%E7%84%B6%E5%9C%A8Trash%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Trash%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>查阅了一个<a href="https://askubuntu.com/questions/351400/deleting-contents-of-local-share-trash-expunged">网上的答案</a>，大意就是，你删除了属于你的文件夹，但其中包含属于另一个用户的文件时，文件可能会卡住，就会在Trash目录里不会被彻底删除。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo rm -rv /home/&lt;your_username&gt;/.<span class="hljs-built_in">local</span>/share/Trash/expunged/*<br></code></pre></td></tr></table></figure><p>PS：发现一个好用的磁盘分析工具，Linux内置应用<code>Disk Usage Analyzer</code>。按<code>Win</code>键后搜索框搜索即可打开。</p><p>图形化的方式快速找到占用空间较大的目录，文件。可以右击直接删除。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211125102946.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git如何合并连续的多个commit</title>
    <link href="/2021/11/24/Git%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%A4%9A%E4%B8%AAcommit/"/>
    <url>/2021/11/24/Git%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%A4%9A%E4%B8%AAcommit/</url>
    
    <content type="html"><![CDATA[<ul><li><p>确定需要合并的<code>commit</code><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242323497.png"></p></li><li><p>变基操作，以需要合并的<code>commit</code>下方的结点为基准。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242324125.png"></p></li><li><p>交互式变基，<code>squash</code>表示合并到上方<code>commit</code><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242325615.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242326279.png"></p></li><li><p>编写合并<code>commit</code>的<code>message</code>，保留原先的不变<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242328440.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111242328175.png"></p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git不同人修改了同一文件的不同区域该如何处理</title>
    <link href="/2021/11/23/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <url>/2021/11/23/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ul><li><code>git fetch</code> <code>git merge</code><br>或者</li><li><code>git pull</code></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git修改老旧commit的message</title>
    <link href="/2021/11/22/Git%E4%BF%AE%E6%94%B9%E8%80%81%E6%97%A7commit%E7%9A%84message/"/>
    <url>/2021/11/22/Git%E4%BF%AE%E6%94%B9%E8%80%81%E6%97%A7commit%E7%9A%84message/</url>
    
    <content type="html"><![CDATA[<p><strong>以下操作仅限于维护自己的分支，不建议对团队共享的代码进行修改。</strong></p><p>以最近三次提交为例，假设想要修改第二个提交的<code>message</code>。可以使用<code>git rebase</code>命令<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222255230.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> rebase -i <span class="hljs-number">27</span>d<span class="hljs-number">2</span>f<br></code></pre></td></tr></table></figure><ul><li><code>-i</code>交互式变基</li><li><code>27d2f</code>需要改变<code>message</code>的提交的父节点</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222258390.png"></p><p>弹出页面可以使用提供的命令进行操作，比如<code>pick</code>意思就是挑选需要的<code>commit</code>。本次任务需要修改<code>message</code>，从下方帮助文档里可以找到<code>reword</code>命令，可以保留<code>commit</code>，只修改<code>message</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222301367.png"></p><p>保存退出后，会弹出另外一个界面。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222302032.png"></p><p>在这里就可以真正修改需要更新的<code>message</code>。保存退出即可。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222303965.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git修改最新commit的message</title>
    <link href="/2021/11/22/Git%E4%BF%AE%E6%94%B9%E6%9C%80%E6%96%B0commit%E7%9A%84message/"/>
    <url>/2021/11/22/Git%E4%BF%AE%E6%94%B9%E6%9C%80%E6%96%B0commit%E7%9A%84message/</url>
    
    <content type="html"><![CDATA[<p><code>commit</code>提交后觉得描述信息不准确，想重新修改<code>message</code>内容，该如何操作？</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span><br></code></pre></td></tr></table></figure><p>弹出页面就和<code>git commit</code>操作时的一样，将其改为新内容即可。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决C语言undefined reference to pthread_join</title>
    <link href="/2021/11/17/%E8%A7%A3%E5%86%B3C%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/"/>
    <url>/2021/11/17/%E8%A7%A3%E5%86%B3C%E8%AF%AD%E8%A8%80undefined-reference-to-pthread-join/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p><code>undefined reference to sleep</code>同样的问题。<br>在使用C语言线程函数时，需要包含<code>#include &lt;pthread&gt;</code>，编译时就会报这种错误。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p><code>pthread</code> 库不是 <code>Linux</code> 系统默认的库，连接时需要使用静态库 <code>libpthread.a</code>，所以在使用<code>pthread_create()</code>创建线程，以及调用<code> pthread_atfork()</code>函数建立<code>fork</code>处理程序时，需要链接该库。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc thread.c -o thread -lpthread<br><br></code></pre></td></tr></table></figure><p>如果是<code>Makefile</code>配置的编译条件，在<code>Makefile</code>文件中加上如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CFLAGS += -lpthread<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决QT点击按钮无响应</title>
    <link href="/2021/11/16/%E8%A7%A3%E5%86%B3QT%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%97%A0%E5%93%8D%E5%BA%94/"/>
    <url>/2021/11/16/%E8%A7%A3%E5%86%B3QT%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%97%A0%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>在运行中的界面上点击按钮没有效果，像是按钮上层有其他遮盖层。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p><code>widget</code>的父控件上又添加了其他<code>Widget</code>，覆盖在了按钮上，因此无法点击。通过<code>new</code>得到的控件，默认显示在比它<code>new</code>的早的控件上面。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 将有按钮的那一层widget置于上层</span><br>widget-&gt;<span class="hljs-built_in">raise</span>();<br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决QT在构造函数中写的控件不显示的问题</title>
    <link href="/2021/11/16/%E8%A7%A3%E5%86%B3QT%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%86%99%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/11/16/%E8%A7%A3%E5%86%B3QT%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E5%86%99%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>在新窗口中的构造函数中添加控件运行后却没有显示</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><ul><li><p>新建的工程师MainWindow子类工程，没有设置父窗口。</p></li><li><p>没有将控件的父窗口设置成自己定义的widget。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br> <br>QMainWindow::<span class="hljs-built_in">QMainWindow</span>(QMainWindow*parent) :<br>    <span class="hljs-built_in">QMainWindow</span>(parent),<br>    <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::QMainWindow)<br>&#123;<br>     ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;add&quot;</span>);<br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;del&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法1：给按钮控件设置父窗口：QWidget,并且把按钮添加到父窗口中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QHBoxLayout&gt;</span></span><br> <br>QMainWindow::<span class="hljs-built_in">QMainWindow</span>(QMainWindow*parent) :<br>    <span class="hljs-built_in">QMainWindow</span>(parent),<br>    <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::QMainWindow)<br>&#123;<br>     ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br>     QWidget* w = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QWidget</span>();<br>     <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setCentralWidget</span>(w);<br>     QHBoxLayout* hLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;add&quot;</span>);<br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;del&quot;</span>);<br>     hLayout-&gt;<span class="hljs-built_in">addWidget</span>(button_1);<br>     hLayout-&gt;<span class="hljs-built_in">addWidget</span>(button_2);<br>     w-&gt;<span class="hljs-built_in">setLayout</span>(hLayout);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法2：手动指定父窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;QHBoxLayout&gt;</span></span><br> <br>QMainWindow::<span class="hljs-built_in">QMainWindow</span>(QMainWindow*parent) :<br>    <span class="hljs-built_in">QMainWindow</span>(parent),<br>    <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::QMainWindow)<br>&#123;<br>     ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br>    <br>    <br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;add&quot;</span>);<br>     QPushButton* button_1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;del&quot;</span>);<br>     button_1-&gt;<span class="hljs-built_in">setParent</span>(<span class="hljs-keyword">this</span>);<br>     button_2-&gt;<span class="hljs-built_in">setParent</span>(<span class="hljs-keyword">this</span>);<br>     button_2-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">300</span>,<span class="hljs-number">100</span>);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QWidget中update不执行paintEvent</title>
    <link href="/2021/11/15/%E8%A7%A3%E5%86%B3QWidget%E4%B8%ADupdate%E4%B8%8D%E6%89%A7%E8%A1%8CpaintEvent/"/>
    <url>/2021/11/15/%E8%A7%A3%E5%86%B3QWidget%E4%B8%ADupdate%E4%B8%8D%E6%89%A7%E8%A1%8CpaintEvent/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>手动执行<code>update()</code>或者<code>repaint()</code>都不能执行<code>paintEvent</code>函数。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>如果是代码<code>new</code>出来的控件，检查是否正确显示，比如有没有加入到<code>layout</code>中。或者有没有设置父窗口（可能被其他空间遮挡）。</p><p>检查控件<code>width</code>或者<code>height</code>大小是否不为0。如果为0，也不会出出发<code>paintEvent</code>。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>参考QT在构造函数中写的控件不显示</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决C++中vector声明错误expected parameter declarator</title>
    <link href="/2021/11/13/%E8%A7%A3%E5%86%B3C-%E4%B8%ADvector%E5%A3%B0%E6%98%8E%E9%94%99%E8%AF%AFexpected-parameter-declarator/"/>
    <url>/2021/11/13/%E8%A7%A3%E5%86%B3C-%E4%B8%ADvector%E5%A3%B0%E6%98%8E%E9%94%99%E8%AF%AFexpected-parameter-declarator/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">QVector&lt;<span class="hljs-keyword">uint32_t</span>&gt; <span class="hljs-title">buttonPins</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><br></code></pre></td></tr></table></figure><p>声明了一个长度为3的<code>vector</code>数组，编译是会报这个错误。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>编译器可能无法区分这是一个成员函数声明还是一个成员变量声明，也就是产生歧义。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">QVector&lt;<span class="hljs-keyword">uint32_t</span>&gt; buttonPins = QVector&lt;<span class="hljs-keyword">uint32_t</span>&gt;(<span class="hljs-number">3</span>);<span class="hljs-comment">//明确这是一个成员变量</span><br><br></code></pre></td></tr></table></figure><p>方法2：默认构造函数里面进行成员变量的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">MainWindow::<span class="hljs-built_in">MainWindow</span>(QWidget *parent) : <span class="hljs-built_in">QMainWindow</span>(parent),<br>    <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::MainWindow),<span class="hljs-built_in">buttonPins</span>(<span class="hljs-number">3</span>)&#123;&#125;<br></code></pre></td></tr></table></figure><p>方法3：列表初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">QVector&lt;<span class="hljs-keyword">uint32_t</span>&gt; buttonPins&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决expected identifier before ‘(’ token</title>
    <link href="/2021/11/12/%E8%A7%A3%E5%86%B3expected-identifier-before-%E2%80%98-%E2%80%99-token/"/>
    <url>/2021/11/12/%E8%A7%A3%E5%86%B3expected-identifier-before-%E2%80%98-%E2%80%99-token/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>比如在一个枚举类型中，会告诉你某行有这种错误。又或者，在一个宏定义语句中出现这种错误。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>一般来说，出现这种情况，是语句中有些定义的名字发生了冲突。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>定位错误位置，搜索是否有同名的函数，变量等等。改个名字。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU源码分析-外设模拟（以GPIO为例）</title>
    <link href="/2021/11/11/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%A4%96%E8%AE%BE%E6%A8%A1%E6%8B%9F%EF%BC%88%E4%BB%A5GPIO%E4%B8%BA%E4%BE%8B%EF%BC%89/"/>
    <url>/2021/11/11/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%A4%96%E8%AE%BE%E6%A8%A1%E6%8B%9F%EF%BC%88%E4%BB%A5GPIO%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="QEMU模拟外设的原理"><a href="#QEMU模拟外设的原理" class="headerlink" title="QEMU模拟外设的原理"></a>QEMU模拟外设的原理</h2><p>QEMU主要是实现了CPU核的模拟，可以读写某个地址。<br>QEMU的模拟外设的原理很简单：<strong>硬件即内存</strong>。<br>要在QEMU上模拟某个外设，思路就是：</p><ul><li>CPU读某个地址时，QEMU模拟外设的行为，把数据返回给CPU</li><li>CPU写某个地址时，QEMU获得数据，用来模拟外设的行为。<br>即：要模拟外设备，我们只需要针对外设的地址提供对应的读写函数即可。</li></ul><p>以GPIO为例：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211111102930.png"></p><p>QEMU 为<code>GPIO</code>内存地址提供读写回调函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sifive_gpio_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque, hwaddr offset, <span class="hljs-keyword">uint64_t</span> value, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">sifive_gpio_read</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque, hwaddr offset, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span><br></code></pre></td></tr></table></figure><h2 id="给外设地址提供读写函数"><a href="#给外设地址提供读写函数" class="headerlink" title="给外设地址提供读写函数"></a>给外设地址提供读写函数</h2><p>怎么描述某段地址：基地址、大小？如何给这段地址提供读写函数呢？这段地址设置好后，如何添加进<code>system_memory</code>去？有2种方法。</p><p><strong>法1：memory_region_init_io/memory_region_add_subregion</strong><br>以<code>SIFIVE_UART</code>为例，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">memory_region_init_io(&amp;s-&gt;mmio, <span class="hljs-literal">NULL</span>, &amp;uart_ops, s,<br>                        TYPE_SIFIVE_UART, <span class="hljs-number">0x2000</span>);<br>memory_region_add_subregion(address_space, base, &amp;s-&gt;mmio);<br></code></pre></td></tr></table></figure><p><code>memory_region_init_io</code>函数初始化<code>iomem</code>，读写函数，大小。<br><code>memory_region_add_subregion</code>函数<code>s-&gt;iomem</code>指定了基地址，并添加进<code>system_memory</code>中。<br>以后，客户机上的程序读写这块地址时，就会导致对应的读写函数被调用。</p><p><strong>法2：memory_region_init_io/sysbus_init_mmio/sysbus_mmio_map</strong><br>以<code>SIFIVE_GPIO</code>为例，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">memory_region_init_io(&amp;s-&gt;mmio, OBJECT(dev), &amp;gpio_ops, s, TYPE_SIFIVE_GPIO, SIFIVE_GPIO_SIZE);<br><br>sysbus_init_mmio(SYS_BUS_DEVICE(dev), &amp;s-&gt;mmio);<br></code></pre></td></tr></table></figure><p><code>memory_region_init_io</code>函数初始化<code>iomem</code>，读写函数，大小。<br><code>sysbus_init_mmio</code>将<code>mmin</code>传给设备；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sysbus_mmio_map(SYS_BUS_DEVICE(&amp;s-&gt;gpio), <span class="hljs-number">0</span>, memmap[SIFIVE_E_DEV_GPIO0].base);<br></code></pre></td></tr></table></figure><p><code>sysbus_mmio_map</code>从设备中吧<code>mmio</code>添加进<code>system_memory</code>并指定基地址。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QEMU</tag>
      
      <tag>GPIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU源码分析-虚拟外设创建(以GPIO为例)</title>
    <link href="/2021/11/09/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9F%E5%A4%96%E8%AE%BE%E5%88%9B%E5%BB%BA/"/>
    <url>/2021/11/09/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9F%E5%A4%96%E8%AE%BE%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>一个板子上有很多硬件：芯片，LED、按键、LCD、触摸屏、网卡等等。芯片里面也有很多部件，比如CPU、GPIO、SD控制器、中断控制器等等。</p><p>这些硬件，或是部件，各有不同。怎么描述它们？</p><h3 id="如何描述硬件"><a href="#如何描述硬件" class="headerlink" title="如何描述硬件"></a>如何描述硬件</h3><p>每一个都使用一个<code>TypeInfo</code>结构体来描述。</p><p>对于<code>KVM</code>有这样的结构体 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo kvm_accel_type = &#123;<br>    .name = TYPE_KVM_ACCEL,<br>    .parent = TYPE_ACCEL,<br>    .class_init = kvm_accel_class_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(KVMState),<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于<code>sifive_gpio</code>有这样的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo sifive_gpio_info =<br>&#123;<br>        .name = TYPE_SIFIVE_GPIO,<br>        .parent = TYPE_SYS_BUS_DEVICE,<br>        .instance_size = <span class="hljs-keyword">sizeof</span>(SIFIVEGPIOState),<br>        .class_init = sifive_gpio_class_init<br>&#125;;<br></code></pre></td></tr></table></figure><p>这些结构体在运行时会被注册进程序里，保存在一个链表中备用，为什么是备用，因为不是每一个硬件都会被用到。</p><h3 id="如何注册硬件"><a href="#如何注册硬件" class="headerlink" title="如何注册硬件"></a>如何注册硬件</h3><p>当虚拟机真的要使用物理资源的时候，对下面的物理机上的资源要进行请求，所以它的工作模式有点儿类似操作系统对接驱动。驱动要符合一定的格式，才能算操作系统的一个模块。同理，<code>qemu</code> 为了模拟各种各样的设备，也需要管理各种各样的模块，这些模块也需要符合一定的格式。</p><p>怎么注册这些<code>TypeInfo</code>结构体呢？不需要我们去调用注册函数，以<code>GPIO</code>为例，在<code>hw/gpio/sifive_gpio.c</code>中有如下代码,一般在最后一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">type_init(sifive_gpio_register_types)<br></code></pre></td></tr></table></figure><p><code>F12</code>找到这个宏定义，我们追根溯源，调用过程如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">type_init(sifive_gpio_register_types)<br>||<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> type_init(function) module_init(function, MODULE_INIT_QOM)</span><br>||<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> module_init(function, type)                                         \</span><br><span class="hljs-meta">static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \</span><br><span class="hljs-meta">&#123;                                                                           \</span><br><span class="hljs-meta">    register_module_init(function, type);                                   \</span><br><span class="hljs-meta">&#125;</span><br>||<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register_module_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*fn)(<span class="hljs-keyword">void</span>), module_init_type type)</span></span><br><span class="hljs-function"></span>&#123;<br>    ModuleEntry *e;     <span class="hljs-comment">//构造ModuleEntry</span><br>    ModuleTypeList *l;  <span class="hljs-comment">//构造链表</span><br><br>    e = g_malloc0(<span class="hljs-keyword">sizeof</span>(*e));<br>    e-&gt;init = fn;       <span class="hljs-comment">//设置初始化函数，fn即sifive_gpio_register_types</span><br>    e-&gt;type = type;<br><br>    l = find_type(type);<br><br>    QTAILQ_INSERT_TAIL(l, e, node);<span class="hljs-comment">//将ModuleEntry插入链表尾</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>type_init</code>是个宏定义，调用了<code>__attribute__((constructor))</code>函数，我们知道这个C语言中位数不多的在<code>main</code>函数执行前，执行的函数。函数中调用了<code>register_module_init</code>注册函数，说明在<code>main</code>函数执行前，已经注册好硬件了。该函数将一个新的<code>ModuleEntry</code>加到链表里。</p><h3 id="初始化设备"><a href="#初始化设备" class="headerlink" title="初始化设备"></a>初始化设备</h3><p>了解了设备的注册机制，得到了<code>ModuleEntry</code>链表，那么<code>ModuleEntry</code>里面的<code>init</code>函数在合适被调用呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//qemu/softmmu/main.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">--&gt; <span class="hljs-title">qemu_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">--&gt; <span class="hljs-title">qemu_init_subsystems</span><span class="hljs-params">()</span></span><br><span class="hljs-function">--&gt; <span class="hljs-title">module_call_init</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// utils/module.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">module_call_init</span><span class="hljs-params">(module_init_type type)</span></span><br><span class="hljs-function"></span>&#123;<br>    ModuleTypeList *l;<br>    ModuleEntry *e;<br>    l = find_type(type);<br>    QTAILQ_FOREACH(e, l, node) &#123;<br>        e-&gt;init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>module_call_init</code> 中，我们会找到 <code>MODULE_INIT_QOM</code> 这种类型对应的 <code>ModuleTypeList</code>，找出列表中所有的 <code>ModuleEntry</code>，然后调用每个 <code>ModuleEntry</code> 的 <code>init</code> 函数。</p><p>这些<code>xxx_register_types</code>执行后，又得到了什么？</p><ul><li>分配一个<code>TypeImpl</code>结构体，使用<code>TypeInfo</code>来设置它：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_type_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    type_register_static(&amp;kvm_accel_type);<br>&#125;<br>||<br><span class="hljs-function">TypeImpl *<span class="hljs-title">type_register_static</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> type_register(info);<br>&#125;<br>||<br><span class="hljs-function">TypeImpl *<span class="hljs-title">type_register</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(info-&gt;parent);<br>    <span class="hljs-keyword">return</span> type_register_internal(info);<br>&#125;<br>||<br><span class="hljs-function"><span class="hljs-keyword">static</span> TypeImpl *<span class="hljs-title">type_register_internal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    TypeImpl *ti;<br>    ti = type_new(info);<br><br>    type_table_add(ti);<br>    <span class="hljs-keyword">return</span> ti;<br>&#125;<br>||<br><span class="hljs-function"><span class="hljs-keyword">static</span> TypeImpl *<span class="hljs-title">type_new</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    TypeImpl *ti = g_malloc0(<span class="hljs-keyword">sizeof</span>(*ti));<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (type_table_lookup(info-&gt;name) != <span class="hljs-literal">NULL</span>) &#123;<br>    &#125;<br>    ti-&gt;name = g_strdup(info-&gt;name);<br>    ti-&gt;parent = g_strdup(info-&gt;parent);<br>    ti-&gt;class_size = info-&gt;class_size;<br>    ti-&gt;instance_size = info-&gt;instance_size;<br>    ti-&gt;class_init = info-&gt;class_init;<br>    ti-&gt;class_base_init = info-&gt;class_base_init;<br>    ti-&gt;class_data = info-&gt;class_data;<br>    ti-&gt;instance_init = info-&gt;instance_init;<br>    ti-&gt;instance_post_init = info-&gt;instance_post_init;<br>    ti-&gt;instance_finalize = info-&gt;instance_finalize;<br>    ti-&gt;abstract = info-&gt;abstract;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; info-&gt;interfaces &amp;&amp; info-&gt;interfaces[i].type; i++) &#123;<br>        ti-&gt;interfaces[i].<span class="hljs-keyword">typename</span> = g_strdup(info-&gt;interfaces[i].type);<br>    &#125;<br>    ti-&gt;num_interfaces = i;<br>    <span class="hljs-keyword">return</span> ti;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>把<code>TypeImpl</code>放入链表：<code>type_table</code>。<br>在 <code>qemu</code> 里面，有一个全局的哈希表 <code>type_table</code>，用来存放所有定义的类。在 <code>type_new</code> 里面，我们先从全局表里面根据名字<code>type_table_lookup</code>查找找这个类。如果找到，说明这个类曾经被注册过，就报错；如果没有找到，说明这是一个新的类，则将 <code>TypeInfo</code> 里面信息填到 <code>TypeImpl</code> 里面。<code>type_table_add</code> 会将这个类注册到全局的表里面。到这里，我们注意，<code>class_init</code> 还没有被调用，也即这个类现在还处于<strong>纸面的状态</strong>。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">type_table_add</span><span class="hljs-params">(TypeImpl *ti)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(!enumerating_types);<br>    g_hash_table_insert(type_table_get(), (<span class="hljs-keyword">void</span> *)ti-&gt;name, ti);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> GHashTable *<span class="hljs-title">type_table_get</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> GHashTable *type_table;<br><br>    <span class="hljs-keyword">if</span> (type_table == <span class="hljs-literal">NULL</span>) &#123;<br>        type_table = g_hash_table_new(g_str_hash, g_str_equal);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> type_table;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>这点更加像 Java 的反射机制了。在 Java 里面，对于一个类，首先我们写代码的时候要写一个 <code>class xxx</code> 的定义，编译好就放在<code>XXX.class</code> 文件中，这也是出于纸面的状态。然后，Java 会有一个 <code>Class</code> 对象，用于读取和表示这个纸面上的 <code>class xxx</code>，可以生成真正的对象。</p><p>相同的过程在后面的代码中我们也可以看到，<code>class_init</code> 会生成<code>XXXClass</code>，就相当于 Java 里面的 <code>Class</code>对象，<code>TypeImpl</code> 还会有一个 <code>instance_init</code> 函数，相当于构造函数，用于根据 <code>XXXClass</code> 生成 <code>Object</code>，这就相当于 Java 反射里面最终创建的对象。和构造函数对应的还有 <code>instance_finalize</code>，相当于析构函数。</p><h3 id="实例化设备"><a href="#实例化设备" class="headerlink" title="实例化设备"></a>实例化设备</h3><p>上面提到，目前设备还处于纸面状态，它只有被实例化后，才表示QEMU模拟的板子上有了这些硬件设备。那么到底是如何实例化的呢？</p><p>在程序的<code>type_table</code>链表中，有很多<code>TypeImpl</code>结构体，比如<code>CPU</code>、<code>GPIO</code>、<code>LCD</code>对应的<code>TypeImpl</code>结构体。</p><p>但是这并不表示QEMU模拟的板子上有这些硬件，必竟它们只是“TypeImpl”，表示“类型”，需要在“实例化”之后，才表示板子上有了这些硬件。</p><p>以<code>GPIO</code>为例，代码为<code>hw/gpio/sifive_gpio.c</code>，里面声明了一个<code>A15MPPrivState</code>结构体，还定义了一个<code>TypeInfo</code>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SIFIVEGPIOState</span></span><br><span class="hljs-class">&#123;</span><br>    SysBusDevice parent_obj;<br><br>    MemoryRegion mmio;<br><br>    qemu_irq irq[SIFIVE_GPIO_PINS];<br>    qemu_irq output[SIFIVE_GPIO_PINS];<br><br>    <span class="hljs-keyword">uint32_t</span> value; <span class="hljs-comment">/* Actual value of the pin */</span><br>    <span class="hljs-keyword">uint32_t</span> input_en;<br>    <span class="hljs-keyword">uint32_t</span> output_en;<br>    <span class="hljs-keyword">uint32_t</span> port; <span class="hljs-comment">/* Pin value requested by the user */</span><br>    <span class="hljs-keyword">uint32_t</span> pue;<br>    <span class="hljs-keyword">uint32_t</span> ds;<br>    <span class="hljs-keyword">uint32_t</span> rise_ie;<br>    <span class="hljs-keyword">uint32_t</span> rise_ip;<br>    <span class="hljs-keyword">uint32_t</span> fall_ie;<br>    <span class="hljs-keyword">uint32_t</span> fall_ip;<br>    <span class="hljs-keyword">uint32_t</span> high_ie;<br>    <span class="hljs-keyword">uint32_t</span> high_ip;<br>    <span class="hljs-keyword">uint32_t</span> low_ie;<br>    <span class="hljs-keyword">uint32_t</span> low_ip;<br>    <span class="hljs-keyword">uint32_t</span> iof_en;<br>    <span class="hljs-keyword">uint32_t</span> iof_sel;<br>    <span class="hljs-keyword">uint32_t</span> out_xor;<br><br>    <span class="hljs-comment">/* config */</span><br>    <span class="hljs-keyword">uint32_t</span> ngpio;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>SIFIVEGPIOState</code>用来表示<code>GPIO</code>外设，你要在板子上添加<code>GPIO</code>设备，就必须分配，设置一个<code>SIFIVEGPIOState</code>结构体。</p><p>板子上不止有一个<code>GPIO</code>端口，假设有10个，那么应该有对应的10个<code>GPIO</code>结构体。这10个<code>GPIO</code>是类似的，同属于某类：用<code>TypeImpl</code>来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeImpl</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br><br>    <span class="hljs-keyword">size_t</span> class_size;<br><br>    <span class="hljs-keyword">size_t</span> instance_size;<br>    <span class="hljs-keyword">size_t</span> instance_align;<br><br>    <span class="hljs-keyword">void</span> (*class_init)(ObjectClass *klass, <span class="hljs-keyword">void</span> *data);<br>    <span class="hljs-keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="hljs-keyword">void</span> *data);<br><br>    <span class="hljs-keyword">void</span> *class_data;<br><br>    <span class="hljs-keyword">void</span> (*instance_init)(Object *obj);<br>    <span class="hljs-keyword">void</span> (*instance_post_init)(Object *obj);<br>    <span class="hljs-keyword">void</span> (*instance_finalize)(Object *obj);<br><br>    <span class="hljs-keyword">bool</span> abstract;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *parent;<br>    TypeImpl *parent_type;<br><br>    ObjectClass *<span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br><br>    <span class="hljs-keyword">int</span> num_interfaces;<br>    InterfaceImpl interfaces[MAX_INTERFACES];<br>&#125;;<br></code></pre></td></tr></table></figure><p>谁来分配、设置<code>SIFIVEGPIOState</code>结构体？</p><ul><li>分配：<br>  根据<code>TypeInfo</code>中的<code>instrance_size</code>来<code>malloc</code>出结构体。</li><li>设置：<br>  调用<code>TypeInfo</code>中的<code>instrance_init</code>函数来设置刚<code>malloc</code>出的结构体。</li></ul><h4 id="方法一：object-initialize-child"><a href="#方法一：object-initialize-child" class="headerlink" title="方法一：object_initialize_child"></a>方法一：object_initialize_child</h4><p>参考<code>hw/arm/fsl-imx6ul.c</code>，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    * GPIOs 1 to 5</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FSL_IMX6UL_NUM_GPIOS; i++) &#123;<br>    <span class="hljs-built_in">snprintf</span>(name, NAME_SIZE, <span class="hljs-string">&quot;gpio%d&quot;</span>, i);<br>    object_initialize_child(obj, name, &amp;s-&gt;gpio[i], TYPE_IMX_GPIO);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>object_initialize_child</code>该函数的第<code>5</code>个参数是<code>type</code>，表示<code>type name</code>，<br>它会被用来找到对应的<code>TypeImpl</code>;<br>找到后，会分配<code>instance_size</code>大小的结构体；<br>然后调用<code>TypeImpl</code>中的<code>class_init</code>函数，这一般是设置<code>dc-&gt;realize</code>;<br>最后调用<code>TypeImpl</code>中的<code>instance_init</code>函数。</p><p>调用流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">object_initialize_child(obj, name, &amp;s-&gt;gpio[i], TYPE_IMX_GPIO);<br>    object_initialize_child_internal()<br>        object_initialize_child_with_props()<br>            object_initialize_child_with_propsv()<br>                object_initialize()<br>                    object_initialize_with_type()<br>                        type_initialize()<br>                        &#123;<br>                            <span class="hljs-keyword">if</span> (ti-&gt;class_init) <br>                            &#123;<br>                                ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data);<br>                            &#125;<br>                        &#125;<br>                        object_init_with_type()<br>                        &#123;       <br>                            <span class="hljs-keyword">if</span> (ti-&gt;instance_init) &#123;<br>                                ti-&gt;instance_init(obj);<br>                            &#125;<br>                        &#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决一台电脑配置两个GIT账户</title>
    <link href="/2021/10/30/%E8%A7%A3%E5%86%B3%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E4%B8%A4%E4%B8%AAGIT%E8%B4%A6%E6%88%B7/"/>
    <url>/2021/10/30/%E8%A7%A3%E5%86%B3%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E4%B8%A4%E4%B8%AAGIT%E8%B4%A6%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<p>公司的也在用git，但是账号和地址肯定都不同，需要配置两个不同的提交环境。</p><h2 id="生成两个Key"><a href="#生成两个Key" class="headerlink" title="生成两个Key"></a>生成两个Key</h2><h3 id="生成第一个Key"><a href="#生成第一个Key" class="headerlink" title="生成第一个Key"></a>生成第一个Key</h3><p>如果电脑上已经在用Git了就无需重新生成key，用当前的就可以。key保存在<code>~/.ssh</code>文件夹内。</p><p>如果第一次使用，就使用以下命令重新生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  .ssh ssh-keygen -t rsa -C home_pc<br>Generating public/private rsa key pair.<br>Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/home/dominic/.ssh/id_rsa): id_rsa_pc<br><br></code></pre></td></tr></table></figure><p><code>home_pc</code>就是个备注名，假设我们这个key是平时捣腾GitHub玩，用来和GitHub同步用的，<code>id_rsa_pc</code>是生成的文件名，打开<code>id_rsa_pc.pub</code>可以看到生成的key最后就是备注名（如下）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">ssh<span class="hljs-literal">-rsa</span> AAAAB3NzaC1yc2EAAAADAQABAAABR/Fyj7Pz+e+/////////////////ZbdPGtHB86fLQYh/uR+TKcCERedrDKzGPdVt8= home_pc<br></code></pre></td></tr></table></figure><h3 id="配置Github-SSH"><a href="#配置Github-SSH" class="headerlink" title="配置Github SSH"></a>配置Github SSH</h3><p>路径为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">Github-头像<span class="hljs-literal">-settings</span><span class="hljs-literal">-SSH</span> and GPG keys<span class="hljs-literal">-New</span> SSH key<br></code></pre></td></tr></table></figure><h3 id="测试连通"><a href="#测试连通" class="headerlink" title="测试连通"></a>测试连通</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure><h3 id="生成第二Key"><a href="#生成第二Key" class="headerlink" title="生成第二Key"></a>生成第二Key</h3><p>这个key就打算用来和公司代码同步用，所以备注名换成了<code>work_ubuntu</code>，文件名也换成了<code>id_rsa_work</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  .ssh ssh-keygen -t rsa -C work_ubuntu<br>Generating public/private rsa key pair.<br>Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/home/dominic/.ssh/id_rsa): id_rsa_work<br><br></code></pre></td></tr></table></figure><h3 id="配置公司-SSH"><a href="#配置公司-SSH" class="headerlink" title="配置公司 SSH"></a>配置公司 SSH</h3><p>和GitHub类似，根据自己公司使用的平台设置。</p><h2 id="配置本地账户"><a href="#配置本地账户" class="headerlink" title="配置本地账户"></a>配置本地账户</h2><p>因为本地的代码仓库可能是从GitHub下载的，也有从公司仓库下载的。那么提交代码时就需要为仓库配置指定的用户名和邮箱。以前只有一个GitHub，所以配置时使用的是<code>-global</code>参数，任何一个仓库都是配置的相同的用户名与邮箱，而现在需要区分。</p><h3 id="取消全局配置"><a href="#取消全局配置" class="headerlink" title="取消全局配置"></a>取消全局配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-comment"># 取消全局 用户名/邮箱 配置</span><br>git config --global --<span class="hljs-built_in">unset</span> user.name<br>git config --global --<span class="hljs-built_in">unset</span> user.email<br><br><br></code></pre></td></tr></table></figure><h3 id="单独配置代码仓"><a href="#单独配置代码仓" class="headerlink" title="单独配置代码仓"></a>单独配置代码仓</h3><p>进入项目目录，有<code>.git</code>目录的那一级。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 单独设置每个repo 用户名/邮箱</span><br>git config user.email “xxxx@xx.com”<br>git config user.name “xxxx”<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言复杂声明</title>
    <link href="/2021/10/22/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/"/>
    <url>/2021/10/22/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>C语言常常因为声明的语法问题而受到人们的批评，特别是涉及到函数指针的语法。C语言的语法力图使声明和使用相一致。对于简单的情况， C语言的做法是很有效的，但是，如果情况比较复杂，则容易让人混淆，原因在于， C语言的声明不能从左至右阅读，而且使用了太多的圆括号。<br>在C中，声明的形式为（dcl是declaration的简写）：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">dcl: optional *&#x27;s <span class="hljs-built_in">direct</span>-dcl（含有可选<span class="hljs-string">&quot;*&quot;</span>的<span class="hljs-built_in">direct</span>-dcl）<br><span class="hljs-built_in">direct</span>-dcl name<br>            (dcl)<br>            <span class="hljs-built_in">direct</span>-dcl()<br>            <span class="hljs-built_in">direct</span>-dcl[optional size] <br></code></pre></td></tr></table></figure><p>简而言之,声明符<code>dc1</code>(可以理解成间接声明)就是前面可能带有多个<code>*</code>的<code>direcr-dclo</code>。<code> direct-dcl</code>可以是<code>name</code>、由一对圆括号括起来的<code>dcl</code>、后面跟有一对圆括号的<code>direct-dcl</code>、后面跟有用方括号括起来的表示可选长度的<code>direc-dcl</code>。</p><p>根据该规则进行逆向解析，就可以得到正确的声明。简化一下：<code>TypeName Declarator;</code>其中，<code>Declarator</code>就是声明中的那个<code>name</code>。当你遇到任何你不能理解的声明时，这个法则就是救命稻草。最简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> aInt;<br></code></pre></td></tr></table></figure><p>这里，<code>int</code>是<code>TypeName</code>，<code>aInt</code>是<code>Declarator</code>。</p><p>再说明一下结合紧密度。在声或定义变量时，可以使用一些修饰比如<code>*</code>，<code>[]</code>，<code>()</code>等。<code>()</code>（非函数声明中的<code>()</code>）具有最高的紧密度，其次才是函数和数组的<code>()</code>和<code>[]</code>。</p><p>没有<code>*</code>的声明称为直接声明（<code>direct-dcl</code>），而有<code>*</code>称为声明（<code>dcl</code>）。直接声明要比声明结合的紧。分解声明时，先读出结合紧的。在这里，我把<code>direct-dcl</code>称为更紧的结合，它比<code>dcl</code>结合得紧。</p><p>最后，需要你用英语来读出这个声明。对于<code>[]</code>，应该读成<code>array of</code>。</p><p>对于复杂的定义，可以将其分解。比如<code>T (*p)()</code>可以分解成<code>T D1()</code>，<code>D1</code>读作：*<code>function returning T</code><em>。其中<code>D1</code>是<code>*p</code>。那么该声明应该读成：</em><code>p is a poniter to</code>*。二者合在一起，就变成了 *<code>p is a pointer to function returning T</code>*，即：<code>p</code>是指向返回<code>T</code>类对象的函数的指针。</p><p>再看一个稍微复杂的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">T (*pfa[])();<br></code></pre></td></tr></table></figure><p>根据<code>dcl</code>和<code>direct-dcl</code>，可以分解成<code>T1 D1</code>（因为结合紧密度），<code>T1</code>也就是<code>T ()</code>，那么应该读作：<br>*<code>D1 is function returning T</code>*。</p><p><code>D1</code>又可以写成<code>T2 D2</code>，其中<code>T2</code>是<code>T1 []</code>，可以分解成<code>T1 D2[]</code>，读作：*<code>array of D2 function returning T</code>*。</p><p><code>D2</code>是指针，读作：*<code>pointers to</code><em>。那么整个 <em><code>T (*pfa[])()</code></em> 应该读作：</em><code>pfa is an array of pointers to function returning T</code>*，即：<code>pfa</code>是个存放指向返回T类对象函数的指针的数组。</p><p>换种方式看，在这个例子中，<code>pfa</code>是名字，<code>T(*[])()</code>是类型。将<code>(*pfa[])</code>视为一体（<code>direct-dcl</code>），称为<code>D1</code>，那么可以写成<code>T D1()</code>，*<code>function returning object of T</code>*。在<code>D1</code>中，将<code>*pfa</code>视为一体（<code>dcl</code>），称为<code>D2</code>，那么<code>*pfa[]</code>应该是<code>D2[]</code>（direct-dcl），<code>array of D2</code>。合起来就是 *<code>array of D2 function returning object of T</code>*。<code>D2</code>是<code>*pfa</code>（dcl），替换到前面这句话，结果就是 *<code>array of pointers to function returning object of T</code>*。</p><p>有了这些说明，可以试着做一下下面的题，看看自己是否真的理解了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> **argv<br>    <span class="hljs-comment">// argv:  pointer to pointer to char</span><br>    <span class="hljs-comment">// 指向char型指针的指针</span><br><span class="hljs-keyword">int</span> (*daytab)[<span class="hljs-number">13</span>]<br>    <span class="hljs-comment">// daytab:  pointer to array[13] of int</span><br>    <span class="hljs-comment">// 指向int型数组的指针</span><br><span class="hljs-keyword">int</span> *daytab[<span class="hljs-number">13</span>]<br>    <span class="hljs-comment">// daytab:  array[13] of pointer to int</span><br>    <span class="hljs-comment">// 存放int型指针的数组</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">comp</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-comment">// comp: function returning pointer to void</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回值为指向void型指针的函数</span></span><br><span class="hljs-function"><span class="hljs-title">void</span> <span class="hljs-params">(*comp)</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-comment">// comp: pointer to function returning void</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 指向返回值为void型函数的指针</span></span><br><span class="hljs-function"><span class="hljs-title">char</span> <span class="hljs-params">(*(*x())[])</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-comment">// x: function returning pointer to array[] of</span></span><br><span class="hljs-function">    <span class="hljs-comment">// pointer to function returning char</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回值为char型的函数</span></span><br><span class="hljs-function"><span class="hljs-title">char</span> <span class="hljs-params">(*(*x[<span class="hljs-number">3</span>])())</span>[5]</span><br><span class="hljs-function">    <span class="hljs-comment">// x: array[3] of pointer to function returning</span></span><br><span class="hljs-function">    <span class="hljs-comment">// pointer to array[5] of char</span></span><br></code></pre></td></tr></table></figure><p>理解复杂声明可用的“右左法则”：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">int</span> (*<span class="hljs-function"><span class="hljs-keyword">func</span>)<span class="hljs-params">(<span class="hljs-keyword">int</span> *p)</span>;</span><br></code></pre></td></tr></table></figure><p>首先找到变量名<code>func</code>，外面有一对圆括号，而且左边是一个<code>*</code>号，这说明<code>func</code>是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明<code>(*func)</code>是一个函数，所以<code>func</code>是一个指向这类函数的指针，即函数指针，这类函数具有<code>int*</code>类型的形参，返回值类型是<code>int</code>。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">int <span class="hljs-comment">(*func[5])(int *)</span>;<br></code></pre></td></tr></table></figure><p><code>func</code>右边是一个<code>[]</code>运算符，说明<code>func</code>是具有<code>5</code>个元素的数组；<code>func</code>的左边有一个<code>*</code>，说明<code>func</code>的元素是指针（注意这里的<code>*</code>不是修饰<code>func</code>，而是修饰<code>func[5]</code>的，原因是<code>[]</code>运算符优先级比<code>*</code>高，<code>func</code>先跟<code>[]</code>结合）。跳出这个括号，看右边，又遇到圆括号，说明<code>func</code>数组的元素是函数类型的指针，它指向的函数具有<code>int*</code>类型的形参，返回值类型为<code>int</code>。</p><p>在C++中，规则比C要复杂一些。不过，基本思想保持不变，按照C的原则来理解复杂的声明，基本上就能满足要求了。没有在这里列出C++的规则一方面是因为太广，不能覆盖全；另一个原因就是，按照C的规则来就足够了，毕竟C++要与C兼容。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言共享内存实现CyclicBuffer循环缓冲区</title>
    <link href="/2021/10/21/C%E8%AF%AD%E8%A8%80%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0CyclicBuffer%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    <url>/2021/10/21/C%E8%AF%AD%E8%A8%80%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0CyclicBuffer%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>完整代码详见<a href="https://github.com/Dunky-Z/learning-linux/tree/main/helloworld/c/CyclicBuffer">GitHub CyclicBuffer</a>。</p><h2 id="什么是循环缓冲区"><a href="#什么是循环缓冲区" class="headerlink" title="什么是循环缓冲区"></a>什么是循环缓冲区</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211021171456.gif"></p><p>循环缓冲区通常应用在模块与模块之间的通信，可以减少程序挂起的时间，节省内存空间。</p><p>如图所示，蓝色箭头表示读取指针，红色表示写入指针。写入指针可以在缓冲区有剩余空间时不中断地写入数据，读取指针可以在循环缓冲区有数据时不停读取。</p><h2 id="如何设计循环缓冲区"><a href="#如何设计循环缓冲区" class="headerlink" title="如何设计循环缓冲区"></a>如何设计循环缓冲区</h2><p>为了方便两个进程之间的通信，我们在共享内存中创建循环缓冲区。基本原理如图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211021173628.png"></p><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CyclicBuffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">uint8_t</span> buf[CYCBUFFSIZ];    <span class="hljs-comment">//缓冲区</span><br>    <span class="hljs-keyword">uint8_t</span> read;               <span class="hljs-comment">//读指针</span><br>    <span class="hljs-keyword">uint8_t</span> write;              <span class="hljs-comment">//写指针</span><br>    <span class="hljs-keyword">uint32_t</span> valid_size;        <span class="hljs-comment">//已写入数据数</span><br>&#125; CyCBuf;<br></code></pre></td></tr></table></figure><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cycbuff_write</span><span class="hljs-params">(CyCBuf *cycbuff, <span class="hljs-keyword">uint8_t</span> ch)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (cycbuff_isfull(cycbuff))<br>        ;<br>    cycbuff-&gt;buf[cycbuff-&gt;write] = ch;<br>    cycbuff-&gt;write++;<br>    cycbuff-&gt;write %= CYCBUFFSIZ;<br>    cycbuff-&gt;valid_size++;<br>&#125;<br></code></pre></td></tr></table></figure><p>写入数据前，要检查缓冲区是否已满，如果已满就得挂起等待。直到缓冲区有空间再进行写入。</p><p>写入指针每次写完向后偏移一位，<code>valid_size</code>记录当前缓冲区中有效数据个数。</p><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">cycbuff_read</span><span class="hljs-params">(CyCBuf *cycbuff)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint8_t</span> ch;<br>    <span class="hljs-keyword">while</span> (cycbuff_isempty(cycbuff))<br>        ;<br>    ch = cycbuff-&gt;buf[cycbuff-&gt;read];<br>    cycbuff-&gt;read++;<br>    cycbuff-&gt;read %= CYCBUFFSIZ;<br>    cycbuff-&gt;valid_size--;<br>    <span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取数据前，要检查缓冲区是否为空，如果为空就要挂起等待。</p><h3 id="判断空"><a href="#判断空" class="headerlink" title="判断空"></a>判断空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cycbuff_isempty</span><span class="hljs-params">(CyCBuf *cycbuff)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cycbuff-&gt;valid_size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断满"><a href="#判断满" class="headerlink" title="判断满"></a>判断满</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cycbuff_isfull</span><span class="hljs-params">(CyCBuf *cycbuff)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cycbuff-&gt;valid_size == CYCBUFFSIZ)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本次实验中，为了方便期间，用<code>valid_size</code>保存有效数据个数，没有用读写指针是否重合来判断，这就无需再考虑读写指针重合时，是空还是满。</p><h2 id="数据收发流程"><a href="#数据收发流程" class="headerlink" title="数据收发流程"></a>数据收发流程</h2><h3 id="服务端-写入"><a href="#服务端-写入" class="headerlink" title="服务端-写入"></a>服务端-写入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(CyCBuf *cycbuff, SHMS *shms)</span></span><br><span class="hljs-function"></span>&#123;<br>    cycbuff_init(cycbuff);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Enter Message: &quot;</span>);<br>        <span class="hljs-keyword">uint8_t</span> ch[BUFFERSIZE];<br>        fgets(ch, BUFFERSIZE, <span class="hljs-built_in">stdin</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; ch[i] != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; i &lt; BUFFERSIZE; i++)<br>        &#123;<br>            cycbuff_write(cycbuff, ch[i]);<br>        &#125;<br>        cycbuff_write(cycbuff, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SHMS *shms</code>为共享内存相关数据，有关共享内存的使用可以参考<a href="https://dunky-z.github.io/2021/08/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88SharedMemory%EF%BC%89/">进程间通信（IPC）之共享内存（SharedMemory）</a>。</p><h3 id="客户端-读取"><a href="#客户端-读取" class="headerlink" title="客户端-读取"></a>客户端-读取</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">(CyCBuf *cycbuff, SHMS *shms)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server operational: shm id is %d\n&quot;</span>, shms-&gt;shmid);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">uint8_t</span> ch;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Recv Message: &quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            ch = cycbuff_read(cycbuff);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            fflush(<span class="hljs-built_in">stdout</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取数据以回车符为分界，当读到回车符时进行换行处理，并等待接收下一波数据。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211021195237.gif"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Circular_buffer">Circular buffer</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决gcc编译后fflush失效</title>
    <link href="/2021/10/21/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/"/>
    <url>/2021/10/21/%E8%A7%A3%E5%86%B3gcc%E7%BC%96%E8%AF%91%E5%90%8Efflush%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>使用<code>scanf()</code>获取输入时，因为涉及键盘缓冲区的问题，每次输入后想要把缓冲清空，但是在gcc编译后，使用<code>fflush</code>无法清空缓冲区。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>C标准(ISO/IEC 9899:1999 standard)规定<code>fflush(stdin)</code>操作是未定义的&lt;参看《ISO/IEC 9899:1999 standard》p270&gt;;。也就是说不一定能实现刷新功能，但有的编译器可能不遵循标准，对<code>fflush(stdin)</code>操作不予警告，并且有时可能产生正确的结果，但最好不要这样使用。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>通过 <code>while</code> 循环把输入流中的余留数据“吃”掉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> c;<br><span class="hljs-keyword">while</span> ((c=getchar()) != ‘\n’ &amp;&amp; c != EOF);<br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V入门（3）-RVOS系统引导</title>
    <link href="/2021/10/20/RISC-V%E5%85%A5%E9%97%A8%EF%BC%883%EF%BC%89-%20RVOS%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/"/>
    <url>/2021/10/20/RISC-V%E5%85%A5%E9%97%A8%EF%BC%883%EF%BC%89-%20RVOS%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="硬件的基本概念"><a href="#硬件的基本概念" class="headerlink" title="硬件的基本概念"></a>硬件的基本概念</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202320868.png"></p><ul><li>Hart</li><li>Platform<br>不能说是个板子，应该理解为芯片。早期的板子就是一块芯片加上各种外设，但是随着技术发展，板子越来越小，外设却并没有变少 ，是因为外设都被集成到了芯片中。当所有外设都被集成，那么芯片就是platform。</li><li>SoC(System on Chip)<br>片上系统</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202328649.png"></p><p>QEMU模拟virt这个平台，这个平台有八个Hart。</p><h2 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202331403.png"></p><p>为了方便访问外设，现在主流的platform会对外设的内存地址做一个映射。映射到platform的真实物理地址。对真实物理地址进行操作时，就是对外设的地址进行操作。</p><p>物理地址从最低位到最高位都被分配给了各种外设。</p><h2 id="引导过程介绍"><a href="#引导过程介绍" class="headerlink" title="引导过程介绍"></a>引导过程介绍</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110202342918.png"></p><p>通电后，会先到箭头所指的地址，这个地址就是对应的ROM外设首地址。ROM相当于一个小硬盘，断电后不会丢失数据。这里面固化了一些指令。</p><p>主要就是跳转指令，运行到kernel段继续执行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212317389.png"></p><p>八核同时在执行这个过程。</p><p>以上是硬件的部分过程，软件该如何写？</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212320524.png"></p><p>为了简化学习流程和降低调试难度，目前只支持单核，其余七个核处于空转状态。</p><h3 id="如何判断当前Hart是不是第一个？"><a href="#如何判断当前Hart是不是第一个？" class="headerlink" title="如何判断当前Hart是不是第一个？"></a>如何判断当前Hart是不是第一个？</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212323556.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212325328.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212325081.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212327552.png"></p><p>以上指令就是将寄存器值进行一次交换，只不过这个过程是原子性的，不能被打断。</p><p><code>CSRRW</code>经常会用在伪指令<code>CSRW</code>中，完整指令中，第一步向<code>x0</code>写入数据，就是空操作，第二步将<code>rs</code>写入<code>csr</code>。这个伪指令就是完成了一个写入<code>csr</code>的操作。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212333753.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212335906.png"></p><p><code>mhartid</code>就是<code>machine hart id</code>。</p><p>学习以上几个指令 ，就可以完成判断hart是否为第一个的工作了， </p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110212337619.png"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">csrr <span class="hljs-built_in">t0</span>, mhartid    <span class="hljs-comment">#读寄存器值</span><br>mv tp, <span class="hljs-built_in">t0</span>           #<br><span class="hljs-keyword">bnez </span><span class="hljs-built_in">t0</span>, park       <span class="hljs-comment"># 跳转指令，不等于0就跳转到park标签</span><br></code></pre></td></tr></table></figure><h2 id="UART硬件介绍"><a href="#UART硬件介绍" class="headerlink" title="UART硬件介绍"></a>UART硬件介绍</h2><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211022171638.png"></p><p>真实的硬件开发是有一个快开发板，但是这个课程里使用的是QEMU来模拟开发板的硬件环境。如果要在程序里打印一段信息，正常的情况是在开发板上连接显示器，但是这里是通过将信息用串口传到主机上，然后用主机的屏幕显示信息。</p><p>串口线里是有两根线，负责收信息和发信息。</p><h3 id="UART特点"><a href="#UART特点" class="headerlink" title="UART特点"></a>UART特点</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211022172156.png"></p><ul><li>并行就是需要多根线，比如有两根线，那么就可以一次发送两位。但是串行节省材料。</li><li>数据通信就会涉及同步的问题，同步的话需要一根时钟线来协商好发送时间和接收时间。而UART使用异步，发送的数据不仅仅是真实的数据，还会带有一些标识信息。这些标识可以判断出是收还是发。</li></ul><h3 id="物理接口"><a href="#物理接口" class="headerlink" title="物理接口"></a>物理接口</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252233134.png"></p><h3 id="UART通讯协议"><a href="#UART通讯协议" class="headerlink" title="UART通讯协议"></a>UART通讯协议</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252235270.png"></p><p>图示中横轴可以表示时间，纵轴表示高低电平。</p><p>在需要发送数据时，会进行“下拉”1bit，1bit持续的时间就是波特率分之一秒。</p><p>数据在发送过程中可能会受到干扰，会产生畸变，所以需要检验位来判断是否发生畸变。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252246423.png"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252305528.png"></p><p>在软件中，配置UART就是配置寄存器的信息。</p><p>在板子上有个元器件叫晶振（crystal），他会产生固定频率的时钟。一种是1.8432MHZ，一种是7.3728MHZ。想要获得指定的输出频率就需要对寄存器进行配置。查表可以得到配置信息。比如获得38.4K频率的输出，就要配置寄存器值为3。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110252310435.png"></p><p>LCR寄存器功能比较多，将第7位设置为1就是用来设置波特率。</p><p>图中<code>DLL</code>和<code>DLM</code>寄存器就是需要配置的寄存器。因为UART寄存器都是8位的，将值<code>0x0003</code>高位<code>0x00</code>存在<code>DLM</code>中，将低位<code>0x03</code>存入<code>DLL</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Segmentation fault (core dumped)</title>
    <link href="/2021/10/20/%E8%A7%A3%E5%86%B3Segmentation-fault-core-dumped/"/>
    <url>/2021/10/20/%E8%A7%A3%E5%86%B3Segmentation-fault-core-dumped/</url>
    
    <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><p>在使用半导体作为内存的材料前，人类是利用线圈当作内存的材料（发明者为王安），线圈就叫作 <code>core</code> ，用线圈做的内存就叫作 <code>core memory</code>。如今 ，半导体工业澎勃发展，已经没有人用<code>core memory</code> 了，不过，在许多情况下，人们还是把记忆体叫作 <code>core</code> 。</p><h3 id="Core-dump"><a href="#Core-dump" class="headerlink" title="Core dump"></a>Core dump</h3><p>我们在开发（或使用）一个程序时，最怕的就是程序莫明其妙地宕掉。虽然系统没事，但我们下次仍可能遇到相同的问题。于是这时操作系统就会把程序宕掉时的内存内容 <code>dump</code> 出来（现在通常是写在一个叫 <code>core</code> 的 <code>file</code> 里面），让我们做为参考。这个动作就叫作 <code>core dump</code>。</p><h3 id="如何获取Core文件"><a href="#如何获取Core文件" class="headerlink" title="如何获取Core文件"></a>如何获取Core文件</h3><p>1、在一些Linux版本下，默认是不产生<code>core</code>文件的，首先可以查看一下系统<code>core</code>文件的大小限制：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>:~/segfault<span class="hljs-symbol">$</span> ulimit -c<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>2、可以看到默认设置情况下，本机Linux环境下发生段错误时不会自动生成<code>core</code>文件，下面设置下<code>core</code>文件的大小限制（单位为KB）：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>:~/segfault<span class="hljs-symbol">$</span> ulimit -c <span class="hljs-number">1024</span><br><span class="hljs-symbol">$</span>:~/segfault<span class="hljs-symbol">$</span> ulimit -c<br><span class="hljs-number">1024</span><br></code></pre></td></tr></table></figure><p>3、重新运行程序，如果发生段错误，就会生成<code>core</code>文件。</p><h2 id="出现段错误的可能原因"><a href="#出现段错误的可能原因" class="headerlink" title="出现段错误的可能原因"></a>出现段错误的可能原因</h2><h3 id="访问不存在的内存地址"><a href="#访问不存在的内存地址" class="headerlink" title="访问不存在的内存地址"></a>访问不存在的内存地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> *ptr = <span class="hljs-literal">NULL</span>;<br>        *ptr = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问系统保护的内存地址"><a href="#访问系统保护的内存地址" class="headerlink" title="访问系统保护的内存地址"></a>访问系统保护的内存地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> *ptr = (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0</span>;<br>        *ptr = <span class="hljs-number">100</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问只读的内存地址"><a href="#访问只读的内存地址" class="headerlink" title="访问只读的内存地址"></a>访问只读的内存地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">char</span> *ptr = <span class="hljs-string">&quot;test&quot;</span>;<br>        <span class="hljs-built_in">strcpy</span>(ptr, <span class="hljs-string">&quot;TEST&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        main();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="段错误信息获取"><a href="#段错误信息获取" class="headerlink" title="段错误信息获取"></a>段错误信息获取</h2><p>程序发生段错误时，提示信息很少，下面有几种查看段错误的发生信息的途径。</p><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>dmesg可以在应用程序crash掉时，显示内核中保存的相关信息。如下所示，通过<code>dmesg</code>命令可以查看发生段错误的程序名称、引起段错误发生的内存地址、指令指针地址、堆栈指针地址、错误代码、错误原因等。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$:~/segfault$ dmesg<br><span class="hljs-selector-attr">[ 2329.479037]</span> segfault3<span class="hljs-selector-attr">[2700]</span>: segfault at <span class="hljs-number">80484</span>e0 ip <span class="hljs-number">00</span>d2906a sp bfbbec3c error <span class="hljs-number">7</span> <span class="hljs-keyword">in</span> libc-<span class="hljs-number">2.10</span>.<span class="hljs-number">1</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-attr">[cb4000+13e000]</span><br></code></pre></td></tr></table></figure><h3 id="g"><a href="#g" class="headerlink" title="-g"></a>-g</h3><p>使用gcc编译程序的源码时，加上<code>-g</code>参数，这样可以使得生成的二进制文件中加入可以用于gdb调试的有用信息。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>:~/segfault<span class="hljs-symbol">$</span> gcc -g -o segfault3 segfault3.c<br><br></code></pre></td></tr></table></figure><h3 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h3><p>使用nm命令列出二进制文件中的符号表，包括符号地址、符号类型、符号名等，这样可以帮助定位在哪里发生了段错误。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs sqf">panfeng@ubuntu:~/segfault$ nm segfault3<br><span class="hljs-number">08049</span>f20 d <span class="hljs-variable">_DYNAMIC</span><br><span class="hljs-number">08049</span>ff4 d <span class="hljs-variable">_GLOBAL_OFFSET_TABLE_</span><br><span class="hljs-number">080484</span>dc R <span class="hljs-variable">_IO_stdin_used</span><br>         w <span class="hljs-variable">_Jv_RegisterClasses</span><br><span class="hljs-number">08049</span>f10 d <span class="hljs-variable">__CTOR_END__</span><br><span class="hljs-number">08049</span>f0c d <span class="hljs-variable">__CTOR_LIST__</span><br><span class="hljs-number">08049</span>f18 D <span class="hljs-variable">__DTOR_END__</span><br><span class="hljs-number">08049</span>f14 d <span class="hljs-variable">__DTOR_LIST__</span><br><span class="hljs-number">080484</span>ec r <span class="hljs-variable">__FRAME_END__</span><br><span class="hljs-number">08049</span>f1c d <span class="hljs-variable">__JCR_END__</span><br><span class="hljs-number">08049</span>f1c d <span class="hljs-variable">__JCR_LIST__</span><br><span class="hljs-number">0804</span>a014 A <span class="hljs-variable">__bss_start</span><br><span class="hljs-number">0804</span>a00c D <span class="hljs-variable">__data_start</span><br><span class="hljs-number">08048490</span> t <span class="hljs-variable">__do_global_ctors_aux</span><br><span class="hljs-number">08048360</span> t <span class="hljs-variable">__do_global_dtors_aux</span><br><span class="hljs-number">0804</span>a010 D <span class="hljs-variable">__dso_handle</span><br>         w <span class="hljs-variable">__gmon_start__</span><br><span class="hljs-number">0804848</span>a T <span class="hljs-variable">__i686</span>.get_pc_thunk.bx<br><span class="hljs-number">08049</span>f0c d <span class="hljs-variable">__init_array_end</span><br><span class="hljs-number">08049</span>f0c d <span class="hljs-variable">__init_array_start</span><br><span class="hljs-number">08048420</span> T <span class="hljs-variable">__libc_csu_fini</span><br><span class="hljs-number">08048430</span> T <span class="hljs-variable">__libc_csu_init</span><br>         U <span class="hljs-variable">__libc_start_main</span>@@GLIBC_2.<span class="hljs-number">0</span><br><span class="hljs-number">0804</span>a014 A <span class="hljs-variable">_edata</span><br><span class="hljs-number">0804</span>a01c A <span class="hljs-variable">_end</span><br><span class="hljs-number">080484</span>bc T <span class="hljs-variable">_fini</span><br><span class="hljs-number">080484</span>d8 R <span class="hljs-variable">_fp_hw</span><br><span class="hljs-number">080482</span>bc T <span class="hljs-variable">_init</span><br><span class="hljs-number">08048330</span> T <span class="hljs-variable">_start</span><br><span class="hljs-number">0804</span>a014 b completed.<span class="hljs-number">6990</span><br><span class="hljs-number">0804</span>a00c W data_start<br><span class="hljs-number">0804</span>a018 b dtor_idx.<span class="hljs-number">6992</span><br><span class="hljs-number">080483</span>c0 t frame_dummy<br><span class="hljs-number">080483</span>e4 T main<br>         U memcpy@@GLIBC_2.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h3><p>使用ldd命令查看二进制程序的共享链接库依赖，包括库的名称、起始地址，这样可以确定段错误到底是发生在了自己的程序中还是依赖的共享库中。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">$:~<span class="hljs-regexp">/segfault$ ldd ./</span>segfault3<br>    linux-gate.so.<span class="hljs-number">1</span> =&gt;  (<span class="hljs-number">0</span>x00e08000)<br>    libc.so.<span class="hljs-number">6</span> =&gt; <span class="hljs-regexp">/lib/</span>tls<span class="hljs-regexp">/i686/</span>cmov/libc.so.<span class="hljs-number">6</span> (<span class="hljs-number">0</span>x00675000)<br>    <span class="hljs-regexp">/lib/</span>ld-linux.so.<span class="hljs-number">2</span> (<span class="hljs-number">0</span>x00482000)<br></code></pre></td></tr></table></figure><h2 id="调试方法和技巧"><a href="#调试方法和技巧" class="headerlink" title="调试方法和技巧"></a>调试方法和技巧</h2><h3 id="使用gcc和gdb"><a href="#使用gcc和gdb" class="headerlink" title="使用gcc和gdb"></a>使用gcc和gdb</h3><h4 id="调试流程"><a href="#调试流程" class="headerlink" title="调试流程"></a>调试流程</h4><ol><li>为了能够使用gdb调试程序，在编译阶段加上-g参数，</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>:~/segfault<span class="hljs-symbol">$</span> gcc -g -o segfault3 segfault3.c<br></code></pre></td></tr></table></figure><ol start="2"><li>使用gdb命令调试程序：</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$:~<span class="hljs-regexp">/segfault$ gdb -q ./</span>segfault3 <br>Reading symbols <span class="hljs-keyword">from</span> ./segfault3...done.<br>(gdb) <br></code></pre></td></tr></table></figure><ol start="3"><li>进入gdb后，运行程序：</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">(gdb) run<br>Starting program: ./segfault3 <br><br>Program received signal SIGSEGV, Segmentation fault.<br><span class="hljs-number">0</span>x001a306a in memcpy () <span class="hljs-keyword">from</span> <span class="hljs-regexp">/lib/</span>tls<span class="hljs-regexp">/i686/</span>cmov/libc.so.<span class="hljs-number">6</span><br>(gdb) <br></code></pre></td></tr></table></figure><p>从输出看出，程序收到<code>SIGSEGV</code>信号，触发段错误，并提示地址<code>0x001a306a</code>、调用memcpy报的错，位于<code>/lib/tls/i686/cmov/libc.so.6</code>库中。</p><ol start="4"><li>完成调试后，输入<code>quit</code>命令退出gdb：</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ol><li><p>仅当能确定程序一定会发生段错误的情况下使用。</p></li><li><p>当程序的源码可以获得的情况下，使用<code>-g</code>参数编译程序。</p></li><li><p>一般用于测试阶段，生产环境下gdb会有副作用：使程序运行减慢，运行不够稳定，等等。</p></li><li><p>即使在测试阶段，如果程序过于复杂，gdb也不能处理。</p></li></ol><h3 id="使用core文件和gdb"><a href="#使用core文件和gdb" class="headerlink" title="使用core文件和gdb"></a>使用core文件和gdb</h3><p>在上节中提到段错误会触发<code>SIGSEGV</code>信号，通过<code>man 7 signal</code>，可以看到<code>SIGSEGV</code>默认的<code>handler</code>会打印段错误出错信息，并产生<code>core</code>文件，由此我们可以借助于程序异常退出时生成的<code>core</code>文件中的调试信息，使用gdb工具来调试程序中的段错误。</p><h4 id="调试流程-1"><a href="#调试流程-1" class="headerlink" title="调试流程"></a>调试流程</h4><ol><li>运行有段错误的程序，生成core文件。</li><li>gdb加载core文件<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">$:~/segfault$ gdb ./segfault3 ./core <br>Reading symbols <span class="hljs-keyword">from</span> /home/panfeng/segfault/segfault3...done.<br><br><span class="hljs-symbol">warning:</span> Can<span class="hljs-comment">&#x27;t read pathname for load map: 输入/输出错误.</span><br>Reading symbols <span class="hljs-keyword">from</span> /<span class="hljs-keyword">lib</span>/tls/i686/cmov/libc.so.<span class="hljs-number">6</span>...(no debugging symbols found)...done.<br>Loaded symbols <span class="hljs-keyword">for</span> /<span class="hljs-keyword">lib</span>/tls/i686/cmov/libc.so.<span class="hljs-number">6</span><br>Reading symbols <span class="hljs-keyword">from</span> /<span class="hljs-keyword">lib</span>/ld-linux.so.<span class="hljs-number">2</span>...(no debugging symbols found)...done.<br>Loaded symbols <span class="hljs-keyword">for</span> /<span class="hljs-keyword">lib</span>/ld-linux.so.<span class="hljs-number">2</span><br>Core was generated <span class="hljs-keyword">by</span> `./segfault3<span class="hljs-comment">&#x27;.</span><br>Program terminated <span class="hljs-keyword">with</span> signal <span class="hljs-number">11</span>, Segmentation fault.<br>#<span class="hljs-number">0</span>  <span class="hljs-number">0</span>x0018506a <span class="hljs-keyword">in</span> memcpy () <span class="hljs-keyword">from</span> /<span class="hljs-keyword">lib</span>/tls/i686/cmov/libc.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>从输出看出，同上节中一样的段错误信息。</li></ol><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ol><li><p>适合于在实际生成环境下调试程序的段错误（即在不用重新发生段错误的情况下重现段错误）。</p></li><li><p>当程序很复杂，core文件相当大时，该方法不可用。</p></li></ol><h3 id="使用objdump"><a href="#使用objdump" class="headerlink" title="使用objdump"></a>使用objdump</h3><h4 id="调试流程-2"><a href="#调试流程-2" class="headerlink" title="调试流程"></a>调试流程</h4><ol><li><p>使用dmesg命令，找到最近发生的段错误输出信息：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$:~<span class="hljs-string">/segfault</span>$ dmesg<br><span class="hljs-string">...</span> <span class="hljs-string">...</span><br>[17257.502808] segfault3[3320]: segfault at 80484e0 ip 0018506a sp bfc1<span class="hljs-keyword">cd</span>6c error 7 in libc-2.10.1.so[110000+13e000]<br></code></pre></td></tr></table></figure><p>其中，对我们接下来的调试过程有用的是发生段错误的地址：<code>80484e0</code>和指令指针地址：<code>0018506a</code>。</p></li><li><p>使用<code>objdump</code>生成二进制的相关信息，重定向到文件中：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$:~<span class="hljs-regexp">/segfault$ objdump -d ./</span>segfault3 &gt; segfault3Dump<br></code></pre></td></tr></table></figure><p>其中，生成的<code>segfault3Dump</code>文件中包含了二进制文件的<code>segfault3</code>的汇编代码。</p></li><li><p>在<code>segfault3Dump</code>文件中查找发生段错误的地址：</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">panfeng</span>@ubuntu:~/segfault$ grep -n -A <span class="hljs-number">10</span> -B <span class="hljs-number">10</span> <span class="hljs-string">&quot;80484e0&quot;</span> ./segfault<span class="hljs-number">3</span>Dump <br><span class="hljs-attribute">121</span>- <span class="hljs-number">80483</span>df:    ff d<span class="hljs-number">0</span>                    call   *%eax<br><span class="hljs-attribute">122</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">1</span>:    c<span class="hljs-number">9</span>                       leave  <br><span class="hljs-attribute">123</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">2</span>:    c<span class="hljs-number">3</span>                       ret    <br><span class="hljs-attribute">124</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">3</span>:    <span class="hljs-number">90</span>                       nop<br><span class="hljs-attribute">125</span>-<br><span class="hljs-attribute">126</span>-<span class="hljs-number">080483</span>e<span class="hljs-number">4</span> &lt;main&gt;:<br><span class="hljs-attribute">127</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">4</span>:    <span class="hljs-number">55</span>                       push   %ebp<br><span class="hljs-attribute">128</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">5</span>:    <span class="hljs-number">89</span> e<span class="hljs-number">5</span>                    mov    %esp,%ebp<br><span class="hljs-attribute">129</span>- <span class="hljs-number">80483</span>e<span class="hljs-number">7</span>:    <span class="hljs-number">83</span> e<span class="hljs-number">4</span> f<span class="hljs-number">0</span>                 and    $<span class="hljs-number">0</span>xfffffff<span class="hljs-number">0</span>,%esp<br><span class="hljs-attribute">130</span>- <span class="hljs-number">80483</span>ea:    <span class="hljs-number">83</span> ec <span class="hljs-number">20</span>                 sub    $<span class="hljs-number">0</span>x<span class="hljs-number">20</span>,%esp<br><span class="hljs-attribute">131</span>: <span class="hljs-number">80483</span>ed:    c<span class="hljs-number">7</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">1</span>c e<span class="hljs-number">0</span> <span class="hljs-number">84</span> <span class="hljs-number">04</span>     movl   $<span class="hljs-number">0</span>x<span class="hljs-number">80484</span>e<span class="hljs-number">0</span>,<span class="hljs-number">0</span>x<span class="hljs-number">1</span>c(%esp)<br><span class="hljs-attribute">132</span>- <span class="hljs-number">80483</span>f<span class="hljs-number">4</span>:    <span class="hljs-number">08</span> <br><span class="hljs-attribute">133</span>- <span class="hljs-number">80483</span>f<span class="hljs-number">5</span>:    b<span class="hljs-number">8</span> e<span class="hljs-number">5</span> <span class="hljs-number">84</span> <span class="hljs-number">04</span> <span class="hljs-number">08</span>           mov    $<span class="hljs-number">0</span>x<span class="hljs-number">80484</span>e<span class="hljs-number">5</span>,%eax<br><span class="hljs-attribute">134</span>- <span class="hljs-number">80483</span>fa:    c<span class="hljs-number">7</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>     movl   $<span class="hljs-number">0</span>x<span class="hljs-number">5</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%esp)<br><span class="hljs-attribute">135</span>- <span class="hljs-number">8048401</span>:    <span class="hljs-number">00</span> <br><span class="hljs-attribute">136</span>- <span class="hljs-number">8048402</span>:    <span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">04</span>              mov    %eax,<span class="hljs-number">0</span>x<span class="hljs-number">4</span>(%esp)<br><span class="hljs-attribute">137</span>- <span class="hljs-number">8048406</span>:    <span class="hljs-number">8</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">1</span>c              mov    <span class="hljs-number">0</span>x<span class="hljs-number">1</span>c(%esp),%eax<br><span class="hljs-attribute">138</span>- <span class="hljs-number">804840</span>a:    <span class="hljs-number">89</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span>                 mov    %eax,(%esp)<br><span class="hljs-attribute">139</span>- <span class="hljs-number">804840</span>d:    e<span class="hljs-number">8</span> <span class="hljs-number">0</span>a ff ff ff           call   <span class="hljs-number">804831</span>c &lt;memcpy@plt&gt;<br><span class="hljs-attribute">140</span>- <span class="hljs-number">8048412</span>:    c<span class="hljs-number">9</span>                       leave  <br><span class="hljs-attribute">141</span>- <span class="hljs-number">8048413</span>:    c<span class="hljs-number">3</span>                       ret    <br></code></pre></td></tr></table></figure><p>通过对以上汇编代码分析，得知段错误发生<code>main</code>函数，对应的汇编指令是<code>movl $0x80484e0,0x1c(%esp)</code>，接下来打开程序的源码，找到汇编指令对应的源码，也就定位到段错误了。</p><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ol><li>不需要<code>-g</code>参数编译，不需要借助于<code>core</code>文件，但需要有一定的汇编语言基础。</li></ol><p>2、如果使用了gcc编译优化参数（-O1，-O2，-O3）的话，生成的汇编指令将会被优化，使得调试过程有些难度。</p><h3 id="使用catchsegv"><a href="#使用catchsegv" class="headerlink" title="使用catchsegv"></a>使用catchsegv</h3><p><code>catchsegv</code>命令专门用来扑获段错误，它通过动态加载器（ld-linux.so）的预加载机制（PRELOAD）把一个事先写好的库（/lib/libSegFault.so）加载上，用于捕捉断错误的出错信息。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$:~/segfault$ catchsegv ./segfault3<br>Segmentation fault (core dumped)<br>*** Segmentation fault<br>Register dump:<br><br> EAX: <span class="hljs-number">00000000</span>   EBX: <span class="hljs-number">00fb3ff4</span>   ECX: <span class="hljs-number">00000002</span>   EDX: <span class="hljs-number">00000000</span><br> ESI: <span class="hljs-number">080484e5</span>   EDI: <span class="hljs-number">080484e0</span>   EBP: bfb7ad38   ESP: bfb7ad0c<br><br> EIP: <span class="hljs-number">00ee806a</span>   EFLAGS: <span class="hljs-number">00010203</span><br><br> CS: <span class="hljs-number">0073</span>   DS: <span class="hljs-number">007b</span>   ES: <span class="hljs-number">007b</span>   FS: <span class="hljs-number">0000</span>   GS: <span class="hljs-number">0033</span>   SS: <span class="hljs-number">007b</span><br><br> Trap: <span class="hljs-number">0000000e</span>   Error: <span class="hljs-number">00000007</span>   OldMask: <span class="hljs-number">00000000</span><br> ESP/signal: bfb7ad0c   CR2: <span class="hljs-number">080484e0</span><br><br>Backtrace:<br>/lib/libSegFault.so[<span class="hljs-number">0x3b606f</span>]<br>??:<span class="hljs-number">0</span>(??)[<span class="hljs-number">0xc76400</span>]<br>/lib/tls/i686/cmov/libc.so<span class="hljs-number">.6</span>(__libc_start_main+<span class="hljs-number">0xe6</span>)[<span class="hljs-number">0xe89b56</span>]<br>/build/buildd/eglibc-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>/csu/../sysdeps/i386/elf/start.S:<span class="hljs-number">122</span>(_start)[<span class="hljs-number">0x8048351</span>]<br><br>Memory <span class="hljs-built_in">map</span>:<br><br><span class="hljs-number">00258000</span>-<span class="hljs-number">00273000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">157</span> /lib/ld-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00273000</span>-<span class="hljs-number">00274000</span> r--p <span class="hljs-number">0001a000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">157</span> /lib/ld-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00274000</span>-<span class="hljs-number">00275000</span> rw-p <span class="hljs-number">0001b000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">157</span> /lib/ld-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">003b4000</span>-<span class="hljs-number">003b7000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">13105</span> /lib/libSegFault.so<br><span class="hljs-number">003b7000</span>-<span class="hljs-number">003b8000</span> r--p <span class="hljs-number">00002000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">13105</span> /lib/libSegFault.so<br><span class="hljs-number">003b8000</span>-<span class="hljs-number">003b9000</span> rw-p <span class="hljs-number">00003000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">13105</span> /lib/libSegFault.so<br><span class="hljs-number">00c76000</span>-<span class="hljs-number">00c77000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> [vdso]<br><span class="hljs-number">00e0d000</span>-<span class="hljs-number">00e29000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">4817</span> /lib/libgcc_s.so<span class="hljs-number">.1</span><br><span class="hljs-number">00e29000</span>-<span class="hljs-number">00e2a000</span> r--p <span class="hljs-number">0001b000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">4817</span> /lib/libgcc_s.so<span class="hljs-number">.1</span><br><span class="hljs-number">00e2a000</span>-<span class="hljs-number">00e2b000</span> rw-p <span class="hljs-number">0001c000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">4817</span> /lib/libgcc_s.so<span class="hljs-number">.1</span><br><span class="hljs-number">00e73000</span>-<span class="hljs-number">00fb1000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">1800</span> /lib/tls/i686/cmov/libc-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00fb1000</span>-<span class="hljs-number">00fb2000</span> ---p <span class="hljs-number">0013e000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">1800</span> /lib/tls/i686/cmov/libc-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00fb2000</span>-<span class="hljs-number">00fb4000</span> r--p <span class="hljs-number">0013e000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">1800</span> /lib/tls/i686/cmov/libc-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00fb4000</span>-<span class="hljs-number">00fb5000</span> rw-p <span class="hljs-number">00140000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">1800</span> /lib/tls/i686/cmov/libc-<span class="hljs-number">2.10</span><span class="hljs-number">.1</span>.so<br><span class="hljs-number">00fb5000</span>-<span class="hljs-number">00fb8000</span> rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">303895</span> /home/segfault/segfault3<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">303895</span> /home/segfault/segfault3<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000</span> <span class="hljs-number">08</span>:<span class="hljs-number">01</span> <span class="hljs-number">303895</span> /home/segfault/segfault3<br><span class="hljs-number">09432000</span>-<span class="hljs-number">09457000</span> rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> [heap]<br>b78cf000-b78d1000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b78df000-b78e1000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>bfb67000-bfb7c000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> [stack]<br></code></pre></td></tr></table></figure><h2 id="如何避免段错误"><a href="#如何避免段错误" class="headerlink" title="如何避免段错误"></a>如何避免段错误</h2><ol><li><p>出现段错误时，首先应该想到段错误的定义，从它出发考虑引发错误的原因。</p></li><li><p>在使用指针时，定义了指针后记得初始化指针，在使用的时候记得判断是否为NULL。</p></li><li><p>在使用数组时，注意数组是否被初始化，数组下标是否越界，数组元素是否存在等。</p></li><li><p>在访问变量时，注意变量所占地址空间是否已经被程序释放掉。</p></li><li><p>在处理变量时，注意变量的格式控制是否合理等。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V入门（2）-RISC-V汇编语言编程</title>
    <link href="/2021/10/16/RISC-V%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89-%20RISC-V%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/10/16/RISC-V%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89-%20RISC-V%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="汇编语法介绍"><a href="#汇编语法介绍" class="headerlink" title="汇编语法介绍"></a>汇编语法介绍</h2><p>一条典型的RISCV汇编语句由三个部分组成<code>[label:][operation][comment]</code>。<br>后缀<code>.s</code>和<code>.S</code>区别：后者纯汇编。</p><ul><li><p>label(标号)</p></li><li><p>operation可以有以下多种类型:</p><ul><li><p>instruction (指令) ：直接对应二进制机器指令的宇符串</p></li><li><p>pseudo-instruction (伪指令) ：为了提高编写代码的效率,可以用一条伪指令指示汇编器产生多条实际的指令(instructions)。</p></li><li><p>directive (指示/伪操作) ：通过类似指令的形式(以”.”开头),通知汇编器如何控制代码的产生等，不对应具体的指令。</p></li><li><p>macro：采用.macro/.endm自定义的宏</p><p>例子</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.macro</span> do_nothing<span class="hljs-comment"># directive</span><br><span class="hljs-keyword">nop</span><span class="hljs-comment"># pseudo-instruction</span><br><span class="hljs-keyword">nop</span><span class="hljs-comment"># pseudo-instruction</span><br><span class="hljs-meta">.endm</span><span class="hljs-comment"># directive</span><br><br><span class="hljs-meta">.text</span><span class="hljs-comment"># directive</span><br><span class="hljs-meta">.global</span> _start<span class="hljs-comment"># directive</span><br><span class="hljs-symbol">_start:</span> <span class="hljs-comment"># Label</span><br>li x6, <span class="hljs-number">5</span><span class="hljs-comment"># pseudo-instruction</span><br>li x7, <span class="hljs-number">4</span><span class="hljs-comment"># pseudo-instruction</span><br><span class="hljs-keyword">add </span>x5, x6, x7<span class="hljs-comment"># instruction</span><br>do_nothing<span class="hljs-comment"># Calling macro</span><br><span class="hljs-symbol">stop:</span><span class="hljs-keyword">j </span>stop<span class="hljs-comment"># statement in one line</span><br><br><span class="hljs-meta">.end</span><span class="hljs-comment"># End of file</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>comment（注释）以<code>#</code>开头到行尾</p></li></ul><h2 id="RISCV介绍"><a href="#RISCV介绍" class="headerlink" title="RISCV介绍"></a>RISCV介绍</h2><h3 id="什么是ISA"><a href="#什么是ISA" class="headerlink" title="什么是ISA"></a>什么是ISA</h3><p>底层硬件电路面向上层软件程序提供的一种接口规范。<br>ISA定义了：</p><ul><li>基本数据类型</li><li>寄存器</li><li>指令</li><li>寻址模式</li><li>异常或者中断等</li></ul><h3 id="为什么要ISA"><a href="#为什么要ISA" class="headerlink" title="为什么要ISA"></a>为什么要ISA</h3><p>为上层软件提供一层抽象，制定规则和约束，让编程者不用操心具体的电路结构。（微架构考虑的事）</p><p>IBM360是第一个将ISA与其实现分离的计算机。</p><h3 id="复杂指令集（CISC）与简单指令集（RISC）"><a href="#复杂指令集（CISC）与简单指令集（RISC）" class="headerlink" title="复杂指令集（CISC）与简单指令集（RISC）"></a>复杂指令集（CISC）与简单指令集（RISC）</h3><p>CISC(Complex Instruction Set Computing)：针对特定的功能实现特定的指令，导致指令数目比较多，但生成的程序长度相对较短。<br>RISC(Reduced Instruction Set Computing)：只定义常用指令,对复杂的功能采用常用指令组合实现，这导致指令数目比较精简，但生成的程序长度相对较长。</p><h3 id="ISA宽度"><a href="#ISA宽度" class="headerlink" title="ISA宽度"></a>ISA宽度</h3><p>宽度指的是CPU通用寄存器的宽度（二进制位数），这决定了寻址大小，数据运算能力</p><h3 id="开源与闭源"><a href="#开源与闭源" class="headerlink" title="开源与闭源"></a>开源与闭源</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108232257173.png"></p><h3 id="RISCV是什么"><a href="#RISCV是什么" class="headerlink" title="RISCV是什么"></a>RISCV是什么</h3><ul><li>一款高质量,免许可证，开放的RISC ISA</li><li>一套由非营利的RISC-V基金会维护的标准: <a href="https://riscv.org/">https://riscv.org/</a></li><li>适用于所有类型的计算系统：从微控制器到超级计算机</li><li>RISC-V不是一家公司，也不是一款CPU实现。</li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>ISA命名格式: <code>RV[###][abc...xyz]</code></p><ul><li><code>RV</code>:用于标识RISC-V体系架构的前缀，即<code>RISC-V</code>的缩写。</li><li><code>[##]</code>: <code>&#123;32, 64, 128&#125;</code>用于标识处理器的字宽,也就是处理器的寄存器的宽度单位为bit</li><li><code>[abc xyz]</code>:标识该处理器支持的指令集模块集合。例子: <code>RV32IMA</code>, <code>RV64GC</code><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108232325834.png"></li></ul><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p><code>PC</code>寄存器没有暴露出来，无法直接获取，改动。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108232328265.png"></p><h3 id="HART"><a href="#HART" class="headerlink" title="HART"></a>HART</h3><p>HART = HARdware+Thread=硬件线程<br>以往一个Core里可能有两个执行流，</p><h3 id="特权级别"><a href="#特权级别" class="headerlink" title="特权级别"></a>特权级别</h3><p>不同特权级别下分别对应一套寄存器，比如用户态不能访问内核态的寄存器，这就起到了保护的作用。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108232356276.png"></p><p>高级别可以访问低级别的寄存器。</p><h2 id="RISCV汇编指令总览"><a href="#RISCV汇编指令总览" class="headerlink" title="RISCV汇编指令总览"></a>RISCV汇编指令总览</h2><h3 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h3><ul><li>寄存器<ul><li>32个通用寄存器,<code>x0 ~ x31</code>（注意：本章节课程仅涉及RV32I的通用寄存器组）；</li><li>在RISC-V中，Hart在执行算术逻辑运算时所操作的数据必须直接来自寄存器。</li></ul></li><li>内存<ul><li>Hart可以执行在寄存器和内存之间的数据读写操作;</li><li>读写操作使用字节(Byte)为基本单位进行寻址;</li><li>RV32可以访问最多<code>2^32</code>个字节的内存空间。</li></ul></li></ul><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826142737.png"></p><h4 id="小端序"><a href="#小端序" class="headerlink" title="小端序"></a>小端序</h4><ul><li>主机字节序(HBO-Host Byte Order)</li><li>一个多字节整数在计算机内存中存储的字节顺序称主机字节序(HBO- Host Byte Order，或者叫本地字节序)</li><li>不同类型CPU的HBO不同,这与CPU的设计有关。分为大端序(Big-Endian)和小端序(Little-Endian)</li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826144713.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826145319.png"></p><h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826145633.png"></p><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>算数指令只包含加减，不包含乘除，乘除运算有专门的扩展。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108262335167.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108262343942.png"></p><p>数据传送顺序是由后向前，和正常的编码习惯类似。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202109172320337.png"><br><code>.text</code>告诉编译器下面内容放到<code>elf</code>的<code>text section</code>中。<br><code>.global</code>声明一个全局函数</p><p>elf文件包含了调试信息<br>使用objcopy命令生成的bin文件，剔除了调试信息</p><h4 id="SUB-Substract"><a href="#SUB-Substract" class="headerlink" title="SUB Substract"></a>SUB Substract</h4><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>现知道某条RISC-V的机器指令在内存中的值为<code>b3 05 95 00</code>,从左往右为从低地址到高地址，单位为字节，请将其翻译为对应的汇编指令。</p><ul><li>确定字节序<br>在RISCV中存放是小端序，根据题意真正指令应该是<code>00 95 05 b3</code></li><li>转换二进制<br>机器码是二进制，所以需要将上述指令值转换为二进制，可得<code>0000000 01001 01010 000 01011 0110011</code></li><li>查阅手册<br>查阅<code>The RISC-V Instruction Set Manual Volume I: Unprivileged ISA</code>找到<code>RV32/64G Instruction Set Listings</code>指令表格，低7位是<code>opcode</code>，查表可得<code>0110011</code>对应操作码有多个<code>SLLI SRAI SUB </code>等等，此时再看最高位<code>00000000</code>,可以确定是<code>ADD</code>指令</li><li>将分割的二进制转成十进制<br><code>0000000 9 10 000 11 010011</code>-&gt;<code>ADD x11 x10 x9</code><h4 id="ADDI-ADD-Immediate"><a href="#ADDI-ADD-Immediate" class="headerlink" title="ADDI ADD Immediate"></a>ADDI ADD Immediate</h4></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918102935.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104115.png"></p><h4 id="LUI-Load-Upper-Immediate"><a href="#LUI-Load-Upper-Immediate" class="headerlink" title="LUI Load Upper Immediate"></a>LUI Load Upper Immediate</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104625.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104556.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104911.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918104929.png"></p><h4 id="基于算术运算指令实现的其他伪指令"><a href="#基于算术运算指令实现的其他伪指令" class="headerlink" title="基于算术运算指令实现的其他伪指令"></a>基于算术运算指令实现的其他伪指令</h4><p><code>x0</code>寄存器具有特殊含义，往里写数据没有意义。<br><code>NOP</code>指令主要为了占位，空转。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210918103237.png"></p><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><h3 id="移位运算指令"><a href="#移位运算指令" class="headerlink" title="移位运算指令"></a>移位运算指令</h3><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><p>只有右移，没有左移。左移会把最高位覆盖。</p><h3 id="内存读写指令"><a href="#内存读写指令" class="headerlink" title="内存读写指令"></a>内存读写指令</h3><h3 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211008115038.png"></p><p>指令格式中的立即数(imm)存放有些奇怪，第[1-4]位和第[11]位放在一起，第[5-10]位和第[12]位放在一起。这是为了迎合硬件处理效率，编程时不需要考虑立即数存储方式。</p><h3 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h3><h3 id="RISC-V指令寻址模式总结"><a href="#RISC-V指令寻址模式总结" class="headerlink" title="RISC-V指令寻址模式总结"></a>RISC-V指令寻址模式总结</h3><h2 id="汇编函数调用约定"><a href="#汇编函数调用约定" class="headerlink" title="汇编函数调用约定"></a>汇编函数调用约定</h2><h3 id="函数调用过程概述"><a href="#函数调用过程概述" class="headerlink" title="函数调用过程概述"></a>函数调用过程概述</h3><p>栈（stack）数据结构，在函数调用过程中会用来保存变量，函数地址等等。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162130267.png"></p><p>栈帧里保存的变量是自动变量，会被内存自动释放。</p><p>为何要有调用者与被调用者保存的概念<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162137133.png"></p><p>函数调用过程中就会有参数和返回值的传递，自己写的函数可能由别人来调用，如果没有约定好某个参数存放位置，就不能够顺利执行函数。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162144447.png"></p><p>因为寄存器需要经常在编程中使用，所以ABI名就是寄存器的别名。</p><blockquote><p>这些寄存器其实都可以设置成被调用者保存，也就是在被调用函数中保存一遍为啥还要分这么多<br>答：因为保存一遍效率低</p></blockquote><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162209273.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162217164.gif"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162234551.png"></p><h2 id="汇编与C混合编程"><a href="#汇编与C混合编程" class="headerlink" title="汇编与C混合编程"></a>汇编与C混合编程</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>遵守ABI（Abstract Binary Interface）的规定</p><ul><li>数据类型大小，布局，对齐</li><li>函数调用约定</li><li>系统调用约定<br>等等</li></ul><p>RISC-V函数调用约定规定</p><ul><li>函数参数采用寄存器<code>a0-a7</code></li><li>函数返回值采用寄存器<code>a0,a1</code></li></ul><h3 id="汇编嵌入C语言"><a href="#汇编嵌入C语言" class="headerlink" title="汇编嵌入C语言"></a>汇编嵌入C语言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ASM"># ASM call C<br><br>.text# Define beginning of text section<br>.global_start# Define entry _start<br>.globalfoo# foo is a C function defined in test.c<br><br>_start:<br>la sp, stack_end# prepare stack for calling functions<br><br># RISC-V uses a0 ~ a7 to transfer parameters<br>li a0, 1<br>li a1, 2<br>call foo    #调用了C语言函数<br># RISC-V uses a0 &amp; a1 to transfer return value<br># check value of a0<br><br>stop:<br>j stop# Infinite loop to stop execution<br><br>nop# just for demo effect<br><br>stack_start:<br>.rept 10<br>.word 0<br>.endr<br>stack_end:<br><br>.end# End of file<br><br></code></pre></td></tr></table></figure><p><code>call foo</code>就是在调用C语言函数，<code>foo</code>。<br><code>.global foo</code>告诉编译器<code>foo</code>函数定义在外面。</p><h3 id="C语言嵌入汇编"><a href="#C语言嵌入汇编" class="headerlink" title="C语言嵌入汇编"></a>C语言嵌入汇编</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162347033.png"><br>下图中为简化写法<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202110162342119.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言可变参数</title>
    <link href="/2021/10/12/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <url>/2021/10/12/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>学习过程中查看了<code>printf()</code>源码，遇到了这样的函数定义，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fmt, ...)</span></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br>    va_list args;<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>    va_start(args, fmt);<br>    vsprint(buf, fmt, args);<br>    va_end(args);<br>    <br>    <span class="hljs-built_in">puts</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>参数中的三个点号，就是C语言中可变参数的标识。这样的函数称为可变参数函数。这种函数需要固定数量的<strong>强制参数</strong>（mandatory argument），后面是<strong>数量可变的可选参数</strong>（optional argument）。</p><p>这种函数<strong>必须至少有一个</strong>强制参数。可选参数的类型可以变化。可选参数的数量由强制参数的值决定，或由用来定义可选参数列表的特殊值决定。</p><p>C 语言中最常用的可变参数函数例子是<code> printf（）</code>和 <code>scanf（）</code>。这两个函数都有一个强制参数，即格式化字符串。格式化字符串中的转换修饰符决定了可选参数的数量和类型。</p><p>可变参数函数要获取可选参数时，必须通过一个类型为 <code>va_list</code> 的对象，它包含了参数信息。这种类型的对象也称为参数指针（argument pointer），它包含了栈中至少一个参数的位置。可以使用这个参数指针从一个可选参数移动到下一个可选参数，由此，函数就可以获取所有的可选参数。<code>va_list</code> 类型被定义在头文件 <code>stdarg.h</code> 中。</p><p>当编写支持参数数量可变的函数时，必须用 <code>va_list</code> 类型定义参数指针，以获取可选参数。在下面的讨论中，<code>va_list</code> 对象被命名为 <code>argptr</code>。可以用 <code>4 </code>个宏来处理该参数指针，这些宏都定义在头文件 <code>stdarg.h</code> 中：</p><ul><li><p>宏 <code>va_start</code> 使用第一个可选参数的位置来初始化 <code>argptr</code> 参数指针。该宏的第二个参数必须是该函数最后一个有名称参数的名称。必须先调用该宏，才可以开始使用可选参数。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">va_start</span><span class="hljs-params">(va_list argptr, lastparam)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>展开宏 <code>va_arg</code> 会得到当前 <code>argptr</code> 所引用的可选参数，也会将 <code>argptr</code> 移动到列表中的下一个参数。宏 <code>va_arg</code> 的第二个参数是刚刚被读入的参数的类型。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">type <span class="hljs-title">va_arg</span><span class="hljs-params">(va_list argptr, type)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>当不再需要使用参数指针时，必须调用宏 <code>va_end</code>。如果想使用宏 <code>va_start</code> 或者宏 <code>va_copy</code> 来重新初始化一个之前用过的参数指针，也必须先调用宏 <code>va_end</code>。<code>va_end</code>被定义为空.它只是为实现与va_start配对(实现代码对称和”代码自注释”(根据代码就能知道功能，不需要额外注释)功能)</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">va_end</span><span class="hljs-params">(va_list argptr)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>宏 <code>va_copy</code> 使用当前的<code>src</code>值来初始化参数指针 <code>dest</code>。然后就可以使用 <code>dest </code>中的备份获取可选参数列表，从<code> src</code> 所引用的位置开始。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">va_copy</span><span class="hljs-params">(va_list dest, va_list src)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数add() 计算可选参数之和</span><br><span class="hljs-comment">// 参数：第一个强制参数指定了可选参数的数量，可选参数为double类型</span><br><span class="hljs-comment">// 返回值：和值，double类型</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">( <span class="hljs-keyword">int</span> n, ... )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br>  va_list argptr;<br>  va_start( argptr, n );             <span class="hljs-comment">// 初始化argptr</span><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; n; ++i )          <span class="hljs-comment">// 对每个可选参数，读取类型为double的参数，</span><br>    sum += va_arg( argptr, <span class="hljs-keyword">double</span> ); <span class="hljs-comment">// 然后累加到sum中</span><br>  va_end( argptr );<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>简易<code>printf</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-comment">/* minprintf: minimal printf with variable arqument list */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">minprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fmt, ...)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br>    GPIO<br>    va_list ap; <span class="hljs-comment">/* points to each unnamed arq in turn */</span><br>    <span class="hljs-keyword">char</span> *p, *sval;<br>    <span class="hljs-keyword">int</span> ival;<br>    <span class="hljs-keyword">double</span> dval;<br>    va_start(ap, fmt); <span class="hljs-comment">/* make ap point to 1st unnamed arg */</span><br>    <span class="hljs-keyword">for</span> (p = fmt; *p; p++) &#123;<br>        <span class="hljs-keyword">if</span> (*p != <span class="hljs-string">&#x27;%&#x27;</span>) &#123;<br>            <span class="hljs-built_in">putchar</span>(*p);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">switch</span> (*++p) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>         ival = va_arg(ap, <span class="hljs-keyword">int</span>);<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ival);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br>            dval = va_arg(ap, <span class="hljs-keyword">double</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f&quot;</span>, dval);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>            <span class="hljs-keyword">for</span> (sval = va_arq(ap, <span class="hljs-keyword">char</span> *); *sval; sval++)<br>                <span class="hljs-built_in">putchar</span>(*sval);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">putchar</span>(*p);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    va_end(ap); <span class="hljs-comment">/* clean up when done */</span><br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下将编译结果输出到文件</title>
    <link href="/2021/09/30/Linux%E4%B8%8B%E5%B0%86%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6/"/>
    <url>/2021/09/30/Linux%E4%B8%8B%E5%B0%86%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>在命令行编译项目时，经常遇到编译结果太长，覆盖了最先输出的结果，此时就需要将结果输出到文件再查看。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">make &gt; make.log 2&gt;&amp;1<br><span class="hljs-comment"># make 编译命令</span><br><span class="hljs-comment"># make.log 输出文件名</span><br><span class="hljs-comment"># 2 文件描述符，标准错误</span><br><span class="hljs-comment"># &gt; 重定向符，输出</span><br><span class="hljs-comment"># &amp;1 文件描述符&amp;，文件描述符1 标准输入</span><br></code></pre></td></tr></table></figure><p>该命令功能即将<code>make</code>编译时输出，标准错误重定向为标准输入，写入到<code>make.log</code>文件中。符号的含义可以参考<a href="">Linux文件描述符</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件描述符</title>
    <link href="/2021/09/30/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <url>/2021/09/30/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux 中一切皆文件，比如 C++ 源文件、视频文件、Shell脚本、可执行文件等，就连键盘、显示器、鼠标等硬件设备也都是文件。</p><p>一个 Linux 进程可以打开成百上千个文件，为了表示和区分已经打开的文件，Linux 会给每个文件分配一个编号（一个 ID），这个编号就是一个整数，被称为<strong>文件描述符</strong>（File Descriptor）。</p><h2 id="文件描述符是什么？"><a href="#文件描述符是什么？" class="headerlink" title="文件描述符是什么？"></a>文件描述符是什么？</h2><p>一个 Linux 进程启动后，会在内核空间中创建一个 <code>PCB</code> 控制块，<code>PCB</code> 内部有一个<strong>文件描述符表</strong>（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。</p><p>除了文件描述符表，系统还需要维护另外两张表：</p><ul><li>打开文件表（Open file table）</li><li><code>i-node</code> 表（i-node table）</li></ul><p>文件描述符表每个进程都有一个，打开文件表和 <code>i-node</code> 表整个系统只有一个，它们三者之间的关系如下图所示。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210930132546.png"></p><p>对上图的说明：</p><ul><li>在进程<code> A</code> 中，文件描述符 <code>1</code> 和<code> 20</code> 都指向了同一个打开文件表项，标号为 <code>23</code>（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 <code>dup()</code>、<code>dup2()</code>、<code>fcntl()</code> 或者对同一个文件多次调用了 <code>open()</code> 函数形成的。</li><li>进程 <code>A</code> 的文件描述符 <code>2 </code>和进程<code> B</code> 的文件描述符<code> 2</code> 都指向了同一个文件，这可能是在调用 <code>fork()</code> 后出现的（即进程 <code>A</code>、<code>B </code>是父子进程关系），或者是不同的进程独自去调用<code> open()</code> 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</li><li>进程 <code>A</code> 的描述符<code>0</code>和进程<code>B</code>的描述符<code>3</code>分别指向不同的打开文件表项，但这些表项均指向 <code>i-node</code> 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 <code>open()</code> 调用。同一个进程两次打开同一个文件，也会发生类似情况。 </li></ul><p>通过文件描述符，可以找到文件指针，从而进入打开文件表。该表存储了以下信息：</p><ul><li>文件偏移量，也就是文件内部指针偏移量。调用<code>read()</code>或者<code> write()</code> 函数时，文件偏移量会自动更新，当然也可以使用 <code>lseek()</code> 直接修改。</li><li>状态标志，比如只读模式、读写模式、追加模式、覆盖模式等。</li><li><code>i-node</code> 表指针。</li></ul><p>然而，要想真正读写文件，还得通过打开文件表的 i-node 指针进入</p><ul><li><code>i-node</code> 表，该表包含了诸如以下的信息：</li><li>文件类型，例如常规文件、套接字或 <code>FIFO</code>。</li><li>文件大小。</li><li>时间戳，比如创建时间、更新时间。</li><li>文件锁。</li></ul><h2 id="标准文件描述符"><a href="#标准文件描述符" class="headerlink" title="标准文件描述符"></a>标准文件描述符</h2><table><thead><tr><th align="center">文件描述符</th><th align="center">用途</th><th align="center">POSIX名称</th><th align="center">stdio流</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">标准输入</td><td align="center">STDIN FILENO</td><td align="center">stdin</td></tr><tr><td align="center">1</td><td align="center">标准输出</td><td align="center">STDOUT FILENO</td><td align="center">stdout</td></tr><tr><td align="center">2</td><td align="center">标准错误</td><td align="center">STDERR FILENO</td><td align="center">stderr</td></tr></tbody></table><p>标准文件描述符通常会和重定向符<code>&lt;,&gt;,&lt;&lt;,&gt;&gt;</code>结合使用。箭头向左表示输入重定向，向右表示输出重定向。文件描述符中的<code>0</code>通常省略。如<code>0&lt; ~ &lt;</code>，<code>0&lt;&lt; ~ &lt;&lt;</code>。</p><h3 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h3><p>使用<code>wc</code>命令统计文档中有多少行字，命令格式如下，详细介绍参考<a href="https://dunky-z.github.io/2021/07/30/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-wc%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AD%97%E5%A4%9A%E5%B0%91%E8%A1%8C/">这篇文章</a>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">wc  <span class="hljs-selector-attr">[选项]</span>  <span class="hljs-selector-attr">[文件名]</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat test.txt<br>This is a <span class="hljs-built_in">test</span> file.<br>Hello world!<br><br>$ wc -l &lt;test.txt<br>2<br></code></pre></td></tr></table></figure><p>这里的重定向符号<code>&lt;</code>作用就是将<code>test.txt</code>的内容作为标准输入，传递给<code>wc</code>命令。</p><h2 id="标准输出与标准错误"><a href="#标准输出与标准错误" class="headerlink" title="标准输出与标准错误"></a>标准输出与标准错误</h2><p>这个我们每天都在接触，但是可能没有留意。假设我当前目录下只有一个<code>test.txt</code>文件，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat text.txt<br>This is a <span class="hljs-built_in">test</span> file.<br>Hello world!            <span class="hljs-comment">#标准输出1</span><br><br>$ cat text.md<br>cat: test.md: No such file or directory <span class="hljs-comment">#标准错误2</span><br><br>$ ls text.txt text.md 1&gt;file.out 2&gt;file.err <br><span class="hljs-comment"># 执行后,没有任何返回值. 原因是, 返回值都重定向到相应的文件中了,而不再前端显示 </span><br>$ cat file.out <br>text.txt <br><br>$ cat file.err <br>cat: test.md: No such file or directory<br></code></pre></td></tr></table></figure><h2 id="amp-描述符"><a href="#amp-描述符" class="headerlink" title="&amp;描述符"></a><code>&amp;</code>描述符</h2><p><code>&amp;</code> 是一个描述符，如果<code>1</code>或<code>2</code>前不加<code>&amp;</code>，会被当成一个普通文件。</p><p><code>1&gt;&amp;2</code> 意思是把标准输出重定向到标准错误.<br><code>2&gt;&amp;1</code> 意思是把标准错误输出重定向到标准输出。<br><code>&amp;&gt;filename</code> 意思是把标准输出和标准错误输出都重定向到文件filename中</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://c.biancheng.net/view/942.html">Linux Shell重定向（输入输出重定向）精讲</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode快速添加注释模板</title>
    <link href="/2021/09/29/VScode%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/09/29/VScode%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>通常函数的注释一般都比较长，而且每个函数注释都格式一致，例如下面的函数注释模板。如果每次写注释都要复制一遍比较麻烦，复制完还要删除多余的字符。但是现有的编辑器一般都支持快捷输入。下面介绍在VSCode中如何快捷输入注释模板。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><code>Ctrl+Shift+P</code>打开编辑器命令窗口-输入<code>snippets</code>-选择<code>Preferences:Configure User Snippets</code>-选择·c.json·<br>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210929170226.png"><br>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210929170717.png"></li><li>更改如下：  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">   &#123;<br><span class="hljs-comment">// Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and </span><br><span class="hljs-comment">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span><br><span class="hljs-comment">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the </span><br><span class="hljs-comment">// same ids are connected.</span><br><span class="hljs-comment">// Example:</span><br><span class="hljs-comment">// &quot;Print to console&quot;: &#123;</span><br><span class="hljs-comment">// &quot;prefix&quot;: &quot;log&quot;,</span><br><span class="hljs-comment">// &quot;body&quot;: [</span><br><span class="hljs-comment">// &quot;console.log(&#x27;$1&#x27;);&quot;,</span><br><span class="hljs-comment">// &quot;$2&quot;</span><br><span class="hljs-comment">// ],</span><br><span class="hljs-comment">// &quot;description&quot;: &quot;Log output to console&quot;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-attr">&quot;Function comment&quot;</span>: &#123;<br><span class="hljs-attr">&quot;prefix&quot;</span>: <span class="hljs-string">&quot;funcom&quot;</span>,<br><span class="hljs-attr">&quot;body&quot;</span>: [<br><span class="hljs-string">&quot;/* &quot;</span><br> <span class="hljs-string">&quot;* Description:      &quot;</span><br> <span class="hljs-string">&quot;* Input Parameter:  &quot;</span><br> <span class="hljs-string">&quot;* Output Parameter: &quot;</span><br> <span class="hljs-string">&quot;* Return:           &quot;</span><br> <span class="hljs-string">&quot;*/ &quot;</span><br>],<br><span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;function comment&quot;</span><br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><code>prefix</code>:输入时的缩写，触发器</li><li><code>body</code>:内容</li><li><code>description</code>:描述</li></ul></li></ul><p><a href="https://juejin.cn/post/6844903869424599053">VSCode 利用 Snippets 设置超实用的代码块 - 掘金</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QtCreator快速添加注释模板</title>
    <link href="/2021/09/28/QtCreator%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/09/28/QtCreator%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>通常函数的注释一般都比较长，而且每个函数注释都格式一致，例如下面的函数注释模板。如果每次写注释都要复制一遍比较麻烦，复制完还要删除多余的字符。但是现有的编辑器一般都支持快捷输入。下面介绍在QtCreator中如何快捷输入注释模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Description:      // 函数功能、性能等的描述  </span><br><span class="hljs-comment"> * Input Parameter:  // 输入参数说明，包括每个参数的作 </span><br><span class="hljs-comment"> * Output Parameter: // 对输出参数的说明。 </span><br><span class="hljs-comment"> * Return:           // 函数返回值的说明 </span><br><span class="hljs-comment"> */</span> <br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>QtCreator-菜单栏工具（Tool）-选项（Options）-文本编辑器（Text Editor）-片段（Snippets）</li><li>组（Group）选择<code>C++</code>-添加（Add）<br>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210928193309.png"></li><li>现在要为我们的触发（Trigger）起个名字，因为是函数注释，我起了个<code>funcom</code>，然后在下方空白框里填入注释模板。Apply保存。如图<br>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210928193538.png"></li><li>在需要添加注释模板的地方输入<code>funcom</code>即可提示快捷输入，回车即可添加注释模板。<br>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210928194108.gif"></li></ul><p>我们可以看到片段里有很多熟悉的内容，比如<code>if else</code>，我们在写代码时输入<code>if else</code>自动补全花括号其实就是在这里设置的。同理，我们还可以设置一些其他需要的快捷输入内容。比如行注释，文件注释，经常使用的代码框架等等。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>QtCreator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt修改UI文件不生效</title>
    <link href="/2021/09/26/Qt%E4%BF%AE%E6%94%B9UI%E6%96%87%E4%BB%B6%E4%B8%8D%E7%94%9F%E6%95%88/"/>
    <url>/2021/09/26/Qt%E4%BF%AE%E6%94%B9UI%E6%96%87%E4%BB%B6%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>修改了UI文件后，在代码中无法调用新增的内容。</p><h2 id="探究原因"><a href="#探究原因" class="headerlink" title="探究原因"></a>探究原因</h2><p>导致<code>ui_*.h</code>文件没有更新的原因是源代码中<code>#include ui_*.h</code>的位置和实际生成的位置不同，引用的是老的<code>ui_*.h</code></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法一：</p><p>项目设置文件<code>.pro</code>内增加 <code>UI_DIR=./UI</code>，同时删除掉源代码目录中<code>ui_*.h</code>，<code>clear all</code>,<code>-&gt;qmake-&gt;rebuilt all</code><br>方法二：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210926105252.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QtCreator修改项目构建目录</title>
    <link href="/2021/09/25/QtCreator%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%9B%AE%E5%BD%95/"/>
    <url>/2021/09/25/QtCreator%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>QtCreator构建项目时，会在统计目录新建一个<code>build-xxx-debug</code>的目录，如果想要自己修改这个目录的位置，名称，该怎么办。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>仅修改工具（Tool）–&gt;选项(Options)–&gt;构建和运行(Build&amp;Run)中<code>Default build directory：./%&#123;CurrentBuild:Name&#125;</code>是不会生效的。</p><ul><li><p>将工具–&gt;选项–&gt;构建和运行中<code>Default build directory</code>修改为<code>./%&#123;CurrentBuild:Name&#125;</code>（改为你想要的目标目录都行）；</p></li><li><p>把QtCreator关闭，把工程目录下后缀名为<code>.pro.user</code>的文件删掉；</p></li><li><p>用QtCreator打开工程，会提示你创建构建目录，此时提示的就是你修改后的<code>Default build directory</code>中填写的目录；</p></li></ul><p>其中<code>.pro.user</code>文件记录了编译器、构建工具链、构建目录、版本…..等工程编译相关信息，想要更换项目的编译环境，得删除这个文件，由QtCreator自动重新创建。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-把本地仓库同步到GitHub</title>
    <link href="/2021/09/23/Git%E6%8A%8A%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5%E5%88%B0GitHub/"/>
    <url>/2021/09/23/Git%E6%8A%8A%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5%E5%88%B0GitHub/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>因为现在大部分情况下是先从远程Clone下来代码，所以这一功能用的不多。但是如果自己想把本地已有的代码同步到远程，本文就可以解决这一的需求。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>GitHub新建一个仓库，并复制SSH地址  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:git201901/git_learning.git<br></code></pre></td></tr></table></figure></li><li><code>git remote add 名称</code>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pc:git-learning suling$ git remote add github git@github.com:git201901/git_learning.git<br></code></pre></td></tr></table></figure>  这里的<code>github</code>就是自定义的一个名称，用于替换后面的远程地址。方便后续<code>git push github</code>以及<code>git fetch github</code>。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Undefined reference to问题</title>
    <link href="/2021/09/17/%E8%A7%A3%E5%86%B3Undefined-reference-to%E9%97%AE%E9%A2%98/"/>
    <url>/2021/09/17/%E8%A7%A3%E5%86%B3Undefined-reference-to%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="链接时缺失了相关目标文件"><a href="#链接时缺失了相关目标文件" class="headerlink" title="链接时缺失了相关目标文件"></a>链接时缺失了相关目标文件</h2><p>这是最典型最常见的情况。比如新添加了一个模块<code>fun.h fun.c</code>两个文件，其他文件中使用了这个模块里的函数，如果编译时忘记加上这两个文件，调用<code>fun</code>模块函数的地方，就会报<code>undefined reference</code>错误。</p><p>这个问题在编辑器中一般不容易发现，因为头文件包含是正确的，编辑器能够找到相关的函数及其实现，所以在编写代码时不会报错。</p><h2 id="链接时缺少相关的库文件"><a href="#链接时缺少相关的库文件" class="headerlink" title="链接时缺少相关的库文件"></a>链接时缺少相关的库文件</h2><p>这个原因和上一条类似，我们在调用静态库中的函数时，编译时如果没有将静态库一起编译，就会报同样的错误。</p><h2 id="链接的库文件中又使用了另一个库文件"><a href="#链接的库文件中又使用了另一个库文件" class="headerlink" title="链接的库文件中又使用了另一个库文件"></a>链接的库文件中又使用了另一个库文件</h2><p>在使用第三方库时，一定要在编译中加入第三方库的路径。</p><h2 id="多个库文件链接顺序问题"><a href="#多个库文件链接顺序问题" class="headerlink" title="多个库文件链接顺序问题"></a>多个库文件链接顺序问题</h2><p>在链接命令中给出所依赖的库时，需要注意库之间的依赖顺序，依赖其他库的库一定要放到被依赖库的前面，这样才能真正避免undefined reference的错误，完成编译链接。</p><h2 id="声明与实现不一致"><a href="#声明与实现不一致" class="headerlink" title="声明与实现不一致"></a>声明与实现不一致</h2><p>这个原因也比较典型，注意排查声明与实现的参数是否一致，返回值是否一致。</p><h2 id="在c-代码中链接c语言的库"><a href="#在c-代码中链接c语言的库" class="headerlink" title="在c++代码中链接c语言的库"></a>在c++代码中链接c语言的库</h2><p>在<code>C++</code>代码中，调用了<code>C</code>语言库的函数，因此链接的时候找不到，解决方法是在相关文件添加一个<code>extern &quot;C&quot;</code>的声明即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顾名思义，这个错误就是<strong>未定义</strong>你使用的内容导致的。所以要排查使用的内容是否能够被正确“找到”。使用的时候有没有声明，有没有定义，声明与定义是否一致，编译时能否正确链接等等。</p><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><p><a href="https://segmentfault.com/a/1190000006049907">“undefined reference to” 问题汇总及解决方法</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C++</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++如何避免过多使用全局变量</title>
    <link href="/2021/09/17/C-C-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <url>/2021/09/17/C-C-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>‘</p><p>具体实例可以参考<a href="https://blog.csdn.net/maple_2014/article/details/109541104">Marc Pony</a></p><h2 id="指针传参"><a href="#指针传参" class="headerlink" title="指针传参"></a>指针传参</h2><p>C语言中，全局变量用结构体封装，设计函数时，将参数以结构体指针形式传入。</p><h2 id="定义获取变量的方法-函数"><a href="#定义获取变量的方法-函数" class="headerlink" title="定义获取变量的方法/函数"></a>定义获取变量的方法/函数</h2><p>定义一个函数以<code>get/set</code>全局变量，利用<code>static</code>变量，将全局变量作用域限定于该函数，将全局变量隐藏起来。</p><h2 id="善用static"><a href="#善用static" class="headerlink" title="善用static"></a>善用<code>static</code></h2><p>把全局变量定义在某一个 .c 文件中, 并定义为 static类型，然后定义一系列操作这个变量的函数，头文件里面只有操作函数, 没有变量的声明</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言sizeof(结构体)到底有多大</title>
    <link href="/2021/09/15/C%E8%AF%AD%E8%A8%80sizeof-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%A4%A7/"/>
    <url>/2021/09/15/C%E8%AF%AD%E8%A8%80sizeof-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="C语言中各个数据类型的大小"><a href="#C语言中各个数据类型的大小" class="headerlink" title="C语言中各个数据类型的大小"></a>C语言中各个数据类型的大小</h2><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1 字节</td><td align="center">-128 到 127 或 0 到 255</td></tr><tr><td align="center">unsigned char</td><td align="center">1 字节</td><td align="center">0 到 255</td></tr><tr><td align="center">signed char</td><td align="center">1 字节</td><td align="center">-128 到 127</td></tr><tr><td align="center">int</td><td align="center">2 或 4 字节</td><td align="center">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td align="center">unsigned int</td><td align="center">2 或 4 字节</td><td align="center">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td align="center">short</td><td align="center">2 字节</td><td align="center">-32,768 到 32,767</td></tr><tr><td align="center">unsigned short</td><td align="center">2 字节</td><td align="center">0 到 65,535</td></tr><tr><td align="center">long</td><td align="center">4 字节</td><td align="center">-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="center">unsigned long</td><td align="center">4 字节</td><td align="center">0 到 4,294,967,295</td></tr><tr><td align="center">结构体(struct)</td><td align="center">待分析，需要考虑字节对齐</td><td align="center"></td></tr><tr><td align="center">联合(union)</td><td align="center">所有成员中最长的</td><td align="center"></td></tr><tr><td align="center">枚举(enum)</td><td align="center">根据数据类型</td><td align="center"></td></tr></tbody></table><h2 id="单层结构体大小"><a href="#单层结构体大小" class="headerlink" title="单层结构体大小"></a>单层结构体大小</h2><p>如果结构体中的成员数据类型相同，这样的情况最简单，<code>结构体大小=数据类型*数据个数</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test1</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>&#125; T1;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test2</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>&#125; T2;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T1 t1;<br>    <span class="hljs-keyword">int</span> siz01 = <span class="hljs-keyword">sizeof</span>(t1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, siz01); <span class="hljs-comment">//8</span><br><br>    T2 t2;<br>    <span class="hljs-keyword">int</span> siz02 = <span class="hljs-keyword">sizeof</span>(t2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, siz02); <span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是结构体中通常数据类型都各不相同，成员<strong>按照定义时的顺序依次存储在连续的内存空间</strong>。和数组不一样的是，结构体的大小不是所有成员大小简单的相加，需要考虑到地址对齐问题。看下面这样的一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test3</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">int</span> c;<br>&#125; T3;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T3 t3;<br>    <span class="hljs-keyword">int</span> siz03 = <span class="hljs-keyword">sizeof</span>(t3);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t3: %d\n&quot;</span>, siz03); <span class="hljs-comment">//t3: 12</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>sizeof</code>求该结构体的大小，发现值为<code>12</code>。<code>int</code>占<code>4</code>个字节，<code>char</code>占<code>1</code>个字节，结果应该是<code>9</code>个字节才对啊，为什么呢？</p><p>先介绍一个相关的概念——<strong>偏移量</strong>。偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员<code>int a</code>的偏移量为<code>0</code>。第二个成员<code>char b</code>的偏移量是第一个成员的偏移量加上第一个成员的大小<code>0+4</code>,其值为<code>4</code>；第三个成员<code>int c</code>的偏移量是第二个成员的偏移量加上第二个成员的大小<code>4+1</code>,其值为<code>5</code>。</p><p>即结构体的大小等于最后一个成员变量的地址与第一个成员变量的地址之差，再加上最后一个成员变量的大小。</p><p>如果不考虑对齐的情况，变量在内存中的存放如下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t3</span><br>    ________<br><span class="hljs-number">0</span>  |aaaabccc| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |c       | <span class="hljs-number">15</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><p>当我们凭直觉去用<code>4+1+4=9</code>来计算结构体大小时并不会觉得有什么错，但是通过内存的排放可以直观的看到，第三个变量的存放有点奇怪。CPU从内存中读取肯定也是极为不便的。实际存储变量时，地址要求对齐的。编译器在编译程序时会遵循两条原则：</p><ul><li>结构体变量中成员的偏移量必须是成员大小的整数倍（<code>0</code>被认为是任何数的整数倍） </li><li>结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。</li></ul><p>我们在回头分析上述的例子，前两个成员的偏移量<code>0 4</code>都满足要求，但第三个成员的偏移量为<code>5</code>，并不是自身<code>int</code>大小的整数倍。编译器在处理时会在第二个成员后面补上<code>3</code>个空字节，使得第三个成员的偏移量变成<code>8</code>。结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为<code>12</code>，满足公倍数要求。</p><p>直观描述这个结构体在内存中的存储如下，<code>星号*表示该段内存因为内存对齐被占用，也就是其实际大小。字母个数表示其单独拿出来的大小</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t3</span><br>    ________<br><span class="hljs-number">0</span>  |aaaab***| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |cccc    | <span class="hljs-number">15</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><p>再看一例，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test4</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">short</span> b;<br>&#125; T4;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T4 t4;<br>    <span class="hljs-keyword">int</span> siz04 = <span class="hljs-keyword">sizeof</span>(t4);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t4: %d\n&quot;</span>, siz04); <span class="hljs-comment">//t4: 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 成员<code>int a</code>的偏移量为0；成员<code>short b</code>的偏移量为4，都不需要调整。但计算出来的大小为<code>6</code>，显然不是成员<code>int a</code>大小的整数倍。因此，编译器会在成员<code>int b</code>后面补上<code>2</code>个字节，使得结构体的大小变成<code>8</code>从而满足第二个公倍数要求。</p><p>由此可见，结构体类型需要考虑到字节对齐的情况，<strong>不同的顺序会影响结构体的大小</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test5</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-keyword">char</span> c;<br>&#125; T5;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test6</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">int</span> c;<br>&#125; T6;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T5 t5;<br>    <span class="hljs-keyword">int</span> siz05 = <span class="hljs-keyword">sizeof</span>(t5);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t5: %d\n&quot;</span>, siz05); <span class="hljs-comment">//t5: 12</span><br><br>    T4 t6;<br>    <span class="hljs-keyword">int</span> siz06 = <span class="hljs-keyword">sizeof</span>(t6);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t6: %d\n&quot;</span>, siz06); <span class="hljs-comment">//t6: 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个结构体成员都一样，但是一个大小为<code>12</code>一个大小为<code>8</code>。我们将其在内存的存储画出来就可以明白，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t5</span><br>    ________<br><span class="hljs-number">0</span>  |a***bbbb| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |c***    | <span class="hljs-number">15</span><br>    ‾‾‾‾‾‾‾‾<br><span class="hljs-comment">//t6</span><br>    ________<br><span class="hljs-number">0</span>  |ab**cccc| <span class="hljs-number">7</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>结构体大小等于最后一个成员的偏移量加上最后一个成员的大小</li><li>结构体变量中成员的偏移量必须是成员大小的整数倍（<code>0</code>被认为是任何数的整数倍） </li><li>结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数</li><li>不同的顺序会影响结构体的大小</li></ul><h2 id="嵌套结构体大小"><a href="#嵌套结构体大小" class="headerlink" title="嵌套结构体大小"></a>嵌套结构体大小</h2><p>对于嵌套的结构体，需要将其展开。对结构体求<code>sizeof</code>时，上述两种原则变为：</p><ul><li>展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test7</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">short</span> a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">char</span> b;<br>        <span class="hljs-keyword">int</span> c;<br>    &#125; tt;<br>    <span class="hljs-keyword">int</span> d;<br>&#125; T7;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T7 t7;<br>    <span class="hljs-keyword">int</span> siz07 = <span class="hljs-keyword">sizeof</span>(t7);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t7: %d\n&quot;</span>, siz07); <span class="hljs-comment">//t7: 16</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据原则一，<code>tt</code>的偏移量应该是<code>4</code>，而不是<code>2</code>。</p><p>在内存中的存储，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t7</span><br>    ________<br><span class="hljs-number">0</span>  |aa**b***| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |ccccdddd| <span class="hljs-number">15</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test8</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">char</span> b;<br>        <span class="hljs-keyword">int</span> c;<br>    &#125; tt;<br>    <span class="hljs-keyword">char</span> d;<br>    <span class="hljs-keyword">char</span> e;<br>    <span class="hljs-keyword">char</span> f;<br>    <span class="hljs-keyword">char</span> g;<br>    <span class="hljs-keyword">char</span> h;<br>&#125; T8;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T8 t8;<br>    <span class="hljs-keyword">int</span> siz08 = <span class="hljs-keyword">sizeof</span>(t8);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t8: %d\n&quot;</span>, siz08); <span class="hljs-comment">//t8: 20</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体<code>tt</code>单独计算占用空间为<code>8</code>，而<code>t8</code>则是<code>20</code>，不是<code>8</code>的整数倍，这说明在计算<code>sizeof(t8)</code>时，将嵌套的结构体<code>tt</code>展开了，这样<code>t8</code>中最大的成员为<code>tt.c</code>，占用4个字节，<code>20</code>为4的整数倍。如果将<code>tt</code>当做一个整体，结果应该是<code>24</code>了。</p><p>在内存中的存储，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t8</span><br>    ________<br><span class="hljs-number">0</span>  |a***b***| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |ccccdefg| <span class="hljs-number">15</span><br><span class="hljs-number">16</span> |h***    | <span class="hljs-number">31</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><p>另一个特殊的例子是结构体中包含数组，其大小计算应当和处理嵌套结构体一样，将其展开，如下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test9</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">float</span> b;<br>    <span class="hljs-keyword">int</span> c[<span class="hljs-number">2</span>];<br>&#125; T9;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    T9 t9;<br>    <span class="hljs-keyword">int</span> siz09 = <span class="hljs-keyword">sizeof</span>(t9);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t9: %d\n&quot;</span>, siz09); <span class="hljs-comment">//t9: 16</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>char a</code>占一个字节，偏移量为<code>0</code>，<code>short b</code>占四字节，偏移量为<code>2</code>，不是最大成员的整数倍，这里取最大成员是<code>int</code>或者<code>short</code>的大小的倍数。而不是整个数组<code>int c[2]</code>的倍数。所以<code>short b</code>偏移量扩展为<code>4</code>。</p><p>内存中存储，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t9</span><br>    ________<br><span class="hljs-number">0</span>  |a***bbbb| <span class="hljs-number">7</span><br><span class="hljs-number">8</span>  |cccccccc| <span class="hljs-number">15</span><br>    ‾‾‾‾‾‾‾‾<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</li><li>想象在内存中的存储，保证对齐要求，基本上可以比较准确的算出来</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt命令行带参数启动Qt程序</title>
    <link href="/2021/09/13/Qt%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E5%90%AF%E5%8A%A8Qt%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/09/13/Qt%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E5%90%AF%E5%8A%A8Qt%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们经常用到命令行参数，比如最常见的Linux命令，显示所有文件<code>ls -a</code>,<code>ls</code>其实就是一个程序，<code>-a</code>就是该程序需要解析的一个参数。那么如何能让Qt程序也能解析命令行参数，从命令行启动呢？</p><p>Qt从5.2版开始提供了两个类<code>QCommandLineOption</code>和<code>QCommandLineParser</code>来解析应用的命令行参数。</p><h2 id="添加程序属性信息，帮助，版本"><a href="#添加程序属性信息，帮助，版本" class="headerlink" title="添加程序属性信息，帮助，版本"></a>添加程序属性信息，帮助，版本</h2><p>一个程序启动后，我们会在命令行看到程序的一些简要信息，以及可以使用<code>-v</code>命令显示其版本信息，这些通用的参数以及被Qt分装好，可以直接使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QCommandLineParser&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    QCommandLineParser parser;                        <span class="hljs-comment">// 定义解析实例</span><br>    parser.<span class="hljs-built_in">setApplicationDescription</span>(<span class="hljs-string">&quot;TestCommandLine&quot;</span>);  <span class="hljs-comment">// 描述可执行程序的属性</span><br>    parser.<span class="hljs-built_in">addHelpOption</span>();                           <span class="hljs-comment">// 添加帮助命令</span><br>    parser.<span class="hljs-built_in">addVersionOption</span>();                        <span class="hljs-comment">// 添加版本选择命令</span><br>    parser.<span class="hljs-built_in">process</span>(a);                                <span class="hljs-comment">// 把用户的命令行的放入解析实例</span><br>    MainWindow w;<br>    w.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜ ./CommandLine -h<br>Usage: ./CommandLine [options]<br>TestCommandLine<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Displays <span class="hljs-built_in">help</span> on commandline options.<br>  --help-all     Displays <span class="hljs-built_in">help</span> including Qt specific options.<br>  -v, --version  Displays version information.<br></code></pre></td></tr></table></figure><h2 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QCommandLineParser&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QCommandLineOption&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    QCommandLineParser parser;                        <span class="hljs-comment">// 定义解析实例</span><br>    parser.<span class="hljs-built_in">setApplicationDescription</span>(<span class="hljs-string">&quot;TestCommandLine&quot;</span>);  <span class="hljs-comment">// 描述可执行程序的属性</span><br>    parser.<span class="hljs-built_in">addHelpOption</span>();                           <span class="hljs-comment">// 添加帮助命令</span><br>    parser.<span class="hljs-built_in">addVersionOption</span>();                        <span class="hljs-comment">// 添加版本选择命令</span><br><br>    <span class="hljs-function">QCommandLineOption  <span class="hljs-title">CommandExe</span><span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>, QGuiApplication::translate(<span class="hljs-string">&quot;main&quot;</span>,<span class="hljs-string">&quot;Take  the  first  argument  as a command to execute, &quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                                          <span class="hljs-string">&quot;rather than reading commands from a script or standard input.  &quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                                          <span class="hljs-string">&quot;If  any  fur‐\ther  arguments  are  given,  &quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                                          <span class="hljs-string">&quot;the  first  one is assigned to $0,&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                                          <span class="hljs-string">&quot; rather than being used as a positional parameter.&quot;</span>))</span></span>;<br><br>    parser.<span class="hljs-built_in">addOption</span>(CommandExe);<br>    parser.<span class="hljs-built_in">process</span>(a);                                <span class="hljs-comment">// 把用户的命令行的放入解析实例</span><br>    MainWindow w;<br>    w.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vim">➜ ./CommandLine -h<br>Usage: ./CommandLine [<span class="hljs-keyword">options</span>]<br>TestCommandLine<br><br>Option<span class="hljs-variable">s:</span><br>  -h, --<span class="hljs-keyword">help</span>     Displays <span class="hljs-keyword">help</span> <span class="hljs-keyword">on</span> commandline <span class="hljs-keyword">options</span>.<br>  --<span class="hljs-keyword">help</span>-<span class="hljs-keyword">all</span>     Displays <span class="hljs-keyword">help</span> including Qt specific <span class="hljs-keyword">options</span>.<br>  -v, --<span class="hljs-keyword">version</span>  Displays <span class="hljs-keyword">version</span> information.<br>  -<span class="hljs-keyword">c</span>             Take  the  <span class="hljs-keyword">first</span>  <span class="hljs-keyword">argument</span>  <span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">command</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">execute</span>, rather<br>                 than reading commands from <span class="hljs-keyword">a</span> script <span class="hljs-built_in">or</span> standard <span class="hljs-built_in">input</span>.  If  any<br>                 fur‐her  arguments  are  given,  the  <span class="hljs-keyword">first</span>  one <span class="hljs-keyword">is</span> assigned<br>                 <span class="hljs-keyword">to</span> $<span class="hljs-number">0</span>, rather than being used <span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> positional parameter.<br></code></pre></td></tr></table></figure><h2 id="获取参数值"><a href="#获取参数值" class="headerlink" title="获取参数值"></a>获取参数值</h2><p>如果需要从命令行获取参数值，那么必须要给参数值，指定一个名字。如，参数接收的是路径，可以<code>setValueName(&quot;path&quot;)</code>，如，参数接收的是个数值，可以<code>setValueName(&quot;value&quot;)</code>。</p><p>如果不设置参数值名称，那么将无法获取其值。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git不同人修改了不同的文件该如何处理</title>
    <link href="/2021/09/12/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <url>/2021/09/12/Git%E4%B8%8D%E5%90%8C%E4%BA%BA%E4%BF%AE%E6%94%B9%E4%BA%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>同一个项目，<strong>不同的开发者修改了不同的文件</strong>，如何解决同步冲突。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="用户一修改"><a href="#用户一修改" class="headerlink" title="用户一修改"></a>用户一修改</h3><p>第一个用户新建一个分支，<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222312698.png"></p><p>以上命令就是新建一个分支<code>feature/add_git_commands</code> 将其与远端分支<code>origin/feature/add_git_commands</code>相关联，并切换到该分支。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111222317370.png"></p><p>修改readme文件，并推送到远端。因为新建分支时已经做了与远端关联，所以可以直接<code>git push</code>。</p><h3 id="用户二修改"><a href="#用户二修改" class="headerlink" title="用户二修改"></a>用户二修改</h3><p>第二个用户，首先拉取远端分支。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232232495.png"></p><p><code>git branch -v</code>查看本地分支，保持不变，但是<code>git branch -av</code>查看所有分支，可以发现多了两个远端分支。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232233342.png"></p><p>新建本地分支，保持与远端分支名相同。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232235005.png"></p><p>此时再对与readme不同的文件进行修改，提交，推送都会比较顺利。因为当前分支保持<code>fast forward</code>。</p><p>用户二继续做开发，但是没再往远端推送代码。在此期间，用户一对远端代码进行了更新。用户二想再次推送代码，将会报错，提示当前提交不再<code>fast forward</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232242069.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li><p><code>git fetch</code>远端分支<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232243841.png"></p></li><li><p><code>git merge</code>合并远端分支<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202111232245751.png"></p></li></ul><p>因为两个用户修改的不同文件，所以合并不会产生冲突。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决TypeError [ERR_INVALID_ARG_TYPE]: The data argument must be of type string or an instance of Buffe</title>
    <link href="/2021/09/10/%E8%A7%A3%E5%86%B3TypeError-ERR-INVALID-ARG-TYPE-The-data-argument-must-be-of-type-string-or-an-instance-of-Buffe/"/>
    <url>/2021/09/10/%E8%A7%A3%E5%86%B3TypeError-ERR-INVALID-ARG-TYPE-The-data-argument-must-be-of-type-string-or-an-instance-of-Buffe/</url>
    
    <content type="html"><![CDATA[<p>安装GitBook时出现这个错误，将<code>node</code>版本降级即可</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs smali">MINGW64 ~/Desktop/dir1/dir11<br>$ gitbook init<br>warn: no summary file in this book<br>info: create SUMMARY.md<br><br>TypeError [ERR_INVALID_ARG_TYPE]: The <span class="hljs-string">&quot;data&quot;</span> argument must be of type string<br><span class="hljs-built_in"> or </span>an<span class="hljs-built_in"> instance </span>of Buffer, TypedArray,<span class="hljs-built_in"> or </span>DataView. Received an<span class="hljs-built_in"> instance </span>of<br>Promise<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言预处理</title>
    <link href="/2021/09/09/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <url>/2021/09/09/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是预处理"><a href="#什么是预处理" class="headerlink" title="什么是预处理"></a>什么是预处理</h2><p>C语言通过预处理器提供了一些语言功能。从概念上讲, 预处理器是编译过程中单独执行的第一个步骤。两个最常用的预处理器指令是: <code>#include</code> 指令(用于在编译期间把指定文件的内容包含进当前文件中)和 <code>#define</code> 指令(用任意字符序列替代一个标记)。</p><p>为啥要进行预先处理呢？如果要深入的了解的话可以参考《程序员的自我修养：链接、装载与库》这本书。这里举一个非常常见的例子，假如我们编写跨平台的程序时，我们就需要考虑不同平台的系统库是不同的，如果只包含了一个平台下的库文件，换个平台编译就可能出错。这时候就需要在编译前进行预处理。</p><p>有重要的预处理器指令：<br>| 指令     | 描述|<br>|:———-:|:—–:|<br>| #define  | 定义宏|<br>| #include | 包含一个源代码文件|<br>| #undef   | 取消已定义的宏|<br>| #ifdef   | 如果宏已经定义，则返回真|<br>| #ifndef  | 如果宏没有定义，则返回真|<br>| #if      | 如果给定条件为真，则编译下面代码|<br>| #else    | #if 的替代方案|<br>| #elif    | 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 |<br>| #endif   | 结束一个 #if……#else 条件编译块|<br>| #error   | 当遇到标准错误时，输出错误消息|<br>| #pragma  | 使用标准化方法，向编译器发布特殊的命令到编译器中|</p><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><h3 id="if"><a href="#if" class="headerlink" title="#if"></a><code>#if</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 整型常量表达式1</span><br>    程序段<span class="hljs-number">1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> 整型常量表达式2</span><br>    程序段<span class="hljs-number">2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> 整型常量表达式3</span><br>    程序段<span class="hljs-number">3</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    程序段<span class="hljs-number">4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>它的意思是：如常“表达式1”的值为真（非0），就对“程序段1”进行编译，否则就计算“表达式2”，结果为真的话就对“程序段2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 <code>#else</code> 。这一点和 <code>if else</code> 非常类似。</p><p>需要注意的是， <code>#if</code> 命令要求判断条件为<strong>整型常量表达式</strong>，也就是说，表达式中不能包含变量，而且结果必须是整数；而 <code>if</code> 后面的表达式没有限制，只要符合语法就行。这是 <code> #if</code> 和 <code>if</code> 的一个重要区别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//不同的平台下引入不同的头文件</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _WIN32  <span class="hljs-comment">//识别windows平台</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __linux__  <span class="hljs-comment">//识别linux平台</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//不同的平台下调用不同的函数</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _WIN32  <span class="hljs-comment">//识别windows平台</span></span><br>    Sleep(<span class="hljs-number">5000</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __linux__  <span class="hljs-comment">//识别linux平台</span></span><br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;http://c.biancheng.net/&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ifedf"><a href="#ifedf" class="headerlink" title="#ifedf"></a><code>#ifedf</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span>  宏名</span><br>    程序段<span class="hljs-number">1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    程序段<span class="hljs-number">2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a><code>#ifndef</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> 宏名</span><br>    程序段<span class="hljs-number">1</span> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> </span><br>    程序段<span class="hljs-number">2</span> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>与<code>#ifdef</code>相比，仅仅是将 <code>#ifdef</code> 改为了 <code>#ifndef</code>。它的意思是，如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与<code> #ifdef</code> 的功能正好相反。</p><h2 id="文件包含-include"><a href="#文件包含-include" class="headerlink" title="文件包含#include"></a>文件包含#include</h2><p><code>#include</code> 叫做文件包含命令，用来引入对应的头文件（.h文件）。 <code>#include</code> 的处理过程很简单，就是将<strong>头文件的内容插入到该命令所在的位置</strong>，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。</p><p><code>#include</code> 的用法有两种，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdHeader.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myHeader.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>使用尖括号 <code>&lt; &gt;</code> 和双引号 <code>&quot; &quot;</code> 的区别在于头文件的搜索路径不同：</p><ul><li>使用尖括号<code>&lt; &gt;</code>，编译器会到环境变量下查找头文件；</li><li>使用双引号<code>&quot; &quot;</code>，编译器首先在当前目录下查找头文件，如果没有找到，再到环境变量下查找。</li></ul><p>注意事项：</p><ul><li>在头文件中尽量不要进行函数的定义，只对其进行声明。否则如果有多个源文件链接时会报错</li><li>某一个头文件的内容发生变化，所有包含该文件的源文件都需要重新编译</li><li>一个<code>#include</code>命令指定一个头文件，多个头文件需要多个<code>#include</code></li><li>包含可以嵌套</li><li>文件1包含文件2，文件2用到文件3，则文件3的包含命令#include应放在文件1的头部第一行；</li><li>被包含文件中的静态全局变量不用在包含文件中声明</li></ul><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p><code>#define</code> 叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就<strong>全部替换成指定的字符串</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  宏名  字符串    <span class="hljs-comment">//基本格式</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100           <span class="hljs-comment">//将所有N都替换成整数100</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> forever for (;;) <span class="hljs-comment">//该语句为无限循环定义了一个新名字forever</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max(A, B) ((A)&gt; (B) ? (A) : (B) )</span><br><br></code></pre></td></tr></table></figure><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>对于函数，其调用必须要将程序执行的顺序跳转到函数所在内存的某个地址，在将函数程序执行完成后，再跳转回去执行函数调用前的地方。这种跳转操作要求在函数执行前保存现场并记录当前执行地址，函数调用返回后要恢复现场，并按原来保存地址继续执行。因此，函数调用会有一定的时间和空间方面的开销，必将影响程序的运行效率。</p><p>对于宏，它只是在预处理的地方<strong>把代码展开</strong>，而不需要额外的空间和时间方面的开销，因此调用宏比调用函数更有效率。</p><p>但是，宏也有很多的问题和缺陷：</p><ul><li>在C语言中，宏容易出现一些边界性的问题，容易产生歧义。(优先级的问题，能加括号都加括号)</li><li>在C++语言中，宏不可以调用C++类中的私有或受保护的成员。</li></ul><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>能用括号的地方都用括号，不要偷懒省略，以免歧义，特别是于带参宏定义不仅要在参数两侧加括号，还应该在整个字符串外加括号</li><li> 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换</li><li>宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用<code>#undef</code>命令</li><li>代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替</li><li>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换</li><li>习惯上宏名用大写字母表示，以便于与变量区别</li><li>可用宏定义表示数据类型，使书写方便</li><li>带参数的宏和函数很相似，但有本质上的区别：宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，<strong>它没有机会参与编译，也不会占用内存</strong>。而函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。</li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>从上文可知，可以看到宏有一些难以避免的问题，对于不能访问C++类中私有或者受保护的成员，我们应该如何解决呢？</p><h3 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h3><p>关键字 <code>inline</code> 告诉编译器，任何地方只要调用内联函数，就直接把该函数的机器码插入到调用它的地方。这样程序执行更有效率，就好像将内联函数中的语句直接插入到了源代码文件中需要调用该函数的地方一样。</p><h3 id="why-1"><a href="#why-1" class="headerlink" title="why"></a>why</h3><p>内联函数是代码被插入到调用者代码处的函数。如同 <code>#define</code> 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（过程化集成）被编译器优化。</p><p>内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而<strong>内联函数是通过编译器控制来实现的</strong>。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以像调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>对于内联函数，其工作原理是：</p><p>对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型）。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。在调用一个内联函数时，编译器首先检查调用是否正确（<strong>进行类型安全检查</strong>，或者进行<strong>自动类型转换</strong>，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。</p><p>这个过程与预处理有显著的不同，<strong>因为预处理器不能进行类型安全检查，或者进行自动类型转换</strong>。假如内联函数是成员函数，对象的地址（this）会被放在合适的地方，这也是预处理器办不到的。</p><h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h3><ul><li>当你定义一个内联函数时，在函数定义前加上 <code>inline</code> 关键字，并且将定义放入<strong>头文件</strong>。</li><li>内联函数必须是和函数体声明在一起才有效</li><li>内联函数不宜过大，比如循环体，递归体就不适合内联。如果过大，编译器会放弃内联，采用普通方式调用函数。</li></ul><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><p><a href="https://www.runoob.com/cprogramming/c-preprocessors.html">C预处理器</a><br><a href="http://c.biancheng.net/view/1878.html">C语言预处理命令是什么？</a><br><a href="https://developer.aliyun.com/article/632378">C语言中宏与内联函数解析</a><br><a href="http://c.biancheng.net/view/339.html">C语言内联函数</a><br><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">内联函数</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决expected &#39;char * const*&#39; but argument is of type &#39;char **&#39;</title>
    <link href="/2021/09/08/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/"/>
    <url>/2021/09/08/%E8%A7%A3%E5%86%B3expected-char-const-but-argument-is-of-type-char/</url>
    
    <content type="html"><![CDATA[<p>在使用<code>exec</code>系列函数时，<code>execle</code>，<code>execv</code>，<code>execvp</code>三个函数，都可以使用<code>char *arg[]</code>传入启动参数。以下面的程序为例，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-keyword">char</span> *argv[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-literal">NULL</span>&#125;;<br>    ret = execvp(<span class="hljs-string">&quot;ls&quot;</span>,argv);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        perror(<span class="hljs-string">&quot;execl error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译时就会出现一下，警告，</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">expected &#x27;<span class="hljs-built_in">char</span> * <span class="hljs-keyword">const</span>*&#x27; but argument <span class="hljs-keyword">is</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> &#x27;<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> **&#x27;<br></code></pre></td></tr></table></figure><p>因为项目中不允许警告产生，所以编译选项是<code>-Werror</code>，所有警告都会被升级成错误。编译时就会产生如下提示，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ccl : all warnings being treated as errors<br></code></pre></td></tr></table></figure><p>如果是平时练习，改一下编译选项，把这个警告忽略就行，但是现在只能解决。</p><p>出现这个问题就是因为定义数组时<code>char *argv[]</code>类型是<code>char **</code>。但是<code>execvp()</code>函数签名是<code>execvp(const char *file, char *const argv[]);</code>第二个参数的类型是<code>char * const *</code>。</p><p>本以为直接将变量定义更改成<code>char * const argv[]</code>就行了，但是它等价于<code>const char **</code>，所以仍然不能和函数签名匹配。</p><p>实在没办法只能改成如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;entering main process---\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-keyword">char</span> str1[] = <span class="hljs-string">&quot;ls&quot;</span>;<br>    <span class="hljs-keyword">char</span> str2[] = <span class="hljs-string">&quot;-l&quot;</span>;<br>    <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> argv[] = &#123;str1, str2, <span class="hljs-literal">NULL</span>&#125;;<br>    ret = execvp(<span class="hljs-string">&quot;ls&quot;</span>,argv);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        perror(<span class="hljs-string">&quot;execl error&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exiting main process ----\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者在将形参<code>argv</code>进行强制转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;entering main process---\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    ret = execvp(<span class="hljs-string">&quot;ls&quot;</span>,(<span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> *)argv);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        perror(<span class="hljs-string">&quot;execl error&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exiting main process ----\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode中调试带Makefile文件的项目</title>
    <link href="/2021/09/06/VSCode%E4%B8%AD%E8%B0%83%E8%AF%95%E5%B8%A6Makefile%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/09/06/VSCode%E4%B8%AD%E8%B0%83%E8%AF%95%E5%B8%A6Makefile%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>在调试QEMU时，自己需要修改源文件，但是每次修改都需要在命令行重新<code>make</code>编译一遍，比较麻烦，想到之前刚刚配置过<code>tasks.json</code>文件，可以把命令行任务配置到文件里，<code>make</code>命令不也一样可以加入吗？修改<code>tasks.json</code>文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>    &#123;<br>       <span class="hljs-comment">//任务的名字方便执行</span><br>      <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;make qemu&quot;</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>      <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>,<br>      <span class="hljs-attr">&quot;args&quot;</span>:[<br>          <span class="hljs-comment">//8线程编译</span><br>          <span class="hljs-string">&quot;-j8&quot;</span>,<br>      ],<br>      <span class="hljs-attr">&quot;options&quot;</span>: &#123;<br>        <span class="hljs-comment">//切换到build文件夹下</span><br>        <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span> <br>      &#125;,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-comment">// 启动qemu供调试器连接</span><br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>        <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Run Qemu Server(RISCV)&quot;</span>,<br>        <span class="hljs-comment">//在执行这个任务前，先执行make qemu任务、</span><br>        <span class="hljs-comment">//这样就可以在执行调试时，自动先编译一遍</span><br>        <span class="hljs-attr">&quot;dependsOn&quot;</span>: <span class="hljs-string">&quot;make qemu&quot;</span>,<br>        <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;qemu-system-riscv64&quot;</span>,<br>        <span class="hljs-attr">&quot;args&quot;</span>: [<br>            <span class="hljs-string">&quot;-g&quot;</span>,<br>            <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>        ],<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决gcc-multilib : 依赖: gcc-4.8-multilib (&gt;= 4.8.2-5~) 但是它将不会被安装</title>
    <link href="/2021/09/03/%E8%A7%A3%E5%86%B3gcc-multilib-%E4%BE%9D%E8%B5%96-gcc-4-8-multilib-4-8-2-5-%E4%BD%86%E6%98%AF%E5%AE%83%E5%B0%86%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%AE%89%E8%A3%85/"/>
    <url>/2021/09/03/%E8%A7%A3%E5%86%B3gcc-multilib-%E4%BE%9D%E8%B5%96-gcc-4-8-multilib-4-8-2-5-%E4%BD%86%E6%98%AF%E5%AE%83%E5%B0%86%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这是一类问题，不仅限于安装gcc，这类问题的根本原因在于，<strong>Ubuntu已安装的软件包版本高，而所安装软件的依赖包版本低</strong>，这样在安装高版软件时，已有的软件包依赖你要安装的软件包，你把软件包升级了，可能就会破坏这个依赖关系，所以<code>apt-get</code>不让你安装。</p><p>这时就要请到大杀器-<code>aptitude</code>，它与 <code>apt-get </code>一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 <code>apt-get</code> 不同的是，<code>aptitude</code>在处理依赖问题上更佳一些。举例来说，<code>aptitude</code>在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$sudo</span> apt-get install aptitude  <span class="hljs-regexp">//</span>安装aptitude包管理器<br><span class="hljs-variable">$sudo</span> aptitude install gcc-multilib <span class="hljs-regexp">//</span>用新的包管理器安装你要安装的软件<br></code></pre></td></tr></table></figure><p>安装<code>gcc-multilib</code>时会把所有依赖包一并安装，此时会让你同意，选择<code>n</code>就行。</p><p>接下来就会解决已经安装的包之间的依赖关系，他会降级或升级一些软件包来匹配当前安装的软件版本，此时选择<code>y</code>。</p><p>完成以上操作，再次正常安装需要的软件包即可成功安装。</p><p>如果无法正常安装，重复以上操作，每次都选择<code>n</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决fatal error: bits/libc-header-start.h：no such file</title>
    <link href="/2021/09/03/%E8%A7%A3%E5%86%B3fatal-error-bits-libc-header-start-h%EF%BC%9Ano-such-file/"/>
    <url>/2021/09/03/%E8%A7%A3%E5%86%B3fatal-error-bits-libc-header-start-h%EF%BC%9Ano-such-file/</url>
    
    <content type="html"><![CDATA[<h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>想要分别编译32位和64位的程序时，gcc出现了错误，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">In <span class="hljs-keyword">file</span> included <span class="hljs-keyword">from</span> func_call.c:<span class="hljs-number">1</span>:<br><span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/stdio.h:27:10: fatal error: bits/</span>libc-header-start.h: 没有那个文件或目录<br>   <span class="hljs-number">27</span> | #<span class="hljs-keyword">include</span> &lt;bits/libc-header-start.h&gt;<br>      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~<br>compilation terminated.<br></code></pre></td></tr></table></figure><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>问题原因猜测是默认gcc只提供当前机器的版本，解决如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">install</span> gcc-multilib<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
      <tag>汇编语言</tag>
      
      <tag>GCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU源码分析-虚拟CPU创建</title>
    <link href="/2021/09/01/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9FCPU%E5%88%9B%E5%BB%BA/"/>
    <url>/2021/09/01/QEMU%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9FCPU%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>先开个头吧，把创建流程稍微捋一下，找到创建虚拟CPU的模块。至于中间的流程还没有详细分析，万事开头难，先上手再说吧。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210901182329.svg"></p><h2 id="qemu-add-opts解析qemu的命令行"><a href="#qemu-add-opts解析qemu的命令行" class="headerlink" title="qemu_add_opts解析qemu的命令行"></a><code>qemu_add_opts</code>解析qemu的命令行</h2><p><code>qemu_init</code>函数中下面这一长串内容，就是在解析命令行的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu drive opts)</span></span>;<br><span class="hljs-function">qemu add drive <span class="hljs-title">opts</span><span class="hljs-params">(&amp;qemu Legacy drive opts)</span></span>;<br><span class="hljs-function">qemu add drive <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu common drive opts)</span></span>;<br><span class="hljs-function">qemu add drive <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu drive opts)</span></span>;<br><span class="hljs-function">qemu add drive <span class="hljs-title">opts</span> <span class="hljs-params">(sbdry runtime opts)</span></span>;<br><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(qemu chardev opts)</span></span>;<br><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu device opts)</span></span>;<br><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu netdev opts)</span></span>;<br><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(&amp;qemu nic opts)</span></span>;<br><span class="hljs-function">qemu add <span class="hljs-title">opts</span> <span class="hljs-params">(sqemu net opts</span></span><br><span class="hljs-params"><span class="hljs-function">qemu add opts (&amp;qemu rtc opts)</span></span><br><span class="hljs-params"><span class="hljs-function">qemu add opts (&amp;qemu global_opts);</span></span><br><span class="hljs-params"><span class="hljs-function">qemu add opts (&amp;qemu mon opts);</span></span><br><span class="hljs-params"><span class="hljs-function">qemu add opts (sqemu trace opts);</span></span><br><span class="hljs-params"><span class="hljs-function">.</span></span><br><span class="hljs-params"><span class="hljs-function">.</span></span><br><span class="hljs-params"><span class="hljs-function">.</span></span><br></code></pre></td></tr></table></figure><p>为什么有这么多的 <code>opts </code>呢？这是因为，实际运行中创建的<code>kvm</code>参数会复杂<code>N</code>倍。这里我们贴一个开源云平台软件 <code>OpenStack</code> 创建出来的<code>KVM</code>的参数，如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-system-x86_64<br>-enable-kvm<br>-name instance-00000024<br>-machine pc-i440fx-trusty,accel=kvm,usb=off<br>-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme<br>-m 2048<br>-smp 1,sockets=1,cores=1,threads=1<br>......<br>-rtc base=utc,driftfix=slew<br>-drive file=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if=none,id=drive-virtio-disk0,format=qcow2,cache=none<br>-device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x4,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1<br>-netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37<br>-device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3<br>-chardev file,id=charserial0,path=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/console.log<br>-vnc 0.0.0.0:12<br>-device cirrus-vga,id=video0,bus=pci.0,addr=0x2<br></code></pre></td></tr></table></figure><ul><li><p><code>-enable-kvm</code>：表示启用硬件辅助虚拟化。</p></li><li><p><code>-name instance-00000024</code>：表示虚拟机的名称。</p></li><li><p><code>-machine pc-i440fx-trusty,accel=kvm,usb=off</code>：machine 是什么呢？其实就是计算机体系结构。不知道什么是体系结构的话，可以订阅极客时间的另一个专栏《深入浅出计算机组成原理》。<br>qemu 会模拟多种体系结构，常用的有普通 PC 机，也即 x86 的 32 位或者 64 位的体系结构、Mac 电脑 PowerPC 的体系结构、Sun 的体系结构、MIPS 的体系结构，精简指令集。如果使用 KVM hardware-assisted virtualization，也即 BIOS 中 VD-T 是打开的，则参数中 <code>accel=kvm</code>。如果不使用 <code>hardware-assisted virtualization</code>，用的是纯模拟，则有参数 <code>accel = tcg</code>，<code>-no-kvm</code>。</p></li><li><p><code>-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme</code>：表示设置 CPU，SandyBridge 是 Intel 处理器，后面的加号都是添加的 CPU 的参数，这些参数会显示在 /proc/cpuinfo 里面。</p></li><li><p><code>-m 2048</code>：表示内存。</p></li><li><p><code>-smp 1,sockets=1,cores=1,threads=1</code>：<code>SMP</code> 我们解析过，叫对称多处理器，和<code> NUMA</code> 对应。qemu 仿真了一个具有 1 个 <code>vcpu</code>，一个 <code>socket</code>，一个 <code>core</code>，一个 <code>threads</code> 的处理器。<br><code>socket</code>、<code>core</code>、<code>threads</code> 是什么概念呢？<code>socket</code> 就是主板上插 cpu 的槽的数目，也即常说的“路”，<code>core</code> 就是我们平时说的“核”，即双核、4 核等。<code>thread</code> 就是每个 core 的硬件线程数，即超线程。举个具体的例子，某个服务器是：2 路 4 核超线程（一般默认为 2 个线程），通过 <code>cat /proc/cpuinfo</code>，我们看到的是 242=16 个<code> processor</code>，很多人也习惯成为 16 核了。</p></li><li><p><code>-rtc base=utc,driftfix=slew</code>：表示系统时间由参数 <code>-rtc</code> 指定。</p></li><li><p><code>-device cirrus-vga,id=video0,bus=pci.0,addr=0x2</code>：表示显示器用参数 <code>-vga</code> 设置，默认为 <code>cirrus</code>，它模拟了 <code>CL-GD5446PCI VGA card</code>。</p></li><li><p>有关网卡，使用 <code>-net</code> 参数和 <code>-device</code>。</p></li><li><p>从 HOST 角度：<code>-netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37</code>。</p></li><li><p>从 GUEST 角度：<code>-device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3</code>。</p></li><li><p>有关硬盘，使用 <code>-hda -hdb</code>，或者使用 <code>-drive</code> 和 <code>-device</code>。</p></li><li><p>从 HOST 角度：<code>-drive file=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if=none,id=drive-virtio-disk0,format=qcow2,cache=none</code></p></li><li><p>从 GUEST 角度：<code>-device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x4,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1</code></p></li><li><p><code>-vnc 0.0.0.0:12</code>：设置 VNC。</p><h2 id="module-call-init初始化所有模块"><a href="#module-call-init初始化所有模块" class="headerlink" title="module_call_init初始化所有模块"></a><code>module_call_init</code>初始化所有模块</h2></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">--&gt; <span class="hljs-title">qemu_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">--&gt; <span class="hljs-title">qemu_init_subsystems</span><span class="hljs-params">()</span></span><br><span class="hljs-function">--&gt; <span class="hljs-title">module_call_init</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>当虚拟机真的要使用物理资源的时候，对下面的物理机上的资源要进行请求，所以它的工作模式有点儿类似操作系统对接驱动。驱动要符合一定的格式，才能算操作系统的一个模块。同理，qemu 为了模拟各种各样的设备，也需要管理各种各样的模块，这些模块也需要符合一定的格式。</p><p>定义一个 qemu 模块会调用 <code>type_init</code>。例如，<code>kvm</code> 的模块要在 <code>accel/kvm/kvm-all.c</code> 文件里面实现。在这个文件里面，有一行下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo kvm_accel_type = &#123;<br>    .name = TYPE_KVM_ACCEL,<br>    .parent = TYPE_ACCEL,<br>    .instance_init = kvm_accel_instance_init,<br>    .class_init = kvm_accel_class_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(KVMState),<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_type_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    type_register_static(&amp;kvm_accel_type);<br>&#125;<br><br>type_init(kvm_type_init);<br></code></pre></td></tr></table></figure><p>找到<code>type_init</code>的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> type_init(function) module_init(function, MODULE_INIT_QOM)</span><br></code></pre></td></tr></table></figure><p>从代码里面的定义我们可以看出来，<code>type_init</code> 后面的参数是一个函数，调用 <code>type_init</code> 就相当于调用 <code>module_init</code>，在这里函数就是 <code>kvm_type_init</code>，类型就是 <code>MODULE_INIT_QOM</code>。</p><p>再查看一下<code>module_init</code>的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//include/qemu/module.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> module_init(function, type)                                         \</span><br><span class="hljs-meta">static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \</span><br><span class="hljs-meta">&#123;                                                                           \</span><br><span class="hljs-meta">    register_module_init(function, type);                                   \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><p><code>module_init</code> 最终要调用 <code>register_module_init</code>。属于 <code>MODULE_INIT_QOM</code> 这种类型的，有一个 <code>Module</code> 列表 <code>ModuleTypeList</code>，列表里面是一项一项的 <code>ModuleEntry</code>。<code>KVM</code> 就是其中一项，并且会初始化每一项的 <code>init</code> 函数为参数表示的函数 <code>fn</code>，也即 <code>KVM</code> 这个 <code>module</code> 的 <code>init</code> 函数就是 <code>kvm_type_init</code>。</p><p>当然，<code>MODULE_INIT_QOM</code> 这种类型会有很多很多的 <code>module</code>，从后面的代码我们可以看到，所有调用 <code>type_init</code> 的地方都注册了一个 <code>MODULE_INIT_QOM</code> 类型的 <code>Module</code>。</p><p>了解了 <code>Module</code> 的注册机制，我们继续回到 <code>qemu_init_subsystems</code> 函数中 <code>module_call_init</code> 的调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qemu_init_subsystems</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    Error *err;<br>    os_set_line_buffering();<br>    module_call_init(MODULE_INIT_TRACE);<br>    qemu_init_cpu_list();<br>    qemu_init_cpu_loop();<br>    qemu_mutex_lock_iothread();<br>    atexit(qemu_run_exit_notifiers);<br>    module_call_init(MODULE_INIT_QOM);<br>    module_call_init(MODULE_INIT_MIGRATION);<br>.<br>.<br>.<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// utils/module.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">module_call_init</span><span class="hljs-params">(module_init_type type)</span></span><br><span class="hljs-function"></span>&#123;<br>    ModuleTypeList *l;<br>    ModuleEntry *e;<br>    l = find_type(type);<br>    QTAILQ_FOREACH(e, l, node) &#123;<br>        e-&gt;init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>module_call_init</code> 中，我们会找到 <code>MODULE_INIT_QOM</code> 这种类型对应的 <code>ModuleTypeList</code>，找出列表中所有的 <code>ModuleEntry</code>，然后调用每个 <code>ModuleEntry</code> 的 <code>init</code> 函数。这里需要注意的是，在 <code>module_call_init</code> 调用的这一步，所有 <code>Module</code> 的 <code>init</code> 函数都已经被调用过了。</p><p>后面我们会看到很多的 <code>Module</code>，当我们后面再次遇到时，需要意识到，它的 <code>init</code> 函数在这里也被调用过了。这里我们还是以对于 <code>kvm</code> 这个 <code>module</code> 为例子，看看它的 <code>init</code> 函数都做了哪些事情。我们会发现，其实它调用的是 <code>kvm_type_init</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_type_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    type_register_static(&amp;kvm_accel_type);<br>&#125;<br><span class="hljs-function">TypeImpl *<span class="hljs-title">type_register_static</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> type_register(info);<br>&#125;<br><span class="hljs-function">TypeImpl *<span class="hljs-title">type_register</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(info-&gt;parent);<br>    <span class="hljs-keyword">return</span> type_register_internal(info);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> TypeImpl *<span class="hljs-title">type_register_internal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    TypeImpl *ti;<br>    ti = type_new(info);<br> <br>    type_table_add(ti);<br>    <span class="hljs-keyword">return</span> ti;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> TypeImpl *<span class="hljs-title">type_new</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TypeInfo *info)</span></span><br><span class="hljs-function"></span>&#123;<br>    TypeImpl *ti = g_malloc0(<span class="hljs-keyword">sizeof</span>(*ti));<br>    <span class="hljs-keyword">int</span> i;<br> <br>    <span class="hljs-keyword">if</span> (type_table_lookup(info-&gt;name) != <span class="hljs-literal">NULL</span>) &#123;<br>    &#125;<br>    ti-&gt;name = g_strdup(info-&gt;name);<br>    ti-&gt;parent = g_strdup(info-&gt;parent);<br>    ti-&gt;class_size = info-&gt;class_size;<br>    ti-&gt;instance_size = info-&gt;instance_size;<br>    ti-&gt;class_init = info-&gt;class_init;<br>    ti-&gt;class_base_init = info-&gt;class_base_init;<br>    ti-&gt;class_data = info-&gt;class_data;<br>    ti-&gt;instance_init = info-&gt;instance_init;<br>    ti-&gt;instance_post_init = info-&gt;instance_post_init;<br>    ti-&gt;instance_finalize = info-&gt;instance_finalize;<br>    ti-&gt;abstract = info-&gt;abstract;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; info-&gt;interfaces &amp;&amp; info-&gt;interfaces[i].type; i++) &#123;<br>        ti-&gt;interfaces[i].<span class="hljs-keyword">typename</span> = g_strdup(info-&gt;interfaces[i].type);<br>    &#125;<br>    ti-&gt;num_interfaces = i;<br>    <span class="hljs-keyword">return</span> ti;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">type_table_add</span><span class="hljs-params">(TypeImpl *ti)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(!enumerating_types);<br>    g_hash_table_insert(type_table_get(), (<span class="hljs-keyword">void</span> *)ti-&gt;name, ti);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> GHashTable *<span class="hljs-title">type_table_get</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> GHashTable *type_table;<br> <br>    <span class="hljs-keyword">if</span> (type_table == <span class="hljs-literal">NULL</span>) &#123;<br>        type_table = g_hash_table_new(g_str_hash, g_str_equal);<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> type_table;<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TypeInfo kvm_accel_type = &#123;<br>    .name = TYPE_KVM_ACCEL,<br>    .parent = TYPE_ACCEL,<br>    .class_init = kvm_accel_class_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(KVMState),<br>&#125;;<br></code></pre></td></tr></table></figure><p>调用流程如下：虚线表示返回</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210907133931.svg"></p><p>每一个 <code>Module</code> 既然要模拟某种设备，那应该定义一种类型 <code>TypeImpl</code> 来表示这些设备，这其实是一种<code>面向对象编程</code>的思路，只不过这里用的是纯 C 语言的实现，所以需要变相实现一下类和对象。</p><p><code>kvm_type_init</code> 会注册 <code>kvm_accel_type</code>，定义上面的代码，我们可以认为这样动态定义了一个类。这个类的名字是 <code>TYPE_KVM_ACCEL</code>，这个类有父类 <code>TYPE_ACCEL</code>，这个类的初始化应该调用函数 <code>kvm_accel_class_init</code>。如果用这个类声明一个对象，对象的大小应该是 <code>instance_size</code>。</p><p>在 <code>type_register_internal</code> 中，我们会根据 <code>kvm_accel_type</code> 这个 <code>TypeInfo</code>，创建一个<code> TypeImpl</code> 来表示这个新注册的类，也就是说，<code>TypeImpl</code> 才是我们想要声明的那个 <code>class</code>。在 qemu 里面，有一个全局的哈希表 <code>type_table</code>，用来存放所有定义的类。在 <code>type_new</code> 里面，我们先从全局表里面根据名字<code>type_table_lookup</code>查找找这个类。如果找到，说明这个类曾经被注册过，就报错；如果没有找到，说明这是一个新的类，则将 <code>TypeInfo</code> 里面信息填到 <code>TypeImpl</code> 里面。<code>type_table_add</code> 会将这个类注册到全局的表里面。到这里，我们注意，<code>class_init</code> 还没有被调用，也即这个类现在还处于纸面的状态。</p><p>这点更加像 Java 的反射机制了。在 Java 里面，对于一个类，首先我们写代码的时候要写一个 <code>class xxx</code> 的定义，编译好就放在<code>.class</code> 文件中，这也是出于纸面的状态。然后，Java 会有一个 <code>Class</code> 对象，用于读取和表示这个纸面上的 <code>class xxx</code>，可以生成真正的对象。</p><p>相同的过程在后面的代码中我们也可以看到，<code>class_init</code> 会生成<code> XXXClass</code>，就相当于 Java 里面的 <code>Class </code>对象，<code>TypeImpl</code> 还会有一个 <code>instance_init</code> 函数，相当于构造函数，用于根据 <code>XXXClass</code> 生成 <code>Object</code>，这就相当于 Java 反射里面最终创建的对象。和构造函数对应的还有 <code>instance_finalize</code>，相当于析构函数。</p><p>这一套反射机制放在 <code>qom</code> 文件夹下面，全称 <code>QEMU Object Model</code>，也即用 C 实现了一套<strong>面向对象的反射机制</strong>。</p><h2 id="初始化machine"><a href="#初始化machine" class="headerlink" title="初始化machine"></a>初始化machine</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210913115046.svg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vl.c</span><br>qemu_create_machine (select_machine());<br></code></pre></td></tr></table></figure><p>在创建machine之前，先要通过<code>select_machine</code>确定一个<code>machine</code>。<code>select_machine</code>又是怎么确定的呢，这就和我们命令行的输入有关，比如我们<code>-m spike</code>，那么这里就会选择<code>spike</code>作为<code>machine</code>。它的定义在<code>hw/riscv/spike.c</code>中。</p><p>在源码最后有这么一句，会和我们上面解析的<code>type_init</code> 是一样的，在全局的表里面注册了一个全局的名字是<code>spike</code>的纸面上的 <code>class</code>，也即 <code>TypeImpl</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">type_init(spike_machine_init_reqister_types)<br></code></pre></td></tr></table></figure><p>现在全局表中有这个纸面上的 <code>class</code> 了。我们回到 <code>select_machine</code>。</p><p>在 <code>select_machine</code> 中，有两种方式可以生成 <code>MachineClass</code>。一种方式是 <code>find_default_machine</code>，找一个默认的；另一种方式是 <code>machine_parse</code>，通过解析参数生成 <code>MachineClass</code>。无论哪种方式，都会调用 <code>object_class_get_list</code> 获得一个 <code>MachineClass</code> 的列表，然后在里面找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> MachineClass *<span class="hljs-title">select_machine</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    GSList *machines = object_class_get_list(TYPE_MACHINE, <span class="hljs-literal">false</span>);<br>    MachineClass *machine_class = find_default_machine(machines);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optarg;<br>    QemuOpts *opts;<br>    Location loc;<br>    loc_push_none(&amp;loc);<br>    opts = qemu_get_machine_opts();<br>    qemu_opts_loc_restore(opts);<br>    optarg = qemu_opt_get(opts, <span class="hljs-string">&quot;type&quot;</span>);<br>    <span class="hljs-keyword">if</span> (optarg) &#123;<br>        machine_class = machine_parse(optarg, machines);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!machine_class) &#123;<br>        error_report(<span class="hljs-string">&quot;No machine specified, and there is no default&quot;</span>);<br>        error_printf(<span class="hljs-string">&quot;Use -machine help to list supported machines\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    loc_pop(&amp;loc);<br>    g_slist_free(machines);<br>    <span class="hljs-keyword">return</span> machine_class;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> MachineClass *<span class="hljs-title">find_default_machine</span><span class="hljs-params">(GSList *machines)</span></span><br><span class="hljs-function"></span>&#123;<br>    GSList *el;<br>    MachineClass *default_machineclass = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (el = machines; el; el = el-&gt;next) &#123;<br>        MachineClass *mc = el-&gt;data;<br><br>        <span class="hljs-keyword">if</span> (mc-&gt;is_default) &#123;<br>            assert(default_machineclass == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-string">&quot;Multiple default machines&quot;</span>);<br>            default_machineclass = mc;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> default_machineclass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> MachineClass *<span class="hljs-title">machine_parse</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, GSList *machines)</span></span><br><span class="hljs-function"></span>&#123;<br>    MachineClass *mc;<br>    GSList *el;<br>    <span class="hljs-keyword">if</span> (is_help_option(name)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Supported machines are:\n&quot;</span>);<br>        machines = g_slist_sort(machines, machine_class_cmp);<br>        <span class="hljs-keyword">for</span> (el = machines; el; el = el-&gt;next) &#123;<br>            MachineClass *mc = el-&gt;data;<br>            <span class="hljs-keyword">if</span> (mc-&gt;alias) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-20s %s (alias of %s)\n&quot;</span>, mc-&gt;alias, mc-&gt;desc, mc-&gt;name);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-20s %s%s%s\n&quot;</span>, mc-&gt;name, mc-&gt;desc,<br>                   mc-&gt;is_default ? <span class="hljs-string">&quot; (default)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>                   mc-&gt;deprecation_reason ? <span class="hljs-string">&quot; (deprecated)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    mc = find_machine(name, machines);<br>    <span class="hljs-keyword">if</span> (!mc) &#123;<br>        error_report(<span class="hljs-string">&quot;unsupported machine type&quot;</span>);<br>        error_printf(<span class="hljs-string">&quot;Use -machine help to list supported machines\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mc;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>object_class_get_list</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">GSList *<span class="hljs-title">object_class_get_list</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *implements_type,<span class="hljs-keyword">bool</span> include_abstract)</span></span><br><span class="hljs-function"></span>&#123;<br>    GSList *<span class="hljs-built_in">list</span> = <span class="hljs-literal">NULL</span>;<br>    object_class_foreach(object_class_get_list_tramp,<br>                         implements_type, include_abstract, &amp;<span class="hljs-built_in">list</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">object_class_foreach</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*fn)(ObjectClass *klass, <span class="hljs-keyword">void</span> *opaque),</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *implements_type, <span class="hljs-keyword">bool</span> include_abstract,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">void</span> *opaque)</span></span><br><span class="hljs-function"></span>&#123;<br>    OCFData data = &#123; fn, implements_type, include_abstract, opaque &#125;;<br><br>    enumerating_types = <span class="hljs-literal">true</span>;<br>    g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &amp;data);<br>    enumerating_types = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在全局表 <code>type_table_get()</code> 中，对于每一项 <code>TypeImpl</code>，我们都执行 <code>object_class_foreach_tramp</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">object_class_foreach_tramp</span><span class="hljs-params">(gpointer key, gpointer value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       gpointer opaque)</span></span><br><span class="hljs-function"></span>&#123;<br>    OCFData *data = opaque;<br>    TypeImpl *type = value;<br>    ObjectClass *k;<br>    type_initialize(type);<br>    k = type-&gt;class;<br>    <span class="hljs-keyword">if</span> (!data-&gt;include_abstract &amp;&amp; type-&gt;abstract) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (data-&gt;implements_type &amp;&amp; <br>        !object_class_dynamic_cast(k, data-&gt;implements_type)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    data-&gt;fn(k, data-&gt;opaque);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>object_class_foreach_tramp</code> 中，会调用将 <code>type_initialize</code>，这里面会调用 <code>class_init</code> 将纸面上的 <code>class</code> 也即 <code>TypeImpl</code> 变为 <code>ObjectClass</code>，<code>ObjectClass</code> 是所有<code> Class</code> 类的祖先，<code>MachineClass</code> 是它的子类。</p><p>因为在 <code>machine</code> 的命令行里面，我们指定了名字为<code>spike</code>，就肯定能够找到我们注册过了的 <code>TypeImpl</code>，并调用它的 <code>class_init</code> 函数。</p><p>所以，当 <code>select_machine</code> 执行完毕后，就有一个 <code>MachineClass</code> 了。</p><p>接着，我们回到 <code>qemu_create_machine</code> 中的<code>object_new_with_class</code>。这就很好理解了，<code>MachineClass</code> 是一个 <code>Class</code> 类，接下来应该通过它生成一个 <code>Instance</code>，也即对象，这就是 <code>object_new_with_class</code> 的作用。</p><p><code>object_new_with_class</code> 中，<code>TypeImpl</code> 的 <code>instance_init</code> 会被调用，创建一个对象。<code>current_machine</code> 就是这个对象，它的类型是<code> MachineState</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">Object *<span class="hljs-title">object_new_with_class</span><span class="hljs-params">(ObjectClass *klass)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> object_new_with_type(klass-&gt;type);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> Object *<span class="hljs-title">object_new_with_type</span><span class="hljs-params">(Type type)</span></span><br><span class="hljs-function"></span>&#123;<br>    Object *obj;<br>    type_initialize(type);<br>    obj = g_malloc(type-&gt;instance_size);<br>    object_initialize_with_type(obj, type-&gt;instance_size, type);<br>    obj-&gt;<span class="hljs-built_in">free</span> = g_free;<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，绕了这么大一圈，有关体系结构的对象才创建完毕，接下来很多的设备的初始化，包括 CPU 和内存的初始化，都是围绕着体系结构的对象来的，后面我们会常常看到<code> current_machine</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220308180036.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/nm90/p/15661202.html">Qemu CPU虚拟化 - 人生一世，草木一秋。 - 博客园</a><br><a href="https://www.cnblogs.com/LoyenWang/p/13796537.html">【原创】Linux虚拟化KVM-Qemu分析（四）之CPU虚拟化（2） - LoyenWang - 博客园</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>QEMU源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt文件系统</title>
    <link href="/2021/08/31/Qt%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/31/Qt%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>Qt 通过<code>QIODevice</code>提供了对 <code>I/O</code> 设备的抽象，这些设备具有读写字节块的能力。下面是 <code>I/O</code> 设备的类图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210831200940.png"></p><p>图中所涉及的类及其用途简要说明如下：</p><p><code>QIODevice</code>：所有<code>I/O</code>设备类的父类，提供了字节块读写的通用操作以及基本接口；<br><code>QFlie</code>：访问本地文件或者嵌入资源；<br><code>QTemporaryFile</code>：创建和访问本地文件系统的临时文件；<br><code>QBuffer</code>：读写<code>QByteArray</code>；<br><code>QProcess</code>：运行外部程序，处理进程间通讯；<br><code>QAbstractSocket</code>：所有套接字类的父类；<br><code>QTcpSocket</code>：<code>TCP</code>协议网络数据传输；<br><code>QUdpSocket</code>：传输 <code>UDP</code> 报文；<br><code>QSslSocket</code>：使用 <code>SSL/TLS</code> 传输数据；<br><code>QFileDevice</code>：Qt5新增加的类，提供了有关文件操作的通用实现。</p><h2 id="QFile及其相关类"><a href="#QFile及其相关类" class="headerlink" title="QFile及其相关类"></a>QFile及其相关类</h2><p>我们通常会将文件路径作为参数传给<code>QFile</code>的构造函数。不过也可以在创建好对象最后，使用<code>setFileName()</code>来修改。<code>QFile</code>需要使用<code>/</code>作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如<code>C:/windows</code>这样的路径在 Windows 平台下同样是可以的。</p><p><code>QFile</code>主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。我们可以使用<code>QDataStream</code>或<code>QTextStream</code>类来读写文件，也可以使用<code>QIODevice</code>类提供的<code>read()</code>、<code>readLine()</code>、<code>readAll()</code>以及<code>write()</code>这样的函数。值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过<code>QFileInfo</code>获取，而不是自己分析文件路径字符串。</p><p>在这段代码中，我们首先使用<code>QFile</code>创建了一个文件对象。这个文件名字是 <code>test.txt</code>。只要将这个文件放在同执行路径一致的目录下即可。可以使用<code>QDir::currentPath()</code>来获得应用程序执行时的当前路径。只要将这个文件放在与当前路径一致的目录下即可。然后，我们使用<code>open()</code>函数打开这个文件，打开形式是只读方式，文本格式。这个类似于<code>fopen()</code>的 <code>r</code> 这样的参数。<code>open()</code>函数返回一个 <code>bool</code> 类型，如果打开失败，我们在控制台输出一段提示然后程序退出。否则，我们利用 <code>while</code> 循环，将每一行读到的内容输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QWidget&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDebug&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QFile&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QFileInfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;test.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text))<br>    &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Open file failed.&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (!file.<span class="hljs-built_in">atEnd</span>())<br>        &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; file.<span class="hljs-built_in">readLine</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">QFileInfo <span class="hljs-title">info</span><span class="hljs-params">(file)</span></span>;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">isDir</span>();            <span class="hljs-comment">//false</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">isExecutable</span>();     <span class="hljs-comment">//false</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">baseName</span>();         <span class="hljs-comment">//test</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">completeBaseName</span>(); <span class="hljs-comment">//test.txt</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">suffix</span>();           <span class="hljs-comment">//txt</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">completeSuffix</span>();   <span class="hljs-comment">//txt</span><br><br>    <span class="hljs-function">QFileInfo <span class="hljs-title">fi</span><span class="hljs-params">(<span class="hljs-string">&quot;/tmp/archive.tar.gz&quot;</span>)</span></span>;<br>    QString base = fi.<span class="hljs-built_in">baseName</span>();          <span class="hljs-comment">// base = &quot;archive&quot;</span><br>    QString cbase = fi.<span class="hljs-built_in">completeBaseName</span>(); <span class="hljs-comment">// base = &quot;archive.tar&quot;</span><br>    QString ext = fi.<span class="hljs-built_in">suffix</span>();             <span class="hljs-comment">// ext = &quot;gz&quot;</span><br>    QString ext = fi.<span class="hljs-built_in">completeSuffix</span>();     <span class="hljs-comment">// ext = &quot;tar.gz&quot;</span><br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h2><p>本节，我们将学习<code>QDataStream</code>的使用以及一些技巧。</p><p><code>QDataStream</code>提供了基于<code>QIODevice</code>的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、CPU 或者字节顺序（大端或小端）。例如，在安装了 Windows 平台的 PC 上面写入的一个数据流，可以不经过任何处理，直接拿到运行了 Solaris 的 SPARC 机器上读取。由于数据流就是二进制流，因此我们也可以直接读写没有编码的二进制数据，例如图像、视频、音频等。</p><p><code>QDataStream</code>既能够存取 <code>C++</code> 基本类型，如 <code>int</code>、<code>char</code>、<code>short</code> 等，也可以存取复杂的数据类型，例如自定义的类。实际上，<code>QDataStream</code>对于类的存储，是将复杂的类分割为很多基本单元实现的。</p><p>结合<code>QIODevice</code>，<code>QDataStream</code>可以很方便地对文件、网络套接字等进行读写操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<br><span class="hljs-function">QDataStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;file)</span></span>;<br>out &lt;&lt; <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;the answer is&quot;</span>);<br>out &lt;&lt; (qint32)<span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure><p>在这段代码中，我们首先打开一个名为 file.dat 的文件（注意，我们为简单起见，并没有检查文件打开是否成功，这在正式程序中是不允许的）。然后，我们将刚刚创建的<code>file</code>对象的指针传递给一个<code>QDataStream</code>实例<code>out</code>。类似于<code>std::cout</code>标准输出流，<code>QDataStream</code>也重载了输出重定向&lt;&lt;运算符。后面的代码就很简单了：将<code>“the answer is”</code>和数字<code>42</code>输出到数据流（如果你不明白这句话的意思，这可是宇宙终极问题的答案，请自行搜索《银河系漫游指南》）。由于我们的 <code>out</code> 对象建立在<code>file</code>之上，因此相当于将宇宙终极问题的答案写入<code>file</code>。</p><p>需要指出一点：最好使用<code>Qt</code>整型来进行读写，比如程序中的<code>qint32</code>。这保证了在任意平台和任意编译器都能够有相同的行为。</p><p>我们通过一个例子来看看 <code>Qt</code> 是如何存储数据的。例如<code>char *</code>字符串，在存储时，会首先存储该字符串包括<code>\0</code>结束符的长度（32位整型），然后是字符串的内容以及结束符<code> \0</code>。在读取时，先以<code>32</code>位整型读出整个的长度，然后按照这个长度取出整个字符串的内容。</p><p>但是，如果你直接运行这段代码，你会得到一个空白的 <code>file.dat</code>，并没有写入任何数据。这是因为我们的<code>file</code>没有正常关闭。为性能起见，数据只有在文件关闭时才会真正写入。因此，我们必须在最后添加一行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">file.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 如果不想关闭文件，可以使用 file.flush();</span><br></code></pre></td></tr></table></figure><p>重新运行一下程序，你就得到宇宙终极问题的答案了。</p><p>我们已经获得宇宙终极问题的答案了，下面，我们要将这个答案读取出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br><span class="hljs-function">QDataStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;<br>QString str;<br>qint32 a;<br>in &gt;&gt; str &gt;&gt; a;<br></code></pre></td></tr></table></figure><p>这段代码没什么好说的。唯一需要注意的是，你必须按照写入的顺序，将数据读取出来。也就是说，程序数据写入的顺序必须预先定义好。在这个例子中，我们首先写入字符串，然后写入数字，那么就首先读出来的就是字符串，然后才是数字。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。</p><p>由于二进制流是纯粹的字节数据，带来的问题是，如果程序不同版本之间按照不同的方式读取（前面说过，<code>Qt</code> 保证读写内容的一致，但是并不能保证不同 <code>Qt</code> 版本之间的一致），数据就会出现错误。因此，我们必须提供一种机制来确保不同版本之间的一致性。通常，我们会使用如下的代码写入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<br><span class="hljs-function">QDataStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;file)</span></span>;<br><br><span class="hljs-comment">// 写入魔术数字和版本</span><br>out &lt;&lt; (quint32)<span class="hljs-number">0xA0B0C0D0</span>;<br>out &lt;&lt; (qint32)<span class="hljs-number">123</span>;<br><br>out.<span class="hljs-built_in">setVersion</span>(QDataStream::Qt_4_0);<br><br><span class="hljs-comment">// 写入数据</span><br>out &lt;&lt; lots_of_interesting_data;<br></code></pre></td></tr></table></figure><p>所谓魔术数字，是二进制输出中经常使用的一种技术。二进制格式是人不可读的，并且通常具有相同的后缀名（比如 <code>dat</code> 之类），因此我们没有办法区分两个二进制文件哪个是合法的。所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性。在本例中，我们在文件最开始写入 <code>0xA0B0C0D0</code>，在读取的时候首先检查这个数字是不是 <code>0xA0B0C0D0</code>。如果不是的话，说明这个文件不是可识别格式，因此根本不需要去继续读取。一般二进制文件都会有这么一个魔术数字，例如 <code>Java</code> 的 <code>class</code> 文件的魔术数字就是 <code>0xCAFEBABE</code>，使用二进制查看器就可以查看。魔术数字是一个 <code>32</code> 位的无符号整型，因此我们使用<code>quint32</code>来得到一个平台无关的 <code>32</code> 位无符号整型。</p><p><code>out &lt;&lt; (qint32)123</code>是标识文件的版本。我们用魔术数字标识文件的类型，从而判断文件是不是合法的。但是，文件的不同版本之间也可能存在差异：我们可能在第一版保存整型，第二版可能保存字符串。为了标识不同的版本，我们只能将版本写入文件。比如，现在我们的版本是 <code>123</code>。</p><p><code>out.setVersion(QDataStream::Qt_4_0)</code>上面一句是文件的版本号，但是，<code>Qt </code>不同版本之间的读取方式可能也不一样。这样，我们就得指定<code> Qt</code> 按照哪个版本去读。这里，我们指定以<code>Qt 4.0</code> 格式去读取内容。</p><p>当我们这样写入文件之后，我们在读取的时候就需要增加一系列的判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br><span class="hljs-function">QDataStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;<br><br><span class="hljs-comment">// 检查魔术数字</span><br>quint32 magic;<br>in &gt;&gt; magic;<br><span class="hljs-keyword">if</span> (magic != <span class="hljs-number">0xA0B0C0D0</span>) <br>&#123;<br>    <span class="hljs-keyword">return</span> BAD_FILE_FORMAT;<br>&#125;<br><br><span class="hljs-comment">// 检查版本</span><br>qint32 version;<br>in &gt;&gt; version;<br><span class="hljs-keyword">if</span> (version &lt; <span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">return</span> BAD_FILE_TOO_OLD;<br>&#125;<br><span class="hljs-keyword">if</span> (version &gt; <span class="hljs-number">123</span>) &#123;<br>    <span class="hljs-keyword">return</span> BAD_FILE_TOO_NEW;<br>&#125;<br><br><span class="hljs-keyword">if</span> (version &lt;= <span class="hljs-number">110</span>) &#123;<br>    in.<span class="hljs-built_in">setVersion</span>(QDataStream::Qt_3_2);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    in.<span class="hljs-built_in">setVersion</span>(QDataStream::Qt_4_0);<br>&#125;<br><br><span class="hljs-comment">// 读取数据</span><br>in &gt;&gt; lots_of_interesting_data;<br><span class="hljs-keyword">if</span> (version &gt;= <span class="hljs-number">120</span>) &#123;<br>    in &gt;&gt; data_new_in_version_1_2;<br>&#125;<br>in &gt;&gt; other_interesting_data;<br></code></pre></td></tr></table></figure><p>我们通过下面一段代码看看什么是流的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;file.dat&quot;</span>)</span></span>;<br>file.<span class="hljs-built_in">open</span>(QIODevice::ReadWrite);<br><br><span class="hljs-function">QDataStream <span class="hljs-title">stream</span><span class="hljs-params">(&amp;file)</span></span>;<br>QString str = <span class="hljs-string">&quot;the answer is 42&quot;</span>;<br>QString strout;<br><br>stream &lt;&lt; str;<br>file.<span class="hljs-built_in">flush</span>();<br>stream &gt;&gt; strout;<br></code></pre></td></tr></table></figure><p>在这段代码中，我们首先向文件中写入数据，紧接着把数据读出来。有什么问题吗？运行之后你会发现，<code>strout</code>实际是空的。为什么没有读取出来？我们不是已经添加了<code>file.flush()</code>;语句吗？原因并不在于文件有没有写入，而是在于我们使用的是“流”。<strong>所谓流，就像水流一样，它的游标会随着输出向后移动</strong>。当使用<code>&lt;&lt;</code>操作符输出之后，流的游标已经到了最后，此时你再去读，当然什么也读不到了。所以你需要在输出之后重新把游标设置为<code>0</code>的位置才能够继续读取。具体代码片段如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stream &lt;&lt; str;<br>stream.<span class="hljs-built_in">device</span>()-&gt;<span class="hljs-built_in">seek</span>(<span class="hljs-number">0</span>);<br>stream &gt;&gt; strout;<br></code></pre></td></tr></table></figure><h2 id="文本文件读写"><a href="#文本文件读写" class="headerlink" title="文本文件读写"></a>文本文件读写</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作系统-虚拟化</title>
    <link href="/2021/08/31/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <url>/2021/08/31/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h4 id="QEMU工作原理"><a href="#QEMU工作原理" class="headerlink" title="QEMU工作原理"></a>QEMU工作原理</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721140349.png"></p><p>单纯使用 qemu，采用的是完全虚拟化的模式。qemu 向 Guest OS 模拟 CPU，也模拟其他的硬件，GuestOS 认为自己和硬件直接打交道，其实是同 qemu 模拟出来的硬件打交道，qemu 会将这些指令转译给真正的硬件。由于所有的指令都要从 qemu 里面过一手，因而性能就会比较差。</p><p>完全虚拟化是非常慢的，所以要使用硬件辅助虚拟化技术 Intel-VT，AMD-V，所以需要 CPU 硬件开启这个标志位，一般在 BIOS 里面设置。当确认开始了标志位之后，通过 KVM，GuestOS 的 CPU 指令不用经过 Qemu 转译，直接运行，大大提高了速度。所以，KVM 在内核里面需要有一个模块，来设置当前 CPU 是 Guest OS 在用，还是 Host OS 在用。</p><p>可以通过如下命令查看内核模块中是否有KVM</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lsmod <span class="hljs-string">| grep kvm</span><br></code></pre></td></tr></table></figure><p>KVM 内核模块通过 <code>/dev/kvm</code> 暴露接口，用户态程序可以通过 <code>ioctl</code>来访问这个接口。Qemu 将 KVM 整合进来，将有关 CPU 指令的部分交由内核模块来做，就是 qemu-kvm (qemu-system-XXX)。</p><p>qemu 和 kvm 整合之后，CPU 的性能问题解决了。另外 Qemu 还会模拟其他的硬件，如网络和硬盘。同样，全虚拟化的方式也会影响这些设备的性能。</p><p>于是，qemu 采取半虚拟化的方式，让 Guest OS 加载特殊的驱动来做这件事情。</p><p>例如，网络需要加载 <code>virtio_net</code>，存储需要加载 <code>virtio_blk</code>，Guest 需要安装这些半虚拟化驱动，GuestOS 知道自己是虚拟机，所以数据会直接发送给半虚拟化设备，经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。</p><h3 id="计算虚拟化之CPU"><a href="#计算虚拟化之CPU" class="headerlink" title="计算虚拟化之CPU"></a>计算虚拟化之CPU</h3><h3 id="计算虚拟化之内存"><a href="#计算虚拟化之内存" class="headerlink" title="计算虚拟化之内存"></a>计算虚拟化之内存</h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Linux操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作系统-进程管理</title>
    <link href="/2021/08/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//process.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">create_process</span> <span class="hljs-params">(<span class="hljs-keyword">char</span>* program, <span class="hljs-keyword">char</span>** arg_list)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">create_process</span> <span class="hljs-params">(<span class="hljs-keyword">char</span>* program, <span class="hljs-keyword">char</span>** arg_list)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> child_pid;<br>    child_pid = fork ();<br>    <span class="hljs-keyword">if</span> (child_pid != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> child_pid;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-built_in">execvp</span> (program, arg_list);<br>        <span class="hljs-built_in">abort</span> ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们创建的子程序运行了一个最最简单的命令 <code>ls</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//createprocess.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">create_process</span> <span class="hljs-params">(<span class="hljs-keyword">char</span>* program, <span class="hljs-keyword">char</span>** arg_list)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span>* arg_list[] = &#123;<br>        <span class="hljs-string">&quot;ls&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<br>        <span class="hljs-string">&quot;/etc/yum.repos.d/&quot;</span>,<br>        <span class="hljs-literal">NULL</span><br>    &#125;;<br>    <span class="hljs-built_in">create_process</span> (<span class="hljs-string">&quot;ls&quot;</span>, arg_list);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>CPU看不懂源码里的函数，命令，CPU只认二进制数据，所以源码需要翻译成<code>01</code>二进制数据，这个过程就是<strong>编译（Compile）</strong>的过程。</p><p>编译出的文件好比一个公司的项目执行计划书，你要把一个项目执行好，计划书得有章法，有一定格式。在Linux下，二进制程序也有这样的格式，叫<strong>ELF</strong>（Executeable and Linkable Format，可执行与可链接格式），这个格式可以根据编译的结果不同，分为不同的格式。</p><h3 id="ELF-可重定位文件"><a href="#ELF-可重定位文件" class="headerlink" title="ELF-可重定位文件"></a>ELF-可重定位文件</h3><p>下图展示了如何从源码到二进制文件的转化</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810085445.png"></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -<span class="hljs-keyword">c</span> -fPIC process.<span class="hljs-keyword">c</span><br>gcc -<span class="hljs-keyword">c</span> -fPIC createprocess.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p><code>-fPIC </code>作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)。产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。</p><p>在编译的时候，先做<strong>预处理</strong>工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为<code>.o </code>文件，这就是<code>ELF</code>的第一种类型，<strong>可重定位文件</strong>（Relocatable File）。文件格式如下，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810085520.png"></p><p><code>ELF</code> 文件的头是用于描述整个文件的。这个文件格式在内核中有定义，分别为 <code>struct elf32_hdr</code> 和 <code>struct elf64_hdr</code>。</p><table><thead><tr><th>section</th><th>内容</th></tr></thead><tbody><tr><td>.text</td><td>放编译好的二进制可执行代码</td></tr><tr><td>.data</td><td>已经初始化好的全局变量（临时变量放在栈里）</td></tr><tr><td>.rodata</td><td>只读数据，例如字符串常量、const 的变量</td></tr><tr><td>.bss</td><td>未初始化全局变量，运行时会置 0</td></tr><tr><td>.symtab</td><td>符号表，记录的则是函数和变量</td></tr><tr><td>.strtab</td><td>字符串表、字符串常量和变量名</td></tr></tbody></table><p>第一种ELF文件叫可重定位文件，为啥可重定位？我们可以想象一下，这个编译好的代码和变量，将来<strong>加载到内存</strong>里面的时候，都是要加载到一定位置的。比如说，调用一个函数，其实就是跳到这个函数所在的代码位置执行；再比如修改一个全局变量，也是要到变量的位置那里去修改。但是现在这个时候，还是<code>.o </code>文件，不是一个可以直接运行的程序，这里面只是部分代码片段。</p><p>例如这里的 <code>create_process </code>函数，将来被谁调用，在哪里调用都不清楚，就更别提确定位置了。所以，<code>.o </code>里面的位置是不确定的，但是必须是可重新定位的，因为它将来是要做函数库的嘛，就是一块砖，哪里需要哪里搬，搬到哪里就重新定位这些代码、变量的位置。</p><h4 id="ELF-可执行文件"><a href="#ELF-可执行文件" class="headerlink" title="ELF-可执行文件"></a>ELF-可执行文件</h4><p>要让<code>create_process</code>这个函数作为库文件重用，需要将其形成库文件，最简单的类型是静态链接库<code>.a</code>文件，它将一系列<code>.o</code>文件归档为一个文件。使用<code>ar</code>命令创建<code>.a</code>文件。<a href="">使用方法看这里</a>。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ar <span class="hljs-literal">cr</span> libstaticprocess.<span class="hljs-keyword">a</span> <span class="hljs-built_in">process</span>.o<br></code></pre></td></tr></table></figure><p>虽然这里 <code>libstaticprocess.a</code> 里面只有一个<code>.o</code>，但是实际情况可以有多个<code>.o</code>。当有程序要使用这个静态连接库的时候，会将.o 文件提取出来，链接到程序中。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">gcc</span> -o staticcreateprocess createprocess.o -L. -lstaticprocess<br></code></pre></td></tr></table></figure><p><code>-L </code>表示在当前目录下找<code>.a </code>文件，<code>-lstaticprocess</code> 会自动补全文件名，比如加前缀 <code>lib</code>，后缀<code>.a</code>，变成 <code>libstaticprocess.a</code>，找到这个<code>.a </code>文件后，将里面的 process.o 取出来，和 <code>createprocess.o</code> 做一个链接，形成二进制执行文件 <code>staticcreateprocess</code>。</p><p>在链接过程中，重定位就起作用了，在<code>createprocess.o</code>里调用了<code>create_process</code>函数，但是不能确定位置，现在将<code>process.o</code>合并进来，就知道位置了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810114727.png"></p><p>这个格式和<code>.o</code> 文件大致相似，还是分成一个个的 <code>section</code>，并且被节头表描述。只不过这些<code> section</code> 是多个<code>.o</code> 文件合并过的。但是这个时候，这个文件已经是马上就可以加载到内存里面执行的文件了，因而这些 <code>section</code> 被分成了需要加载到内存里面的<strong>代码段</strong>、<strong>数据段</strong>和<strong>不需要加载</strong>到内存里面的部分，将小的 <code>section</code> 合成了大的段 <code>segment</code>，并且在最前面加一个<strong>段头表</strong>（Segment Header Table）。</p><p>在代码里面的定义为 <code>struct elf32_phdr </code>和 <code>struct elf64_phdr</code>，这里面除了有对于段的描述之外，最重要的是 <code>p_vaddr</code>，这个是这个段加载到内存的虚拟地址。</p><p>在 <code>ELF</code> 头里面，有一项 <code>e_entry</code>，也是个虚拟地址，是这个<strong>程序运行的入口</strong>。</p><h4 id="ELF-共享对象文件"><a href="#ELF-共享对象文件" class="headerlink" title="ELF-共享对象文件"></a>ELF-共享对象文件</h4><p>静态库一旦被链接，代码和变量的<code>section</code>会被合并，所以运行时不依赖静态库文件，但是缺点就是，相同代码段被多个程序使用，在<strong>内存里会有多份</strong>，而且<strong>静态库更新需要重新编译</strong>。</p><p>因而就出现了另一种，<strong>动态链接库</strong>（Shared Libraries），不仅仅是一组对象文件的简单归档，而是多个对象文件的重新组合，可被多个程序共享。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">gcc -<span class="hljs-keyword">shared</span> -fPIC -o libdynamicprocess.so <span class="hljs-keyword">process</span>.o<br></code></pre></td></tr></table></figure><p>当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">gcc</span> -o dynamiccreateprocess createprocess.o -L. -ldynamicprocess<br></code></pre></td></tr></table></figure><p>当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在 <code>/lib</code> 和<code> /usr/lib</code> 文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定 <code>LD_LIBRARY_PATH </code>环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment"># export LD_LIBRARY_PATH=.</span><br><span class="hljs-comment"># ./dynamiccreateprocess</span><br><span class="hljs-comment"># total 40</span><br>-rw-r--r--.<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 1572 </span>Oct<span class="hljs-number"> 24 </span>18:38 CentOS-Base.repo<br>......<br></code></pre></td></tr></table></figure><p>动态链接库，就是<code>ELF</code>的第三种类型，<strong>共享对象文件</strong>（Shared Object）。</p><p>文件格式和上两种文件稍有不同，首先，多了一个<code>.interp </code>的 <code>Segment</code>，这里面是 <code>ld-linux.so</code>，这是动态链接器，也就是说，运行时的链接动作都是它做的。</p><p>另外，<code>ELF </code>文件中还多了两个<code> section</code>，一个是<code>.plt</code>，<strong>过程链接表</strong>（Procedure Linkage Table，PLT），一个是.<code>got.plt</code>，<strong>全局偏移量表</strong>（Global Offset Table，GOT）。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>在内核中，有<code>linux_binfmt elf_format </code>数据结构定义了加载ELF的方法，使用<code>load_elf_binary </code>加载二进制文件，该函数由<code>do_execve</code>调用，学过系统调用知道<code>exec</code>调用了<code>do_execve</code>函数。所以流程为</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">exec</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">do_execve</span>-&gt;</span>load_elf_binary<br></code></pre></td></tr></table></figure><h4 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h4><p>所有进程都是从父进程fork来的，祖宗进程就是<code>init</code> 进程。</p><p>系统启动之后，<code>init</code> 进程会启动很多的<code> daemon</code> 进程，为系统运行提供服务，然后就是启动 <code>getty</code>，让用户登录，登录后运行 <code>shell</code>，用户启动的进程都是通过 <code>shell </code>运行的，从而形成了一棵进程树。</p><p>我们可以通过 <code>ps -ef </code>命令查看当前系统启动的进程，我们会发现有三类进程。<code>PID 1</code> 的进程就是我们的<code>init</code>进程 <code>systemd</code>，<code>PID 2</code> 的进程是内核线程 <code>kthreadd</code>。</p><p>内核态进程的<code>PPID</code>祖先进程都是2号进程，用户态进程祖先进程都是1号进程，<code>tty</code>列是问号的，说明是后台服务进程。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810143343.png"></p><h2 id="进程数据结构"><a href="#进程数据结构" class="headerlink" title="进程数据结构"></a>进程数据结构</h2><p>在Linux里面，无论是进程还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构<code>task_struct</code>进行管理。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826183622.png"></p><p>每个任务应该包含的字段：</p><h3 id="任务ID"><a href="#任务ID" class="headerlink" title="任务ID"></a>任务ID</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">pid_t</span> pid; <span class="hljs-meta">#process id</span><br><span class="hljs-keyword">pid_t</span> tgid; <span class="hljs-meta">#thread group ID</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">group_leader</span>;</span> <br></code></pre></td></tr></table></figure><p>为何要有这么多ID，一个不够吗？</p><ul><li>可以方便任务展示，比如在命令行中ps显示所有进程，只显示<code>pid_t pid</code>，而不会把所有内部线程摊开展示，这样太碍眼。</li><li>方便下达命令，当我kill一个进程时，我们是对整个进程发送信号，但是有时候一些命令只需要对某个线程发送信号。</li><li></li></ul><h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Signal handlers: */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">signal_struct</span>    *<span class="hljs-title">signal</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sighand_struct</span>    *<span class="hljs-title">sighand</span>;</span><br><span class="hljs-keyword">sigset_t</span>      blocked;<br><span class="hljs-keyword">sigset_t</span>      real_blocked;<br><span class="hljs-keyword">sigset_t</span>      saved_sigmask;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigpending</span>    <span class="hljs-title">pending</span>;</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>      sas_ss_sp;<br><span class="hljs-keyword">size_t</span>        sas_ss_size;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>      sas_ss_flags;<br></code></pre></td></tr></table></figure><p>这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。</p><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> state;    <span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><br><span class="hljs-keyword">int</span> exit_state;<br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags;<br><br></code></pre></td></tr></table></figure><p><code>state</code>可取值定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Used in tsk-&gt;state: */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_RUNNING                    0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_INTERRUPTIBLE              1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_UNINTERRUPTIBLE            2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __TASK_STOPPED                  4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __TASK_TRACED                   8</span><br><span class="hljs-comment">/* Used in tsk-&gt;exit_state: */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXIT_DEAD                       16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXIT_ZOMBIE                     32</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXIT_TRACE                      (EXIT_ZOMBIE | EXIT_DEAD)</span><br><span class="hljs-comment">/* Used in tsk-&gt;state again: */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_DEAD                       64</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_WAKEKILL                   128</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_WAKING                     256</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_PARKED                     512</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_NOLOAD                     1024</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_NEW                        2048</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TASK_STATE_MAX                  4096</span><br></code></pre></td></tr></table></figure><p>可以发现Linux通过bitset方式设置状态，当前什么状态，哪一位就置1。</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>进程的状态切换往往涉及调度，下面这些字段都是用于调度的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 是否在运行队列上</span><br><span class="hljs-keyword">int</span>               on_rq;<br><span class="hljs-comment">// 优先级</span><br><span class="hljs-keyword">int</span>               prio;<br><span class="hljs-keyword">int</span>               static_prio;<br><span class="hljs-keyword">int</span>               normal_prio;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>      rt_priority;<br><span class="hljs-comment">// 调度器类</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span>  *<span class="hljs-title">sched_class</span>;</span><br><span class="hljs-comment">// 调度实体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span>       <span class="hljs-title">se</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_rt_entity</span>    <span class="hljs-title">rt</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_dl_entity</span>    <span class="hljs-title">dl</span>;</span><br><span class="hljs-comment">// 调度策略</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>      policy;<br><span class="hljs-comment">// 可以使用哪些 CPU</span><br><span class="hljs-keyword">int</span>            nr_cpus_allowed;<br><span class="hljs-keyword">cpumask_t</span>      cpus_allowed;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_info</span>    <span class="hljs-title">sched_info</span>;</span><br></code></pre></td></tr></table></figure><h3 id="运行统计信息"><a href="#运行统计信息" class="headerlink" title="运行统计信息"></a>运行统计信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">u64        utime;<span class="hljs-comment">// 用户态消耗的 CPU 时间</span><br>u64        stime;<span class="hljs-comment">// 内核态消耗的 CPU 时间</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>      nvcsw;<span class="hljs-comment">// 自愿 (voluntary) 上下文切换计数</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>      nivcsw;<span class="hljs-comment">// 非自愿 (involuntary) 上下文切换计数</span><br>u64        start_time;<span class="hljs-comment">// 进程启动时间，不包含睡眠时间</span><br>u64        real_start_time;<span class="hljs-comment">// 进程启动时间，包含睡眠时间</span><br></code></pre></td></tr></table></figure><h3 id="进程亲缘关系"><a href="#进程亲缘关系" class="headerlink" title="进程亲缘关系"></a>进程亲缘关系</h3><p>进程有棵进程树，所以有亲缘关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">real_parent</span>;</span> <span class="hljs-comment">/* real parent process */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">parent</span>;</span> <span class="hljs-comment">/* recipient of SIGCHLD, wait4() reports */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">children</span>;</span>      <span class="hljs-comment">/* list of my children */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">sibling</span>;</span>       <span class="hljs-comment">/* linkage in my parent&#x27;s children list */</span><br></code></pre></td></tr></table></figure><p>通常情况下，<code>real_parent</code> 和 <code>parent</code> 是一样的，但是也会有另外的情况存在。例如，<code>bash</code> 创建一个进程，那进程的 parent 和 <code>real_parent</code> 就都是 <code>bash</code>。如果在 bash 上使用 <code>GDB</code> 来 <code>debug</code> 一个进程，这个时候 <code>GDB</code> 是 <code>real_parent</code>，<code>bash</code> 是这个进程的 <code>parent</code>。</p><h3 id="进程权限"><a href="#进程权限" class="headerlink" title="进程权限"></a>进程权限</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Objective and real subjective task credentials (COW): */</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>         *<span class="hljs-title">real_cred</span>;</span><br><span class="hljs-comment">/* Effective (overridable) subjective task credentials (COW): */</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>   </span><br></code></pre></td></tr></table></figure><p><code>real_cred</code> 就是说明谁能操作我这个进程，而 <code>cred</code> 就是说明我这个进程能够操作谁。</p><p>总结到一起，<code>task_struct</code>结构图如下，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826190834.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Linux操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
      <tag>进程管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPPLAB-Bomb Lab</title>
    <link href="/2021/08/29/CSAPP-LAB-Bomb%20Lab/"/>
    <url>/2021/08/29/CSAPP-LAB-Bomb%20Lab/</url>
    
    <content type="html"><![CDATA[<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="缩写注释"><a href="#缩写注释" class="headerlink" title="缩写注释"></a>缩写注释</h3><p>CSAPP：Computer Systems A Programmer’s Perspective（深入理解计算机操作系统）。CSAPP（C：P166，O：P278）表示书本的中文版第166页，英文原版第278页。</p><h3 id="寄存器信息"><a href="#寄存器信息" class="headerlink" title="寄存器信息"></a>寄存器信息</h3><p>了解寄存器的基本用途，看到一个汇编代码，可以大概了解这个寄存器是在栈中使用的，还是保存参数的，是调用者保存，还是被调用者保存。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830160500.png"></p><div STYLE="page-break-after: always;"></div><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>调试过程用到的GDB命令可以先参考<a href="https://dunky-z.github.io/2021/08/29/GDB%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/">GDB调试入门</a>这篇文章。文中所用例子也是摘自与BombLab的源码，更容易理解如何使用。还有一定比较重要的是，如何使用gdb带参数调试。为了不用每次运行<code>bomb</code>程序都需要重新输入答案，<code>bomb</code>程序可以读取文本信息，在文本文件中写入答案即可免去手动输入。</p><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>拆弹专家已上线，开干！！！！！！！！！！！！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;"><br>(gdb) b phase_1<br>(gdb) b explode_bomb<br>(gdb) disas phase_1<br>Dump of assembler code for function phase_1:&#x27;<br>   0x0000000000400ee0 &lt;+0&gt;:sub    $0x8,%rsp<br>   0x0000000000400ee4 &lt;+4&gt;:mov    $0x402400,%esi<br>   0x0000000000400ee9 &lt;+9&gt;:callq  0x401338 &lt;strings_not_equal&gt;<br>   0x0000000000400eee &lt;+14&gt;:test   %eax,%eax<br>   0x0000000000400ef0 &lt;+16&gt;:je     0x400ef7 &lt;phase_1+23&gt;<br>   0x0000000000400ef2 &lt;+18&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400ef7 &lt;+23&gt;:add    $0x8,%rsp<br>   0x0000000000400efb &lt;+27&gt;:retq   <br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li>3：将栈指针<code>rsp</code>减去8个字节，也就是申请8个字节的栈空间</li><li>4：将一个立即数存到寄存器<code>esi</code>中</li><li>5：调用函数<code>strings_not_equal</code>，该函数第一条语句的地址为<code>0x401338</code>。<code>callq</code>指令的执行过程可参考书本CSAPP（C：P166，O：P278）</li><li>6：使用<code>test</code>命令（同<code>and</code>命令，不修改目标对象的值）来测试<code>eax</code>中的值是否为<code>0</code>，如果为<code>0</code>则跳过引爆炸弹的函数</li><li>7：这一句和上一句是一个整体，如果<code>eax==0</code>,就跳转到<code>0x400ef7</code>，这个地址也就是第9行的地址，成功跳过了引爆炸弹函数。意思就是我们输入的某个字符串成功匹配，也就是<code>strings_not_equal</code>函数返回值为0。</li><li>8：调用函数<code>explode_bomb</code>，引爆炸弹</li><li>9：将栈指针<code>rsp</code>加上8个字节，也就是恢复8个字节的栈空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) disas strings_not_equal <br>Dump of assembler code for function strings_not_equal:<br>=&gt; 0x0000000000401338 &lt;+0&gt;:push   %r12<br>   0x000000000040133a &lt;+2&gt;:push   %rbp<br>   0x000000000040133b &lt;+3&gt;:push   %rbx<br>   0x000000000040133c &lt;+4&gt;:mov    %rdi,%rbx<br>   0x000000000040133f &lt;+7&gt;:mov    %rsi,%rbp<br>   0x0000000000401342 &lt;+10&gt;:callq  0x40131b &lt;string_length&gt;<br>   0x0000000000401347 &lt;+15&gt;:mov    %eax,%r12d<br>   0x000000000040134a &lt;+18&gt;:mov    %rbp,%rdi<br>   0x000000000040134d &lt;+21&gt;:callq  0x40131b &lt;string_length&gt;<br>   0x0000000000401352 &lt;+26&gt;:mov    $0x1,%edx<br>   0x0000000000401357 &lt;+31&gt;:cmp    %eax,%r12d<br>   0x000000000040135a &lt;+34&gt;:jne    0x40139b &lt;strings_not_equal+99&gt;<br>   0x000000000040135c &lt;+36&gt;:movzbl (%rbx),%eax<br>   0x000000000040135f &lt;+39&gt;:test   %al,%al<br>   0x0000000000401361 &lt;+41&gt;:je     0x401388 &lt;strings_not_equal+80&gt;<br>   0x0000000000401363 &lt;+43&gt;:cmp    0x0(%rbp),%al<br>   0x0000000000401366 &lt;+46&gt;:je     0x401372 &lt;strings_not_equal+58&gt;<br>   0x0000000000401368 &lt;+48&gt;:jmp    0x40138f &lt;strings_not_equal+87&gt;<br>   0x000000000040136a &lt;+50&gt;:cmp    0x0(%rbp),%al<br>   0x000000000040136d &lt;+53&gt;:nopl   (%rax)<br>   0x0000000000401370 &lt;+56&gt;:jne    0x401396 &lt;strings_not_equal+94&gt;<br>   0x0000000000401372 &lt;+58&gt;:add    $0x1,%rbx<br>   0x0000000000401376 &lt;+62&gt;:add    $0x1,%rbp<br>   0x000000000040137a &lt;+66&gt;:movzbl (%rbx),%eax<br>   0x000000000040137d &lt;+69&gt;:test   %al,%al<br>   0x000000000040137f &lt;+71&gt;:jne    0x40136a &lt;strings_not_equal+50&gt;<br>   0x0000000000401381 &lt;+73&gt;:mov    $0x0,%edx<br>   0x0000000000401386 &lt;+78&gt;:jmp    0x40139b &lt;strings_not_equal+99&gt;<br>   0x0000000000401388 &lt;+80&gt;:mov    $0x0,%edx<br>   0x000000000040138d &lt;+85&gt;:jmp    0x40139b &lt;strings_not_equal+99&gt;<br>   0x000000000040138f &lt;+87&gt;:mov    $0x1,%edx<br>   0x0000000000401394 &lt;+92&gt;:jmp    0x40139b &lt;strings_not_equal+99&gt;<br>   0x0000000000401396 &lt;+94&gt;:mov    $0x1,%edx<br>   0x000000000040139b &lt;+99&gt;:mov    %edx,%eax<br>   0x000000000040139d &lt;+101&gt;:pop    %rbx<br>   0x000000000040139e &lt;+102&gt;:pop    %rbp<br>   0x000000000040139f &lt;+103&gt;:pop    %r12<br>   0x00000000004013a1 &lt;+105&gt;:retq   <br>End of assembler dump.<br>       <br></code></pre></td></tr></table></figure><ul><li>3-5：在函数调用时先保存相关寄存器值，<code>rbp</code>和<code>rbx</code>就是用来保存两个参数的寄存器</li><li>6：将寄存器<code>rdi</code>的值复制到寄存器<code>rbp</code></li><li>7：将寄存器<code>rsi</code>的值复制到寄存器<code>rbx</code></li></ul><p>其实看到这里就一直能够猜到答案是什么了。我们通过之前的<code>phase_1</code>函数能够大概知道需要输入一个值进行比较，如果比较正确就能解除炸弹。现在我们又进入到了这个比较函数，比较函数有两个参数，分别保存在两个寄存器里。我们正常的思维如果写一个比较函数，肯定一个参数是我们输入的值，一个参数是正确的值。</p><p>这里看到了<code>rsi</code>寄存器，我们还记得在<code>phase_1</code>函数中第4行的<code>esi</code>寄存器吗？这两个寄存器是同一个寄存器，只不过<code>esi</code>是寄存器的低32位，既然<code>esi</code>已经赋值了，那剩下的一个参数保存我们输入的内容。所以<code>esi</code>内存的内容就是我们需要的正确答案。我们只要把寄存器<code>esi</code>中的值打印出来，或者内存地址为<code>0x402400</code>的内容打印出来即可。可以通过以下三条命令查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) p (char*)($esi)<br>$5 = 0x402400 &quot;Border relations with Canada have never been better.&quot;<br>(gdb) x/s 0x402400<br>0x402400:&quot;Border relations with Canada have never been better.&quot;<br>(gdb) x/s $esi<br>0x402400:&quot;Border relations with Canada have never been better.&quot;<br></code></pre></td></tr></table></figure><p>将答案复制，然后继续运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">The program being debugged has been started already.<br>Start it from the beginning? (y or n) y<br>Starting program: /home/dominic/learning-linux/bomb/bomb <br>Welcome to my fiendish little bomb. You have 6 phases with<br>which to blow yourself up. Have a nice day!<br>Border relations with Canada have never been better.<br><br>Breakpoint 2, 0x0000000000400ee0 in phase_1 ()<br>(gdb) s<br>Single stepping until exit from function phase_1,<br>which has no line number information.<br>main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at bomb.c:75<br>75    phase_defused();                 /* Drat!  They figured it out!<br>(gdb) s<br>77    printf(&quot;Phase 1 defused. How about the next one?\n&quot;);<br></code></pre></td></tr></table></figure><p>从13行<code>phase_defused()</code>可以知道我们已经解除了炸弹，从15行<code>printf</code>函数也可以看到，需要进行下一个炸弹的拆除。过来人的建议，在这里就开始分析<code>phase_2</code>，寻找答案，因为继续执行就要开始输入内容了，将无法调试。</p><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>继续分析第二个炸弹，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) disas phase_2<br>Dump of assembler code for function phase_2:<br>   0x0000000000400efc &lt;+0&gt;:push   %rbp<br>   0x0000000000400efd &lt;+1&gt;:push   %rbx<br>   0x0000000000400efe &lt;+2&gt;:sub    $0x28,%rsp<br>   0x0000000000400f02 &lt;+6&gt;:mov    %rsp,%rsi<br>   0x0000000000400f05 &lt;+9&gt;:callq  0x40145c &lt;read_six_numbers&gt;<br>   0x0000000000400f0a &lt;+14&gt;:cmpl   $0x1,(%rsp)<br>   0x0000000000400f0e &lt;+18&gt;:je     0x400f30 &lt;phase_2+52&gt;<br>   0x0000000000400f10 &lt;+20&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f15 &lt;+25&gt;:jmp    0x400f30 &lt;phase_2+52&gt;<br>   0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax<br>   0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax<br>   0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)<br>   0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;<br>   0x0000000000400f20 &lt;+36&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx<br>   0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx<br>   0x0000000000400f2c &lt;+48&gt;:jne    0x400f17 &lt;phase_2+27&gt;<br>   0x0000000000400f2e &lt;+50&gt;:jmp    0x400f3c &lt;phase_2+64&gt;<br>   0x0000000000400f30 &lt;+52&gt;:lea    0x4(%rsp),%rbx<br>   0x0000000000400f35 &lt;+57&gt;:lea    0x18(%rsp),%rbp<br>   0x0000000000400f3a &lt;+62&gt;:jmp    0x400f17 &lt;phase_2+27&gt;<br>   0x0000000000400f3c &lt;+64&gt;:add    $0x28,%rsp<br>   0x0000000000400f40 &lt;+68&gt;:pop    %rbx<br>   0x0000000000400f41 &lt;+69&gt;:pop    %rbp<br>   0x0000000000400f42 &lt;+70&gt;:retq   <br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li>3-6：保存程序入口地址，变量等内容，就不再赘述了</li><li>7: 调用<code>read_six_numbers</code>函数，根据函数名我们可以猜测这个函数需要读入六个数字</li><li>8-9：比较寄存器<code>rsp</code>存的第一个数字是否等于<code>0x1</code>，如果等于就跳转到<code>phase_2+52</code>处继续执行，如果不等于就执行<code>explode_bomb</code>。栈中保存了六个输入的数字，保存顺序是从右往左，假如输入<code>1,2,3,4,5,6</code>。那么入栈的顺序就是<code>6,5,4,3,2,1</code>，寄存器<code>rsp</code>指向栈顶，也就是数字<code>1</code>的地址。</li><li>21:假设第一个数字正确，我们跳转到<code>&lt;+52&gt;</code>位置，也就是第21行，将<code>rsp+0x4</code>写入寄存器<code>rbx</code>，栈指针向上移动四个字节，也就是取第二个输入的参数，将它赋给寄存器<code>rbx</code></li><li>22：将<code>rsp+0x18</code>写入寄存器<code>rbp</code>，十六进制<code>0x18=24</code>，4个字节一个数，刚好6个数，就是将输入参数的最后一个位置赋给寄存器<code>rbp</code></li><li>23：跳到<code>phase_2+27</code>继续执行</li><li>12：<code>rbx-0x4</code>赋给寄存器<code>eax</code>。第21行我们知道，<code>rbx</code>此时已经到第二个参数了，这一句就是说把第一个参数的值写入寄存器<code>eax</code></li><li>13：将<code>eax</code>翻一倍，第8行知道第一个参数值为<code>1</code>，所以此时<code>eax</code>值为<code>2</code></li><li>14-15：比较<code>eax</code>是否等于<code>rbx</code>。<code>rbx</code>此时保存的是第二个参数，这里也就是比较第二个参数是否等于<code>2</code>。如果等于跳转到<code>phase_2+41</code>位置，如果不等于就调用爆炸函数</li><li>17-18：假设第二个参数就是2，我们跳过了炸弹来到第17行，将<code>rbx</code>继续上移，然后比较<code>rbp</code>是否等于<code>rbx</code>，我们知道<code>rbp</code>保存了最后一个参数的地址，所以这里的意思就是看看参数有没有到最后一个参数。</li><li>19：如果<code>rbx&lt;rbp</code>，意思就是还没到最后一个参数，就跳转到<code>phase_2+27</code></li><li>12：再次回到第12行，这里就是相当于一个循环了，让<code>rbx</code>一直向上移动，分别存入第2，3，4，5，6个参数，在移动到下一个参数时先保存当前参数到寄存器<code>eax</code>让其翻一倍，然后<code>rbx</code>再移动到下一个参数，比较<code>eax==rbx</code>。直到<code>rbx</code>越过了<code>rbp</code>。程序跳转到<code>phase_2+64</code>，将栈空间恢复。</li></ul><p>以上分析也可以得出答案了，我们只要输入一个以<code>1</code>为初值，公比为<code>2</code>，个数为<code>6</code>的等比数列就是答案，也就是<code>1 2 4 8 16 32</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell&#123;.line-numbers&#125;">(gdb) c<br>Continuing.<br>Phase 1 defused. How about the next one?<br>1 2 4 8 16 32<br><br>Breakpoint 6, 0x00000000004015c4 in phase_defused ()<br>(gdb) s<br>Single stepping until exit from function phase_defused,<br>which has no line number information.<br>main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at bomb.c:84<br>84    printf(&quot;That&#x27;s number 2.  Keep going!\n&quot;);<br>(gdb) s<br></code></pre></td></tr></table></figure><p>这个炸弹的作者应该再心狠手辣一点，把函数名换成<code>read_some_numbers</code>，这样我们就不得不看这个函数的内容了，因为这个函数里还有一个坑，这个坑在函数名字上一句被填了。那就是这个函数会对参数个数做判断，如果小于5就爆炸。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) disas read_six_numbers<br>Dump of assembler code for function read_six_numbers:<br>   0x000000000040145c &lt;+0&gt;:sub    $0x18,%rsp<br>   0x0000000000401460 &lt;+4&gt;:mov    %rsi,%rdx<br>   0x0000000000401463 &lt;+7&gt;:lea    0x4(%rsi),%rcx<br>   0x0000000000401467 &lt;+11&gt;:lea    0x14(%rsi),%rax<br>   0x000000000040146b &lt;+15&gt;:mov    %rax,0x8(%rsp)<br>   0x0000000000401470 &lt;+20&gt;:lea    0x10(%rsi),%rax<br>   0x0000000000401474 &lt;+24&gt;:mov    %rax,(%rsp)<br>   0x0000000000401478 &lt;+28&gt;:lea    0xc(%rsi),%r9<br>   0x000000000040147c &lt;+32&gt;:lea    0x8(%rsi),%r8<br>   0x0000000000401480 &lt;+36&gt;:mov    $0x4025c3,%esi<br>   0x0000000000401485 &lt;+41&gt;:mov    $0x0,%eax<br>   0x000000000040148a &lt;+46&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>   0x000000000040148f &lt;+51&gt;:cmp    $0x5,%eax<br>   0x0000000000401492 &lt;+54&gt;:jg     0x401499 &lt;read_six_numbers+61&gt;<br>   0x0000000000401494 &lt;+56&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000401499 &lt;+61&gt;:add    $0x18,%rsp<br>   0x000000000040149d &lt;+65&gt;:retq   <br>End of assembler dump.<br></code></pre></td></tr></table></figure><ul><li>3：申请24个字节栈空间</li><li>4：<code>rdx=rsi</code>，将输入参数的第一个参数放到寄存器<code>rdx</code>中，为啥是第一个参数，因为<code>rsi</code>现在保存的地址是栈顶位置，栈顶目前保存就是第一个参数。</li><li>5：<code>rcx = rsi + 4</code>，把第二个参数的地址传给寄存器<code>rcx</code></li><li>6：<code>rax = rsi + 20</code>，把第六个参数的地址传给寄存器<code>rax</code></li><li>7：<code>rsp + 8 = rax</code>第八个参数</li><li>8：<code>rax = rsi + 16</code>，把第五个参数传给</li><li>9：<code>rsp = rax</code>第七个参数</li><li>10：<code>r9 = rsi + 12</code>把第四个参数传给寄存器<code>r9</code></li><li>11：<code>r8 = rsi + 8</code>把第三个参数传给寄存器<code>r8</code></li><li>12：</li><li>13：<code>eax = 0</code></li><li>14：调用输入函数<code>sscanf</code></li><li>15-17：函数返回值个数与5比较，如果小于5就爆炸，否则返回<h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">0x0000000000400f43 &lt;+0&gt;:sub    $0x18,%rsp<br>0x0000000000400f47 &lt;+4&gt;:lea    0xc(%rsp),%rcx<br>0x0000000000400f4c &lt;+9&gt;:lea    0x8(%rsp),%rdx<br>0x0000000000400f51 &lt;+14&gt;:mov    $0x4025cf,%esi<br>0x0000000000400f56 &lt;+19&gt;:mov    $0x0,%eax<br>0x0000000000400f5b &lt;+24&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>0x0000000000400f60 &lt;+29&gt;:cmp    $0x1,%eax<br>0x0000000000400f63 &lt;+32&gt;:jg     0x400f6a &lt;phase_3+39&gt;<br>0x0000000000400f65 &lt;+34&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>0x0000000000400f6a &lt;+39&gt;:cmpl   $0x7,0x8(%rsp)<br>0x0000000000400f6f &lt;+44&gt;:ja     0x400fad &lt;phase_3+106&gt;<br>0x0000000000400f71 &lt;+46&gt;:mov    0x8(%rsp),%eax<br>0x0000000000400f75 &lt;+50&gt;:jmpq   *0x402470(,%rax,8)<br>0x0000000000400f7c &lt;+57&gt;:mov    $0xcf,%eax<br>0x0000000000400f81 &lt;+62&gt;:jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400f83 &lt;+64&gt;:mov    $0x2c3,%eax<br>0x0000000000400f88 &lt;+69&gt;:jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400f8a &lt;+71&gt;:mov    $0x100,%eax<br>0x0000000000400f8f &lt;+76&gt;:jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400f91 &lt;+78&gt;:mov    $0x185,%eax<br>0x0000000000400f96 &lt;+83&gt;:jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400f98 &lt;+85&gt;:mov    $0xce,%eax<br>0x0000000000400f9d &lt;+90&gt;:jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400f9f &lt;+92&gt;:mov    $0x2aa,%eax<br>0x0000000000400fa4 &lt;+97&gt;:jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400fa6 &lt;+99&gt;:mov    $0x147,%eax<br>0x0000000000400fab &lt;+104&gt;:jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400fad &lt;+106&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>0x0000000000400fb2 &lt;+111&gt;:mov    $0x0,%eax<br>0x0000000000400fb7 &lt;+116&gt;:jmp    0x400fbe &lt;phase_3+123&gt;<br>0x0000000000400fb9 &lt;+118&gt;:mov    $0x137,%eax<br>0x0000000000400fbe &lt;+123&gt;:cmp    0xc(%rsp),%eax<br>0x0000000000400fc2 &lt;+127&gt;:je     0x400fc9 &lt;phase_3+134&gt;<br>0x0000000000400fc4 &lt;+129&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>0x0000000000400fc9 &lt;+134&gt;:add    $0x18,%rsp<br>0x0000000000400fcd &lt;+138&gt;:retq   <br><br></code></pre></td></tr></table></figure></li><li>1：开辟24字节的栈空间</li><li>2：<code>rcx = rsp + 12</code>第二个参数</li><li>3：<code>rdx = rsp + 8</code>第一个参数</li><li>4-8：和<code>phase_2</code>里<code>read_six_numbers</code>函数中的第13行开始一样，输入数据，判断一下输入参数的个数，只不过这里是返回值个数大于1，如果参数个数正确就跳到<code>phase_3+39</code>也就是第10行，否则引爆炸弹。</li><li>10-11：如果<code>7 &lt; rsp + 8 等价于 7 &lt; rdx 等价于 7 &lt; 第一个参数</code>就跳转到<code>phase_3+106</code>，爆炸。这里确定第一个数必须小于7</li><li>12：<code>eax = rsp + 8 等价于 eax = 第一个参数</code></li><li>13：跳转至<code>0x402470 + 8 * rax</code>处，具体跳转到哪里根据第一个值做判断</li><li>14：<code>eax = 207</code></li><li>15：跳转至<code>phase_3+123</code>,即32行</li><li>16：<code>eax = 707</code></li><li>17：跳转到32行</li><li>18：<code>eax = 256</code></li><li>19：跳转到32行</li><li>20：<code>eax = 389</code></li><li>21-27：以此类推</li><li>29：<code>eax = 0</code></li><li>30：</li><li>31：<code>eax = 311</code></li><li>32-34：比较<code>eax</code>和<code>rsp + 12</code> 等价于 比较 第二个参数和<code>eax</code>。如果相等就返回，如果不等就引爆。</li></ul><p>分析至此，我们也就知道了程序的大概流程，输入两个值，第一个值必须小于等于7，第二个值根据第一个值来确定，具体等于多少，根据跳转表确定，因为第一个值有八个数，也就对应着汇编中八段寄存器<code>eax</code>赋值的过程，我们只要输入第一个合法的数值，然后再打印出寄存器<code>eax</code>的值，即可确定答案。</p><p>比如我们先测试一下第一个值为0时，对应的第二个值为多少，我们输入<code>0  10</code>，因为只是测试，第二个值任意。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stata">That&#x27;s number 2.  <span class="hljs-keyword">Keep</span> going! <span class="hljs-comment">//接上个炸弹后面</span><br>88    <span class="hljs-keyword">input</span> = read_line();<br>(gdb) <span class="hljs-keyword">n</span><br>0 10              <span class="hljs-comment">//输入测试答案</span><br>89    phase_3(<span class="hljs-keyword">input</span>);<br>(gdb) <span class="hljs-keyword">n</span><br>Breakpoint 4, 0x0000000000400f43 <span class="hljs-keyword">in</span> phase_3 ()<br>(gdb) <span class="hljs-keyword">n</span><br>Single stepping until <span class="hljs-keyword">exit</span> from function phase_3,<br><span class="hljs-keyword">which</span> has <span class="hljs-keyword">no</span> <span class="hljs-keyword">line</span> number information.<br>Breakpoint 2, 0x000000000040143a <span class="hljs-keyword">in</span> explode_bomb ()<br>(gdb) p <span class="hljs-variable">$eax</span><br><span class="hljs-variable">$14</span> = 207         <span class="hljs-comment">//207即是答案</span><br></code></pre></td></tr></table></figure><p>输入真正答案测试，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">(gdb) n<br><span class="hljs-number">0</span> <span class="hljs-number">207</span>                         <span class="hljs-regexp">//</span>输入答案<br><span class="hljs-number">89</span>    phase_3(input);<br>(gdb) n<br>Breakpoint <span class="hljs-number">4</span>, <span class="hljs-number">0</span>x0000000000400f43 <span class="hljs-keyword">in</span> phase_3 ()<br>(gdb) n<br>Single stepping until <span class="hljs-keyword">exit</span> from <span class="hljs-keyword">function</span> phase_3,<br>which has no line number information.<br>main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at bomb.c:<span class="hljs-number">90</span><br><span class="hljs-number">90</span>    phase_defused();    <span class="hljs-regexp">//</span>炸弹拆除<br>(gdb) <br><span class="hljs-number">91</span>    printf(<span class="hljs-string">&quot;Halfway there!\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>我们上面说过，第一个值有八种可能，所以这题答案也有八个，我们只要挨个测试<code>0-7</code>，分别打印出寄存器<code>eax</code>的值就可以得到所有答案。他们分别是</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">207</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">311</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">707</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">256</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">389</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">206</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">682</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">327</span><br></code></pre></td></tr></table></figure><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>行百里者半九十，NO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) disas phase_4<br>Dump of assembler code for function phase_4:<br>   0x000000000040100c &lt;+0&gt;:sub    $0x18,%rsp<br>   0x0000000000401010 &lt;+4&gt;:lea    0xc(%rsp),%rcx<br>   0x0000000000401015 &lt;+9&gt;:lea    0x8(%rsp),%rdx<br>   0x000000000040101a &lt;+14&gt;:mov    $0x4025cf,%esi<br>   0x000000000040101f &lt;+19&gt;:mov    $0x0,%eax<br>   0x0000000000401024 &lt;+24&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>   0x0000000000401029 &lt;+29&gt;:cmp    $0x2,%eax<br>   0x000000000040102c &lt;+32&gt;:jne    0x401035 &lt;phase_4+41&gt;<br>   0x000000000040102e &lt;+34&gt;:cmpl   $0xe,0x8(%rsp)<br>   0x0000000000401033 &lt;+39&gt;:jbe    0x40103a &lt;phase_4+46&gt;<br>   0x0000000000401035 &lt;+41&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>   0x000000000040103a &lt;+46&gt;:mov    $0xe,%edx<br>   0x000000000040103f &lt;+51&gt;:mov    $0x0,%esi<br>   0x0000000000401044 &lt;+56&gt;:mov    0x8(%rsp),%edi<br>   0x0000000000401048 &lt;+60&gt;:callq  0x400fce &lt;func4&gt;<br>   0x000000000040104d &lt;+65&gt;:test   %eax,%eax<br>   0x000000000040104f &lt;+67&gt;:jne    0x401058 &lt;phase_4+76&gt;<br>   0x0000000000401051 &lt;+69&gt;:cmpl   $0x0,0xc(%rsp)<br>   0x0000000000401056 &lt;+74&gt;:je     0x40105d &lt;phase_4+81&gt;<br>   0x0000000000401058 &lt;+76&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>   0x000000000040105d &lt;+81&gt;:add    $0x18,%rsp<br>   0x0000000000401061 &lt;+85&gt;:retq   <br></code></pre></td></tr></table></figure><ul><li>1-8：开辟空间，保存参数信息，调用输入函数，和上面的分析重复，不再赘述。注意的是第6行，<code>x/s 0x4025cf</code>可知两个参数是整型数值。</li><li>9-10：参数个数必须等于2，否则引爆</li><li>11-12：<code>14</code>与<code>rsp + 8</code>比较，等价于<code>14</code>与第一个参数比较。表示第一个参数必须小于等于14，否则引爆。</li><li>14：<code>edx = 14</code></li><li>15：<code>esi = 0</code></li><li>16：<code>edi = rsp + 8</code>即<code>edi = 第一个参数</code></li><li>17：调用函数<code>fun4</code>，参数分别为<code>edi 0 14</code></li><li>18：测试返回值是否为0，如果不为0，引爆</li><li>20-22：比较<code>0</code>和<code>rsp + 12</code>，如果不等，引爆，否则返回</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">(gdb) disas func4<br>Dump of assembler code for function func4:<br>   0x0000000000400fce &lt;+0&gt;:sub    $0x8,%rsp<br>   0x0000000000400fd2 &lt;+4&gt;:mov    %edx,%eax<br>   0x0000000000400fd4 &lt;+6&gt;:sub    %esi,%eax<br>   0x0000000000400fd6 &lt;+8&gt;:mov    %eax,%ecx<br>   0x0000000000400fd8 &lt;+10&gt;:shr    $0x1f,%ecx<br>   0x0000000000400fdb &lt;+13&gt;:add    %ecx,%eax<br>   0x0000000000400fdd &lt;+15&gt;:sar    %eax<br>   0x0000000000400fdf &lt;+17&gt;:lea    (%rax,%rsi,1),%ecx<br>   0x0000000000400fe2 &lt;+20&gt;:cmp    %edi,%ecx<br>   0x0000000000400fe4 &lt;+22&gt;:jle    0x400ff2 &lt;func4+36&gt;<br>   0x0000000000400fe6 &lt;+24&gt;:lea    -0x1(%rcx),%edx<br>   0x0000000000400fe9 &lt;+27&gt;:callq  0x400fce &lt;func4&gt;<br>   0x0000000000400fee &lt;+32&gt;:add    %eax,%eax<br>   0x0000000000400ff0 &lt;+34&gt;:jmp    0x401007 &lt;func4+57&gt;<br>   0x0000000000400ff2 &lt;+36&gt;:mov    $0x0,%eax<br>   0x0000000000400ff7 &lt;+41&gt;:cmp    %edi,%ecx<br>   0x0000000000400ff9 &lt;+43&gt;:jge    0x401007 &lt;func4+57&gt;<br>   0x0000000000400ffb &lt;+45&gt;:lea    0x1(%rcx),%esi<br>   0x0000000000400ffe &lt;+48&gt;:callq  0x400fce &lt;func4&gt;<br>   0x0000000000401003 &lt;+53&gt;:lea    0x1(%rax,%rax,1),%eax<br>   0x0000000000401007 &lt;+57&gt;:add    $0x8,%rsp<br>   0x000000000040100b &lt;+61&gt;:retq   <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C">func (edi, esi, edx)<br>&#123;<br>   <span class="hljs-comment">// edi = 第一个参数, esi = 0, edx = 14</span><br>   eax = edx            <span class="hljs-comment">// 4:mov %edx, %eax</span><br>   eax = eax -esi       <span class="hljs-comment">// 5:sub esi, %eax</span><br>   eax = edx -esi<br>   ecx = eax            <span class="hljs-comment">// 6:mov %eax, %ecx</span><br>   ecx = edx - esi<br>   eсx = ecx &gt;&gt; <span class="hljs-number">31</span>      <span class="hljs-comment">// 7:shr  $0x1f, %ecx</span><br>   ecx = (edx - esi) &gt;&gt; <span class="hljs-number">31</span><br>   eax = eax + ecx      <span class="hljs-comment">// 8:add %ecx, %eax</span><br>   eax = (edx - esi) + ((edx - esi) &gt;&gt; <span class="hljs-number">31</span>)<span class="hljs-comment">//替换eax和ecx</span><br>   eax = eax &gt; <span class="hljs-number">1</span>;       <span class="hljs-comment">// 9:sar %eax</span><br>   eax = ((edx - esi) +((edx -esi) &gt;&gt; <span class="hljs-number">31</span>)) / <span class="hljs-number">2</span><br>   ecx = eax + esi * <span class="hljs-number">1</span>   <span class="hljs-comment">// 10:lea (rax,ersi,1), %ecx</span><br>   ecx = ((edx - esi) +((edx -esi) &gt;&gt; <span class="hljs-number">31</span>)) / <span class="hljs-number">2</span> + esi * <span class="hljs-number">1</span><br><br>   ecx = ((<span class="hljs-number">14</span> - <span class="hljs-number">0</span>) + ((<span class="hljs-number">14</span> - <span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">31</span>)) / <span class="hljs-number">2</span> + <span class="hljs-number">0</span><br>   ecx = <span class="hljs-number">7</span><br><br>   <span class="hljs-comment">// 11:cmp %edi, %ecx</span><br>   <span class="hljs-keyword">if</span> (ecx &lt;= edi)<br>   &#123;<br>      <span class="hljs-comment">// 12:jle 400ff2</span><br>      eax = <span class="hljs-number">0</span>    <span class="hljs-comment">// mov $0x0,%eax</span><br>      <span class="hljs-comment">// 18:cmp %edi, %ecx</span><br>      <span class="hljs-keyword">if</span>(ecx &gt;= edi)<br>      &#123;<br>         <span class="hljs-comment">// 19:jge    0x401007 &lt;func4+57&gt;</span><br>         <span class="hljs-keyword">return</span>;<br>         <span class="hljs-comment">//由此可以得知道 edx == edi</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs &#123;.line-numbers&#125;">0x0000000000401062 &lt;+0&gt;:push   %rbx<br>0x0000000000401063 &lt;+1&gt;:sub    $0x20,%rsp<br>0x0000000000401067 &lt;+5&gt;:mov    %rdi,%rbx<br>0x000000000040106a &lt;+8&gt;:mov    %fs:0x28,%rax<br>0x0000000000401073 &lt;+17&gt;:mov    %rax,0x18(%rsp)<br>0x0000000000401078 &lt;+22&gt;:xor    %eax,%eax<br>0x000000000040107a &lt;+24&gt;:callq  0x40131b &lt;string_length&gt;<br>0x000000000040107f &lt;+29&gt;:cmp    $0x6,%eax<br>0x0000000000401082 &lt;+32&gt;:je     0x4010d2 &lt;phase_5+112&gt;<br>0x0000000000401084 &lt;+34&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>0x0000000000401089 &lt;+39&gt;:jmp    0x4010d2 &lt;phase_5+112&gt;<br>0x000000000040108b &lt;+41&gt;:movzbl (%rbx,%rax,1),%ecx<br>0x000000000040108f &lt;+45&gt;:mov    %cl,(%rsp)<br>0x0000000000401092 &lt;+48&gt;:mov    (%rsp),%rdx<br>0x0000000000401096 &lt;+52&gt;:and    $0xf,%edx<br>0x0000000000401099 &lt;+55&gt;:movzbl 0x4024b0(%rdx),%edx<br>0x00000000004010a0 &lt;+62&gt;:mov    %dl,0x10(%rsp,%rax,1)<br>0x00000000004010a4 &lt;+66&gt;:add    $0x1,%rax<br>0x00000000004010a8 &lt;+70&gt;:cmp    $0x6,%rax<br>0x00000000004010ac &lt;+74&gt;:jne    0x40108b &lt;phase_5+41&gt;<br>0x00000000004010ae &lt;+76&gt;:movb   $0x0,0x16(%rsp)<br>0x00000000004010b3 &lt;+81&gt;:mov    $0x40245e,%esi<br>   0x00000000004010b8 &lt;+86&gt;:lea    0x10(%rsp),%rdi<br>0x00000000004010bd &lt;+91&gt;:callq  0x401338 &lt;strings_not_equal&gt;<br>0x00000000004010c2 &lt;+96&gt;:test   %eax,%eax<br>0x00000000004010c4 &lt;+98&gt;:je     0x4010d9 &lt;phase_5+119&gt;<br>0x00000000004010c6 &lt;+100&gt;:callq  0x40143a &lt;explode_bomb&gt;<br>0x00000000004010cb &lt;+105&gt;:nopl   0x0(%rax,%rax,1)<br>0x00000000004010d0 &lt;+110&gt;:jmp    0x4010d9 &lt;phase_5+119&gt;<br>0x00000000004010d2 &lt;+112&gt;:mov    $0x0,%eax<br>0x00000000004010d7 &lt;+117&gt;:jmp    0x40108b &lt;phase_5+41&gt;<br>0x00000000004010d9 &lt;+119&gt;:mov    0x18(%rsp),%rax<br>0x00000000004010de &lt;+124&gt;:xor    %fs:0x28,%rax<br>0x00000000004010e7 &lt;+133&gt;:je     0x4010ee &lt;phase_5+140&gt;<br>0x00000000004010e9 &lt;+135&gt;:callq  0x400b30 &lt;__stack_chk_fail@plt&gt;<br>0x00000000004010ee &lt;+140&gt;:add    $0x20,%rsp<br>0x00000000004010f2 &lt;+144&gt;:pop    %rbx<br>0x00000000004010f3 &lt;+145&gt;:retq   <br><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>CSAPP-Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GDB</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB调试入门</title>
    <link href="/2021/08/29/GDB%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/"/>
    <url>/2021/08/29/GDB%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="file加载程序"><a href="#file加载程序" class="headerlink" title="file加载程序"></a>file加载程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) file bomb<br>Reading symbols from bomb...<br></code></pre></td></tr></table></figure><h2 id="set-args带参数调试"><a href="#set-args带参数调试" class="headerlink" title="set args带参数调试"></a>set args带参数调试</h2><p>有时候程序不是直接可以运行的，需要加上一些必要的参数。带上参数运行很容易，只要在程序名后加上相应参数即可，但是如何带上参数进行调试呢？这就需要<code>set args</code>命令。</p><p>比如在<code>BombLab</code>实验中，我们不可能一次解决所有<code>phase</code>，但是每次重新调试，已经解决的<code>phase</code>还要重新输入一次答案，这就很麻烦，好在这个实验的作者也考虑到了，他支持读取文本。我们可以把答案预先写入一个文本文件中，程序读取已经保存的答案即可跳过相应的<code>phase</code>。</p><p>假设我们把答案写入了<code>solutions.txt</code>文件中，首先，我们加载程序，然后通过<code>set args solutions.txt</code>设置运行参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) file bomb<br>Reading symbols from bomb...<br>(gdb) <span class="hljs-built_in">set</span> args solutions.txt <br>(gdb) r<br>Starting program: /home/dominic/learning-linux/bomb/bomb solutions.txt <br>Welcome to my fiendish little bomb. You have 6 phases with<br><span class="hljs-built_in">which</span> to blow yourself up. Have a nice day!<br>Phase 1 defused. How about the next one?<br>That<span class="hljs-string">&#x27;s number 2.  Keep going!</span><br></code></pre></td></tr></table></figure><h2 id="list查看源码"><a href="#list查看源码" class="headerlink" title="list查看源码"></a>list查看源码</h2><h3 id="查看10行源码"><a href="#查看10行源码" class="headerlink" title="查看10行源码"></a>查看10行源码</h3><p>每条命令显示10行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) l<br>23#include &lt;stdio.h&gt;<br>24#include &lt;stdlib.h&gt;<br>25#include &quot;support.h&quot;<br>26#include &quot;phases.h&quot;<br>27<br>28/* <br>29 * Note to self: Remember to erase this file so my victims will have no<br>30 * idea what is going on, and so they will all blow up in a<br>31 * spectaculary fiendish explosion. -- Dr. Evil <br>32 */<br>(gdb) l<br>33<br>34FILE *infile;<br>35<br>36int main(int argc, char *argv[])<br>37&#123;<br>38    char *input;<br>39<br>40    /* Note to self: remember to port this bomb to Windows and put a <br>41     * fantastic GUI on it. */<br>42<br></code></pre></td></tr></table></figure><h3 id="set-list-num设置默认显示代码行数"><a href="#set-list-num设置默认显示代码行数" class="headerlink" title="set list num设置默认显示代码行数"></a>set list num设置默认显示代码行数</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">(gdb) <span class="hljs-keyword">set</span> list <span class="hljs-comment">20</span>   //默认显示<span class="hljs-comment">20</span>行代码<br></code></pre></td></tr></table></figure><h3 id="list-linenumber查看指定行代码"><a href="#list-linenumber查看指定行代码" class="headerlink" title="list linenumber查看指定行代码"></a>list linenumber查看指定行代码</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">(gdb) l <span class="hljs-number">10</span>  <br>(gdb) l <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.h</span> : <span class="hljs-number">10</span> <span class="hljs-comment">//指定main.c文件中的第十行</span><br></code></pre></td></tr></table></figure><h3 id="list-function查看指定函数的代码"><a href="#list-function查看指定函数的代码" class="headerlink" title="list function查看指定函数的代码"></a>list function查看指定函数的代码</h3><h2 id="break-打断点"><a href="#break-打断点" class="headerlink" title="break 打断点"></a>break 打断点</h2><h3 id="break-linenum对指定行打断点"><a href="#break-linenum对指定行打断点" class="headerlink" title="break linenum对指定行打断点"></a>break linenum对指定行打断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b 36<br>Note: breakpoint 1 also set at pc 0x400da0.<br>Breakpoint 2 at 0x400da0: file bomb.c, line 37.<br></code></pre></td></tr></table></figure><h3 id="break-function对指定函数打断点"><a href="#break-function对指定函数打断点" class="headerlink" title="break function对指定函数打断点"></a>break function对指定函数打断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b main<br>Breakpoint 3 at 0x400da0: file bomb.c, line 37.<br>(gdb) b phase_1<br>Breakpoint 4 at 0x400ee0<br></code></pre></td></tr></table></figure><h2 id="删除断点包括禁用断点"><a href="#删除断点包括禁用断点" class="headerlink" title="删除断点包括禁用断点"></a>删除断点包括禁用断点</h2><h3 id="delete删除所有断点"><a href="#delete删除所有断点" class="headerlink" title="delete删除所有断点"></a>delete删除所有断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) delete <br>Delete all breakpoints? (y or n) y<br></code></pre></td></tr></table></figure><h3 id="disable-breakpoint禁用断点"><a href="#disable-breakpoint禁用断点" class="headerlink" title="disable breakpoint禁用断点"></a>disable breakpoint禁用断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) info b #先看有哪些断点<br>Num     Type           Disp Enb Address            What<br>3       breakpoint     keep y   0x0000000000400da0 in main at bomb.c:37<br>4       breakpoint     keep y   0x0000000000400ee0 &lt;phase_1&gt;<br>(gdb) d 3 #禁用第三号断点<br>(gdb) info b #再次查看断点信息发现已经没有第三号断点<br>Num     Type           Disp Enb Address            What<br>4       breakpoint     keep y   0x0000000000400ee0 &lt;phase_1&gt;<br></code></pre></td></tr></table></figure><h3 id="clear-function删除一个函数中所有的断点"><a href="#clear-function删除一个函数中所有的断点" class="headerlink" title="clear function删除一个函数中所有的断点"></a>clear function删除一个函数中所有的断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) info b<br>Num     Type           Disp Enb Address            What<br>4       breakpoint     keep y   0x0000000000400ee0 &lt;phase_1&gt;<br>(gdb) clear phase_1<br>(gdb) info b<br>Deleted breakpoint 4 No breakpoints or watchpoints.<br></code></pre></td></tr></table></figure><h2 id="启动与退出"><a href="#启动与退出" class="headerlink" title="启动与退出"></a>启动与退出</h2><h3 id="run启动程序直到遇到断点"><a href="#run启动程序直到遇到断点" class="headerlink" title="run启动程序直到遇到断点"></a>run启动程序直到遇到断点</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">(gdb) <span class="hljs-builtin-name">run</span>  <br></code></pre></td></tr></table></figure><h3 id="start启动程序并在第一条代码处停下"><a href="#start启动程序并在第一条代码处停下" class="headerlink" title="start启动程序并在第一条代码处停下"></a>start启动程序并在第一条代码处停下</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">(gdb) <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><h3 id="x配置gdb常用命令"><a href="#x配置gdb常用命令" class="headerlink" title="x配置gdb常用命令"></a>x配置gdb常用命令</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>gdb -q -x gdbinit<br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//gdbinit</span><br><span class="hljs-keyword">display</span>/z <span class="hljs-symbol">$</span>xs<br><span class="hljs-keyword">display</span>/z <span class="hljs-symbol">$</span>x6<br><span class="hljs-keyword">display</span>/z <span class="hljs-symbol">$</span>x7<br><span class="hljs-keyword">set</span> disassemble-next-line <span class="hljs-comment">on</span><br>b <span class="hljs-comment">_start</span><br>target <span class="hljs-comment">remote: 34</span><br></code></pre></td></tr></table></figure><p>有了配置文件，就不用每次启动gdb时都要重新输入一遍调试命令。</p><h3 id="quit退出调试"><a href="#quit退出调试" class="headerlink" title="quit退出调试"></a>quit退出调试</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">(gdb) <span class="hljs-keyword">quit</span><br></code></pre></td></tr></table></figure><h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><h3 id="print打印变量值"><a href="#print打印变量值" class="headerlink" title="print打印变量值"></a>print打印变量值</h3><table><thead><tr><th>格式化字符 (/fmt)</th><th>说明</th></tr></thead><tbody><tr><td>/x</td><td>以十六进制的形式打印出整数。</td></tr><tr><td>/d</td><td>以有符号、十进制的形式打印出整数。</td></tr><tr><td>/u</td><td>以无符号、十进制的形式打印出整数。</td></tr><tr><td>/o</td><td>以八进制的形式打印出整数。</td></tr><tr><td>/t</td><td>以二进制的形式打印出整数。</td></tr><tr><td>/f</td><td>以浮点数的形式打印变量或表达式的值。</td></tr><tr><td>/c</td><td>以字符形式打印变量或表达式的值。</td></tr></tbody></table><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">(gdb) p i       <span class="hljs-meta"># 10进制</span><br>$5 = <span class="hljs-number">3</span><br>(gdb) p/x i     <span class="hljs-meta"># 16进制</span><br>$6 = <span class="hljs-number">0x3</span><br>(gdb) p/o i     <span class="hljs-meta"># 8进制</span><br>$7 = <span class="hljs-number">03</span><br><br></code></pre></td></tr></table></figure><h3 id="ptype打印变量类型"><a href="#ptype打印变量类型" class="headerlink" title="ptype打印变量类型"></a>ptype打印变量类型</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">(gdb) ptype i<br>type =<span class="hljs-built_in"> int</span><br><span class="hljs-built_in"></span>(gdb) ptype array[i]<br>type =<span class="hljs-built_in"> int</span><br><span class="hljs-built_in"></span>(gdb) ptype<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span>type =<span class="hljs-built_in"> int </span>[12]<br></code></pre></td></tr></table></figure><h3 id="display跟踪显示变量"><a href="#display跟踪显示变量" class="headerlink" title="display跟踪显示变量"></a>display跟踪显示变量</h3><p><code>print</code>命令可以打印出变量的值，但是只是一次性的。如果我们想要跟踪某个变量的变化，可以使用<code>display</code>命令，每当程序在断点处停下，都会打印出跟踪的变量值。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">(gdb) <span class="hljs-attribute">display</span> <br></code></pre></td></tr></table></figure><p><code>info display</code>查看已跟踪的变量，<code>delete display</code>取消跟踪显示变量。</p><h3 id="step执行一行代码"><a href="#step执行一行代码" class="headerlink" title="step执行一行代码"></a>step执行一行代码</h3><p>执行一行代码，如果改行代码是函数，将进入函数内部。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(gdb)</span> s<br></code></pre></td></tr></table></figure><h3 id="finish跳出函数"><a href="#finish跳出函数" class="headerlink" title="finish跳出函数"></a>finish跳出函数</h3><p>如果通过<code>s</code>单步调试进入到函数内部，想要跳出这个函数体， 可以执行 <code>finish </code>命令。如果想要跳出函数体必须要<strong>保证函数体内不能有有效断点</strong>，否则无法跳出。</p><h3 id="next执行一行代码"><a href="#next执行一行代码" class="headerlink" title="next执行一行代码"></a>next执行一行代码</h3><p><code>next</code> 命令和 <code>step</code> 命令功能是相似的，只是在使用 <code>next</code> 调试程序的时候不会进入到函数体内部，<code>next</code> 可以缩写为 <code>n</code>。</p><h3 id="until跳出循环体"><a href="#until跳出循环体" class="headerlink" title="until跳出循环体"></a>until跳出循环体</h3><p>通过 until 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要保证，<strong>要跳出的循环体内部不能有有效的断点</strong>，<strong>必须要在循环体的开始 / 结束行执行该命令</strong>。</p><h2 id="layout分割窗口，边调试边看源码"><a href="#layout分割窗口，边调试边看源码" class="headerlink" title="layout分割窗口，边调试边看源码"></a>layout分割窗口，边调试边看源码</h2><h3 id="layout-src"><a href="#layout-src" class="headerlink" title="layout src"></a>layout src</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830153452.png"></p><h3 id="layout-asm"><a href="#layout-asm" class="headerlink" title="layout asm"></a>layout asm</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830153520.png"></p><h3 id="layout-split"><a href="#layout-split" class="headerlink" title="layout split"></a>layout split</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830153555.png"></p><h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><h3 id="s-S"><a href="#s-S" class="headerlink" title="-s -S"></a><code>-s -S</code></h3><p><code>-s</code>启动<code>gdb server</code>，默认端口号为1234<br><code>-S</code>让程序在<code>_start</code>处停下。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GDB</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oh-my-zsh让你的终端更加顺手（眼）</title>
    <link href="/2021/08/29/oh-my-zsh%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%BB%88%E7%AB%AF%E6%9B%B4%E5%8A%A0%E9%A1%BA%E6%89%8B%EF%BC%88%E7%9C%BC%EF%BC%89/"/>
    <url>/2021/08/29/oh-my-zsh%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%BB%88%E7%AB%AF%E6%9B%B4%E5%8A%A0%E9%A1%BA%E6%89%8B%EF%BC%88%E7%9C%BC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方方法，<code>curl</code>和<code>wget</code>二选一即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -fsSL https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/ohmyzsh/</span>ohmyzsh<span class="hljs-regexp">/master/</span>tools/install.sh<br>wget -O- https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/ohmyzsh/</span>ohmyzsh<span class="hljs-regexp">/master/</span>tools/install.sh<br></code></pre></td></tr></table></figure><p>应该也有人和我一样，可能会遇到连接GitHub失败的问题，要不就是SSL验证失败，要不就是连接无响应。可以更换下面的方法。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 先下载</span><br>git clone git:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/robbyrussell/</span>oh-my-zsh.git ~/.oh-my-zsh<br><span class="hljs-comment">## 再替换</span><br>cp ~<span class="hljs-regexp">/.oh-my-zsh/</span>templates<span class="hljs-regexp">/zshrc.zsh-template ~/</span>.zshrc<br></code></pre></td></tr></table></figure><p>重启终端即可成功。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工欲善其事必先利其器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Plugins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt绘制系统</title>
    <link href="/2021/08/27/Qt%E7%BB%98%E5%88%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/27/Qt%E7%BB%98%E5%88%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>本篇文章所涉及代码可在<a href="https://github.com/Dunky-Z/learning-qt/tree/main/QtRoad2">此处查看</a>。</p><h2 id="绘制系统简介"><a href="#绘制系统简介" class="headerlink" title="绘制系统简介"></a>绘制系统简介</h2><p>Qt的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于<code>QPainter</code>,<code>QPainterDevice</code>和<code>QPaintEngine</code>三个类。</p><p><code>QPainter</code>用来执行绘制的操作；<code>QPaintDevice</code>是一个二维空间的抽象，这个二维空间允许<code>QPainter</code>在其上面进行绘制，也就是<code>QPainter</code>工作的空间；<code>QPaintEngine</code>提供了画笔（<code>QPainter</code>）在不同的设备上进行绘制的统一的接口。<code>QPaintEngine</code>类应用于<code>QPainter</code>和<code>QPaintDevice</code>之间，通常对开发人员是透明的。</p><p>三个类的关系：<code>QPainter-&gt;QPaintEngine-&gt;QPaintDevice</code>。通过这个关系我们也可以知道，<code>QPainter</code>通过<code>QPaintEngine</code>翻译指令在<code>QPaintDevice</code>上绘制。</p><p>通过一个实例来了解一下绘制系统的，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPainter&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QWidget&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPaintEvent&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaintedWidget</span> :</span> <span class="hljs-keyword">public</span> QWidget<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PaintedWidget</span>(QWidget *parent = <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;paintwidget.h&quot;</span></span><br><br>PaintedWidget::<span class="hljs-built_in">PaintedWidget</span>(QWidget *parent) : <span class="hljs-built_in">QWidget</span>(parent)<br>&#123;<br>    <span class="hljs-built_in">resize</span>(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br>    <span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;Paint Demo&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PaintedWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">700</span>, <span class="hljs-number">20</span>);<br>    painter.<span class="hljs-built_in">setPen</span>(Qt::red);<br>    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>);<br>    painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(Qt::green, <span class="hljs-number">5</span>));<br>    painter.<span class="hljs-built_in">setBrush</span>(Qt::blue);<br>    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>, <span class="hljs-number">40</span>);<br>    <span class="hljs-comment">// painter.drawRect(120, 50, 50, 400);</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    PaintedWidget paintMap;<br>    paintMap.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827184613.png"></p><p>在构造函数中，我们仅仅设置了窗口的大小和标题。而<code>paintEvent()</code>函数则是绘制的代码。</p><p>首先，我们在栈上创建了一个<code>QPainter</code>对象，也就是说，每次运行<code>paintEvent()</code>函数的时候，都会重建这个<code>QPainter</code>对象。注意，这一点可能会引发某些细节问题：由于我们每次重建<code>QPainter</code>，因此第一次运行时所设置的画笔颜色、状态等，第二次再进入这个函数时就会全部丢失。有时候我们希望保存画笔状态，就必须自己保存数据，否则的话则需要将<code>QPainter</code>作为类的成员变量。</p><p><code>paintEvent()</code>作为重绘函数，会在需要重绘时由Qt自动调用。“需要重绘”可能发生在很多地方，比如组件刚刚创建出来的时候就需要重绘；<strong>组件最大化、最小化的时候也需要重新绘制</strong>；组件由遮挡变成完全显示的时候也需要等等。</p><p><code>QPainter</code>接收一个<code>QPaintDevice</code>指针作为参数。<code>QPaintDevice</code>有很多子类，比如<code>QImage</code>，以及<code>QWidget</code>。注意回忆一下，<code>QPaintDevice</code>可以理解成要在哪里去绘制，而现在我们希望画在这个组件，因此传入的是 <code>this</code> 指针。</p><p>我们还需要注意绘制的顺序，直线-矩形-椭圆，所以直线位于最下方，以此类推。</p><p>如果了解 <code>OpenGL</code>，肯定听说过这么一句话：<code>OpenGL</code> 是一个状态机。所谓状态机，就是说，<code>OpenGL</code> 保存的只是各种状态。比如，将画笔颜色设置成红色，那么，除非你重新设置另外的颜色，它的颜色会一直是红色。<code>QPainter</code>也是这样，它的状态不会自己恢复，除非你使用了各种设置函数。因此，如果在上面的代码中，我们在椭圆绘制之后再画一个矩形，它的样式还会是绿色<code>5</code>像素的轮廓线以及蓝色的填充，除非你显式地调用了设置函数进行状态的更新。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827184538.png"></p><p>这是大多数绘图系统的实现方式，包括 <code>OpenGL</code>、<code>QPainter</code>以及 <code>Java2D</code>。正因为<code>QPainter</code>是一个状态机，才会引出我们前面曾经介绍过的一个细节问题：<strong>由于<code>paintEvent()</code>是需要重复进入的，因此，需要注意第二次进入时，<code>QPainter</code>的状态是不是和第一次一致，否则的话可能会造成闪烁的现象</strong>。这个闪烁并不是由于双缓冲的问题，而是由于绘制状态的快速切换。</p><h2 id="画刷和画笔"><a href="#画刷和画笔" class="headerlink" title="画刷和画笔"></a>画刷和画笔</h2><p>画刷和画笔。前者使用<code>QBrush</code>描述，大多用于填充；后者使用<code>QPen</code>描述，大多用于绘制轮廓线。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PaintedWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">700</span>, <span class="hljs-number">20</span>);<br>    painter.<span class="hljs-built_in">setPen</span>(Qt::red);<br>    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>);<br>    painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(Qt::green, <span class="hljs-number">5</span>));<br>    painter.<span class="hljs-built_in">setBrush</span>(Qt::blue);<br>    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>, <span class="hljs-number">40</span>);<br>    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">120</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">400</span>);<br>    <span class="hljs-comment">///////////////////画笔与笔刷</span><br>    <span class="hljs-function">QLinearGradient <span class="hljs-title">gradient</span><span class="hljs-params">(QPointF(<span class="hljs-number">180</span>, <span class="hljs-number">50</span>), QPointF(<span class="hljs-number">230</span>, <span class="hljs-number">400</span>))</span></span>;<br>    gradient.<span class="hljs-built_in">setColorAt</span>(<span class="hljs-number">0</span>, Qt::black);<br>    gradient.<span class="hljs-built_in">setColorAt</span>(<span class="hljs-number">1</span>, Qt::red);<br>    gradient.<span class="hljs-built_in">setSpread</span>(QGradient::PadSpread);<br><br>    <span class="hljs-function">QBrush <span class="hljs-title">brush</span><span class="hljs-params">(gradient)</span></span>;<br><br>    <span class="hljs-function">QPen <span class="hljs-title">pen</span><span class="hljs-params">(Qt::green, <span class="hljs-number">3</span>, Qt::DashDotLine, Qt::RoundCap, Qt::RoundJoin)</span></span>;<br>    <span class="hljs-comment">// painter.setPen(pen);</span><br>    painter.<span class="hljs-built_in">setBrush</span>(brush);<br>    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">180</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">400</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827190208.png"></p><p>画刷的<code>style()</code>定义了填充的样式，使用<code>Qt::BrushStyle</code>枚举，默认值是<code>Qt::NoBrush</code>，也就是不进行任何填充。我们可以从下面的图示中看到各种填充样式的区别：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827190421.png"></p><p>画刷的<code>gradient()</code>定义了渐变填充。这个属性只有在样式是<code>Qt::LinearGradientPattern</code>、<code>Qt::RadialGradientPattern</code>或者<code>Qt::ConicalGradientPattern</code>之一时才有效。渐变可以由<code>QGradient</code>对象表示。<code>Qt</code> 提供了三种渐变：<code>QLinearGradient</code>、<code>QConicalGradient</code>和<code>QRadialGradient</code>，它们都是<code>QGradient</code>的子类。</p><p>本文以<code>QLinearGradient</code>为例，两个坐标分别为起点与重点坐标。<code>setColorAt</code>设置渐变颜色，<code>0</code>表示开始，<code>1</code>表示结束。意思就是从黑色渐变到红色。<code>setSpread</code>设置显示方式为平铺。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QLinearGradient <span class="hljs-title">gradient</span><span class="hljs-params">(QPointF(<span class="hljs-number">180</span>, <span class="hljs-number">50</span>), QPointF(<span class="hljs-number">230</span>, <span class="hljs-number">400</span>))</span></span>;<br>gradient.<span class="hljs-built_in">setColorAt</span>(<span class="hljs-number">0</span>, Qt::black);<br>gradient.<span class="hljs-built_in">setColorAt</span>(<span class="hljs-number">1</span>, Qt::red);<br>gradient.<span class="hljs-built_in">setSpread</span>(QGradient::PadSpread);<br></code></pre></td></tr></table></figure><p>默认的画笔属性是纯黑色，0 像素，方形笔帽（<code>Qt::SquareCap</code>），斜面型连接（<code>Qt::BevelJoin</code>）。</p><p>画笔样式有一下几种，<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827191748.png"></p><p>你也可以使用<code>setDashPattern()</code>函数自定义样式，例如如下代码片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QVector&lt;qreal&gt; dashes;<br>qreal space = <span class="hljs-number">4</span>;<br><br>dashes &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; space &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; space &lt;&lt; <span class="hljs-number">9</span> &lt;&lt; space<br>        &lt;&lt; <span class="hljs-number">27</span> &lt;&lt; space &lt;&lt; <span class="hljs-number">9</span> &lt;&lt; space;<br>pen.<span class="hljs-built_in">setColor</span>(Qt::black);<br>pen.<span class="hljs-built_in">setDashPattern</span>(dashes);<br>painter.<span class="hljs-built_in">setPen</span>(pen);<br>painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-number">30</span>, <span class="hljs-number">300</span>, <span class="hljs-number">600</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827193722.png"></p><p><code>pen.setCapStyle(Qt::RoundCap)</code>笔帽定义了画笔末端的样式，例如：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827193821.png"></p><p><code>pen.setJoinStyle(Qt::RoundJoin)</code>连接样式定义了两条线连接时的样式，例如：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827193833.png"></p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><p>我们在光栅图形显示器上绘制非水平、非垂直的直线或多边形边界时，或多或少会呈现锯齿状外观。这是因为直线和多边形的边界是连续的，而光栅则是由离散的点组成。在光栅显示设备上表现直线、多边形等，必须在离散位置采样。由于采样不充分重建后造成的信息失真，就叫走样；用于减少或消除这种效果的技术，就称为反走样。也就是常说的防锯齿现象。因为性能方面的考虑，Qt默认关闭反走样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">///////////////////对比反走样效果</span><br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(Qt::black, <span class="hljs-number">5</span>, Qt::DashDotLine, Qt::RoundCap));<br>    painter.<span class="hljs-built_in">setBrush</span>(Qt::yellow);<br>    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">550</span>, <span class="hljs-number">150</span>, <span class="hljs-number">200</span>, <span class="hljs-number">150</span>);<br><br>    painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<br>    painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(Qt::black, <span class="hljs-number">5</span>, Qt::DashDotLine, Qt::RoundCap));<br>    painter.<span class="hljs-built_in">setBrush</span>(Qt::yellow);<br>    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">300</span>, <span class="hljs-number">150</span>, <span class="hljs-number">200</span>, <span class="hljs-number">150</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830192414.png"></p><p>我们可以明显观察到右边的椭圆轮廓是有锯齿现象的，这两个椭圆除了位置位置不同，唯一的区别就是右边的开启了反锯齿。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>虽然反走样比不反走样的图像质量高很多，但是，没有反走样的图形绘制还是有很大用处的。首先，就像前面说的一样，在一些对图像质量要求不高的环境下，或者说性能受限的环境下，比如嵌入式和手机环境，一般是不进行反走样的。另外，在一些必须精确操作像素的应用中，也是不能进行反走样的。</p><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p>在 Qt 的坐标系统中，每个像素占据 <code>1x1</code> 的空间。你可以把它想象成一张方格纸，每个小格都是1个像素。方格的焦点定义了坐标，也就是说，像素 <code>(x, y)</code> 的中心位置其实是在<code>(x + 0.5, y + 0.5)</code>的位置上。这个坐标系统实际上是一个“半像素坐标系”。我们可以通过下面的示意图来理解这种坐标系：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830195728.png"></p><p>我们使用一个像素的画笔进行绘制，可以看到，每一个绘制像素都是以坐标点为中心的矩形。注意，这是坐标的逻辑表示，实际绘制则与此不同。因为在实际设备上，像素是最小单位，我们不能像上面一样，在两个像素之间进行绘制。所以在实际绘制时，Qt 的定义是，绘制点所在像素是逻辑定义点的右下方的像素。</p><p>接下来，我们探究Qt绘制图像的坐标情况，<br>对于画笔大小为一个像素的情况比较容易理解，当我们绘制矩形左上角 <code>(1, 2)</code> 时，实际绘制的像素是在右下方。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830195744.png"></p><p>当画笔大小超过1个像素时，就略显复杂了。如果绘制像素是偶数，则实际绘制会包裹住逻辑坐标值；如果是奇数，则是包裹住逻辑坐标值，再加上右下角一个像素的偏移。具体请看下面的图示：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830200442.png"></p><p>从上图可以看出，如果实际绘制是偶数像素，则会将逻辑坐标值夹在相等的两部分像素之间；如果是奇数，则会在右下方多出一个像素。</p><p>Qt 的这种处理，带来的一个问题是，我们可能获取不到真实的坐标值。由于历史原因，<code>QRect::right()</code>和<code>QRect::bottom()</code>的返回值并不是矩形右下角点的真实坐标值：<code>QRect::right()</code>返回的是<code> left() + width() - 1</code>；<code>QRect::bottom()</code>则返回 <code>top() + height() - 1</code>，上图的绿色点指出了这两个函数的返回点的坐标。</p><p>为避免这个问题，我们建议是使用<code>QRectF。QRectF</code>使用浮点值，而不是整数值，来描述坐标。这个类的两个函数<code>QRectF::right()</code>和<code>QRectF::bottom()</code>是正确的。如果你不得不使用<code>QRect</code>，那么可以利用 <code>x() + width()</code> 和 <code>y() + height() </code>来替代 <code>right() </code>和<code>bottom()</code>函数。</p><p>对于反走样，实际绘制会包裹住逻辑坐标值：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830201429.png"></p><p>前面说过，<code>QPainter</code>是一个状态机。那么，有时我想保存下当前的状态：当我临时绘制某些图像时，就可能想这么做。当然，我们有最原始的办法：将可能改变的状态，比如画笔颜色、粗细等，在临时绘制结束之后再全部恢复。对此，<code>QPainter</code>提供了内置的函数：<code>save()</code>和<code>restore()</code>。<code>save()</code>就是保存下当前状态；<code>restore()</code>则恢复上一次保存的结果。这两个函数必须成对出现：<code>QPainter</code>使用栈来保存数据，每一次<code>save()</code>，将当前状态压入栈顶，<code>restore()</code>则弹出栈顶进行恢复。</p><p>在了解了这两个函数之后，我们就可以进行示例代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//绘制一个网格背景</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CoordinateWidget::paintGrid</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> win_width = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">width</span>();<br>    <span class="hljs-keyword">size_t</span> win_height = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">height</span>();<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> x = <span class="hljs-number">0</span>; x &lt; win_width; x += <span class="hljs-number">25</span>)<br>    &#123;<br>        painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-built_in">QPoint</span>(x, <span class="hljs-number">1</span>), <span class="hljs-built_in">QPoint</span>(x, win_height));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> y = <span class="hljs-number">0</span>; y &lt; win_height; y += <span class="hljs-number">25</span>)<br>    &#123;<br>        painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-built_in">QPoint</span>(<span class="hljs-number">1</span>, y), <span class="hljs-built_in">QPoint</span>(win_width, y));<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CoordinateWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">paintGrid</span>();<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, Qt::red);<br>    painter.<span class="hljs-built_in">save</span>();<br>    painter.<span class="hljs-built_in">translate</span>(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 向右平移 100px</span><br>    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, Qt::yellow);<br>    painter.<span class="hljs-built_in">restore</span>();<br>    painter.<span class="hljs-built_in">save</span>();<br>    painter.<span class="hljs-built_in">translate</span>(<span class="hljs-number">300</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 向右平移 300px</span><br>    painter.<span class="hljs-built_in">rotate</span>(<span class="hljs-number">30</span>);        <span class="hljs-comment">// 顺时针旋转 30 度</span><br>    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, Qt::green);<br>    painter.<span class="hljs-built_in">restore</span>();<br>    painter.<span class="hljs-built_in">save</span>();<br>    painter.<span class="hljs-built_in">translate</span>(<span class="hljs-number">400</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 向右平移 400px</span><br>    painter.<span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);       <span class="hljs-comment">// 横坐标单位放大 2 倍，纵坐标放大 3 倍</span><br>    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, Qt::blue);<br>    painter.<span class="hljs-built_in">restore</span>();<br>    painter.<span class="hljs-built_in">save</span>();<br>    painter.<span class="hljs-built_in">translate</span>(<span class="hljs-number">600</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 向右平移 600px</span><br>    painter.<span class="hljs-built_in">shear</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);       <span class="hljs-comment">// 横向不变，纵向扭曲 1 倍</span><br>    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, Qt::cyan);<br>    painter.<span class="hljs-built_in">restore</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Qt 提供了四种坐标变换：平移 <code>translate</code>，旋转 <code>rotate</code>，缩放 <code>scale</code> 和扭曲 <code>shear</code>。在这段代码中，我们首先在 <code>(10, 10)</code> 点绘制一个红色的 <code>50x100</code> 矩形。保存当前状态，将坐标系平移到 <code>(100, 0)</code>，绘制一个黄色的矩形。注意，<code>translate()</code>操作平移的是坐标系，不是矩形。因此，我们还是在<code> (10, 10)</code> 点绘制一个 <code>50x100</code> 矩形，现在，它跑到了右侧的位置。然后恢复先前状态，也就是把坐标系重新设为默认坐标系（相当于进行<code>translate(-100, 0)</code>），再进行下面的操作。之后也是类似的。由于我们只是保存了默认坐标系的状态，因此我们之后的<code>translate()</code>横坐标值必须增加，否则就会覆盖掉前面的图形。所有这些操作都是针对坐标系的，因此在绘制时，我们提供的矩形的坐标参数都是不变的。</p><p>为了更直观的查看绘制坐标，先在背景画了一个网格。</p><p>运行结果如下：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210830201720.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V入门（1）- 计算机基础</title>
    <link href="/2021/08/26/RISC-V%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89-%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/08/26/RISC-V%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89-%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机硬件基础"><a href="#计算机硬件基础" class="headerlink" title="计算机硬件基础"></a>计算机硬件基础</h3><p>两大硬件架构</p><ul><li><p>冯诺依曼架构</p><ul><li><p>一根总线，开销小，控制逻辑实现简单</p></li><li><p>执行效率低</p></li></ul></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211529332.png"></p><ul><li><p>哈佛架构</p><ul><li>与上一架构相反</li></ul></li></ul><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211529619.png"></p><h3 id="程序的存储与执行"><a href="#程序的存储与执行" class="headerlink" title="程序的存储与执行"></a>程序的存储与执行</h3><p><code>.c</code>文件经过编译链接，生成<code>.out</code>文件。加载到内存中，到控制单元运行。进行取值，译码，执行。</p><p>晶振发出脉冲。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211621792.png"></p><h3 id="语言的设计与进化"><a href="#语言的设计与进化" class="headerlink" title="语言的设计与进化"></a>语言的设计与进化</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211735861.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211736944.png"><br>上图是冯诺依曼架构，特点就是指令与数据放在一起。黄色部分表示指令，绿色部分表示数据。我们来看看指令是如何执行的。<br><code>ProgramCounter</code>指到右图内存的第一条指令，程序开始执行。将第一条 指令读入指令寄存器。然后将指令解码，根据之前的规定，我们可以知道这条指令是将<code>0100(二进制即5)</code>位置的数据，<code>00(load)</code>到<code>00(Register 0)</code>中。下面的指令一次类推，每次取指，<code>Program Counter</code>移动一次。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211743999.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202108211719114.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>RISC-V入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode单步调试QEMU</title>
    <link href="/2021/08/24/VSCode%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95QEMU/"/>
    <url>/2021/08/24/VSCode%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95QEMU/</url>
    
    <content type="html"><![CDATA[<p>了解了如何在<a href="https://dunky-z.github.io/2021/08/23/VSCode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/">VSCode中调试程序</a>，接下来我们在VSCode中搭建调试QEMU的环境。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先我们需要<a href="https://dunky-z.github.io/2021/07/23/QEMU%E5%88%9D%E8%AF%86/">下载和编译QEMU源码</a></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span> <span class="hljs-params">--enable-debug</span> <span class="hljs-params">--target-list=riscv32-softmmu</span>,riscv32-linux-user <span class="hljs-params">--enable-kvm</span><br></code></pre></td></tr></table></figure><p>一定要加上<code>--enable-debug</code>，编译出的程序才带有调试信息，不用设置安装路径，编译时会自动在qemu文件夹下自动创建一个<code>build</code>文件夹，编译后的程序也在<code>build</code>文件夹下。</p><p>用VSCode打开<code>qemu-6.X.X</code>文件夹，<code>Ctrl+Shift+D</code>打开调试配置。如果参考过<a href="https://dunky-z.github.io/2021/08/23/VSCode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/">VSCode中调试程序</a>这篇文章，接下来就很容易。我们只需要将<code>launch.jason</code>文件中的<code>program</code>属性改为<code>$&#123;workspaceFolder&#125;/build/qemu-system-riscv32</code>即可。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>打开<code>qemu-6.X.X/softmmu/main.c</code>文件，在<code>main</code>函数入口处打上断点，即可开始调试。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824194442.png"></p><p>现在只需要点击屏幕上的图标，就可以快速的进行单步调试。</p><p>如果需要进行命令行操作，在屏幕下方打开<code>DEBUG CONSOLE</code>，输入<code>-exec+正常命令行下的命令</code>即可在命令行中进行更多的调试。如查看断点信息<code>-exec info breakpoints</code></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824201427.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>VSCode</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt模仿登录界面-页面反转效果</title>
    <link href="/2021/08/24/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E9%A1%B5%E9%9D%A2%E5%8F%8D%E8%BD%AC%E6%95%88%E6%9E%9C/"/>
    <url>/2021/08/24/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E9%A1%B5%E9%9D%A2%E5%8F%8D%E8%BD%AC%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>设置一个旋转效果，将登录界面旋转翻个面，设置一些网络参数。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210826100416.gif"></p><h2 id="网络参数设置界面布局"><a href="#网络参数设置界面布局" class="headerlink" title="网络参数设置界面布局"></a>网络参数设置界面布局</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824144033.png"></p><h2 id="网络参数设置界面"><a href="#网络参数设置界面" class="headerlink" title="网络参数设置界面"></a>网络参数设置界面</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//loginnetsetwindow.cpp</span><br><span class="hljs-comment">//初始化标题</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginNetSetWindow::initMyTitle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_titleBar-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>m_titleBar-&gt;<span class="hljs-built_in">raise</span>();<br>m_titleBar-&gt;<span class="hljs-built_in">setBackgroundColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>m_titleBar-&gt;<span class="hljs-built_in">setButtonType</span>(MIN_BUTTON);<br>m_titleBar-&gt;<span class="hljs-built_in">setTitleWidth</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>());<br>m_titleBar-&gt;<span class="hljs-built_in">setMoveParentWindowFlag</span>(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginNetSetWindow::initWindow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>QLabel* pBack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QLabel</span>(<span class="hljs-keyword">this</span>);<br>QMovie *movie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QMovie</span>();<br>movie-&gt;<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;:/Resources/NetSetWindow/headBack.gif&quot;</span>);<br>pBack-&gt;<span class="hljs-built_in">setMovie</span>(movie);<br>movie-&gt;<span class="hljs-built_in">start</span>();<br>pBack-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">connect</span>(ui.pButtonOk, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">rotateWindow</span>()));<br><span class="hljs-built_in">connect</span>(ui.pButtonCancel, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">rotateWindow</span>()));<br><br>    ui.comboBoxNetType-&gt;<span class="hljs-built_in">addItem</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;不使用代理&quot;</span>));<br>ui.comboBoxServerType-&gt;<span class="hljs-built_in">addItem</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;不使用高级选项&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginNetSetWindow::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 绘制背景图;</span><br><span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>QPainterPath pathBack;<br>pathBack.<span class="hljs-built_in">setFillRule</span>(Qt::WindingFill);<br>pathBack.<span class="hljs-built_in">addRoundedRect</span>(<span class="hljs-built_in">QRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>(), <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>()), <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<br>painter.<span class="hljs-built_in">fillPath</span>(pathBack, <span class="hljs-built_in">QBrush</span>(<span class="hljs-built_in">QColor</span>(<span class="hljs-number">235</span>, <span class="hljs-number">242</span>, <span class="hljs-number">249</span>)));<br><br>QPainterPath pathBottom;<br>pathBottom.<span class="hljs-built_in">setFillRule</span>(Qt::WindingFill);<br>pathBottom.<span class="hljs-built_in">addRoundedRect</span>(<span class="hljs-built_in">QRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">300</span>, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>(), <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() - <span class="hljs-number">300</span>), <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<br>painter.<span class="hljs-built_in">fillPath</span>(pathBottom, <span class="hljs-built_in">QBrush</span>(<span class="hljs-built_in">QColor</span>(<span class="hljs-number">205</span>, <span class="hljs-number">226</span>, <span class="hljs-number">242</span>)));<br><br>painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(<span class="hljs-built_in">QColor</span>(<span class="hljs-number">160</span> , <span class="hljs-number">175</span> , <span class="hljs-number">189</span>)));<br>painter.<span class="hljs-built_in">drawRoundedRect</span>(<span class="hljs-built_in">QRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>(), <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>()), <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>initMyTitle()</code>就不多说了，和正面登录界面差不多。</p><h3 id="QPainterPath类"><a href="#QPainterPath类" class="headerlink" title="QPainterPath类"></a><code>QPainterPath</code>类</h3><p>它是由一些图形如曲线、矩形、椭圆组成的对象。主要的用途是，能保存已经绘制好的图形。实现图形元素的构造和复用；图形状只需创建一次，然后调用<code>QPainter::drawPath()</code> 函数多次绘制。<code>painterpath </code>可以加入闭合或不闭合的图形( 如：矩形、椭圆和曲线) 。<code>QPainterPath</code> 可用于填充，描边，clipping 。</p><h4 id="setFillRule-设置填充模式"><a href="#setFillRule-设置填充模式" class="headerlink" title="setFillRule()设置填充模式"></a><code>setFillRule()</code>设置填充模式</h4><p>不是很理解<br> <a href="https://doc.qt.io/qt-5/qt.html#FillRule-enum">https://doc.qt.io/qt-5/qt.html#FillRule-enum</a></p><h4 id="addRoundedRect-QRect-0-0-this-gt-width-this-gt-height-3-3-圆角矩形"><a href="#addRoundedRect-QRect-0-0-this-gt-width-this-gt-height-3-3-圆角矩形" class="headerlink" title="addRoundedRect(QRect(0, 0, this-&gt;width(), this-&gt;height()), 3, 3)圆角矩形"></a><code>addRoundedRect(QRect(0, 0, this-&gt;width(), this-&gt;height()), 3, 3)</code>圆角矩形</h4><ul><li><code>QRect(0, 300, this-&gt;width(), this-&gt;height() - 300)</code>设置了矩形的位置及大小</li><li><code>(3,3)</code>表示倒圆角的大小</li></ul><h3 id="setRenderHint-开启反走样"><a href="#setRenderHint-开启反走样" class="headerlink" title="setRenderHint()开启反走样"></a><code>setRenderHint()</code>开启反走样</h3><ul><li><code>QPainter::Antialiasing</code>           告诉绘图引擎应该在可能的情况下进行边的反锯齿绘制</li><li><code>QPainter::TextAntialiasing</code>       尽可能的情况下文字的反锯齿绘制</li><li><code>QPainter::SmoothPixmapTransform</code> 使用平滑的pixmap变换算法(双线性插值算法),而不是近邻插值算</li></ul><h2 id="初始化旋转窗口"><a href="#初始化旋转窗口" class="headerlink" title="初始化旋转窗口"></a>初始化旋转窗口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化旋转的窗口;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RotateWidget::initRotateWindow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_loginWindow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LoginWindow</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// 这里定义了两个信号，需要自己去发送信号;</span><br><span class="hljs-built_in">connect</span>(m_loginWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">rotateWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onRotateWindow</span>()));<br><span class="hljs-built_in">connect</span>(m_loginWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">closeWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">close</span>()));<br><span class="hljs-built_in">connect</span>(m_loginWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">hideWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onHideWindow</span>()));<br><br>m_loginNetSetWindow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LoginNetSetWindow</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-built_in">connect</span>(m_loginNetSetWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">rotateWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onRotateWindow</span>()));<br><span class="hljs-built_in">connect</span>(m_loginNetSetWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">closeWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">close</span>()));<br><span class="hljs-built_in">connect</span>(m_loginNetSetWindow, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">hideWindow</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onHideWindow</span>()));<br><br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">addWidget</span>(m_loginWindow);<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">addWidget</span>(m_loginNetSetWindow);<br><br><span class="hljs-comment">// 这里宽和高都增加，是因为在旋转过程中窗口宽和高都会变化;</span><br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setFixedSize</span>(<span class="hljs-built_in">QSize</span>(m_loginWindow-&gt;<span class="hljs-built_in">width</span>() + <span class="hljs-number">20</span>, m_loginWindow-&gt;<span class="hljs-built_in">height</span>() + <span class="hljs-number">100</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>对正面和反面分别定义了信号槽，当对应的面接收到信号时，执行对应的动作。因为是旋转一百八十度，所以选择函数可以公用。</p><h2 id="旋转窗口"><a href="#旋转窗口" class="headerlink" title="旋转窗口"></a>旋转窗口</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824182705.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 开始旋转窗口;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RotateWidget::onRotateWindow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 如果窗口正在旋转，直接返回;</span><br><span class="hljs-keyword">if</span> (m_isRoratingWindow)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>m_isRoratingWindow = <span class="hljs-literal">true</span>;<br>m_nextPageIndex = (<span class="hljs-built_in">currentIndex</span>() + <span class="hljs-number">1</span>) &gt;= <span class="hljs-built_in">count</span>() ? <span class="hljs-number">0</span> : (<span class="hljs-built_in">currentIndex</span>() + <span class="hljs-number">1</span>);<br>QPropertyAnimation *rotateAnimation = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPropertyAnimation</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;rotateValue&quot;</span>);<br><span class="hljs-comment">// 设置旋转持续时间;</span><br>rotateAnimation-&gt;<span class="hljs-built_in">setDuration</span>(<span class="hljs-number">1500</span>);<br><span class="hljs-comment">// 设置旋转角度变化趋势;</span><br>rotateAnimation-&gt;<span class="hljs-built_in">setEasingCurve</span>(QEasingCurve::InCubic);<br><span class="hljs-comment">// 设置旋转角度范围;</span><br>rotateAnimation-&gt;<span class="hljs-built_in">setStartValue</span>(<span class="hljs-number">0</span>);<br>rotateAnimation-&gt;<span class="hljs-built_in">setEndValue</span>(<span class="hljs-number">180</span>);<br><span class="hljs-built_in">connect</span>(rotateAnimation, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">valueChanged</span>(QVariant)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">repaint</span>()));<br><span class="hljs-built_in">connect</span>(rotateAnimation, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">finished</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onRotateFinished</span>()));<br><span class="hljs-comment">// 隐藏当前窗口，通过不同角度的绘制来达到旋转的效果;</span><br><span class="hljs-built_in">currentWidget</span>()-&gt;<span class="hljs-built_in">hide</span>();<br>rotateAnimation-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-comment">// 旋转结束;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RotateWidget::onRotateFinished</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_isRoratingWindow = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">setCurrentWidget</span>(<span class="hljs-built_in">widget</span>(m_nextPageIndex));<br><span class="hljs-built_in">repaint</span>();<br>&#125;<br>/ 绘制旋转效果;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RotateWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m_isRoratingWindow)<br>    &#123;<br>        <span class="hljs-comment">// 小于90度时;</span><br>        <span class="hljs-keyword">int</span> rotateValue = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">property</span>(<span class="hljs-string">&quot;rotateValue&quot;</span>).<span class="hljs-built_in">toInt</span>();<br>        <span class="hljs-keyword">if</span> (rotateValue &lt;= <span class="hljs-number">90</span>)<br>        &#123;<br>            <span class="hljs-function">QPixmap <span class="hljs-title">rotatePixmap</span><span class="hljs-params">(currentWidget()-&gt;size())</span></span>;<br>            <span class="hljs-built_in">currentWidget</span>()-&gt;<span class="hljs-built_in">render</span>(&amp;rotatePixmap);<br>            <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>            painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing);<br>            QTransform transform;<br>            transform.<span class="hljs-built_in">translate</span>(<span class="hljs-built_in">width</span>() / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>            transform.<span class="hljs-built_in">rotate</span>(rotateValue, Qt::YAxis);<br>            painter.<span class="hljs-built_in">setTransform</span>(transform);<br>            painter.<span class="hljs-built_in">drawPixmap</span>(<span class="hljs-number">-1</span> * <span class="hljs-built_in">width</span>() / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, rotatePixmap);<br>        &#125;<br>        <span class="hljs-comment">// 大于90度时</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            QPixmap <span class="hljs-built_in">rotatePixmap</span>(<span class="hljs-built_in">widget</span>(m_nextPageIndex)-&gt;<span class="hljs-built_in">size</span>());<br>            <span class="hljs-built_in">widget</span>(m_nextPageIndex)-&gt;<span class="hljs-built_in">render</span>(&amp;rotatePixmap);<br>            <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>            painter.<span class="hljs-built_in">setRenderHint</span>(QPainter::Antialiasing);<br>            QTransform transform;<br>            transform.<span class="hljs-built_in">translate</span>(<span class="hljs-built_in">width</span>() / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>            transform.<span class="hljs-built_in">rotate</span>(rotateValue + <span class="hljs-number">180</span>, Qt::YAxis);<br>            painter.<span class="hljs-built_in">setTransform</span>(transform);<br>            painter.<span class="hljs-built_in">drawPixmap</span>(<span class="hljs-number">-1</span> * <span class="hljs-built_in">width</span>() / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, rotatePixmap);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> QStackedWidget::<span class="hljs-built_in">paintEvent</span>(event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="QPropertyAnimation-动画类"><a href="#QPropertyAnimation-动画类" class="headerlink" title="QPropertyAnimation 动画类"></a><code>QPropertyAnimation </code>动画类</h3><p><code>    QPropertyAnimation *rotateAnimation = new QPropertyAnimation(this, &quot;rotateValue&quot;)</code></p><ul><li><code>rotateValue</code>就是这个动画的属性，我们这个动画中变化的就是旋转值，也就是旋转角度。这个属性名完全自己起，也可以改成<code>rotateAngle</code>等等，或者说想做一个平移的动画，也可以取一个<code>moveDist</code>等名字。</li></ul><p>下面这一串就是标准的一套动画流程</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// 设置旋转持续时间;</span><br><span class="hljs-function"><span class="hljs-title">rotateAnimation</span>-&gt;</span>setDuration(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 设置旋转角度变化趋势;</span><br><span class="hljs-function"><span class="hljs-title">rotateAnimation</span>-&gt;</span>setEasingCurve(QEasingCurve::InCubic);<br><span class="hljs-comment">// 设置旋转角度范围;</span><br><span class="hljs-function"><span class="hljs-title">rotateAnimation</span>-&gt;</span>setStartValue(<span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-title">rotateAnimation</span>-&gt;</span>setEndValue(<span class="hljs-number">180</span>);<br><span class="hljs-comment">//开始动画</span><br><span class="hljs-function"><span class="hljs-title">rotateAnimation</span>-&gt;</span>start();<br></code></pre></td></tr></table></figure><h3 id="paintEvent绘图事件"><a href="#paintEvent绘图事件" class="headerlink" title="paintEvent绘图事件"></a><code>paintEvent</code>绘图事件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;rotatewidget.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    RotateWidget w;<br>    w.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们<code>main</code>函数得知，最开始显示的窗口就是<code>RotateWidget</code>。在实例化一个<code>RotateWidget</code>类后，进行了标题栏的初始化工作，然后开始执行<code>w.show()</code>显示，但是此时窗口是不显示的。这是因为我们在<code>RotateWidget</code>的构造函数中进行了设置不显示窗口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setWindowFlags</span>(Qt::FramelessWindowHint | <br>Qt::WindowStaysOnTopHint | <br>Qt::WindowMinimizeButtonHint);<br></code></pre></td></tr></table></figure><p>当运行到<code>    return a.exec()</code>时，Qt会自动调用<code>void RotateWidget::paintEvent()</code>。此时开始正式绘制窗口，但是因为我们还没哟点击登录页面的网络设置按钮，所以<code>m_isRoratingWindow=0</code>。会调用父类的绘图事件，<code>QStackedWidget::paintEvent()</code>，最后也就是<code>BaseWindow::paintEvent()</code>。会将登录页面先绘制出来。</p><p>当我们点击网络设置按钮时，<code>m_isRoratingWindow=1</code>开始绘制旋转画面。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作系统-系统初始化</title>
    <link href="/2021/08/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2021/08/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><h3 id="x86架构概述"><a href="#x86架构概述" class="headerlink" title="x86架构概述"></a>x86架构概述</h3><p><strong>CPU（Central Processing Unit）</strong>：中央处理器，计算机所有设备都围绕它展开工作。</p><ul><li>运算单元：只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。</li><li>数据单元：运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了数据单元。数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。</li><li>控制单元：有了放数据的地方，也有了算的地方，还需要有个指挥到底做什么运算的地方，这就是控制单元。控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。</li></ul><p><strong>内存（Memory）</strong>：CPU本身不能保存大量数据，许多复杂的计算需要将中间结果保存下来就必须用到内存。</p><p><strong>总线（Bus）</strong>：CPU 和其他设备连接，就靠总线，其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。</p><ul><li>地址总线：传输地址数据（我想拿内存中哪个位置的数据）</li><li>数据总线：传输真正的数据</li></ul><p>总线就像CPU和内存之间的高速公路，总线多少位就类似高速公路多少个车道，但两种总线的位数意义不同。</p><p>地址总线的位数决定了访问地址范围有多广，数据总线位数决定了一次能拿多少数据进来。那么 CPU中总线的位数有没有标准呢？如果没有标准，那操作系统作为软件就很难办了，因为软件层没办法实现通用的运算逻辑。早期每家公司的CPU架构都不同，后来历史将x86平台推到了<strong>开放，统一，兼容</strong>的位置。</p><h4 id="8086架构图"><a href="#8086架构图" class="headerlink" title="8086架构图"></a>8086架构图</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721092854.png"></p><p><strong>数据单元：</strong> 8086处理器内部共有8 个 16 位的通用寄存器，分别是 数据寄存器（AX、BX、CX、DX）、指针寄存器（SP、BP）、变址寄存器（SI、DI）。其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。</p><p><strong>控制单元：</strong> IP 寄存器（Instruction Pointer Register）就是指令指针寄存器，它指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。</p><p>如果需要切换进程呢？每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS、DS、SS、ES。</p><p>其中，<strong>CS</strong> 就是代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置；<strong>DS</strong> 是数据段的寄存器（Data Segment Register），通过它可以找到数据在内存中的位置。<strong>SS</strong> 是栈寄存器（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则。<strong>ES</strong>是扩展段寄存器（Extra Segment Register）顾名思义。</p><p>如果CPU运算中需要加载内存中的数据，需要通过 DS 找到内存中的数据，加载到通用寄存器中，应该如何加载呢？对于一个段，有一个起始的地址，而段内的具体位置，我们称为<strong>偏移量（Offset）</strong>。在 CS 和 DS 中都存放着一个段的起始地址。<strong>代码段的偏移量在 IP 寄存器中</strong>，<strong>数据段的偏移量会放在通用寄存器中</strong>。因为段寄存器都是16位的，而地址总线是20位的，所以通过 *<em>起始地址 <em>16+ 偏移量</em></em> 的方式，将寻址位数都变成20位，也就是将CS和DS的值左移4位。</p><p>对于只有20位地址总线的8086来说，寻址空间最大也就是$2^{20}=1\text{M}$，超过这个位置就访问不到了，一个段因为偏移量只有16位，所以一个段最大是$2^{16}=64\text{k}$。</p><h4 id="32位处理器"><a href="#32位处理器" class="headerlink" title="32位处理器"></a>32位处理器</h4><p>随着计算机发展，内存越来越大，总线也越来越宽。在 32 位处理器中，有 32 根地址总线，可以访问 $2^{32}=4\text{G}$ 的内存。使用原来的模式肯定不行了，但是又不能完全抛弃原来的模式，因为这个架构是<strong>开放的</strong>。那么在开发架构的基础上如何保持兼容呢？</p><p>首先，通用寄存器有扩展，可以将 8 个 16 位的扩展到 8 个 32 位的，但是依然可以保留 16 位的和 8 位的使用方式。其中，指向下一条指令的指令指针寄存器 IP，就会扩展成 32 位的，同样也兼容 16 位的。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721103205.png"></p><p>段寄存器改动较大，新的段寄存器都改成了32位的，每个寄存器又分为<strong>段描述符缓存器（Segment Descriptor）</strong>，和<strong>段选择子寄存器（Selector）</strong> ,现在的段寄存器不在是段的起始地址，段的起始地址保存在表格一样的段描述符缓冲器中，段选择子寄存器保存地址在段描述符缓存器中的哪一项。这样，将一个从段寄存器直接拿到的段起始地址，就变成了<strong>先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。</strong></p><p>虽然现在的这种模式和之前的模式不兼容，但是后面这种模式灵活的非常高，可以保持一直兼容下去。在32位的系统架构下，将前一种模式称为<strong>实模式（Real Pattern）</strong>，后一种模式称为<strong>保护模式（Protected Pattern）</strong> 。当系统刚刚启动的时候，CPU 是处于实模式的，这个时候和原来的模式是兼容的。也就是说，哪怕你买了 32 位的 CPU，也支持在原来的模式下运行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721104550.png"></p><blockquote><p>汇编命令学习<br>mov,<br>call, jmp, int, ret, add, or, xor, shl, shr, push, pop, inc, dec, sub, cmp。</p></blockquote><h3 id="BIOS与BootLoader"><a href="#BIOS与BootLoader" class="headerlink" title="BIOS与BootLoader"></a>BIOS与BootLoader</h3><p>BIOS： 基本输入输出系统</p><p>ROM： 只读存储器</p><p>RAM：随机存取存储器</p><p>在我们按下电脑电源键的那一刻，主板就加电了，CPU就要开始执行指令了，但是刚开始操作系统都没，CPU执行什么指令呢？这就有了<code>BIOS</code>，它相当于一个指导手册，告诉CPU接下来要干啥。</p><p>刚开机时，系统初始化代码从ROM读取，将 <code>CS</code> 设置为 <code>0xFFFF</code>，将 <code>IP</code> 设置为 <code>0x0000</code>，所以第一条指令就会指向 <code>0xFFFF0</code>，初始化完成后确定访问指令位置。</p><p>接下来BIOS会检查各个硬件是否正常，检测内容显卡等关键部件的存在于工作状态，设备初始化，执行系统BIOS进行系统检测，更新CMOS中的扩展系统配置数据ESCD。这期间也会建立中断向量表和中断服务程序，因为要使用键盘鼠标都需要中断进行。</p><p>下一步BIOS就得要找操作系统了，操作系统一般安装在硬盘上，但是BIOS得先找到启动盘，启动盘一般安装在第一个扇区，占512字节，会包含启动的相关代码。在Linux中，可以通过<code>Grub2</code>配置这些代码。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">grub2-mkconfig -o <span class="hljs-regexp">/boot/g</span>rub2/grub.cfg<br></code></pre></td></tr></table></figure><p><code>grub2 </code>第一个要安装的就是<code> boot.img</code>。它由 <code>boot.S </code>编译而成，一共 <code>512</code> 字节，正式安装到启动盘的第一个扇区。这个扇区通常称为<code>MBR</code>（Master Boot Record，主引导记录 / 扇区）。</p><p><code>BIOS</code> 完成任务后，会将 <code>boot.img</code> 从硬盘加载到内存中的 <code>0x7c00 </code>来运行。</p><p>由于 <code>512</code> 个字节实在有限，<code>boot.img</code> 做不了太多的事情。它能做的最重要的一个事情就是加载<code> grub2</code> 的另一个镜像 <code>core.img</code>。</p><p><code>core.img</code> 由<code> lzma_decompress.img</code>、<code>diskboot.img</code>、<code>kernel.img</code> 和一系列的模块组成，功能比较丰富，能做很多事情。</p><p><code>boot.img</code> 先加载的是 <code>core.img</code> 的第一个扇区。如果从硬盘启动的话，这个扇区里面是<code> diskboot.img</code>，对应的代码是 <code>diskboot.S</code>。</p><p><code>boot.img</code> 将控制权交给 <code>diskboot.img</code> 后，<code>diskboot.img</code> 的任务就是将<code> core.img</code> 的其他部分加载进来，先是解压缩程序 <code>lzma_decompress.img</code>，再往下是 <code>kernel.img</code>，最后是各个模块<code>module</code>对应的映像。这里需要注意，它不是 Linux 的内核，而是<code> grub</code> 的内核。</p><p>在这之前，我们所有遇到过的程序都非常非常小，完全可以在实模式下运行，但是随着我们加载的东西越来越大，实模式这<code>1M</code> 的地址空间实在放不下了，所以在真正的解压缩之前，<code>lzma_decompress.img</code> 做了一个重要的决定，就是调用 <code>real_to_prot</code>，切换到<strong>保护模式</strong>，这样就能在更大的寻址空间里面，加载更多的东西。</p><p><code>BIOS</code>将加载程序从硬盘的引导扇区加载到指定位置，再跳转到指定位置，将控制权转交给加载程序。加载程序将操作系统代码读取到内存，并将控制权转到操作系统。</p><blockquote><p>Q：BIOS-操作系统，中间经过加载程序。为何不直接读取？<br>A：磁盘文件系统多种多样，硬盘出厂时不能限制只能用一种文件系统，而BIOS也不能加上识别所有文件系统的代码。所有为了灵活性只读取磁盘的一块，由加载程序来识别磁盘的文件系统。</p></blockquote><p>切换到保护模式后，将会做以下这些事，大多数都与内存访问方式有关。</p><p>首先<strong>启动分段</strong>，就是在内存里面<strong>建立段描述符表</strong>，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。</p><p>接着是<strong>启动分页</strong>。能够管理的内存变大了，就需要将内存分成相等大小的块。</p><p><strong>打开Gate20</strong>，也就是第21根地址线的控制线。因为在实模式8086下，一共就20根地址线，最大访问<code>1M</code>的地址空间。切换保护模式的函数<code>DATA32 call real_to_prot </code>会打开<code>Gate A20</code>。</p><p>现在好了，有的是空间了。接下来我们要对压缩过的 <strong>kernel.img 进行解压缩</strong>，然后跳转到 <code>kernel.img</code> 开始运行。</p><h3 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h3><ul><li>start_kernel()<ul><li>INIT_TASK(init_task)</li><li>trap_init()</li><li>mm_init()</li><li>sched_init()</li><li>rest_init()<ul><li>kernel_thread(kernel_init, NULL,CLONE_FS)</li><li>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)</li></ul></li></ul></li></ul><p>内核的启动从入口函数<code>start_kernel()</code> 开始。在 <code>init/main.c</code> 文件中，<code>start_kernel</code> 相当于内核的 <code>main</code> 函数。打开这个函数，我们会发现，里面是各种各样初始化函数 <code>XXXX_init</code>。</p><p>在操作系统里面，先要有个<strong>创始进程</strong>，有一行指令 <code>set_task_stack_end_magic(&amp;init_task)</code>。这里面有一个参数 <code>init_task</code>，它的定义是 <code>struct task_struct init_task = INIT_TASK(init_task)</code>。它是系统创建的第一个进程，我们称为<code>0 </code>号进程。这是唯一一个没有通过<code> fork</code> 或者<code> kernel_thread</code> 产生的进程，是进程列表的第一个。</p><p><code>trap_init()</code>里设置了很多**中断门(Interrupt Gate)**处理各种中断。</p><p><code>mm_init()</code>初始化内存管理模块，<code>sched_init()</code>初始化调度模块。</p><p><code>vfs_caches_init()</code> 会用来初始化基于内存的文件系统 <code>rootfs</code>。在这个函数里面，会调用 <code>mnt_init()-&gt;init_rootfs()</code>。这里面有一行代码，<code>register_filesystem(&amp;rootfs_fs_type)</code>。在 VFS 虚拟文件系统里面注册了一种类型，我们定义为 <code>struct file_system_type rootfs_fs_type</code>。为了兼容各种各样的文件系统，我们需要将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一的接口，这个抽象层就是 <code>VFS（Virtual File System）</code>，虚拟文件系统。</p><p>最后<code>start_kernel()</code>调用<code>rest_init()</code>来做其他方面的初始化，如初始化1号进程，内核态与用户态转化等。</p><p><code>rest_init</code> 的第一大工作是，用 <code>kernel_thread(kernel_init, NULL, CLONE_FS) </code>创建第二个进程，这个是<strong>1 号进程</strong>。这对操作系统意义非凡，因为他将运行第一个用户进程，一旦有了用户进程，运行模式也将发生改变，之前所有资源都是给一个进程用，现在有了用户进程，就会出现抢夺资源的现象。资源也分核心和非核心资源，具有不同权限的进程可以获取不同的资源。<code>x86</code>提供了分层的权限机制，分成四个<code>Ring</code>，越往里权限越高。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210727192141.png"></p><p>操作系统很好地利用了这个机制，将能够访问关键资源的代码放在 <code>Ring0</code>，我们称为<strong>内核态</strong>（Kernel Mode）；将普通的程序代码放在 <code>Ring3</code>，我们称为<strong>用户态</strong>（User Mode）。</p><p>继续探究<code>kernel_thread()</code>这个函数，它的一个参数有一个函数<code>kernel_init</code>，在这个函数里会调用<code>kernel_init_freeable()</code>，里面有这样一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!ramdisk_execute_command)<br>    ramdisk_execute_command = <span class="hljs-string">&quot;/init&quot;</span>;<br></code></pre></td></tr></table></figure><p>先不管<code> ramdisk</code> 是啥，我们回到 <code>kernel_init</code> 里面。这里面有这样的代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ramdisk_execute_command) &#123;<br>  ret = run_init_process(ramdisk_execute_command);<br>....<br>&#125;<br>....<br><span class="hljs-keyword">if</span> (!try_to_run_init_process(<span class="hljs-string">&quot;/sbin/init&quot;</span>) ||<br>    !try_to_run_init_process(<span class="hljs-string">&quot;/etc/init&quot;</span>) ||<br>    !try_to_run_init_process(<span class="hljs-string">&quot;/bin/init&quot;</span>) ||<br>    !try_to_run_init_process(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>我们可以发现，1号进程运行的是一个文件，如果我们打开<code>run_init_process </code>函数，会发现它调用的是<code>do_execve</code>。</p><p>前面讲系统调用的时候，<code>execve</code> 是一个系统调用，它的作用是运行一个执行文件。加一个 <code>do_</code> 的往往是内核系统调用的实现。没错，这就是一个系统调用，它会尝试运行 <code>ramdisk</code> 的“<code>/init”</code>，或者普通文件系统上的<code>“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”</code>。不同版本的 Linux 会选择不同的文件启动，但是只要有一个起来了就可以。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run_init_process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *init_filename)</span></span><br><span class="hljs-function"></span>&#123;<br>  argv_init[<span class="hljs-number">0</span>] = init_filename;<br>  <span class="hljs-keyword">return</span> do_execve(getname_kernel(init_filename),<br>    (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *<span class="hljs-keyword">const</span> __user *)argv_init,<br>    (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *<span class="hljs-keyword">const</span> __user *)envp_init);<br>&#125;<br></code></pre></td></tr></table></figure><p>如何利用执行 <code>init</code> 文件的机会，从内核态回到用户态呢？</p><p>我们从系统调用的过程可以得到启发，“用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态”，然后接着运行。而咱们刚才运行<code> init</code>，是调用 <code>do_execve</code>，正是上面的过程的后半部分，从内核态执行系统调用开始。</p><p><code>do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler</code>，这里面会调用这段内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search_binary_handler</span><span class="hljs-params">(struct linux_binprm *bprm)</span></span><br><span class="hljs-function"></span>&#123;<br>  ......<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> *<span class="hljs-title">fmt</span>;</span><br>  ......<br>  retval = fmt-&gt;load_binary(bprm);<br>  ......<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，我要运行一个程序，需要加载这个二进制文件，这就是我们常说的项目执行计划书。它是有一定格式的。Linux 下一个常用的格式是ELF（Executable and Linkable Format，可执行与可链接格式）。于是我们就有了下面这个定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> <span class="hljs-title">elf_format</span> =</span> &#123;<br>.<span class="hljs-keyword">module</span>  = THIS_MODULE,<br>.load_binary  = load_elf_binary,<br>.load_shlib  = load_elf_library,<br>.core_dump  = elf_core_dump,<br>.min_coredump  = ELF_EXEC_PAGESIZE,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这其实就是先调用 <code>load_elf_binary</code>，最后调用 <code>start_thread</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">start_thread</span><span class="hljs-params">(struct pt_regs *regs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> new_ip, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> new_sp)</span></span><br><span class="hljs-function"></span>&#123;<br>set_user_gs(regs, <span class="hljs-number">0</span>);<br>regs-&gt;fs  = <span class="hljs-number">0</span>;<br>regs-&gt;ds  = __USER_DS;<br>regs-&gt;es  = __USER_DS;<br>regs-&gt;ss  = __USER_DS;<br>regs-&gt;cs  = __USER_CS;<br>regs-&gt;ip  = new_ip;<br>regs-&gt;sp  = new_sp;<br>regs-&gt;flags  = X86_EFLAGS_IF;<br>force_iret();<br>&#125;<br>EXPORT_SYMBOL_GPL(start_thread);<br></code></pre></td></tr></table></figure><p><code>struct pt_regs</code>，看名字里的 <code>register</code>，就是寄存器啊！这个结构就是在系统调用的时候，内核中保存用户态运行上下文的，里面将用户态的代码段 <code>CS </code>设置为 <code>__USER_CS</code>，将用户态的数据段 <code>DS</code> 设置为 <code>__USER_DS</code>，以及<code>指令指针寄存器 IP</code>、<code>栈指针寄存器 SP</code>。这里相当于补上了原来系统调用里，保存寄存器的一个步骤。</p><p>最后的 <code>iret</code> 是干什么的呢？它是用于从系统调用中返回。这个时候会恢复寄存器。从哪里恢复呢？按说是从进入系统调用的时候，保存的寄存器里面拿出。好在上面的函数补上了寄存器。<code>CS</code> 和指令指针寄存器 <code>IP</code> 恢复了，指向用户态下一个要执行的语句。<code>DS</code> 和函数栈指针 <code>SP</code> 也被恢复了，指向用户态函数栈的栈顶。所以，下一条指令，就从用户态开始运行了。</p><p>init 终于从内核到用户态了。一开始到用户态的是 ramdisk 的 init，后来会启动真正根文件系统上的 init，成为所有用户态进程的祖先。</p><p>为什么会有 ramdisk 这个东西呢？还记得上一节咱们内核启动的时候，配置过这个参数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">initrd16</span> /boot/initramfs-<span class="hljs-number">3</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span>-<span class="hljs-number">862</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.img<br></code></pre></td></tr></table></figure><p>就是这个东西，这是一个基于内存的文件系统。为啥会有这个呢？</p><p>是因为刚才那个 init 程序是在文件系统上的，文件系统一定是在一个存储设备上的，例如硬盘。Linux 访问存储设备，要有驱动才能访问。如果存储系统数目很有限，那驱动可以直接放到内核里面，反正前面我们加载过内核到内存里了，现在可以直接对存储系统进行访问。</p><p>但是存储系统越来越多了，如果所有市面上的存储系统的驱动都默认放进内核，内核就太大了。这该怎么办呢？</p><p>我们只好先弄一个基于内存的文件系统。内存访问是不需要驱动的，这个就是 <code>ramdisk</code>。这个时候，<code>ramdisk</code> 是根文件系统。</p><p>然后，我们开始运行 <code>ramdisk</code> 上的 <code>/init</code>。等它运行完了就已经在用户态了。<code>/init</code> 这个程序会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。有了真正的根文件系统，<code>ramdisk </code>上的 <code>/init</code> 会启动文件系统上的 <code>init</code>。</p><p>接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了。</p><p>至此，用户态进程有了一个祖宗，那内核态的进程呢？这就是<code>rest_init</code>接下来要做的是，<strong>创建2号线程</strong>。</p><p><code>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES) </code>又一次使用 <code>kernel_thread</code> 函数创建进程。这里的函数 <code>kthreadd</code>，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>Linux 提供了<code>glibc</code>这个库封装了系统调用，方便用户使用。那么在打开一个文件时，<code>glibc</code>是如何调用内核的<code>open</code>的呢？</p><p>在 <code>glibc</code> 的源代码中，有个文件<code> syscalls.list</code>，里面列着所有 <code>glibc</code> 的函数对应的系统调用，就像下面这个样子：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># File <span class="hljs-type">name</span> Caller  Syscall <span class="hljs-type">name</span>    Args    Strong <span class="hljs-type">name</span> Weak names<br><span class="hljs-keyword">open</span>    -  <span class="hljs-keyword">open</span>    Ci:siv  __libc_open __open <span class="hljs-keyword">open</span><br></code></pre></td></tr></table></figure><p>另外，<code>glibc</code> 还有一个脚本 <code>make-syscall.sh</code>，可以根据上面的配置文件，对于每一个封装好的系统调用，生成一个文件。这个文件里面定义了一些宏，例如 <code>#define SYSCALL_NAME open</code>。</p><p><code>glibc</code> 还有一个文件 <code>syscall-template.S</code>，使用上面这个宏，定义了这个系统调用的调用方式。</p><p>对于任何一个系统调用，会调用<code> DO_CALL</code>。这也是一个宏，这个宏 32 位和 64 位的定义是不一样的。</p><h4 id="32位系统调用过程"><a href="#32位系统调用过程" class="headerlink" title="32位系统调用过程"></a>32位系统调用过程</h4><p>i386 目录下的<code> sysdep.h</code> 文件</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs llvm">/* Linux takes system <span class="hljs-keyword">call</span> arguments in registers:<br>  syscall number  <span class="hljs-variable">%eax</span>       <span class="hljs-keyword">call</span>-clobbered<br>  arg <span class="hljs-number">1</span>    <span class="hljs-variable">%ebx</span>       <span class="hljs-keyword">call</span>-saved<br>  arg <span class="hljs-number">2</span>    <span class="hljs-variable">%ecx</span>       <span class="hljs-keyword">call</span>-clobbered<br>  arg <span class="hljs-number">3</span>    <span class="hljs-variable">%edx</span>       <span class="hljs-keyword">call</span>-clobbered<br>  arg <span class="hljs-number">4</span>    <span class="hljs-variable">%esi</span>       <span class="hljs-keyword">call</span>-saved<br>  arg <span class="hljs-number">5</span>    <span class="hljs-variable">%edi</span>       <span class="hljs-keyword">call</span>-saved<br>  arg <span class="hljs-number">6</span>    <span class="hljs-variable">%ebp</span>       <span class="hljs-keyword">call</span>-saved<br>......<br>*/<br>#<span class="hljs-keyword">define</span> DO_CALL(syscall_name<span class="hljs-punctuation">,</span> args)                           <br>    PUSHARGS_##args                             <br>    DOARGS_##args                                <br>    movl $SYS_ify (syscall_name)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%eax</span><span class="hljs-comment">;                          </span><br>    ENTER_KERNEL                                 <br>    POPARGS_##args<br></code></pre></td></tr></table></figure><p>这里，我们将请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器 <code>eax</code> 里面，然后执行 <code>ENTER_KERNEL</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> ENTER_KERNEL int $0x80</span><br></code></pre></td></tr></table></figure><p><code>ENTER_KERNEL</code>就是一个软中断，通过它可以陷入(trap)内核。</p><p>在内核启动的时候，还记得有一个 <code>trap_init()</code>，这是一个软中断的陷入门。当接到一个系统调用时，<code>trap_init()</code>就会调用<code>entry_INT80_32</code>。</p><p>通过 <code>push</code> 和 <code>SAVE_ALL</code> 将当前用户态的寄存器，保存在 <code>pt_regs</code> 结构里面，然后调用 <code>do_syscall_32_irqs_on</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210809163844.png"></p><h4 id="64-位系统调用过程"><a href="#64-位系统调用过程" class="headerlink" title="64 位系统调用过程"></a>64 位系统调用过程</h4><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210809170711.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210809171554.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Linux操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VSCode调试RISCV程序</title>
    <link href="/2021/08/23/VSCode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/08/23/VSCode%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>本文主要涉及VSCode的相关配置，编译及调试工具需要提前安装好。</p><ul><li>已经安装好<code>riscv-toolchain</code>，包括<code>riscv64-unknown-elf-gcc</code>，<code>riscv64-unknown-elf-gdb</code></li><li>已经安装好<code>qemu</code>，包括<code>riscv32-softmmu,riscv32-linux-user,riscv64-softmmu,riscv64-linux-user</code></li><li>已经安装好<code>g++</code>,<code>gdb</code></li></ul><h2 id="调试流程简介"><a href="#调试流程简介" class="headerlink" title="调试流程简介"></a>调试流程简介</h2><p>对于我这样的新手，要调试一个项目源码最怕的就是开始，也就是怎么能把项目跑起来。</p><p>我们以一个简单的<code>test</code>项目，看看在VSCode里怎么跑起来。</p><p>拿到源码后，将其以文件夹形式，加入到VSCode中，<code>文件-打开文件夹-选择test项目文件夹</code>。项目就会在VSCode 中打开，但是此时我们还无法编译运行，我们需要在VSCode上<br>构建出一个C语言的编译与调试环境。</p><p>首先得安装一个插件<code>C/C++</code>，打开插件中心<code>Ctrl+Shit+X</code>，搜索，安装。</p><p>然后输入<code>F5</code>，会弹出对话框，选择<code>C++(GDB)</code>，继续选择<code>g++</code>。VSCode会自动创建<code>.vscode</code>文件夹，已经两个文件<code>launch.json</code>和<code>tasks.json</code>。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210823193157.png"></p><p><code>launch.json</code>用来配置调试环境，<code>tasks.json</code>主要用来配置编译环境，当然也可以配置其他任务。<code>task.json</code>里配置的每个任务其实就相当于多开一个控制台。</p><h2 id="配置tasks-json"><a href="#配置tasks-json" class="headerlink" title="配置tasks.json"></a>配置<code>tasks.json</code></h2><p>因为我们先要编译源码，生成<code>.out</code>或者<code>.exe</code>文件，才能调试，所以先进行编译任务配置。</p><p>自动生成的文件是个配置模板，我们可以根据自己的实际情况进行配置，也有一部分可以保持默认。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// tasks.json</span><br>&#123;<br>    <span class="hljs-comment">// https://code.visualstudio.com/docs/editor/tasks</span><br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>        &#123;<br>             <span class="hljs-comment">// 任务的名字，注意是大小写区分的</span><br>             <span class="hljs-comment">//会在launch中调用这个名字</span><br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++: g++ build active file&quot;</span>, <br>             <span class="hljs-comment">// 任务执行的是shell</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>, <br>             <span class="hljs-comment">// 命令是g++</span><br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;g++&quot;</span>, <br>             <span class="hljs-comment">//g++ 后面带的参数</span><br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;&#x27;-Wall&#x27;&quot;</span>,<br>                <span class="hljs-string">&quot;-g&quot;</span>,           <span class="hljs-comment">// 生成调试信息，否则无法进入断点</span><br>                <span class="hljs-string">&quot;&#x27;-std=c++17&#x27;&quot;</span>,     <span class="hljs-comment">//使用c++17标准编译</span><br>                <span class="hljs-string">&quot;&#x27;$&#123;file&#125;&#x27;&quot;</span>,        <span class="hljs-comment">//当前文件名</span><br>                <span class="hljs-string">&quot;-o&quot;</span>,               <span class="hljs-comment">//对象名，不进行编译优化</span><br>                <span class="hljs-string">&quot;&#x27;$&#123;fileBasenameNoExtension&#125;.exe&#x27;&quot;</span>,  <span class="hljs-comment">//当前文件名（去掉扩展名）</span><br>            ],<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>如果项目是通过Makefile编译的，那就更加简单，只需要配置一个任务即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>    &#123;<br>       <span class="hljs-comment">//任务的名字方便执行</span><br>      <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Make Project&quot;</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>      <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>,<br>      <span class="hljs-attr">&quot;args&quot;</span>:[<br>          <span class="hljs-comment">//8线程编译</span><br>          <span class="hljs-string">&quot;-j8&quot;</span>,<br>      ],<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>运行该任务时就会执行<code>make</code>命令进行编译。</p><h2 id="配置launch-json"><a href="#配置launch-json" class="headerlink" title="配置launch.json"></a>配置<code>launch.json</code></h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// launch.json</span><br><br>&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-comment">//调试任务的名字</span><br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;g++ - Build and debug active file&quot;</span>, <br>            <span class="hljs-comment">//在launch之前运行的任务名，这个名字一定要跟tasks.json中的任务名字大小写一致</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;C/C++: g++ build active file&quot;</span>,  <br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-comment">//需要运行的是当前打开文件的目录中，</span><br>            <span class="hljs-comment">//名字和当前文件相同，但扩展名为exe的程序</span><br>            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>, <br>            <span class="hljs-attr">&quot;args&quot;</span>: [],<br>            <span class="hljs-comment">// 选为true则会在打开控制台后停滞，暂时不执行程序</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-comment">// 当前工作路径：当前文件所在的工作空间</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;</span>: [],<br>            <span class="hljs-comment">// 是否使用外部控制台</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,  <br>            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;<br>            ]<br>        &#125;]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>经过以上配置后，我们打开<code>main.cpp</code>文件，在<code>cout</code>处打一个断点，按<code>F5</code>，即可编译，运行，调试。一定要打开<code>main.cpp</code>文件，不能随便打开文件就开始哦。因为我们在配置时使用了一些预定义，比如<code>$&#123;file&#125;</code>表示当前文件，所以只有打开需要调试的文件才能开始。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210823201621.png"></p><p>程序将会在<code>cout</code>语句停下来。</p><p>我们可以注意一下界面下方的控制台，可以更直观了解<code>launch.jason</code>和<code>tasks.jason</code>。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210823202012.png"></p><p>右边的框，就是我们在<code>tasks.jason</code>中配置的任务，左边的框就是我们在<code>tasks.jason</code>中<code>command</code>以及<code>args</code>的内容，他就是帮我们提前写好编译的选项。然后在shell中运行。</p><h2 id="编译调试RISCV程序"><a href="#编译调试RISCV程序" class="headerlink" title="编译调试RISCV程序"></a>编译调试RISCV程序</h2><p>了解以上这些，就可以按需配置所需的环境了。我们还是从<code>tasks.jason</code>开始。因为开发用的电脑是<code>x86</code>的，所以先要编译出<code>riscv</code>的程序，再用模拟器模拟出<code>rsicv</code>的环境，然后在模拟的环境中运行程序，最后才能开始调试。</p><p>假设已经安装好开头所提到的工具。首先配置<code>tasks.jason</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-comment">// 编译当前代码</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++(RISCV): Build active file&quot;</span>,<br>            <span class="hljs-comment">// 编译器的位置</span><br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;/opt/riscv/bin/riscv64-unknown-elf-g++&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-Wall&quot;</span>, <span class="hljs-comment">// 开启所有警告</span><br>                <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-comment">// 生成调试信息s</span><br>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>,<br>                <span class="hljs-string">&quot;-o&quot;</span>,<br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span> <span class="hljs-comment">// 我选择将可执行文件放在debug目录下</span><br>            ],<br>            <span class="hljs-comment">// 当前工作路径：执行当前命令时所在的路径</span><br>            <span class="hljs-attr">&quot;options&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>            &#125;,<br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span>: [<br>                <span class="hljs-string">&quot;$gcc&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-comment">// 启动qemu供调试器连接</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Run Qemu Server(RISCV)&quot;</span>,<br>            <span class="hljs-attr">&quot;dependsOn&quot;</span>: <span class="hljs-string">&quot;C/C++(RISCV): Build active file&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;qemu-system-riscv64&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-g&quot;</span>,<br>                <span class="hljs-string">&quot;65500&quot;</span>, <span class="hljs-comment">// gdb端口，自己定义</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>            ],<br>        &#125;,<br>        &#123;<br>            <span class="hljs-comment">// 有时候qemu有可能没法退出，故编写一个任务用于强行结束qemu进程</span><br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;Kill Qemu Server(RISCV)&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;ps -C qemu-riscv64 --no-headers | cut -d \\  -f 1 | xargs kill -9&quot;</span>,<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tasks.jason</code>是可以配置多个任务的，第一个任务用来编译成<code>riscv</code>架构下的程序，第二个任务用来启动qemu，让程序在qemu上运行起来。</p><p>第一个任务中，<code>command</code>就是配置编译器<code>riscv64-unkonown-elf-gcc</code>的属性，第二个任务中，<code>command</code>是配置qemu模拟器<code>qemu-system-riscv32</code>的属性。第三个任务中，用来配置结束qemu模拟器的命令。</p><p>接下来配置<code>launch.jason</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;</span>: [<br>        &#123; <br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;C/C++(RISCV) - Debug Active File&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/debug/$&#123;fileBasenameNoExtension&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [],<br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;</span>: [],<br>            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;<br>            ],<br>            <span class="hljs-comment">// RISC-V工具链中的gdb</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;/opt/riscv/bin/riscv64-unknown-elf-gdb&quot;</span>, <br>            <span class="hljs-comment">// 这里需要与task.json中定义的端口一致</span><br>            <span class="hljs-attr">&quot;miDebuggerServerAddress&quot;</span>: <span class="hljs-string">&quot;localhost:65500&quot;</span> <br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在配置<code>x86</code>下的调试环境时，<code>launch.jason</code>中有个<code>  &quot;preLaunchTask&quot;: &quot;C/C++: g++ build active file&quot;</code>，属性，这个属性的目的是在启动调试之前，先执行任务名字为<code>&quot;C/C++: g++ build active file&quot;</code>任务，也是就编译的任务。</p><p>因为启动qemu会导致阻塞，所以这里没有加<code>preLaunchTask</code>，在启动调试之前，先把qemu运行起来。输入<code>Ctrl+Shift+P</code>，打开VSCode命令行。输入<code>Run Task</code>，</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824094556.png"></p><p>点击第一个，选择任务，我们可以看到出现的三个任务就是我们在<code>tasks.jason</code>中配置的三个任务。选择第一个Build，编译出程序，再重复操作，选择第三个执行QEMU任务。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210824094609.png"></p><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><p><a href="https://code.visualstudio.com/docs/editor/variables-reference#_predefined-variables">官网</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>万能VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GDB</tag>
      
      <tag>RISCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信（IPC）之信号量（Semaphore）</title>
    <link href="/2021/08/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89/"/>
    <url>/2021/08/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。</p><p>信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即<code>P</code>)和发送（即<code>V</code>)信息操作。最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。</p><p>由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：</p><p><code>P(sv)</code>：如果<code>sv</code>的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</p><p><code>V(sv)</code>：如果有其他进程因等待<code>sv</code>而被挂起，就让它恢复运行，如果没有进程因等待<code>sv</code>而挂起，就给它加1.</p><p>举个例子，就是两个进程共享信号量<code>sv</code>，一旦其中一个进程执行了<code>P(sv)</code>操作，它将得到信号量，并可以进入临界区，使<code>sv</code>减1。而第二个进程将被阻止进入临界区，因为当它试图执行<code>P(sv)</code>时，<code>sv</code>为0，它会被挂起以等待第一个进程离开临界区域并执行<code>V(sv)</code>释放信号量，这时第二个进程就可以恢复执行。</p><p>本文<a href="https://github.com/Dunky-Z/learning-linux/blob/main/IPC/Semaphore/main.c">代码同步在这里</a>。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件sys/sem.h中。</p><h3 id="semget"><a href="#semget" class="headerlink" title="semget()"></a><code>semget()</code></h3><p>它的作用是创建一个新信号量或取得一个已有信号量，原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">int</span> num_sems, <span class="hljs-keyword">int</span> sem_flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>key</code>是整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用<code>semget()</code>函数并提供一个键，再由系统生成一个相应的信号标识符（<code>semget()</code>函数的返回值），只有<code>semget()</code>函数才直接使用信号量键，所有其他的信号量函数使用由<code>semget()</code>函数返回的信号量标识符。如果多个程序使用相同的<code>key</code>值，<code>key</code>将负责协调工作。</p></li><li><p><code>num_sems</code>指定需要的信号量数目，它的值几乎总是1。</p></li><li><p><code>sem_flags</code>是一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值<code>IPC_CREAT</code>做按位或操作。设置了<code>IPC_CREAT</code>标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而<code>IPC_CREAT | IPC_EXCL</code>则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。</p></li></ul><p><code>semget()</code>函数成功返回一个相应信号标识符（非零），失败返回<code>-1</code>.</p><h3 id="semop"><a href="#semop" class="headerlink" title="semop()"></a><code>semop()</code></h3><p>它的作用是改变信号量的值，原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, struct sembuf *sem_opa, <span class="hljs-keyword">size_t</span> num_sem_ops)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>sem_id</code>是由<code>semget()</code>返回的信号量标识符，<code>sembuf</code>结构的定义如下：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span>&#123;</span><br>    <span class="hljs-keyword">short</span> sem_num; <span class="hljs-comment">// 除非使用一组信号量，否则它为0</span><br>    <span class="hljs-keyword">short</span> sem_op;  <span class="hljs-comment">// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，</span><br>                <span class="hljs-comment">// 一个是+1，即V（发送信号）操作。</span><br>    <span class="hljs-keyword">short</span> sem_flg; <span class="hljs-comment">// 通常为SEM_UNDO,使操作系统跟踪信号，</span><br>                <span class="hljs-comment">// 并在进程没有释放该信号量而终止时，操作系统释放信号量</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><code>num_sem_ops</code>：操作<code>sops</code>中的操作个数，通常取值为1<h3 id="semctl"><a href="#semctl" class="headerlink" title="semctl()"></a><code>semctl()</code></h3></li></ul><p>该函数用来直接控制信号量信息，它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, <span class="hljs-keyword">int</span> sem_num, <span class="hljs-keyword">int</span> command, ...)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>如果有第四个参数，它通常是一个<code>union semum</code>结构，定义如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">semun</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semid_ds</span> *<span class="hljs-title">buf</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *arry;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>前两个参数与前面一个函数中的一样，<code>command</code>通常是下面两个值中的其中一个</p></li><li><p><code>SETVAL</code>：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。</p></li><li><p><code>IPC_RMID</code>：用于删除一个已经无需继续使用的信号量标识符。</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信（IPC）之消息队列（MessageQueue）</title>
    <link href="/2021/08/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MessageQueue%EF%BC%89/"/>
    <url>/2021/08/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MessageQueue%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 </p><p>每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p><p>本文<a href="https://github.com/Dunky-Z/learning-linux/tree/main/IPC/MessageQueue">代码同步在这里</a>。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="msgget"><a href="#msgget" class="headerlink" title="msgget()"></a><code>msgget()</code></h3><p>该函数用来创建和访问一个消息队列。它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msgget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span>, key, <span class="hljs-keyword">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>key</code>：与其他的IPC机制一样，程序<strong>必须提供一个键</strong>来命名某个特定的消息队列。</li><li><code>msgflg</code>是一个权限标志，表示消息队列的<strong>访问权限</strong>，它与文件的访问权限一样。<code>msgflg</code>可以与<code>IPC_CREAT</code>做或操作，表示当key所命名的消息队列不存在时创建一个消息队列，如果key所命名的消息队列存在时，<code>IPC_CREAT</code>标志会被忽略，而只返回一个标识符。</li></ul><p>它返回一个以<code>key</code>命名的消息队列的标识符（非零整数），失败时返回<code>-1</code>.</p><h3 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd()"></a><code>msgsnd()</code></h3><p>该函数用来把消息添加到消息队列中。它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msgsend</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *msg_ptr, <span class="hljs-keyword">size_t</span> msg_sz, <span class="hljs-keyword">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>msgid</code>是由<code>msgget</code>函数返回的消息队列标识符。</li><li><code>msg_ptr</code>是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针<code>msg_ptr</code>所指向的消息结构一定要是以一个<strong>长整型成员变量开始的结构体</strong>，接收函数将用这个成员来确定消息的类型。所以消息结构要定义成这样：   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_message</span> &#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> message_type;<br>    <span class="hljs-comment">/* The data you wish to transfer */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><code>msg_sz</code> 是<code>msg_ptr</code>指向的消息的长度</li><li><code>msgflg</code> 用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情</li><li>如果调用成功，消息数据的副本将被放到消息队列中，并返回<code>0</code>，失败时返回<code>-1</code>.</li></ul><h3 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv()"></a><code>msgrcv()</code></h3><p>该函数用来从一个消息队列获取消息，它的原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msgrcv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid, <span class="hljs-keyword">void</span> *msg_ptr, <span class="hljs-keyword">size_t</span> msg_st, <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> msgtype, <span class="hljs-keyword">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>前三个参数参照前面的解释</li><li><code>msgtype</code> 可以实现一种简单的接收优先级。如果<code>msgtype</code>为<code>0</code>，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。如果它小于零，就获取类型等于或小于<code>msgtype</code>的绝对值的第一个消息。</li><li><code>msgflg</code> 用于控制当队列中没有相应类型的消息可以接收时将发生的事情。</li><li>调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由<code>msg_ptr</code>指向的用户分配的缓存区中，然后删除消息队列中的对应消息。失败时返回<code>-1</code>。</li></ul><h3 id="msgctl"><a href="#msgctl" class="headerlink" title="msgctl()"></a><code>msgctl()</code></h3><p>该函数用来控制消息队列，它与共享内存的shmctl函数相似，它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msgctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid, <span class="hljs-keyword">int</span> command, struct msgid_ds *buf)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>msgid</code>同上</li><li><code>command</code>是将要采取的动作，它可以取3个值:<ul><li><code>IPC_STAT</code>：把<code>msgid_ds</code>结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖<code>msgid_ds</code>的值。</li><li><code>IPC_SET</code>：如果进程有足够的权限，就把消息列队的当前关联值设置为msgid_ds结构中给出的值</li><li><code>IPC_RMID</code>：删除消息队列</li></ul></li><li><code>buf</code>是指向<code>msgid_ds</code>结构的指针，它指向消息队列模式和访问权限的结构。<code>msgid_ds</code>结构至少包括以下成员：   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgid_ds</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">uid_t</span> shm_perm.uid;<br>    <span class="hljs-keyword">uid_t</span> shm_perm.gid;<br>    <span class="hljs-keyword">mode_t</span> shm_perm.mode;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>成功时返回0，失败时返回-1.<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//msgsnd</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TXT 512</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> msg_type;<br>    <span class="hljs-keyword">char</span> msg[MAX_TXT];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> <span class="hljs-title">message</span>;</span><br>    <span class="hljs-keyword">int</span> msgid = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span> buffer[BUFSIZ];<br>    <span class="hljs-keyword">key_t</span> msgKey = ftok(<span class="hljs-string">&quot;./msgsnd.c&quot;</span>, <span class="hljs-number">0</span>);<br>    msgid = msgget(msgKey, <span class="hljs-number">0666</span> | IPC_CREAT);<br><br>    <span class="hljs-keyword">if</span> (msgid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;masget failed error: %d\n&quot;</span>, errno);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter some text: \n&quot;</span>);<br>        fgets(buffer, BUFSIZ, <span class="hljs-built_in">stdin</span>);<br>        message.msg_type = <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意2</span><br>        <span class="hljs-built_in">strcpy</span>(message.msg, buffer);<br><br>        <span class="hljs-comment">// 向队列里发送数据</span><br>        <span class="hljs-keyword">if</span> (msgsnd(msgid, (<span class="hljs-keyword">void</span> *)&amp;message, MAX_TXT, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgsnd failed\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-comment">// 输入end结束输入</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(buffer, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//msgrcv</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TXT 512</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> msg_type;<br>    <span class="hljs-keyword">char</span> msg[MAX_TXT];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> <span class="hljs-title">message</span>;</span><br>    <span class="hljs-keyword">int</span> msgid = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> msgtype = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">key_t</span> msgKey = ftok(<span class="hljs-string">&quot;./msgsnd.c&quot;</span>, <span class="hljs-number">0</span>);<br>    msgid = msgget(msgKey, <span class="hljs-number">0666</span> | IPC_CREAT);<br><br>    <span class="hljs-keyword">if</span> (msgid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;masget failed error: %d\n&quot;</span>, errno);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (msgrcv(msgid, (<span class="hljs-keyword">void</span> *)&amp;message, BUFSIZ, msgtype, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgsnd failed\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You wrote: %s\n&quot;</span>, message.msg);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(message.msg, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210819142858.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210819142913.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(Ubuntu)环境下安装VSCode</title>
    <link href="/2021/08/19/Linux-Ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85VSCode/"/>
    <url>/2021/08/19/Linux-Ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85VSCode/</url>
    
    <content type="html"><![CDATA[<p>本来不想写这一篇的，安装VSCode时随便搜一下就OK了，但是因为APT源中没有VSCode，所以需要找下载网址，几次的安装经历下来，找下载网址也经历了一番折腾。今天又要安装一遍，就顺手记录一下吧。以后翻自己记录总比翻全网记录方便。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>其实最完备安装教程在<a href="https://code.visualstudio.com/docs/setup/linux">官方文档</a>里。本文也算是对官方文档的一个翻译版吧。</p><h2 id="基于-Debian-和-Ubuntu-的发行版"><a href="#基于-Debian-和-Ubuntu-的发行版" class="headerlink" title="基于 Debian 和 Ubuntu 的发行版"></a>基于 Debian 和 Ubuntu 的发行版</h2><p>如果<a href="https://go.microsoft.com/fwlink/?LinkID=760868">下载了.deb安装包</a>，那么只需要一个命令就可以完成安装了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> ./&lt;<span class="hljs-keyword">file</span>&gt;.deb<br></code></pre></td></tr></table></figure><p>无奈的是，我需要在开发机安装，无法下载安装包，但是我又不想用<code>ftp</code>传来传去，要是<code>apt</code>能完成，绝不单独下载安装包。</p><p>可以使用以下脚本手动安装存储库和密钥</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -qO- https:<span class="hljs-regexp">//</span>packages.microsoft.com<span class="hljs-regexp">/keys/mi</span>crosoft.asc | gpg --dearmor &gt; packages.microsoft.gpg<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo install -o root -g root -m <span class="hljs-number">644</span> packages.microsoft.gpg /etc/apt/<span class="hljs-keyword">trusted</span>.gpg.d/<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sudo sh -c &#x27;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main&quot;</span> &gt; <span class="hljs-string">/etc/apt/sources.list.d/vscode.list</span>&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> packages.microsoft.gpg<br></code></pre></td></tr></table></figure><p>更新与安装</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">sudo apt install apt-transport-https<br>sudo apt update<br>sudo apt install <span class="hljs-keyword">code</span> # or <span class="hljs-keyword">code</span>-insiders<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作系统-内存管理</title>
    <link href="/2021/08/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h2><p>计算机所谓的“计算”指的是：</p><ul><li>进程和线程对于CPU的使用</li><li>对内存的管理</li></ul><h3 id="独享内存空间的原理"><a href="#独享内存空间的原理" class="headerlink" title="独享内存空间的原理"></a>独享内存空间的原理</h3><p>每个进程都独享一段内存空间，并且真实物理内存地址对进程不可见，操作系统会给进程分配一个虚拟地址，每个进程看到的内存地址都是从0开始。操作系统会将不同进程的虚拟地址和不同内存的物理地址做映射。当程序访问虚拟地址时，由内核的数据结构进行转换，转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址。</p><h3 id="规划虚拟地址空间"><a href="#规划虚拟地址空间" class="headerlink" title="规划虚拟地址空间"></a>规划虚拟地址空间</h3><p>通过以上的原理，我们可以看出，操作系统的内存管理，主要分为三个方面。</p><ol><li>物理内存的管理；</li><li>虚拟地址的管理；</li><li>虚拟地址和物理地址如何映射；</li></ol><p>进程获取了一段独立的虚拟内存空间后，可以不用管其他进程，“任意”使用这片内存，但是也有一点规则。这篇内存需要存放内核态和用户态的内容。高地址存放内核态的内容，低地址存放用户态的内容。具体分界线64位与32位不同，暂不深究。</p><p>我们从最低位开始排起，先是<strong>Text Segment、Data Segment 和 BSS Segment</strong>。Text Segment 是存放二进制可执行代码的位置，Data Segment 存放静态常量，BSS Segment 存放未初始化的静态变量。是不是觉得这几个名字很熟悉？没错，咱们前面讲 ELF 格式的时候提到过，在二进制执行文件里面，就有这三个部分。这里就是把二进制执行文件的三个部分加载到内存里面。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129170110.png"></p><p>接下来是<strong>堆</strong>（Heap）<strong>段</strong>。堆是往高地址增长的，是用来动态分配内存的区域，<code>malloc</code> 就是在这里面分配的。<br>接下来的区域是<strong>Memory Mapping Segment</strong>。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将 so 文件映射到了内存中。<br>再下面就是<strong>栈</strong>（Stack）<strong>地址段</strong>。主线程的函数调用的函数栈就是用这里的。</p><p>普通进程不能访问内核空间，如果需要进行更高权限的工作，就需要系统调用进入内核。每一段进程的内存空间存放的内容各不相同，但是进入内核后看到的都是同一个内核空间，同一个进程列表。</p><p>内核的代码访问内核的数据结构，大部分的情况下都是使用虚拟地址的，虽然内核代码权限很大，但是能够使用的虚拟地址范围也只能在内核空间，也即内核代码访问内核数据结构。</p><p>接下来，我们需要知道，如何将其映射成为物理地址呢？</p><p>咱们前面讲 x86 CPU 的时候，讲过分段机制，咱们规划虚拟空间的时候，也是将空间分成多个段进行保存。我们来看看分段机制的原理。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129182908.png"></p><p>分段机制下的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。段选择子就保存在咱们前面讲过的段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。段表里面保存的是这个段的<strong>基地址</strong>、<strong>段的界限</strong>和<strong>特权等级</strong>等。虚拟地址中的段内偏移量应该位于 0 和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</p><p>例如，我们将上面的虚拟空间分成以下 4 个段，用 0～3 来编号。每个段在段表中有一个项，在物理空间中，段的排列如下图的右边所示。如果要访问段 2 中偏移量 600 的虚拟地址，我们可以计算出物理地址为，段 2 基地址 2000 + 偏移量 600 = 2600。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129183334.png"></p><p>在 Linux 里面，段表全称<strong>段描述符表</strong>（segment descriptors），放在<strong>全局描述符表 GDT</strong>（Global Descriptor Table）里面，会有下面的宏来初始化段描述符表里面的表项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GDT_ENTRY_INIT(flags, base, limit) &#123; &#123; &#123; \</span><br><span class="hljs-meta">    .a = ((limit) &amp; 0xffff) | (((base) &amp; 0xffff) &lt;&lt; 16), \</span><br><span class="hljs-meta">    .b = (((base) &amp; 0xff0000) &gt;&gt; 16) | (((flags) &amp; 0xf0ff) &lt;&lt; 8) | \</span><br><span class="hljs-meta">      ((limit) &amp; 0xf0000) | ((base) &amp; 0xff000000), \</span><br><span class="hljs-meta">  &#125; &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>一个段表项由段基地址 base、段界限 limit，还有一些标识符组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = &#123; .gdt = &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_X86_64</span><br>  [GDT_ENTRY_KERNEL32_CS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc09b</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_KERNEL_CS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xa09b</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_KERNEL_DS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc093</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER32_CS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0fb</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_DS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0f3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_CS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xa0fb</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  [GDT_ENTRY_KERNEL_CS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc09a</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_KERNEL_DS]    = GDT_ENTRY_INIT(<span class="hljs-number">0xc092</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_CS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0fa</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>  [GDT_ENTRY_DEFAULT_USER_DS]  = GDT_ENTRY_INIT(<span class="hljs-number">0xc0f2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<br>......<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125; &#125;;<br>EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);<br></code></pre></td></tr></table></figure><p>这里面对于 64 位的和 32 位的，都定义了内核代码段、内核数据段、用户代码段和用户数据段。另外，还会定义下面四个段选择子，指向上面的段描述符表项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __KERNEL_CS      (GDT_ENTRY_KERNEL_CS*8)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __KERNEL_DS      (GDT_ENTRY_KERNEL_DS*8)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __USER_DS      (GDT_ENTRY_DEFAULT_USER_DS*8 + 3)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __USER_CS      (GDT_ENTRY_DEFAULT_USER_CS*8 + 3)</span><br></code></pre></td></tr></table></figure><p>通过分析，我们发现，所有的段的起始地址都是一样的，都是 0。所以，在 Linux 操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。<br>其实 Linux 倾向于另外一种从虚拟地址到物理地址的转换方式，称为<strong>分页</strong>（Paging）。对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以<strong>暂时写到硬盘上</strong>，称为<strong>换出</strong>。一旦需要的时候，再<strong>加载进来</strong>，叫作<strong>换入</strong>。这样可以扩大可用物理内存的大小，提高物理内存的利用率。</p><p>这个换入和换出都是以页为单位的。页面的大小一般为 4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129185728.png"></p><p>虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。</p><p>32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了 。</p><p>页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。</p><p>那怎么办呢？我们可以试着将页表再分页，4G 的空间需要 4M 的页表来存储映射。我们把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K。</p><p>页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置。</p><p>这样加起来正好 32 位，也就是用前 10 位定位到页目录表中的一项。将这一项对应的页表取出来共 1k 项，再用中间 10 位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后 12 位定位到页中的具体位置访问数据。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20211129192245.png"></p><p>你可能会问，如果这样的话，映射 4GB 地址空间就需要 4MB+4KB 的内存，这样不是更大了吗？ 当然如果页是满的，当时是更大了，但是，我们往往不会为一个进程分配那么多内存。</p><p>比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省多了。</p><p>当然对于 64 位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。</p><h2 id="进程空间管理"><a href="#进程空间管理" class="headerlink" title="进程空间管理"></a>进程空间管理</h2><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><h2 id="用户态内存映射"><a href="#用户态内存映射" class="headerlink" title="用户态内存映射"></a>用户态内存映射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GDT_ENTRY_INIT(flags, base, limit) &#123; &#123; &#123; \</span><br><span class="hljs-meta">  .a = ((limit) &amp; 0xffff) | (((base) &amp; 0xffff) &lt;&lt; 16), \</span><br><span class="hljs-meta">  .b = (((base) &amp; 0xff0000) &gt;&gt; 16) | (((flags) &amp; 0xf0ff) &lt;&lt; 8) | \</span><br><span class="hljs-meta">    ((limit) &amp; 0xf0000) | ((base) &amp; 0xff000000), \</span><br><span class="hljs-meta">  &#125; &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>通过分析，我们发现，所有的段的起始地址都是一样的，都是 0。这算哪门子分段嘛！所以，在 Linux 操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。</p><p>其实 Linux 倾向于另外一种从虚拟地址到物理地址的转换方式，称为分页（Paging）。</p><p>对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为换出。一旦需要的时候，再加载进来，叫作换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Linux操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt模仿登录界面-交互响应</title>
    <link href="/2021/08/18/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E4%BA%A4%E4%BA%92%E5%93%8D%E5%BA%94/"/>
    <url>/2021/08/18/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E4%BA%A4%E4%BA%92%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820152215.gif"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820152316.gif"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820153546.gif"></p><h2 id="设置窗口拖动"><a href="#设置窗口拖动" class="headerlink" title="设置窗口拖动"></a>设置窗口拖动</h2><p>因为这个项目中没有将登录界面直接继承<code>MainWindow</code>，而是继承的<code>Dialog</code>类，所以它是不能直接移动的，需要我们自己添加相应的方法。这里实现了三种方法，点击，拖动，释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//mytitlebar.cpp</span><br><span class="hljs-comment">// 以下通过mousePressEvent、mouseMoveEvent、mouseReleaseEvent三个事件实现了鼠标拖动标题栏移动窗口的效果;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_buttonType == MIN_MAX_BUTTON)<br>&#123;<br><span class="hljs-comment">// 在窗口最大化时禁止拖动窗口;</span><br><span class="hljs-keyword">if</span> (m_pButtonMax-&gt;<span class="hljs-built_in">isVisible</span>())<br>&#123;<br>m_isPressed = <span class="hljs-literal">true</span>;<br>m_startMovePos = event-&gt;<span class="hljs-built_in">globalPos</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>m_isPressed = <span class="hljs-literal">true</span>;<br>m_startMovePos = event-&gt;<span class="hljs-built_in">globalPos</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">mousePressEvent</span>(event);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::mouseMoveEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_isPressed &amp;&amp; m_isMoveParentWindow)<br>&#123;<br>QPoint movePoint = event-&gt;<span class="hljs-built_in">globalPos</span>() - m_startMovePos;<br>QPoint widgetPos = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">parentWidget</span>()-&gt;<span class="hljs-built_in">pos</span>() + movePoint;<br>m_startMovePos = event-&gt;<span class="hljs-built_in">globalPos</span>();<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">parentWidget</span>()-&gt;<span class="hljs-built_in">move</span>(widgetPos.<span class="hljs-built_in">x</span>(), widgetPos.<span class="hljs-built_in">y</span>());<br>&#125;<br><span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">mouseMoveEvent</span>(event);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::mouseReleaseEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>m_isPressed = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">mouseReleaseEvent</span>(event);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="globalPos-获取全局的坐标"><a href="#globalPos-获取全局的坐标" class="headerlink" title="globalPos()获取全局的坐标"></a><code>globalPos()</code>获取全局的坐标</h3><p><code>event-&gt;globalPos()</code>是获取全局的坐标，全局是相对于整个屏幕而言的。还有一个函数<code>pos()</code>获取的是局部坐标，相对于一个<code>widget</code>窗口而言。</p><h3 id="move-移动窗口"><a href="#move-移动窗口" class="headerlink" title="move()移动窗口"></a><code>move()</code>移动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QPoint &amp;)</span></span>;<br></code></pre></td></tr></table></figure><p>其中<code>move</code>的原点是父窗口的左上角，  如果没有父窗口，则桌面即为父窗口。x往右递增，y往下递增</p><p><code>mouseMoveEvent()</code>这个函数里有一点需要注意的是，<code>m_startMovePos = event-&gt;globalPos()</code>这条语句。每次移动窗口之前，先把鼠标移动后的位置记录下来，作为下一次移动的起点。</p><h2 id="设置最小化，关闭"><a href="#设置最小化，关闭" class="headerlink" title="设置最小化，关闭"></a>设置最小化，关闭</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//mytitlebar.cpp</span><br><span class="hljs-comment">// 信号槽的绑定;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::initConnections</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">connect</span>(m_pButtonMin, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonMinClicked</span>()));<br><span class="hljs-built_in">connect</span>(m_pButtonClose, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonCloseClicked</span>()));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::onButtonMinClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">emit <span class="hljs-title">signalButtonMinClicked</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyTitleBar::onButtonCloseClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">emit <span class="hljs-title">signalButtonCloseClicked</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>标题栏是在<code>basewindow</code>中new出来的，<code>mytitlebar</code>类只负责发送信号，真正处理信号的是在<code>basewindow</code>类中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//basewindow.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BaseWindow::initTitleBar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">createMyTitle</span>(<span class="hljs-keyword">this</span>);<br>m_titleBar-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">connect</span>(m_titleBar, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalButtonMinClicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonMinClicked</span>()));<br><span class="hljs-built_in">connect</span>(m_titleBar, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalButtonCloseClicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onButtonCloseClicked</span>()));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BaseWindow::onButtonMinClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (Qt::Tool == (<span class="hljs-built_in">windowFlags</span>() &amp; Qt::Tool))<br>&#123;<br><span class="hljs-built_in">hide</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">showMinimized</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BaseWindow::onButtonCloseClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在初始化标题栏时，就把点击信号与相关的槽函数绑定。当有最小化点击信号发生时，就会调用最小化操作。</p><h3 id="和窗口相关的几个函数"><a href="#和窗口相关的几个函数" class="headerlink" title="和窗口相关的几个函数"></a>和窗口相关的几个函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">showMinimized</span>()     <span class="hljs-comment">//最小化</span><br><span class="hljs-built_in">showNormal</span>()        <span class="hljs-comment">//从最小化或者最大化窗口恢复到正常窗口</span><br><span class="hljs-built_in">showMaximized</span>()     <span class="hljs-comment">//最大化</span><br><span class="hljs-built_in">show</span>()              <span class="hljs-comment">//显示窗口，可以显示模态窗口也可以显示非模态</span><br><span class="hljs-built_in">hide</span>()              <span class="hljs-comment">//隐藏窗口</span><br><span class="hljs-built_in">isVisible</span>()         <span class="hljs-comment">//判断是否可见</span><br><span class="hljs-built_in">isMinimized</span>()       <span class="hljs-comment">//判断是否处于最小化状态</span><br><span class="hljs-built_in">close</span>()             <span class="hljs-comment">//关闭窗口</span><br></code></pre></td></tr></table></figure><h2 id="切换用户及删除用户"><a href="#切换用户及删除用户" class="headerlink" title="切换用户及删除用户"></a>切换用户及删除用户</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//loginwindow.cpp</span><br><span class="hljs-comment">// 初始化用户登录信息;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initAccountList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 设置代理;</span><br>    m_Accountlist = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QListWidget</span>(<span class="hljs-keyword">this</span>);<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setModel</span>(m_Accountlist-&gt;<span class="hljs-built_in">model</span>());<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setView</span>(m_Accountlist);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        AccountItem *account_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AccountItem</span>();<br>        account_item-&gt;<span class="hljs-built_in">setAccountInfo</span>(i, <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;Dominic%1号&quot;</span>).<span class="hljs-built_in">arg</span>(i), <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/headImage/head_%1.png&quot;</span>).<span class="hljs-built_in">arg</span>(i));<br>        <span class="hljs-built_in">connect</span>(account_item, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalShowAccountInfo</span>(<span class="hljs-keyword">int</span>, QString)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onShowAccountInfo</span>(<span class="hljs-keyword">int</span>, QString)));<br>        <span class="hljs-built_in">connect</span>(account_item, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">signalRemoveAccount</span>(<span class="hljs-keyword">int</span>)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onRemoveAccount</span>(<span class="hljs-keyword">int</span>)));<br>        QListWidgetItem *list_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QListWidgetItem</span>(m_Accountlist);<br>        m_Accountlist-&gt;<span class="hljs-built_in">setItemWidget</span>(list_item, account_item);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//将选项文本显示在QComboBox当中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onShowAccountInfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, QString accountName)</span></span><br><span class="hljs-function"></span>&#123;<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setEditText</span>(accountName);<br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">hidePopup</span>();<br><br>    <span class="hljs-comment">// 更换用户头像;</span><br>    QString fileName = <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/headImage/head_%1.png&quot;</span>).<span class="hljs-built_in">arg</span>(index);<br>    ui-&gt;userHead-&gt;<span class="hljs-built_in">setPixmap</span>(<span class="hljs-built_in">QPixmap</span>(fileName).<span class="hljs-built_in">scaled</span>(ui-&gt;userHead-&gt;<span class="hljs-built_in">width</span>(), ui-&gt;userHead-&gt;<span class="hljs-built_in">height</span>()));<br>&#125;<br><br><span class="hljs-comment">// 移除当前登录列表中某一项;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onRemoveAccount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; m_Accountlist-&gt;<span class="hljs-built_in">count</span>(); row++)<br>    &#123;<br>        AccountItem* itemWidget = (AccountItem*)m_Accountlist-&gt;<span class="hljs-built_in">itemWidget</span>(m_Accountlist-&gt;<span class="hljs-built_in">item</span>(row));<br>        <span class="hljs-keyword">if</span> (itemWidget != <span class="hljs-literal">NULL</span> &amp;&amp; itemWidget-&gt;<span class="hljs-built_in">getItemWidgetIndex</span>() == index)<br>        &#123;<br>            m_Accountlist-&gt;<span class="hljs-built_in">takeItem</span>(row);<br>            itemWidget-&gt;<span class="hljs-built_in">deleteLater</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>initAccountList()</code>中，初始化好了三个账户信息，当接收到显示用户信息的信号<code>signalShowAccountInfo</code>后，就会调用<code>onShowAccountInfo</code>槽函数显示用户信息。在这个函数中，将下拉框的内容设置成切换后的用户名，然后隐藏下拉框<code>hidPopup</code>。更改头像。</p><p>当接收到删除信号时，调用<code>onRemoveAccount</code>槽函数，删除指定的用户信息。</p><h3 id="hidPopup-隐藏下拉框"><a href="#hidPopup-隐藏下拉框" class="headerlink" title="hidPopup()隐藏下拉框"></a><code>hidPopup()</code>隐藏下拉框</h3><p>文章开头的效果图是隐藏下拉框的效果，每次切换用户下拉框隐藏，我们再来看一下不隐藏什么效果就容易理解了。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820105158.gif"></p><h3 id="takeItem-删除部件"><a href="#takeItem-删除部件" class="headerlink" title="takeItem()删除部件"></a><code>takeItem()</code>删除部件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QListWidgetItem *<span class="hljs-title">QListWidget::takeItem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row)</span></span><br></code></pre></td></tr></table></figure><p>从下拉菜单中选择一行部件删除。</p><h3 id="deleteLater-稍后删除对象"><a href="#deleteLater-稍后删除对象" class="headerlink" title="deleteLater()稍后删除对象"></a><code>deleteLater()</code>稍后删除对象</h3><p><code>deletelater</code>的原理是 <code>QObject::deleteLater()</code>并没有将对象立即销毁，而是向主消息循环发送了一个<code>event</code>，下一次主消息循环收到这个<code>event</code>之后才会销毁对象。</p><h2 id="切换登录状态"><a href="#切换登录状态" class="headerlink" title="切换登录状态"></a>切换登录状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//loginwindow.cpp</span><br><span class="hljs-comment">// 选择了新的用户登录状态;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onLoginStateClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    m_loginStateMemu = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QMenu</span>();<br>    QAction *pActionOnline = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_online.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;我在线上&quot;</span>));<br>    QAction *pActionActive = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_Qme.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;Q我吧&quot;</span>));<br>    m_loginStateMemu-&gt;<span class="hljs-built_in">addSeparator</span>();<br>    QAction *pActionAway = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_away.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;离开&quot;</span>));<br>    QAction *pActionBusy = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_busy.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;忙碌&quot;</span>));<br>    QAction *pActionNoDisturb = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_notdisturb.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;请勿打扰&quot;</span>));<br>    m_loginStateMemu-&gt;<span class="hljs-built_in">addSeparator</span>();<br>    QAction *pActionHide = m_loginStateMemu-&gt;<span class="hljs-built_in">addAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_hide.png&quot;</span>), <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;隐身&quot;</span>));<br>    <span class="hljs-comment">// 设置状态值;</span><br>    pActionOnline-&gt;<span class="hljs-built_in">setData</span>(ONLINE);<br>    pActionActive-&gt;<span class="hljs-built_in">setData</span>(ACTIVE);<br>    pActionAway-&gt;<span class="hljs-built_in">setData</span>(AWAY);<br>    pActionBusy-&gt;<span class="hljs-built_in">setData</span>(BUSY);<br>    pActionNoDisturb-&gt;<span class="hljs-built_in">setData</span>(NOT_DISTURB);<br>    pActionHide-&gt;<span class="hljs-built_in">setData</span>(HIDE);<br><br><br>    <span class="hljs-built_in">connect</span>(m_loginStateMemu, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">triggered</span>(QAction *)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">onMenuClicked</span>(QAction*)));<br><br>    QPoint pos = ui-&gt;loginState-&gt;<span class="hljs-built_in">mapToGlobal</span>(<span class="hljs-built_in">QPoint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) + <span class="hljs-built_in">QPoint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br>    m_loginStateMemu-&gt;<span class="hljs-built_in">exec</span>(pos);<br>&#125;<br><br><span class="hljs-comment">// 用户状态菜单点击;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::onMenuClicked</span><span class="hljs-params">(QAction * action)</span></span><br><span class="hljs-function"></span>&#123;<br>    ui-&gt;loginState-&gt;<span class="hljs-built_in">setIcon</span>(action-&gt;<span class="hljs-built_in">icon</span>());<br>    <span class="hljs-comment">// 获取状态值;</span><br>    m_loginState = (LoginState)action-&gt;<span class="hljs-built_in">data</span>().<span class="hljs-built_in">toInt</span>();<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;onMenuClicked&quot;</span> &lt;&lt; m_loginState;<br>&#125;<br></code></pre></td></tr></table></figure><p>在接收到点击状态按钮信号时，调用<code>onLoginStateClicked</code>槽函数，改变用户登录状态。切换的下拉菜单用的是<code>QMenu</code>。</p><h3 id="addSeparator-添加分割线"><a href="#addSeparator-添加分割线" class="headerlink" title="addSeparator()添加分割线"></a><code>addSeparator()</code>添加分割线</h3><p>Q我吧和离开状态之间的分割线。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820113856.png"></p><h3 id="mapToGlobal-映射成全局坐标"><a href="#mapToGlobal-映射成全局坐标" class="headerlink" title="mapToGlobal()映射成全局坐标"></a><code>mapToGlobal()</code>映射成全局坐标</h3><p>弹出登录状态菜单<code>m_loginStateMemu</code>是我们自己new出来的，默认显示是从左上角开始显示，这样当然不行。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820140445.png"></p><p> <code>mapToGlobal()</code>的作用就是将控件的坐标映射成全局坐标。代码里的意思就是将<code>loginState</code>控件里面的坐标用全局坐标表示。然后再向下偏移<code>20</code>个单位。再把得到的全局坐标作为<code>m_loginStateMemu</code>显示起始坐标。</p><p>下图是未偏移的结果，<br> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820141408.png"></p><p>向下偏移<code>20</code>个单位的效果，因为我们<code>mapToGlobal(QPoint(0, 0))</code>的参数是<code>(0,0)</code>为起点。如果我们<code>mapToGlobal(QPoint(0, 20))</code>的参数是<code>(0,20)</code>，就不用再加上偏移了。<br> <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820141521.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt模仿登录界面-窗口布局及样式</title>
    <link href="/2021/08/17/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80%E5%8F%8A%E6%A0%B7%E5%BC%8F/"/>
    <url>/2021/08/17/Qt%E6%A8%A1%E4%BB%BF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2-%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80%E5%8F%8A%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="框架类图"><a href="#框架类图" class="headerlink" title="框架类图"></a>框架类图</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210827120419.png"></p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210818130510.gif"><br>完整项目及资源文件请在<a href="https://github.com/Dunky-Z/learning-qt/tree/main/Demo/login">Github</a>查看。</p><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820101857.png"></p><h2 id="初始化标题栏"><a href="#初始化标题栏" class="headerlink" title="初始化标题栏"></a>初始化标题栏</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化标题栏;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initMyTitle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 因为这里有控件层叠了，所以要注意控件raise()方法的调用顺序;</span><br>    m_titleBar-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    m_titleBar-&gt;<span class="hljs-built_in">raise</span>();<br>    m_titleBar-&gt;<span class="hljs-built_in">setBackgroundColor</span>(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    m_titleBar-&gt;<span class="hljs-built_in">setButtonType</span>(MIN_BUTTON);<br>    m_titleBar-&gt;<span class="hljs-built_in">setTitleWidth</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>());<br>    <span class="hljs-comment">// 这里需要设置成false，不允许通过标题栏拖动来移动窗口位置,否则会造成窗口位置错误;</span><br>    m_titleBar-&gt;<span class="hljs-built_in">setMoveParentWindowFlag</span>(<span class="hljs-literal">false</span>);<br>    ui-&gt;pButtonArrow-&gt;<span class="hljs-built_in">raise</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="raise-将控件置于顶层"><a href="#raise-将控件置于顶层" class="headerlink" title="raise()将控件置于顶层"></a><code>raise()</code>将控件置于顶层</h3><p>程序在打开后一般都在所有窗体的顶层，打开其他程序后之前的程序就会被放到下一层，在这里，当设置完<code>my_titleBar</code>后对其他控件操作就会把<code>my_titleBar</code>控件覆盖。所有要用<code>raise()</code>方法将其置于顶层。</p><h2 id="初始化窗口"><a href="#初始化窗口" class="headerlink" title="初始化窗口"></a>初始化窗口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化窗口;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initWindow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//背景GIG图;</span><br>    QLabel* pBack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QLabel</span>(<span class="hljs-keyword">this</span>);<br>    QMovie *movie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QMovie</span>();<br>    movie-&gt;<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/back.gif&quot;</span>);<br>    pBack-&gt;<span class="hljs-built_in">setMovie</span>(movie);<br>    movie-&gt;<span class="hljs-built_in">start</span>();<br>    pBack-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//文本框内提示</span><br>    ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">setEditable</span>(<span class="hljs-literal">true</span>);<br>    QLineEdit* lineEdit = ui-&gt;accountComboBox-&gt;<span class="hljs-built_in">lineEdit</span>();<br>    lineEdit-&gt;<span class="hljs-built_in">setPlaceholderText</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;QQ号码/手机/邮箱&quot;</span>));<br>    <span class="hljs-function">QRegExp <span class="hljs-title">regExp</span><span class="hljs-params">(<span class="hljs-string">&quot;[A-Za-z0-9_]&#123;6,30&#125;&quot;</span>)</span></span>;<span class="hljs-comment">//正则表达式限制用户名输入不能输入汉字</span><br>    lineEdit-&gt;<span class="hljs-built_in">setValidator</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QRegExpValidator</span>(regExp,<span class="hljs-keyword">this</span>));<br>    ui-&gt;passwordEdit-&gt;<span class="hljs-built_in">setPlaceholderText</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;密码&quot;</span>));<br><br>    <span class="hljs-comment">//密码框中的小键盘按钮;</span><br>    m_keyboardButton = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>();<br>    m_keyboardButton-&gt;<span class="hljs-built_in">setObjectName</span>(<span class="hljs-string">&quot;pButtonKeyboard&quot;</span>);<br>    m_keyboardButton-&gt;<span class="hljs-built_in">setFixedSize</span>(<span class="hljs-built_in">QSize</span>(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>));<br>    m_keyboardButton-&gt;<span class="hljs-built_in">setCursor</span>(<span class="hljs-built_in">QCursor</span>(Qt::PointingHandCursor));<span class="hljs-comment">//鼠标放上去变成手形</span><br><br>    QHBoxLayout* passwordEditLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>    passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>();<br>    passwordEditLayout-&gt;<span class="hljs-built_in">addWidget</span>(m_keyboardButton);<br>    passwordEditLayout-&gt;<span class="hljs-built_in">setSpacing</span>(<span class="hljs-number">0</span>);<br>    passwordEditLayout-&gt;<span class="hljs-built_in">setContentsMargins</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br><br>    ui-&gt;passwordEdit-&gt;<span class="hljs-built_in">setLayout</span>(passwordEditLayout);<br>    <span class="hljs-comment">//设置密码达到最长时最后一个字符离小键盘图标的距离（12）</span><br>    ui-&gt;passwordEdit-&gt;<span class="hljs-built_in">setTextMargins</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m_keyboardButton-&gt;<span class="hljs-built_in">width</span>() + <span class="hljs-number">12</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//设置头像以及状态图标</span><br>    ui-&gt;userHead-&gt;<span class="hljs-built_in">setPixmap</span>(<span class="hljs-built_in">QPixmap</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/HeadImage.png&quot;</span>));<br>    ui-&gt;loginState-&gt;<span class="hljs-built_in">setIcon</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/LoginState/state_online.png&quot;</span>));<br>    ui-&gt;loginState-&gt;<span class="hljs-built_in">setIconSize</span>(<span class="hljs-built_in">QSize</span>(<span class="hljs-number">13</span>, <span class="hljs-number">13</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>lineEdit-&gt;setPlaceholderText<br>QStringLiteral:如果该QString不会修改的话，那使用QStringLiteral</p><h3 id="setPlaceholderText-设置文本提示"><a href="#setPlaceholderText-设置文本提示" class="headerlink" title="setPlaceholderText()设置文本提示"></a><code>setPlaceholderText()</code>设置文本提示</h3><p>该方法可以设置文本框中的默认文字提示，如图片中的QQ号码/手机/邮箱。</p><h3 id="setCursor-设置鼠标形态"><a href="#setCursor-设置鼠标形态" class="headerlink" title="setCursor()设置鼠标形态"></a><code>setCursor()</code>设置鼠标形态</h3><p>共有以下19种鼠标形态：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210820150422.png"></p><p>图片来自<a href="https://blog.csdn.net/taiyang1987912/article/details/35281407">这里</a></p><h3 id="addStretch-布局加入弹簧"><a href="#addStretch-布局加入弹簧" class="headerlink" title="addStretch()布局加入弹簧"></a><code>addStretch()</code>布局加入弹簧</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QHBoxLayout* passwordEditLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>();<br>passwordEditLayout-&gt;<span class="hljs-built_in">addWidget</span>(m_keyboardButton);<br></code></pre></td></tr></table></figure><p><code>addStretch()</code>用来在布局中平分布局，他就是个弹簧的作用。如果不加参数，就是等于加个弹簧，会把小键盘图标挤到边上。如图：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817143033.png"></p><p>如果将代码改一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QHBoxLayout* passwordEditLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>(<span class="hljs-number">1</span>);<br>passwordEditLayout-&gt;<span class="hljs-built_in">addWidget</span>(m_keyboardButton);<br>passwordEditLayout-&gt;<span class="hljs-built_in">addStretch</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>意思就是将除了小键盘图标以外的空间分成两份，那么刚好小键盘图标就是在中间位置，就像两遍各防止了一个弹簧。效果如下：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817143135.png"></p><p><code>setSpacing()</code>设置空间之间上下距离，还有一个容易混淆的设置<code>setMargin()</code>表示设置空间与窗口边缘的左右距离。</p><p><code>setContentsMargins</code>设置左侧、顶部、右侧和底部边距，以便在布局周围使用。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817144359.png"></p><p>现在我们设置的是<code>setContentsMargins(0, 0, 8, 0)</code>，现在我们设置大一点看看效果。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210817144532.png"></p><p><code>QLineEdit.setTextMargins(left=,top=,right=,bottom=) </code>设置文本边距，这里主要为了设置密码输入过长时，最后一个字符距离小键盘图标有一定间隙。</p><h2 id="初始化用户登录信息"><a href="#初始化用户登录信息" class="headerlink" title="初始化用户登录信息"></a>初始化用户登录信息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//accountitem.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoginWindow::initAccountList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>AccountItem *account_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AccountItem</span>();<br>account_item-&gt;<span class="hljs-built_in">setAccountInfo</span>(i, <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;Dominic_%1号&quot;</span>).<span class="hljs-built_in">arg</span>(i), <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;:/Resources/LoginWindow/headImage/head_%1.png&quot;</span>).<span class="hljs-built_in">arg</span>(i));<br>QListWidgetItem *list_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QListWidgetItem</span>(m_Accountlist);<br>m_Accountlist-&gt;<span class="hljs-built_in">setItemWidget</span>(list_item, account_item);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作系统-进程间通信</title>
    <link href="/2021/08/14/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/08/14/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong>。</p><h2 id="进程间通信概述"><a href="#进程间通信概述" class="headerlink" title="进程间通信概述"></a>进程间通信概述</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>在学Linux命令时就有管道在这个概念，比如下面这个命令</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">ps -ef  | <span class="hljs-type">-grep</span> root | <span class="hljs-type">xargs</span> kill <span class="hljs-number">-9</span><br></code></pre></td></tr></table></figure><p>将上一个命令的输出作为下一个命令的输入，数据只能向一个方向流动；双方需要互相通信时，需要建立起两个管道。</p><p>管道有两种类型：匿名管道和命名管道。上面提到的命令中<code>|</code>表示的管道即<strong>匿名管道pipe</strong>。用完即销毁，自动创建，自动销毁。</p><p>使用<code>mkfifo</code>显示创建的是<strong>命名管道fifo</strong>，</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mkfifo hello</span><br></code></pre></td></tr></table></figure><p><code>hello</code>即是管道名称，类型为<code>p</code>，就是<code>pipe</code>，接下来就可以在管道里写入东西，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span> &gt; hello</span><br></code></pre></td></tr></table></figure><p>光写入还不行，只有有另一个进程读取了内容才完成一次信息交换，才完成一次通信，</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># cat &lt; hello </span><br><span class="hljs-attribute">hello</span> world<br></code></pre></td></tr></table></figure><p>这种方式通信效率低，无法频繁通信。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>类似于日常沟通使用的邮件，有一定格式，有个收件列表，列表上的用户都可以反复在原邮件基础上回复，达到频繁交流的目的。这种模型就是<strong>消息队列模型</strong>。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。</p><p>每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存空间映射到不同的物理内存中去。这个进程访问 A 地址和另一个进程访问 A 地址，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p>但是，咱们是不是可以变通一下，<strong>拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。</p><p>使用<code>shmget</code>函数创建一个共享内存，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//key_t key:  唯一定位一个共享内存对象</span><br><span class="hljs-comment">//size_t size: 共享内存大小</span><br><span class="hljs-comment">//int flag: 如果是IPC_CREAT表示创建新的共享内存空间</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> flag)</span></span>;<br></code></pre></td></tr></table></figure><p>创建完毕之后，我们可以通过 <code>ipcs</code> 命令查看这个共享内存。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#ipcs ­­--shmems</span><br> <br>------ <span class="hljs-keyword">Shared </span>Memory Segments ------ ­­­­­­­­<br>key        <span class="hljs-keyword">shmid </span>   owner perms    <span class="hljs-keyword">bytes </span>nattch status<br><span class="hljs-number">0x00000000</span> <span class="hljs-number">19398656</span> marc  <span class="hljs-number">600</span>    <span class="hljs-number">1048576</span> <span class="hljs-number">2</span>      dest<br></code></pre></td></tr></table></figure><p>进程通过<code>shmat</code>，就是<code>attach</code>的意思，将内存加载到自己虚拟地址空间某个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//int shm_id:</span><br><span class="hljs-comment">//const void *addr: 加载的地址，通常设为NULL，让内核选一个合适地址</span><br><span class="hljs-comment">//int flag:</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">shmat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">int</span> flag)</span></span>;<br></code></pre></td></tr></table></figure><p>如果共享内存使用完毕，可以通过 <code>shmdt</code> 解除绑定，然后通过 <code>shmctl</code>，将 <code>cmd</code> 设置为 <code>IPC_RMID</code>，从而删除这个共享内存对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmdt</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;<br></code></pre></td></tr></table></figure><p>共享内存的最大不足之处在于，由于多个进程对同一块内存区具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>如果两个进程同时向一个共享内存读写数据，很可能就会导致冲突。所以需要有一种保护机制，使得同一个共享资源同时只能被一个进程访问。在进程间通信机制中，<strong>信号量</strong>（Semaphore）就是用来实现进程间互斥与同步的。它其实是个<strong>计数器</strong>，只不过不是用来记录进程间通信数据的。</p><p>我们可以将信号量初始化为一个数值，来代表某种资源的总体数量。对于信号量来讲，会定义两种原子操作，一个是<code>P</code> 操作，我们称为<strong>申请资源操作</strong>。这个操作会申请将信号量的数值<strong>减去</strong> N，表示这些数量被他申请使用了，其他人不能用了。另一个是<code>V </code>操作，我们称为<strong>归还资源操作</strong>，这个操作会申请将信号量<strong>加上</strong> M，表示这些数量已经还给信号量了，其他人可以使用了。</p><p>所谓<strong>原子操作</strong>（Atom Operation）就是不可被中断的一个或一系列操作。</p><p>使用<code>semget</code><strong>创建</strong>信号量，第一个参数表示唯一标识，第二个参数表示可以创建多少个信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">int</span> num_sems, <span class="hljs-keyword">int</span> sem_flags)</span></span>;<br></code></pre></td></tr></table></figure><p>接下来，我们需要<strong>初始化</strong>信号量的总的资源数量。通过<code> semctl</code> 函数，第一个参数 <code>semid </code>是这个信号量组的<code> id</code>，第二个参数 <code>semnum</code> 才是在这个信号量组中某个信号量的<code> id</code>，第三个参数是命令，如果是初始化，则用 <code>SETVAL</code>，第四个参数是一个 <code>union</code>。如果初始化，应该用里面的<code>val</code>设置资源总量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> semid, <span class="hljs-keyword">int</span> semnum, <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">union</span> semun args)</span></span>;<br> <br> <br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">semun</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">int</span> val;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semid_ds</span> *<span class="hljs-title">buf</span>;</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seminfo</span> *__<span class="hljs-title">buf</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>无论是 P 操作还是 V 操作，我们统一用 semop 函数。第一个参数还是信号量组的 id，一次可以操作多个信号量。第三个参数 numops 就是有多少个操作，第二个参数将这些操作放在一个数组中。</p><p>数组的每一项是一个 <code>struct sembuf</code>，里面的第一个成员是这个操作的对象是哪个信号量。第二个成员就是要对这个信号量做多少改变。如果 <code>sem_op &lt; 0</code>，就请求 <code>sem_op</code> 的绝对值的资源。如果相应的资源数可以满足请求，则将该信号量的值减去 <code>sem_op</code> 的绝对值，函数成功返回。</p><p>当相应的资源数不能满足请求时，就要看<code> sem_flg</code> 了。如果把 <code>sem_flg</code> 设置为<code> IPC_NOWAIT</code>，也就是没有资源也不等待，则 <code>semop</code> 函数出错返回 <code>EAGAIN</code>。如果 <code>sem_flg</code> 没有指定<code> IPC_NOWAIT</code>，则进程挂起，直到当相应的资源数可以满足请求。若 <code>sem_op &gt; 0</code>，表示进程归还相应的资源数，将 <code>sem_op</code> 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则唤醒它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">semop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> semid, struct sembuf semoparray[], <span class="hljs-keyword">size_t</span>  numops)</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> </span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">short</span> sem_num; <span class="hljs-comment">// 信号量组中对应的序号，0～sem_nums-1</span><br>  <span class="hljs-keyword">short</span> sem_op;  <span class="hljs-comment">// 信号量值在一次操作中的改变量</span><br>  <span class="hljs-keyword">short</span> sem_flg; <span class="hljs-comment">// IPC_NOWAIT, SEM_UNDO</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>以上提到的通信方式，都是常规状态下的工作模式，而信号一般是由<strong>错误</strong>产生的。</p><p>信号没有特别复杂的数据结构，就是用一个代号一样的数字。Linux 提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Linux操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-rename批量重命名</title>
    <link href="/2021/08/13/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-rename%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/"/>
    <url>/2021/08/13/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-rename%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">rename</span> [<span class="hljs-meta">options</span>] <span class="hljs-string">&quot;s/oldname/newname/&quot;</span> <span class="hljs-meta">file</span><br></code></pre></td></tr></table></figure><p>格式就很容易看出来怎么用的，就是<code>/</code>不能丢。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-v 将重命名的内容都打印到标准输出，v 可以看成 verbose</span><br><span class="hljs-deletion">-n 测试会重命名的内容，将结果都打印，但是并不真正执行重命名的过程</span><br><span class="hljs-deletion">-f force 会覆盖本地已经存在的文件</span><br><span class="hljs-deletion">-h -m -V 分别为帮助，帮助，版本</span><br><span class="hljs-deletion">-e 比较复杂，可以通过该选项，写一些脚本来做一些复杂的事情</span><br></code></pre></td></tr></table></figure><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="替换文件名中的特定字段"><a href="#替换文件名中的特定字段" class="headerlink" title="替换文件名中的特定字段"></a>替换文件名中的特定字段</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/AA/aa/&quot;</span> *  <span class="hljs-comment"># 把文件名中的AA替换成aa</span><br></code></pre></td></tr></table></figure><h3 id="修改文件后缀"><a href="#修改文件后缀" class="headerlink" title="修改文件后缀"></a>修改文件后缀</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/.html/.php/&quot;</span> *     <span class="hljs-comment"># 把.html 后缀的改成 .php后缀</span><br><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/.png/.jpg/&quot;</span> *      <span class="hljs-comment"># 将 png 改为 jpg</span><br></code></pre></td></tr></table></figure><h3 id="添加后缀"><a href="#添加后缀" class="headerlink" title="添加后缀"></a>添加后缀</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span> <span class="hljs-string">&quot;s/$/.txt/&quot;</span> *     <span class="hljs-comment"># 把所有的文件名都以txt结尾</span><br></code></pre></td></tr></table></figure><p><code>$</code>正则表达式中表示结尾。</p><h3 id="保留部分文件名"><a href="#保留部分文件名" class="headerlink" title="保留部分文件名"></a>保留部分文件名</h3><p>假如需要在批量修改的时候保留部分文件名，可以使用引用<code> \1</code> ，比如有下面格式的文件，只想保留日期部分。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Screenshot</span> from <span class="hljs-number">2019</span>-<span class="hljs-number">01</span>-<span class="hljs-number">02</span> <span class="hljs-number">15</span>-<span class="hljs-number">56</span>-<span class="hljs-number">49</span>.jpg<br><span class="hljs-attribute">rename</span> -n <span class="hljs-string">&quot;s/Screenshot from ([0-9\\- ]+).jpg/\1.jpg/&quot;</span> *<br></code></pre></td></tr></table></figure><p>将<code>()</code> 匹配的内容取出来放到替换部分。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-apt安装卸载软件</title>
    <link href="/2021/08/12/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-apt%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/"/>
    <url>/2021/08/12/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-apt%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>这个命令应该是我们平时用的最多的命令之一了，应该早就拿出来讲一下的。但是平时用的太多，总感觉自己都会用了，但是仔细看了所有命令，还是有一些比较实用但是没记住的命令。</p><p><code>apt</code>的全称是<code>Advanced Packaging Tool</code>是Linux系统下的一款安装包管理工具。 APT 可以自动下载、配置和安装二进制或源代码格式软件包，简化了 Unix 系统上管理软件的过程。</p><p>APT 主要由以下几个命令组成：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">apt-<span class="hljs-keyword">get</span><br>apt-cache<br>apt-<span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><h3 id="搜索软件包"><a href="#搜索软件包" class="headerlink" title="搜索软件包"></a>搜索软件包</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">apt <span class="hljs-built_in">search</span> <span class="hljs-keyword">python3</span><br></code></pre></td></tr></table></figure><h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">apt</span> install python<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> update<br></code></pre></td></tr></table></figure><h3 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h3><p>执行完update命令后，就可以使用apt upgrade来升级软件包了。执行命令后系统会提示有几个软件需要升级。在得到你的同意后，系统即开始自动下载安装软件包。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> upgrade<br></code></pre></td></tr></table></figure><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">remove</span> python3  <span class="hljs-comment"># 移除软件包，但是保留配置文件</span><br>apt purge python3 <span class="hljs-comment">#移除软件包并移除配置</span><br>apt autoremove <span class="hljs-comment"># 移除孤立的并不被依赖的软件包</span><br></code></pre></td></tr></table></figure><h3 id="列出软件清单"><a href="#列出软件清单" class="headerlink" title="列出软件清单"></a>列出软件清单</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">apt list</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt添加资源文件（QtCreator）</title>
    <link href="/2021/08/12/Qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%88QtCreator%EF%BC%89/"/>
    <url>/2021/08/12/Qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%88QtCreator%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>QtCreator➜新建文件或项目➜Qt➜Qt Resource File</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812102544.png"></p><p>点击<code>Choose</code>，设置资源文件名和路径。资源文件是一系列文件的集合，比如我要建立一个图片的资源文件，我可以设置<code>img</code>为资源文件名，将来所有图片类资源，都放到这个资源文件里，加入还有音频类的文件，我可以新建一个<code>audio</code>的资源文件，以后所有音频类的文件都放到这个资源文件下。</p><p>而不是我想要添加的文件名。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812103024.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812103101.png"></p><p>右侧编辑器下方有个<code>Add Prefix</code>(添加前缀)，我们首先要添加文件前缀，前缀就是存放文件的文件夹名，然后添加需要的文件。添加完以后看效果就知道啥意思了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210812104121.png"></p><p>这么做带来的一个问题是，如果以后我们要更改文件名，比如将 <code>xbl.png</code> 改成 <code>xiabanle.png</code>，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：</p><p>这样，我们可以直接使用<code>:/images/avatar </code>用到这个资源，无需关心图片的真实文件名。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-kill这个进程</title>
    <link href="/2021/08/11/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-kill%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B/"/>
    <url>/2021/08/11/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-kill%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>对于在前台运行的程序，我们可以用<code>Ctrl+C</code>来终止运行，但是在后台的程序就必须用<code>kill</code>命令来终止了。</p><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class="hljs-deletion">-a  当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="hljs-deletion">-p  指定 kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="hljs-deletion">-s  指定发送信号</span><br><span class="hljs-deletion">-u  指定用户</span><br></code></pre></td></tr></table></figure><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="查看所有信号"><a href="#查看所有信号" class="headerlink" title="查看所有信号"></a>查看所有信号</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos">➜   <span class="hljs-keyword">kill</span> -<span class="hljs-keyword">l</span><br>HUP INT <span class="hljs-keyword">QUIT</span> ILL TRAP ABRT BUS FPE <span class="hljs-keyword">KILL</span> USR1 <br>SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP <br>TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS<br></code></pre></td></tr></table></figure><p>常用信号</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HUP</span>    <span class="hljs-number">1</span>    终端断线<br><span class="hljs-attribute">INT</span>     <span class="hljs-number">2</span>    中断（同 Ctrl + C）<br><span class="hljs-attribute">QUIT</span>    <span class="hljs-number">3</span>    退出（同 Ctrl + \）<br><span class="hljs-attribute">TERM</span>   <span class="hljs-number">15</span>    终止<br><span class="hljs-attribute">KILL</span>    <span class="hljs-number">9</span>    强制终止<br><span class="hljs-attribute">CONT</span>   <span class="hljs-number">18</span>    继续（与 STOP 相反， fg/bg 命令）<br><span class="hljs-attribute">STOP</span>    <span class="hljs-number">19</span>    暂停（同 Ctrl + Z）<br></code></pre></td></tr></table></figure><h3 id="用-ps-查找进程，然后用-kill-杀掉"><a href="#用-ps-查找进程，然后用-kill-杀掉" class="headerlink" title="用 ps 查找进程，然后用 kill 杀掉"></a>用 ps 查找进程，然后用 kill 杀掉</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">ps -ef | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;program&#x27;</span><br><span class="hljs-keyword">kill</span> PID<br></code></pre></td></tr></table></figure><h3 id="无条件彻底杀死进程"><a href="#无条件彻底杀死进程" class="headerlink" title="无条件彻底杀死进程"></a>无条件彻底杀死进程</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> –<span class="hljs-number">9</span> PID<br></code></pre></td></tr></table></figure><h3 id="杀死指定用户所有进程"><a href="#杀死指定用户所有进程" class="headerlink" title="杀死指定用户所有进程"></a>杀死指定用户所有进程</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">kill -<span class="hljs-number">9</span> <span class="hljs-constructor">$(<span class="hljs-params">ps</span> -<span class="hljs-params">ef</span> | <span class="hljs-params">grep</span> <span class="hljs-params">username</span>)</span><br>kill -u username<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信（IPC）之信号（Signal）</title>
    <link href="/2021/08/11/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E4%BF%A1%E5%8F%B7%EF%BC%88Signal%EF%BC%89/"/>
    <url>/2021/08/11/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E4%BF%A1%E5%8F%B7%EF%BC%88Signal%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>关于进程间通信的概述可以查看<a href="https://dunky-z.github.io/2021/08/10/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">Linux操作系统-进程间通信</a>，<a href="https://github.com/Dunky-Z/learning-linux/tree/main/IPC/SharedMemory">代码同步在这里</a>。</p><p>本文通过实例介绍通过共享内存实现进程间通信。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>信号就像实际生产过程中的应急预案，发生了某个异常就会启动特定的应急预案，为了响应各类异常情况，所以就定义了很多个信号，信号的名称是在头文件<code>signal.h</code>中定义的，信号都以<code>SIG</code>开头，常用的信号并不多，常用的信号如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SIGALRM</span>     <span class="hljs-comment">#时钟定时信号, 计算的是实际的时间或时钟时间</span><br>SIGHUP      <span class="hljs-comment">#终端的挂断或进程死亡</span><br>SIGINT      <span class="hljs-comment">#来自键盘的中断信号</span><br>SIGKILL     <span class="hljs-comment">#用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。</span><br>SIGPIPE     <span class="hljs-comment">#管道破裂</span><br>SIGTERM     <span class="hljs-comment">#程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理</span><br>SIGUSR1,SIGUSR2     <span class="hljs-comment">#留给用户使用</span><br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nOps! - I got signal %d\n&quot;</span>, sig);<br><br>    <span class="hljs-comment">// 恢复终端中断信号SIGINT的默认行为</span><br>    (<span class="hljs-keyword">void</span>)signal(SIGINT, SIG_DFL);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 改变终端中断信号SIGINT的默认行为，使之执行ouch函数</span><br>    <span class="hljs-comment">// 而不是终止程序的执行</span><br>    (<span class="hljs-keyword">void</span>)signal(SIGINT, signalHandler);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以用<code>signal()</code>函数处理指定的信号，主要通过忽略和恢复其默认行为来工作。signal()函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> (*signal(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">int</span>)))(<span class="hljs-keyword">int</span>);<br></code></pre></td></tr></table></figure><p>这是一个相当复杂的声明，耐心点看可以知道signal是一个带有<code>sig</code>和<code>func</code>两个参数的函数，<code>func</code>是一个类型为<code>void (*)(int)</code>的函数指针。该函数返回一个与<code>func</code>相同类型的指针，指向先前指定信号处理函数的函数指针。准备捕获的信号的参数由<code>sig</code>给出，接收到的指定信号后要调用的函数由参数<code>func</code>给出。其实这个函数的使用是相当简单的，通过下面的例子就可以知道。注意信号处理函数的原型必须为<code>void func（int）</code>，或者是下面的特殊值：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">SIG_IGN : 忽略信号<br>SIG_DFL : 恢复信号的默认行为<br></code></pre></td></tr></table></figure><p>我们程序的目的是想要捕获键盘输入<code>Ctrl+C</code>，这个中断。通过表里可以查到，我们使用<code>SIGINT</code>这个信号，当我们的程序出现<code>SIGINT</code>信号时，让程序接下来干啥呢？正常情况下，我们的<code>Ctrl+C</code>会中断当前运行的程序，但是现在我们做了一些更改，更改的内容在我们自己编写的<code>signalHandler</code>中。我们让程序输出一行字符串加上信号值。然后再把信号的行为恢复原样。此时我们运行程序可以得到如下</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210811143147.png"></p><p>在我们第一输入<code>Ctrl+C</code>时，程序没有中断，而是调用了<code>signalHanlder</code>函数，因为我们更改了信号的行为。但是第二次输入<code>Ctrl+C</code>时，程序中断了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信（IPC）之共享内存(SharedMemory)</title>
    <link href="/2021/08/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88SharedMemory%EF%BC%89/"/>
    <url>/2021/08/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88SharedMemory%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>关于进程间通信的概述可以查看<a href="https://dunky-z.github.io/2021/08/10/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">Linux操作系统-进程间通信</a>，<a href="https://github.com/Dunky-Z/learning-linux/tree/main/IPC/SharedMemory">代码同步在这里</a>。</p><p>本文通过实例介绍通过共享内存实现进程间通信。</p><h2 id="shmget-得到一个共享内存标识符或创建一个共享内存对象"><a href="#shmget-得到一个共享内存标识符或创建一个共享内存对象" class="headerlink" title="shmget(得到一个共享内存标识符或创建一个共享内存对象)"></a>shmget(得到一个共享内存标识符或创建一个共享内存对象)</h2><p>我们可以通过<code>shmget</code>函数创建或打开共享内存，通过函数签名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//key_t key:  唯一定位一个共享内存对象</span><br><span class="hljs-comment">//size_t size: 共享内存大小</span><br><span class="hljs-comment">//int flag: 如果是IPC_CREAT表示创建新的共享内存空间</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> flag)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>第一个参数是共享内存的唯一标识，是需要我们指定的。那么如何指定<code>key</code>呢？如何保证唯一性呢？我们可以指定一个文件，<code>ftok </code>会根据这个文件的 <code>inode</code>，生成一个近乎唯一的 <code>key</code>。只要在这个消息队列的生命周期内，这个文件不要被删除就可以了。只要不删除，无论什么时刻，再调用 <code>ftok</code>，也会得到同样的<code> key</code>。</li><li>第二个参数是申请的空间大小，我们就申请1024B。</li><li>第三个参数是权限标识，<code>IPC_CREAT</code>表示创建共享内存，<code>0644</code>表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。</li></ul><h2 id="shmat-把共享内存区对象映射到调用进程的地址空间"><a href="#shmat-把共享内存区对象映射到调用进程的地址空间" class="headerlink" title="shmat(把共享内存区对象映射到调用进程的地址空间)"></a>shmat(把共享内存区对象映射到调用进程的地址空间)</h2><p>第一次创建完共享内存时，它还不能被任何进程访问，<code>shmat()</code>函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。它的签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">shmat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *shm_addr, <span class="hljs-keyword">int</span> shmflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>第一个参数就是上文产生的唯一标识。</li><li>第二个参数，<code>shm_addr</code>指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</li><li>第三个参数，<code>shm_flg</code>是一组标志位，通常为0。<br>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</li></ul><p><code>(void *) - 1</code>把<code>-1</code>转换为指针<code>0xFFFFFFFF</code>，有时也会用到<code>(void*)0</code>，表示一个空指针。</p><h2 id="shmdt-断开共享内存连接"><a href="#shmdt-断开共享内存连接" class="headerlink" title="shmdt(断开共享内存连接)"></a>shmdt(断开共享内存连接)</h2><p>与shmat函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存</p><p>函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmdt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *shmaddr)</span></span><br></code></pre></td></tr></table></figure><ul><li>参数一<code>shmaddr</code>为连接共享内存的起始地址。</li></ul><p>需要注意的是，本函数调用并不删除所指定的共享内存区，而只是将先前用shmat函数连接（attach）好的共享内存脱离（detach）目前的进程。删除共享内存就需要下面的这个函数。</p><h2 id="shmctl-共享内存管理"><a href="#shmctl-共享内存管理" class="headerlink" title="shmctl(共享内存管理)"></a>shmctl(共享内存管理)</h2><p>完成对共享内存的控制，包括改变状态，删除共享内存等。</p><p>函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shmid, <span class="hljs-keyword">int</span> cmd, struct shmid_ds *buf)</span></span><br></code></pre></td></tr></table></figure><ul><li><code>shmid</code>共享内存唯一标识符</li><li><code>cmd</code>执行的操作，包括如下<ul><li><code>IPC_STAT</code>：得到共享内存的状态，把共享内存的<code>shmid_ds</code>结构复制到<code>buf</code>中</li><li><code>IPC_SET</code>：改变共享内存的状态，把<code>buf</code>所指的<code>shmid_ds</code>结构中的<code>uid</code>、<code>gid</code>、<code>mode</code>复制到共享内存的<code>shmid_ds</code>结构内</li><li><code>IPC_RMID</code>：删除这片共享内存</li></ul></li><li><code>buf</code>共享内存管理结构体。具体说明参见共享内存内核结构定义部分</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//server.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> shmid;<br>    <span class="hljs-keyword">key_t</span> shmkey;<br>    <span class="hljs-keyword">char</span> *shmptr;<br>    shmkey = ftok(<span class="hljs-string">&quot;./client.c&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 创建或打开内存共享区域</span><br>    shmid = shmget(shmkey, <span class="hljs-number">1024</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (shmid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmget error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将共享内存映射到当前进程的地址中，</span><br>    <span class="hljs-comment">//之后直接对进程中的地址addr操作就是对共享内存操作</span><br>    shmptr = (<span class="hljs-keyword">char</span> *)shmat(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (shmptr == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmat error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 把用户的输入存到共享内存区域中</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, shmptr);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//client.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> shmid;<br>    <span class="hljs-keyword">char</span> *shmptr;<br>    <span class="hljs-keyword">key_t</span> shmkey;<br>    shmkey = ftok(<span class="hljs-string">&quot;./client.c&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 创建或打开内存共享区域</span><br>    shmid = shmget(shmkey, <span class="hljs-number">1024</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (shmid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmget error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将共享内存映射到当前进程的地址中，</span><br>    <span class="hljs-comment">//之后直接对进程中的地址addr操作就是对共享内存操作</span><br>    shmptr = (<span class="hljs-keyword">char</span> *)shmat(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (shmptr == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;shmat error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 每隔 3 秒从共享内存中取一次数据并打印到控制台</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string:%s\n&quot;</span>, shmptr);<br>        sleep(<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在两个终端分别运行<code>client</code>和<code>server</code>，<code>client</code>会每三秒在终端打印出<code>server</code>输入的内容。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810205816.png"><br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210810205830.png"></p><h3 id="如何手动删除共享内存？"><a href="#如何手动删除共享内存？" class="headerlink" title="如何手动删除共享内存？"></a>如何手动删除共享内存？</h3><p>列出所有的共享内存段：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dns">ipcs -m<br>------------ 共享内存段 --------------<br>键        shmid      拥有者  权限     字节     连接数  状态      <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">2</span>          dominic    <span class="hljs-number">600</span>        <span class="hljs-number">16384</span>      <span class="hljs-number">1</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">753668</span>     dominic    <span class="hljs-number">606</span>        <span class="hljs-number">10089696</span>   <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">622597</span>     dominic    <span class="hljs-number">600</span>        <span class="hljs-number">4194304</span>    <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">753670</span>     dominic    <span class="hljs-number">606</span>        <span class="hljs-number">10089696</span>   <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">688135</span>     dominic    <span class="hljs-number">600</span>        <span class="hljs-number">899976</span>     <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">8</span>          dominic    <span class="hljs-number">600</span>        <span class="hljs-number">524288</span>     <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">9</span>          dominic    <span class="hljs-number">600</span>        <span class="hljs-number">524288</span>     <span class="hljs-number">2</span>          目标       <br><span class="hljs-number">0x00000000</span> <span class="hljs-number">753674</span>     dominic    <span class="hljs-number">600</span>        <span class="hljs-number">7127040</span>    <span class="hljs-number">2</span>          目标 <br><span class="hljs-number">0</span>x0000006f <span class="hljs-number">720918</span>     dominic    <span class="hljs-number">666</span>        <span class="hljs-number">1024</span>        <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们发现最后一个键值为<code>0x0000006f = 111</code>的共享内存段，就是我们创建的共享内存段。<br>删除指定共享内存段：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ipcrm</span> -m <span class="hljs-number">720918</span>  <br>或者 <br>ipcrm -M 0x0000006f  <br></code></pre></td></tr></table></figure><p>信号量和消息队列的操作，命令类似，只是参数不同。<br>查看命令：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">ipcs [-m|<span class="hljs-type">-q</span>|<span class="hljs-type">-s</span>]<br></code></pre></td></tr></table></figure><ul><li><code>-m</code> 输出有关共享内存(shared memory)的信息</li><li><code>-q</code> 输出有关信息队列(message queue)的信息</li><li><code>-s</code> 输出有关“信号量”(semaphore)的信息</li></ul><p>删除命令</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">ipcrm [ -M<span class="hljs-built_in"> key</span> | -m<span class="hljs-built_in"> id</span> | -Q<span class="hljs-built_in"> key</span> | -q<span class="hljs-built_in"> id</span> | -S<span class="hljs-built_in"> key</span> | -s<span class="hljs-built_in"> id</span> ]<br></code></pre></td></tr></table></figure><ul><li><code>-M</code>用shmkey删除共享内存</li><li><code>-m</code>用shmid删除共享内存</li><li><code>-Q</code>用msgkey删除消息队列</li><li><code>-q</code>用msgid删除消息队列</li><li><code>-S</code>用semkey删除信号量</li><li><code>-s</code>用semid删除信号量</li></ul><h2 id="超过共享内存的大小限制"><a href="#超过共享内存的大小限制" class="headerlink" title="超过共享内存的大小限制"></a>超过共享内存的大小限制</h2><p>共享内存的总体大小是有限制的，这个大小通过SHMMAX参数来定义（以字节为单位），您可以通过执行以下命令来确定 SHMMAX 的值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmmax<br></code></pre></td></tr></table></figure><p>如果机器上创建的共享内存的总共大小超出了这个限制，在程序中使用标准错误<code>perror</code>可能会出现以下的信息：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">unable <span class="hljs-keyword">to</span> attach <span class="hljs-keyword">to</span> <span class="hljs-keyword">shared</span> memory<br></code></pre></td></tr></table></figure><p>1、设置 SHMMAX</p><p>　　SHMMAX 的默认值是 <code>32MB</code> 。一般使用下列方法之一种将 SHMMAX 参数设为 <code>2GB</code> ：<br>通过直接更改 <code>/proc</code> 文件系统，你不需重新启动机器就可以改变 SHMMAX 的默认设置。我使用的方法是将以下命令放入 <code>/&gt;etc/rc.local</code> 启动文件中：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-string">&quot;2147483648&quot;</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmmax<br></code></pre></td></tr></table></figure><p>　　您还可以使用 <code>sysctl</code> 命令来更改 SHMMAX 的值：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sysctl -w kernel.<span class="hljs-attribute">shmmax</span>=2147483648<br></code></pre></td></tr></table></figure><p>最后，通过将该内核参数插入到<code> /etc/sysctl.conf</code> 启动文件中，您可以使这种更改永久有效：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;kernel.shmmax=2147483648&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>sysctl.conf<br></code></pre></td></tr></table></figure><p>　　2、设置 SHMMNI</p><p>　　我们现在来看 SHMMNI 参数。这个内核参数用于设置系统范围内共享内存段的最大数量。该参数的默认值是 <code>4096</code> 。这一数值已经足够，通常不需要更改。您可以通过执行以下命令来确定 SHMMNI 的值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmmni<br></code></pre></td></tr></table></figure><p>　　3、设置 SHMALL</p><p>　　最后，我们来看 SHMALL 共享内存内核参数。该参数控制着系统一次可以使用的共享内存总量（以页为单位）。简言之，该参数的值始终应该至少为：<code>ceil(SHMMAX/PAGE_SIZE)</code></p><p>SHMALL 的默认大小为 <code>2097152</code> ，可以使用以下命令进行查询：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>shmall<br></code></pre></td></tr></table></figure><p>　　SHMALL 的默认设置对于我们来说应该足够使用。注意： 在 i386 平台上 Red Hat Linux 的 页面大小 为 <code>4096</code> 字节。但是，您可以使用 <code>bigpages</code> ，它支持配置更大的内存页面尺寸。</p><h2 id="多次进行shmat操作会出现什么问题"><a href="#多次进行shmat操作会出现什么问题" class="headerlink" title="多次进行shmat操作会出现什么问题"></a>多次进行shmat操作会出现什么问题</h2><p>一个进程是可以对同一个共享内存多次 shmat进行挂载的，物理内存是指向同一块，如果shmaddr为NULL，则每次返回的线性地址空间都不同。而且指向这块共享内存的引用计数会增加。也就是进程多块线性空间会指向同一块物理地址。这样，如果之前挂载过这块共享内存的进程的线性地址没有被<code>shmdt</code>掉，即申请的线性地址都没有释放，就会一直消耗进程的虚拟内存空间，很有可能会最后导致进程线性空间被使用完而导致下次shmat或者其他操作失败。</p><h2 id="shmget创建共享内存，当key相同时，什么情况下会出错？"><a href="#shmget创建共享内存，当key相同时，什么情况下会出错？" class="headerlink" title="shmget创建共享内存，当key相同时，什么情况下会出错？"></a>shmget创建共享内存，当key相同时，什么情况下会出错？</h2><p>当创建一个新的共享内存区时，size 的值必须大于 0 ；如果是访问一个已经存在的内存共享区，则置 size 为 0 。</p><p>已经创建的共享内存的大小是可以调整的，但是已经创建的共享内存的大小只能调小，不能调大</p><p>当多个进程都能创建共享内存的时候，如果key出现相同的情况，并且一个进程需要创建的共享内存的大小要比另外一个进程要创建的共享内存小，共享内存大的进程先创建共享内存，共享内存小的进程后创建共享内存，小共享内存的进程就会获取到大的共享内存进程的共享内存，并修改其共享内存的大小和内容，从而可能导致大的共享内存进程崩溃。</p><h2 id="ftok是否一定会产生唯一的key值？"><a href="#ftok是否一定会产生唯一的key值？" class="headerlink" title="ftok是否一定会产生唯一的key值？"></a>ftok是否一定会产生唯一的key值？</h2><p>ftok原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">key_t</span> <span class="hljs-title">ftok</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * pathname, <span class="hljs-keyword">int</span> proj_id)</span></span><br></code></pre></td></tr></table></figure><p><code>pathname</code>就时你指定的文件名，<code>proj_id</code>是子序号。在一般的UNIX实现中，是将文件的索引节点号取出，前面加上子序号得到<code>key_t</code>的返回值。如指定文件的索引节点号为65538，换算成16进制为<code>0×010002</code>，而你指定的<code>proj_id</code>值为<code>38</code>，换算成16进制为<code>0×26</code>，则最后的<code>key_t</code>返回值为<code>0×26010002</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-ar多文件归档为一个文件</title>
    <link href="/2021/08/10/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ar%E5%A4%9A%E6%96%87%E4%BB%B6%E5%BD%92%E6%A1%A3%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/"/>
    <url>/2021/08/10/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ar%E5%A4%9A%E6%96%87%E4%BB%B6%E5%BD%92%E6%A1%A3%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>现在我们有<code>solution.c</code>,<code>solution.h</code>两个文件，他们实现了某一个功能，自成一个模块。在其他项目中也可复用。我们就可以把它做成库文件。<code>ar</code>命令就可以将锁哥文件整合成一个库文件，也可以从一个库中单独提取出某一个文件。</p><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-d 　删除备存文件中的成员文件。</span><br><span class="hljs-deletion">-m 　变更成员文件在备存文件中的次序。</span><br><span class="hljs-deletion">-p 　显示备存文件中的成员文件内容。</span><br><span class="hljs-deletion">-q 　将文件附加在备存文件末端。</span><br><span class="hljs-deletion">-r 　将文件插入备存文件中。</span><br><span class="hljs-deletion">-t 　显示备存文件中所包含的文件。</span><br><span class="hljs-deletion">-x 　自备存文件中取出成员文件。</span><br></code></pre></td></tr></table></figure><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="打包文件"><a href="#打包文件" class="headerlink" title="打包文件"></a>打包文件</h3><p>将<code>solution.c solution.h</code>两个文件打包成<code>solution.bak</code>，并显示详细信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  ar rv solution<span class="hljs-selector-class">.bak</span> solution<span class="hljs-selector-class">.c</span> solution<span class="hljs-selector-class">.h</span><br>ar: 正在创建 solution<span class="hljs-selector-class">.bak</span><br><span class="hljs-selector-tag">a</span> - solution<span class="hljs-selector-class">.c</span><br><span class="hljs-selector-tag">a</span> - solution.h<br></code></pre></td></tr></table></figure><h3 id="显示打包文件内容"><a href="#显示打包文件内容" class="headerlink" title="显示打包文件内容"></a>显示打包文件内容</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  ar t solution<span class="hljs-selector-class">.bak</span> <br>solution<span class="hljs-selector-class">.c</span><br>solution.h<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日学命令-ps显示进程状态</title>
    <link href="/2021/08/09/%E6%AF%8F%E6%97%A5%E5%AD%A6%E5%91%BD%E4%BB%A4-ps%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <url>/2021/08/09/%E6%AF%8F%E6%97%A5%E5%AD%A6%E5%91%BD%E4%BB%A4-ps%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p><code>ps</code>命令显示的信息类似于Windows的任务管理器。也是参数超级多的一个命令，所以就不列参数了，需要查看时直接搜索，这里列举一下实例。</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>显示当前执行的所有程序</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">➜  ~ ps -a<br>    PID TTY          TIME CMD<br>   <span class="hljs-number"> 879 </span>tty2     00:03:43 Xorg<br>   <span class="hljs-number"> 990 </span>tty2     00:00:00 gnome-session-b<br>  <span class="hljs-number"> 2653 </span>pts/0    00:00:00 zsh<br> <span class="hljs-number"> 12365 </span>pts/0    00:00:00 ps<br><br></code></pre></td></tr></table></figure><p>显示所有程序</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tap">➜  ~ ps -A<br>    PID TTY          TIME CMD<br>     <span class="hljs-number"> 1 </span>?        00:00:01 systemd<br>     <span class="hljs-number"> 2 </span>?        00:00:00 kthreadd<br>     <span class="hljs-number"> 3 </span>?        00:00:00 rcu_gp<br>     <span class="hljs-number"> 4 </span>?        00:00:00 rcu_par_gp<br>     <span class="hljs-number"> 6 </span>?        00:00:00 kworker/0:0H-kblockd<br>     <span class="hljs-number"> 9 </span>?        00:00:00 mm_percpu_wq<br>    <span class="hljs-number"> 10 </span>?        00:00:00 ksoftirqd/0<br>    <span class="hljs-number"> 11 </span>?        00:00:02 rcu_sched<br>    <span class="hljs-number"> 12 </span>?        00:00:00 migration/0<br>    <span class="hljs-number"> 13 </span>?        00:00:00 idle_inject/0<br>    <span class="hljs-number"> 14 </span>?        00:00:00 cpuhp/0<br>    <span class="hljs-number"> 15 </span>?        00:00:00 kdevtmpfs<br>.<br>.<br>.<br></code></pre></td></tr></table></figure><p>显示指定用户的信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">➜  ~ <span class="hljs-built_in">ps</span> <span class="hljs-literal">-u</span> root<br></code></pre></td></tr></table></figure><p><code>a</code>显示现行终端机下的所有程序，包括其他用户的程序，<code>u</code>以用户为主的格式来显示程序状况，<code>x</code>显示所有程序，不以终端机来区分<br><code>USER</code>－运行该流程的用户。</p><p><code>%CPU</code>－进程cpu利用率。</p><p><code>%MEM</code>－进程驻留集大小占计算机物理内存的百分比。</p><p><code>VSZ</code>－KiB中进程的虚拟内存大小。</p><p><code>RSS</code>－进程正在使用的物理内存的大小。</p><p><code>STAT</code>－进程状态代码，可以是Z（zombie），S（休眠），R（运行）..等等。</p><p><code>START</code>－命令启动的时间。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">➜  ~ ps aux              <br>USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root          <span class="hljs-number"> 1 </span> 0.0  0.2<span class="hljs-number"> 102084 </span>11540 ?        Ss   09:09   0:01 /sbin/init splash<br>root          <span class="hljs-number"> 2 </span> 0.0  0.0     <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>?        S    09:09   0:00 [kthreadd]<br>root          <span class="hljs-number"> 3 </span> 0.0  0.0     <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>?        I&lt;   09:09   0:00 [rcu_gp]<br></code></pre></td></tr></table></figure><p>按 CPU 资源的使用量对进程进行排序：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">➜  ~ ps aux | sort -nk 3<br>avahi       <span class="hljs-number"> 492 </span> 0.0  0.0  <span class="hljs-number"> 8536 </span><span class="hljs-number"> 3260 </span>?        Ss   09:09   0:00 avahi-daemon: running [hanhan.local]<br>avahi       <span class="hljs-number"> 552 </span> 0.0  0.0  <span class="hljs-number"> 8352 </span> <span class="hljs-number"> 332 </span>?        S    09:09   0:00 avahi-daemon: chroot helper<br>colord     <span class="hljs-number"> 1442 </span> 0.0  0.3<span class="hljs-number"> 255144 </span>14408 ?        Ssl  09:09   0:00 /usr/libexec/colord<br>dominic    <span class="hljs-number"> 1068 </span> 0.0  0.0 <span class="hljs-number"> 31244 </span> <span class="hljs-number"> 364 </span>?        S    09:09   0:00 /usr/bin/VBoxClient --clipboard<br>dominic    <span class="hljs-number"> 1069 </span> 0.0  0.9<span class="hljs-number"> 163512 </span>39088 ?        Sl   09:09   0:00 /usr/bin/VBoxClient --clipboard<br>dominic    <span class="hljs-number"> 1080 </span> 0.0  0.0 <span class="hljs-number"> 31244 </span> <span class="hljs-number"> 364 </span>?        S    09:09   0:00 /usr/bin/VBoxClient --seamless<br><br><span class="hljs-comment"># 其中`sort`命令中`-n`为按数值进行排序，`-k  3` 表示以输出结果的第三列来进行排序，</span><br><span class="hljs-comment"># 从上一个实例中看到，第三列为CPU使用率`%CPU`。</span><br><span class="hljs-comment"># 同理ps aux | sort -rnk 4 即按内存使用降序排序</span><br></code></pre></td></tr></table></figure><p>显示前5名最耗cpu的进程</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">➜  ~ ps aux --<span class="hljs-keyword">sort</span>=-pcpu | head -<span class="hljs-number">5</span><br>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root         <span class="hljs-number">1</span>  <span class="hljs-number">2.6</span>  <span class="hljs-number">0.7</span>  <span class="hljs-number">51396</span>  <span class="hljs-number">7644</span> ?        Ss   <span class="hljs-number">02</span>:<span class="hljs-number">02</span>   <span class="hljs-number">0</span>:<span class="hljs-number">03</span> <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>systemd --switched-root --system --deserialize <span class="hljs-number">23</span><br>root      <span class="hljs-number">1249</span>  <span class="hljs-number">2.6</span>  <span class="hljs-number">3.0</span> <span class="hljs-number">355800</span> <span class="hljs-number">30896</span> tty1     Rsl+ <span class="hljs-number">02</span>:<span class="hljs-number">02</span>   <span class="hljs-number">0</span>:<span class="hljs-number">02</span> <span class="hljs-regexp">/usr/</span>bin/X -background none :<span class="hljs-number">0</span> vt01 -nolisten tcp<br>root       <span class="hljs-number">508</span>  <span class="hljs-number">2.4</span>  <span class="hljs-number">1.6</span> <span class="hljs-number">248488</span> <span class="hljs-number">16776</span> ?        Ss   <span class="hljs-number">02</span>:<span class="hljs-number">02</span>   <span class="hljs-number">0</span>:<span class="hljs-number">03</span> <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python /u</span>sr<span class="hljs-regexp">/sbin/</span>firewalld --nofor<br></code></pre></td></tr></table></figure><p>下面的命令会显示进程id为3150的进程的所有线程</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">➜  ~ ps -<span class="hljs-selector-tag">p</span> <span class="hljs-number">3150</span> -L<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决OpenSSL SSL_connect: Connection was reset in connection to github.com:443</title>
    <link href="/2021/08/09/%E8%A7%A3%E5%86%B3OpenSSL-SSL-connect-Connection-was-reset-in-connection-to-github-com-443/"/>
    <url>/2021/08/09/%E8%A7%A3%E5%86%B3OpenSSL-SSL-connect-Connection-was-reset-in-connection-to-github-com-443/</url>
    
    <content type="html"><![CDATA[<p>在向github推送博客时，推送失败报了这个错。也不知道是改了什么设置突然报错。SSL的错之前遇到一次，就是刚开始配置Git时用的<code>https</code>协议，每次<code>push</code>都需要重新输入一次密码。改成<code>ssl</code>协议就OK了。当时把Linux环境的Git改了，但是现在的Windows下没改，猜测可能和这也有关，于是就把URL改了一下，结果还真好了。<br>在本地仓库的<code>.git</code>文件里找到<code>config</code>文件，打开后将<code>url</code>改为<code>ssl</code>协议，<code>git@github.com:XXX</code>格式的。</p><p>将Hexo的配置也改了，找到仓库下的<code>_config.yml</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> 改成ssl协议地址<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Bug</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt事件</title>
    <link href="/2021/08/09/Qt%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/08/09/Qt%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>本篇文章所涉及代码可在<a href="https://github.com/Dunky-Z/learning-qt/tree/main/Event">此处查看</a></p><h2 id="事件以及与信号的区别"><a href="#事件以及与信号的区别" class="headerlink" title="事件以及与信号的区别"></a>事件以及与信号的区别</h2><p><strong>事件</strong>（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p><p>事件和信号槽的区别</p><ul><li>信号是由具体对象发出，然后马上交给<code>connect</code>函数连接的槽进行处理，如果处理过程中产生了新的信号，将会继续执行新的信号，一直这样递归进行下去。而事件使用一个事件队列对发出的所有事件进行维护，当新的事件产生时会被加到事件队列的尾部。</li></ul><p>在运行过程中发现，刚启动时并不会显示任何内容，只有在点击一次后，平面才会显示信息。这是因为<code>QWidget</code>中有一个<code>mouseTracking</code>属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，<code>mouseMoveEvent()</code>才会发出。如果<code>mouseTracking</code>是 <code>false</code>（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出<code>mouseMoveEvent()</code>事件。如果<code>mouseTracking</code>为 <code>true</code>，则<code>mouseMoveEvent()</code>直接可以被发出。知道了这一点，我们就可以在<code>main()</code>函数中直接设置下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">EventLabel *label = new EventLabel;<br><span class="hljs-function"><span class="hljs-title">label</span>-&gt;</span>setWindowTitle(<span class="hljs-string">&quot;MouseEvent Demo&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">label</span>-&gt;</span>resize(<span class="hljs-number">300</span>, <span class="hljs-number">200</span>);<br><span class="hljs-function"><span class="hljs-title">label</span>-&gt;</span>setMouseTracking(<span class="hljs-literal">true</span>);<br><span class="hljs-function"><span class="hljs-title">label</span>-&gt;</span>show();<br></code></pre></td></tr></table></figure><h3 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h3><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210809102859.png"></p><h2 id="事件的接受与忽略"><a href="#事件的接受与忽略" class="headerlink" title="事件的接受与忽略"></a>事件的接受与忽略</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//custombutton.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDebug&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomButton</span> :</span> <span class="hljs-keyword">public</span> QPushButton<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onButtonClicked</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CustomButton</span>(QWidget *parent = <span class="hljs-number">0</span>);<br><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//custombutton.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;custombutton.h&quot;</span></span><br><br>CustomButton::<span class="hljs-built_in">CustomButton</span>(QWidget *parent) : <span class="hljs-built_in">QPushButton</span>(parent)<br>&#123;<br>    <span class="hljs-built_in">connect</span>(<span class="hljs-keyword">this</span>, &amp;CustomButton::clicked, <span class="hljs-keyword">this</span>, &amp;CustomButton::onButtonClicked);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CustomButton::onButtonClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;You clicked this!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main02.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;custombutton.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    CustomButton btn;<br>    btn.<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;This is a Button!&quot;</span>);<br>    btn.<span class="hljs-built_in">show</span>();<br><br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码运行结果就是点击按钮会在控制台输出：”You clicked this!”。</p><p>现在，我们在<code>CustomButton</code>类中再添加一个事件函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//custombutton.h</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//custombutton.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CustomButton::mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (event-&gt;<span class="hljs-built_in">button</span>() == Qt::LeftButton)<br>    &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Left&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        QPushButton::<span class="hljs-built_in">mousePressEvent</span>(event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时运行结果为点击按键输出”Left”。而没有再输出”You clicked this!”。说明我们把父类的实现覆盖了。<strong>当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！</strong>。这一定程度上说，我们的组件<strong>忽略</strong>了父类的事件。</p><p>通过调用父类的同名函数，我们可以把 Qt 的事件传递看成链状：如果子类没有处理这个事件，就会继续向其父类传递。<code>Qt</code> 的事件对象有两个函数：<code>accept()</code>和<code>ignore()</code>。正如它们的名字一样，前者用来告诉 Qt，这个类的事件处理函数想要处理这个事件；后者则告诉 Qt，这个类的事件处理函数不想要处理这个事件。在事件处理函数中，可以使用<code>isAccepted()</code>来查询这个事件是不是已经被接收了。具体来说：如果一个事件处理函数调用了一个事件对象的<code>accept()</code>函数，这个事件就不会被继续传播给其父组件；如果它调用了事件的<code>ignore()</code>函数，Qt 会从其父组件中寻找另外的接受者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//custombutton01.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDebug&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QVBoxLayout&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomButton</span> :</span> <span class="hljs-keyword">public</span> QPushButton<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CustomButton</span>(QWidget *parent) : <span class="hljs-built_in">QPushButton</span>(parent)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;CustomButton&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomButtonEx</span> :</span> <span class="hljs-keyword">public</span> CustomButton<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CustomButtonEx</span>(QWidget *parent) : <span class="hljs-built_in">CustomButton</span>(parent)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;CustomButtonEx&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomWidget</span> :</span> <span class="hljs-keyword">public</span> QWidget<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CustomWidget</span>(QWidget *parent) : <span class="hljs-built_in">QWidget</span>(parent)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;CustomWidget&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MainWindow</span>(QWidget *parent = <span class="hljs-number">0</span>) : <span class="hljs-built_in">QMainWindow</span>(parent)<br>    &#123;<br>        CustomWidget *widget = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CustomWidget</span>(<span class="hljs-keyword">this</span>);<br>        CustomButton *cbex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CustomButton</span>(widget);<br>        cbex-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;CustomButton&quot;</span>));<br>        CustomButtonEx *cb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CustomButtonEx</span>(widget);<br>        cb-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;CustomButtonEx&quot;</span>));<br>        QVBoxLayout *widgetLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QVBoxLayout</span>(widget);<br>        widgetLayout-&gt;<span class="hljs-built_in">addWidget</span>(cbex);<br>        widgetLayout-&gt;<span class="hljs-built_in">addWidget</span>(cb);<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setCentralWidget</span>(widget);<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;MainWindow&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//mai03.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;custombutton01.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    MainWindow win;<br>    win.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码在一个<code>MainWindow</code>中添加了一个<code>CustomWidget</code>，里面有两个按钮对象：<code>CustomButton</code>和<code>CustomButtonEx</code>。每一个类都重写了<code>mousePressEvent()</code>函数。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210809145445.png"></p><p>运行程序点击 <code>CustomButtonEx</code>，结果是</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">CustomButtonEx</span><br></code></pre></td></tr></table></figure><p>因为我们重写了<code>mousePressEvent()</code>，所以调用子类自己的函数，如果在<code>CustomButtonEx</code>的<code>mousePressEvent()</code>第一行增加一句<code>event-&gt;accept()</code>，重新运行，发现结果不变。正如我们前面所说，QEvent默认是<code>accept</code>的，调用这个函数并没有什么区别。然后我们将<code>CustomButtonEx</code>的<code>event-&gt;accept()</code>改成<code>event-&gt;ignore()</code>。这次运行结果是</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">CustomButtonEx</span><br><span class="hljs-attribute">CustomWidget</span><br></code></pre></td></tr></table></figure><p><code>ignore()</code>说明我们想让事件继续传播，于是<code>CustomButtonEx</code>的父组件<code>CustomWidget</code>也收到了这个事件，所以输出了自己的结果。</p><p>同理，<code>CustomWidget</code>又没有调用父类函数或者显式设置<code>accept()</code>或<code>ignore()</code>，所以事件传播就此打住。</p><p>这里值得注意的是，<code>CustomButtonEx</code>的事件传播给了父组件<code>CustomWidget</code>，而不是它的父类<code>CustomButton</code>。<strong>事件的传播是在组件层次上面的，而不是依靠类继承机制</strong>。</p><p>在一个特殊的情形下，我们必须使用<code>accept()</code>和<code>ignore()</code>函数，那就是窗口关闭的事件。对于窗口关闭<code>QCloseEvent</code>事件，调用<code>accept()</code>意味着 Qt 会停止事件的传播，窗口关闭；调用<code>ignore()</code>则意味着事件继续传播，即阻止窗口关闭。<a href="https://github.com/Dunky-Z/learning-qt/blob/main/Dialog/mainwindow.cpp">回到我们前面写的简单的文本编辑器</a>。</p><h2 id="event-函数"><a href="#event-函数" class="headerlink" title="event()函数"></a>event()函数</h2><p>事件对象创建完毕后，Qt 将这个事件对象传递给<code>QObject</code>的<code>event()</code>函数。<code>event()</code>函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（<code>event handler</code>）。</p><p>如上所述，<code>event()</code>函数主要用于事件的分发。所以，如果你希望在事件分发之前做一些操作，就可以重写这个<code>event()</code>函数了。例如，我们希望在一个QWidget组件中监听 <code>tab</code> 键的按下，那么就可以继承QWidget，并重写它的<code>event()</code>函数，来达到这个目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CustomWidget::event</span><span class="hljs-params">(QEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) <br>    &#123;<br>        QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(e);<br>        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) <br>        &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;You press tab.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">event</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CustomWidget</code>是一个普通的<code>QWidget</code>子类。我们重写了它的<code>event()</code>函数，这个函数有一个<code>QEvent</code>对象作为参数，也就是需要转发的事件对象。函数返回值是 <code>bool</code> 类型。如果传入的事件已被识别并且处理，则需要返回 <code>true</code>，否则返回 <code>false</code>。如果返回值是 <code>true</code>，并且，该事件对象设置了<code>accept()</code>，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。注意，在<code>event()</code>函数中，调用事件对象的<code>accept()</code>和<code>ignore()</code>函数是没有作用的，不会影响到事件的传播。</p><p>我们可以通过使用<code>QEvent::type()</code>函数可以检查事件的实际类型，其返回值是<code>QEvent::Type</code>类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 <code>true</code>，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的<code>event()</code>函数继续转发，否则这个组件就只能处理我们定义的事件了。为了测试这一种情况，我们可以尝试下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CustomTextEdit::event</span><span class="hljs-params">(QEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) &#123;<br>        QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(e);<br>        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;You press tab.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CustomTextEdit</code>是<code>QTextEdit</code>的一个子类。我们重写了其<code>event()</code>函数，却没有调用父类的同名函数。这样，我们的组件就只能处理 <code>Tab</code> 键，再也无法输入任何文本，也不能响应其它事件，比如鼠标点击之后也不会有光标出现。这是因为我们只处理的<code>KeyPress</code>类型的事件，并且如果不是<code>KeyPress</code>事件，则直接返回 <code>false</code>，鼠标事件根本不会被转发，也就没有了鼠标事件。</p><h2 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h2><p>有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。</p><p>通过前面的章节，我们已经知道，Qt 创建了<code>QEvent</code>事件对象之后，会调用<code>QObject</code>的<code>event()</code>函数处理事件的分发。显然，我们可以在<code>event()</code>函数中实现拦截的操作。由于<code>event()</code>函数是 <code>protected</code> 的，因此，需要继承已有类。如果组件很多，就需要重写很多个<code>event()</code>函数。这当然相当麻烦，更不用说重写<code>event()</code>函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。</p><p><code>QObject</code>有一个<code>eventFilter()</code>函数，用于建立事件过滤器。这个函数的签名如下：</p><p>这个函数正如其名字显示的那样，是一个“事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。想想做化学实验时用到的过滤器，可以将杂质留到滤纸上，让过滤后的液体溜走。事件过滤器也是如此：它会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 <code>bool</code> 类型，如果你想将参数 <code>event</code> 过滤出来，比如，不想让它继续转发，就返回 <code>true</code>，否则返回 <code>false</code>。事件过滤器的调用时间是目标对象（也就是参数里面的<code>watched</code>对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，<code>watched</code>对象以及以后所有的事件过滤器根本不会知道这么一个事件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">MainWindow</span>();<br> <span class="hljs-keyword">protected</span>:<br>     <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">eventFilter</span><span class="hljs-params">(QObject *obj, QEvent *event)</span></span>;<br> <span class="hljs-keyword">private</span>:<br>     QTextEdit *textEdit;<br> &#125;;<br><br> MainWindow::<span class="hljs-built_in">MainWindow</span>()<br> &#123;<br>     textEdit = <span class="hljs-keyword">new</span> QTextEdit;<br>     <span class="hljs-built_in">setCentralWidget</span>(textEdit);<br>     textEdit-&gt;<span class="hljs-built_in">installEventFilter</span>(<span class="hljs-keyword">this</span>);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">MainWindow::eventFilter</span><span class="hljs-params">(QObject *obj, QEvent *event)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (obj == textEdit) &#123;<br>         <span class="hljs-keyword">if</span> (event-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) &#123;<br>             QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(event);<br>             <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Ate key press&quot;</span> &lt;&lt; keyEvent-&gt;<span class="hljs-built_in">key</span>();<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// pass the event on to the parent class</span><br>         <span class="hljs-keyword">return</span> QMainWindow::<span class="hljs-built_in">eventFilter</span>(obj, event);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><code>MainWindow</code>是我们定义的一个类。我们重写了它的<code>eventFilter()</code>函数。为了过滤特定组件上的事件，首先需要判断这个对象是不是我们感兴趣的组件，然后判断这个事件的类型。在上面的代码中，我们不想让<code>textEdit</code>组件处理键盘按下的事件。所以，首先我们找到这个组件，如果这个事件是键盘事件，则直接返回 <code>true</code>，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回 <code>false</code>。对于其它的组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。</p><p><code>eventFilter()</code>函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用<code>QObject::installEventFilter()</code>函数。这个函数的签名如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QObject::installEventFilter</span> <span class="hljs-params">( QObject * filterObj )</span></span><br></code></pre></td></tr></table></figure><p>这个函数接受一个<code>QObject *</code>类型的参数。记得刚刚我们说的，<code>eventFilter()</code>函数是<code>QObject</code>的一个成员函数，因此，任意<code>QObject</code>都可以作为事件过滤器（问题在于，如果你没有重写<code>eventFilter()</code>函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过<code>QObject::removeEventFilter()</code>函数移除。</p><p>我们可以向一个对象上面安装多个事件处理器，只要调用多次<code>installEventFilter()</code>函数。如果一个对象存在多个事件过滤器，那么，<strong>最后一个安装的会第一个执行</strong>，也就是后进先执行的顺序。</p><p>还记得我们前面的那个例子吗？我们使用<code>event()</code>函数处理了 <code>Tab</code> 键：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CustomWidget::event</span><span class="hljs-params">(QEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) &#123;<br>        QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(e);<br>        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;You press tab.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">event</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FilterObject::eventFilter</span><span class="hljs-params">(QObject *object, QEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (object == target &amp;&amp; event-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) &#123;<br>        QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(event);<br>        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) &#123;<br>            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;You press tab.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，<code>installEventFilter()</code>函数是<code>QObject</code>的函数，<code>QApplication</code>或者<code>QCoreApplication</code>对象都是<code>QObject</code>的子类，因此，我们可以向<code>QApplication</code>或者<code>QCoreApplication</code>添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。因此，除非是不得不使用的情况，否则的话我们不应该这么做。</p><p><strong>注意，如果你在事件过滤器中 <code>delete</code> 了某个接收组件，务必将函数返回值设为 <code>true</code>。否则，Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃。</strong></p><p><strong>事件过滤器和被安装过滤器的组件必须在同一线程</strong>，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p><blockquote><p>事件过滤器和安装过滤器的组件必须在同一线程。Qt 里面，对象创建之后，可以使用 moveToThread() 函数将一个对象移动到另外的线程。在这种情形下（当然，事件过滤器必须在同一线程时才能被正确安装，这是第一句话说明的），在它们分属在不同线程时，事件过滤器也是不起作用的，只用当它们重新回到同一线程（使用 moveToThread() 或者是线程自然结束）时，过滤器才能重新工作</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-scp远程拷贝文件</title>
    <link href="/2021/08/06/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-scp%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/"/>
    <url>/2021/08/06/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-scp%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>看到同事要安装自己编译一天的库，本想传授一下“踩坑经验”，结果他用<code>scp</code>命令直接从已经安装好的电脑里复制了一份。心里一万只XXX在奔腾。</p><p>早知道先学学这个命令了。</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">强制scp命令使用协议ssh1</td></tr><tr><td align="center">-2</td><td align="center">强制scp命令使用协议ssh2</td></tr><tr><td align="center">-4</td><td align="center">强制scp命令使用协议ssh2</td></tr><tr><td align="center">-6</td><td align="center">强制scp命令只使用IPv6寻址</td></tr><tr><td align="center">-B</td><td align="center">使用批处理模式（传输过程中不询问传输口令或短语）</td></tr><tr><td align="center">-C</td><td align="center">允许压缩</td></tr><tr><td align="center">-p</td><td align="center">保留原文件的修改时间，访问时间和访问权限。</td></tr><tr><td align="center">-q</td><td align="center">不显示传输进度条</td></tr><tr><td align="center">-r</td><td align="center">递归复制整个目录</td></tr><tr><td align="center">-v</td><td align="center">详细方式显示输出</td></tr><tr><td align="center">-P</td><td align="center">注意是大写的P, port是指定数据传输用到的端口号</td></tr></tbody></table><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>复制文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp local_file rmot_usr<span class="hljs-variable">@rmot_ip</span><span class="hljs-symbol">:rmot_folder</span><br>scp /opt/soft/ root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.120</span>.<span class="hljs-number">204</span><span class="hljs-symbol">:/opt/soft/nginx-</span>0.<span class="hljs-number">5.38</span>.tar.gz <br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-grep文本搜索</title>
    <link href="/2021/08/05/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-grep%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/08/05/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-grep%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><code>grep</code>全称<code>global search regular expression(RE) and print out the line</code>，全面搜索正则表达式并把行打印出来。这名字就怪吓人，如果熟练掌握正则表达式，配上这命令Linux里可以横着走了。</p><p>这个命令参数实在太多，加上正则表达式估计一张纸不够。那就直接上实例吧。</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>在当前目录中，查找后缀带有<code>cpp</code>字样的文中包含<code>test</code>字符串的文件，并打印所在行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-built_in">test</span> *cpp<br>grep --colorauto <span class="hljs-built_in">test</span> *cpp      <span class="hljs-comment"># 用颜色标记</span><br></code></pre></td></tr></table></figure><p>通过”-v”参数可以打印出不符合条件行的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -v <span class="hljs-built_in">test</span> *cpp<br></code></pre></td></tr></table></figure><p>系统报警显示了时间，但是日志文件太大无法直接 cat 查看。(查询含有特定文本的文件，并拿到这些文本所在的行)。<code>-n</code> 或 <code>--line-number</code> 可以显示符合样式的那一行之前，标示出该行的列数编号。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grep</span> -n &#x27;<span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">01</span>:<span class="hljs-number">11</span>&#x27; *.log<br></code></pre></td></tr></table></figure><p>grep静默输出，不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> -q <span class="hljs-string">&quot;test&quot;</span> filename<br></code></pre></td></tr></table></figure><p>在多级目录中对文本进行递归搜索</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">grep <span class="hljs-string">&quot;text&quot;</span> . -r -<span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure><p>配合管道，查找指定的进程信息</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> svn<br></code></pre></td></tr></table></figure><p>查找指定的进程个数，<code>-c</code>计数</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> svn -<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>常用正则表达式通配符<br>|  通配符   | 功能  |<br>| :—-:  | :—-:  |<br>| c*  | 将匹配 0 个（即空白）或多个字符 c（c 为任一字符） |<br>| .  | 将匹配任何一个字符，且只能是一个字符 |<br>| [xyz]  | 匹配方括号中的任意一个字符 |<br>| [^xyz]  | 匹配除方括号中字符外的所有字符 |<br>| ^  | 锁定行的开头 |<br>| $  | 锁定行的结尾 |</p><p>在<code>id.txt</code>中找到所有以3207开头的数据</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">grep</span><span class="hljs-regexp"> ^3207</span> id.txt<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt对话框</title>
    <link href="/2021/08/05/Qt%E5%AF%B9%E8%AF%9D%E6%A1%86/"/>
    <url>/2021/08/05/Qt%E5%AF%B9%E8%AF%9D%E6%A1%86/</url>
    
    <content type="html"><![CDATA[<p>本篇文章所涉及代码，可在<a href="https://github.com/Dunky-Z/learning-qt/tree/main/Dialog">此处查看</a></p><p>Qt 中使用QDialog类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog（及其子类，以及所有Qt::Dialog类型的类）的对于其 parent 指针都有额外的解释：</p><p>如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。</p><p>顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。</p><p>对话框分为<strong>模态对话框</strong>和<strong>非模态对话框</strong>。所谓模态对话框，就是会阻塞同一应用程序中其它窗口的输入。模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。</p><p>与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。</p><p>Qt 支持模态对话框和非模态对话框。其中，Qt 有两种级别的模态对话框：<strong>应用程序级别的模态</strong>和<strong>窗口级别的模态</strong>，默认是应用程序级别的模态。应用程序级别的模态是指，当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。窗口级别的模态是指，该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。</p><h2 id="消息对话框-QMessageBox"><a href="#消息对话框-QMessageBox" class="headerlink" title="消息对话框 QMessageBox"></a>消息对话框 QMessageBox</h2><h2 id="文件对话框-QFileDialog"><a href="#文件对话框-QFileDialog" class="headerlink" title="文件对话框 QFileDialog"></a>文件对话框 QFileDialog</h2><h2 id="‘QTextEdit’-Does-not-name-a-type"><a href="#‘QTextEdit’-Does-not-name-a-type" class="headerlink" title="‘QTextEdit’ Does not name a type"></a>‘QTextEdit’ Does not name a type</h2><p>需要包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QTextEdit&gt;</span></span><br></code></pre></td></tr></table></figure><p>Qt需要包含的头文件实在太多了。</p><p>可能添加了头文件仍然报同样的错，没有搜索到相关的解答。</p><p>我的做法是：</p><ol><li>确保在<code>.pro</code>文件中加入<code>QT += widgets</code>和<code>CONFIG += c++11</code></li><li>将包含库文件语句都放到头文件<code>.h</code>中</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git中添加gitignore并更新远程仓库</title>
    <link href="/2021/08/04/Git%E4%B8%AD%E6%B7%BB%E5%8A%A0gitignore%E5%B9%B6%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2021/08/04/Git%E4%B8%AD%E6%B7%BB%E5%8A%A0gitignore%E5%B9%B6%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="gitignore的作用"><a href="#gitignore的作用" class="headerlink" title="gitignore的作用"></a>gitignore的作用</h2><p>在使用<code>Git</code>版本控制时，必须要用<code>.gitignore</code>这个文件来告诉<code>Git</code>那些文件或目录不需要添加到版本控制中。通俗点说，就是不需要<code>git push</code>到远程仓库。</p><p>在平时开发过程中，开发目录下会有各种格式的文件，比如C语言除了<code>.c</code>源码，还会有<code>.o</code>目标文件，没有后缀的可执行程序等等，假如你要进行深度学习类的开发，如图像识别，需要训练大量数据，如果这些训练数据也到跟踪管理，那<code>push</code>一次就可以下班回家了。</p><p>但是我们怎么让<code>Git</code>知道哪些文件需要跟踪，哪些文件不需要呢，这时候<code>.gitignore</code>文件就起作用了。</p><h2 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h2><p>简单介绍一下常用的规则，虽然后面有现成的模板，但是我们还是了解一下常用规则，能看得懂<code>.gitignore</code>里写了啥。也方便自己编写一些规则适应自己的工作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/test/</span>              <span class="hljs-comment"># 过滤整个test文件夹</span><br>*.o                 <span class="hljs-comment"># 过滤所有.o文件</span><br><span class="hljs-regexp">/test/</span>hello.o       <span class="hljs-comment"># 过滤test文件夹下hello.o这个文件</span><br>!src/               <span class="hljs-comment"># 不过滤src这个文件夹</span><br>!*.c                <span class="hljs-comment"># 不过滤.c文件</span><br></code></pre></td></tr></table></figure><h2 id="通过gitignore文件更新远程仓库"><a href="#通过gitignore文件更新远程仓库" class="headerlink" title="通过gitignore文件更新远程仓库"></a>通过gitignore文件更新远程仓库</h2><p>上面说到我们在不同环境下需要制定不同的规则，但是每次都要重新写一遍，又或者不知道制定什么样的规则，还是挺麻烦的。</p><p>首先推荐一个<code>.gitignore</code><a href="https://github.com/github/gitignore">模板仓库</a>，在平时工作学习中遇到的各种语言环境下的模板都能找到。这是广大开发人员总结的一些规则。</p><p>最近在学习<code>Qt</code>，在所有模板中搜索关键字，找到了<code>Qt.gitignore</code>这个模板打开并复制，在自己本地仓库里新建一个<code>.gitignore</code>文件，将复制的内容粘贴进去。</p><p>现在就要解决如何更新远程仓库的内容，因为我在使用<code>.gitignore</code>文件之前已经向远程<code>push</code>过了，现在需要删除不需要的文件。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git rm -r <span class="hljs-comment">--cached .</span><br></code></pre></td></tr></table></figure><p><code>rm</code>就是<code>Linux</code>下常用的删除命令，<code>-r</code>表示递归删除，<code>--cached</code>表示需要在本地端（工作区）保留文件，<code>.</code>表示所有文件。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> .   <span class="hljs-meta"># 重新添加所有文件到暂存区，然后提交，推送</span><br>git commit -m <span class="hljs-string">&quot;update&quot;</span><br>git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt添加资源文件</title>
    <link href="/2021/08/04/Qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <url>/2021/08/04/Qt%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是学习【<a href="https://www.devbean.net/2012/08/qt-study-road-2-catelog/">Qt学习之路</a>】的学习笔记，源码非原创。<a href="https://github.com/Dunky-Z/learning-qt/tree/main/MainWindow">Github</a>同步本文更改的代码。</p></blockquote><p>在建立Qt学习代码仓时，推送到远程的代码比较乱，所以用<code>gitignore</code>文件屏蔽了一些。相关方法在<a href="https://dunky-z.github.io/2021/08/04/Git%E4%B8%AD%E6%B7%BB%E5%8A%A0gitignore%E5%B9%B6%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/">这里</a>。</p><h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><p>Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也<strong>不需要担心这些文件的丢失</strong>。也就是说，如果你将资源以资源文件形式存储，它是会<strong>编译到可执行文件内部</strong>。</p><p>使用QtCreator的<a href="https://www.devbean.net/2012/08/qt-study-road-2-resource-files/">相关方法</a>，讲得也很清楚了，就不赘述了。</p><h2 id="不使用QtCreator添加资源文件"><a href="#不使用QtCreator添加资源文件" class="headerlink" title="不使用QtCreator添加资源文件"></a>不使用QtCreator添加资源文件</h2><p>在使用命令行编译运行时，并不能像在QtCreator中一样，可以自动的生成一个<code>.qrc</code>文件，这就需要我们自己去编写。从原文的讲解中我们也知道，它就是一个<code>XML</code>描述文件，里面定义了文件位置等信息。如原文中的<code>.qrc</code>文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RCC</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">qresource</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;/images&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;doc-open&quot;</span>&gt;</span>document-open.png<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">qresource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">RCC</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;RCC&gt;</span><br>    <span class="hljs-section">&lt;qresource&gt;</span><br><br>    <span class="hljs-section">&lt;/qresource&gt;</span><br><span class="hljs-section">&lt;/RCC&gt;</span><br></code></pre></td></tr></table></figure><p>是固定的标记，再往中间加东西。如果学过<code>html</code>语言就很容易理解。其中<code>prefix=&quot;/images&quot;</code>就是自动加上前缀<code>/images</code>，因为图片在<code>images</code>目录下，每次都加这个路径太麻烦，太长。</p><p><code>alias=&quot;doc-open&quot;</code>意思是将<code>document-open.png</code>这个文件起个别名，原来的太长了。下次再用<code>document-open.png</code>就只需要用<code>doc-open</code>就行了。</p><p>我们知道了这些，就可以编写一个自己的<code>.qrc</code>文件了。我也自己下载了一个打开文件的图标<code>open.png</code>，文件比较少，就和代码放在同一个目录下了。我们将其命名为<code>ico.qrc</code>，这个文件中以后都存放有关图标的资源，我们开始编写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RCC</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">qresource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>open.png<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">qresource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">RCC</span>&gt;</span><br></code></pre></td></tr></table></figure><p>因为添加资源后需要更新<code>.pro</code>文件才能正常编译，所以需要在<code>.pro</code>中加入<code>RESOURCES</code> 信息，就在<code>.pro</code>文件最后一行加入：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">RESOURCES +</span>=<span class="hljs-string"> ico.qrc</span><br></code></pre></td></tr></table></figure><p>然后输入命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">qmake MainWindow.<span class="hljs-keyword">pro</span><br><span class="hljs-keyword">make</span> clean #因为之前可能<span class="hljs-keyword">make</span>过，先清理一遍<br><span class="hljs-keyword">make</span><br>./MainWindow<br></code></pre></td></tr></table></figure><p>如果一切顺利，将会得到下面的窗口：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210804120719.png"></p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210804120739.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.devbean.net/2012/08/qt-study-road-2-action/">https://www.devbean.net/2012/08/qt-study-road-2-action/</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-cat可以查看文件的小猫咪</title>
    <link href="/2021/08/04/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-cat%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%8C%AB%E5%92%AA/"/>
    <url>/2021/08/04/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-cat%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%8C%AB%E5%92%AA/</url>
    
    <content type="html"><![CDATA[<p><code>cat</code> 可以将文件的内容方便地输出到屏幕上。但是它的全称<code>concatenate</code>意为“连接”，连接文件也是它的重要功能之一，很多人可能都不常用。只记得输出文件内容了。</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">n 或 --number              <span class="hljs-comment">#由 1 开始对所有输出的行数编号。</span></span><br><span class="ruby"></span>-<span class="ruby">b 或 --number-nonblank     <span class="hljs-comment">#和 -n 相似，只不过对于空白行不编号。</span></span><br><span class="ruby"></span>-<span class="ruby">s 或 --squeeze-blank       <span class="hljs-comment">#当遇到有连续两行以上的空白行，就代换为一行的空白行。</span></span><br><span class="ruby"></span>-<span class="ruby">v 或 --show-nonprinting    <span class="hljs-comment">#使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</span></span><br><span class="ruby"></span>-<span class="ruby">E 或 --show-ends           <span class="hljs-comment"># 在每行结束处显示 $。</span></span><br><span class="ruby"></span>-<span class="ruby">T 或 --show-<span class="hljs-symbol">tabs:</span>          <span class="hljs-comment">#将 TAB 字符显示为 ^I。</span></span><br><span class="ruby"></span>-<span class="ruby">A, --show-all              <span class="hljs-comment">#等价于 -vET。</span></span><br><span class="ruby"></span>-<span class="ruby">e                          <span class="hljs-comment">#等价于&quot;-vE&quot;选项；</span></span><br><span class="ruby"></span>-<span class="ruby">t                          <span class="hljs-comment">#等价于&quot;-vT&quot;选项；</span></span><br></code></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>将文件内容输出到屏幕</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ cat test.txt <br>This <span class="hljs-keyword">is</span> firt <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> second <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> third <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> fourth <span class="hljs-type">line</span>!<br></code></pre></td></tr></table></figure><p>将<code>test.txt</code>的内容输入到<code>test01.txt</code>中</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ cat test.txt &gt; test01.txt<br>➜  ~ cat test01.txt <br>This <span class="hljs-keyword">is</span> firt <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> second <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> third <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> fourth <span class="hljs-type">line</span>!<br></code></pre></td></tr></table></figure><p>带行号输出</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ cat -n test.txt <br>     <span class="hljs-number">1</span>This <span class="hljs-keyword">is</span> firt <span class="hljs-type">line</span>!<br>     <span class="hljs-number">2</span>This <span class="hljs-keyword">is</span> second <span class="hljs-type">line</span>!<br>     <span class="hljs-number">3</span>This <span class="hljs-keyword">is</span> third <span class="hljs-type">line</span>!<br>     <span class="hljs-number">4</span>This <span class="hljs-keyword">is</span> fourth <span class="hljs-type">line</span>! <br></code></pre></td></tr></table></figure><p>将两个文件内容合并，再写入到第三个文件中</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ cat test.txt test01.txt &gt;&gt; test02.txt<br>➜  ~ cat test02.txt <br>This <span class="hljs-keyword">is</span> firt <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> second <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> third <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> fourth <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> firt <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> second <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> third <span class="hljs-type">line</span>!<br>This <span class="hljs-keyword">is</span> fourth <span class="hljs-type">line</span>!<br></code></pre></td></tr></table></figure><p>清空文件中的内容</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">➜  ~ <span class="hljs-keyword">cat</span> /dev/null &gt; <span class="hljs-keyword">test</span>.txt <br>➜  ~ <span class="hljs-keyword">cat</span> <span class="hljs-keyword">test</span>.txt <br>➜  ~ <br></code></pre></td></tr></table></figure><p>在类 Unix 系统中，/dev/null 称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个 EOF。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.runoob.com/linux/linux-comm-cat.html">https://www.runoob.com/linux/linux-comm-cat.html</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决/usr/bin/env:python:No such file or directory</title>
    <link href="/2021/08/03/%E8%A7%A3%E5%86%B3-usr-bin-env-python-No-such-file-or-directory/"/>
    <url>/2021/08/03/%E8%A7%A3%E5%86%B3-usr-bin-env-python-No-such-file-or-directory/</url>
    
    <content type="html"><![CDATA[<p>在执行的程序源码开头有这么一句<code>!#/usr/bin/env python</code>，<code>!#</code>这玩意叫<code>shebang</code>也叫<code>hashbang</code>。他用来指定脚本的解释器，也就是说这个程序指定<code>python</code>解释器。</p><p>再看这个错误提示，罪魁祸首就是这句命令，就是说在环境变量找不到<code>python</code>，通俗点说，假如我要能直接用<code>python</code>来跑这个程序，我在命令行直接输入<code>python</code>应该是可以进入<code>python</code>环境的，但是此时肯定不能。我们可以试试</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">dominic<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>python<br>Commond <span class="hljs-keyword">not</span> found xxxxxxxxxxx<br></code></pre></td></tr></table></figure><h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><p>系统里没有<code>python</code>还跑个锤子，先装上再说</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-builtin-name">get</span> install python3<br></code></pre></td></tr></table></figure><p>这时候可能就解决问题了</p><h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h2><p>有的人可能<code>python</code>早就装了，但是仍然有这个问题，但是我们在命令输入<code>python</code>仍然没法用，但是输入<code>python3</code>就可以</p><p>那<code>python3</code>可以，我直接将<code>python</code>改成<code>python3</code>不就完了。没错！</p><p>打开文件将<code>!#/usr/bin/env python</code>改成<code>!#/usr/bin/env python3</code></p><h2 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h2><p>如果了解软链接，那我们就可以不用去改源码了，源码最好还是保持原样。</p><p>既然找不到<code>python</code>这玩意，那我们给他建一个不就完了。</p><p>他要<code>python</code>就是用来解释程序的，我们本地装的<code>python3</code>就是他需要的东西</p><p>先找找我们的<code>python3</code>在哪</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">dominic@hanhan:~$ whereis python3<br>python3: <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python3.8 /u</span>sr<span class="hljs-regexp">/bin/</span>python3.<span class="hljs-number">8</span>-config <span class="hljs-regexp">/usr/</span>bin/python3 <br></code></pre></td></tr></table></figure><p>一般在<code>/usr/bin</code>目录下，然后我们在这个目录下给他创建一个软链接“快捷方式”，具体咋用的啥意思，可以<a href="https://dunky-z.github.io/2021/08/03/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/">参考这篇文章</a>。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln -s <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python3 /u</span>sr<span class="hljs-regexp">/bin/</span>python<br></code></pre></td></tr></table></figure><p>这样程序再找<code>python</code>时就会链接到<code>python3</code>，然后用<code>python3</code>去当解释器。</p><h2 id="解决方案四"><a href="#解决方案四" class="headerlink" title="解决方案四"></a>解决方案四</h2><p>可能在<code>root</code>目录下使用过<code>repo</code>，将其删除</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Bug踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-ln软硬链接</title>
    <link href="/2021/08/03/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <url>/2021/08/03/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ln%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。这有点像Windows环境下的快捷方式。介绍命令前了解一下软链接，硬链接具体是什么。</p><h2 id="硬链接-Hard-Link"><a href="#硬链接-Hard-Link" class="headerlink" title="硬链接 Hard Link"></a>硬链接 Hard Link</h2><p>在 Linux 系统中，每个文件对应一个 <code>inode</code>，文件的内容在存储在 <code>inode</code> 指向的 <code>data block</code> 中。要读取该文件的内容，需要通过文件所在的目录中记录的<strong>文件名</strong>找到文件的 <code>inode</code> 号，然后通过 <code>inode</code> 找到存储文件内容的 <code>data block</code>。当然多个<strong>文件名</strong>可以指向同一个<code>inode</code>。</p><p>使用<code>ll</code>命令显示文件的详细信息，<code>-i</code>参数显示其结点信息，其中最前面的一串数字就是<code>inode</code>信息。我们以<code>/opt/test.txt</code>文件为例，查看其结点信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dominic</span>@hanhan:/opt$ ll -i test.txt <br><span class="hljs-attribute">2498138</span> -rw-r--r-- <span class="hljs-number">1</span> root root <span class="hljs-number">4</span> <span class="hljs-number">8</span>月   <span class="hljs-number">3</span> <span class="hljs-number">12</span>:<span class="hljs-number">16</span> test.txt<br></code></pre></td></tr></table></figure><p>使用 <code>ln</code> 命令在<code>/opt/temp</code>目录下创建一个 <code>test.txt</code> 文件的硬链接，然后观察其文件属性：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dominic</span>@hanhan:/opt/temp$ sudo ln ../test.txt .<br><span class="hljs-attribute">dominic</span>@hanhan:/opt/temp$ ll -i ../test.txt test.txt <br><span class="hljs-attribute">2498138</span> -rw-r--r-- <span class="hljs-number">2</span> root root <span class="hljs-number">4</span> <span class="hljs-number">8</span>月   <span class="hljs-number">3</span> <span class="hljs-number">12</span>:<span class="hljs-number">16</span> ../test.txt<br><span class="hljs-attribute">2498138</span> -rw-r--r-- <span class="hljs-number">2</span> root root <span class="hljs-number">4</span> <span class="hljs-number">8</span>月   <span class="hljs-number">3</span> <span class="hljs-number">12</span>:<span class="hljs-number">16</span> test.txt<br></code></pre></td></tr></table></figure><p>我们再用<code>ll -i</code>命令查看结点信息，发现这两个文件名的结点信息是一样的。说明这两个文件名指向的是同一个文件。其中第三个字段是<strong>链接数</strong>，数字<code>2</code>，表示有两个文件名链接到同一个<code>inode</code>。</p><h4 id="硬链接的特点"><a href="#硬链接的特点" class="headerlink" title="硬链接的特点"></a>硬链接的特点</h4><ul><li>硬链接，以文件副本的形式存在。但不占用实际空间。<br>由于硬链接只是在目录中添加了一条包含文件名和 对应 inode 的记录，所以它几乎不会消耗额外的磁盘容量。</li><li>不允许给目录创建硬链接</li><li>硬链接只有在同一个文件系统中才能创建</li><li>只要还有一个文件名引用着文件，文件就不会被真正删除<br>删除硬链接所关联的文件时，其实只是删除了一条目录中的记录，真正的文件并不受影响。只有在删除最后一个硬链接时才会真正删除文件的内容数据。</li></ul><h2 id="软链接-Symbolic-Link"><a href="#软链接-Symbolic-Link" class="headerlink" title="软链接 Symbolic Link"></a>软链接 Symbolic Link</h2><p>软链接的实现方式与硬链接有本质上的不同。创建软链接时会创建一个新的文件(分配一个<code> inode</code> 和对应的 <code>data block</code>)，新文件的 <code>data block</code> 中存储了目标文件的路径。</p><p>我们以<code>/opt/test.txt</code>为例，在<code>/opt/temp</code>目录中，为其创建一个软链接，然后查看其<code>inode</code>结点信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dominic</span>@hanhan:/opt/temp$ sudo ln -s ../test.txt test<span class="hljs-number">2</span>.txt<br><span class="hljs-attribute">dominic</span>@hanhan:/opt/temp$ ll -i ../test.txt test<span class="hljs-number">2</span>.txt <br><span class="hljs-attribute">2498139</span> lrwxrwxrwx <span class="hljs-number">1</span> root root <span class="hljs-number">11</span> <span class="hljs-number">8</span>月   <span class="hljs-number">3</span> <span class="hljs-number">14</span>:<span class="hljs-number">01</span> test<span class="hljs-number">2</span>.txt -&gt; ../test.txt<br><span class="hljs-attribute">2498138</span> -rw-r--r-- <span class="hljs-number">2</span> root root  <span class="hljs-number">4</span> <span class="hljs-number">8</span>月   <span class="hljs-number">3</span> <span class="hljs-number">12</span>:<span class="hljs-number">16</span> ../test.txt<br></code></pre></td></tr></table></figure><ul><li>第一个字段不同，说明是两个文件了</li><li>第二个字段表示权限，第一个字母表示文件类型，<code>l</code>说明书软链接文件</li><li>第三个字段表示链接数，仍然是<code>2</code>，说明软链接不增加源文件链接数</li><li>第六个字段是文件大小，新建的软链接文件时11字节，这就是<code>/opt/test.txt</code>的长度。</li></ul><h4 id="软链接特点"><a href="#软链接特点" class="headerlink" title="软链接特点"></a>软链接特点</h4><ul><li>软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li><li>软链接可以 跨文件系统 ，硬链接不可以</li><li>软链接可以对一个不存在的文件名进行链接</li><li>软链接可以对目录进行链接</li></ul><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>ln [参数][源文件或目录][目标文件或目录]<br>为文件<code>test.txt</code>创建一个硬链接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln test.txt <span class="hljs-regexp">/etc/</span><br></code></pre></td></tr></table></figure><p>删除<code>test.txt</code>的硬链接，因为是以副本形式存在的，所以直接用<code>rm</code>命令将其删除即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/etc/</span>test.txt <br></code></pre></td></tr></table></figure><p>为文件<code>test.txt</code>创建一个软链接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln -s test.txt <span class="hljs-regexp">/etc/</span>test2.txt<br></code></pre></td></tr></table></figure><p>删除软链接也一样，直接用<code>rm</code>命令删除软链接的名称即可。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.runoob.com/linux/linux-comm-ln.html">https://www.runoob.com/linux/linux-comm-ln.html</a></li><li><a href="https://www.cnblogs.com/lixuze/p/14248559.html">https://www.cnblogs.com/lixuze/p/14248559.html</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-ed行编辑器</title>
    <link href="/2021/08/02/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ed%E8%A1%8C%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <url>/2021/08/02/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-ed%E8%A1%8C%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><code>ed</code>命令是文本编辑器，用于文本编辑。</p><p><code>ed</code>是Linux中功能最简单的文本编辑程序，一次仅能编辑一行而非全屏幕方式的操作。很多命令和<code>vim</code>相似，平时开发中并不常用，但是在编辑大文本时还是会用到。</p><p>学学无妨毕竟这是Unix系统三大要件（编辑器，汇编器和shell）之一。</p><p><code>ed</code>编辑器有两种模式：命令模式和输入模式。命令模式下输入<code>a</code>,<code>i</code>,<code>c</code>,<code>d</code>可以进入对应的编辑模式，接下来可以输入任何想要输入的内容，输入完毕或者要切换命令时，可以输入<code>.</code>退出输入模式。</p><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span>           <span class="hljs-comment">#添加到行</span><br>i           <span class="hljs-comment">#添加到行首</span><br>c           <span class="hljs-comment">#改变行</span><br>d           <span class="hljs-comment">#删除行</span><br></code></pre></td></tr></table></figure><h2 id="Line-Address"><a href="#Line-Address" class="headerlink" title="Line Address"></a>Line Address</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-comment">#buffer 中 当前行</span><br>$<span class="hljs-comment">#最后一行</span><br>n<span class="hljs-comment">#第 n 行，行的范围是 [0,$]</span><br>- or ^<span class="hljs-comment">#前一行</span><br>-n or ^n<span class="hljs-comment">#前 n 行</span><br>+ or +n<span class="hljs-comment">#后一行及后n行</span><br>, or %<span class="hljs-comment">#全部行，等同于 1,$</span><br>;<span class="hljs-comment">#当前行到最后一行 .,$</span><br><span class="hljs-regexp">/re/</span><span class="hljs-comment">#下一个包含正则 re 的行</span><br>?re?<span class="hljs-comment">#上一个包含正则 re 的行</span><br></code></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs applescript">dominic@hanhan:~$ ed                <span class="hljs-comment"># 进入编辑模式</span><br>This <span class="hljs-keyword">is</span> a test <span class="hljs-built_in">text</span>!                <span class="hljs-comment"># 输入文本</span><br>.               <span class="hljs-comment"># 结束输入命令</span><br>This <span class="hljs-keyword">is</span> a test <span class="hljs-built_in">text</span>!                <span class="hljs-comment"># 回显当前行</span><br>n               <span class="hljs-comment"># 显示行号命令</span><br><span class="hljs-number">1</span>This <span class="hljs-keyword">is</span> a test <span class="hljs-built_in">text</span>!        <span class="hljs-comment"># 回显当前行并显示行号</span><br>c               <span class="hljs-comment"># 改变行命令</span><br>This <span class="hljs-keyword">is</span> changed <span class="hljs-built_in">text</span>!               <span class="hljs-comment"># 输入更改后的内容</span><br>.               <span class="hljs-comment"># 结束输入命令</span><br>n               <span class="hljs-comment"># 显示行号命令</span><br><span class="hljs-number">1</span>This <span class="hljs-keyword">is</span> changed <span class="hljs-built_in">text</span>!       <span class="hljs-comment"># 回显当前行并显示行号</span><br>i               <span class="hljs-comment"># 在首行插入命令</span><br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">first</span> line!                 <span class="hljs-comment"># 输入插入内容</span><br>.               <span class="hljs-comment"># 结束输入命令</span><br>+               <span class="hljs-comment"># 后一行命令</span><br>This <span class="hljs-keyword">is</span> changed <span class="hljs-built_in">text</span>!               <span class="hljs-comment"># 回显后一行</span><br>d               <span class="hljs-comment"># 删除当前行 </span><br>.               <span class="hljs-comment"># 回显当前行命令</span><br>This <span class="hljs-keyword">is</span> firt line!                  <span class="hljs-comment"># 回显当前行</span><br>a<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">second</span> line!<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">third</span> line!<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">fourth</span> line!<br>w test.txt      <span class="hljs-comment"># 写入并保存文件</span><br>q               <span class="hljs-comment"># 退出编辑器</span><br><br>dominic@hanhan:~$ cat test.txt      <span class="hljs-comment"># 查看内容</span><br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">first</span> line!s<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">second</span> line!<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">third</span> line!<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">fourth</span> line!<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-wc统计文件有多少字多少行</title>
    <link href="/2021/07/30/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-wc%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AD%97%E5%A4%9A%E5%B0%91%E8%A1%8C/"/>
    <url>/2021/07/30/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-wc%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AD%97%E5%A4%9A%E5%B0%91%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>想知道自己代码写了多少行，可以一个<code>wc</code>命令搞定。</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-l ：仅列出行；</span><br><span class="hljs-deletion">-w ：仅列出多少字(英文单字)；</span><br><span class="hljs-deletion">-m ：多少字符</span><br></code></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>统计<code>hello.c</code>文件夹下文件总共多少行</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">dominic<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:~/learning-linux/helloworld/c</span><span class="hljs-variable">$ </span>wc -l  hello.c<br><span class="hljs-number">14</span> hello.c<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更换Ubuntu软件更新源</title>
    <link href="/2021/07/30/Linux%E6%9B%B4%E6%8D%A2Ubuntu%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/"/>
    <url>/2021/07/30/Linux%E6%9B%B4%E6%8D%A2Ubuntu%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu默认是国外的源，软件下载和更新都比较慢。两种方法将下载源换成国内的源。</p><h2 id="用”软件和更新”工具"><a href="#用”软件和更新”工具" class="headerlink" title="用”软件和更新”工具"></a>用”软件和更新”工具</h2><p>从Ubuntu菜单中找到<strong>软件和更新</strong>这个应用并打开。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210730112638.png"></p><p>找到<strong>下载自</strong>，选择<strong>其他-国内-aliyun</strong>，然后勾选前四个选项。关闭时会弹出对话框，点击<strong>更新</strong>。然后就能愉<strong>快</strong>的下载软件了。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210730113029.png"></p><h2 id="修改sourcelist"><a href="#修改sourcelist" class="headerlink" title="修改sourcelist"></a>修改<code>sourcelist</code></h2><h3 id="备份原文件"><a href="#备份原文件" class="headerlink" title="备份原文件"></a>备份原文件</h3><p>这也算是系统文件的一部分，还是保险一点，出错了再改回来。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list /</span>etc<span class="hljs-regexp">/apt/</span>sources.list.backup<br></code></pre></td></tr></table></figure><h3 id="打开并修改"><a href="#打开并修改" class="headerlink" title="打开并修改"></a>打开并修改</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>apt/sources.list<br></code></pre></td></tr></table></figure><p><code>vim</code>用的不习惯的估计会和我一样找全选内容怎么操作。教给你了<br>在命令模式下，就是按一下<code>esc</code>键，然后输入<code>ggvG</code>。具体什么含义看<code>vim笔记</code>吧，选择后直接<code>delete</code>删除，再把阿里云源粘贴进去。保存退出。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#阿里云</span><br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> trusty main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> trusty-security main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> trusty-updates main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> trusty-proposed main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> trusty-backports main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> trusty main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> trusty-security main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> trusty-updates main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> trusty-proposed main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> trusty-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> update<br>sudo apt-<span class="hljs-builtin-name">get</span> dist-upgrade<br>sudo apt-<span class="hljs-builtin-name">get</span> upgrade<br></code></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-find查找文件</title>
    <link href="/2021/07/29/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-find%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/"/>
    <url>/2021/07/29/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-find%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">find <span class="hljs-selector-attr">[path]</span> <span class="hljs-selector-attr">[expression]</span><br></code></pre></td></tr></table></figure><p>在<code>path</code>下查找<code>expression</code>表示的文件</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>一般常见就是自己不知道写的某个文件或者文件夹放哪里了，又或者只记住部分文件名。以下几个命令就能帮到你。</p><h3 id="按文件名查找"><a href="#按文件名查找" class="headerlink" title="按文件名查找"></a>按文件名查找</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">find</span>  -name filename(查找结果显示路径)或者 <span class="hljs-builtin-name">find</span> filename(查找结果不显示路径)<br><br><span class="hljs-builtin-name">find</span> hello.cpp          #当前目录下精确查找hello.cpp文件<br><span class="hljs-builtin-name">find</span> hello              #当前目录下精确查找hello文件<br><span class="hljs-builtin-name">find</span> hello*             #当前目录下模糊查找以hello为前缀的文件<br></code></pre></td></tr></table></figure><h3 id="按类型查找"><a href="#按类型查找" class="headerlink" title="按类型查找"></a>按类型查找</h3><p>这就是为查找文件夹用的。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> -<span class="hljs-built_in">type</span> [fdlcb] <span class="hljs-built_in">name</span><br></code></pre></td></tr></table></figure><p><code>[fdlcb]</code>都是类型，<code>d</code>就是目录，文件夹类型。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">find / -<span class="hljs-keyword">type</span> <span class="hljs-type">d </span>-name <span class="hljs-string">&quot;helloworld&quot;</span>   #查找名为helloworld的文件夹<br></code></pre></td></tr></table></figure><h2 id="按文件名查找-1"><a href="#按文件名查找-1" class="headerlink" title="按文件名查找"></a>按文件名查找</h2><p>以下就详细介绍一些参数</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golo"><span class="hljs-keyword">find</span> -name <span class="hljs-string">&quot;hello.cpp&quot;</span>              <span class="hljs-comment"># 搜索文件名，大小写敏感</span><br><span class="hljs-keyword">find</span> -iname <span class="hljs-string">&quot;hello.cpp&quot;</span>             <span class="hljs-comment">#大小写不敏感</span><br></code></pre></td></tr></table></figure><h2 id="按文件大小查找"><a href="#按文件大小查找" class="headerlink" title="按文件大小查找"></a>按文件大小查找</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">find [path] -size <span class="hljs-number">50</span>M<br><br>find / -size <span class="hljs-number">10</span>M                # 查找系统中大小等于<span class="hljs-number">10</span>M的文件<br>find / -size +<span class="hljs-number">50</span>M               # 查找系统中大小大于<span class="hljs-number">50</span>M的文件<br>find  / -size <span class="hljs-number">-30</span>M              # 查找系统中大小小于<span class="hljs-number">30</span>M的文件<br></code></pre></td></tr></table></figure><h2 id="按时间来查找文件"><a href="#按时间来查找文件" class="headerlink" title="按时间来查找文件"></a>按时间来查找文件</h2><p>Linux 会存储下面的时间：</p><ul><li>Access time 上一次文件读或者写的时间</li><li>Modifica time 上一次文件被修改的时间</li><li>Change time 上一次文件 <code>inode meta</code> 信息被修改的时间</li></ul><p>在按照时间查找时，可以使用 <code>-atime</code>， <code>-mtime</code> 或者 <code>-ctime </code>，和之前 <code>size </code>参数一样可以使用 <code>+</code> 或者 <code>- </code>时间范围，下图表示<code>find</code>的时间轴。<code>+</code>表示超过多少天，<code>-</code>表示多少天以内。</p><p>此外，也可以换成<code>-amin</code>， <code>-mmin</code> 或者 <code>-cmin </code>参数，单位是分钟。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210729151915.png"></p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golo"><span class="hljs-keyword">find</span> / -mtime <span class="hljs-number">1</span>          <span class="hljs-comment"># 寻找修改时间超过一天的文件</span><br><span class="hljs-keyword">find</span> / -atime <span class="hljs-number">-1</span>         <span class="hljs-comment"># 寻找在一天时间内被访问的文件</span><br><span class="hljs-keyword">find</span> / -ctime +<span class="hljs-number">3</span>         <span class="hljs-comment"># 寻找 meta 信息被修改的时间超过 3 天的文件</span><br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><p><a href="http://c.biancheng.net/view/779.html">http://c.biancheng.net/view/779.html</a></p></li><li><p><a href="https://einverne.github.io/post/2018/02/find-command.html#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E6%97%B6%E9%97%B4%E8%B6%85%E8%BF%87-1-%E5%A4%A9%E7%9A%84%E6%96%87%E4%BB%B6">https://einverne.github.io/post/2018/02/find-command.html#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E6%97%B6%E9%97%B4%E8%B6%85%E8%BF%87-1-%E5%A4%A9%E7%9A%84%E6%96%87%E4%BB%B6</a></p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git clone快速下载子模块</title>
    <link href="/2021/07/28/git-clone%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    <url>/2021/07/28/git-clone%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD%E5%AD%90%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>在<code>git clone</code>时候，如果遇到项目里有子模块通常会在下载时加上<code>--recursive</code>参数，一起下载。但是子模块较多，体积较大时大概率都会下载失败。</p><p>好在可以通过一些小技巧，下载国内镜像，进行加速。但是下载项目时，只是主体是国内的镜像，子模块仍然下载很慢。首先解决获取国内镜像的问题。有三个方法：</p><ul><li><p><strong>在码云Gitee上搜索下载</strong></p><p>  在码云上搜索同样的项目，然后用码云git 的地址下载。</p></li><li><p><strong>加上<code>.cnpmjs.org</code>后缀</strong></p><p>  在地址后面加上后缀，如<code>git clone https://github.com.cnpmjs.org/riscv/riscv-binutils-gdb.git</code>。</p></li><li><p><strong>使用油猴脚本获取镜像地址</strong></p><p>  如果你有油猴插件可以去<a href="https://greasyfork.org/zh-CN">greasyfork</a>搜索安装<strong>GitHub镜像访问，加速下载</strong>这个脚本，刷新GitHub仓库界面就会多出几个镜像地址，一般下载都会快好几倍。</p><p>  <img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728155417.png"></p></li></ul><p>再来解决子模块下载速度慢的问题，下载项目时，先不加<code>--recursive</code>参数，只下载项目的本题。</p><p>下载完后找到<code>.gitmodules</code>文件，这是一个隐藏文件，需要显示隐藏文件，Linux下使用快捷键<code>Ctrl+H</code>。用<code>vim</code>打开后可以得到：</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728164406.png"></p><p>这个文件里写入了子模块的下载信息，<code>url</code>就是下载地址。我们把所有子模块中的url地址同样加上<code>.cnpmjs.org</code>后缀。或者使用上述三种方式得到的镜像地址。</p><p>然后利用<code>git submodule sync</code>更新子项目对应的<code>url</code></p><p>最后再<code>git submodule update --init --recursive</code>，即可快速下载所有子项目。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在QEMU上运行64位和32位RISC-V-Linux</title>
    <link href="/2021/07/28/QEMU%E4%B8%8A%E8%BF%90%E8%A1%8C64%E4%BD%8D%E5%92%8C32%E4%BD%8DRISC-V-Linux/"/>
    <url>/2021/07/28/QEMU%E4%B8%8A%E8%BF%90%E8%A1%8C64%E4%BD%8D%E5%92%8C32%E4%BD%8DRISC-V-Linux/</url>
    
    <content type="html"><![CDATA[<h2 id="制作交叉工具链-riscv-gnu-toolchain"><a href="#制作交叉工具链-riscv-gnu-toolchain" class="headerlink" title="制作交叉工具链 riscv-gnu-toolchain"></a>制作交叉工具链 riscv-gnu-toolchain</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>这个仓库是我遇到的最难下载的一个仓库了，公司网慢和虚拟机性能差都脱不了干系。估计下载了五小时都不止，刚开始还指望一个命令所有子模块都下载完的，结果愣是等了半天中断了。试了两次后放弃了。如果各位看官能一次完成，那您是福大。</p><p>国内的码云平台有个<a href="https://gitee.com/organizations/mirrors/projects">Gitee极速下载</a>项目，上面有GitHub的一些常用开源项目的镜像，可供加速下载。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># riscv-gnu-toolchain</span><br>https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-gnu-toolchain.git<br></code></pre></td></tr></table></figure><p>下载时问题出现了，如果下载子模块仍然会卡住，如果不加<code>--recursive</code>就只能下载主体内容，子模块都没有。（<strong>以下内容为第一安装时的方法，后续又找到了<a href="">git clone快速下载子模块</a>的方法</strong>）</p><p>开始下载时不加<code>--recursive</code>参数，只下载<code>riscv-gnu-toolchain</code>的主体内容，然后进入到<code>riscv-gnu-toolchain</code>文件夹下，手动下载子模块的内容。</p><p>当下完<code>riscv-binutils</code>继续下载<code>riscv-gdb</code>时发现这两个项目是同一个项目，只是不同的分支。但是码云上并没有区分，但是我也没找到在码云上的对应分支。只能用油猴脚本了。</p><p>如果你有油猴插件可以去<a href="https://greasyfork.org/zh-CN">greasyfork</a>搜索安装<strong>GitHub镜像访问，加速下载</strong>这个脚本，刷新GitHub仓库界面就会多出几个镜像地址，一般下载都会快好几倍。如果不用油猴插件的可以用我复制好的链接。</p><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728155417.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># riscv-binutils</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-binutils-gdb.git<br><span class="hljs-comment"># riscv-gcc</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-gcc.git<br><span class="hljs-comment"># riscv-dejagnu</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-dejagnu.git<br><span class="hljs-comment"># riscv-glibc</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-glibc.git<br><span class="hljs-comment"># riscv-newlib</span><br>git clone https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/mirrors/</span>riscv-newlib.git<br><span class="hljs-comment"># riscv-gdb</span><br>git clone --depth=<span class="hljs-number">1</span> https:<span class="hljs-regexp">//</span>hub.fastgit.org<span class="hljs-regexp">/riscv/</span>riscv-binutils-gdb.git<br></code></pre></td></tr></table></figure><h3 id="编译riscv-gnu-toolchain"><a href="#编译riscv-gnu-toolchain" class="headerlink" title="编译riscv-gnu-toolchain"></a>编译riscv-gnu-toolchain</h3><p>提前安装如下软件：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">$ sudo apt-<span class="hljs-built_in">get</span> install autoconf automake autotools-<span class="hljs-built_in">dev</span> curl python3 libmpc-<span class="hljs-built_in">dev</span> libmpfr-<span class="hljs-built_in">dev</span> libgmp-<span class="hljs-built_in">dev</span> gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-<span class="hljs-built_in">dev</span> libexpat-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>不听老人言，吃亏在眼前呀，本以为这是可选项，很多库都安装了，就没有操作这一步，结果就是编译半天结果还错了。如果报<code>make 错误 127</code>，那就老老实实把前置的这些库都装上。</p><p>建立<code>riscv-gnu-toolchain</code>安装目录<code>/opt/riscv64 </code>。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>./configure --prefix=<span class="hljs-regexp">/opt/riscv</span>64 <br><span class="hljs-variable">$ </span>sudo make linux -j8<br></code></pre></td></tr></table></figure><h3 id="导出安装路径"><a href="#导出安装路径" class="headerlink" title="导出安装路径"></a>导出安装路径</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:/opt/riscv64/bin&quot;</span><br></code></pre></td></tr></table></figure><p>出现一下信息表示安装成功。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">Using built-in specs.<br>COLLECT_GCC=riscv64-unknown-linux-gnu-gcc<br>COLLECT_LTO_WRAPPER=<span class="hljs-string">/opt/riscv64/libexec/gcc/riscv64-unknown-linux-gnu/10.2.0/lto-wrapper</span><br>Target: riscv64-unknown-linux-gnu<br>Configured with: <span class="hljs-string">/home/dominic/riscv64-linux/riscv-gnu-toolchain/riscv-gcc/configure</span> <span class="hljs-params">--target=riscv64-unknown-linux-gnu</span> <span class="hljs-params">--prefix=/opt/riscv64</span> <span class="hljs-params">--with-sysroot=/opt/riscv64/sysroot</span> <span class="hljs-params">--with-system-zlib</span> <span class="hljs-params">--enable-shared</span> <span class="hljs-params">--enable-tls</span> <span class="hljs-params">--enable-languages=c</span>,c++,fortran <span class="hljs-params">--disable-libmudflap</span> <span class="hljs-params">--disable-libssp</span> <span class="hljs-params">--disable-libquadmath</span> <span class="hljs-params">--disable-libsanitizer</span> <span class="hljs-params">--disable-nls</span> <span class="hljs-params">--disable-bootstrap</span> <span class="hljs-params">--src=</span><span class="hljs-string">.././riscv-gcc</span> <span class="hljs-params">--disable-multilib</span> <span class="hljs-params">--with-abi=lp64d</span> <span class="hljs-params">--with-arch=rv64imafdc</span> <span class="hljs-params">--with-tune=rocket</span> &#x27;CFLAGS_FOR_TARGET=-O2   -mcmodel=medlow&#x27; &#x27;CXXFLAGS_FOR_TARGET=-O2   -mcmodel=medlow&#x27;<br>Thread model: posix<br>Supported LTO compression algorithms: zlib<br>gcc <span class="hljs-keyword">version</span> 10.2.0 <span class="hljs-params">(GCC)</span> <br></code></pre></td></tr></table></figure><h2 id="制作内核"><a href="#制作内核" class="headerlink" title="制作内核"></a>制作内核</h2><h3 id="下载Linux内核"><a href="#下载Linux内核" class="headerlink" title="下载Linux内核"></a>下载Linux内核</h3><p>makefile</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天学命令-df/du查看磁盘剩余空间</title>
    <link href="/2021/07/28/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-df-du%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4/"/>
    <url>/2021/07/28/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E5%91%BD%E4%BB%A4-df-du%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p><code>df</code>全称<code>disk filesystem</code> ，以磁盘分区为单位查看文件系统，可以查看磁盘文件占用空间，磁盘剩余空间等信息。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">df <span class="hljs-selector-attr">[]</span> <span class="hljs-selector-attr">[]</span><br></code></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a      全部文件系统列表</span><br><span class="hljs-deletion">-h      方便阅读方式显示</span><br><span class="hljs-deletion">-H      等于“-h”，但是计算式，1K=1000，而不是 1K=1024</span><br><span class="hljs-deletion">-i      显示 inode 信息</span><br><span class="hljs-deletion">-k      区块为 1024 字节</span><br><span class="hljs-deletion">-l      只显示本地文件系统</span><br><span class="hljs-deletion">-m      区块为 1048576 字节</span><br><span class="hljs-deletion">--no-sync 忽略 sync 命令</span><br><span class="hljs-deletion">-P      输出格式为 POSIX</span><br><span class="hljs-deletion">--sync  在取得磁盘信息前，先执行 sync 命令</span><br><span class="hljs-deletion">-T      文件系统类型</span><br></code></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><code>df -T</code>显示包含文件系统，类型，可用大小，已用大小，挂载点等信息。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">dominic@hanhan:~$ df -T<br>文件系统       类型         1K-块      已用      可用 已用% 挂载点<br>udev           devtmpfs  <span class="hljs-number"> 1985056 </span>       <span class="hljs-number"> 0 </span> <span class="hljs-number"> 1985056 </span>   0% /dev<br>tmpfs          tmpfs      <span class="hljs-number"> 403036 </span>    <span class="hljs-number"> 1304 </span>  <span class="hljs-number"> 401732 </span>   1% /run<br>/dev/sda5      ext4     <span class="hljs-number"> 50824704 </span><span class="hljs-number"> 20826256 </span><span class="hljs-number"> 27386992 </span>  44% /<br>tmpfs          tmpfs     <span class="hljs-number"> 2015172 </span>       <span class="hljs-number"> 0 </span> <span class="hljs-number"> 2015172 </span>   0% /dev/shm<br>tmpfs          tmpfs        <span class="hljs-number"> 5120 </span>       <span class="hljs-number"> 4 </span>    <span class="hljs-number"> 5116 </span>   1% /run/lock<br>tmpfs          tmpfs     <span class="hljs-number"> 2015172 </span>       <span class="hljs-number"> 0 </span> <span class="hljs-number"> 2015172 </span>   0% /sys/fs/cgroup<br>/dev/loop0     squashfs    <span class="hljs-number"> 56832 </span>   <span class="hljs-number"> 56832 </span>       <span class="hljs-number"> 0 </span> 100% /snap/core18/1988<br>/dev/loop1     squashfs    <span class="hljs-number"> 56832 </span>   <span class="hljs-number"> 56832 </span>       <span class="hljs-number"> 0 </span> 100% /snap/core18/2074<br></code></pre></td></tr></table></figure><hr><p><code>du</code>全称<code>disk usage</code>可以查看文件，文件夹占用情况。</p><h2 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">du <span class="hljs-selector-attr">[opt]</span> <span class="hljs-selector-attr">[filename]</span><br></code></pre></td></tr></table></figure><h2 id="可选参数-1"><a href="#可选参数-1" class="headerlink" title="可选参数"></a>可选参数</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">a或-all                    <span class="hljs-comment">#显示目录中个别文件的大小。</span></span><br><span class="ruby"></span>-<span class="ruby">b或-bytes                  <span class="hljs-comment">#显示目录或文件大小时，以byte为单位。</span></span><br><span class="ruby"></span>-<span class="ruby">c或--total                 <span class="hljs-comment">#除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</span></span><br><span class="ruby"></span>-<span class="ruby">D或--dereference-args      <span class="hljs-comment">#显示指定符号连接的源文件大小。</span></span><br><span class="ruby"></span>-<span class="ruby">h或--human-readable        <span class="hljs-comment">#以K，M，G为单位，提高信息的可读性。</span></span><br><span class="ruby"></span>-<span class="ruby">H或--si                    <span class="hljs-comment">#与-h参数相同，但是K，M，G是以1000为换算单位。</span></span><br><span class="ruby"></span>-<span class="ruby">k或--kilobytes             <span class="hljs-comment">#以1024 bytes为单位。</span></span><br><span class="ruby"></span>-<span class="ruby">l或--count-links           <span class="hljs-comment">#重复计算硬件连接的文件。</span></span><br><span class="ruby"></span>-<span class="ruby">L&lt;符号连接&gt;或-</span><br><span class="ruby"></span>-<span class="ruby">dereference&lt;符号连接&gt;          <span class="hljs-comment">#显示选项中所指定符号连接的源文件大小。</span></span><br><span class="ruby"></span>-<span class="ruby">m或--megabytes                 <span class="hljs-comment">#以1MB为单位。</span></span><br><span class="ruby"></span>-<span class="ruby">s或--summarize                 <span class="hljs-comment">#仅显示总计。</span></span><br><span class="ruby"></span>-<span class="ruby">S或--separate-dirs             <span class="hljs-comment">#显示个别目录的大小时，并不含其子目录的大小。</span></span><br><span class="ruby"></span>-<span class="ruby">x或--one-file-xystem           <span class="hljs-comment">#以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</span></span><br><span class="ruby"></span>-<span class="ruby">X&lt;文件&gt;或--exclude-from=&lt;文件&gt;  <span class="hljs-comment">#在&lt;文件&gt;指定目录或文件。</span></span><br><span class="ruby"></span>-<span class="ruby">-exclude=&lt;目录或文件&gt;           <span class="hljs-comment">#略过指定的目录或文件。</span></span><br><span class="ruby"></span>-<span class="ruby">-max-depth=&lt;目录层数&gt;           <span class="hljs-comment">#超过指定层数的目录后，予以忽略。</span></span><br><span class="ruby"></span>-<span class="ruby">-help          <span class="hljs-comment">#显示帮助。</span></span><br><span class="ruby"></span>-<span class="ruby">-version       <span class="hljs-comment">#显示版本信息</span></span><br></code></pre></td></tr></table></figure><h2 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h2><p>查看当前目录使用情况</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">dominic@hanhan:~/learning-linux$ du<br><span class="hljs-number">56</span>.<span class="hljs-regexp">/.git/</span>hooks<br><span class="hljs-number">8</span>.<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>heads<br><span class="hljs-number">8</span>.<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes/origin<br><span class="hljs-number">12</span>.<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes<br><span class="hljs-number">24</span>.<span class="hljs-regexp">/.git/</span>logs/refs<br><span class="hljs-number">32</span>.<span class="hljs-regexp">/.git/</span>logs<br><span class="hljs-number">8</span>.<span class="hljs-regexp">/.git/i</span>nfo<br></code></pre></td></tr></table></figure><p>以易读的方式查看使用情况</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">dominic@hanhan:~/learning-linux$ du -h<br><span class="hljs-number">56</span>K.<span class="hljs-regexp">/.git/</span>hooks<br><span class="hljs-number">8.0</span>K.<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>heads<br><span class="hljs-number">8.0</span>K.<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes/origin<br><span class="hljs-number">12</span>K.<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes<br><span class="hljs-number">24</span>K.<span class="hljs-regexp">/.git/</span>logs/refs<br><span class="hljs-number">32</span>K.<span class="hljs-regexp">/.git/</span>logs<br><span class="hljs-number">8.0</span>K.<span class="hljs-regexp">/.git/i</span>nfo<br></code></pre></td></tr></table></figure><p>只输出当前目录占用总空间，同上<code>-h</code>命令就是以人读的方式（加上了数据单位）</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">dominic<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:~/learning-linux</span><span class="hljs-variable">$ </span>du -hs<br><span class="hljs-number">264</span>K.<br></code></pre></td></tr></table></figure><p>查看当前目录及其指定深度目录的大小</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">不深入子目录，就是当前文件夹所占用大小<br>dominic<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:~/learning-linux</span><span class="hljs-variable">$ </span>du -h --max-depth=0<br><span class="hljs-number">264</span>K.<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">深入一层<br>dominic@hanhan:~/learning-linux$ du -h --max-depth=<span class="hljs-number">2</span><br><span class="hljs-number">56</span>K.<span class="hljs-regexp">/.git/</span>hooks<br><span class="hljs-number">32</span>K.<span class="hljs-regexp">/.git/</span>logs<br><span class="hljs-number">8.0</span>K.<span class="hljs-regexp">/.git/i</span>nfo<br><span class="hljs-number">28</span>K.<span class="hljs-regexp">/.git/</span>objects<br><span class="hljs-number">4.0</span>K.<span class="hljs-regexp">/.git/</span>branches<br><span class="hljs-number">28</span>K.<span class="hljs-regexp">/.git/</span>refs<br><span class="hljs-number">180</span>K./.git<br><span class="hljs-number">24</span>K.<span class="hljs-regexp">/helloworld/</span>c<br><span class="hljs-number">44</span>K.<span class="hljs-regexp">/helloworld/</span>shell<br><span class="hljs-number">72</span>K./helloworld<br><span class="hljs-number">264</span>K.<br></code></pre></td></tr></table></figure><p>忽略<code>helloworld</code>这个文件夹</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gradle">dominic@hanhan:~/learning-linux$ du --<span class="hljs-keyword">exclude</span>=helloworld<br><span class="hljs-number">56</span>.<span class="hljs-regexp">/.git/</span>hooks<br><span class="hljs-number">8</span>.<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>heads<br><span class="hljs-number">8</span>.<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes/origin<br><span class="hljs-number">12</span>.<span class="hljs-regexp">/.git/</span>logs<span class="hljs-regexp">/refs/</span>remotes<br><span class="hljs-number">24</span>.<span class="hljs-regexp">/.git/</span>logs/refs<br><span class="hljs-number">32</span>.<span class="hljs-regexp">/.git/</span>logs<br><span class="hljs-number">8</span>.<span class="hljs-regexp">/.git/i</span>nfo<br><span class="hljs-number">4</span>.<span class="hljs-regexp">/.git/</span>objects/info<br><span class="hljs-number">20</span>.<span class="hljs-regexp">/.git/</span>objects/pack<br><span class="hljs-number">28</span>.<span class="hljs-regexp">/.git/</span>objects<br><span class="hljs-number">4</span>.<span class="hljs-regexp">/.git/</span>branches<br><span class="hljs-number">8</span>.<span class="hljs-regexp">/.git/</span>refs/heads<br><span class="hljs-number">4</span>.<span class="hljs-regexp">/.git/</span>refs/tags<br><span class="hljs-number">8</span>.<span class="hljs-regexp">/.git/</span>refs<span class="hljs-regexp">/remotes/</span>origin<br><span class="hljs-number">12</span>.<span class="hljs-regexp">/.git/</span>refs/remotes<br><span class="hljs-number">28</span>.<span class="hljs-regexp">/.git/</span>refs<br><span class="hljs-number">180</span>./.git<br><span class="hljs-number">192</span>.<br></code></pre></td></tr></table></figure><h2 id="Refernece"><a href="#Refernece" class="headerlink" title="Refernece"></a>Refernece</h2><ol><li><a href="https://einverne.github.io/post/2018/03/du-find-out-which-fold-take-space.html">https://einverne.github.io/post/2018/03/du-find-out-which-fold-take-space.html</a></li><li><a href="https://www.runoob.com/linux/linux-comm-du.html">https://www.runoob.com/linux/linux-comm-du.html</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>每天学命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(Ubuntu)环境下安装Qt</title>
    <link href="/2021/07/27/Linux-Ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Qt/"/>
    <url>/2021/07/27/Linux-Ubuntu-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Qt/</url>
    
    <content type="html"><![CDATA[<p>真蠢，之前费那么大劲，只要一句命令就完事了</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> qtcreator<br></code></pre></td></tr></table></figure><p>但是在用命令行构建project时可能会报错</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">qmake -<span class="hljs-keyword">project</span><br>could not <span class="hljs-keyword">find</span> a Qt installation of <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>这时候需要</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">sudo apt-<span class="hljs-keyword">get</span> install qt5-<span class="hljs-keyword">default</span> <br></code></pre></td></tr></table></figure><p>好了可以愉快玩耍了。</p><hr><p>瞎折腾</p><h2 id="下载Qt"><a href="#下载Qt" class="headerlink" title="下载Qt"></a>下载Qt</h2><p>从Qt5.15.0起，对于开源用户，Qt官方不再提供独立安装文件，且不再有bug修复版本（比如Qt5.15.1），如果从官网下载，需要自己编译。虽然想试试编译，但是虚拟机刚开始开的空间太小了，还是另寻他法吧。以后有机会再来编译试试新功能。若读者有兴趣可以从<a href="https://download.qt.io/archive/qt/">官网</a>下载源码并编译。或者参考<a href="https://wiki.qt.io/Building_Qt_5_from_Git#Getting_the_source_code">官方的编译教程</a>，从github上下载。</p><p>国内有一些镜像站，提供qt镜像下载：<br>清华大学：<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/">https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/</a><br>中国科学技术大学：<a href="http://mirrors.ustc.edu.cn/qtproject/">http://mirrors.ustc.edu.cn/qtproject/</a><br>北京理工大学：<a href="https://mirrors.cnnic.cn/qt/">https://mirrors.cnnic.cn/qt/</a></p><p>以清华大学的镜像为例，找到<code>archive/qt/5.14/5.14.0/qt-opensource-linux-x64-5.14.0.run</code>，点击即可开始下载。</p><blockquote><p>qt 5.15已经不提供安装包，想要最新版本，只能下5.14,但是5.14.2下载没资源，下不动，如果遇到下不动的情况换一个版本吧</p></blockquote><h2 id="安装Qt"><a href="#安装Qt" class="headerlink" title="安装Qt"></a>安装Qt</h2><p>下载的<code>.run</code>文件双击是无法安装的，因为它还没有可执行的权限，需要我们赋给它执行权限，打开终端进入安装包的目录。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">chmod +<span class="hljs-meta">x</span> <span class="hljs-meta">filename</span>.run<br></code></pre></td></tr></table></figure><p><code>chmod</code>命令是控制用户对文件的权限修改的命令，<code>x</code>是可执行权限的参数。<br>执行以上命令后就可以直接双击安装了。</p><p>网上一些教程可以跳过登录，我没找到跳过按钮，需要注册一个账号才能继续安装。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728092743.png"></p><p>安装目录一般选择在<code>/opt</code>目录下<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728092813.png"></p><p>安装的附加组件最好都选择，以免后期使用再安装麻烦。Qt Creator肯定要装的。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728093014.png"></p><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-builtin-name">get</span> install g++<br>apt-<span class="hljs-builtin-name">get</span> install libgl1-mesa-dev<br>apt-<span class="hljs-builtin-name">get</span> install libqt4-dev<br>apt-<span class="hljs-builtin-name">get</span> install build-essential # Build Essential，它是一个元软件包，可让您在Ubuntu中安装和使用c ++工具。<br>sudo apt install qt5-default # 如果要将Qt 5用作默认的Qt Creator版本需要安装，否则会报 qmake: could <span class="hljs-keyword">not</span> <span class="hljs-builtin-name">find</span> a Qt installation of <span class="hljs-string">&#x27;&#x27;</span>的错误<br></code></pre></td></tr></table></figure><h2 id="使用Qt-Creator创建第一个程序"><a href="#使用Qt-Creator创建第一个程序" class="headerlink" title="使用Qt Creator创建第一个程序"></a>使用Qt Creator创建第一个程序</h2><h3 id="使用Qt-Creator创建"><a href="#使用Qt-Creator创建" class="headerlink" title="使用Qt Creator创建"></a>使用Qt Creator创建</h3><p>首先我们先创建一个不带窗口的HelloWorld程序，测试安装是否成功，打开Qt Creator-文件-新建文件或项目，选择Non-Qt Project-Plain C++ Application。<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728102920.png"><br>接下来就设置项目名等，一直下一步。完成后就可以在编辑器看到如下<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728103424.png"></p><p>点击左下角运行按钮就可以得到如下：<br><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728103540.png"></p><p>再创建一个带窗口的HelloWorld，在选择模板时选择Application-Qt Widgets Application。一路点下一步就可以完成创建，运行后就可得到一个灰白的HelloWorld窗口。</p><h3 id="命令行编译第一个Qt程序"><a href="#命令行编译第一个Qt程序" class="headerlink" title="命令行编译第一个Qt程序"></a>命令行编译第一个Qt程序</h3><p>首先创建工作目录<code>HelloWorldQt</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir HelloWorld<br></code></pre></td></tr></table></figure><p>进入项目目录下，新建一个<code>main.cpp</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> HelloWorldQt<br>vim main.cpp<br></code></pre></td></tr></table></figure><p>编辑以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QLabel&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QWidget&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[ ])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br>    <span class="hljs-function">QLabel <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-string">&quot;&lt;center&gt;Welcome to my first Qt program&lt;/center&gt;&quot;</span>)</span></span>;<br>    hello.<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-string">&quot;My First Qt Program&quot;</span>);<br>    hello.<span class="hljs-built_in">resize</span>(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>);<br>    hello.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>建立QtProject文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">qmake -<span class="hljs-keyword">project</span><br></code></pre></td></tr></table></figure><p>用<code>vim</code>打开<code>HelloWorldQt.pro</code>文件，添加以下内容</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">QT +</span>=<span class="hljs-string"> gui widgets</span><br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210730095602.png"><br>运行<code>qmake</code>，使项目platform-specific，会得到一个<code>Makefile</code>文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">qmake <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HelloWorldQt</span>.</span></span>pro <br></code></pre></td></tr></table></figure><p>使用<code>make</code>命令将<code>Makefile</code>编译为可执行程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">➜  HelloWorldQt make<br>g++ -c -pipe -O2 -Wall -W -D_REENTRANT -fPIC -DQT_DEPRECATED_WARNINGS / <br>-DQT_NO_DEBUG -DQT_WIDGETS_LIB /<br>-DQT_GUI_LIB -DQT_CORE_LIB -I. / <br>-I. -isystem / <br><span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/x86_64-linux-gnu/</span>qt5 -isystem / <br><span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/x86_64-linux-gnu/</span>qt5<span class="hljs-regexp">/QtWidgets /</span><br>-isystem <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/x86_64-linux-gnu/</span>qt5<span class="hljs-regexp">/QtGui /</span><br>-isystem <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/x86_64-linux-gnu/</span>qt5<span class="hljs-regexp">/QtCore -I. /</span><br>-I<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>qt5<span class="hljs-regexp">/mkspecs/</span>linux-g++ -o main.o main.cpp<br>g++ -Wl,-O1 -o HelloWorldQt main.o  /<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libQt5Widgets.so /<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libQt5Gui.so / <br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libQt5Core.so /<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libGL.so -lpthread <br></code></pre></td></tr></table></figure><p>如果一切顺利，执行可以得到如下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./HelloWorldQt</span> <br></code></pre></td></tr></table></figure><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210728112155.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU文档</title>
    <link href="/2021/07/27/QEMU%E6%96%87%E6%A1%A3/"/>
    <url>/2021/07/27/QEMU%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="调用文档"><a href="#调用文档" class="headerlink" title="调用文档"></a>调用文档</h1><p><code>qemu-system-x86_64 [options] [disk_image] </code><br><code>disk_image</code>是 IDE 硬盘 0 的原始硬盘映像。某些目标不需要磁盘映像。</p><h2 id="标准参数-Standard-options"><a href="#标准参数-Standard-options" class="headerlink" title="标准参数 Standard options"></a>标准参数 Standard options</h2><h3 id="h"><a href="#h" class="headerlink" title="-h"></a><code>-h</code></h3><ul><li>功能<br>显示帮助信息并退出</li><li>子参数</li><li>调用实例  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-riscv<span class="hljs-number">32</span> -h<br></code></pre></td></tr></table></figure></li></ul><h3 id="version"><a href="#version" class="headerlink" title="-version"></a><code>-version</code></h3><ul><li>功能<br>显示qemu版本信息并退出</li><li>子参数</li><li>调用实例  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qemu-<span class="hljs-keyword">system</span>-riscv32 -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="machine-type-name-prop-value"><a href="#machine-type-name-prop-value" class="headerlink" title="-machine [type=]name[,prop=value[,...]]"></a><code>-machine [type=]name[,prop=value[,...]]</code></h3><ul><li>功能<br>通过名称选择模拟器。使用 <code>-machine help</code> 可以查看可用的模拟器。<br>对于支持跨版本实时迁移兼容性的架构，每个版本都会引入一个新的版本化模拟器类型。例如，2.8.0 版本为 <code>x86_64/i686</code> 架构引入了<code>“pc-i440fx-2.8”</code>和<code>“pc-q35-2.8”</code>。</li><li>子参数<br>为了允许用户从 QEMU 2.8.0 版实时迁移到 QEMU 2.9.0 版，2.9.0 版也必须支持<code>“pc-i440fx-2.8”</code>和<code>“pc-q35-2.8”</code>机器。为了允许用户在升级时实时迁移 VMs 跳过多个中间版本，QEMU 的新版本将支持多个以前版本的机器类型 。<br>支持的机器属性有：<ul><li><code>accel=accels1[:accels2[:...]]</code><br>This is used to enable an accelerator. Depending on the target architecture, kvm, xen, hax, hvf, nvmm, whpx or tcg can be available. By default, tcg is used. If there is more than one accelerator specified, the next one is used if the previous one fails to initialize.</li><li><code>vmport=on|off|auto</code><br>Enables emulation of VMWare IO port, for vmmouse etc. auto says to select the value based on accel. For accel=xen the default is off otherwise the default is on.</li><li><code>dump-guest-core=on|off</code><br>Include guest memory in a core dump. The default is on.</li><li><code>mem-merge=on|off</code><br>Enables or disables memory merge support. This feature, when supported by the host, de-duplicates identical memory pages among VMs instances (enabled by default).</li><li><code>aes-key-wrap=on|off</code><br>Enables or disables AES key wrapping support on s390-ccw hosts. This feature controls whether AES wrapping keys will be created to allow execution of AES cryptographic functions. The default is on.</li><li><code>dea-key-wrap=on|off</code><br>Enables or disables DEA key wrapping support on s390-ccw hosts. This feature controls whether DEA wrapping keys will be created to allow execution of DEA cryptographic functions. The default is on.</li><li><code>nvdimm=on|off</code><br>Enables or disables NVDIMM support. The default is off.</li><li><code>memory-encryption=</code><br>Memory encryption object to use. The default is none.</li><li><code>hmat=on|off</code><br>Enables or disables ACPI Heterogeneous Memory Attribute Table (HMAT) support. The default is off.</li><li><code>memory-backend=&#39;id&#39;</code><br>An alternative to legacy -mem-path and mem-prealloc options. Allows to use a memory backend as main RAM.<br>For example: <code>:: -object memory-backend-file,id=pc.ram,size=512M,mem-path=/hugetlbfs,prealloc=on,share=on -machine memory-backend=pc.ram -m 512M</code><br>Migration compatibility note: a) as backend id one shall use value of ‘default-ram-id’, advertised by machine type (available via query-machines QMP command), if migration to/from old QEMU (&lt;5.0) is expected. b) for machine types 4.0 and older, user shall use x-use-canonical-path-for-ramblock-id=off backend option if migration to/from old QEMU (&lt;5.0) is expected. For example: :: -object memory-backend-ram,id=pc.ram,size=512M,x-use-canonical-path-for-ramblock-id=off -machine memory-backend=pc.ram -m 512M</li></ul></li><li>调用实例：  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qemu-<span class="hljs-keyword">system</span>-riscv32 -machine virt,mem-<span class="hljs-built_in">merge</span>=<span class="hljs-keyword">on</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="cpu-model"><a href="#cpu-model" class="headerlink" title="-cpu model"></a><code>-cpu model</code></h3><ul><li>功能<br>选择 CPU 型号（<code>-cpu help</code>显示帮助列表和附加功能的选项）<blockquote><p>默认情况会给客户机提供qemu64或qemu32的基本CPU模型。这样做可以对CPU特性提供一些高级的过滤功能，让客户机在同一组硬件平台上的动态迁移会更加平滑和安全。<br>在客户机中查看CPU信息(cat /proc/cpuinfo)，model name就是当前CPU模型的名称。</p></blockquote></li><li>调用实例  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-riscv<span class="hljs-number">32</span> -cpu rv<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="accel-name-prop-value"><a href="#accel-name-prop-value" class="headerlink" title="accel name[,prop=value[,...]]"></a><code>accel name[,prop=value[,...]]</code></h3><ul><li>功能<br>This is used to enable an accelerator. Depending on the target architecture, kvm, xen, hax, hvf, nvmm, whpx or tcg can be available. By default, tcg is used. If there is more than one accelerator specified, the next one is used if the previous one fails to initialize.</li><li>子参数<ul><li><code>igd-passthru=on|off</code><br>When Xen is in use, this option controls whether Intel integrated graphics devices can be passed through to the guest (default=off)</li><li><code>kernel-irqchip=on|off|split</code><br>Controls KVM in-kernel irqchip support. The default is full acceleration of the interrupt controllers. On x86, split irqchip reduces the kernel attack surface, at a performance cost for non-MSI interrupts. Disabling the in-kernel irqchip completely is not recommended except for debugging purposes.</li><li><code>kvm-shadow-mem=size</code><br>Defines the size of the KVM shadow MMU.</li><li><code>split-wx=on|off</code><br>Controls the use of split w^x mapping for the TCG code generation buffer. Some operating systems require this to be enabled, and in such a case this will default on. On other operating systems, this will default off, but one may enable this for testing or debugging.</li><li><code>tb-size=n</code><br>Controls the size (in MiB) of the TCG translation block cache.</li><li><code>thread=single|multi</code><br>Controls number of TCG threads. When the TCG is multi-threaded there will be one thread per vCPU therefore taking advantage of additional host cores. The default is to enable multi-threading where both the back-end and front-ends support it and no incompatible TCG features have been enabled (e.g. icount/replay).</li><li><code>dirty-ring-size=n</code><br>When the KVM accelerator is used, it controls the size of the per-vCPU dirty page ring buffer (number of entries for each vCPU). It should be a value that is power of two, and it should be 1024 or bigger (but still less than the maximum value that the kernel supports). 4096 could be a good initial value if you have no idea which is the best. Set this value to 0 to disable the feature. By default, this feature is disabled (dirty-ring-size=0). When enabled, KVM will instead record dirty pages in a bitmap.</li></ul></li></ul><h3 id="smp-cpus-n-maxcpus-maxcpus-sockets-sockets-dies-dies-cores-cores-threads-threads"><a href="#smp-cpus-n-maxcpus-maxcpus-sockets-sockets-dies-dies-cores-cores-threads-threads" class="headerlink" title="smp [[cpus=]n][,maxcpus=maxcpus][,sockets=sockets][,dies=dies][,cores=cores][,threads=threads]"></a><code>smp [[cpus=]n][,maxcpus=maxcpus][,sockets=sockets][,dies=dies][,cores=cores][,threads=threads]</code></h3><ul><li><p>功能<br>配置客户机的SMP（Symmetric Multi-Processing），对称多处理机</p></li><li><p>子参数</p><ul><li><code>[cpus=]n </code><br>设置客户机中使用逻辑的CPU数量（默认值是1）。</li><li><code>[,maxcpus=cpus]</code><br>设置客户机最大可能被使用的CPU数量（可以用热插拔hot-plug添加CPU，不能超过maxcpus上限）。</li><li><code>[,cores=cores]</code><br>设置每个CPU socket上的core数量（默认值是1）。</li><li><code>[,threads=threads]</code><br>设置每个CPU core上的线程数（默认值是1）。</li><li><code>[,sockets=sockets]</code><br>设置客户机中总的CPU socket数量。</li></ul></li><li><p>调用实例</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>  -smp <span class="hljs-number">1</span>,sockets=<span class="hljs-number">1</span>,cores=<span class="hljs-number">2</span>,threads=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="numa-node-mem-size-cpus-firstcpu-lastcpu-nodeid-node-initiator-initiator"><a href="#numa-node-mem-size-cpus-firstcpu-lastcpu-nodeid-node-initiator-initiator" class="headerlink" title="-numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]"></a><code>-numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]</code></h3><h3 id="numa-node-memdev-id-cpus-firstcpu-lastcpu-nodeid-node-initiator-initiator"><a href="#numa-node-memdev-id-cpus-firstcpu-lastcpu-nodeid-node-initiator-initiator" class="headerlink" title="-numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]"></a><code>-numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]</code></h3><h3 id="numa-dist-src-source-dst-destination-val-distance"><a href="#numa-dist-src-source-dst-destination-val-distance" class="headerlink" title="-numa dist,src=source,dst=destination,val=distance"></a><code>-numa dist,src=source,dst=destination,val=distance</code></h3><h3 id="numa-cpu-node-id-node-socket-id-x-core-id-y-thread-id-z"><a href="#numa-cpu-node-id-node-socket-id-x-core-id-y-thread-id-z" class="headerlink" title="-numa cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]"></a><code>-numa cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]</code></h3><h3 id="numa-hmat-lb-initiator-node-target-node-hierarchy-hierarchy-data-type-tpye-latency-lat-bandwidth-bw"><a href="#numa-hmat-lb-initiator-node-target-node-hierarchy-hierarchy-data-type-tpye-latency-lat-bandwidth-bw" class="headerlink" title="-numa hmat-lb,initiator=node,target=node,hierarchy=hierarchy,data-type=tpye[,latency=lat][,bandwidth=bw]"></a><code>-numa hmat-lb,initiator=node,target=node,hierarchy=hierarchy,data-type=tpye[,latency=lat][,bandwidth=bw]</code></h3><h3 id="numa-hmat-cache-node-id-node-size-size-level-level-associativity-str-policy-str-line-size"><a href="#numa-hmat-cache-node-id-node-size-size-level-level-associativity-str-policy-str-line-size" class="headerlink" title="-numa hmat-cache,node-id=node,size=size,level=level[,associativity=str][,policy=str][,line=size]"></a><code>-numa hmat-cache,node-id=node,size=size,level=level[,associativity=str][,policy=str][,line=size]</code></h3><ul><li>功能</li><li>子参数</li><li>调用实例</li></ul><h3 id="add-fd-fd-fd-set-set-opaque-opaque"><a href="#add-fd-fd-fd-set-set-opaque-opaque" class="headerlink" title="-add-fd fd=fd,set=set[,opaque=opaque]"></a><code>-add-fd fd=fd,set=set[,opaque=opaque]</code></h3><ul><li>功能</li><li>子参数</li><li>调用实例</li></ul><h3 id="set-group-id-arg-value"><a href="#set-group-id-arg-value" class="headerlink" title="-set group.id.arg=value"></a><code>-set group.id.arg=value</code></h3><ul><li>功能</li><li>子参数</li><li>调用实例</li></ul><h3 id="global-driver-prop-value"><a href="#global-driver-prop-value" class="headerlink" title="-global driver.prop=value"></a><code>-global driver.prop=value</code></h3><ul><li>功能</li><li>子参数</li><li>调用实例</li></ul><h3 id="global-driver-driver-property-property-value-value"><a href="#global-driver-driver-property-property-value-value" class="headerlink" title="-global driver=driver,property=property,value=value"></a><code>-global driver=driver,property=property,value=value</code></h3><ul><li>功能</li><li>子参数</li><li>调用实例</li></ul><h3 id="boot-order-drives-once-drives-menu-on-off-splash-sp-name-splash-time-sp-time-reboot-timeout-rb-timeout-strict-on-off"><a href="#boot-order-drives-once-drives-menu-on-off-splash-sp-name-splash-time-sp-time-reboot-timeout-rb-timeout-strict-on-off" class="headerlink" title="-boot [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]"></a><code>-boot [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]</code></h3><ul><li>功能<br>设置客户机启动顺序<blockquote><p>在qemu模拟的x86平台中，用”a”、”b”分别表示第一和第二软驱，用”c”表示第一个硬盘，用”d”表示CD-ROM光驱，用”n”表示从网络启动。<br>默认从硬盘启动。</p></blockquote></li><li>子参数<ul><li><code>[order=drives]</code><br>设置启动顺序。</li><li><code>[,once=drives]</code><br>只设置下一次启动的顺序，再重启后无效。</li><li><code>[,menu=on|off]</code><br>只要固件/BIOS 支持，就可以启用交互式引导菜单/提示。默认为非交互式引导。</li><li><code>[,splash=sp_name]</code><br>如果固件/BIOS 支持选项 splash=sp_name 和 menu=on，则可以将启动画面传递给 bios，使用户能够将其显示为徽标。目前 Seabios for X86 系统支持它。限制：启动文件可以是 24 BPP 格式（真彩色）的 jpeg 文件或 BMP 文件。分辨率应该是SVGA模式支持的，推荐320x240、640x480、800x640。</li><li><code>[,splash-time=sp_time]</code></li><li><code>[,reboot-timeout=rb_timeout]</code><br>引导失败时，客户机将暂停 <code>rb_timeout</code> 毫秒，然后重新启动。如果 <code>rb_timeout</code> 为 ‘-1’，客户机不会重启，qemu 默认将 ‘-1’ 传递给 bios。目前 Seabios for X86 系统支持它。</li><li><code>[,strict=on|off]</code><br>只要固件/BIOS 支持，就通过严格启动。这仅在 bootindex 选项更改引导优先级时有效。默认为非严格引导。</li></ul></li><li>调用实例  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 尝试先从网络启动，然后从硬盘启动</span><br><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> -boot order=nc<br><span class="hljs-comment"># 先从光驱启动，重启后切换回默认顺序</span><br><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> -boot once=d<br><span class="hljs-comment"># 5 秒钟的启动画面。</span><br><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> -boot menu=<span class="hljs-literal">on</span>,splash=/root/boot.bmp,splash-time=<span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="m-size-megs-slots-n-maxmem-size"><a href="#m-size-megs-slots-n-maxmem-size" class="headerlink" title="-m [size=]megs[,slots=n,maxmem=size]"></a><code>-m [size=]megs[,slots=n,maxmem=size]</code></h3><ul><li><p>功能<br>将客户机内存设置为 <code>megs</code> M字节。默认值为 <code>128 MiB</code>。或者，也可以使用“M”或“G”的后缀。齐。</p></li><li><p>子参数</p><ul><li><code>[size=]megs</code><br>将客户机内存设置为 <code>megs</code> M字节</li><li><code>[,slots=n,maxmem=size]</code><br>可用于设置可热插拔内存插槽的数量和最大内存数量。<code>maxmem</code> 必须与页面大小对</li></ul></li><li><p>调用实例<br>以下命令行将客户机启动 RAM 大小设置为 1GB，创建 3 个插槽以热插拔额外内存，并将客户机可以达到的最大内存设置为 4GB：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> -m <span class="hljs-number">1</span>G,slots=<span class="hljs-number">3</span>,maxmem=<span class="hljs-number">4</span>G<br></code></pre></td></tr></table></figure><p>  如果未指定 <code>slot</code> 和 <code>maxmem</code>，则不会启用内存热插拔，并且客户机内存永远不会增加。</p></li></ul><h3 id="mem-path-path"><a href="#mem-path-path" class="headerlink" title="-mem-path path"></a><code>-mem-path path</code></h3><ul><li>功能<br>使用huge page。对于内存访问密集型的应用，使用<code>huge page</code>是可以比较明显地提高客户机性能。 使用<code>huge page</code>的内存不能被换出（swap out），也不能使用<code>ballooning</code>方式自动增长。</li><li>子参数</li><li>调用实例</li></ul><h3 id="mem-prealloc"><a href="#mem-prealloc" class="headerlink" title="-mem-prealloc"></a><code>-mem-prealloc</code></h3><ul><li>功能<br>使宿主机在客户机启动时就全部分配好客户机的内存</li><li>子参数</li><li>调用实例</li></ul><h3 id="k-language"><a href="#k-language" class="headerlink" title="-k language"></a><code>-k language</code></h3><ul><li><p>功能<br>设置键盘布局语言，默认为<code>en-us</code></p></li><li><p>子参数<br>可用布局：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ar</span>  de-ch  es  <span class="hljs-keyword">fo</span>     fr-<span class="hljs-keyword">ca</span>  hu  ja  <span class="hljs-keyword">mk</span>     <span class="hljs-keyword">no</span>  <span class="hljs-keyword">pt</span>-<span class="hljs-keyword">br</span>  <span class="hljs-keyword">sv</span><br>da  <span class="hljs-keyword">en</span>-gb  et  fr     fr-ch  <span class="hljs-keyword">is</span>  <span class="hljs-keyword">lt</span>  nl     pl  <span class="hljs-keyword">ru</span>     <span class="hljs-keyword">th</span><br>de  <span class="hljs-keyword">en</span>-us  fi  fr-<span class="hljs-keyword">be</span>  hr     it  <span class="hljs-keyword">lv</span>  nl-<span class="hljs-keyword">be</span>  <span class="hljs-keyword">pt</span>  <span class="hljs-keyword">sl</span>     <span class="hljs-keyword">tr</span><br></code></pre></td></tr></table></figure></li><li><p>调用实例</p></li></ul><h2 id="块设备参数-Block-device-options"><a href="#块设备参数-Block-device-options" class="headerlink" title="块设备参数 Block device options"></a>块设备参数 Block device options</h2><h3 id="fda-file"><a href="#fda-file" class="headerlink" title="fda file"></a><code>fda file</code></h3><ul><li>功能<br>为客户机指定软盘设备，指定客户机的第一个软盘设备,在客户机中显示为<code>/dev/fd0</code></li><li>子参数</li><li>调用实例</li></ul><h3 id="fdb-file"><a href="#fdb-file" class="headerlink" title="fdb file"></a><code>fdb file</code></h3><ul><li>功能<br>为客户机指定软盘设备，指定客户机的第一个软盘设备,在客户机中显示为<code>/dev/fd1</code></li><li>子参数</li><li>调用实例</li></ul><h3 id="hda-file"><a href="#hda-file" class="headerlink" title="hda file"></a><code>hda file</code></h3><h3 id="hdb-file"><a href="#hdb-file" class="headerlink" title="hdb file"></a><code>hdb file</code></h3><h3 id="hdc-file"><a href="#hdc-file" class="headerlink" title="hdc file"></a><code>hdc file</code></h3><h3 id="hdd-file"><a href="#hdd-file" class="headerlink" title="hdd file"></a><code>hdd file</code></h3><ul><li>功能<br>为客户机指定块存储设备，指定客户机种的第一个IDE设备</li><li>子参数<br>若客户机使用<code>PIIX_IDE</code>驱动，显示为<code>/dev/hda</code>设备；<br>若客户机使用<code>ata_piix</code>驱动，显示为<code>/dev/sda</code>设备。<br>若没有使用<code>-hdx</code>的参数，则默认使用<code>-hda</code>参数；<br>可以将宿主机的一块硬盘作为<code>-hda</code>的参数使用；<br>若文件名包含逗号，应使用两个连续的逗号进行转义。</li><li>调用实例</li></ul><h3 id="cdrom-file"><a href="#cdrom-file" class="headerlink" title="-cdrom file"></a><code>-cdrom file</code></h3><ul><li>功能<br>为客户机指定光盘CD-ROM。可以将宿主机的光驱<code>/dev/cdrom</code>设备作为<code>-cdrom</code>参数使用。<code>-cdrom</code>参数不能与<code>-hdc</code>参数同时使用，因为<code>-cdrom</code>就是客户机里的第三个IDE设备</li><li>子参数</li><li>调用实例</li></ul><h3 id="blockdev-option-option-option"><a href="#blockdev-option-option-option" class="headerlink" title="-blockdev option[,option[,option[,...]]]"></a><code>-blockdev option[,option[,option[,...]]]</code></h3><ul><li><p>功能</p></li><li><p>子参数</p></li><li><p>调用实例</p></li></ul><h3 id="drive-option-option-option"><a href="#drive-option-option-option" class="headerlink" title="-drive option[,option[,option[,...]]]"></a><code>-drive option[,option[,option[,...]]]</code></h3><ul><li>功能<br>定义一个存储驱动器</li><li>子参数<ul><li><code>[file=file]</code><br>加载<code>file</code>镜像文件到客户机的驱动器中。</li><li><code>[,if=type]</code><br>指定驱动器使用的接口类型：可用的类类型有：<code>ide</code>、<code>scsi</code>、<code>virtio</code>、<code>sd</code>、<code>floopy</code>、<code>pflash</code>等。</li><li><code>[,bus=n]</code><br>设置驱动器在客户机中的总线编号。</li><li><code>[,unit=m]</code><br>设置驱动器在客户机中的单元编号。</li><li><code>[,media=d]</code><br>设置驱动器中媒介的类型，值为disk或cdrom。</li><li><code>[,index=i]</code><br>设置在通一种接口的驱动器中的索引编号。</li><li><code>[,snapshot=on|off]</code><br>当值为on时，qemu不会将磁盘数据的更改写回到镜像文件中，而是写到临时文件中，可以在qemu moinitor中使用commit命令强制将磁盘数据保存回镜像文件中。</li><li><code>[,cache=writethrough|writeback|none|directsync|unsafe]</code><br>设置宿主机对块设备数据访问的cache模式。，<br><code>writethrough</code>（直写模式）：调用write写入数据的同时将数据写入磁盘缓存和后端块设备中。<br><code>writeback</code>（回写模式）：调用write写入数据时只将数据写入到磁盘缓存中，当数据被换出缓存时才写入到后端存储中。优点写入数据块，缺点系统掉电数据无法恢复。</li><li><code>[,aio=threads|native]</code><br>选择异步IO的方式</li><li><code>threads</code><br>为aio参数的默认值，让一个线程池去处理异步IO；</li><li><code>native</code><br>只适用于cache=none的情况，使用的是linux原生的AIO。</li><li><code>[,format=f]</code><br>指定使用的磁盘格式，默认是QEMU自动检测磁盘格式的。</li><li><code>[,serial=s]</code><br>指定分配给设备的序列号。</li><li><code>[,addr=A]</code><br>分配给驱动器控制器的PCI地址，只在使用virtio接口时适用。</li><li><code>[,id=name]</code><br>设置驱动器的ID，可以在QEMU monitor中用info block看到。<br><code>[,readonly=on|off]</code><br>设置驱动器是否只读。</li></ul></li><li>调用实例</li></ul><h2 id="USB参数-USB-convenience-options"><a href="#USB参数-USB-convenience-options" class="headerlink" title="USB参数 USB convenience options"></a>USB参数 USB convenience options</h2><h2 id="显示参数-Display-options"><a href="#显示参数-Display-options" class="headerlink" title="显示参数 Display options"></a>显示参数 Display options</h2><h2 id="仅限i386架构的参数-i386-target-only"><a href="#仅限i386架构的参数-i386-target-only" class="headerlink" title="仅限i386架构的参数 i386 target only"></a>仅限i386架构的参数 i386 target only</h2><h2 id="网络参数-Network-options"><a href="#网络参数-Network-options" class="headerlink" title="网络参数 Network options"></a>网络参数 Network options</h2><h2 id="字符设备参数-Character-device-options"><a href="#字符设备参数-Character-device-options" class="headerlink" title="字符设备参数 Character device options"></a>字符设备参数 Character device options</h2><h2 id="TPM设备-TPM-device-options"><a href="#TPM设备-TPM-device-options" class="headerlink" title="TPM设备 TPM device options"></a>TPM设备 TPM device options</h2><h2 id="指定启动指引-Linux-Multiboot-boot-specific"><a href="#指定启动指引-Linux-Multiboot-boot-specific" class="headerlink" title="指定启动指引 Linux/Multiboot boot specific"></a>指定启动指引 Linux/Multiboot boot specific</h2><p>当使用该调用参数时，你可以使用给定的Linux或者多重引导内核，而不需要安装内核到一个光盘中。这样可以更方便地测试不同内核。</p><ul><li><p><code>-kernel bzImage</code></p><ul><li>功能<br>用bzImage作为内核镜像，也可以使用其他启动格式。</li></ul></li><li><p><code>-append cmdline</code></p><ul><li>功能<br>用<code>cmd</code>命令行，作为内核的命令行</li></ul></li><li><p><code>-initrd file</code></p><ul><li>功能<br>用文件作为初始化ram</li></ul></li><li><p><code>-initrd &quot;file1 arg=foo,file2&quot;</code></p><ul><li>功能<br>此语法仅适用于多重引导<br>使用 <code>file1</code> 和 <code>file2</code> 作为模块并将 <code>arg=foo</code> 作为参数传递给第一个模块</li></ul></li><li><p><code>-dtb file</code></p><ul><li>功能<br>将文件用作设备树二进制 (dtb) 映像并在启动时将其传递给内核</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git踩坑记录</title>
    <link href="/2021/07/23/git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/07/23/git%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="创建仓库时没有加入gitignore文件，上传了不需要的文件，后添加了gitignore文件如何同步远程与本地的文件（自动删除不需要的文件）"><a href="#创建仓库时没有加入gitignore文件，上传了不需要的文件，后添加了gitignore文件如何同步远程与本地的文件（自动删除不需要的文件）" class="headerlink" title="创建仓库时没有加入gitignore文件，上传了不需要的文件，后添加了gitignore文件如何同步远程与本地的文件（自动删除不需要的文件）"></a>创建仓库时没有加入gitignore文件，上传了不需要的文件，后添加了gitignore文件如何同步远程与本地的文件（自动删除不需要的文件）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 注意有个点“.”</span><br>取消版本控制<br>git rm -r --cached .<br>重新添加<br>git add -A<br>重新提交<br>git commit -m &quot;update .gitignore&quot;<br></code></pre></td></tr></table></figure><h2 id="Git-rm和rm-–cached区别"><a href="#Git-rm和rm-–cached区别" class="headerlink" title="Git rm和rm –cached区别"></a>Git rm和rm –cached区别</h2><p><code>rm</code> ：当需要删除暂存区或分支上的文件，同时工作区不需要这个文件</p><p><code>rm --cached</code>：当需要删除暂存区或分支上的文件，同时工作区需要这个文件，但是不需要被版本控制。就是本地需要保留，但是远程不保留</p><h2 id="推送空文件夹到远程仓库"><a href="#推送空文件夹到远程仓库" class="headerlink" title="推送空文件夹到远程仓库"></a>推送空文件夹到远程仓库</h2><p>在需要推送的空文件下创建”.gitkeep”文件<br>在”.gitignore”文件中编写规则<br><code>!.gitkeep</code></p><h2 id="克隆指定分支代码"><a href="#克隆指定分支代码" class="headerlink" title="克隆指定分支代码"></a>克隆指定分支代码</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span>  <span class="hljs-title">-b</span> <span class="hljs-keyword">master</span> <span class="hljs-title">https</span>://github.com/Dunky-Z/Dunky-Z.github.io.git<br></code></pre></td></tr></table></figure><p><code>master</code>就是分支名</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>Git实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QEMU初识</title>
    <link href="/2021/07/23/QEMU%E5%88%9D%E8%AF%86/"/>
    <url>/2021/07/23/QEMU%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>QEMU是一款开源的模拟器及虚拟机监管器(Virtual Machine Monitor, VMM)。QEMU主要提供两种功能给用户使用。一是作为用户态模拟器，利用动态代码翻译机制来执行不同于主机架构的代码。二是作为虚拟机监管器，模拟全系统，利用其他VMM(Xen, KVM, etc)来使用硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="使用包管理安装"><a href="#使用包管理安装" class="headerlink" title="使用包管理安装"></a>使用包管理安装</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install qemu<br></code></pre></td></tr></table></figure><h3 id="使用源码安装"><a href="#使用源码安装" class="headerlink" title="使用源码安装"></a>使用源码安装</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> wget https://download.qemu.org/qemu-<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-rc<span class="hljs-number">3</span>.tar.xz<br><span class="hljs-attribute">tar</span> xvJf qemu-<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-rc<span class="hljs-number">3</span>.tar.xz<br><span class="hljs-attribute">cd</span> qemu-<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-rc<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="安装相关库"><a href="#安装相关库" class="headerlink" title="安装相关库"></a>安装相关库</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">apt-get <span class="hljs-keyword">install </span>libglib2.<span class="hljs-number">0</span>-dev<br>apt-get <span class="hljs-keyword">install </span>ninja-<span class="hljs-keyword">build</span><br><span class="hljs-keyword"></span>apt <span class="hljs-keyword">install </span>g++<br>apt <span class="hljs-keyword">install </span>libpixman<span class="hljs-number">-1</span>-dev<br>apt <span class="hljs-keyword">install </span>libsdl2-dev -y<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>通过<code> ./configure --help</code> 的查看编译时的选项，<code> --target-list</code>选项为可选的模拟器，默认全选。<br><code>--target-list</code> 中的 <code>xxx-soft</code> 和 <code>xxx-linux-user</code> 分别指系统模拟器和应用程序模拟器, 生成的二进制文件名字为<code>qemu-system-xxx</code>和 <code>qemu-xxx</code><br>本文使用如下配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">./configure <span class="hljs-attribute">--prefix</span>=XXX --enable-<span class="hljs-builtin-name">debug</span> <span class="hljs-attribute">--target-list</span>=riscv32-softmmu,riscv32-linux-user,riscv64-linux-user,riscv64-softmmu --enable-kvm<br><span class="hljs-comment"># --prefix 选项设置qemu的安装位置绝对路径，之后若要卸载删除qemu只要删除该文件夹即可，--enable-kvm开启kvm</span><br><span class="hljs-comment"># config完，可以在指定的qemu安装文件夹下面找到config-host.mak文件，</span><br><span class="hljs-comment"># 该文件记录着qemu配置的选项，可以和自己设置的进行对比，确保配置和自己已知</span><br></code></pre></td></tr></table></figure><p>接着进行编译</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">make</span> -j<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>直接<code>make</code>会很慢，第一次编译时默认安装说有模拟器，编译了三四个小时。加上<code>-j8</code>可以进行多线程编译</p><h2 id="创建与使用"><a href="#创建与使用" class="headerlink" title="创建与使用"></a>创建与使用</h2><h3 id="创建虚拟镜像"><a href="#创建虚拟镜像" class="headerlink" title="创建虚拟镜像"></a>创建虚拟镜像</h3><p>使用虚拟镜像来模拟虚拟机的硬盘，在启动虚拟机之前需要创建一个镜像文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># qemu-img create -f qcow2 qmtest.img 10G</span><br>Formatting <span class="hljs-string">&#x27;qmtest.img&#x27;</span>, fmt=qcow2 size=<span class="hljs-number">10737418240</span> encryption=off cluster_size=<span class="hljs-number">65536</span> lazy_refcounts=off <br>root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># ls</span><br>qmtest.img<br></code></pre></td></tr></table></figure><p><code>-f</code>选项用于指定镜像的格式，<code>qcow2</code>格式是QEMU最常用的镜像格式，采用写时复制技术来优化性能。<code>qmtest.img</code>是镜像文件的名字，<code>10G</code>是镜像文件大小。</p><p>镜像文件创建完成后，可使用<code>qemu-system-x86</code>来启动<code>x86</code>架构的虚拟机：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> qmtest.img<br></code></pre></td></tr></table></figure><p>qmtest.img中还未安装操作系统，所以会提示“No bootable device”的错误。</p><h3 id="准备操作系统镜像"><a href="#准备操作系统镜像" class="headerlink" title="准备操作系统镜像"></a>准备操作系统镜像</h3><p>下载需要的Linux发行版镜像文件,<a href="https://launchpad.net/ubuntu/+cdmirrors%EF%BC%8C">https://launchpad.net/ubuntu/+cdmirrors，</a> 找到想要下载的镜像，这里以交通大学的镜像为例<br>右击链接复制地址：<a href="https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso">https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso</a></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># wget https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso</span><br></code></pre></td></tr></table></figure><h3 id="检查KVM是否可用"><a href="#检查KVM是否可用" class="headerlink" title="检查KVM是否可用"></a>检查KVM是否可用</h3><p>QEMU使用KVM来提升虚拟机性能，如果不启用KVM会导致性能损失。要使用KVM，首先要检查硬件是否有虚拟化支持：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># grep -E &#x27;vmx|svm&#x27; /proc/cpuinfo</span><br></code></pre></td></tr></table></figure><p>如果有输出则表示硬件有虚拟化支持。其次要检查kvm模块是否已经加载：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># lsmod | grep kvm</span><br>kvm_intel             <span class="hljs-number">142999</span>  0 <br>kvm                   <span class="hljs-number">444314</span>  <span class="hljs-number">1</span> kvm_intel<br></code></pre></td></tr></table></figure><p>如果<code>kvm_intel/kvm_amd</code>、<code>kvm</code>模块被显示出来，则<code>kvm</code>模块已经加载。最后要确保qemu在编译的时候使能了<code>KVM</code>，即在执行<code>configure</code>脚本的时候加入了<code>–enable-kvm</code>选项。</p><h3 id="启动虚拟机安装操作系统"><a href="#启动虚拟机安装操作系统" class="headerlink" title="启动虚拟机安装操作系统"></a>启动虚拟机安装操作系统</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># qemu-system-x86_64 -m 2048 -enable-kvm qmtest.img -cdrom ./Fedora-Live-Desktop-x86_64-20-1.iso</span><br></code></pre></td></tr></table></figure><p><code>-m </code>指定虚拟机内存大小，默认单位是MB，<code>-enable-kvm</code>使用KVM进行加速，<code>-cdrom</code>添加fedora的安装镜像。可在弹出的窗口中操作虚拟机，安装操作系统，安装完成后重起虚拟机便会从硬盘(qmtest.img)启动。之后再启动虚拟机只需要执行：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment">#  qemu-system-x86_64 -m 2048 -enable-kvm qmtest.img</span><br></code></pre></td></tr></table></figure><h2 id="退出qemu"><a href="#退出qemu" class="headerlink" title="退出qemu"></a>退出qemu</h2><p>在运行qemu后，关闭图形界面但是终端仍然是处于qemu环境中，可以直接关闭终端退出。如果不想关闭终端，可以另外打开一个终端kill进程</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">killall</span> qemu-system-riscv<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><p>如果记不清全称，可以输入大概名称回车后会列出相关的进程</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是驱动，驱动的作用又是什么？</title>
    <link href="/2021/07/21/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A9%B1%E5%8A%A8%EF%BC%8C%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>/2021/07/21/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A9%B1%E5%8A%A8%EF%BC%8C%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>任何一个计算机系统的运行都是系统中软硬件协作的结果，没有硬件的软件是空中楼阁，而没有软件的硬件则只是一堆废铁。–<a href="https://blog.csdn.net/yunfenglw/article/details/39337343">天朗-星空</a></p></blockquote><p>硬件是底层基础，所有软件代码的运行平台，相对固定不易改变，而软件是具体的应用，它灵活多变，可以应对用户的不同需求。</p><p>为尽可能快速地完成设计，应用软件工程师不想也不必关心硬件，而硬件工程师也难有足够的闲暇和能力来顾忌软件。譬如，应用软件工程师在调用套接字发送和接收数据包的时候，不必关心网卡上的寄存器、存储空间、I/O端口、片选以及其他任何硬件层面的操作调度；在使用<code>printf()</code>函数输出信息的时候，他不用知道底层究竟是怎样把相应的信息输出到屏幕或者串口的具体硬件过程，需要的只是出现相应的显示效果。</p><p>也就是说，应用软件工程师需要看到一个没有硬件的纯粹的软件世界，硬件必须被透明地呈现给他们。谁来实现硬件对应用软件工程师的隐形？这个艰巨的任务就落在了驱动工程师的头上。</p><p>对设备驱动最通俗的解释就是“驱使硬件设备行动” 。设备驱动与底层硬件直接打交道，按照硬件设备的具体工作方式读写设备寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的映射，最终使通信设备能够收发数据，使显示设备能够显示文字和画面，使存储设备能够记录文件和数据。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建GitHub博客如何添加README文件</title>
    <link href="/2021/07/21/Hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0README%E6%96%87%E4%BB%B6/"/>
    <url>/2021/07/21/Hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0README%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>刚开始搭建的时候并没有为仓库添加Readme文件，但是后期添加也不能直接在仓库里直接添加，因为每次部署都会被自动删除。<br>添加方法：</p><ul><li>在博客根目录的<code>source</code>文件夹下新建<code>README.md</code>文件</li><li>在根目录的<code>_config.yml</code>文件中搜索<code>skip_render</code>，并做如下更改<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">skip_render: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>md<br></code></pre></td></tr></table></figure></li></ul><p>因为在每次<code>hexo g</code>时候，README文件都会被自动渲染为HTML文件，所以在配置文件中告诉渲染器跳过这个文件不要渲染他。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>QEMU学习记录</title>
    <link href="/2021/07/20/QEMU%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/07/20/QEMU%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="QEMU学习记录"><a href="#QEMU学习记录" class="headerlink" title="QEMU学习记录"></a>QEMU学习记录</h1><h2 id="什么是KVM？"><a href="#什么是KVM？" class="headerlink" title="什么是KVM？"></a>什么是KVM？</h2><p>基于内核的虚拟机 <code>Kernel-based Virtual Machine（KVM）</code>是一种内建于 Linux 中的开源虚拟化技术。具体而言，<code>KVM</code> 可帮助用户将 Linux 转变为虚拟机监控程序，使主机计算机能够运行多个隔离的虚拟环境，即虚拟客户机或虚拟机（VM）。</p><h2 id="什么是QEMU？"><a href="#什么是QEMU？" class="headerlink" title="什么是QEMU？"></a>什么是QEMU？</h2><p>Qemu是一个完整的可以单独运行的软件，它可以用来模拟不同架构的机器，非常灵活和可移植。它主要通过一个特殊的’重编译器’将为特定处理器编写二进制代码转换为另一种。</p><h2 id="KVM与QEMU的关系"><a href="#KVM与QEMU的关系" class="headerlink" title="KVM与QEMU的关系"></a>KVM与QEMU的关系</h2><p>KVM是Linux的一个模块。可以用<code>modprobe</code>去加载KVM模块。加载了模块后，才能进一步通过其他工具创建虚拟机。但仅有KVM模块是 远远不够的，因为用户无法直接控制内核模块去作事情：还必须有一个用户空间的工具才行。这个用户空间的工具，开发者选择了已经成型的开源虚拟化软件 QEMU。KVM使用了QEMU的一部分，并稍加改造，就成了可控制KVM的用户空间工具了。所以你会看到，官方提供的KVM下载有两 大部分三个文件，分别是KVM模块、QEMU工具以及二者的合集。也就是说，你可以只升级KVM模块，也可以只升级QEMU工具。</p><h2 id="QEMU用户模式与系统模式"><a href="#QEMU用户模式与系统模式" class="headerlink" title="QEMU用户模式与系统模式"></a>QEMU用户模式与系统模式</h2><p>QEMU属于应用层的仿真程序，它支持两种操作模式：<strong>用户模式</strong>模拟和<strong>系统模式</strong>模拟。</p><ul><li><strong>用户模式仿真</strong> 利用动态代码翻译机制，可以在当前CPU上执行被编译为支持其他CPU的程序，如可以在x86机器上执行一个ARM二进制可执行程序。（执行主机 CPU 指令的动态翻译并相应地转换 Linux 系统调用）。</li><li><strong>系统模式仿真</strong> 利用其它VMM(Xen, KVM)来使用硬件提供的虚拟化支持，创建接近于主机性能的全功能虚拟机，包括处理器和配套的外围设备（磁盘，以太网等）。</li></ul><h3 id="用户模式"><a href="#用户模式" class="headerlink" title="用户模式"></a>用户模式</h3><p>支持的CPU：x86 (32 and 64 bit), PowerPC (32 and 64 bit), ARM, MIPS (32 bit only), Sparc (32 and 64 bit), Alpha, ColdFire(m68k), CRISv32 和 MicroBlaze<br>下列操作系统支持QEMU的用户模式模拟：</p><ul><li>Linux (referred as qemu-linux-user)</li><li>BSD (referred as qemu-bsd-user)</li></ul><p>调用（<a href="https://qemu.readthedocs.io/en/latest/user/main.html">具体参数含义</a>）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">qemu-i386 <span class="hljs-selector-attr">[-h]</span> <span class="hljs-selector-attr">[-d]</span> <span class="hljs-selector-attr">[-L path]</span> <span class="hljs-selector-attr">[-s size]</span> <span class="hljs-selector-attr">[-cpu model]</span> <span class="hljs-selector-attr">[-g port]</span> <span class="hljs-selector-attr">[-B offset]</span> <span class="hljs-selector-attr">[-R size]</span> program <span class="hljs-selector-attr">[arguments...]</span><br></code></pre></td></tr></table></figure><p>用户模式模拟环境下运行速度要比系统模式模拟环境下快，但并不是完美模拟，比如程序读取<code>/proc/cpuinfo</code>内容时，由主机内核返回，因此返回的信息是描述主机CPU的，而不是模拟的CPU。</p><h3 id="系统模式"><a href="#系统模式" class="headerlink" title="系统模式"></a>系统模式</h3><p>首先创建虚拟镜像，模拟硬盘空间：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># qemu-img create -f qcow2 qmtest.img 10G</span><br>Formatting <span class="hljs-string">&#x27;qmtest.img&#x27;</span>, fmt=qcow2 size=<span class="hljs-number">10737418240</span> encryption=off cluster_size=<span class="hljs-number">65536</span> lazy_refcounts=off <br>root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># ls</span><br>qmtest.img<br></code></pre></td></tr></table></figure><p><code>-f</code>选项用于指定镜像的格式，<code>qcow2</code>格式是QEMU最常用的镜像格式，采用写时复制技术来优化性能。<code>qmtest.img</code>是镜像文件的名字，<code>10G</code>是镜像文件大小。</p><p>镜像文件创建完成后，可使用<code>qemu-system-x86</code>来启动<code>x86</code>架构的虚拟机：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> qmtest.img<br></code></pre></td></tr></table></figure><p>qmtest.img中还未安装操作系统，所以会提示“No bootable device”的错误。</p><p>其次，准备操作系统镜像<br>下载需要的Linux发行版镜像文件,<a href="https://launchpad.net/ubuntu/+cdmirrors%EF%BC%8C">https://launchpad.net/ubuntu/+cdmirrors，</a> 找到想要下载的镜像，这里以交通大学的镜像为例<br>右击链接复制地址：<a href="https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso">https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso</a></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># wget https://ftp.sjtu.edu.cn/ubuntu-cd/20.10/ubuntu-20.10-live-server-amd64.iso</span><br></code></pre></td></tr></table></figure><p>最后，启动虚拟机安装操作系统</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@hanhan</span><span class="hljs-symbol">:/home/dominic/qemu/</span><span class="hljs-comment"># qemu-system-x86_64 -m 2048 -enable-kvm qmtest.img -cdrom ./Fedora-Live-Desktop-x86_64-20-1.iso</span><br></code></pre></td></tr></table></figure><p><code>-m </code>指定虚拟机内存大小，默认单位是MB，<code>-enable-kvm</code>使用KVM进行加速，<code>-cdrom</code>添加fedora的安装镜像。</p><p>该模式下，要比用户模式模拟慢得多，因为模拟了目标内核，以及设备输入/输出、中断等。</p><h2 id="QEMU工作原理"><a href="#QEMU工作原理" class="headerlink" title="QEMU工作原理"></a>QEMU工作原理</h2><p><img src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210721140349.png"><br>单纯使用 qemu，采用的是完全虚拟化的模式。qemu 向 Guest OS 模拟 CPU，也模拟其他的硬件，GuestOS 认为自己和硬件直接打交道，其实是同 qemu 模拟出来的硬件打交道，qemu 会将这些指令转译给真正的硬件。由于所有的指令都要从 qemu 里面过一手，因而性能就会比较差。</p><p>完全虚拟化是非常慢的，所以要使用硬件辅助虚拟化技术 <code>Intel-VT</code>，<code>AMD-V</code>，所以需要 CPU 硬件开启这个标志位，一般在 BIOS 里面设置。当确认开始了标志位之后，通过<code> KVM</code>，GuestOS 的 CPU 指令不用经过 Qemu 转译，直接运行，大大提高了速度。所以，<code>KVM</code> 在内核里面需要有一个模块，来设置当前 CPU 是 Guest OS 在用，还是 Host OS 在用。</p><p>可以通过如下命令查看内核模块中是否有KVM</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lsmod <span class="hljs-string">| grep kvm</span><br></code></pre></td></tr></table></figure><p>KVM 内核模块通过 <code>/dev/kvm</code> 暴露接口，用户态程序可以通过 <code>ioctl</code>来访问这个接口。Qemu 将 KVM 整合进来，将有关 CPU 指令的部分交由内核模块来做，就是 <code>qemu-kvm (qemu-system-XXX)</code>。</p><p>qemu 和 kvm 整合之后，CPU 的性能问题解决了。另外 Qemu 还会模拟其他的硬件，如网络和硬盘。同样，全虚拟化的方式也会影响这些设备的性能。</p><p>于是，qemu 采取半虚拟化的方式，让 Guest OS 加载特殊的驱动来做这件事情。</p><p>例如，网络需要加载 <code>virtio_net</code>，存储需要加载 <code>virtio_blk</code>，Guest 需要安装这些半虚拟化驱动，GuestOS 知道自己是虚拟机，所以数据会直接发送给半虚拟化设备，经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。</p><blockquote><p>Q : 系统模式和用户模式的区别？<br>系统模式 是qemu虚拟出一套完整的硬件环境， 包含cpu，内存，网卡，硬盘，对于虚拟机上运行的OS看到的和硬件和真实的是一样的。<br>用户模式是直接将可执行的文件进行指令翻译，只虚拟出cpu。<br>假设有KVM：host 是 x86 ，QEMU 虚拟出x86 的系统模式 运行windows系统。QEMU会将 windows 指令直接交给  host cpu 直接运行（ 这个功能是由KVM 实现的，相当于直接调用host CPU）， 性能损失小  。 内存，硬盘，网络等外设是由qemu虚拟出来的。<br>假设无KVM：host 是 x86 ，QEMU 虚拟出x86 的系统模式运行windows系统。QEMU会将windows指令翻译成中间码，中间码再转成   host cpu 指令（ 这个功能是由qemu TCG 实现的），性能损失大。内存，硬盘，网洛等外设是由qemu 虚拟出来的。<br>假设有KVM：host 是 x86 ，QEMU 虚拟出riscv 的系统模式 运行Linux系统。QEMU会将Linux指令翻译成中间码，中间码再转成host cpu指令（ 这个功能是由qemu TCG 实现的），性能损失大。内存，硬盘，网洛等外设是由qemu 虚拟出来的。<br>KVM需要在虚拟机与宿主机架构相同时才生效。<br>此外， 用户模式下调用IO硬件会报错。qemu系统模式下会模拟出所有设备，但是模拟的IO设备效率低，所以后来有了半虚拟化。</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZH-Unix是什么，为什么重要？</title>
    <link href="/2021/07/20/ZH-Unix%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%9F/"/>
    <url>/2021/07/20/ZH-Unix%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Unix是什么，为什么重要？"><a href="#Unix是什么，为什么重要？" class="headerlink" title="Unix是什么，为什么重要？"></a>Unix是什么，为什么重要？</h1><blockquote><p>Author：CHRIS HOFFMAN<br>译 ：<a href="https://www.howtogeek.com/182649/htg-explains-what-is-unix/">What Is Unix, and Why Does It Matter?</a></p></blockquote><p>大多数操作系统都可以分为两大类。除了微软基于 Windows NT 的操作系统之外，几乎所有其他系统的祖宗都是Unix。</p><p>Linux、Mac OS X、Android、iOS、Chrome OS、PlayStation 4 上使用的 Orbis 操作系统，无论路由器上运行的是什么固件——所有这些操作系统通常都被称为“类 Unix”操作系统。</p><h2 id="Unix的设计延续至今"><a href="#Unix的设计延续至今" class="headerlink" title="Unix的设计延续至今"></a>Unix的设计延续至今</h2><p>19世纪中后期Unix在贝尔实验室中被开发出来。最初版的Unix有许多重要的设计特性至今仍然在使用。</p><p>“Unix哲学”之一就是，创建小型、模块化的程序，一个程序只做一件事并把它做好。如果你经常使用Linux 终端，那么你应该对此很熟悉——系统提供了许多实用程序，这些程序可以通过管道和其他功能以不同方式组合以执行更复杂的任务。甚至图形程序也可能在后台调用更简单的实用程序来完成复杂的工作。这也使得创建 shell 脚本变得容易，将简单的工具串在一起来完成复杂的事情。</p><p>Unix有一个程序之间通信用的单一文件系统。这就是为什么在Linux上“一切都是文件” ——包括硬件设备和提供系统信息或其他数据的特殊文件。这也是为什么只有 Windows 有驱动器号（C、D、E盘）的原因，它是从 DOS 继承的——在其他操作系统上，系统上的每个文件都是单个目录层次结构的一部分。</p><h2 id="追寻Unix的后代"><a href="#追寻Unix的后代" class="headerlink" title="追寻Unix的后代"></a>追寻Unix的后代</h2><p>Unix及其后代的历史错综复杂，简化起见，我们大致将Unix的后代分为两类。</p><p>一类Unix后代是在学术界发展起来的。第一个是BSD（BerkeleySoftwareDistribution），一个开源、类Unix操作系统。BSD通过FreeBSD、NetBSD和OpenBSD延续至今。NeXTStep也是基于最初的BSD开发的，Apple的Mac OS X 是基于NeXTStep开发出来的，而iOS则基于Mac OS X。还有一些操作系统，包括PlayStation 4上使用的Orbis OS，都是从BSD操作系统衍生而来的。</p><p>Richard Stallman的GNU项目也是为了应对AT&amp;T日益严格的Unix软件许可条款而启动的。MINIX是一个为教育目的而创建的类Unix操作系统，Linux的灵感来自于MINIX。我们今天所知道的Linux实际上是GNU/Linux，因为它由Linux内核和许多GNU实用程序组成。GNU/Linux并非直接继承自BSD，但它继承了Unix的设计并植根于学术界。当今的许多操作系统，包括Android、ChromeOS、SteamOS以及大量设备的嵌入式操作系统，都基于Linux。</p><p>另一类就是商业Unix操作系统。AT&amp;T UNIX、SCO UnixWare、Sun Microsystems Solaris、HP-UX、IBM AIX、SGI IRIX——许多大公司想要创建他们自己的Unix版本。这些在今天并不常见，但其中一些仍然存在。</p><h2 id="DOS-和-Windows-NT-的崛起"><a href="#DOS-和-Windows-NT-的崛起" class="headerlink" title="DOS 和 Windows NT 的崛起"></a>DOS 和 Windows NT 的崛起</h2><p>许多人期望Unix成为行业标准操作系统，但DOS系统和“IBM PC兼容”的计算机最终流行起来。Microsoft的DOS成为其中最成功的DOS系统。DOS系统完全不同于Unix，这就是为什么Windows使用反斜杠作为文件路径，而其他一切都使用正斜杠。这个决定是在DOS系统早期做出的，后来的Windows版本继承了它，就像BSD、Linux、Mac OS X 和其他类Unix操作系统继承了许多Unix的设计一样。</p><p>Windows 3.1、Windows 95、Windows 98 和 Windows ME 都基于底层的 DOS。当时，微软正在开发一种更现代、更稳定的操作系统，他们将其命名为 Windows NT——即“Windows  New Technology”。Windows NT 最终以 Windows XP 的形式出现在普通用户的计算机中，但在此之前，它以 Windows 2000 和 Windows NT 的形式供公司使用。</p><p>今天，微软的所有操作系统都基于 Windows NT 内核。Windows 7、Windows 8、Windows RT、Windows Phone 8、Windows Server 和 Xbox One 的操作系统都使用 Windows NT 内核。与大多数其他操作系统不同，Windows NT 并不是作为类 Unix 操作系统开发的。</p><p>当然，微软并不是完全重新开始。为了保持与 DOS 和旧的 Windows 软件的兼容性，Windows NT 继承了许多 DOS 约定，如驱动器号、文件路径的反斜杠和命令行的正斜杠。</p><blockquote><p>“在绝大多数地方，用的都是/（slash），包括Mac/Linux，也包括URL。你唯一需要记住的是，Microsoft这个怪鸡在自己的操作系统里面偏要用\（backslash），使得自己与众不同。<br>在Windows中，正斜杠/表示除法，用来进行整除运算；反斜杠\用来表示目录。<br>在Unix系统中，/表示目录；\表示跳脱字符将特殊字符变成一般字符<br>Windows由于使用斜杠/作为DOS命令提示符的参数标志了，为了不混淆，所以采用反斜杠\作为路径分隔符。所以目前windows系统上的文件浏览器都是用反斜杠\作为路径分隔符。</p></blockquote><h2 id="为什么重要？"><a href="#为什么重要？" class="headerlink" title="为什么重要？"></a>为什么重要？</h2><p>你是否曾经看过 Mac OS X 终端或文件系统，并注意到它与 Linux 的相似之处，以及它们与 Windows 的不同之处？嗯，这就是为什么——Mac OSX 和 Linux 都是类 Unix 操作系统。</p><p>了解这段历史有助于您了解什么是“类 Unix”操作系统，以及为什么这么多操作系统看起来彼此如此相似而 Windows 似乎如此不同。这解释了为什么Linux极客会觉得Mac OS X上的终端如此熟悉，而Windows上的命令提示符和PowerShell与其他命令行环境如此不同。</p><p>这只是一个简短的历史，它将帮助您了解我们如何到达今天的位置，而不会陷入细节中。如果您想了解更多信息，可以找到有关Unix历史的整本书。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>翻译</tag>
      
      <tag>Unix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo实时更新预览</title>
    <link href="/2021/07/20/Hexo%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E9%A2%84%E8%A7%88/"/>
    <url>/2021/07/20/Hexo%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E9%A2%84%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>在项目目录下安装 <code>hexo-browsersync</code> 插件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ npm <span class="hljs-keyword">install </span>hexo-<span class="hljs-keyword">browsersync </span>--save<br></code></pre></td></tr></table></figure><p><code>hexo s</code>启动服务后，每次保存markdown文件都会实时更新页面。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo和GitHub搭建博客以及更换电脑同步博客</title>
    <link href="/2021/07/20/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/07/20/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>只要有<code>source</code>文件夹下所有源文件就可以重新部署，按照正常的搭建Hexo环境开始搭建，搭建好以后将<code>source</code>文件夹替换即可，需要应用主题就下载主题然后替换。</p><p>注意：</p><ul><li>主题更换需要更改<code>_config_yml</code>文件</li><li><code>_config_yml</code>文件中的部署配置，<code>branch:master</code>就是每次<code>hexo d</code>操作推送的分支。而在命令行每次<code>git push</code>推送的分支是设置的默认分支<code>hexo</code><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> https:<span class="hljs-comment">//github.com/Dunky-Z/Dunky-Z.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><a href="https://www.jianshu.com/p/0b1fccce74e0">利用Hexo在多台电脑上提交和更新github pages博客</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld</title>
    <link href="/2020/08/23/HelloWorld/"/>
    <url>/2020/08/23/HelloWorld/</url>
    
    <content type="html"><![CDATA[<p>这是博客的第一篇文章</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
