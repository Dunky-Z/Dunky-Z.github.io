<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QEMU Decodetree详解 | 夜云泊</title>
<meta name=keywords content="QEMU,TCG,Decodetree"><meta name=description content="QEMU 在 decode 指令的时候，需要调用各平台所定义的 instruction decoders 来解析指令。如在 ARM 平台下，就定义了：disas_arm_insn()、disas_thumb_insn() 及 disas_thumb2_insn() 等来分别负责 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。"><meta name=author content="Nic"><link rel=canonical href=https://lifeislife.cn/posts/qemu-decodetree%E8%AF%A6%E8%A7%A3/><link crossorigin=anonymous href=/assets/css/stylesheet.4490366ee59f83f7324bce1d2f81fb1ebba1a551f24577c75929014495a1d9b1.css integrity="sha256-RJA2buWfg/cyS84dL4H7HruhpVHyRXfHWSkBRJWh2bE=" rel="preload stylesheet" as=style><link rel=icon href=https://lifeislife.cn/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lifeislife.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lifeislife.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://lifeislife.cn/apple-touch-icon.png><link rel=mask-icon href=https://lifeislife.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lifeislife.cn/posts/qemu-decodetree%E8%AF%A6%E8%A7%A3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PS8L2EEEPR")}</script><meta property="og:title" content="QEMU Decodetree详解"><meta property="og:description" content="QEMU 在 decode 指令的时候，需要调用各平台所定义的 instruction decoders 来解析指令。如在 ARM 平台下，就定义了：disas_arm_insn()、disas_thumb_insn() 及 disas_thumb2_insn() 等来分别负责 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。"><meta property="og:type" content="article"><meta property="og:url" content="https://lifeislife.cn/posts/qemu-decodetree%E8%AF%A6%E8%A7%A3/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="QEMU Decodetree详解"><meta name=twitter:description content="QEMU 在 decode 指令的时候，需要调用各平台所定义的 instruction decoders 来解析指令。如在 ARM 平台下，就定义了：disas_arm_insn()、disas_thumb_insn() 及 disas_thumb2_insn() 等来分别负责 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifeislife.cn/posts/"},{"@type":"ListItem","position":2,"name":"QEMU Decodetree详解","item":"https://lifeislife.cn/posts/qemu-decodetree%E8%AF%A6%E8%A7%A3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"QEMU Decodetree详解","name":"QEMU Decodetree详解","description":"QEMU 在 decode 指令的时候，需要调用各平台所定义的 instruction decoders 来解析指令。如在 ARM 平台下，就定义了：disas_arm_insn()、disas_thumb_insn() 及 disas_thumb2_insn() 等来分别负责 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。\n","keywords":["QEMU","TCG","Decodetree"],"articleBody":"QEMU 在 decode 指令的时候，需要调用各平台所定义的 instruction decoders 来解析指令。如在 ARM 平台下，就定义了：disas_arm_insn()、disas_thumb_insn() 及 disas_thumb2_insn() 等来分别负责 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。\n而 Decodetree 则是由 Bastian Koppelmann 于 2017 年在 移植 RISC-V QEMU 的时候所提出来的机制 (详见：讨论邮件1、讨论邮件2)。提出该机制主要是因为过往的 instruction decoders (如：ARM) 都是采用一堆 switch-case 来做判断。不仅难阅读，也难以维护。\n因此 Bastian Koppelmann 就提出了 Decodetree 的机制，开发者只需要通过 Decodetree 的语法定义各个指令的格式，便可交由 Decodetree 来动态生成对应包含 switch-case 的 instruction decoder .c 文档。\nDecodetree 特别适合像 RISC-V 这种具有固定指令格式的 ISA。\n因为各字段都在固定的位置，(如 RISC-V 的 opcode 都是固定在 bits[6..0] 的位置)。 \u003c!DOCTYPE html\u003e Responsive Image Decodetree 其实是由 Python script (./scripts/decodetree.py) 所生成的。使用文档可以参考：./docs/devel/decodetree.rst，里面有详细定义了其语法的格式。QEMU 在编译时，会调用 Decodetree，根据各平台所定义的 decode 文档，动态生成对应的 decoder。\n如 RISC-V 的 instruction decoders 就是被定义在：./target/riscv/*.decode 中。其 Makefile.obj 就有如下的声明：\n... DECODETREE = $(SRC_PATH)/scripts/decodetree.py decode32-y = $(SRC_PATH)/target/riscv/insn32.decode decode32-$(TARGET_RISCV64) += $(SRC_PATH)/target/riscv/insn32-64.decode ... target/riscv/decode_insn32.inc.c: $(decode32-y) $(DECODETREE) $(call quiet-command, \\ $(PYTHON) $(DECODETREE) -o $@ --static-decode decode_insn32 \\ $(decode32-y), \"GEN\", $(TARGET_DIR)$@) Decodetree 的语法共分为：Fields、Argument Sets、Formats、Patterns 五部分。本文将介绍如何通过 Decodetree 的语法，来动态生成一个指令的 decoder。\nField Field 定义如何取出一指令中，各字段 (eg: rd, rs1, rs2, imm) 的值。\nfield_def := '%' identifier ( unnamed_field )* ( !function=identifier )? unnamed_field := number ':' ( 's' ) number 其语法由 % 开头，随后紧接着一个 identifier 及零个或多个 unamed_field，并可再加上可选的 !function。\nidentifier 可由开发者自定，如：rd、imm… 等。 unamed_field 定义了该字段的所在比特。第一个数字定义了该字段的 least-significant bit position，第二个数字则定义了该字段的比特长度。另外可加上可选的 s 字符来标明在取出该字段后，是否需要做 符号扩展。 Eg：%rd 7:5 代表 rd 占了指令中 bits 7 ~ bits 11 的位置 (insn[11:7])，共 5 bits。 !function 定义在截取出该字段的值后，所会再调用的 function。 Field (32-bits 指令) 最后会生成对应的 extract32() 及 sextract32() 代码，以用来取得指令中各字段的值：\nField 示例 Input Generated code %disp 0:s16 sextract(i, 0, 16) %imm9 16:6 10:3 extract(i, 16, 6) « 3 %disp12 0:s1 1:1 2:10 sextract(i, 0, 1) « 11 %shimm8 5:s8 13:1 !function=expand_shimm8 expand_shimm8(sextract(i, 5, 8)) « 1 以 RISC-V 的 U-type 指令为例：\n\u003c!DOCTYPE html\u003e Responsive Image 其中，imm 占 insn[31:12]，共20位，rd 占 insn[11:7]，且 imm 需要做 符号扩展 后 左移 12 位 (20-bit immediate is shifted left by 12 bits to form U immediates)。因此，如果我们要定义 RISC-V 的 U-type 指令，则可以声明成：\n%rd 7:5 %imm_u 12:s20 !function=ex_shift_12 20 表示占 20 bits\n最后会生成如下的代码：\nstatic void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn) { a-\u003eimm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u003erd = extract32(insn, 7, 5); } static void decode_insn32_extract_u() 是由下文 Format 定义所生成的，而 arg_u *a 则是由 Argument Set 定义所生成的，将会在后面的部分再做说明。\n可以看到：\na-\u003eimm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u003erd = extract32(insn, 7, 5); a-\u003eimm 是由 insn[31:12] 所取得并做符号扩展，且会再调用 ex_shift_12() 来 左移 12 个 bits。\nP.S. RISC-V 的 ex_shift_12() 是通过定义在./target/riscv/translate.c 中 EX_SH 这个 macro 所展开的：\n#define EX_SH(amount) \\ static int ex_shift_##amount(DisasContext *ctx, int imm) \\ { \\ return imm \u003c\u003c amount; \\ } EX_SH(1) EX_SH(2) EX_SH(3) EX_SH(4) EX_SH(12) a-\u003erd 是由 insn[11:7] 所取得。\n此外，在 Decodetree 的 spec 中也有提到，我们可以通过只定义 !function 来直接调用该 function。在这种情况下，只有 DisasContext 会被传入该 function。\n如 ARM Thumb ./target/arm/t16.decode 就有定义：\n# Set S if the instruction is outside of an IT block. %s !function=t16_setflags static void disas_t16_extract_addsub_2i(DisasContext *ctx, arg_s_rri_rot *a, uint16_t insn) { a-\u003eimm = extract32(insn, 6, 3); a-\u003ern = extract32(insn, 3, 3); a-\u003erd = extract32(insn, 0, 3); a-\u003es = t16_setflags(ctx); a-\u003erot = 0; } 请注意，未包含任何 unnamed_fields 或 !function 的 Field 会被视为错误。\nArgument Set Argument Set 定义用来保存从指令中所截取出来各字段的值。\nargs_def := '\u0026' identifier ( args_elt )+ ( !extern )? args_elt := identifier 其语法由 \u0026 开头，随后紧接着一个或多个的 identifier ，并可再加上可选的 !extern 。\nidentifier 可由开发者自订，如：regs、loadstore… 等。 !extern 则表示是否在其他地方已经由其他的 decoder 定义过。如果有该字段，就不会再次生成对应的 argument set struct。 Argument Set 示例 例1：\n\u0026ampreg3 ra rb rc 会生成以下的 argument set struct：\ntypedef struct { int ra; int rb; int rc; } arg_reg3; 例2：\n\u0026loadstore reg base offset 则会生成以下的 argument set struct：\ntypedef struct { int base; int offset; int reg; } arg_loadstore; 因此，以刚刚的 RISC-V U-type 指令为例，我们需要从指令中截取 imm 及 rd 字段的值，可以声明其 argument set 如下：\n\u0026u imm rd 最后会生成以下的 argument set struct：\ntypedef struct { int imm; int rd; } arg_u; 此 argument set struct 会被传入由 Format 定义所生成的 extract function：\nstatic void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn) { a-\u003eimm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u003erd = extract32(insn, 7, 5); } 所传入的arg_u 会保存从指令中截取出的 imm 及 rd 字段的值，待后续使用。\nFormat Format 定义了指令的格式 (如 RISC-V 中的 R、I、S、B、U、J-type)，并会生成对应的 decode function。\nfmt_def := '@' identifier ( fmt_elt )+ fmt_elt := fixedbit_elt | field_elt | field_ref | args_ref fixedbit_elt := [01.-]+ field_elt := identifier ':' 's'? number field_ref := '%' identifier | identifier '=' '%' identifier args_ref := '\u0026' identifier 其语法由 @ 开头，随后紧接着一个 identifier 及一个以上的 fmt_elt。\nidentifier 可由开发者自订，如：opr、opi… 等。\nfmt_elt 则可以采用以下不同的语法：\nfixedbit_elt 包含一个或多个 0、1、.、-，每一个代表指令中的 1 个 bit。\n. 代表该 bit 可以用 0 或是 1 来表示。 - 代表该 bit 完全被忽略。 field_elt 可以用 Field 的语法来声明。\nEg：ra:5、rb:5、lit:8 field_ref 有下列两种格式 (以下范例参考上文所定义之 Field)：\n'%' identifier：直接参考一个被定义过的 Field。\n如：%rd，会生成：\na-\u003erd = extract32(insn, 7, 5); identifier '=' '%' identifier：直接参考一个被定义过的 Field，但通过第一个 identifier 来重命名其所对应的 argument 名称。此方式可以用来指定不同的 argument 名称来参考至同一个 Field。\n如：my_rd=%rd，会生成：\na-\u003emy_rd = extract32(insn, 7, 5); args_ref 指定所传入 decode function 的 Argument Set。若没有指定 args_ref 的话，Decodetree 会根据 field_elt 或 field_ref 自动生成一个 Argument Set。此外，一个 Format 最多只能包含一个 args_ref。\n当 fixedbit_elt 或 field_ref 被定义时，该 Foramt 的所有的 bits 都必须被定义 (可通过 fixedbit_elt 或 . 来定义各个 bits，空格会被忽略)。\nFormat 示例 @opi ...... ra:5 lit:8 1 ....... rc:5 定义了 op1 这个 Format，其中：\ninsn[31:26] 可为 0 或 1。 insn[25:21] 为 ra。 insn[20:13] 为 lit。 insn[12] 固定为 1。 insn[11:5] 可为 0 或 1。 insn[4:0] 为 rc。 此 Format 会生成以下的 decode function：\ntypedef struct { int lit; int ra; int rc; } arg_decode_insn320; static void decode_insn32_extract_opi(DisasContext *ctx, arg_decode_insn320 *a, uint32_t insn) { a-\u003era = extract32(insn, 21, 5); a-\u003elit = extract32(insn, 13, 8); a-\u003erc = extract32(insn, 0, 5); } 由于我们没有指定 args_ref，因此 Decodetree 根据了 field_elt 的定义，自动生成了 arg_decode_insn320 这个 Argument Set。\n以 RISC-V I-type 指令为例：\n# Fields: %rs1 15:5 %rd 7:5 # immediates: %imm_i 20:s12 # Argment sets: \u0026i imm rs1 rd @i ........ ........ ........ ........ \u0026i imm=%imm_i %rs1 %rd 定义了 i 这个 Format，其中：\ninsn[31:20] 为 imm，且为 符号扩展。 insn[19:5] 为 rs1。 insn[11:7] 为 rd。 此外，我们可以看到：\n此 Format 指定了 Argument Set：\u0026i。 \u0026i 中必须包含所有有用到的 arguments (也就是：imm、rs1 及 rd) imm 是通过重命名的方式来参考 %imm_i 这个 Field。 此范例会生成以下的 decode function：\ntypedef struct { int imm; int rd; int rs1; } arg_i; static void decode_insn32extract_i(DisasContext *ctx, arg_i *a, uint32_t insn) { a-\u003eimm = sextract32(insn, 20, 12); a-\u003ers1 = extract32(insn, 15, 5); a-\u003erd = extract32(insn, 7, 5); } 相比于第一个范例，由于这次我们有指定 args_ref：\u0026i，因此对应的 arg_i 会被传入 decode function。\n回到先前的 RISC-V U-type 指令，我们可以如同 I-type 指令定义其格式：\n# Fields: %rd 7:5 # immediates: %imm_u 12:s20 !function=ex_shift_12 # Argument sets: \u0026u imm rd @u .................... ..... ....... \u0026u imm=%imm_u %rd 定义了 u 这个 Format，其中：\ninsn[31:12] 为 imm，且为 符号扩展。 insn[11:7] 为 rd。 会生成以下的 decode function：\ntypedef struct { int imm; int rd; } arg_u; static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn) { a-\u003eimm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u003erd = extract32(insn, 7, 5); } 我们可以看到：\n此 Format 指定了 Argument Set：\u0026u。 \u0026u 中必须包含所有有用到的 arguments (也就是：imm、rd) imm 是通过重命名的方式来参考 %imm_u 这个 Field。 Pattern Pattern 实际定义了一个指令的 decode 方式。Decodetree 会根据 Patterns 的定义，来动态产生出对应的 switch-case decode 判断分支。\npat_def := identifier ( pat_elt )+ pat_elt := fixedbit_elt | field_elt | field_ref | args_ref | fmt_ref | const_elt fmt_ref := '@' identifier const_elt := identifier '=' number 其语法由用户所定义的 identifier，随后紧接着一个以上的 pat_elt。\nidentifier 可由开发者自订，如：addl_r、addli … 等。\npat_elt 则可以采用以下不同的语法：\nfixedbit_elt 与在 Format 中 fixedbit_elt 的定义相同。 field_elt 与在 Format 中 field_elt 的定义相同。 field_ref 与在 Format 中 field_ref 的定义相同。 args_ref 与在 Format 中 args_ref 的定义相同。 fmt_ref 直接参考一个被定义过的Format。 const_elt 可以直接指定某一个 argument 的值。 由于 Pattern 实际定义了一个指令的 decode 方式，因此所有的 bits 及 arguments (如果有参考 args_ref 的话) 都必须明确的被定义，如果在搭配了所有的 pat_elt 后还有未定义的 bits 或是 arguments 的话，Decodetree 便会报错。\n此外，Pattern 所产生出来的 decoder，最后还会调用对应的 translator function。translator function 需开发者自行定义。\nPattern 示例 addl_i 010000 ..... ..... .... 0000000 ..... @opi 定义了 addl_i 这个指令的 Pattern，其中：\ninsn[31:26] 为 010000。 insn[11:5] 为 0000000。 参考了 Format 示例中 定义的 @opi Format。 由于 Pattern 的所有 bits 都必须明确的被定义，因此 @opi 必须包含其余 insn[25:12] 及 insn[4:0] 的格式定义，否则 Decodetree 便会报错。 最后 addl_i 的 decoder 还会调用 trans_addl_i() 这个 translator function。\n搭配之前介绍的 Fields、Argument Sets 及 Formats，让我们再看几个完整的例子应该会更清楚 Decodetree 是怎产生一个指令的 decoder 的。\n首先是 RISC-V 的 lui 及 auipc 指令：\n\u003c!DOCTYPE html\u003e Responsive Image # Fields: %rd 7:5 # immediates: %imm_u 12:s20 !function=ex_shift_12 # Argument sets: \u0026u imm rd # Formats: @u .................... ..... ....... \u0026u imm=%imm_u %rd # Patterns lui .................... ..... 0110111 @u auipc .................... ..... 0010111 @u 会产生以下 lui 及 auipc 的 decoder：\ntypedef struct { int imm; int rd; } arg_u; static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn) { a-\u003eimm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u003erd = extract32(insn, 7, 5); } static bool decode_insn32(DisasContext *ctx, uint32_t insn) { union { arg_u f_u; } u; decode_insn32_extract_u(ctx, \u0026u.f_u, insn); switch (insn \u0026 0x0000007f) { case 0x00000017: if (trans_auipc(ctx, \u0026u.f_u)) return true; return false; case 0x00000037: if (trans_lui(ctx, \u0026u.f_u)) return true; return false; } return false; } 回顾到目前为止所介绍的：\nArgument Sets：\u0026u 这个 argument set 包含了 imm 及 rd 这两个 arguments。\ntypedef struct { int imm; int rd; } arg_u; Fields： imm 及 rd 分别位在 insn[31:12] 及 insn[11:7]，且 imm 为 符号扩展。最后在截取出 imm 的值后，还会调用 ex_shift_12()。\na-\u003eimm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u003erd = extract32(insn, 7, 5); Formats：@u 定义了 RISC-V U-type 指令的格式\n参考了 \u0026u 这个 Argument Set，因此 decode function 会传入 arg_u 作为参数。 insn[31:12] 参考了 imm_u 这个 Field (并重命名为 imm) insn[11:7] 参考了 rd 这个 Field。 static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn) { a-\u003eimm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-\u003erd = extract32(insn, 7, 5); } Patterns：\nlui 的 opcode (insn[6:0]) 为 0010111，也就是 0x17，在产生出来的 switch-case 中可以看到其对应的 case。 lui 的 decoder 最后调用了 trans_lui()，并传入 DisasContext 及经由 decode_insn32_extract_u() 所解析出来的 arg_u。 auipc 的 opcode (insn[6:0]) 为 0110111，也就是 0x37，在产生出来的 switch-case 中可以看到其对应的 case。 auipc 的 decoder 最后调用了 trans_auipc()，并传入 DisasContext 及经由 decode_insn32_extract_u() 所解析出来的 arg_u。 P.S. 这边由于 Decodetree 发现 lui 及 auipc 可以共用 decode_insn32_extract_u()，因此将其提到了 switch-case 之外。 static bool decode_insn32(DisasContext *ctx, uint32_t insn) { union { arg_u f_u; } u; decode_insn32_extract_u(ctx, \u0026u.f_u, insn); switch (insn \u0026 0x0000007f) { case 0x00000017: if (trans_auipc(ctx, \u0026u.f_u)) return true; return false; case 0x00000037: if (trans_lui(ctx, \u0026u.f_u)) return true; return false; } return false; } 我们另外可以发现，Pattern + Format 把所有的 32-bits 都给了明确的定义：\nPattern 定义了 opcode (insn[6:0])。 Format 参考了 imm (insn[31:12]) 及 rd (insn[11:7])。 如果有任何未明确定义的 bits 的话，Decodetree 便会报错，例如如果我们将 lui 的 opcode 最高 2 个 bits (insn[6:5]) 由 01 改成 ..：\nlui .................... ..... ..10111 @u Decodetree 在解析时，便会报错：\n./insn32.decode:17: error: (‘bits left unspecified (0x00000060)’,)\nDecodetree 提醒我们，insn[6:5] (0x00000060) 尚未给出明确定义，并会显示出其错误的行数。\ntrans_lui() 和 trans_auipc() 被定义在 target/riscv/insn_trans/trans_rvi.inc.c：\nstatic bool trans_lui(DisasContext *ctx, arg_lui *a) { if (a-\u003erd != 0) { tcg_gen_movi_tl(cpu_gpr[a-\u003erd], a-\u003eimm); } return true; } static bool trans_auipc(DisasContext *ctx, arg_auipc *a) { if (a-\u003erd != 0) { tcg_gen_movi_tl(cpu_gpr[a-\u003erd], a-\u003eimm + ctx-\u003ebase.pc_next); } return true; } 可以看到 trans_*() 负责实际指令的业务逻辑及产生对应的 TCG codes。\n如同先前所介绍，Patterns 的 pat_elt 也可以采用 field_elt 语法，如 RISC-V 的 fence 指令：\nfence ---- pred:4 succ:4 ----- 000 ----- 0001111 insn[27:24] 为 pred。 insn[23:20] 为 succ。 insn[14:12] 固定为 000。 insn[6:0] 为 opcode (0001111)。 没有参考任何的 Format。 剩下的 insn[31:28]、insn[19:15]、insn[11:7] 被声明为 -，因此就算没有被明确定义也没有关系。 所生成 fence 的 decoder 如下：\ntypedef struct { int pred; int succ; } arg_decode_insn320; static void decode_insn32_extract_decode_insn32_Fmt_0(DisasContext *ctx, arg_decode_insn320 *a, uint32_t insn) { a-\u003epred = extract32(insn, 24, 4); a-\u003esucc = extract32(insn, 20, 4); } static bool decode_insn32(DisasContext *ctx, uint32_t insn) { union { arg_decode_insn320 f_decode_insn320; } u; decode_insn32_extract_decode_insn32_Fmt_0(ctx, \u0026u.f_decode_insn320, insn); switch (insn \u0026 0x0000707f) { case 0x0000000f: if (trans_fence(ctx, \u0026u.f_decode_insn320)) return true; return false; } return false; } 值得注意的是，虽然这次我们没有参考任何的 Argument Set，但 Decodetree 还是替我们生成了一个包含 pred 和 succ 的 arg_decode_insn320 。\ntrans_fence() 同样是被定义在 ./target/riscv/insn_trans/trans_rvi.inc.c：\nstatic bool trans_fence(DisasContext *ctx, arg_fence *a) { tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC); return true; } Pattern Groups Pattern Groups 由一个以上的 Patterns 所组成，其主要差别是不同 Patterns 之间的 bits 可以 overlap。当同组中有多个 Patterns 时，会依据该组中各 Pattern 的声明顺序依序判断目前的指令是否符合其定义。除此之外，当符合的 Pattern 其 trans_*() 回传值为 false 时，也会被视为不相符，而继续判断该组中的下一个 Pattern。因此 Pattern Groups 非常适合将多个相似格式的指令给组成同一个 Pattern Group。\ngroup := '{' ( pat_def | group )+ '}' 各 Pattern Group 以 { 开头，并以 } 结尾，且允许 nested pattern groups 的存在，其他语法皆与 Pattern 相同。\nPattern Group 示例 { { nop 000010 ----- ----- 0000 001001 0 00000 copy 000010 00000 r1:5 0000 001001 0 rt:5 } or 000010 rt2:5 r1:5 cf:4 001001 0 rt:5 } 会产生以下的 decoder：\nswitch (insn \u0026 0xfc000fe0) { case 0x08000240: if ((insn \u0026 0x0000f000) == 0x00000000) { if ((insn \u0026 0x0000001f) == 0x00000000) { extract_decode_Fmt_0(\u0026u.f_decode0, insn); if (trans_nop(ctx, \u0026u.f_decode0)) return true; } if ((insn \u0026 0x03e00000) == 0x00000000) { extract_decode_Fmt_1(\u0026u.f_decode1, insn); if (trans_copy(ctx, \u0026u.f_decode1)) return true; } } extract_decode_Fmt_2(\u0026u.f_decode2, insn); if (trans_or(ctx, \u0026u.f_decode2)) return true; return false; } 当指令的值符合 nop 及 copy 这个内层 Pattern Group 时，会先判断该指令是否符合 nop 指令的定义，且 trans_nop() 的回传值为 true。否则的话，就会继续判断是否符合同组中的 copy 指令。若都不符，就会再判断是否符合外层 Pattern Group 的 or 指令。若仍不符，才会回传 false 表示 decode 失败。\n与单纯使用 Pattern 最大不同的是，当一 Pattern 的 trans_*() 回传值为 false 时，不会直接回传 false (代表 decode 失败)，而是会接续着判断后续的 Patterns 是否相符。\nRISC-V Compressed-Extension 中的 c.ebreak、c.jalr、及 c.add 指令，由于这三个指令的格式非常相似，因此非常适合使用 Pattern Group 来定义：\nRISC-V spec. 中定义：\n\u003c!DOCTYPE html\u003e Responsive Image C.EBREAK指令与C.ADD指令共享相同的opcode，但是rd和rs2都为zero，因此也可以使用CR格式。 C.JALR指令只有在rs1≠x0时才有效；当rs1=x0时，对应的代码点是C.EBREAK指令。 C.ADD指令只有在rs2≠x0时才有效；当rs2=x0时，对应的代码点是C.JALR和C.EBREAK指令。具有rs2̸=x0和rd=x0的代码点是HINTs。 c.ebreak、c.jalr、c.add 三个指令：\ninsn[15:13]、insn[12]、insn[1:0] 的值皆相同。 当 insn[11:7] 且 insn[6:2] 的值皆为 0 (rs1=0 且 rs2=0) 时为 c.ebreak 指令。 当只有 insn[11:7] 的值为 0 (rs1=0 且 rs2≠0) 时为 c.jalr 指令。 否则为 c.add 指令 (rs1≠x0 且 rs2≠0)。 # Fields %rd 7:5 %rs2_5 2:5 # Argument Sets \u0026r rd rs1 rs2 !extern \u0026i imm rs1 rd !extern # Formats @cr .... ..... ..... .. \u0026r rs2=%rs2_5 rs1=%rd %rd @c_jalr ... . ..... ..... .. \u0026i imm=0 rs1=%rd # Pattern Groups { ebreak 100 1 00000 00000 10 jalr 100 1 ..... 00000 10 @c_jalr rd=1 # C.JALR add 100 1 ..... ..... 10 @cr } 所生成的 decoder 如下：\nstatic void decode_insn16_extract_c_jalr(DisasContext *ctx, arg_i *a, uint16_t insn) { a-\u003eimm = 0; a-\u003ers1 = extract32(insn, 7, 5); } static void decode_insn16_extract_cr(DisasContext *ctx, arg_r *a, uint16_t insn) { a-\u003ers2 = extract32(insn, 2, 5); a-\u003ers1 = extract32(insn, 7, 5); a-\u003erd = extract32(insn, 7, 5); } static void decode_insn16_extract_decode_insn16_Fmt_2(DisasContext *ctx, arg_decode_insn162 *a, uint16_t insn) {} static bool decode_insn16(DisasContext *ctx, uint16_t insn) { union { arg_decode_insn162 f_decode_insn162; arg_i f_i; arg_r f_r; } u; switch (insn \u0026 0x0000f003) { case 0x00009002: if ((insn \u0026 0x00000ffc) == 0x00000000) { decode_insn16_extract_decode_insn16_Fmt_2(ctx, \u0026u.f_decode_insn162, insn); if (trans_ebreak(ctx, \u0026u.f_decode_insn162)) return true; } if ((insn \u0026 0x0000007c) == 0x00000000) { decode_insn16_extract_c_jalr(ctx, \u0026u.f_i, insn); u.f_i.rd = 1; if (trans_jalr(ctx, \u0026u.f_i)) return true; } decode_insn16_extract_cr(ctx, \u0026u.f_r, insn); if (trans_add(ctx, \u0026u.f_r)) return true; return false; } return false; } 当指令格式符合 c.ebreak、c.jalr、c.add 的 Pattern Group 时，会依序判断该指令是否符合 c.ebreak、c.jalr、c.add 的定义以及其对应的 trans_*()。\n另外值得一提的是，在 c_jalr Format 和 jalr Pattern 中有分别指定其 imm 及 rd 的值为 0，所生成的 codes 也会分别在对应的地方将该值设为 0 (见 codes 注解说明)。\n总结 以上就是 Decodetree 的语法说明。通过 Decodetree，我们不用再像以前以样写一大包的 switch-case 来 decode 指令。将不同类型的指令写至不同的 decode 档，不仅方便维护，阅读起来也更为容易。\n--translate：translator function 的 prefix，默认为 trans。一旦指定后，translator function 的 scope 就不会再是 static。 --decode：decode function 的 prefix，默认为 decode，且 scope 为 static。一旦指定后，decode function 的 scope 就不会再是 static。 --static-decode：如同 --decode，不过 decode function 的 scope 仍维持为 static。 -o / --output：指定生成的 decoder .c 档路径。 -w / --insnwidth：指令长度，eg：32 or 16，默认为 32。 --varinsnwidth：指令为不定长度。 最后一个参数为输入的 decode 档路径。 运行范例：\n./decodetree.py -o target/riscv/decode_insn16.inc.c --static-decode decode_insn16 \\ -w 16 ./insn16.decode static inline int32_t sextract32(uint32_t value, int start, int length){ assert(start \u003e= 0 \u0026\u0026 length \u003e 0 \u0026\u0026 length \u003c= 32 - start); return ((int32_t)(value \u003c\u003c (32 - length - start))) \u003e\u003e (32 - length);} ","wordCount":"6345","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Nic"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifeislife.cn/posts/qemu-decodetree%E8%AF%A6%E8%A7%A3/"},"publisher":{"@type":"Organization","name":"夜云泊","logo":{"@type":"ImageObject","url":"https://lifeislife.cn/assets/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script defer src=/static/fontawesome/fontawesome-all.js></script><header class=header><nav class=nav><div class=logo><a href=https://lifeislife.cn/ accesskey=h title="夜云泊 (Alt + H)">夜云泊</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lifeislife.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://lifeislife.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://lifeislife.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://lifeislife.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://www.travellings.cn/go.html title=开往><span><i class='fa-solid fa-train-subway'></i>开往</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lifeislife.cn/>主页</a>&nbsp;»&nbsp;<a href=https://lifeislife.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">QEMU Decodetree详解</h1><div class=post-meta>13 分钟&nbsp;·&nbsp;6345 字&nbsp;·&nbsp;Nic</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#field>Field</a><ul><li><a href=#field-示例>Field 示例</a></li></ul></li><li><a href=#argument-set>Argument Set</a><ul><li><a href=#argument-set-示例>Argument Set 示例</a></li></ul></li><li><a href=#format>Format</a><ul><li><a href=#format-示例>Format 示例</a></li></ul></li><li><a href=#pattern>Pattern</a><ul><li><a href=#pattern-示例>Pattern 示例</a></li></ul></li><li><a href=#pattern-groups>Pattern Groups</a><ul><li><a href=#pattern-group-示例>Pattern Group 示例</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><p>QEMU 在 decode 指令的时候，需要调用各平台所定义的 instruction decoders 来解析指令。如在 ARM 平台下，就定义了：<code>disas_arm_insn()</code>、<code>disas_thumb_insn()</code> 及 <code>disas_thumb2_insn()</code> 等来分别负责 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。</p><p>而 <code>Decodetree</code> 则是由 <code>Bastian Koppelmann</code> 于 2017 年在 移植 RISC-V QEMU 的时候所提出来的机制 (详见：<a href=https://lists.gnu.org/archive/html/qemu-devel/2017-07/msg07735.html>讨论邮件1</a>、<a href=https://lists.gnu.org/archive/html/qemu-devel/2017-10/msg05046.html>讨论邮件2</a>)。提出该机制主要是因为过往的 instruction decoders (如：ARM) 都是采用一堆 <code>switch-case</code> 来做判断。不仅难阅读，也难以维护。</p><p>因此 <code>Bastian Koppelmann</code> 就提出了 <code>Decodetree</code> 的机制，开发者只需要通过 <code>Decodetree</code> 的语法定义各个指令的格式，便可交由 <code>Decodetree</code> 来动态生成对应包含 <code>switch-case</code> 的 instruction decoder <code>.c</code> 文档。</p><p><code>Decodetree</code> 特别适合像 RISC-V 这种具有<strong>固定指令格式</strong>的 ISA。</p><ul><li>因为各字段都在固定的位置，(如 RISC-V 的 <code>opcode</code> 都是固定在 <code>bits[6..0]</code> 的位置)。</li></ul><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F18%2F5a051d22c43a2ce34069fecd2e4fb8c0.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F18%2F5a051d22c43a2ce34069fecd2e4fb8c0.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p><code>Decodetree</code> 其实是由 Python script (<code>./scripts/decodetree.py</code>) 所生成的。使用文档可以参考：<code>./docs/devel/decodetree.rst</code>，里面有详细定义了其语法的格式。QEMU 在编译时，会调用 <code>Decodetree</code>，根据各平台所定义的 decode 文档，动态生成对应的 decoder。</p><ul><li><p>如 RISC-V 的 instruction decoders 就是被定义在：<code>./target/riscv/*.decode</code> 中。其 <code>Makefile.obj</code> 就有如下的声明：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>DECODETREE = $(SRC_PATH)/scripts/decodetree.py
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>decode32-y = $(SRC_PATH)/target/riscv/insn32.decode
</span></span><span class=line><span class=cl>decode32-$(TARGET_RISCV64) += $(SRC_PATH)/target/riscv/insn32-64.decode
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>target/riscv/decode_insn32.inc.c: $(decode32-y) $(DECODETREE)
</span></span><span class=line><span class=cl>	$(call quiet-command, \
</span></span><span class=line><span class=cl>	  $(PYTHON) $(DECODETREE) -o $@ --static-decode decode_insn32 \
</span></span><span class=line><span class=cl>          $(decode32-y), &#34;GEN&#34;, $(TARGET_DIR)$@)
</span></span></code></pre></div></li></ul><p><code>Decodetree</code> 的语法共分为：Fields、Argument Sets、Formats、Patterns 五部分。本文将介绍如何通过 <code>Decodetree</code> 的语法，来动态生成一个指令的 decoder。</p><h2 id=field>Field<a hidden class=anchor aria-hidden=true href=#field>#</a></h2><p><code>Field</code> 定义如何取出一指令中，各<strong>字段</strong> (eg: <code>rd</code>, <code>rs1</code>, <code>rs2</code>, <code>imm</code>) 的值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>field_def     := &#39;%&#39; identifier ( unnamed_field )* ( !function=identifier )?
</span></span><span class=line><span class=cl>unnamed_field := number &#39;:&#39; ( &#39;s&#39; ) number
</span></span></code></pre></div><p>其语法由 <code>%</code> 开头，随后紧接着一个 <code>identifier</code> 及零个或多个 <code>unamed_field</code>，并可再加上可选的 <code>!function</code>。</p><ul><li><code>identifier</code> 可由开发者自定，如：<code>rd</code>、<code>imm</code>… 等。</li><li><code>unamed_field</code> 定义了该字段的所在比特。第一个数字定义了该字段的 <code>least-significant bit position</code>，第二个数字则定义了该字段的<code>比特长度</code>。另外可加上可选的 <code>s</code> 字符来标明在取出该字段后，是否需要做 符号扩展。<ul><li>Eg：<code>%rd 7:5</code> 代表 <code>rd</code> 占了指令中 bits 7 ~ bits 11 的位置 (insn[11:7])，共 5 bits。</li></ul></li><li><code>!function</code> 定义在截取出该字段的值后，所会再调用的 function。</li></ul><p><code>Field</code> (32-bits 指令) 最后会生成对应的 <code>extract32()</code> 及 <code>sextract32()</code> 代码，以用来取得指令中各字段的值：</p><h3 id=field-示例>Field 示例<a hidden class=anchor aria-hidden=true href=#field-示例>#</a></h3><table><thead><tr><th style=text-align:left>Input</th><th style=text-align:left>Generated code</th></tr></thead><tbody><tr><td style=text-align:left>%disp 0:s16</td><td style=text-align:left>sextract(i, 0, 16)</td></tr><tr><td style=text-align:left>%imm9 16:6 10:3</td><td style=text-align:left>extract(i, 16, 6) &#171; 3</td></tr><tr><td style=text-align:left>%disp12 0:s1 1:1 2:10</td><td style=text-align:left>sextract(i, 0, 1) &#171; 11</td></tr><tr><td style=text-align:left>%shimm8 5:s8 13:1 !function=expand_shimm8</td><td style=text-align:left>expand_shimm8(sextract(i, 5, 8)) &#171; 1</td></tr></tbody></table><p>以 RISC-V 的 <code>U-type</code> 指令为例：</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F18%2Ffb558390c2c5a8c8b9e1645d90cabfc8.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F18%2Ffb558390c2c5a8c8b9e1645d90cabfc8.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>其中，<code>imm</code> 占 <code>insn[31:12]</code>，共20位，<code>rd</code> 占 <code>insn[11:7]</code>，且 <code>imm</code> 需要做 符号扩展 后 <code>左移 12 位</code> (<code>20-bit immediate is shifted left by 12 bits to form U immediates</code>)。因此，如果我们要定义 RISC-V 的 <code>U-type</code> 指令，则可以声明成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>%rd       7:5
</span></span><span class=line><span class=cl>%imm_u    12:s20                 !function=ex_shift_12
</span></span></code></pre></div><blockquote><p>20 表示占 20 bits</p></blockquote><p>最后会生成如下的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn32_extract_u</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_u</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>=</span> <span class=nf>ex_shift_12</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=nf>sextract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>20</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><code>static void decode_insn32_extract_u()</code> 是由下文 Format 定义所生成的，而 <code>arg_u *a</code> 则是由 Argument Set 定义所生成的，将会在后面的部分再做说明。</p></blockquote><p>可以看到：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>=</span> <span class=nf>ex_shift_12</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=nf>sextract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>20</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span></code></pre></div><ul><li><p><code>a->imm</code> 是由 <code>insn[31:12]</code> 所取得并做符号扩展，且会再调用 <code>ex_shift_12()</code> 来 <code>左移 12 个 bits</code>。</p><ul><li><p>P.S. RISC-V 的 <code>ex_shift_12()</code> 是通过定义在<code>./target/riscv/translate.c</code> 中 <code>EX_SH</code> 这个 macro 所展开的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define EX_SH(amount) \
</span></span></span><span class=line><span class=cl><span class=cp>    static int ex_shift_##amount(DisasContext *ctx, int imm) \
</span></span></span><span class=line><span class=cl><span class=cp>    {                                         \
</span></span></span><span class=line><span class=cl><span class=cp>        return imm &lt;&lt; amount;                 \
</span></span></span><span class=line><span class=cl><span class=cp>    }
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nf>EX_SH</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>EX_SH</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>EX_SH</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>EX_SH</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>EX_SH</span><span class=p>(</span><span class=mi>12</span><span class=p>)</span>
</span></span></code></pre></div></li></ul></li><li><p><code>a->rd</code> 是由 <code>insn[11:7]</code> 所取得。</p></li></ul><p>此外，在 <code>Decodetree</code> 的 spec 中也有提到，我们可以通过只定义 <code>!function</code> 来直接调用该 function。在这种情况下，只有 <code>DisasContext</code> 会被传入该 function。</p><p>如 ARM Thumb <code>./target/arm/t16.decode</code> 就有定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl># Set S if the instruction is outside of an IT block.
</span></span><span class=line><span class=cl>%s               !function=t16_setflags
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>disas_t16_extract_addsub_2i</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_s_rri_rot</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rn</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>s</span> <span class=o>=</span> <span class=nf>t16_setflags</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rot</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>请注意，未包含任何 <code>unnamed_fields</code> 或 <code>!function</code> 的 <code>Field</code> 会被视为错误。</p><hr><h2 id=argument-set>Argument Set<a hidden class=anchor aria-hidden=true href=#argument-set>#</a></h2><p><code>Argument Set</code> 定义用来保存从指令中所截取出来各字段的值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>args_def    := &#39;&amp;&#39; identifier ( args_elt )+ ( !extern )?
</span></span><span class=line><span class=cl>args_elt    := identifier
</span></span></code></pre></div><p>其语法由 <code>&</code> 开头，随后紧接着一个或多个的 <code>identifier</code> ，并可再加上可选的 <code>!extern</code> 。</p><ul><li><code>identifier</code> 可由开发者自订，如：<code>regs</code>、<code>loadstore</code>… 等。</li><li><code>!extern</code> 则表示是否在其他地方已经由其他的 decoder 定义过。如果有该字段，就<strong>不会</strong>再次生成对应的 <code>argument set struct</code>。</li></ul><h3 id=argument-set-示例>Argument Set 示例<a hidden class=anchor aria-hidden=true href=#argument-set-示例>#</a></h3><p>例1：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>&amp;ampreg3 ra rb rc
</span></span></code></pre></div><p>会生成以下的 <code>argument set struct</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ra</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>arg_reg3</span><span class=p>;</span>
</span></span></code></pre></div><p>例2：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>&amp;loadstore reg base offset
</span></span></code></pre></div><p>则会生成以下的 <code>argument set struct</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>reg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>arg_loadstore</span><span class=p>;</span>
</span></span></code></pre></div><p>因此，以刚刚的 RISC-V <code>U-type</code> 指令为例，我们需要从指令中截取 <code>imm</code> 及 <code>rd</code> 字段的值，可以声明其 <code>argument set</code> 如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>&amp;u    imm rd
</span></span></code></pre></div><p>最后会生成以下的 <code>argument set struct</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>imm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>arg_u</span><span class=p>;</span>
</span></span></code></pre></div><p>此 <code>argument set struct</code> 会被传入由 <code>Format</code> 定义所生成的 extract function：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn32_extract_u</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_u</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>=</span> <span class=nf>ex_shift_12</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=nf>sextract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>20</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>所传入的<code>arg_u</code> 会保存从指令中截取出的 <code>imm</code> 及 <code>rd</code> 字段的值，待后续使用。</p><h2 id=format>Format<a hidden class=anchor aria-hidden=true href=#format>#</a></h2><p><code>Format</code> 定义了指令的格式 (如 RISC-V 中的 <code>R</code>、<code>I</code>、<code>S</code>、<code>B</code>、<code>U</code>、<code>J-type</code>)，并会生成对应的 decode function。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>fmt_def      := &#39;@&#39; identifier ( fmt_elt )+
</span></span><span class=line><span class=cl>fmt_elt      := fixedbit_elt | field_elt | field_ref | args_ref
</span></span><span class=line><span class=cl>fixedbit_elt := [01.-]+
</span></span><span class=line><span class=cl>field_elt    := identifier &#39;:&#39; &#39;s&#39;? number
</span></span><span class=line><span class=cl>field_ref    := &#39;%&#39; identifier | identifier &#39;=&#39; &#39;%&#39; identifier
</span></span><span class=line><span class=cl>args_ref     := &#39;&amp;&#39; identifier
</span></span></code></pre></div><p>其语法由 <code>@</code> 开头，随后紧接着一个 <code>identifier</code> 及一个以上的 <code>fmt_elt</code>。</p><ul><li><p><code>identifier</code> 可由开发者自订，如：<code>opr</code>、<code>opi</code>… 等。</p></li><li><p><code>fmt_elt</code> 则可以采用以下不同的语法：</p><ul><li><p><code>fixedbit_elt</code> 包含一个或多个 <code>0</code>、<code>1</code>、<code>.</code>、<code>-</code>，每一个代表指令中的 1 个 bit。</p><ul><li><code>.</code> 代表该 bit 可以用 <code>0</code> 或是 <code>1</code> 来表示。</li><li><code>-</code> 代表该 bit 完全被忽略。</li></ul></li><li><p><code>field_elt</code> 可以用 Field 的语法来声明。</p><ul><li>Eg：<code>ra:5</code>、<code>rb:5</code>、<code>lit:8</code></li></ul></li><li><p><code>field_ref</code> 有下列两种格式 (以下范例参考上文所定义之 Field)：</p><ul><li><p><code>'%' identifier</code>：直接参考一个被定义过的 <code>Field</code>。</p><ul><li><p>如：<code>%rd</code>，会生成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span></code></pre></div></li></ul></li><li><p><code>identifier '=' '%' identifier</code>：直接参考一个被定义过的 <code>Field</code>，但通过第一个 <code>identifier</code> 来重命名其所对应的 <code>argument</code> 名称。此方式可以用来指定不同的 <code>argument</code> 名称来参考至同一个 <code>Field</code>。</p><ul><li><p>如：<code>my_rd=%rd</code>，会生成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>a</span><span class=o>-&gt;</span><span class=n>my_rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span> 
</span></span></code></pre></div></li></ul></li></ul></li><li><p><code>args_ref</code> 指定所传入 decode function 的 <code>Argument Set</code>。若没有指定 <code>args_ref</code> 的话，<code>Decodetree</code> 会根据 <code>field_elt</code> 或 <code>field_ref</code> 自动生成一个 <code>Argument Set</code>。此外，一个 <code>Format</code> 最多只能包含一个 <code>args_ref</code>。</p></li></ul></li></ul><p>当 <code>fixedbit_elt</code> 或 <code>field_ref</code> 被定义时，该 <code>Foramt</code> 的所有的 bits 都必须被定义 (可通过 <code>fixedbit_elt</code> 或 <code>.</code> 来定义各个 bits，<code>空格</code>会被忽略)。</p><h3 id=format-示例>Format 示例<a hidden class=anchor aria-hidden=true href=#format-示例>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>@opi    ...... ra:5 lit:8    1 ....... rc:5
</span></span></code></pre></div><p>定义了 <code>op1</code> 这个 <code>Format</code>，其中：</p><ul><li>insn[31:26] 可为 <code>0</code> 或 <code>1</code>。</li><li>insn[25:21] 为 <code>ra</code>。</li><li>insn[20:13] 为 <code>lit</code>。</li><li>insn[12] 固定为 <code>1</code>。</li><li>insn[11:5] 可为 <code>0</code> 或 <code>1</code>。</li><li>insn[4:0] 为 <code>rc</code>。</li></ul><p>此 <code>Format</code> 会生成以下的 decode function：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>lit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ra</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>arg_decode_insn320</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn32_extract_opi</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_decode_insn320</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>ra</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>21</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>lit</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>13</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rc</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由于我们没有指定 <code>args_ref</code>，因此 <code>Decodetree</code> 根据了 <code>field_elt</code> 的定义，自动生成了 <code>arg_decode_insn320</code> 这个 <code>Argument Set</code>。</p><p>以 RISC-V <code>I-type</code> 指令为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl># Fields:
</span></span><span class=line><span class=cl>%rs1       15:5
</span></span><span class=line><span class=cl>%rd        7:5
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># immediates:
</span></span><span class=line><span class=cl>%imm_i    20:s12
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Argment sets:
</span></span><span class=line><span class=cl>&amp;i    imm rs1 rd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>@i       ........ ........ ........ ........ &amp;i      imm=%imm_i     %rs1 %rd
</span></span></code></pre></div><p>定义了 <code>i</code> 这个 <code>Format</code>，其中：</p><ul><li>insn[31:20] 为 <code>imm</code>，且为 符号扩展。</li><li>insn[19:5] 为 <code>rs1</code>。</li><li>insn[11:7] 为 <code>rd</code>。</li></ul><p>此外，我们可以看到：</p><ul><li>此 <code>Format</code> 指定了 <code>Argument Set</code>：<code>&amp;i</code>。 <code>&amp;i</code> 中必须包含所有有用到的 <code>arguments</code> (也就是：<code>imm</code>、<code>rs1</code> 及 <code>rd</code>)</li><li><code>imm</code> 是通过重命名的方式来参考 <code>%imm_i</code> 这个 <code>Field</code>。</li></ul><p>此范例会生成以下的 decode function：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>imm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rs1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>arg_i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn32extract_i</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_i</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>=</span> <span class=nf>sextract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>12</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rs1</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>相比于第一个范例，由于这次我们有指定 <code>args_ref</code>：<code>&amp;i</code>，因此对应的 <code>arg_i</code> 会被传入 decode function。</p><hr><p>回到先前的 RISC-V <code>U-type</code> 指令，我们可以如同 <code>I-type</code> 指令定义其格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl># Fields:
</span></span><span class=line><span class=cl>%rd        7:5
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># immediates:
</span></span><span class=line><span class=cl>%imm_u    12:s20                 !function=ex_shift_12
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Argument sets:
</span></span><span class=line><span class=cl>&amp;u    imm rd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>@u       ....................      ..... ....... &amp;u      imm=%imm_u          %rd
</span></span></code></pre></div><p>定义了 <code>u</code> 这个 <code>Format</code>，其中：</p><ul><li>insn[31:12] 为 <code>imm</code>，且为 符号扩展。</li><li>insn[11:7] 为 <code>rd</code>。</li></ul><p>会生成以下的 decode function：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>imm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>arg_u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn32_extract_u</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_u</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>=</span> <span class=nf>ex_shift_12</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=nf>sextract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>20</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们可以看到：</p><ul><li>此 <code>Format</code> 指定了 <code>Argument Set</code>：<code>&amp;u</code>。 <code>&amp;u</code> 中必须包含所有有用到的 <code>arguments</code> (也就是：<code>imm</code>、<code>rd</code>)</li><li><code>imm</code> 是通过重命名的方式来参考 <code>%imm_u</code> 这个 <code>Field</code>。</li></ul><h2 id=pattern>Pattern<a hidden class=anchor aria-hidden=true href=#pattern>#</a></h2><p><code>Pattern</code> 实际定义了一个指令的 decode 方式。<code>Decodetree</code> 会根据 <code>Patterns</code> 的定义，来动态产生出对应的 <code>switch-case</code> decode 判断分支。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>pat_def      := identifier ( pat_elt )+
</span></span><span class=line><span class=cl>pat_elt      := fixedbit_elt | field_elt | field_ref | args_ref | fmt_ref | const_elt
</span></span><span class=line><span class=cl>fmt_ref      := &#39;@&#39; identifier
</span></span><span class=line><span class=cl>const_elt    := identifier &#39;=&#39; number
</span></span></code></pre></div><p>其语法由用户所定义的 <code>identifier</code>，随后紧接着一个以上的 <code>pat_elt</code>。</p><ul><li><p><code>identifier</code> 可由开发者自订，如：<code>addl_r</code>、<code>addli</code> … 等。</p></li><li><p><code>pat_elt</code> 则可以采用以下不同的语法：</p><ul><li><code>fixedbit_elt</code> 与在 <code>Format</code> 中 <code>fixedbit_elt</code> 的定义相同。</li><li><code>field_elt</code> 与在 <code>Format</code> 中 <code>field_elt</code> 的定义相同。</li><li><code>field_ref</code> 与在 <code>Format</code> 中 <code>field_ref</code> 的定义相同。</li><li><code>args_ref</code> 与在 <code>Format</code> 中 <code>args_ref</code> 的定义相同。</li><li><code>fmt_ref</code> 直接参考一个被定义过的Format。</li><li><code>const_elt</code> 可以直接指定某一个 <code>argument</code> 的值。</li></ul></li></ul><p>由于 <code>Pattern</code> 实际定义了一个指令的 decode 方式，因此<strong>所有的 bits</strong> 及 <strong>arguments (如果有参考 args_ref 的话)</strong> 都必须明确的被定义，如果在搭配了所有的 <code>pat_elt</code> 后还有未定义的 bits 或是 arguments 的话，<code>Decodetree</code> 便会报错。</p><p>此外，<code>Pattern</code> 所产生出来的 decoder，最后还会调用对应的 <code>translator function</code>。<code>translator function</code> 需开发者自行定义。</p><h3 id=pattern-示例>Pattern 示例<a hidden class=anchor aria-hidden=true href=#pattern-示例>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>addl_i   010000 ..... ..... .... 0000000 ..... @opi
</span></span></code></pre></div><p>定义了 <code>addl_i</code> 这个指令的 <code>Pattern</code>，其中：</p><ul><li>insn[31:26] 为 <code>010000</code>。</li><li>insn[11:5] 为 <code>0000000</code>。</li><li>参考了 Format 示例中 定义的 <code>@opi</code> <code>Format</code>。</li><li>由于 <code>Pattern</code> 的<strong>所有 bits</strong> 都必须明确的被定义，因此 <code>@opi</code> 必须包含其余 <code>insn[25:12]</code> 及 <code>insn[4:0]</code> 的格式定义，否则 <code>Decodetree</code> 便会报错。</li></ul><p>最后 <code>addl_i</code> 的 decoder 还会调用 <code>trans_addl_i()</code> 这个 <code>translator function</code>。</p><p>搭配之前介绍的 Fields、Argument Sets 及 Formats，让我们再看几个完整的例子应该会更清楚 <code>Decodetree</code> 是怎产生一个指令的 decoder 的。</p><p>首先是 RISC-V 的 <code>lui</code> 及 <code>auipc</code> 指令：</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F19%2F922be39211d73158159edf9993a2c906.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F19%2F922be39211d73158159edf9993a2c906.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl># Fields:
</span></span><span class=line><span class=cl>%rd        7:5
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># immediates:
</span></span><span class=line><span class=cl>%imm_u    12:s20                 !function=ex_shift_12
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Argument sets:
</span></span><span class=line><span class=cl>&amp;u    imm rd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Formats:
</span></span><span class=line><span class=cl>@u       ....................      ..... ....... &amp;u      imm=%imm_u          %rd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Patterns
</span></span><span class=line><span class=cl>lui      ....................       ..... 0110111 @u
</span></span><span class=line><span class=cl>auipc    ....................       ..... 0010111 @u
</span></span></code></pre></div><p>会产生以下 <code>lui</code> 及 <code>auipc</code> 的 decoder：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>imm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>arg_u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn32_extract_u</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_u</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>=</span> <span class=nf>ex_shift_12</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=nf>sextract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>20</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>decode_insn32</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>arg_u</span> <span class=n>f_u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>decode_insn32_extract_u</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_u</span><span class=p>,</span> <span class=n>insn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>insn</span> <span class=o>&amp;</span> <span class=mh>0x0000007f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mh>0x00000017</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>trans_auipc</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_u</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mh>0x00000037</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>trans_lui</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_u</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>回顾到目前为止所介绍的：</p><ul><li><p><code>Argument Sets</code>：<code>&amp;u</code> 这个 <code>argument set</code> 包含了 <code>imm</code> 及 <code>rd</code> 这两个 <code>arguments</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>imm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>arg_u</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p><code>Fields</code>： <code>imm</code> 及 <code>rd</code> 分别位在 insn[31:12] 及 insn[11:7]，且 <code>imm</code> 为 符号扩展。最后在截取出 <code>imm</code> 的值后，还会调用 <code>ex_shift_12()</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>=</span> <span class=nf>ex_shift_12</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=nf>sextract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>20</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span></code></pre></div></li><li><p><code>Formats</code>：<code>@u</code> 定义了 RISC-V <code>U-type</code> 指令的格式</p><ul><li>参考了 <code>&amp;u</code> 这个 <code>Argument Set</code>，因此 decode function 会传入 <code>arg_u</code> 作为参数。</li><li>insn[31:12] 参考了 <code>imm_u</code> 这个 <code>Field</code> (并重命名为 <code>imm</code>)</li><li>insn[11:7] 参考了 <code>rd</code> 这个 <code>Field</code>。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn32_extract_u</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_u</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>=</span> <span class=nf>ex_shift_12</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=nf>sextract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>20</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p><code>Patterns</code>：</p><ul><li><code>lui</code> 的 <code>opcode</code> (insn[6:0]) 为 <code>0010111</code>，也就是 <code>0x17</code>，在产生出来的 <code>switch-case</code> 中可以看到其对应的 <code>case</code>。</li><li><code>lui</code> 的 decoder 最后调用了 <code>trans_lui()</code>，并传入 <code>DisasContext</code> 及经由 <code>decode_insn32_extract_u()</code> 所解析出来的 <code>arg_u</code>。</li><li><code>auipc</code> 的 <code>opcode</code> (insn[6:0]) 为 <code>0110111</code>，也就是 <code>0x37</code>，在产生出来的 <code>switch-case</code> 中可以看到其对应的 <code>case</code>。</li><li><code>auipc</code> 的 decoder 最后调用了 <code>trans_auipc()</code>，并传入 <code>DisasContext</code> 及经由 <code>decode_insn32_extract_u()</code> 所解析出来的 <code>arg_u</code>。</li><li>P.S. 这边由于 <code>Decodetree</code> 发现 <code>lui</code> 及 <code>auipc</code> 可以共用 <code>decode_insn32_extract_u()</code>，因此将其提到了 <code>switch-case</code> 之外。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>decode_insn32</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>arg_u</span> <span class=n>f_u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>decode_insn32_extract_u</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_u</span><span class=p>,</span> <span class=n>insn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>insn</span> <span class=o>&amp;</span> <span class=mh>0x0000007f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mh>0x00000017</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>trans_auipc</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_u</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mh>0x00000037</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>trans_lui</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_u</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们另外可以发现，<code>Pattern</code> + <code>Format</code> 把所有的 32-bits 都给了明确的定义：</p><ul><li><code>Pattern</code> 定义了 <code>opcode</code> (insn[6:0])。</li><li><code>Format</code> 参考了 <code>imm</code> (insn[31:12]) 及 <code>rd</code> (insn[11:7])。</li></ul><p>如果有任何未明确定义的 bits 的话，<code>Decodetree</code> 便会报错，例如如果我们将 <code>lui</code> 的 <code>opcode</code> 最高 2 个 bits (insn[6:5]) 由 <code>01</code> 改成 <code>..</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>lui      ....................       ..... ..10111 @u
</span></span></code></pre></div><p><code>Decodetree</code> 在解析时，便会报错：</p><blockquote><p>./insn32.decode:17: error: (‘bits left unspecified (0x00000060)’,)</p></blockquote><p><code>Decodetree</code> 提醒我们，insn[6:5] (<code>0x00000060</code>) 尚未给出明确定义，并会显示出其错误的行数。</p><p><code>trans_lui()</code> 和 <code>trans_auipc()</code> 被定义在 <code>target/riscv/insn_trans/trans_rvi.inc.c</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>trans_lui</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_lui</span> <span class=o>*</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>tcg_gen_movi_tl</span><span class=p>(</span><span class=n>cpu_gpr</span><span class=p>[</span><span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span><span class=p>],</span> <span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>trans_auipc</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_auipc</span> <span class=o>*</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>tcg_gen_movi_tl</span><span class=p>(</span><span class=n>cpu_gpr</span><span class=p>[</span><span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span><span class=p>],</span> <span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>+</span> <span class=n>ctx</span><span class=o>-&gt;</span><span class=n>base</span><span class=p>.</span><span class=n>pc_next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到 <code>trans_*()</code> 负责实际指令的业务逻辑及产生对应的 <code>TCG codes</code>。</p></li></ul><p>如同先前所介绍，<code>Patterns</code> 的 <code>pat_elt</code> 也可以采用 <code>field_elt</code> 语法，如 RISC-V 的 <code>fence</code> 指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>fence    ---- pred:4 succ:4 ----- 000 ----- 0001111
</span></span></code></pre></div><ul><li>insn[27:24] 为 <code>pred</code>。</li><li>insn[23:20] 为 <code>succ</code>。</li><li>insn[14:12] 固定为 <code>000</code>。</li><li>insn[6:0] 为 <code>opcode</code> (<code>0001111</code>)。</li><li>没有参考任何的 <code>Format</code>。</li><li>剩下的 insn[31:28]、insn[19:15]、insn[11:7] 被声明为 <code>-</code>，因此就算没有被明确定义也没有关系。</li></ul><p>所生成 <code>fence</code> 的 decoder 如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pred</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>succ</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>arg_decode_insn320</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn32_extract_decode_insn32_Fmt_0</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_decode_insn320</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>pred</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>24</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>succ</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>decode_insn32</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>arg_decode_insn320</span> <span class=n>f_decode_insn320</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>decode_insn32_extract_decode_insn32_Fmt_0</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_decode_insn320</span><span class=p>,</span> <span class=n>insn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>insn</span> <span class=o>&amp;</span> <span class=mh>0x0000707f</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mh>0x0000000f</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>trans_fence</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_decode_insn320</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>值得注意的是，虽然这次我们没有参考任何的 <code>Argument Set</code>，但 <code>Decodetree</code> 还是替我们生成了一个包含 <code>pred</code> 和 <code>succ</code> 的 <code>arg_decode_insn320</code> 。</p><p><code>trans_fence()</code> 同样是被定义在 <code>./target/riscv/insn_trans/trans_rvi.inc.c</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>trans_fence</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_fence</span> <span class=o>*</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=nf>tcg_gen_mb</span><span class=p>(</span><span class=n>TCG_MO_ALL</span> <span class=o>|</span> <span class=n>TCG_BAR_SC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=pattern-groups>Pattern Groups<a hidden class=anchor aria-hidden=true href=#pattern-groups>#</a></h2><p><code>Pattern Groups</code> 由一个以上的 <code>Patterns</code> 所组成，其主要差别是不同 <code>Patterns</code> 之间的 bits 可以 overlap。当同组中有多个 <code>Patterns</code> 时，会依据该组中各 <code>Pattern</code> 的声明顺序依序判断目前的指令是否符合其定义。除此之外，当符合的 <code>Pattern</code> 其 <code>trans_*()</code> 回传值为 <code>false</code> 时，也会被视为<strong>不相符</strong>，而继续判断该组中的下一个 <code>Pattern</code>。因此 <code>Pattern Groups</code> 非常适合将多个相似格式的指令给组成同一个 <code>Pattern Group</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>group    := &#39;{&#39; ( pat_def | group )+ &#39;}&#39;
</span></span></code></pre></div><p>各 <code>Pattern Group</code> 以 <code>{</code> 开头，并以 <code>}</code> 结尾，且允许 <code>nested pattern groups</code> 的存在，其他语法皆与 <code>Pattern</code> 相同。</p><h3 id=pattern-group-示例>Pattern Group 示例<a hidden class=anchor aria-hidden=true href=#pattern-group-示例>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  {
</span></span><span class=line><span class=cl>    nop   000010 ----- ----- 0000 001001 0 00000
</span></span><span class=line><span class=cl>    copy  000010 00000 r1:5  0000 001001 0 rt:5
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>  or      000010 rt2:5 r1:5  cf:4 001001 0 rt:5
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>会产生以下的 decoder：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>insn</span> <span class=o>&amp;</span> <span class=mh>0xfc000fe0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mh>0x08000240</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>insn</span> <span class=o>&amp;</span> <span class=mh>0x0000f000</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0x00000000</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>insn</span> <span class=o>&amp;</span> <span class=mh>0x0000001f</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0x00000000</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>            <span class=nf>extract_decode_Fmt_0</span><span class=p>(</span><span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_decode0</span><span class=p>,</span> <span class=n>insn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>trans_nop</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_decode0</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>((</span><span class=n>insn</span> <span class=o>&amp;</span> <span class=mh>0x03e00000</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0x00000000</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>          <span class=nf>extract_decode_Fmt_1</span><span class=p>(</span><span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_decode1</span><span class=p>,</span> <span class=n>insn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=p>(</span><span class=nf>trans_copy</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_decode1</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				　
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>extract_decode_Fmt_2</span><span class=p>(</span><span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_decode2</span><span class=p>,</span> <span class=n>insn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>trans_or</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_decode2</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当指令的值符合 <code>nop</code> 及 <code>copy</code> 这个内层 <code>Pattern Group</code> 时，会先判断该指令是否符合 <code>nop</code> 指令的定义，且 <code>trans_nop()</code> 的回传值为 <code>true</code>。否则的话，就会继续判断是否符合同组中的 <code>copy</code> 指令。若都不符，就会再判断是否符合外层 <code>Pattern Group</code> 的 <code>or</code> 指令。若仍不符，才会回传 <code>false</code> 表示 decode 失败。</p><p>与单纯使用 <code>Pattern</code> 最大不同的是，当一 <code>Pattern</code> 的 <code>trans_*()</code> 回传值为 <code>false</code> 时，不会直接回传 <code>false</code> (代表 decode 失败)，而是会接续着判断后续的 <code>Patterns</code> 是否相符。</p><p>RISC-V Compressed-Extension 中的 <code>c.ebreak</code>、<code>c.jalr</code>、及 <code>c.add</code> 指令，由于这三个指令的格式非常相似，因此非常适合使用 <code>Pattern Group</code> 来定义：</p><p>RISC-V spec. 中定义：</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F19%2F722c64cc1a321ef23fab81e722a24154.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/%2F2024%2F03%2F19%2F722c64cc1a321ef23fab81e722a24154.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><ul><li><code>C.EBREAK</code>指令与<code>C.ADD</code>指令共享相同的<code>opcode</code>，但是<code>rd</code>和<code>rs2</code>都为<code>zero</code>，因此也可以使用<code>CR</code>格式。</li><li><code>C.JALR</code>指令只有在<code>rs1≠x0</code>时才有效；当<code>rs1=x0</code>时，对应的代码点是<code>C.EBREAK</code>指令。</li><li><code>C.ADD</code>指令只有在<code>rs2≠x0</code>时才有效；当<code>rs2=x0</code>时，对应的代码点是<code>C.JALR</code>和<code>C.EBREAK</code>指令。具有<code>rs2̸=x0</code>和<code>rd=x0</code>的代码点是<code>HINTs</code>。</li></ul><p><code>c.ebreak</code>、<code>c.jalr</code>、<code>c.add</code> 三个指令：</p><ul><li>insn[15:13]、insn[12]、insn[1:0] 的值皆相同。</li><li>当 insn[11:7] 且 insn[6:2] 的值皆为 <code>0</code> (<code>rs1=0</code> 且 <code>rs2=0</code>) 时为 <code>c.ebreak</code> 指令。</li><li>当只有 insn[11:7] 的值为 <code>0</code> (<code>rs1=0</code> 且 <code>rs2≠0</code>) 时为 <code>c.jalr</code> 指令。</li><li>否则为 <code>c.add</code> 指令 (<code>rs1≠x0</code> 且 <code>rs2≠0</code>)。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl># Fields
</span></span><span class=line><span class=cl>%rd        7:5
</span></span><span class=line><span class=cl>%rs2_5     2:5
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Argument Sets
</span></span><span class=line><span class=cl>&amp;r         rd rs1 rs2   !extern
</span></span><span class=line><span class=cl>&amp;i         imm rs1 rd   !extern
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Formats
</span></span><span class=line><span class=cl>@cr        ....  ..... .....  .. &amp;r      rs2=%rs2_5       rs1=%rd     %rd
</span></span><span class=line><span class=cl>@c_jalr    ... . .....  ..... .. &amp;i      imm=0 rs1=%rd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Pattern Groups
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  ebreak          100 1  00000  00000 10
</span></span><span class=line><span class=cl>  jalr            100 1  .....  00000 10 @c_jalr rd=1  # C.JALR
</span></span><span class=line><span class=cl>  add             100 1  .....  ..... 10 @cr
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>所生成的 decoder 如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn16_extract_c_jalr</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_i</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>imm</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rs1</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn16_extract_cr</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_r</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rs2</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rs1</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>rd</span> <span class=o>=</span> <span class=nf>extract32</span><span class=p>(</span><span class=n>insn</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>decode_insn16_extract_decode_insn16_Fmt_2</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=n>arg_decode_insn162</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>decode_insn16</span><span class=p>(</span><span class=n>DisasContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>insn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>arg_decode_insn162</span> <span class=n>f_decode_insn162</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>arg_i</span> <span class=n>f_i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>arg_r</span> <span class=n>f_r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>insn</span> <span class=o>&amp;</span> <span class=mh>0x0000f003</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mh>0x00009002</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>insn</span> <span class=o>&amp;</span> <span class=mh>0x00000ffc</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0x00000000</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>            <span class=nf>decode_insn16_extract_decode_insn16_Fmt_2</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_decode_insn162</span><span class=p>,</span> <span class=n>insn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>trans_ebreak</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_decode_insn162</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>insn</span> <span class=o>&amp;</span> <span class=mh>0x0000007c</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0x00000000</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>            <span class=nf>decode_insn16_extract_c_jalr</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_i</span><span class=p>,</span> <span class=n>insn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>u</span><span class=p>.</span><span class=n>f_i</span><span class=p>.</span><span class=n>rd</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>trans_jalr</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_i</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=nf>decode_insn16_extract_cr</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_r</span><span class=p>,</span> <span class=n>insn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>trans_add</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>.</span><span class=n>f_r</span><span class=p>))</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当指令格式符合 <code>c.ebreak</code>、<code>c.jalr</code>、<code>c.add</code> 的 <code>Pattern Group</code> 时，会依序判断该指令是否符合 <code>c.ebreak</code>、<code>c.jalr</code>、<code>c.add</code> 的定义以及其对应的 <code>trans_*()</code>。</p><p>另外值得一提的是，在 <code>c_jalr</code> <code>Format</code> 和 <code>jalr</code> <code>Pattern</code> 中有分别指定其 <code>imm</code> 及 <code>rd</code> 的值为 <code>0</code>，所生成的 codes 也会分别在对应的地方将该值设为 <code>0</code> (见 codes 注解说明)。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>以上就是 <code>Decodetree</code> 的语法说明。通过 <code>Decodetree</code>，我们不用再像以前以样写一大包的 <code>switch-case</code> 来 decode 指令。将不同类型的指令写至不同的 decode 档，不仅方便维护，阅读起来也更为容易。</p><hr><ul><li><code>--translate</code>：translator function 的 prefix，默认为 <code>trans</code>。一旦指定后，translator function 的 scope 就不会再是 <code>static</code>。</li><li><code>--decode</code>：decode function 的 prefix，默认为 <code>decode</code>，且 scope 为 <code>static</code>。一旦指定后，decode function 的 scope 就不会再是 <code>static</code>。</li><li><code>--static-decode</code>：如同 <code>--decode</code>，不过 decode function 的 scope 仍维持为 <code>static</code>。</li><li><code>-o</code> / <code>--output</code>：指定生成的 decoder <code>.c</code> 档路径。</li><li><code>-w</code> / <code>--insnwidth</code>：指令长度，eg：<code>32</code> or <code>16</code>，默认为 <code>32</code>。</li><li><code>--varinsnwidth</code>：指令为不定长度。</li><li><code>最后一个参数</code>为输入的 decode 档路径。</li></ul><p>运行范例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>./decodetree.py -o target/riscv/decode_insn16.inc.c --static-decode decode_insn16 \
</span></span><span class=line><span class=cl>    -w 16 ./insn16.decode
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static inline int32_t sextract32(uint32_t value, int start, int length){    assert(start &gt;= 0 &amp;&amp; length &gt; 0 &amp;&amp; length &lt;= 32 - start);        return ((int32_t)(value &lt;&lt; (32 - length - start))) &gt;&gt; (32 - length);}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://lifeislife.cn/tags/qemu/>QEMU</a></li><li><a href=https://lifeislife.cn/tags/tcg/>TCG</a></li><li><a href=https://lifeislife.cn/tags/decodetree/>Decodetree</a></li></ul><nav class=paginav><a class=prev href=https://lifeislife.cn/posts/helloworld/><span class=title>« 上一页</span><br><span>HelloWorld</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU Decodetree详解 on x" href="https://x.com/intent/tweet/?text=QEMU%20Decodetree%e8%af%a6%e8%a7%a3&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu-decodetree%25E8%25AF%25A6%25E8%25A7%25A3%2f&amp;hashtags=QEMU%2cTCG%2cDecodetree"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU Decodetree详解 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu-decodetree%25E8%25AF%25A6%25E8%25A7%25A3%2f&amp;title=QEMU%20Decodetree%e8%af%a6%e8%a7%a3&amp;summary=QEMU%20Decodetree%e8%af%a6%e8%a7%a3&amp;source=https%3a%2f%2flifeislife.cn%2fposts%2fqemu-decodetree%25E8%25AF%25A6%25E8%25A7%25A3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU Decodetree详解 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu-decodetree%25E8%25AF%25A6%25E8%25A7%25A3%2f&title=QEMU%20Decodetree%e8%af%a6%e8%a7%a3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU Decodetree详解 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifeislife.cn%2fposts%2fqemu-decodetree%25E8%25AF%25A6%25E8%25A7%25A3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU Decodetree详解 on whatsapp" href="https://api.whatsapp.com/send?text=QEMU%20Decodetree%e8%af%a6%e8%a7%a3%20-%20https%3a%2f%2flifeislife.cn%2fposts%2fqemu-decodetree%25E8%25AF%25A6%25E8%25A7%25A3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU Decodetree详解 on telegram" href="https://telegram.me/share/url?text=QEMU%20Decodetree%e8%af%a6%e8%a7%a3&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu-decodetree%25E8%25AF%25A6%25E8%25A7%25A3%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU Decodetree详解 on ycombinator" href="https://news.ycombinator.com/submitlink?t=QEMU%20Decodetree%e8%af%a6%e8%a7%a3&u=https%3a%2f%2flifeislife.cn%2fposts%2fqemu-decodetree%25E8%25AF%25A6%25E8%25A7%25A3%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://lifeislife-1.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://lifeislife.cn/>夜云泊</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>