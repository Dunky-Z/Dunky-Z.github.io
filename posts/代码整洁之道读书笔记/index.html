<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《代码整洁之道》读书笔记 | 夜云泊</title>
<meta name=keywords content><meta name=description content="代码整洁之道 整洁代码 整洁之道 代码是我们最终用来表达需求的那种语言，代码永存； 时时保持代码整洁，稍后等于永不（Later equals never）； 整洁代"><meta name=author content="Nic"><link rel=canonical href=https://lifeislife.cn/posts/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.ac74316738ec9be850f385073ae1b0b3c442da15f0a57cb0b89434683d014d90.css integrity="sha256-rHQxZzjsm+hQ84UHOuGws8RC2hXwpXywuJQ0aD0BTZA=" rel="preload stylesheet" as=style><link rel=icon href=https://lifeislife.cn/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lifeislife.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lifeislife.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://lifeislife.cn/apple-touch-icon.png><link rel=mask-icon href=https://lifeislife.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lifeislife.cn/posts/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PS8L2EEEPR")}</script><meta property="og:title" content="《代码整洁之道》读书笔记"><meta property="og:description" content="代码整洁之道 整洁代码 整洁之道 代码是我们最终用来表达需求的那种语言，代码永存； 时时保持代码整洁，稍后等于永不（Later equals never）； 整洁代"><meta property="og:type" content="article"><meta property="og:url" content="https://lifeislife.cn/posts/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-29T23:20:18+00:00"><meta property="article:modified_time" content="2021-11-29T23:20:18+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《代码整洁之道》读书笔记"><meta name=twitter:description content="代码整洁之道 整洁代码 整洁之道 代码是我们最终用来表达需求的那种语言，代码永存； 时时保持代码整洁，稍后等于永不（Later equals never）； 整洁代"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifeislife.cn/posts/"},{"@type":"ListItem","position":2,"name":"《代码整洁之道》读书笔记","item":"https://lifeislife.cn/posts/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《代码整洁之道》读书笔记","name":"《代码整洁之道》读书笔记","description":"代码整洁之道 整洁代码 整洁之道 代码是我们最终用来表达需求的那种语言，代码永存； 时时保持代码整洁，稍后等于永不（Later equals never）； 整洁代","keywords":[],"articleBody":"代码整洁之道 整洁代码 整洁之道 代码是我们最终用来表达需求的那种语言，代码永存；\n时时保持代码整洁，稍后等于永不（Later equals never）；\n整洁代码力求集中，每个函数、每个类和每个模块都全神贯注于一件事；\n整洁代码简单直接，从不隐藏设计者的意图；\n整洁代码应当有单元测试和验收测试。它使用有意义的命名，代码通过其字面表达含义；\n消除重复代码，提高代码表达力。\n有意义的命名 避免误导 “一组账号\"别用accountList表示，List对程序员有特殊含义，可以用 accountGroup、bunchOfAccounts、甚至是accounts；\n不使用区别较小的名称，ZYXControllerForEfficientHandlingOfStrings和 ZYXControllerForEfficientStorageOfStrings难以辨别；\n不使用小写 l、大写 O 作变量名，看起来像常量 1、0。\n做有意义的区分 不以数字系列命名(a1、a2、a3)，按照真实含义命名；\nProduct/ProductInfo/ProductData 意思无区别，只统一用一个；\n别写冗余的名字，变量名别带variable、表名别带table。\n使用读得出来的名称 genymdhms（生成日期，年、月、日、时、分、秒）肯定不如generation timestamp（生成时间戳）方便交流。 使用可搜索的名称 单字母名称和数字常量很难在上下文中找出。名称长短应与其作用域大小相对应，越是频繁出现的变量名称得越容易搜索 (越长)。 命名时避免使用编码 把类型和作用域编码进名称里增加了解码负担。意味着新人除了了解代码逻辑之外，还需要学习这种编码语言；\n别使用匈牙利语标记法(格式：[Prefix]-BaseTag-Name 其中 BaseTag 是数据类型的缩写，Name 是变量名字)，纯属多余。例如，szCmdLine的前缀sz表示“以零结束的字符串”；\n不必用m_前缀来表明成员变量；\n接口和实现别在名称中编码。接口名IShapeFactory的前导\"I\"是废话。如果接口和实现必须选一个编码，宁可选实现，ShapeFactoryImp都比对接口名称编码来的好。\n避免思维映射 不应当让读者在脑中把你的名称翻译为他们熟知的名称。例如，循环计数器自然有可能被命名为i或j或k，但千万别用字母l；\n专业程序员了解，明确是王道，编写能方便他人理解的代码。\n类名、方法名 类名应当是名词或名词短语，方法名应当是动词或动词短语。 命名不要耍宝幽默 言到意到，意到言到，不要在命名上展示幽默感。 每个概念用一个词 fetch、retrieve、get约定一个一直用即可。 尽管使用计算机科学术语 只有程序员才会读你的代码，不需要按照问题所在邻域取名称。 别用双关语 add方法一般语义是：根据两个值获得一个新的值。如果要把单个值加入到某个集合，用insert或append命名更好，这里用add就是双关语了。 添加有意义的语境 很少有名称能自我说明，需要用良好命名的类、函数、或者命名空间来放置名称，给读者提供语境，如果做不到的话，给名称添加前缀就是最后一招了。 函数 越短越好 短小，20 行封顶；\nif/else/while语句的代码块应该只有一行，该行应该是一个函数调用语句；\n函数的缩进层级不应该多于一层或两层。\n一个函数只做一件事 如果函数只是做了该函数名下同一抽象层上的步骤，则函数只做了一件事；\n要判断函数是否不止做了一件事，就是要看是否能再拆出一个函数；\n每个函数一个抽象层级 向下规则：让代码拥有自顶向下的阅读顺序。每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能循抽象层级向下阅读了。 switch 语句 把 switch 埋在较低的抽象层级，一般可以放在抽象工厂底下，用于创建多态对象。 使用描述性的名称 函数越短小、功能越集中，就越便于取个好名字；\n别害怕长名称，长而具有描述性的名称，要比短而令人费解的名称好，要比描述性的长注释好；\n别害怕花时间取名字。\n函数参数 参数越少越好，0 参数最好，尽量避免用三个以上参数；\n参数越多，编写组合参数的测试用例就越困难；\n别用标识参数，向函数传入bool值是不好的，这意味着函数不止做一件事。可以将此函数拆成两个；\n如果函数需要两个、三个或者三个以上参数，就说明其中一些参数应该封装成类了；\n将参数的顺序编码进函数名，减轻记忆参数顺序的负担，例如 assertExpectedEqualsActual(expected, actual)。\n副作用 (函数在正常工作任务之外对外部环境所施加的影响) 检查密码并且初始化session的方法命名为checkPasswordAndInitializeSession而非 checkPassword，即使违反单一职责原则也不要有副作用；\n避免使用\"输出参数”，如果函数必须修改某种状态，就修改所属对象的状态吧。\n设置 (写) 和查询 (读) 分离 ```C if(set(\"username\", \"unclebob\")) { ... } ``` 含义模糊不清。应该改为: ```c if (attributeExists(\"username\")) { setAttribute(\"username\", \"unclebob\"); } ``` 使用异常代替返回错误码 返回错误码会要求调用者立刻处理错误，从而引起深层次的嵌套结构；\nif (deletePate(page) == E_OK) { if (xxx() == E_OK) { if (yyy() == E_OK) { log(); } else { log(); } } else { log(); } } else { log(); } 所以需要用try catch异常机制；\ntry { deletePage(); xxx(); yyy(); zzz(); } catch (Exception e) { log(e-\u003egetMessage()); } try/catch代码块丑陋不堪，所以最好把try和 catch代码块的主体抽离出来，单独形成函数。\ntry { do(); } catch (Exception e) { handle(); } 不要写重复代码 重复是软件中一切邪恶的根源。当算法改变时需要修改多处地方。 结构化编程 只要函数保持短小，偶尔出现的return、break、continue语句没有坏处，甚至还比单入单出原则更具有表达力。goto只有在大函数里才有道理，应该尽量避免使用。\n并不需要一开始就按照这些规则写函数，没人做得到。想些什么就写什么，然后再打磨这些代码，按照这些规则组装函数。\n注释 若编程语言足够有表现力，我们就不需要注释；\n注释总是一种失败，因为我们无法找到不用注释就能表达自我的方法；\n代码在演化，注释却不总是随之变动，会变得越来越不准确。\n用代码来阐述 创建一个与注释所言同一事物的函数即可，\n// check to see if the employee is eligible for full benefits if ((employee.falgs \u0026 HOURLY_FLAG) \u0026\u0026 (employee.age \u003e 65)) 应替换为\nif (employee.isEligibleForFullBenefits()) 好注释 法律信息，并且只要有可能就指向标准许可或者外部文档，而不是放全文；\n提供基本信息，如解释某个抽象方法的返回值；\n对意图的解释，反应了作者某个决定后面的意图；\n阐释。把某些晦涩的参数或者返回值的意义翻译成可读的形式(更好的方法是让它们自身变得足够清晰，但是类似标准库的代码我们无法修改)；\nif (b.compareTo(a) == 1) //b \u003e a 警示。// don't run unless you have some time to kill；\nTODO注释；\n放大 一些看似不合理之物的重要性。\n坏注释 自言自语；\n多余的注释。把逻辑在注释里写一遍不能比代码提供更多信息，读它不比读代码简单。一目了然的成员变量别加注释，显得很多余；\n误导性注释；\n遵循规矩的注释。每个函数都加注释、每个变量都加注释是愚蠢的；\n日志式注释。有了代码版本控制工具，不必在文件开头维护修改时间、修改人这类日志式的注释；\n能用函数或者变量表示就别用注释；\n// does the module from the global list // depend on the subsystem we are part of? if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem()) 可以改为：\nArrayList moduleDependees = smodule.getDependSubsystems(); String ourSubSystem = subSysMod.getSubSystem(); if (moduleDependees.contains(ourSubSystem)) 位置标记。标记多了会被我们忽略掉；\n///////////////////// Actions //////////////////////////\n右括号注释；\ntry { while () { if () { ... } // if ... } // while ... } // try 如果你想标记右括号，其实应该做的是缩短函数\n署名 /* add by rick */ 源代码控制工具会记住你，署名注释跟不上代码的演变；\n注释掉的代码。会导致看到这段代码其他人不敢删除，使用版本控制系统，可以大胆删除需要注释的代码；\n信息过多。别在注释中添加有趣的历史话题或者无关的细节；\n没解释清楚的注释。注释的作用是解释未能自行解释的代码，如果注释本身还需要解释就太遗憾了；\n短函数的函数头注释。为短函数选个好名字比函数头注释要好；\n非公共API函数的javadoc/phpdoc注释。\n格式 垂直格式 短文件比长文件更易于理解。平均200行，最多不超过500行的单个文件可以构造出色的系统；\n像报纸一样排版，由略及详，层层递进；\n区隔: 封包声明、导入声明、每个函数之间，都用空白行分隔开，空白行下面标识着新的独立概念，表示一个思路的开始\n靠近: 紧密相关的代码应该互相靠近，例如一个类里的属性之间别用空白行隔开；\npublic class ReporterConfig { //The class name of the reporter listener private String m_className; //The properties of the reporter listener private List\u003cProperty\u003e m_properties = new ArrayList\u003cProperty\u003e(); public void addProperty(Property property) { m_properties.add(property); } } ///////////////////////对比//////////////////////////////////// public class ReporterConfig { private String m_className; private List\u003cProperty\u003e m_properties = new ArrayList\u003cProperty\u003e(); public void addProperty(Property property) { m_properties.add(property); } } 变量声明应尽可能靠近其使用位置：循环中的控制变量应该总是在循环语句中声明；\n成员变量应该放在类的顶部声明，不要四处放置；\n如果某个函数调用了另外一个，就应该把它们放在一起。我们希望底层细节最后展现出来，不用沉溺于细节，所以调用者尽可能放在被调用者之上；\n执行同一基础任务的几个函数应该放在一起。\n水平格式 一行代码不必死守80字符的上限，偶尔到达100字符不超过120字符即可；\n区隔与靠近: 空格强调左右两边的分割。赋值运算符两边加空格，函数名与左圆括号之间不加空格，乘法运算符在与加减法运算符组合时不用加空格(a*b - c)；\n不必水平对齐。例如声明一堆成员变量时，各行不用每一个单词都对齐，代码自动格式化工具通常会把这类对齐消除掉；\npublic class　FitNesseExpediter implements ResponseSender { private　Socket　socket; private　InputStream　input; private　OutputStream　output; private　Request　request; }　短小的if、while、函数里最好也不要违反缩进规则，不要这样:if (xx == yy) z = 1；\nwhile语句为空，最好分行写分号；\nwhile(1) ; 团队规则 团队绝对不要用各种不同的风格来编写源代码，这样会增加其复杂度。 对象和数据结构 数据抽象 对象：暴露行为 (接口),隐藏数据 (私有变量) ； 数据结构：没有明显的行为 (接口),暴露数据。如DTO(Data Transfer Objects)、Entity； 数据，对象的反对称性 使用数据结构便于在不改动现在数据结构的前提下添加新函数；使用对象便于在不改动既有函数的前提下添加新类；\n使用数据结构难以添加新数据结构，因为必须修改所有函数；使用对象难以添加新函数，因为必须修改所有类；\n万物皆对象只是个传说，有时候我们也会在简单数据结构上做一些过程式的操作。\nLaw of Demeter 模块不应该了解它所操作对象的内部情形；\nclass C的方法f只应该调用以下对象的方法：\nC\n在方法f里创建的对象\n作为参数传递给方法f的对象\nC持有的对象\n方法不应调用 由任何函数返回的对象 的方法。下面的代码违反了 demeter 定律：\nfinal String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。\n错误处理 错误处理很重要，但是不能凌乱到打乱代码逻辑。 使用异常而不是返回错误码 如果使用错误码，调用者必须在函数返回时立刻处理错误，但这很容易被我们忘记；\n错误码通常会导致嵌套if else。\n先写 try-catch 语句 当编写可能会抛异常的代码时，先写好try-catch再往里堆逻辑。 在 catch 里尽可能的记录 在catch里尽可能的记录错误信息，记录失败的操作以及失败的类型 依调用者定义异常类 对错误分类有很多方式。可以依其来源分类：是来自组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？ 别返回 null 值 返回null值只要一处没检查null，应用程序就会失败；\n当想返回null值的时候，可以试试抛出异常，或者返回特例模式的对象。\n别传递 null 值 在方法中传递null值是一种糟糕的做法，应该尽量避免；\n在方法里用if或assert过滤null值参数，但是还是会出现运行时错误，没有良好的办法对付调动者意外传入的null值，恰当的做法就是禁止传入null值。\n边界 将第三方代码干净利落地整合进自己的代码中 避免公共 API 返回边界接口，或者将边界接口作为参数传递给 API。将边界保留在近亲类中；\n不要在生产代码中试验新东西，而是编写测试来理解第三方代码；\n避免我们的代码过多地了解第三方代码中的特定信息。\n学习性测试是一种精确试验，帮助我们增进对 API 的理解。\n单元测试 TDD(Test-driven development) 三定律 First Law: You may not write production code until you have written a failing unit test.\nSecond Law: You may not write more of a unit test than is sufficient to fail, and not compiling is failing.\nThird Law: You may not write more production code than is sufficient to pass the currently failing test.\n保持测试整洁 脏测试等同于没测试，测试代码越脏生产代码越难修改；\n测试代码和生产代码一样重要；\n整洁的测试代码最应具有的要素是：整洁性。测试代码中不要有大量重复代码的调用。\n每个测试一个断言 每个测试函数有且仅有一个断言语句；\n每个测试函数中只测试一个概念。\n整洁的测试依赖于 FIRST 规则 fast: 测试代码应该能够快速运行，因为我们需要频繁运行它；\nindependent: 测试应该相互独立，某个测试不应该依赖上一个测试的结果，测试可以以任何顺序进行；\nrepeatable: 测试应可以在任何环境中通过；\nself-validating: 测试应该有bool值输出，不应通过查看日志来确认测试结果，不应手工对比两个文本文件确认测试结果；\ntimely: 及时编写测试代码。单元测试应该在生产代码之前编写，否则生产代码会变得难以测试。\n类 类的组织 以下针对 JAVA 语言，其他语言类似，变量在前，方法在后，公有在前，私有在后。\n公共静态常量\n私有静态变量\n私有实体变量\n公共函数\n私有工具函数\n如果测试需要调用一个函数或变量，可以设为保护类型。\n类应该短小 对于函数我们计算代码行数衡量大小，对于类我们使用权责来衡量；\n类的名称应当描述其权责。类的命名是判断类长度的第一个手段，如果无法为某个类命以准确的名称，这个类就太长了。类名包含模糊的词汇，如Processor、Manager、Super，这种现象就说明有不恰当的权责聚集情况；\n单一权责原则（Single Responsibility Principle，SRP）: 类或者模块应该有一个权责——只有一条修改的理由 (A class should have only one reason to change.)；\n系统应该由许多短小的类而不是少量巨大的类组成；\n类应该只有少量的实体变量，如果一个类中每个实体变量都被每个方法所使用，则说明该类具有最大的内聚性。创建最大化的内聚类不太现实，但是应该以高内聚为目标，内聚性越高说明类中的方法和变量互相依赖、互相结合形成一个逻辑整体；\n保持内聚性就会得到许多短小的类。如果你想把一个大函数的某一小部分拆解成单独的函数，拆解出的函数使用了大函数中的 4 个变量，不必将 4 个变量作为参数传递到新函数里，仅需将这 4 个变量提升为大函数所在类的实体变量，但是这么做却因为实体变量的增多而丧失了类的内聚性，更好多做法是让这 4 个变量拆出来，拥有自己的类。将大函数拆解成小函数往往是将类拆分为小类的时机。\n为了修改而组织 类应当对扩展开放，对修改封闭 (开放闭合原则)；\n在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。\n系统 将系统的构造与使用分开 软件系统应将起始过程和之后的运行逻辑分开。 分解 main 将全部构造过程搬迁到 main或者被称之为main的模块中，涉及系统其余部分时，假设所有对象都已经正确构造；\n依赖注入 (DI)，控制反转 (IoC) 是分离构造与使用的强大机制。\n迭代 表达力 作者把代码写的越清晰，其他人理解代码就越快；\n太多时候我们深入于要解决的问题中，写出能工作的代码之后，就转移到下一个问题上，没有下足功夫调整代码让后来者易于阅读。多少尊重一下我们的手艺，花一点点时间在每个函数和类上。\n尽可能少的类和方法 为了保持类和函数的短小，我们可能会早出太多细小的类和方法；\n类和方法数量太多，有时是由毫无意义的教条主义导致的。\n以上 4 条规则优先级依次递减。重要的是测试、消除重复、表达意图 并发编程 为什么要并发编程 并发总能改进性能；\n编写并发程序无需修改设计；\n在采用Web或EJB容器的时候，理解并发问题并不重要。\n防御并发代码问题的原则与技巧 遵循单一职责原则。分离并发代码与非并发代码；\n限制临界区数量、限制对共享数据的访问；\n避免使用共享数据，使用对象的副本；\n线程尽可能地独立，不与其他线程共享数据。\n","wordCount":"6265","inLanguage":"zh","datePublished":"2021-11-29T23:20:18Z","dateModified":"2021-11-29T23:20:18Z","author":{"@type":"Person","name":"Nic"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifeislife.cn/posts/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"夜云泊","logo":{"@type":"ImageObject","url":"https://lifeislife.cn/assets/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script defer src=/static/fontawesome/fontawesome-all.js></script><header class=header><nav class=nav><div class=logo><a href=https://lifeislife.cn/ accesskey=h title="夜云泊 (Alt + H)">夜云泊</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lifeislife.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://lifeislife.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://lifeislife.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://lifeislife.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://www.travellings.cn/go.html title=开往><span><i class='fa-solid fa-train-subway'></i>开往</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lifeislife.cn/>主页</a>&nbsp;»&nbsp;<a href=https://lifeislife.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">《代码整洁之道》读书笔记</h1><div class=post-meta><span title='2021-11-29 23:20:18 +0000 UTC'>十一月 29, 2021</span>&nbsp;·&nbsp;13 分钟&nbsp;·&nbsp;6265 字&nbsp;·&nbsp;Nic</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#整洁代码>整洁代码</a><ul><li><a href=#整洁之道>整洁之道</a></li></ul></li><li><a href=#有意义的命名>有意义的命名</a><ul><li><a href=#避免误导>避免误导</a></li><li><a href=#做有意义的区分>做有意义的区分</a></li><li><a href=#使用读得出来的名称>使用读得出来的名称</a></li><li><a href=#使用可搜索的名称>使用可搜索的名称</a></li><li><a href=#命名时避免使用编码>命名时避免使用编码</a></li><li><a href=#避免思维映射>避免思维映射</a></li><li><a href=#类名方法名>类名、方法名</a></li><li><a href=#命名不要耍宝幽默>命名不要耍宝幽默</a></li><li><a href=#每个概念用一个词>每个概念用一个词</a></li><li><a href=#尽管使用计算机科学术语>尽管使用计算机科学术语</a></li><li><a href=#别用双关语>别用双关语</a></li><li><a href=#添加有意义的语境>添加有意义的语境</a></li></ul></li><li><a href=#函数>函数</a><ul><li><a href=#越短越好>越短越好</a></li><li><a href=#一个函数只做一件事>一个函数只做一件事</a></li><li><a href=#每个函数一个抽象层级>每个函数一个抽象层级</a></li><li><a href=#switch-语句>switch 语句</a></li><li><a href=#使用描述性的名称>使用描述性的名称</a></li><li><a href=#函数参数>函数参数</a></li><li><a href=#副作用-函数在正常工作任务之外对外部环境所施加的影响>副作用 (函数在正常工作任务之外对外部环境所施加的影响)</a></li><li><a href=#设置-写-和查询-读-分离>设置 (写) 和查询 (读) 分离</a></li><li><a href=#使用异常代替返回错误码>使用异常代替返回错误码</a></li><li><a href=#不要写重复代码>不要写重复代码</a></li><li><a href=#结构化编程>结构化编程</a></li></ul></li><li><a href=#注释>注释</a><ul><li><a href=#用代码来阐述>用代码来阐述</a></li><li><a href=#好注释>好注释</a></li><li><a href=#坏注释>坏注释</a></li></ul></li><li><a href=#格式>格式</a><ul><li><a href=#垂直格式>垂直格式</a></li><li><a href=#水平格式>水平格式</a></li><li><a href=#团队规则>团队规则</a></li></ul></li><li><a href=#对象和数据结构>对象和数据结构</a><ul><li><a href=#数据抽象>数据抽象</a></li><li><a href=#数据对象的反对称性>数据，对象的反对称性</a></li><li><a href=#law-of-demeter>Law of Demeter</a></li><li><a href=#错误处理>错误处理</a></li><li><a href=#使用异常而不是返回错误码>使用异常而不是返回错误码</a></li><li><a href=#先写-try-catch-语句>先写 try-catch 语句</a></li><li><a href=#在-catch-里尽可能的记录>在 catch 里尽可能的记录</a></li><li><a href=#依调用者定义异常类>依调用者定义异常类</a></li><li><a href=#别返回-null-值>别返回 null 值</a></li><li><a href=#别传递-null-值>别传递 null 值</a></li></ul></li><li><a href=#边界>边界</a><ul><li><a href=#将第三方代码干净利落地整合进自己的代码中>将第三方代码干净利落地整合进自己的代码中</a></li></ul></li><li><a href=#单元测试>单元测试</a><ul><li><a href=#tddtest-driven-development-三定律>TDD(Test-driven development) 三定律</a></li><li><a href=#保持测试整洁>保持测试整洁</a></li><li><a href=#每个测试一个断言>每个测试一个断言</a></li><li><a href=#整洁的测试依赖于-first-规则>整洁的测试依赖于 FIRST 规则</a></li></ul></li><li><a href=#类>类</a><ul><li><a href=#类的组织>类的组织</a></li><li><a href=#类应该短小>类应该短小</a></li><li><a href=#为了修改而组织>为了修改而组织</a></li></ul></li><li><a href=#系统>系统</a><ul><li><a href=#将系统的构造与使用分开>将系统的构造与使用分开</a></li><li><a href=#分解-main>分解 main</a></li></ul></li><li><a href=#迭代>迭代</a><ul><li><a href=#表达力>表达力</a></li><li><a href=#尽可能少的类和方法>尽可能少的类和方法</a></li><li><a href=#以上-4-条规则优先级依次递减重要的是测试消除重复表达意图>以上 4 条规则优先级依次递减。重要的是测试、消除重复、表达意图</a></li></ul></li><li><a href=#并发编程>并发编程</a><ul><li><a href=#为什么要并发编程>为什么要并发编程</a></li><li><a href=#防御并发代码问题的原则与技巧>防御并发代码问题的原则与技巧</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=代码整洁之道>代码整洁之道<a hidden class=anchor aria-hidden=true href=#代码整洁之道>#</a></h1><h2 id=整洁代码>整洁代码<a hidden class=anchor aria-hidden=true href=#整洁代码>#</a></h2><h3 id=整洁之道>整洁之道<a hidden class=anchor aria-hidden=true href=#整洁之道>#</a></h3><ul><li><p>代码是我们最终用来表达需求的那种语言，代码永存；</p></li><li><p>时时保持代码整洁，稍后等于永不（<strong>Later equals never</strong>）；</p></li><li><p>整洁代码力求集中，每个函数、每个类和每个模块都全神贯注于一件事；</p></li><li><p>整洁代码简单直接，从不隐藏设计者的意图；</p></li><li><p>整洁代码应当有单元测试和验收测试。它使用有意义的命名，代码通过其字面表达含义；</p></li><li><p>消除重复代码，提高代码表达力。</p></li></ul><h2 id=有意义的命名>有意义的命名<a hidden class=anchor aria-hidden=true href=#有意义的命名>#</a></h2><h3 id=避免误导>避免误导<a hidden class=anchor aria-hidden=true href=#避免误导>#</a></h3><ul><li><p>&ldquo;一组账号"别用<code>accountList</code>表示，<code>List</code>对程序员有特殊含义，可以用 <code>accountGroup</code>、<code>bunchOfAccounts</code>、甚至是<code>accounts</code>；</p></li><li><p><strong>不使用区别较小的名称</strong>，<code>ZYXControllerForEfficientHandlingOfStrings</code>和 <code>ZYXControllerForEfficientStorageOfStrings</code>难以辨别；</p></li><li><p>不使用小写 l、大写 O 作变量名，看起来像常量 1、0。</p></li></ul><h3 id=做有意义的区分>做有意义的区分<a hidden class=anchor aria-hidden=true href=#做有意义的区分>#</a></h3><ul><li><p><strong>不以数字系列命名</strong>(a1、a2、a3)，按照真实含义命名；</p></li><li><p><strong><code>Product/ProductInfo/ProductData</code></strong> 意思无区别，只统一用一个；</p></li><li><p>别写冗余的名字，变量名别带<code>variable</code>、表名别带<code>table</code>。</p></li></ul><h3 id=使用读得出来的名称>使用读得出来的名称<a hidden class=anchor aria-hidden=true href=#使用读得出来的名称>#</a></h3><ul><li><code>genymdhms</code>（生成日期，年、月、日、时、分、秒）肯定不如<code>generation timestamp</code>（生成时间戳）方便交流。</li></ul><h3 id=使用可搜索的名称>使用可搜索的名称<a hidden class=anchor aria-hidden=true href=#使用可搜索的名称>#</a></h3><ul><li>单字母名称和数字常量很难在上下文中找出。名称长短应与其作用域大小相对应，越是频繁出现的变量名称得越容易搜索 (越长)。</li></ul><h3 id=命名时避免使用编码>命名时避免使用编码<a hidden class=anchor aria-hidden=true href=#命名时避免使用编码>#</a></h3><ul><li><p>把类型和作用域编码进名称里增加了解码负担。意味着新人除了了解代码逻辑之外，还需要学习这种<strong>编码语言</strong>；</p></li><li><p>别使用<strong>匈牙利语标记法</strong>(格式：<strong>[Prefix]-BaseTag-Name</strong> 其中 BaseTag 是数据类型的缩写，Name 是变量名字)，纯属多余。例如，<code>szCmdLine</code>的前缀<code>sz</code>表示“以零结束的字符串”；</p></li><li><p>不必用<code>m_</code>前缀来表明成员变量；</p></li><li><p>接口和实现别在名称中编码。接口名<code>IShapeFactory</code>的<strong>前导"I"是废话</strong>。如果接口和实现必须选一个编码，宁可选实现，<code>ShapeFactoryImp</code>都比对接口名称编码来的好。</p></li></ul><h3 id=避免思维映射>避免思维映射<a hidden class=anchor aria-hidden=true href=#避免思维映射>#</a></h3><ul><li><p>不应当让读者在脑中把你的名称翻译为他们熟知的名称。例如，循环计数器自然有可能被命名为<code>i</code>或<code>j</code>或<code>k</code>，但千万别用字母<code>l</code>；</p></li><li><p>专业程序员了解，<strong>明确是王道</strong>，编写能方便他人理解的代码。</p></li></ul><h3 id=类名方法名>类名、方法名<a hidden class=anchor aria-hidden=true href=#类名方法名>#</a></h3><ul><li><strong>类名应当是名词</strong>或名词短语，<strong>方法名应当是动词</strong>或动词短语。</li></ul><h3 id=命名不要耍宝幽默>命名不要耍宝幽默<a hidden class=anchor aria-hidden=true href=#命名不要耍宝幽默>#</a></h3><ul><li>言到意到，意到言到，不要在命名上展示幽默感。</li></ul><h3 id=每个概念用一个词>每个概念用一个词<a hidden class=anchor aria-hidden=true href=#每个概念用一个词>#</a></h3><ul><li><code>fetch</code>、<code>retrieve</code>、<code>get</code>约定一个一直用即可。</li></ul><h3 id=尽管使用计算机科学术语>尽管使用计算机科学术语<a hidden class=anchor aria-hidden=true href=#尽管使用计算机科学术语>#</a></h3><ul><li>只有程序员才会读你的代码，不需要按照问题所在邻域取名称。</li></ul><h3 id=别用双关语>别用双关语<a hidden class=anchor aria-hidden=true href=#别用双关语>#</a></h3><ul><li><code>add</code>方法一般语义是：根据两个值获得一个新的值。<strong>如果要把单个值加入到某个集合</strong>，用<code>insert</code>或<code>append</code>命名更好，这里用<code>add</code>就是双关语了。</li></ul><h3 id=添加有意义的语境>添加有意义的语境<a hidden class=anchor aria-hidden=true href=#添加有意义的语境>#</a></h3><ul><li>很少有名称能自我说明，<strong>需要用良好命名的类、函数、或者命名空间来放置名称</strong>，给读者提供语境，如果做不到的话，给名称添加前缀就是最后一招了。</li></ul><h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2><h3 id=越短越好>越短越好<a hidden class=anchor aria-hidden=true href=#越短越好>#</a></h3><ul><li><p>短小，20 行封顶；</p></li><li><p><code>if/else/while</code>语句的代码块应该只有一行，该行应该是一个函数调用语句；</p></li><li><p>函数的缩进层级不应该多于一层或两层。</p></li></ul><h3 id=一个函数只做一件事>一个函数只做一件事<a hidden class=anchor aria-hidden=true href=#一个函数只做一件事>#</a></h3><ul><li><p>如果函数只是做了该函数名下<strong>同一抽象层上的步骤</strong>，则函数只做了一件事；</p></li><li><p>要判断函数是否不止做了一件事，就是要看是否能<strong>再拆出一个函数</strong>；</p></li></ul><h3 id=每个函数一个抽象层级>每个函数一个抽象层级<a hidden class=anchor aria-hidden=true href=#每个函数一个抽象层级>#</a></h3><ul><li><strong>向下规则</strong>：让代码拥有自顶向下的阅读顺序。每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能循抽象层级向下阅读了。</li></ul><h3 id=switch-语句>switch 语句<a hidden class=anchor aria-hidden=true href=#switch-语句>#</a></h3><ul><li><strong>把 switch 埋在较低的抽象层级</strong>，一般可以放在抽象工厂底下，用于创建多态对象。</li></ul><h3 id=使用描述性的名称>使用描述性的名称<a hidden class=anchor aria-hidden=true href=#使用描述性的名称>#</a></h3><ul><li><p>函数越短小、功能越集中，就越便于取个好名字；</p></li><li><p>别害怕长名称，<strong>长而具有描述性的名称，要比短而令人费解的名称好，要比描述性的长注释好；</strong></p></li><li><p>别害怕花时间取名字。</p></li></ul><h3 id=函数参数>函数参数<a hidden class=anchor aria-hidden=true href=#函数参数>#</a></h3><ul><li><p><strong>参数越少越好</strong>，0 参数最好，尽量避免用三个以上参数；</p></li><li><p>参数越多，编写组合参数的测试用例就越困难；</p></li><li><p><strong>别用标识参数</strong>，向函数传入<code>bool</code>值是不好的，这意味着函数不止做一件事。可以将此函数拆成两个；</p></li><li><p>如果函数需要<strong>两个、三个或者三个以上参数</strong>，就说明其中<strong>一些参数应该封装成类了</strong>；</p></li><li><p><strong>将参数的顺序编码进函数名</strong>，减轻记忆参数顺序的负担，例如 <code>assertExpectedEqualsActual(expected, actual)</code>。</p></li></ul><h3 id=副作用-函数在正常工作任务之外对外部环境所施加的影响>副作用 (函数在正常工作任务之外对外部环境所施加的影响)<a hidden class=anchor aria-hidden=true href=#副作用-函数在正常工作任务之外对外部环境所施加的影响>#</a></h3><ul><li><p>检查密码并且初始化<code>session</code>的方法命名为<code>checkPasswordAndInitializeSession</code>而非 <code>checkPassword</code>，<strong>即使违反单一职责原则也不要有副作用</strong>；</p></li><li><p>避免使用"输出参数&rdquo;，<strong>如果函数必须修改某种状态，就修改所属对象的状态吧</strong>。</p></li></ul><h3 id=设置-写-和查询-读-分离>设置 (写) 和查询 (读) 分离<a hidden class=anchor aria-hidden=true href=#设置-写-和查询-读-分离>#</a></h3><ul><li></li></ul><pre><code>```C
if(set(&quot;username&quot;, &quot;unclebob&quot;)) 
{ 
    ... 
}
```

含义模糊不清。应该改为:

```c
if (attributeExists(&quot;username&quot;)) 
{ 
    setAttribute(&quot;username&quot;, &quot;unclebob&quot;);
}
```
</code></pre><h3 id=使用异常代替返回错误码>使用异常代替返回错误码<a hidden class=anchor aria-hidden=true href=#使用异常代替返回错误码>#</a></h3><ul><li><p><strong>返回错误码</strong>会要求调用者立刻处理错误，从而<strong>引起深层次的嵌套结构</strong>；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>deletePate</span><span class=p>(</span><span class=n>page</span><span class=p>)</span> <span class=o>==</span> <span class=n>E_OK</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>xxx</span><span class=p>()</span> <span class=o>==</span> <span class=n>E_OK</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>yyy</span><span class=p>()</span> <span class=o>==</span> <span class=n>E_OK</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>log</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> 
</span></span><span class=line><span class=cl>        <span class=k>else</span> 
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>log</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=k>else</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>log</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=k>else</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>log</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p>所以需要用<code>try catch</code>异常机制；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>try</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>deletePage</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>xxx</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>yyy</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>zzz</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=nf>catch</span> <span class=p>(</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>log</span><span class=p>(</span><span class=n>e</span><span class=o>-&gt;</span><span class=nf>getMessage</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p><code>try/catch</code>代码块丑陋不堪，所以最好把<code>try</code>和 <code>catch</code>代码块的主体抽离出来，单独形成函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>try</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=nf>catch</span> <span class=p>(</span><span class=n>Exception</span> <span class=n>e</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>handle</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul><h3 id=不要写重复代码>不要写重复代码<a hidden class=anchor aria-hidden=true href=#不要写重复代码>#</a></h3><ul><li>重复是软件中一切邪恶的根源。当算法改变时需要修改多处地方。</li></ul><h3 id=结构化编程>结构化编程<a hidden class=anchor aria-hidden=true href=#结构化编程>#</a></h3><ul><li><p>只要函数保持短小，偶尔出现的<code>return</code>、<code>break</code>、<code>continue</code>语句没有坏处，甚至还比单入单出原则更具有表达力。<code>goto</code>只有在大函数里才有道理，应该尽量避免使用。</p></li><li><p>并不需要一开始就按照这些规则写函数，没人做得到。想些什么就写什么，然后再打磨这些代码，按照这些规则组装函数。</p></li></ul><h2 id=注释>注释<a hidden class=anchor aria-hidden=true href=#注释>#</a></h2><ul><li><p>若编程语言足够有表现力，我们就不需要注释；</p></li><li><p>注释总是一种失败，因为我们无法找到不用注释就能表达自我的方法；</p></li><li><p>代码在演化，注释却不总是随之变动，会变得越来越不准确。</p></li></ul><h3 id=用代码来阐述>用代码来阐述<a hidden class=anchor aria-hidden=true href=#用代码来阐述>#</a></h3><ul><li><p>创建一个与注释所言同一事物的函数即可，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// check to see if the employee is eligible for full benefits 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>((</span><span class=n>employee</span><span class=p>.</span><span class=n>falgs</span> <span class=o>&amp;</span> <span class=n>HOURLY_FLAG</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>employee</span><span class=p>.</span><span class=n>age</span> <span class=o>&gt;</span> <span class=mi>65</span><span class=p>))</span>
</span></span></code></pre></div><p>应替换为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>employee</span><span class=p>.</span><span class=nf>isEligibleForFullBenefits</span><span class=p>())</span>
</span></span></code></pre></div></li></ul><h3 id=好注释>好注释<a hidden class=anchor aria-hidden=true href=#好注释>#</a></h3><ul><li><p>法律信息，并且只要有可能就指向标准许可或者外部文档，而不是放全文；</p></li><li><p>提供基本信息，如解释某个<strong>抽象方法的返回值</strong>；</p></li><li><p>对意图的解释，反应了作者某个决定后面的意图；</p></li><li><p>阐释。把某些<strong>晦涩的参数或者返回值</strong>的意义<strong>翻译成可读的形式</strong>(更好的方法是让它们自身变得足够清晰，但是类似标准库的代码我们无法修改)；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=nf>compareTo</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>//b &gt; a
</span></span></span></code></pre></div></li><li><p>警示。<code>// don't run unless you have some time to kill</code>；</p></li><li><p><code>TODO</code>注释；</p></li><li><p>放大 一些看似不合理之物的重要性。</p></li></ul><h3 id=坏注释>坏注释<a hidden class=anchor aria-hidden=true href=#坏注释>#</a></h3><ul><li><p>自言自语；</p></li><li><p>多余的注释。<strong>把逻辑在注释里写一遍不能比代码提供更多信息</strong>，读它不比读代码简单。<strong>一目了然的成员变量别加注释</strong>，显得很多余；</p></li><li><p>误导性注释；</p></li><li><p>遵循规矩的注释。<strong>每个函数都加注释、每个变量都加注释是愚蠢的</strong>；</p></li><li><p>日志式注释。有了代码版本控制工具，不必在文件开头维护修改时间、修改人这类日志式的注释；</p></li><li><p><strong>能用函数或者变量表示就别用注释</strong>；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// does the module from the global list &lt;mod&gt; </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// depend on the subsystem we are part of?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>smodule</span><span class=p>.</span><span class=na>getDependSubsystems</span><span class=p>().</span><span class=na>contains</span><span class=p>(</span><span class=n>subSysMod</span><span class=p>.</span><span class=na>getSubSystem</span><span class=p>())</span><span class=w>
</span></span></span></code></pre></div><p>可以改为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ArrayList</span><span class=w> </span><span class=n>moduleDependees</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>smodule</span><span class=p>.</span><span class=na>getDependSubsystems</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>ourSubSystem</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>subSysMod</span><span class=p>.</span><span class=na>getSubSystem</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>moduleDependees</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>ourSubSystem</span><span class=p>))</span><span class=w>
</span></span></span></code></pre></div></li><li><p>位置标记。<strong>标记多了会被我们忽略掉</strong>；</p><p><code>///////////////////// Actions //////////////////////////</code></p></li><li><p>右括号注释；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>try</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>()</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>()</span> 
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=c1>// if
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=c1>// while
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>// try
</span></span></span></code></pre></div><p>如果你想标记右括号，其实应该做的是缩短函数</p></li><li><p>署名 <code>/* add by rick */</code> 源代码控制工具会记住你，<strong>署名注释跟不上代码的演变</strong>；</p></li><li><p>注释掉的代码。会导致看到这段代码其他人不敢删除，使用版本控制系统，可以大胆删除需要注释的代码；</p></li><li><p>信息过多。别在注释中添加有趣的历史话题或者无关的细节；</p></li><li><p>没解释清楚的注释。注释的作用是解释未能自行解释的代码，如果注释本身还需要解释就太遗憾了；</p></li><li><p>短函数的函数头注释。<strong>为短函数选个好名字比函数头注释要好</strong>；</p></li><li><p>非公共API函数的<code>javadoc/phpdoc</code>注释。</p></li></ul><h2 id=格式>格式<a hidden class=anchor aria-hidden=true href=#格式>#</a></h2><h3 id=垂直格式>垂直格式<a hidden class=anchor aria-hidden=true href=#垂直格式>#</a></h3><ul><li><p>短文件比长文件更易于理解。<strong>平均200行，最多不超过500行的单个文件可以构造出色的系统</strong>；</p></li><li><p>像报纸一样排版，由略及详，层层递进；</p></li><li><p>区隔: 封包声明、导入声明、每个函数之间，都用空白行分隔开，<strong>空白行下面标识着新的独立概念</strong>，表示一个思路的开始</p></li><li><p>靠近: 紧密相关的代码应该互相靠近，例如<strong>一个类里的属性之间别用空白行隔开</strong>；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ReporterConfig</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//The class name of the reporter listener</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>m_className</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//The properties of the reporter listener</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Property</span><span class=o>&gt;</span><span class=w> </span><span class=n>m_properties</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Property</span><span class=o>&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>addProperty</span><span class=p>(</span><span class=n>Property</span><span class=w> </span><span class=n>property</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>m_properties</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>property</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>///////////////////////对比////////////////////////////////////</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ReporterConfig</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>m_className</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Property</span><span class=o>&gt;</span><span class=w> </span><span class=n>m_properties</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Property</span><span class=o>&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>addProperty</span><span class=p>(</span><span class=n>Property</span><span class=w> </span><span class=n>property</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>m_properties</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>property</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p><strong>变量声明应尽可能靠近其使用位置</strong>：循环中的控制变量应该总是在循环语句中声明；</p></li><li><p><strong>成员变量应该放在类的顶部声明</strong>，不要四处放置；</p></li><li><p><strong>如果某个函数调用了另外一个，就应该把它们放在一起</strong>。我们希望底层细节最后展现出来，不用沉溺于细节，所以<strong>调用者尽可能放在被调用者之上；</strong></p></li><li><p>执行同一基础任务的几个函数应该放在一起。</p></li></ul><h3 id=水平格式>水平格式<a hidden class=anchor aria-hidden=true href=#水平格式>#</a></h3><ul><li><p>一行代码不必死守80字符的上限，偶尔到达100字符不超过120字符即可；</p></li><li><p>区隔与靠近: 空格强调左右两边的分割。<strong>赋值运算符两边加空格，函数名与左圆括号之间不加空格，乘法运算符在与加减法运算符组合时不用加空格(a*b - c)</strong>；</p></li><li><p>不必水平对齐。例如声明一堆成员变量时，各行不用每一个单词都对齐，代码自动格式化工具通常会把这类对齐消除掉；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span>　<span class=nc>FitNesseExpediter</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>ResponseSender</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w>　　 </span><span class=n>Socket</span><span class=w>　　　　　　　 </span><span class=n>socket</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w>　　 </span><span class=n>InputStream</span><span class=w>　　　   </span><span class=n>input</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w>　　 </span><span class=n>OutputStream</span><span class=w>　　　  </span><span class=n>output</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w>　　 </span><span class=n>Request</span><span class=w>　　　　　　  </span><span class=n>request</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>　　
</span></span></span></code></pre></div></li><li><p>短小的<code>if</code>、<code>while</code>、函数里最好也不要违反缩进规则，不要这样:<code>if (xx == yy) z = 1</code>；</p></li><li><p><code>while</code>语句为空，最好分行写分号；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>;</span>
</span></span></code></pre></div></li></ul><h3 id=团队规则>团队规则<a hidden class=anchor aria-hidden=true href=#团队规则>#</a></h3><ul><li>团队绝对不要用各种不同的风格来编写源代码，这样会增加其复杂度。</li></ul><h2 id=对象和数据结构>对象和数据结构<a hidden class=anchor aria-hidden=true href=#对象和数据结构>#</a></h2><h3 id=数据抽象>数据抽象<a hidden class=anchor aria-hidden=true href=#数据抽象>#</a></h3><ul><li>对象：暴露行为 (接口),隐藏数据 (私有变量) ；</li><li>数据结构：没有明显的行为 (接口),暴露数据。如<code>DTO</code>(Data Transfer Objects)、<code>Entity</code>；</li></ul><h3 id=数据对象的反对称性>数据，对象的反对称性<a hidden class=anchor aria-hidden=true href=#数据对象的反对称性>#</a></h3><ul><li><p>使用<strong>数据结构便于</strong>在不改动现在数据结构的前提下<strong>添加新函数</strong>；使用<strong>对象便于</strong>在不改动既有函数的前提下<strong>添加新类</strong>；</p></li><li><p>使用<strong>数据结构难以添加新数据结构</strong>，因为必须修改所有函数；使用<strong>对象难以添加新函数</strong>，因为必须修改所有类；</p></li><li><p>万物皆对象只是个传说，有时候我们也会在简单数据结构上做一些过程式的操作。</p></li></ul><h3 id=law-of-demeter>Law of Demeter<a hidden class=anchor aria-hidden=true href=#law-of-demeter>#</a></h3><ul><li><p><strong>模块不应该了解它所操作对象的内部情形</strong>；</p></li><li><p><code>class C</code>的方法<code>f</code>只应该调用以下对象的方法：</p><ul><li><p><code>C</code></p></li><li><p>在方法<code>f</code>里创建的对象</p></li><li><p>作为参数传递给方法<code>f</code>的对象</p></li><li><p><code>C</code>持有的对象</p></li></ul></li><li><p>方法不应调用 <strong>由任何函数返回的对象</strong> 的方法。下面的代码违反了 demeter 定律：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>final</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>outputDir</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ctxt</span><span class=p>.</span><span class=na>getOptions</span><span class=p>().</span><span class=na>getScratchDir</span><span class=p>().</span><span class=na>getAbsolutePath</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div></li><li><p>一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p></li></ul><h3 id=错误处理>错误处理<a hidden class=anchor aria-hidden=true href=#错误处理>#</a></h3><ul><li>错误处理很重要，但是不能凌乱到打乱代码逻辑。</li></ul><h3 id=使用异常而不是返回错误码>使用异常而不是返回错误码<a hidden class=anchor aria-hidden=true href=#使用异常而不是返回错误码>#</a></h3><ul><li><p>如果使用错误码，调用者必须在函数返回时<strong>立刻处理错误</strong>，但这很容易被我们忘记；</p></li><li><p>错误码通常会导致<strong>嵌套</strong><code>if else</code>。</p></li></ul><h3 id=先写-try-catch-语句>先写 try-catch 语句<a hidden class=anchor aria-hidden=true href=#先写-try-catch-语句>#</a></h3><ul><li>当编写可能会抛异常的代码时，先写好<code>try-catch</code>再往里堆逻辑。</li></ul><h3 id=在-catch-里尽可能的记录>在 catch 里尽可能的记录<a hidden class=anchor aria-hidden=true href=#在-catch-里尽可能的记录>#</a></h3><ul><li>在<code>catch</code>里尽可能的记录错误信息，记录失败的操作以及失败的类型</li></ul><h3 id=依调用者定义异常类>依调用者定义异常类<a hidden class=anchor aria-hidden=true href=#依调用者定义异常类>#</a></h3><ul><li>对错误分类有很多方式。可以依其来源分类：是来自组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？</li></ul><h3 id=别返回-null-值>别返回 null 值<a hidden class=anchor aria-hidden=true href=#别返回-null-值>#</a></h3><ul><li><p>返回<code>null</code>值只要一处没检查<code>null</code>，应用程序就会失败；</p></li><li><p>当想返回<code>null</code>值的时候，<strong>可以试试抛出异常，或者返回特例模式的对象。</strong></p></li></ul><h3 id=别传递-null-值>别传递 null 值<a hidden class=anchor aria-hidden=true href=#别传递-null-值>#</a></h3><ul><li><p>在方法中传递<code>null</code>值是一种糟糕的做法，应该尽量避免；</p></li><li><p>在方法里用<code>if</code>或<code>assert</code>过滤<code>null</code>值参数，但是还是会出现运行时错误，没有良好的办法对付调动者意外传入的<code>null</code>值，恰当的做法就是<strong>禁止传入<code>null</code>值</strong>。</p></li></ul><h2 id=边界>边界<a hidden class=anchor aria-hidden=true href=#边界>#</a></h2><h3 id=将第三方代码干净利落地整合进自己的代码中>将第三方代码干净利落地整合进自己的代码中<a hidden class=anchor aria-hidden=true href=#将第三方代码干净利落地整合进自己的代码中>#</a></h3><ul><li><p>避免公共 API 返回边界接口，或者将边界接口作为参数传递给 API。将边界保留在近亲类中；</p></li><li><p>不要在生产代码中试验新东西，而是编写测试来理解第三方代码；</p></li><li><p>避免我们的代码过多地了解第三方代码中的特定信息。</p></li><li><p>学习性测试是一种精确试验，帮助我们增进对 API 的理解。</p></li></ul><h2 id=单元测试>单元测试<a hidden class=anchor aria-hidden=true href=#单元测试>#</a></h2><h3 id=tddtest-driven-development-三定律>TDD(Test-driven development) 三定律<a hidden class=anchor aria-hidden=true href=#tddtest-driven-development-三定律>#</a></h3><ul><li><p><em>First Law: You may not write production code until you have written a failing unit test.</em></p></li><li><p><em>Second Law: You may not write more of a unit test than is sufficient to fail, and not compiling is failing.</em></p></li><li><p><em>Third Law: You may not write more production code than is sufficient to pass the currently failing test.</em></p></li></ul><h3 id=保持测试整洁>保持测试整洁<a hidden class=anchor aria-hidden=true href=#保持测试整洁>#</a></h3><ul><li><p><strong>脏测试等同于没测试</strong>，测试代码越脏生产代码越难修改；</p></li><li><p>测试代码和生产代码一样重要；</p></li><li><p>整洁的测试代码最应具有的要素是：<strong>整洁性</strong>。<strong>测试代码中不要有大量重复代码的调用。</strong></p></li></ul><h3 id=每个测试一个断言>每个测试一个断言<a hidden class=anchor aria-hidden=true href=#每个测试一个断言>#</a></h3><ul><li><p>每个测试函数<strong>有且仅有一个断言语句</strong>；</p></li><li><p>每个测试函数中<strong>只测试一个概念</strong>。</p></li></ul><h3 id=整洁的测试依赖于-first-规则>整洁的测试依赖于 FIRST 规则<a hidden class=anchor aria-hidden=true href=#整洁的测试依赖于-first-规则>#</a></h3><ul><li><p><strong>fast</strong>: 测试代码应该<strong>能够快速运行</strong>，因为我们需要频繁运行它；</p></li><li><p><strong>independent</strong>: 测试应该<strong>相互独立</strong>，某个测试不应该依赖上一个测试的结果，测试可以以任何顺序进行；</p></li><li><p><strong>repeatable</strong>: 测试应可以在任何环境中通过；</p></li><li><p><strong>self-validating</strong>: 测试应该有<code>bool</code>值输出，不应通过查看日志来确认测试结果，不应手工对比两个文本文件确认测试结果；</p></li><li><p><strong>timely</strong>: 及时编写测试代码。<strong>单元测试应该在生产代码之前编写</strong>，否则生产代码会变得难以测试。</p></li></ul><h2 id=类>类<a hidden class=anchor aria-hidden=true href=#类>#</a></h2><h3 id=类的组织>类的组织<a hidden class=anchor aria-hidden=true href=#类的组织>#</a></h3><p>以下针对 JAVA 语言，其他语言类似，变量在前，方法在后，公有在前，私有在后。</p><ul><li><p>公共静态常量</p></li><li><p>私有静态变量</p></li><li><p>私有实体变量</p></li><li><p>公共函数</p></li><li><p>私有工具函数</p></li></ul><p>如果测试需要调用一个函数或变量，可以设为保护类型。</p><h3 id=类应该短小>类应该短小<a hidden class=anchor aria-hidden=true href=#类应该短小>#</a></h3><ul><li><p>对于函数我们计算<strong>代码行数</strong>衡量大小，对于类我们使用<strong>权责</strong>来衡量；</p></li><li><p><strong>类的名称应当描述其权责</strong>。类的命名是判断类长度的第一个手段，如果无法为某个类命以准确的名称，这个类就太长了。类名包含模糊的词汇，如<code>Processor</code>、<code>Manager</code>、<code>Super</code>，这种现象就说明有不恰当的<strong>权责聚集</strong>情况；</p></li><li><p>单一权责原则（Single Responsibility Principle，SRP）: 类或者模块应该有一个权责——只有一条修改的理由 (A class should have only one reason to change.)；</p></li><li><p>系统应该由许多短小的类而不是少量巨大的类组成；</p></li><li><p>类应该只有少量的实体变量，如果一个类中每个实体变量都被每个方法所使用，则说明该类具有<strong>最大的内聚性</strong>。创建最大化的内聚类不太现实，但是应该以高内聚为目标，<strong>内聚性越高说明类中的方法和变量互相依赖、互相结合形成一个逻辑整体</strong>；</p></li><li><p><strong>保持内聚性就会得到许多短小的类</strong>。如果你想把一个大函数的某一小部分拆解成单独的函数，拆解出的函数使用了大函数中的 4 个变量，不必<strong>将 4 个变量作为参数传递到新函数里</strong>，仅需<strong>将这 4 个变量提升为大函数所在类的实体变量</strong>，但是这么做却因为实体变量的增多而丧失了类的内聚性，更好多做法是<strong>让这 4 个变量拆出来，拥有自己的类</strong>。将大函数拆解成小函数往往是将类拆分为小类的时机。</p></li></ul><h3 id=为了修改而组织>为了修改而组织<a hidden class=anchor aria-hidden=true href=#为了修改而组织>#</a></h3><ul><li><p>类应当对扩展开放，对修改封闭 (开放闭合原则)；</p></li><li><p>在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。</p></li></ul><h2 id=系统>系统<a hidden class=anchor aria-hidden=true href=#系统>#</a></h2><h3 id=将系统的构造与使用分开>将系统的构造与使用分开<a hidden class=anchor aria-hidden=true href=#将系统的构造与使用分开>#</a></h3><ul><li>软件系统应将起始过程和之后的运行逻辑分开。</li></ul><h3 id=分解-main>分解 main<a hidden class=anchor aria-hidden=true href=#分解-main>#</a></h3><ul><li><p><strong>将全部构造过程搬迁到 main</strong>或者被称之为<code>main</code>的模块中，涉及系统其余部分时，<strong>假设所有对象都已经正确构造</strong>；</p></li><li><p>依赖注入 (DI)，控制反转 (IoC) 是分离构造与使用的强大机制。</p></li></ul><h2 id=迭代>迭代<a hidden class=anchor aria-hidden=true href=#迭代>#</a></h2><h3 id=表达力>表达力<a hidden class=anchor aria-hidden=true href=#表达力>#</a></h3><ul><li><p>作者把代码写的越清晰，其他人理解代码就越快；</p></li><li><p>太多时候我们深入于要解决的问题中，写出能工作的代码之后，就转移到下一个问题上，没有下足功夫调整代码让后来者易于阅读。多少尊重一下我们的手艺，花一点点时间在每个函数和类上。</p></li></ul><h3 id=尽可能少的类和方法>尽可能少的类和方法<a hidden class=anchor aria-hidden=true href=#尽可能少的类和方法>#</a></h3><ul><li><p>为了保持类和函数的短小，我们可能会早出太多细小的类和方法；</p></li><li><p>类和方法数量太多，有时是由毫无意义的教条主义导致的。</p></li></ul><h3 id=以上-4-条规则优先级依次递减重要的是测试消除重复表达意图>以上 4 条规则优先级依次递减。重要的是测试、消除重复、表达意图<a hidden class=anchor aria-hidden=true href=#以上-4-条规则优先级依次递减重要的是测试消除重复表达意图>#</a></h3><h2 id=并发编程>并发编程<a hidden class=anchor aria-hidden=true href=#并发编程>#</a></h2><h3 id=为什么要并发编程>为什么要并发编程<a hidden class=anchor aria-hidden=true href=#为什么要并发编程>#</a></h3><ul><li><p>并发总能改进性能；</p></li><li><p>编写并发程序无需修改设计；</p></li><li><p>在采用<code>Web</code>或<code>EJB</code>容器的时候，理解并发问题并不重要。</p></li></ul><h3 id=防御并发代码问题的原则与技巧>防御并发代码问题的原则与技巧<a hidden class=anchor aria-hidden=true href=#防御并发代码问题的原则与技巧>#</a></h3><ul><li><p>遵循单一职责原则。分离并发代码与非并发代码；</p></li><li><p>限制临界区数量、限制对共享数据的访问；</p></li><li><p>避免使用共享数据，使用对象的副本；</p></li><li><p>线程尽可能地独立，不与其他线程共享数据。</p></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://lifeislife.cn/posts/clang-format%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/><span class=title>« 上一页</span><br><span>Clang-Format 格式化代码</span>
</a><a class=next href=https://lifeislife.cn/posts/git-git-pull%E4%B8%8Egit-pull-rebase%E7%9A%84%E5%8C%BA%E5%88%AB/><span class=title>下一页 »</span><br><span>Git-git pull 与 git pull --rebase 的区别</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 《代码整洁之道》读书笔记 on x" href="https://x.com/intent/tweet/?text=%e3%80%8a%e4%bb%a3%e7%a0%81%e6%95%b4%e6%b4%81%e4%b9%8b%e9%81%93%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25BB%25A3%25E7%25A0%2581%25E6%2595%25B4%25E6%25B4%2581%25E4%25B9%258B%25E9%2581%2593%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 《代码整洁之道》读书笔记 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25BB%25A3%25E7%25A0%2581%25E6%2595%25B4%25E6%25B4%2581%25E4%25B9%258B%25E9%2581%2593%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;title=%e3%80%8a%e4%bb%a3%e7%a0%81%e6%95%b4%e6%b4%81%e4%b9%8b%e9%81%93%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0&amp;summary=%e3%80%8a%e4%bb%a3%e7%a0%81%e6%95%b4%e6%b4%81%e4%b9%8b%e9%81%93%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0&amp;source=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25BB%25A3%25E7%25A0%2581%25E6%2595%25B4%25E6%25B4%2581%25E4%25B9%258B%25E9%2581%2593%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 《代码整洁之道》读书笔记 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25BB%25A3%25E7%25A0%2581%25E6%2595%25B4%25E6%25B4%2581%25E4%25B9%258B%25E9%2581%2593%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f&title=%e3%80%8a%e4%bb%a3%e7%a0%81%e6%95%b4%e6%b4%81%e4%b9%8b%e9%81%93%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 《代码整洁之道》读书笔记 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25BB%25A3%25E7%25A0%2581%25E6%2595%25B4%25E6%25B4%2581%25E4%25B9%258B%25E9%2581%2593%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 《代码整洁之道》读书笔记 on whatsapp" href="https://api.whatsapp.com/send?text=%e3%80%8a%e4%bb%a3%e7%a0%81%e6%95%b4%e6%b4%81%e4%b9%8b%e9%81%93%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20-%20https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25BB%25A3%25E7%25A0%2581%25E6%2595%25B4%25E6%25B4%2581%25E4%25B9%258B%25E9%2581%2593%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 《代码整洁之道》读书笔记 on telegram" href="https://telegram.me/share/url?text=%e3%80%8a%e4%bb%a3%e7%a0%81%e6%95%b4%e6%b4%81%e4%b9%8b%e9%81%93%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25BB%25A3%25E7%25A0%2581%25E6%2595%25B4%25E6%25B4%2581%25E4%25B9%258B%25E9%2581%2593%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 《代码整洁之道》读书笔记 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e3%80%8a%e4%bb%a3%e7%a0%81%e6%95%b4%e6%b4%81%e4%b9%8b%e9%81%93%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0&u=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25BB%25A3%25E7%25A0%2581%25E6%2595%25B4%25E6%25B4%2581%25E4%25B9%258B%25E9%2581%2593%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://lifeislife-1.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://lifeislife.cn/>夜云泊</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>