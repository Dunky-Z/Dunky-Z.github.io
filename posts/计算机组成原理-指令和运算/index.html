<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>计算机组成原理-指令和运算 | 夜云泊</title><meta name=keywords content="计算机组成原理"><meta name=description content="计算机指令
上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0 表示不打孔，1 表示打孔），送入特殊的计算机中执行。"><meta name=author content="Nic"><link rel=canonical href=https://lifeislife.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/><link crossorigin=anonymous href=/assets/css/stylesheet.3e75ab39571716f01a345ec7094abf785059c0622f4efe914e97390076cc7aee.css integrity="sha256-PnWrOVcXFvAaNF7HCUq/eFBZwGIvTv6RTpc5AHbMeu4=" rel="preload stylesheet" as=style><link rel=icon href=https://lifeislife.cn/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lifeislife.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lifeislife.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://lifeislife.cn/apple-touch-icon.png><link rel=mask-icon href=https://lifeislife.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lifeislife.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PS8L2EEEPR")}</script><meta property="og:url" content="https://lifeislife.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/"><meta property="og:site_name" content="夜云泊"><meta property="og:title" content="计算机组成原理-指令和运算"><meta property="og:description" content="计算机指令 上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0 表示不打孔，1 表示打孔），送入特殊的计算机中执行。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-28T21:28:56+00:00"><meta property="article:modified_time" content="2022-02-28T21:28:56+00:00"><meta property="article:tag" content="计算机组成原理"><meta name=twitter:card content="summary"><meta name=twitter:title content="计算机组成原理-指令和运算"><meta name=twitter:description content="计算机指令
上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0 表示不打孔，1 表示打孔），送入特殊的计算机中执行。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifeislife.cn/posts/"},{"@type":"ListItem","position":2,"name":"计算机组成原理-指令和运算","item":"https://lifeislife.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"计算机组成原理-指令和运算","name":"计算机组成原理-指令和运算","description":"计算机指令 上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0 表示不打孔，1 表示打孔），送入特殊的计算机中执行。\n","keywords":["计算机组成原理"],"articleBody":"计算机指令 上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0 表示不打孔，1 表示打孔），送入特殊的计算机中执行。\n从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。\n从软件的角度来看，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。\n不同的 CPU 能够听懂的语言不太一样。也就是 CPU 支持的语言不一样，这里的语言叫指令集（Instruction Set）。\n一个计算机程序由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作存储程序型计算机（Stored-program Computer）。\n了解了计算机指令和计算机指令集，接下来我们来看看，平时编写的代码，到底是怎么变成一条条计算机指令，最后被 CPU 执行的呢？我们拿一小段真实的 C 语言程序来看看。\n// test.c int main() { int a = 1; int b = 2; a = a + b; } 通过编译器，可以将上述代码编译成汇编代码，再通过汇编器，将汇编代码编译成机器码，最后通过 CPU 执行。\n在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。\n$ gcc -g -c test.c $ objdump -d -M intel -S test.o test.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 : int main() { 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp int a = 1; 4: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x4],0x1 int b = 2; b: c7 45 f8 02 00 00 00 mov DWORD PTR [rbp-0x8],0x2 a = a + b; 12: 8b 45 f8 mov eax,DWORD PTR [rbp-0x8] 15: 01 45 fc add DWORD PTR [rbp-0x4],eax } 18: 5d pop rbp 19: c3 ret 左侧有一堆数字，这些就是一条条机器码；右边有一系列的push、mov、add、pop 等，这些就是对应的汇编代码。\n了解了这个过程，下面我们放大局部，来看看这一行行的汇编代码和机器指令，到底是什么意思。\n常见的指令可以分成五大类。\n第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。\n第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。\n第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。\n第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。\n最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。\n指令跳转 CPU 如何执行指令的 代码经过软件层面的编译后就是一条条二进制指令，指令交由 CPU 中几百亿个晶体管去执行。我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。而寄存器就是 CPU 内部，由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。\nN 个触发器或者锁存器，就可以组成一个N位（Bit）的寄存器，能够保存 N位的数据。比方说，我们用的64位 Intel服务器，寄存器就是64 位的。\n一个 CPU 里面会有很多种不同功能的寄存器。这里介绍三种比较特殊的。\nPC 寄存器（Program Counter Register），我们也叫指令地址寄存器（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。\n指令寄存器（Instruction Register），用来存放当前正在执行的指令。\n条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。\n除此之外还有整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。\n实际上，一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。\n而有些特殊指令，比如上一讲我们讲到 J 类指令，也就是跳转指令，会修改 PC 寄存器里面的地址值。\n从 if…else 来看程序的执行和跳转 首先看如下的例程，\n// test.c #include #include int main() { srand(time(NULL)); int r = rand() % 2; int a = 10; if (r == 0) { a = 1; } else { a = 2; } gcc -g -c test.c objdump -d -M intel -S test.o 编译后打印出汇编代码如下：\nif (r == 0) 3b: 83 7d fc 00 cmp DWORD PTR [rbp-0x4],0x0 3f: 75 09 jne 4a { a = 1; 41: c7 45 f8 01 00 00 00 mov DWORD PTR [rbp-0x8],0x1 48: eb 07 jmp 51 } else { a = 2; 4a: c7 45 f8 02 00 00 00 mov DWORD PTR [rbp-0x8],0x2 51: b8 00 00 00 00 mov eax,0x0 } 可以看到，这里对于 r == 0的条件判断，被编译成了 cmp 和 jne 这两条指令。\ncmp 指令比较了前后两个操作数的值，这里的DWORD PTR 代表操作的数据类型是 32位的整数，而 [rbp-0x4] 则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量 r 的值。第二个操作数 0x0 就是我们设定的常量0的 16 进制表示。cmp 指令的比较结果，会存入到条件码寄存器当中去。\n在这里，如果比较的结果是 True，也就是 r == 0，就把零标志条件码（对应的条件码是 ZF，Zero Flag）设置为 1。除了零标志之外，Intel 的 CPU 下还有进位标志（CF，Carry Flag）、符号标志（SF，Sign Flag）以及溢出标志（OF，Overflow Flag），用在不同的判断条件下。\ncmp 指令执行完成之后，PC 寄存器会自动自增，开始执行下一条 jne 的指令。\n跟着的 jne 指令，是 jump if not equal 的意思，它会查看对应的零标志位。如果为0，会跳转到后面跟着的操作数 4a 的位置。这个 4a，对应这里汇编代码的行号，也就是上面设置的 else 条件里的第一条指令。当跳转发生的时候，PC 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 4a 这个地址。这个时候，CPU 再把 4a 地址里的指令加载到指令寄存器中来执行。\n跳转到执行地址为 4a 的指令，实际是一条 mov 指令，第一个操作数和前面的 cmp 指令一样，是另一个 32 位整型的寄存器地址，以及对应的 2 的16 进制值 0x2。mov 指令把 2 设置到对应的寄存器里去，相当于一个赋值操作。然后，PC寄存器里的值继续自增，执行下一条 mov 指令。\n这条 mov 指令的第一个操作数eax，代表累加寄存器，第二个操作数0x0则是 16 进制的0的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的 if 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 jmp 的无条件跳转指令。跳转的地址就是这一行的地址51。我们的 main 函数没有设定返回值，而mov eax, 0x0 其实就是给 main 函数生成了一个默认的为 0 的返回值到累加器里面。if 条件里面的内容执行完成之后也会跳转到这里，和 else 里的内容结束之后的位置是一样的。\n函数调用：为什么会发生 Stack Overflow 静态链接 既然我们的程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在 Linux 下可以运行，而在 Windows 下却不行呢？反过来，Windows 上的程序在 Linux 上也是一样不能执行的。可是我们的 CPU 并没有换掉，它应该可以识别同样的指令呀？\n将以下两个例程编译，然后通过 objdump 命令看看它们的汇编代码。\n// add_lib.c int add(int a, int b) { return a+b; } // link_example.c #include int main() { int a = 10; int b = 5; int c = add(a, b); printf(\"c = %d\\n\", c); } gcc -g -c add_lib.c link_example.c objdump -d -M intel -S add_lib.o objdump -d -M intel -S link_example.o add_lib.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 : 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 89 7d fc mov DWORD PTR [rbp-0x4],edi 7: 89 75 f8 mov DWORD PTR [rbp-0x8],esi a: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] d: 8b 45 f8 mov eax,DWORD PTR [rbp-0x8] 10: 01 d0 add eax,edx 12: 5d pop rbp 13: c3 ret link_example.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 : 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 48 83 ec 10 sub rsp,0x10 8: c7 45 fc 0a 00 00 00 mov DWORD PTR [rbp-0x4],0xa f: c7 45 f8 05 00 00 00 mov DWORD PTR [rbp-0x8],0x5 16: 8b 55 f8 mov edx,DWORD PTR [rbp-0x8] 19: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 1c: 89 d6 mov esi,edx 1e: 89 c7 mov edi,eax 20: b8 00 00 00 00 mov eax,0x0 25: e8 00 00 00 00 call 2a 2a: 89 45 f4 mov DWORD PTR [rbp-0xc],eax 2d: 8b 45 f4 mov eax,DWORD PTR [rbp-0xc] 30: 89 c6 mov esi,eax 32: 48 8d 3d 00 00 00 00 lea rdi,[rip+0x0] # 39 39: b8 00 00 00 00 mov eax,0x0 3e: e8 00 00 00 00 call 43 43: b8 00 00 00 00 mov eax,0x0 48: c9 leave 49: c3 ret 既然代码已经被我们“编译”成了指令，我们不妨尝试运行一下 ./link_example.o。\n然而我们并不能成功运行，会得到一条cannot execute binary file: Exec format error 的错误。\n我们再仔细看一下 objdump 出来的两个文件的代码，会发现两个程序的地址都是从 0 开始的。如果地址是一样的，程序如果需要通过 call 指令调用函数的话，它怎么知道应该跳转到哪一个文件里呢？\n无论是这里的运行报错，还是 objdump 出来的汇编代码里面的重复地址，都是因为add_lib.o以及 link_example.o 并不是一个可执行文件（Executable Program），而是目标文件（Object File）。只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。\n通过 gcc 的-o参数，可以生成对应的可执行文件。\n$ gcc -o link-example add_lib.o link_example.o $ ./link_example c = 15 ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。\n\u003c!DOCTYPE html\u003e Responsive Image 链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。\n\u003c!DOCTYPE html\u003e Responsive Image 在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。\n为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。其中一个非常重要的原因就是，两个操作系统下可执行文件的格式不一样。\n我们今天讲的是 Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作 PE（Portable Executable Format）的文件格式。Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。\n如果我们有一个可以能够解析 PE 格式的装载器，我们就有可能在 Linux 下运行 Windows 程序了。这样的程序真的存在吗？没错，Linux 下著名的开源项目 Wine，就是通过兼容 PE 格式的装载器，使得我们能直接在 Linux 下运行 Windows 程序的。而现在微软的 Windows 里面也提供了 WSL，也就是 Windows Subsystem for Linux，可以解析和加载 ELF 格式的文件。\n程序装载 程序装载面临的挑战 可执行程序加载后占用的内存空间应该是连续的。 这点很好理解，指令正常都是顺序执行的。 我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。 计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用了。 我们把指令里用到的内存地址叫作虚拟内存地址（Virtual Memory Address），实际在内存硬件里面的空间地址，我们叫物理内存地址（Physical Memory Address）。\n程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了。对于任何一个程序来说，它看到的都是同样的内存地址。我们维护一个虚拟内存到物理内存的映射表，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。\n内存分段 这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫分段（Segmentation）。这里的段，就是指系统分配出来的那个连续的内存空间。\n分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处，第一个就是内存碎片（Memory Fragmentation）的问题。\n\u003c!DOCTYPE html\u003e Responsive Image 我们可以通过内存交换（Memory Swapping）技术解决。\n我们可以把 Python 程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里面。不过读回来的时候，我们不再把它加载到原来的位置，而是紧紧跟在那已经被占用了的 512MB 内存后面。这样，我们就有了连续的 256MB 内存空间，就可以去加载一个新的 200MB 的程序。\n如果你自己安装过 Linux 操作系统，你应该遇到过分配一个 swap 硬盘分区的问题。这块分出来的磁盘空间，其实就是专门给 Linux 操作系统进行内存交换用的。\n硬盘的访问速度要比内存慢很多，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。\n内存分页 既然问题出在内存碎片和内存交换的空间太大上，那么解决问题的办法就是，少出现一些内存碎片，并且让需要交换写入或者从磁盘装载的数据更少一点。于是就有了内存分页（Paging）。\n和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小。而对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。\n从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。页的尺寸一般远远小于整个程序的大小。在 Linux 下，我们通常只设置成 4KB。\n由于内存空间都是预先划分好的，也就没有了不能使用的碎片，而只有被释放出来的很多 4KB 的页。即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，让整个机器被内存交换的过程给卡住。\n分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。\n实际上，我们的操作系统，的确是这么做的。当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的缺页错误（Page Fault）。我们的操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。\n动态链接 如果我们有很多个程序都要通过装载器装载到内存里面，那里面链接好的同样的功能代码，也都需要再装载一遍，再占一遍内存空间。在一个运行上百个进程的系统中，这将会造成极大的资源浪费。\n共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接（dynamic linking）是由一个叫做动态链接器（dynamic linker）的程序来执行的。Linux 中为.so文件，Windows 中为.dll文件。\n\u003c!DOCTYPE html\u003e Responsive Image PIC （Position-Independent Code） 要想要在程序运行的时候共享代码，也有一定的要求，就是这些机器码必须是“地址无关”的。也就是说，我们编译出来的共享库文件的指令代码，放在哪个内存地址都能正常运行。\n\u003c!DOCTYPE html\u003e Responsive Image 对于所有动态链接共享库的程序来讲，虽然我们的共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的。我们没办法、也不应该要求动态链接同一个共享库的不同程序，必须把这个共享库所使用的虚拟内存地址变成一致。如果这样的话，我们写的程序就必须明确地知道内部的内存地址分配。\n如何才能实现地址无关？\n动态代码库内部的变量和函数调用都很容易解决，我们只需要使用相对地址（Relative Address）就好了。各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。因为整个共享库是放在一段连续的虚拟内存地址中的，无论装载到哪一段地址，不同指令之间的相对地址都是不变的。\nPLT 和 GOT // lib.h #ifndef LIB_H #define LIB_H void show_me_the_money(int money); #endif // lib.c #include void show_me_the_money(int money) { printf(\"Show me USD %d from lib.c \\n\", money); } // show_me_poor.c #include \"lib.h\" int main() { int money = 5; show_me_the_money(money); } gcc lib.c -fPIC -shared -o lib.so gcc -o show_me_poor show_me_poor.c ./lib.so -fpic 选项指示编译器生成与位置无关的代码。-shared选项指示链接器创建一个共享的目标文件。\n然后，我们再通过 gcc 编译 show_me_poor 动态链接了 lib.so 的可执行文件。在这些操作都完成了之后，我们把 show_me_poor 这个文件通过 objdump 出来看一下。\n$ objdump -d -M intel -S show_me_poor …… 0000000000400540 : 400540: ff 35 12 05 20 00 push QWORD PTR [rip+0x200512] # 600a58 \u003c_GLOBAL_OFFSET_TABLE_+0x8\u003e 400546: ff 25 14 05 20 00 jmp QWORD PTR [rip+0x200514] # 600a60 \u003c_GLOBAL_OFFSET_TABLE_+0x10\u003e 40054c: 0f 1f 40 00 nop DWORD PTR [rax+0x0] 0000000000400550 : 400550: ff 25 12 05 20 00 jmp QWORD PTR [rip+0x200512] # 600a68 \u003c_GLOBAL_OFFSET_TABLE_+0x18\u003e 400556: 68 00 00 00 00 push 0x0 40055b: e9 e0 ff ff ff jmp 400540 \u003c_init+0x28\u003e …… 0000000000400676 : 400676: 55 push rbp 400677: 48 89 e5 mov rbp,rsp 40067a: 48 83 ec 10 sub rsp,0x10 40067e: c7 45 fc 05 00 00 00 mov DWORD PTR [rbp-0x4],0x5 400685: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 400688: 89 c7 mov edi,eax 40068a: e8 c1 fe ff ff call 400550 40068f: c9 leave 400690: c3 ret 400691: 66 2e 0f 1f 84 00 00 nop WORD PTR cs:[rax+rax*1+0x0] 400698: 00 00 00 40069b: 0f 1f 44 00 00 nop DWORD PTR [rax+rax*1+0x0] …… 在 main 函数调用 show_me_the_money 的函数的时候，对应的代码是这样的：\ncall 400550 这里后面有一个@plt 的关键字，代表了我们需要从PLT，也就是过程链接表（Procedure Link Table）里面找要调用的函数。对应的地址呢，则是 400550 这个地址。\n那当我们把目光挪到上面的 400550 这个地址，你又会看到里面进行了一次跳转，这个跳转指定的跳转地址，你可以在后面的注释里面可以看到，GLOBAL_OFFSET_TABLE+0x18。这里的 GLOBAL_OFFSET_TABLE，就是我接下来要说的全局偏移表。\n400550: ff 25 12 05 20 00 jmp QWORD PTR [rip+0x200512] # 600a68 \u003c_GLOBAL_OFFSET_TABLE_+0x18\u003e 在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张全局偏移表（GOT，Global Offset Table）。虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。\n虽然不同的程序调用的同样的动态库，各自的内存地址是独立的，调用的又都是同一个动态库，但是不需要去修改动态库里面的代码所使用的地址，而是各个程序各自维护好自己的 GOT，能够找到对应的动态库就好了。\n二进制编码 原码表示法，左侧第一位是符号位，符号位为 1 时表示负数，为 0 时表示正数。 补码表示法，我们不再把这一位当成单独的符号位，在剩下几位计算出的十进制前加上正负号，而是在计算整个二进制值的时候，在左侧最高位前面加个负号。\n比如，一个 4 位的二进制补码数值 1011，转换成十进制，就是 $-1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = -5$\n一个 4 位的二进制数，可以表示从 -8 到 7 这 16 个整数，不会白白浪费一位。\n字符集：表示的可以是字符的一个集合。比如说“第一版《新华字典》里面出现的所有汉字”，这是一个中文字符集。比如，我们日常说的Unicode，其实就是一个字符集，包含了 150 种语言的 14 万个不同的字符。\n字符编码：对于字符集里的这些字符，怎么一一用二进制表示出来的一个字典。我们上面说的 Unicode，就可以用UTF-8、UTF-16，乃至 UTF-32 来进行编码，存储成二进制。\n同样的文本，采用不同的编码存储下来。如果另外一个程序，用一种不同的编码方式来进行解码和展示，就会出现乱码。\n锟斤拷 烫烫烫 Unicode 编码一直持续在收录各种字元，这就可能会出现各种作业系统支援的 Unicode 字元不一样。这也就会导致 A 上的一个用 Unicode 编码的字元，在 B 上就会出现无法显示的情况。为了避免这种情况，在 Unicode 中定义了一个特殊字元�，它的 Unicode 编码为 0xFFFD。\n假如 A 支援特殊字元⬆，但是 B 并不支援这个⬆，那么在 B 中将会用�来代替。\n这个字元用 UTF-8 编码后，十六进位表示为0xEF 0XBF 0XBD。如果连续出现两个⬆符号，那么用 UTF-8 编码后的十六进位则表示为0xEF 0XBF 0XBD 0xEF 0XBF 0XBD，这时候再转码成 GBK，因为 GBK 中用两个位元组表示一个字元，那么上述的字元就成了锟（0xEFBF），斤（0xBDEF），拷（0xBFBD）。出现锟斤拷的原因就是 UTF-8 转码 GBK 的过程中出现了问题。当然如果想要出现锟斤拷，则至少需要两个字元出现乱码。\n而“烫烫烫”，则是因为如果你用了 Visual Studio 的调试器，默认使用 MBCS 字符集。“烫”在里面是由 0xCCCC 来表示的，而 0xCC 又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。\n理解电路 从以上的学习可以知道，最终执行的程序都是二进制的指令。那为何计算机最终选择了二进制呢？接下来看看计算机在硬件层面究竟是怎么表示二进制的，以此你就会明白，为什么计算机会选择二进制。\n加法器 乘法器 浮点数和定点数 ","wordCount":"8024","inLanguage":"zh","datePublished":"2022-02-28T21:28:56Z","dateModified":"2022-02-28T21:28:56Z","author":{"@type":"Person","name":"Nic"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifeislife.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%90%E7%AE%97/"},"publisher":{"@type":"Organization","name":"夜云泊","logo":{"@type":"ImageObject","url":"https://lifeislife.cn/assets/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script defer src=/static/fontawesome/fontawesome-all.js></script><header class=header><nav class=nav><div class=logo><a href=https://lifeislife.cn/ accesskey=h title="夜云泊 (Alt + H)">夜云泊</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lifeislife.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://lifeislife.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://lifeislife.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://lifeislife.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://lifeislife.cn/awesome-cycling/ title=AwesomeCycling><span>AwesomeCycling</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.travellings.cn/go.html title=开往><span><i class='fa-solid fa-train-subway'></i>开往</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lifeislife.cn/>主页</a>&nbsp;»&nbsp;<a href=https://lifeislife.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">计算机组成原理-指令和运算</h1><div class=post-meta><span title='2022-02-28 21:28:56 +0000 UTC'>二月 28, 2022</span>&nbsp;·&nbsp;17 分钟&nbsp;·&nbsp;8024 字&nbsp;·&nbsp;Nic</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#计算机指令>计算机指令</a></li><li><a href=#指令跳转>指令跳转</a><ul><li><a href=#cpu-如何执行指令的>CPU 如何执行指令的</a></li><li><a href=#从-ifelse-来看程序的执行和跳转>从 if…else 来看程序的执行和跳转</a></li></ul></li><li><a href=#函数调用为什么会发生-stack-overflow>函数调用：为什么会发生 Stack Overflow</a></li><li><a href=#静态链接>静态链接</a></li><li><a href=#程序装载>程序装载</a><ul><li></li></ul></li><li><a href=#动态链接>动态链接</a><ul><li><a href=#pic-position-independent-code>PIC （Position-Independent Code）</a></li><li><a href=#plt-和-got>PLT 和 GOT</a></li></ul></li><li><a href=#二进制编码>二进制编码</a><ul><li><a href=#锟斤拷-烫烫烫>锟斤拷 烫烫烫</a></li></ul></li><li><a href=#理解电路>理解电路</a></li><li><a href=#加法器>加法器</a></li><li><a href=#乘法器>乘法器</a></li><li><a href=#浮点数和定点数>浮点数和定点数</a></li></ul></nav></div></details></div><div class=post-content><h2 id=计算机指令>计算机指令<a hidden class=anchor aria-hidden=true href=#计算机指令>#</a></h2><p>上世纪 60 年代晚期或 70 年代初期，程序需要先写在纸上，然后转成二进制机器码，再打到打孔卡上（0 表示不打孔，1 表示打孔），送入特殊的计算机中执行。</p><p>从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。</p><p>从软件的角度来看，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作<strong>机器语言</strong>（Machine Language）。</p><p>不同的 CPU 能够听懂的语言不太一样。也就是 CPU 支持的语言不一样，这里的语言叫<strong>指令集</strong>（Instruction Set）。</p><p>一个计算机程序由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作<strong>存储程序型计算机</strong>（Stored-program Computer）。</p><p>了解了计算机指令和计算机指令集，接下来我们来看看，平时编写的代码，到底是怎么变成一条条计算机指令，最后被 CPU 执行的呢？我们拿一小段真实的 C 语言程序来看看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// test.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>a</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通过编译器，可以将上述代码编译成汇编代码，再通过汇编器，将汇编代码编译成机器码，最后通过 CPU 执行。</p><p>在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ gcc -g -c test.c
</span></span><span class=line><span class=cl>$ objdump -d -M intel -S test.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>test.o:     file format elf64-x86-64
</span></span><span class=line><span class=cl>Disassembly of section .text:
</span></span><span class=line><span class=cl><span class=m>0000000000000000</span> &lt;main&gt;:
</span></span><span class=line><span class=cl>int main<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>   0:   <span class=m>55</span>                      push   rbp
</span></span><span class=line><span class=cl>   1:   <span class=m>48</span> <span class=m>89</span> e5                mov    rbp,rsp
</span></span><span class=line><span class=cl>  int <span class=nv>a</span> <span class=o>=</span> 1<span class=p>;</span> 
</span></span><span class=line><span class=cl>   4:   c7 <span class=m>45</span> <span class=nb>fc</span> <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span>    mov    DWORD PTR <span class=o>[</span>rbp-0x4<span class=o>]</span>,0x1
</span></span><span class=line><span class=cl>  int <span class=nv>b</span> <span class=o>=</span> 2<span class=p>;</span>
</span></span><span class=line><span class=cl>   b:   c7 <span class=m>45</span> f8 <span class=m>02</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span>    mov    DWORD PTR <span class=o>[</span>rbp-0x8<span class=o>]</span>,0x2
</span></span><span class=line><span class=cl>  <span class=nv>a</span> <span class=o>=</span> a + b<span class=p>;</span>
</span></span><span class=line><span class=cl>  12:   8b <span class=m>45</span> f8                mov    eax,DWORD PTR <span class=o>[</span>rbp-0x8<span class=o>]</span>
</span></span><span class=line><span class=cl>  15:   <span class=m>01</span> <span class=m>45</span> <span class=nb>fc</span>                add    DWORD PTR <span class=o>[</span>rbp-0x4<span class=o>]</span>,eax
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>  18:   5d                      pop    rbp
</span></span><span class=line><span class=cl>  19:   c3                      ret    
</span></span></code></pre></div><p>左侧有一堆数字，这些就是一条条机器码；右边有一系列的<code>push</code>、<code>mov</code>、<code>add</code>、<code>pop</code> 等，这些就是对应的汇编代码。</p><p>了解了这个过程，下面我们放大局部，来看看这一行行的汇编代码和机器指令，到底是什么意思。</p><p>常见的指令可以分成五大类。</p><p>第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。</p><p>第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。</p><p>第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。</p><p>第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。</p><p>最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。</p><h2 id=指令跳转>指令跳转<a hidden class=anchor aria-hidden=true href=#指令跳转>#</a></h2><h3 id=cpu-如何执行指令的>CPU 如何执行指令的<a hidden class=anchor aria-hidden=true href=#cpu-如何执行指令的>#</a></h3><p>代码经过软件层面的编译后就是一条条二进制指令，指令交由 CPU 中几百亿个晶体管去执行。我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。而寄存器就是 CPU 内部，由多个<strong>触发器</strong>（Flip-Flop）或者<strong>锁存器</strong>（Latches）组成的简单电路。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。</p><p><code>N</code> 个触发器或者锁存器，就可以组成一个<code>N</code>位（Bit）的寄存器，能够保存 <code>N</code>位的数据。比方说，我们用的<code>64</code>位 <code>Intel</code>服务器，寄存器就是<code>64</code> 位的。</p><p>一个 CPU 里面会有很多种不同功能的寄存器。这里介绍三种比较特殊的。</p><ul><li><p>PC 寄存器（Program Counter Register），我们也叫<strong>指令地址寄存器</strong>（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。</p></li><li><p>指令寄存器（Instruction Register），用来存放当前正在执行的指令。</p></li><li><p>条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。</p></li></ul><p>除此之外还有<strong>整数寄存器</strong>、<strong>浮点数寄存器</strong>、<strong>向量寄存器</strong>和<strong>地址寄存器</strong>等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。</p><p>实际上，一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。</p><p>而有些特殊指令，比如上一讲我们讲到 <code>J</code> 类指令，也就是跳转指令，会修改 PC 寄存器里面的地址值。</p><h3 id=从-ifelse-来看程序的执行和跳转>从 if…else 来看程序的执行和跳转<a hidden class=anchor aria-hidden=true href=#从-ifelse-来看程序的执行和跳转>#</a></h3><p>首先看如下的例程，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// test.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>srand</span><span class=p>(</span><span class=nf>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=nf>rand</span><span class=p>()</span> <span class=o>%</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> 
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gcc -g -c test.c
</span></span><span class=line><span class=cl>objdump -d -M intel -S test.o 
</span></span></code></pre></div><p>编译后打印出汇编代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> if (r == 0)
</span></span><span class=line><span class=cl>  3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0
</span></span><span class=line><span class=cl>  3f:   75 09                   jne    4a &lt;main+0x4a&gt;
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        a = 1;
</span></span><span class=line><span class=cl>  41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1
</span></span><span class=line><span class=cl>  48:   eb 07                   jmp    51 &lt;main+0x51&gt;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    else
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        a = 2;
</span></span><span class=line><span class=cl>  4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
</span></span><span class=line><span class=cl>  51:   b8 00 00 00 00          mov    eax,0x0
</span></span><span class=line><span class=cl>    } 
</span></span></code></pre></div><p>可以看到，这里对于 <code>r == 0</code>的条件判断，被编译成了 cmp 和 jne 这两条指令。</p><p><code>cmp</code> 指令比较了前后两个操作数的值，这里的<code>DWORD PTR</code> 代表操作的数据类型是 <code>32</code>位的整数，而 <code>[rbp-0x4]</code> 则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量 <code>r</code> 的值。第二个操作数 <code>0x0</code> 就是我们设定的常量<code>0</code>的 <code>16</code> 进制表示。<code>cmp</code> 指令的比较结果，会存入到条件码寄存器当中去。</p><p>在这里，如果比较的结果是 <code>True</code>，也就是 <code>r == 0</code>，就把零标志条件码（对应的条件码是 <code>ZF</code>，<code>Zero Flag</code>）设置为 <code>1</code>。除了零标志之外，<code>Intel</code> 的 <code>CPU</code> 下还有进位标志（<code>CF</code>，<code>Carry Flag</code>）、符号标志（<code>SF</code>，<code>Sign Flag</code>）以及溢出标志（<code>OF</code>，<code>Overflow Flag</code>），用在不同的判断条件下。</p><p><code>cmp</code> 指令执行完成之后，<code>PC</code> 寄存器会自动自增，开始执行下一条 <code>jne</code> 的指令。</p><p>跟着的 <code>jne</code> 指令，是 <code>jump if not equal</code> 的意思，它会查看对应的零标志位。如果为<code>0</code>，会跳转到后面跟着的操作数 <code>4a</code> 的位置。这个 <code>4a</code>，对应这里汇编代码的行号，也就是上面设置的 <code>else</code> 条件里的第一条指令。当跳转发生的时候，<code>PC</code> 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 <code>4a</code> 这个地址。这个时候，<code>CPU</code> 再把 <code>4a</code> 地址里的指令加载到指令寄存器中来执行。</p><p>跳转到执行地址为 <code>4a</code> 的指令，实际是一条 <code>mov</code> 指令，第一个操作数和前面的 <code>cmp</code> 指令一样，是另一个 <code>32</code> 位整型的寄存器地址，以及对应的 <code>2</code> 的<code>16</code> 进制值 <code>0x2</code>。<code>mov</code> 指令把 <code>2</code> 设置到对应的寄存器里去，相当于一个赋值操作。然后，<code>PC</code>寄存器里的值继续自增，执行下一条 <code>mov</code> 指令。</p><p>这条 <code>mov</code> 指令的第一个操作数<code>eax</code>，代表累加寄存器，第二个操作数<code>0x0</code>则是 <code>16</code> 进制的<code>0</code>的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的 <code>if</code> 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 <code>jmp</code> 的无条件跳转指令。跳转的地址就是这一行的地址<code>51</code>。我们的 <code>main</code> 函数没有设定返回值，而<code>mov eax</code>, <code>0x0</code> 其实就是给 <code>main</code> 函数生成了一个默认的为 <code>0</code> 的返回值到累加器里面。<code>if</code> 条件里面的内容执行完成之后也会跳转到这里，和 <code>else</code> 里的内容结束之后的位置是一样的。</p><h2 id=函数调用为什么会发生-stack-overflow>函数调用：为什么会发生 Stack Overflow<a hidden class=anchor aria-hidden=true href=#函数调用为什么会发生-stack-overflow>#</a></h2><h2 id=静态链接>静态链接<a hidden class=anchor aria-hidden=true href=#静态链接>#</a></h2><p>既然我们的程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在 Linux 下可以运行，而在 Windows 下却不行呢？反过来，Windows 上的程序在 Linux 上也是一样不能执行的。可是我们的 CPU 并没有换掉，它应该可以识别同样的指令呀？</p><p>将以下两个例程编译，然后通过 objdump 命令看看它们的汇编代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// add_lib.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// link_example.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=nf>add</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;c = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gcc -g -c add_lib.c link_example.c
</span></span><span class=line><span class=cl>objdump -d -M intel -S add_lib.o
</span></span><span class=line><span class=cl>objdump -d -M intel -S link_example.o
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>add_lib.o:     file format elf64-x86-64
</span></span><span class=line><span class=cl>Disassembly of section .text:
</span></span><span class=line><span class=cl>0000000000000000 &lt;add&gt;:
</span></span><span class=line><span class=cl>   0:   55                      push   rbp
</span></span><span class=line><span class=cl>   1:   48 89 e5                mov    rbp,rsp
</span></span><span class=line><span class=cl>   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
</span></span><span class=line><span class=cl>   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
</span></span><span class=line><span class=cl>   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
</span></span><span class=line><span class=cl>   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
</span></span><span class=line><span class=cl>  10:   01 d0                   add    eax,edx
</span></span><span class=line><span class=cl>  12:   5d                      pop    rbp
</span></span><span class=line><span class=cl>  13:   c3                      ret    
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>link_example.o:     file format elf64-x86-64
</span></span><span class=line><span class=cl>Disassembly of section .text:
</span></span><span class=line><span class=cl>0000000000000000 &lt;main&gt;:
</span></span><span class=line><span class=cl>   0:   55                      push   rbp
</span></span><span class=line><span class=cl>   1:   48 89 e5                mov    rbp,rsp
</span></span><span class=line><span class=cl>   4:   48 83 ec 10             sub    rsp,0x10
</span></span><span class=line><span class=cl>   8:   c7 45 fc 0a 00 00 00    mov    DWORD PTR [rbp-0x4],0xa
</span></span><span class=line><span class=cl>   f:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5
</span></span><span class=line><span class=cl>  16:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
</span></span><span class=line><span class=cl>  19:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
</span></span><span class=line><span class=cl>  1c:   89 d6                   mov    esi,edx
</span></span><span class=line><span class=cl>  1e:   89 c7                   mov    edi,eax
</span></span><span class=line><span class=cl>  20:   b8 00 00 00 00          mov    eax,0x0
</span></span><span class=line><span class=cl>  25:   e8 00 00 00 00          call   2a &lt;main+0x2a&gt;
</span></span><span class=line><span class=cl>  2a:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
</span></span><span class=line><span class=cl>  2d:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]
</span></span><span class=line><span class=cl>  30:   89 c6                   mov    esi,eax
</span></span><span class=line><span class=cl>  32:   48 8d 3d 00 00 00 00    lea    rdi,[rip+0x0]        # 39 &lt;main+0x39&gt;
</span></span><span class=line><span class=cl>  39:   b8 00 00 00 00          mov    eax,0x0
</span></span><span class=line><span class=cl>  3e:   e8 00 00 00 00          call   43 &lt;main+0x43&gt;
</span></span><span class=line><span class=cl>  43:   b8 00 00 00 00          mov    eax,0x0
</span></span><span class=line><span class=cl>  48:   c9                      leave  
</span></span><span class=line><span class=cl>  49:   c3                      ret    
</span></span></code></pre></div><p>既然代码已经被我们“编译”成了指令，我们不妨尝试运行一下 <code>./link_example.o</code>。</p><p>然而我们并不能成功运行，会得到一条<code>cannot execute binary file: Exec format error</code> 的错误。</p><p>我们再仔细看一下 objdump 出来的两个文件的代码，<strong>会发现两个程序的地址都是从 0 开始的</strong>。如果地址是一样的，程序如果需要通过 <code>call</code> 指令调用函数的话，<strong>它怎么知道应该跳转到哪一个文件里呢？</strong></p><p>无论是这里的运行报错，还是 <code>objdump</code> 出来的汇编代码里面的重复地址，都是因为<code>add_lib.o</code>以及 <code>link_example.o</code> 并不是一个可执行文件（Executable Program），而是目标文件（Object File）。<strong>只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。</strong></p><p>通过 <code>gcc</code> 的<code>-o</code>参数，可以生成对应的可执行文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -o link-example add_lib.o link_example.o
</span></span><span class=line><span class=cl>$ ./link_example
</span></span><span class=line><span class=cl>c = 15
</span></span></code></pre></div><p>ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203032207712.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203032207712.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203032209801.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203032209801.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。</p><p>为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。其中一个非常重要的原因就是，<strong>两个操作系统下可执行文件的格式不一样</strong>。</p><p>我们今天讲的是 Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作 PE（Portable Executable Format）的文件格式。<strong>Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。</strong></p><p>如果我们有一个可以能够解析 PE 格式的装载器，我们就有可能在 Linux 下运行 Windows 程序了。这样的程序真的存在吗？没错，Linux 下著名的开源项目 Wine，就是通过兼容 PE 格式的装载器，使得我们能直接在 Linux 下运行 Windows 程序的。而现在微软的 Windows 里面也提供了 WSL，也就是 Windows Subsystem for Linux，可以解析和加载 ELF 格式的文件。</p><h2 id=程序装载>程序装载<a hidden class=anchor aria-hidden=true href=#程序装载>#</a></h2><h4 id=程序装载面临的挑战>程序装载面临的挑战<a hidden class=anchor aria-hidden=true href=#程序装载面临的挑战>#</a></h4><ul><li>可执行程序加载后占用的内存空间应该是连续的。
这点很好理解，指令正常都是顺序执行的。</li><li>我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。
计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用了。</li></ul><p>我们把指令里用到的内存地址叫作<strong>虚拟内存地址</strong>（Virtual Memory Address），实际在内存硬件里面的空间地址，我们叫<strong>物理内存地址</strong>（Physical Memory Address）。</p><p>程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了。对于任何一个程序来说，它看到的都是同样的内存地址。我们<strong>维护一个虚拟内存到物理内存的映射表</strong>，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。</p><h4 id=内存分段>内存分段<a hidden class=anchor aria-hidden=true href=#内存分段>#</a></h4><p>这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫<strong>分段</strong>（Segmentation）。这里的段，就是指系统分配出来的那个连续的内存空间。</p><p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处，第一个就是<strong>内存碎片</strong>（Memory Fragmentation）的问题。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203051544158.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203051544158.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>我们可以通过<strong>内存交换</strong>（Memory Swapping）技术解决。</p><p>我们可以把 Python 程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里面。不过读回来的时候，我们不再把它加载到原来的位置，而是紧紧跟在那已经被占用了的 512MB 内存后面。这样，我们就有了连续的 256MB 内存空间，就可以去加载一个新的 200MB 的程序。</p><p>如果你自己安装过 Linux 操作系统，你应该遇到过分配一个 swap 硬盘分区的问题。这块分出来的磁盘空间，其实就是专门给 Linux 操作系统进行内存交换用的。</p><p>硬盘的访问速度要比内存慢很多，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。</p><h4 id=内存分页>内存分页<a hidden class=anchor aria-hidden=true href=#内存分页>#</a></h4><p>既然问题出在内存碎片和内存交换的空间太大上，那么解决问题的办法就是，<strong>少出现一些内存碎片，并且让需要交换写入或者从磁盘装载的数据更少一点</strong>。于是就有了内存分页（Paging）。</p><p><strong>和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小</strong>。而对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。</p><p>从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。页的尺寸一般远远小于整个程序的大小。在 Linux 下，我们通常只设置成 4KB。</p><p><strong>由于内存空间都是预先划分好的，也就没有了不能使用的碎片</strong>，而只有被释放出来的很多 4KB 的页。即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，让整个机器被内存交换的过程给卡住。</p><p>分页的方式使得我们在加载程序的时候，<strong>不再需要一次性都把程序加载到物理内存中</strong>。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</p><p>实际上，我们的操作系统，的确是这么做的。当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的<strong>缺页错误</strong>（Page Fault）。我们的操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。</p><h2 id=动态链接>动态链接<a hidden class=anchor aria-hidden=true href=#动态链接>#</a></h2><p>如果我们有很多个程序都要通过装载器装载到内存里面，那里面链接好的同样的功能代码，也都需要再装载一遍，再占一遍内存空间。在一个运行上百个进程的系统中，这将会造成极大的资源浪费。</p><p>共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>（dynamic linking）是由一个叫做<strong>动态链接器</strong>（dynamic linker）的程序来执行的。Linux 中为<code>.so</code>文件，Windows 中为<code>.dll</code>文件。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203061034401.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203061034401.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h3 id=pic-position-independent-code>PIC （Position-Independent Code）<a hidden class=anchor aria-hidden=true href=#pic-position-independent-code>#</a></h3><p>要想要在程序运行的时候共享代码，也有一定的要求，就是这些机器码必须是“<strong>地址无关</strong>”的。也就是说，我们编译出来的共享库文件的指令代码，放在哪个内存地址都能正常运行。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203061037029.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202203061037029.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>对于所有动态链接共享库的程序来讲，虽然我们的<strong>共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的</strong>。我们没办法、也不应该要求动态链接同一个共享库的不同程序，必须把这个共享库所使用的虚拟内存地址变成一致。如果这样的话，我们写的程序就必须明确地知道内部的内存地址分配。</p><p>如何才能实现地址无关？</p><p>动态代码库内部的变量和函数调用都很容易解决，我们只需要使用<strong>相对地址</strong>（Relative Address）就好了。各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。因为整个共享库是放在一段连续的虚拟内存地址中的，无论装载到哪一段地址，不同指令之间的相对地址都是不变的。</p><h3 id=plt-和-got>PLT 和 GOT<a hidden class=anchor aria-hidden=true href=#plt-和-got>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// lib.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifndef LIB_H
</span></span></span><span class=line><span class=cl><span class=cp>#define LIB_H
</span></span></span><span class=line><span class=cl><span class=cp></span> 
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>show_me_the_money</span><span class=p>(</span><span class=kt>int</span> <span class=n>money</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// lib.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span> 
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>show_me_the_money</span><span class=p>(</span><span class=kt>int</span> <span class=n>money</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Show me USD %d from lib.c </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>money</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// show_me_poor.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;lib.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>money</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>show_me_the_money</span><span class=p>(</span><span class=n>money</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gcc lib.c -fPIC -shared -o lib.so
</span></span><span class=line><span class=cl>gcc -o show_me_poor show_me_poor.c ./lib.so
</span></span></code></pre></div><p><code>-fpic</code> 选项指示编译器生成与位置无关的代码。<code>-shared</code>选项指示链接器创建一个共享的目标文件。</p><p>然后，我们再通过 <code>gcc</code> 编译 <code>show_me_poor</code> 动态链接了 <code>lib.so</code> 的可执行文件。在这些操作都完成了之后，我们把 <code>show_me_poor</code> 这个文件通过 <code>objdump</code> 出来看一下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ objdump -d -M intel -S show_me_poor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>……
</span></span><span class=line><span class=cl>0000000000400540 &lt;show_me_the_money@plt-0x10&gt;:
</span></span><span class=line><span class=cl>  400540:       ff 35 12 05 20 00       push   QWORD PTR [rip+0x200512]        # 600a58 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;
</span></span><span class=line><span class=cl>  400546:       ff 25 14 05 20 00       jmp    QWORD PTR [rip+0x200514]        # 600a60 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;
</span></span><span class=line><span class=cl>  40054c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>0000000000400550 &lt;show_me_the_money@plt&gt;:
</span></span><span class=line><span class=cl>  400550:       ff 25 12 05 20 00       jmp    QWORD PTR [rip+0x200512]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt;
</span></span><span class=line><span class=cl>  400556:       68 00 00 00 00          push   0x0
</span></span><span class=line><span class=cl>  40055b:       e9 e0 ff ff ff          jmp    400540 &lt;_init+0x28&gt;
</span></span><span class=line><span class=cl>……
</span></span><span class=line><span class=cl>0000000000400676 &lt;main&gt;:
</span></span><span class=line><span class=cl>  400676:       55                      push   rbp
</span></span><span class=line><span class=cl>  400677:       48 89 e5                mov    rbp,rsp
</span></span><span class=line><span class=cl>  40067a:       48 83 ec 10             sub    rsp,0x10
</span></span><span class=line><span class=cl>  40067e:       c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5
</span></span><span class=line><span class=cl>  400685:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
</span></span><span class=line><span class=cl>  400688:       89 c7                   mov    edi,eax
</span></span><span class=line><span class=cl>  40068a:       e8 c1 fe ff ff          call   400550 &lt;show_me_the_money@plt&gt;
</span></span><span class=line><span class=cl>  40068f:       c9                      leave  
</span></span><span class=line><span class=cl>  400690:       c3                      ret    
</span></span><span class=line><span class=cl>  400691:       66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]
</span></span><span class=line><span class=cl>  400698:       00 00 00 
</span></span><span class=line><span class=cl>  40069b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]
</span></span><span class=line><span class=cl>……
</span></span></code></pre></div><p>在 <code>main</code> 函数调用 <code>show_me_the_money</code> 的函数的时候，对应的代码是这样的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>call   400550 &lt;show_me_the_money@plt&gt;
</span></span></code></pre></div><p>这里后面有一个<code>@plt</code> 的关键字，代表了我们需要从<code>PLT</code>，也就是<strong>过程链接表</strong>（Procedure Link Table）里面找要调用的函数。对应的地址呢，则是 <code>400550</code> 这个地址。</p><p>那当我们把目光挪到上面的 400550 这个地址，你又会看到里面进行了一次跳转，这个跳转指定的跳转地址，你可以在后面的注释里面可以看到，GLOBAL_OFFSET_TABLE+0x18。这里的 GLOBAL_OFFSET_TABLE，就是我接下来要说的全局偏移表。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  400550:       ff 25 12 05 20 00       jmp    QWORD PTR [rip+0x200512]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt;
</span></span></code></pre></div><p>在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张<strong>全局偏移表</strong>（GOT，Global Offset Table）。<strong>虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的</strong>。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。</p><p>虽然不同的程序调用的同样的动态库，各自的内存地址是独立的，调用的又都是同一个动态库，但是不需要去修改动态库里面的代码所使用的地址，而是各个程序各自维护好自己的 GOT，能够找到对应的动态库就好了。</p><h2 id=二进制编码>二进制编码<a hidden class=anchor aria-hidden=true href=#二进制编码>#</a></h2><p>原码表示法，左侧第一位是符号位，符号位为 1 时表示负数，为 0 时表示正数。
补码表示法，我们不再把这一位当成单独的符号位，在剩下几位计算出的十进制前加上正负号，而是在计算整个二进制值的时候，在左侧最高位前面加个负号。</p><p>比如，一个 4 位的二进制补码数值 1011，转换成十进制，就是
$-1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = -5$</p><p>一个 4 位的二进制数，可以表示从 -8 到 7 这 16 个整数，不会白白浪费一位。</p><p>字符集：表示的可以是字符的一个集合。比如说“第一版《新华字典》里面出现的所有汉字”，这是一个中文字符集。比如，我们日常说的<code>Unicode</code>，其实就是一个字符集，包含了 150 种语言的 14 万个不同的字符。</p><p>字符编码：对于字符集里的这些字符，怎么一一用二进制表示出来的一个字典。我们上面说的 <code>Unicode</code>，就可以用<code>UTF-8</code>、<code>UTF-16</code>，乃至 <code>UTF-32</code> 来进行编码，存储成二进制。</p><p>同样的文本，采用不同的编码存储下来。如果另外一个程序，用一种不同的编码方式来进行解码和展示，就会出现乱码。</p><h3 id=锟斤拷-烫烫烫>锟斤拷 烫烫烫<a hidden class=anchor aria-hidden=true href=#锟斤拷-烫烫烫>#</a></h3><p>Unicode 编码一直持续在收录各种字元，这就可能会出现各种作业系统支援的 Unicode 字元不一样。这也就会导致 A 上的一个用 Unicode 编码的字元，在 B 上就会出现无法显示的情况。为了避免这种情况，在 Unicode 中定义了一个特殊字元�，它的 Unicode 编码为 0xFFFD。</p><p>假如 A 支援特殊字元⬆，但是 B 并不支援这个⬆，那么在 B 中将会用�来代替。</p><p>这个字元用 UTF-8 编码后，十六进位表示为<code>0xEF 0XBF 0XBD</code>。如果连续出现两个⬆符号，那么用 UTF-8 编码后的十六进位则表示为<code>0xEF 0XBF 0XBD 0xEF 0XBF 0XBD</code>，这时候再转码成 GBK，因为 GBK 中用两个位元组表示一个字元，那么上述的字元就成了锟（<code>0xEFBF</code>），斤（<code>0xBDEF</code>），拷（<code>0xBFBD</code>）。出现锟斤拷的原因就是 UTF-8 转码 GBK 的过程中出现了问题。当然如果想要出现锟斤拷，则至少需要两个字元出现乱码。</p><p>而“烫烫烫”，则是因为如果你用了 Visual Studio 的调试器，默认使用 MBCS 字符集。“烫”在里面是由 <code>0xCCCC</code> 来表示的，而 <code>0xCC</code> 又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。</p><h2 id=理解电路>理解电路<a hidden class=anchor aria-hidden=true href=#理解电路>#</a></h2><p>从以上的学习可以知道，最终执行的程序都是二进制的指令。那为何计算机最终选择了二进制呢？接下来看看计算机在硬件层面究竟是怎么表示二进制的，以此你就会明白，为什么计算机会选择二进制。</p><h2 id=加法器>加法器<a hidden class=anchor aria-hidden=true href=#加法器>#</a></h2><h2 id=乘法器>乘法器<a hidden class=anchor aria-hidden=true href=#乘法器>#</a></h2><h2 id=浮点数和定点数>浮点数和定点数<a hidden class=anchor aria-hidden=true href=#浮点数和定点数>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://lifeislife.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/>计算机组成原理</a></li></ul><nav class=paginav><a class=prev href=https://lifeislife.cn/posts/rgb%E4%B8%8Eyuv%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/><span class=title>« 上一页</span><br><span>RGB 与 YUV 颜色空间</span>
</a><a class=next href=https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3openssl-ssl-read-connection-was-reset-errno-10054/><span class=title>下一页 »</span><br><span>解决 OpenSSL SSL_read: Connection was reset, errno 10054</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 计算机组成原理-指令和运算 on x" href="https://x.com/intent/tweet/?text=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86-%e6%8c%87%e4%bb%a4%e5%92%8c%e8%bf%90%e7%ae%97&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BB%2584%25E6%2588%2590%25E5%258E%259F%25E7%2590%2586-%25E6%258C%2587%25E4%25BB%25A4%25E5%2592%258C%25E8%25BF%2590%25E7%25AE%2597%2f&amp;hashtags=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 计算机组成原理-指令和运算 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BB%2584%25E6%2588%2590%25E5%258E%259F%25E7%2590%2586-%25E6%258C%2587%25E4%25BB%25A4%25E5%2592%258C%25E8%25BF%2590%25E7%25AE%2597%2f&amp;title=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86-%e6%8c%87%e4%bb%a4%e5%92%8c%e8%bf%90%e7%ae%97&amp;summary=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86-%e6%8c%87%e4%bb%a4%e5%92%8c%e8%bf%90%e7%ae%97&amp;source=https%3a%2f%2flifeislife.cn%2fposts%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BB%2584%25E6%2588%2590%25E5%258E%259F%25E7%2590%2586-%25E6%258C%2587%25E4%25BB%25A4%25E5%2592%258C%25E8%25BF%2590%25E7%25AE%2597%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 计算机组成原理-指令和运算 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BB%2584%25E6%2588%2590%25E5%258E%259F%25E7%2590%2586-%25E6%258C%2587%25E4%25BB%25A4%25E5%2592%258C%25E8%25BF%2590%25E7%25AE%2597%2f&title=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86-%e6%8c%87%e4%bb%a4%e5%92%8c%e8%bf%90%e7%ae%97"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 计算机组成原理-指令和运算 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifeislife.cn%2fposts%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BB%2584%25E6%2588%2590%25E5%258E%259F%25E7%2590%2586-%25E6%258C%2587%25E4%25BB%25A4%25E5%2592%258C%25E8%25BF%2590%25E7%25AE%2597%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 计算机组成原理-指令和运算 on whatsapp" href="https://api.whatsapp.com/send?text=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86-%e6%8c%87%e4%bb%a4%e5%92%8c%e8%bf%90%e7%ae%97%20-%20https%3a%2f%2flifeislife.cn%2fposts%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BB%2584%25E6%2588%2590%25E5%258E%259F%25E7%2590%2586-%25E6%258C%2587%25E4%25BB%25A4%25E5%2592%258C%25E8%25BF%2590%25E7%25AE%2597%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 计算机组成原理-指令和运算 on telegram" href="https://telegram.me/share/url?text=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86-%e6%8c%87%e4%bb%a4%e5%92%8c%e8%bf%90%e7%ae%97&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BB%2584%25E6%2588%2590%25E5%258E%259F%25E7%2590%2586-%25E6%258C%2587%25E4%25BB%25A4%25E5%2592%258C%25E8%25BF%2590%25E7%25AE%2597%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 计算机组成原理-指令和运算 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86-%e6%8c%87%e4%bb%a4%e5%92%8c%e8%bf%90%e7%ae%97&u=https%3a%2f%2flifeislife.cn%2fposts%2f%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BB%2584%25E6%2588%2590%25E5%258E%259F%25E7%2590%2586-%25E6%258C%2587%25E4%25BB%25A4%25E5%2592%258C%25E8%25BF%2590%25E7%25AE%2597%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://lifeislife-1.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://lifeislife.cn/>夜云泊</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>