<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>程序员的自我修养笔记 | 夜云泊</title><meta name=keywords content="读书笔记"><meta name=description content="静态链接
库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。
第三章 目标文件里有什么
目标文件的格式
目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。"><meta name=author content="Nic"><link rel=canonical href=https://lifeislife.cn/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.4490366ee59f83f7324bce1d2f81fb1ebba1a551f24577c75929014495a1d9b1.css integrity="sha256-RJA2buWfg/cyS84dL4H7HruhpVHyRXfHWSkBRJWh2bE=" rel="preload stylesheet" as=style><link rel=icon href=https://lifeislife.cn/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lifeislife.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lifeislife.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://lifeislife.cn/apple-touch-icon.png><link rel=mask-icon href=https://lifeislife.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lifeislife.cn/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PS8L2EEEPR")}</script><meta property="og:url" content="https://lifeislife.cn/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="夜云泊"><meta property="og:title" content="程序员的自我修养笔记"><meta property="og:description" content="静态链接 库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。
第三章 目标文件里有什么 目标文件的格式 目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-30T11:12:31+00:00"><meta property="article:modified_time" content="2022-03-30T11:12:31+00:00"><meta property="article:tag" content="读书笔记"><meta name=twitter:card content="summary"><meta name=twitter:title content="程序员的自我修养笔记"><meta name=twitter:description content="静态链接
库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。
第三章 目标文件里有什么
目标文件的格式
目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifeislife.cn/posts/"},{"@type":"ListItem","position":2,"name":"程序员的自我修养笔记","item":"https://lifeislife.cn/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"程序员的自我修养笔记","name":"程序员的自我修养笔记","description":"静态链接 库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。\n第三章 目标文件里有什么 目标文件的格式 目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。\n","keywords":["读书笔记"],"articleBody":"静态链接 库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。\n第三章 目标文件里有什么 目标文件的格式 目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。\n现在 PC 平台流形的可执行文件格式，主要是 Windows 下的 PE（Portable Executable）和 Linux 下的 ELF（Executable Linkable Format）,它们都是 COFF（Common file format）格式的变种。\n指令和数据分开存放的好处：\n一方面当程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被设置成可读写和只读，这样可以防止程序的指令被有意或无意地改写。\n另一方面是现代 CPU 有强大的缓存体系，由于缓存很重要，所以程序必须尽量提高缓存命中率。指令区和数据区分离有利于提高程序的局部性。现代 CPU 的缓存一般都被设计成数据缓存和指令缓存，所以程序的指令和数据分开存放对于 CPU 的缓存命中率提高有好处。\n第三个原因，也是最重要的原因，就是当系统中运行着多个该进程副本时，他们的指令都是一样的，所以内存中只需要保存一份程序的指令部分。\n真正了牛逼的程序员对自己的程序每一个字节都了如指掌。\nobjdump -h SimpleSsection.o # 打印elf文件各个段的信息 size SimpleSsection.o # 查看elf文件各个段的长度 objdump -s -d SimpleSsection.o # -s将所有段内容以十六进制打印，-d将所有包含指令的段反汇编 段名称 内容 .data - 初始化的全局变量 - 局部静态变量 .rodata 只读数据段，对这个段的任何修改都是非法的，保证了程序的安全性。 有时候编译器会把字符串放到 data 段\n- 只读变量 const 修饰 - 字符串常量 .bss 不占磁盘空间， - 未初始化的全局变量 - 未初始化的局部静态变量 - 初始化为 0 的静态变量 .comment 存放编译器版本信息，比如字符串“GCC：（GNU）4.2.0” .line 调试时的行号表，即源代码行号与编译后指令的对应表 .note 额外的编译器信息，如程序公司名，版本号 .symtab Symbol Table 符号表 .plt 动态链接的跳转表 .got 动态链接的全局入口表 段名称都是.前缀，表示这些表名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名称。比如可以加入一个music段，里面存一首 mp3 音乐，运行起来后就会播放音乐，打算自定义段不能使用.作为前缀，以免与系统保留段名冲突。\nQ: 如何将一个二进制文件，如图片，MP3 文件作为目标文件的一个段？ A: 可以使用 objcopy 工具，比如有一个图片 image..jpg，大小为 0x2100 字节： $ objcopy -I binary -O elf32-i388 -B i38 image.jpg image.o\n正常情况下编译出来的目标文件，代码会放到.text段，但是有时候你希望变量或者某些代码能放到你指定的段中去，以实现某些特定的功能。比如为了满足某些硬件的内存和 IO 地址布局。GCC 提供了扩展机制，使得程序员可以指定变量所处的段：\n__attribute__((section(\"FOO\"))) int global = 42; __attribute__((section(\"BAR\"))) void foo; ELF 文件结构 使用readelf命令查看 elf 文件详细信息。\nELF 魔数，确认文件类型。\n文件类型\n常量 值 含义 ET_REL 1 可重定位文件，一般问.o文件 ET_EXEC 2 可执行文件 ET_DYN 3 共享目标文件，一般为.so文件 机器类型\n常量 值 含义 EM_M32 1 AT\u0026T WE 32100 EM_SPARC 2 SPARC EM_M386 3 Intel x86 EM_68K 4 Motorola 68000 EM_88K 5 Motorola 88000 EM_860 6 Intel 80860 段表是保存各个段的基本属性的结构。段表是除文件头外最重要的结构。编译器，链接器和装载器都是依靠段表来定位和访问各个段的属性。\n链接的接口 - 符号 符号表结构 链接过程的本质就是要把多个不同的目标文件之间相互粘到一起。\n目标文件 B 要用到目标文件 A 的函数foo，我们称目标文件 A定义了函数foo，目标文件 B引用了目标文件 A 的函数foo。\n链接中，我们将函数和变量统称为符号，函数名或变量名就是符号名。、\n每一个目标文件都会有一个相应的符号表，表里记录了目标文件中所用到的所有符号。每个符号都有一个对应值，叫符号值，对于变量和函数来说，符号值就是他们的地址。\n符号类型：\n定义在本目标文件的全局符号，可以被其他目标引用。 在本目标文件中应用的全局符号，却没有定义在本目标文件。 段名称，也就是段起始地址。 局部符号，一些静态变量等。 行号信息。 最重要的就是第一类和第二类。链接只关心全局符号的相互粘合，其他都是次要的。\n可以使用 readelf objdump nm等命令查看符号信息。\n特殊符号 一些特殊符号，没有在程序中定义，但是可以直接声明并引用它：\n__executable_start，程序起始地址，不是入口地址，是程序最开始的地址。 __etext __etext etext 代码段结束地址，代码段最末尾的地址。 _edata edata 数据段结束地址，数据段最末尾地址。 __end end 程序结束地址。 符号修饰 符号应与对应的函数或者变量同名，但是在 C 语言发明时，已经存在了很多库和目标文件，如果再用一样的函数或变量就会冲突为了避免冲突，C 语言编译后符号名前会加上下划线_，如foo变成_foo，Fortran 语言编译后会在符号前后加上下划线_foo_。\nC++具有类，继承，重载等复杂机制，为了支持这些复杂特性，人们发明了符号修饰和符号改编。\n函数签名包含了一个函数的信息，包括函数名，参数类型，所在类和名称空间等信息。它用于识别不同的函数。在编译器和链接器处理符号时，使用某种名称修饰的方法，是的每个函数签名对应一个修饰后名称。\n由于不同的编译器采用不同的名字修饰方式，必然导致由不同编译器编译产生的目标文件无法正常互相链接，这是导致不同编译器之间不能互操作的主要原因之一。\nextern C C++为了兼容 C，C++编译器会将在extern C 的大括号内部的代码当做 C 语言代码处理，这样就不会使用 C++的名称修饰机制。（也就不会在编译的时候加上下划线）\n但是 C 语言并不支持extern C关键字，又不能为同一个库函数写两套头文件，这时候就可以用 C++的宏，__cplusplus。C++编译器会在编译 C++的程序时默认定义这个宏，我们可以用条件宏来判断当前编译单元是不是 C++代码。\n#ifdef __cplusplus extern \"C\" { #endif void *memset(void *, int , size_t); #ifdef __cplusplus } #endif 弱符号与强符号 我们经常碰到符号重定义，多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候就会出现符号重定义的错误。比如在两个文件中定义了相同的全局变量。\n对于C/C++来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。\n也可以使用 GCC 的__attribute__((weak))来定义任何一个强符号为弱符号。\n不允许强符号被多次定义，如果多次定义，则链接器报重复定义错误； 如果一个符号在某文件中是强符号，在其他文件中都是弱符号，那么选择强符号。 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。 第四章 静态链接 空间地址分配 可执行文件中的代码段和数据段就是多个文件合并而来的，对于多个文件链接器如何将它们合并到输出文件？\n按序叠加：最简单的方式，按照输入文件顺序依次合并。这会导致大量碎片，比如 x86 的硬件，段的装载地址和空间的对齐单位是页，也就是 4096 字节，那么如果一个段的长度只有 1 字节，它在内存里也要占用 4096 字节。\n相似段合并：将所有相同性质的段合并在一起。\n现在的链接器基本上采用第二种。使用这种方法的链接器都采用一种叫两步链接的方法。\n第一步，空间与地址分配。扫描所有的输入目标文件，并且获得各个段的长度，属性和位置，并将输入目标文件中的符号表所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步，链接器将能够获得所有输入目标文件的段长度，并且将他们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。\n第二部，符号解析与重定位。使用上面收集到的信息，读取输入文件中段的数据，重定位信息。并且进行符号解析与重定位，调整代码中的地址。\nVMA（Virtual Memory Address）虚拟地址，LMA（Load Memory Address）加载地址。正常情况这两个值是一样的。\n链接之前目标文件的所有短 VMA 都是 0，因为虚拟空间还没有被分配，默认为 0，链接之后各个段就会被分配相应的虚拟地址。\nLinux 下，ELF 可执行文件默认从地址0x8048000开始分配。\n符号解析与重定位 objdump -d 查看代码段反汇编结果 源代码在编译成目标文件时并不知道函数的调用地址。需要通过链接时重定位。\n链接器如何知道哪些指令需要被调整？这就用到了重定位表。\n重定位表就是 ELF 文件的一个段，所以其实重定位表也可以叫重定位段。\nobjdump -r 查看重定位表 每个要被重定位的地方叫一个重定位入口（Relocation Entry）。\n重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，或引用到定义在其他文件的符号。重定位过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，他就要确定这个符号的目标地址。这时候链接器就会取查找由所有输入目标文件的符号表组成的全局符号表，找到对应的符号进行重定位。\nreadelf -s 查看符号表 对于 32 位 x86 平台下的 ELF 文件的重定位入口所修正的指令寻址方式只有两种：\n绝对近址 32 位寻址 相对近址 32 位寻址 x86 基本重定位类型\n宏定义 值 重定位修正方法 R_386_32 1 绝对寻址修正 S+A R_386_PC32 2 相对寻址修正 S+A-P A = 保存在被修正位置的值 P = 被修正的位置 (相对于段开始的偏移量或者虚拟地址)，注意，该值可通过 r_offset 计算得到 S = 符号的实际地址，即由 r_info的高 24 位指定的符号的实际地址\n第六章 可执行文件的装载与进程 程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。\nCOMMON 块 Q:在目标文件中，编译器为什么不直接把未初始化的全局变量也当做未初始化的局部静态变量一样处理，为它在 BSS 段分配空间，而是将其标记为一个 COMMON 类型的变量？ A:当编译器将一个编译单元编译成目标文件时，如果该编译单元包含了弱符号（未初始化的全局变量就是典型），那么该弱符号最终所占大小未知，因为有可能其他编译单元中该符号所占空间比当前的大所以编译器此时无法为该符号在 BSS 段分配空间。但链接器在链接过程中可以确定弱符号大小，因为当链接器读取所有输入目标文件后，任何一个弱符号大小都可以确定，所以它可以在最终输出文件的 BSS 段为其分配空间。总体来看，未初始化全局变量最终还是被放在 BSS 段。\nGCC 的-fno-common吧所有未初始化的全局变量不以 COMMON 块形式处理。\n__attribute__扩展也可以实现，int global __attribute__((nocommon))。这样未初始化的全局变量就是强符号。\nQ: 为什么静态运行库里面一个目标文件只包含一个函数？比如 libc.o 里面 printf.o 只包含 printf() 函数，strlen.o 只有 strlen 函数？ A:因为链接器在链接静态库时是以目标文件为单位的，比如我们引用了静态库中的 printf 函数，那么链接器就会把库中包含 printf 函数的那个目标文件链接进来，如果很多函数写在一个目标文件中，就将没用到的函数一起链接进了输出结果中。\n链接的过程控制 第 6 章 可执行文件的装载与进程 程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。\n可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件又被叫做映像文件 (Image)。\nSegment 和 Section 很难从中文翻译上区分，ELF 文件按 Section 存储的，从装载的角度 ELF 文件又可以按照 Segment 划分。\n段地址对齐 可执行文件需要被装载，装载一般通过虚拟内存页映射机制完成，页是映射的最小单位，对于 x86 处理器来说，默认页大小为 4096 字节，所以内存空间的长度必须是 4096 的整数倍，并且这段空间在物理内存和进程虚拟地址空间的起始地址必须是 4096 的整数倍。\n第 7 章 动态链接 第七章 动态链接 为什么要动态链接？ 内存和磁盘空间：如果两个程序都用到一个静态库，链接时就会有静态库的两个副本，运行时就会占用两份内存。 程序的开发与发布：一个程序用到的静态库如果有更新，那么程序就需要重新链接，发布给用户。 要解决以上问题，最简单的方法就是把程序的模块相互分割开来，形成独立的文件，而不再将它们静态链接。就是不对目标文件进行链接，而等到程序运行时再链接。这就是动态链接的基本思想。\n动态链接模块的装载地址是从0x00000000开始的。\n共享对象的最终装载地址在编译时是不确定的。\n地址无关代码 静态共享库：将程序的各个模块交给操作系统管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。\n装载时重定位：程序在编译时被装载的目标地址为0x1000，但是在装载时操作系统发现0x1000这个地址已经被别的程序使用了，从0x4000开始有一块足够大的空间可以容纳，那么该程序就可以被装载至0x4000，程序指令和数据所有引用都只需要加上0x3000偏移量即可。因为他们在程序中的相对位置是不会改变的。\n地址无关代码为了解决共享对象指令中对绝对地址的重定位问题，基本想法是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。\n模块中四类地址引用：\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image 模块内部调用或者跳转 不需要重定位，本身就是地址无关的。\n模块内部数据访问 指令中不能包含数据的绝对地址，所以使用相对寻址的方式。\n模块间数据访问 把跟地址相关的部分放到数据段里面。ELF 的做法是在数据段里面建立一个指向这些数据的指针数据，称为全局偏移表（GOT）。当代码需要引用全局变量时，可以通过 GOT 间接引用。\n链接器在装载时会查找每个变量的地址，填充 GOT 每个项，当指令中需要访问变量时，程序会先找到 GOT，根据 GOT 中对应的地址，找到对应的变量。GOT 本身放在数据段，所以他可以在模块装载时被修改，并且每个进程有独立副本，相互不影响。\n以访问变量 b 为例，程序首先计算出变量 b 的地址在 GOT 中的位置，即\n0x10000000 + 0x454 + 0x118c + 0xfffffff8 = 0x100015d8\n0xfffffff8为-8的补码表示，然后使用寄存器间接寻址方式给变量 b 赋值 2。\n模块间调用跳转 类似于模块机数据访问，不同的是 GOT 中相应项保存的是目标函数的地址。\n各种地址引用方式\n指令跳转，调用 数据访问 模块内部 相对跳转和调用 相对地址访问 模块外部 间接跳转和调用（GOT） 间接访问（GOT） Q : -fpic 和-fPIC 的区别？ A: 都是 GCC 产生地址无关代码的参数。-fpic产生的代码较小，-fPIC产生的代码较大。因为地址无关代码和硬件平台相关，在一些平台上-fpic会受到限制，比如全局符号的数量或者代码长度等，而后者没有这样的限制。\nQ: 如果一个共享对象 lib.so 中定义了一个全局变量 G，进程 A 和进程 B 都是用了 lib.so。那么当进程 A 改变这个全局变量时，进程 B 的 G 是否受到影响？ A: 不会，应当 lib.so 被加载时，它的数据段部分在每个进程都有独立的副本。如果是同一个进程里的线程 A 和线程 B，那么他们是共享数据 G 的。\n如果代码不是地址无关的，它就不能被多个进程共享，就失去了节省内存的优点。但是装载是重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数是需要做一次计算当前地址以及间接地址寻址的过程。\n延迟绑定 PLT 动态链接要比静态链接慢，一是因为动态链接下，对全局和静态数据的访问都要进行复杂的 GOT 定位，然后间接寻址。另外，程序开始执行时，动态链接器都要进行一次链接工作。\n而在一个程序运行过程中，可能很多函数在程序执行完时都不会用到，如果一开始就把所有函数链接好实际就是一种浪费，所有 ELF 采用了一种叫做延迟绑定的做法，基本思想就是当函数第一次使用时才进行绑定（符号查找，重定位等）。\nELF 使用 PLT（Procedure Linkage Table）来实现延迟绑定。以调用bar()函数为例，之前的做法是通过 GOT 中的相应项进行跳转，而延迟绑定下，在这过程中间加了一层 PLT 间接跳转。每个外部函数在 PLT 中都有一个对应项，比如bar()在 PLT 中项的地址为bar@plt。\nbar@plt: jmp *(bar@GOT) push n push moduleID jump _dl_runtime_resolve 第一条是指令通过 GOT 间接跳转的指令，如果链接器在初始化阶段已经初始化该项，并将bar()地址填入该项，那么就能正确跳转到bar()。但是为了延迟绑定，链接器初始化时并没有将bar()地址填入，而是将第二条指令push n的地址填入了bar@GOT中，这一步不需要查找符号，代价很低。\n第一条指令的效果就是跳转到第二条指令，第二条指令将数字n压入堆栈，这个数字是bar这个符号引用在重定位表.rel.plt中的下标。第三条指令将模块 ID 压入堆栈，最后跳转到_dl_runtime_resolve。\n_dl_runtime_resolve进行一系列工作后将bar()真正地址填入到bar@GOT。\n一旦bar()这个函数被解析完，当面再次调用bar@plt时，第一条jump指令就能跳转到bar()的真正地址。bar()函数返回时根据堆栈里保存的EIP直接返回到调用者，而不会执行bar@plt中第二条指令。那段代码只会在符号未被解析时执行一次。\nPLT 在 ELF 文件中以独立段存在，段名通常叫做.plt，因为它本身是一些地址无关的代码，所以可以跟代码段合并成同一个可读可执行的 Segment 被装载入内存。\n动态链接相关结构 .interp 段\nobjdump -s a.out Contents of section .interp: 804811 2f6c6962 2f6c696d 6c696e78 782e736f /lib/ld-linux.so.2 里面保存的就是可执行文件所需要的动态链接器的路径，在 Linux 下，可执行文件动态链接器几乎都是/lib/ld-linux.so.2。\n这是个软链接，会他会指向系统中安装的动态链接器。当系统中的 Glibc 库更新时，软链接也会指向新的动态链接器，所以.interp段不需要修改。\n可以通过以下命令查看可执行文件需要的动态链接器的路径：\n$ readelf -l a.out | grep interpreter [Requesting program interpreter: /lib/ld-linux.so.2] .dynamic 段\n动态链接 ELF 中最重要的结构，这里保存了动态链接器所需要的基本信息，如依赖哪些共享对象，动态链接符号表的位置，动态链接重定位表的位置，共享对象初始化代码的地址等。\n动态符号表\nProgram1程序一来Lib.so，引用到了里面的foobar()函数，那么对于Program1来说，称Program1导入（Import）了foobar函数，foobar是Program1的导入函数。\n而站在Lib.so角度来说，它定义了foobar函数，我们称Lib.so导出（Export）了foobar函数，foobar是Lib.so的导出函数。\n为了表示动态链接这些模块之间的符号导入导出关系，ELF 专门有一个叫做动态符号表的段来保存这些信息，段名通常叫.dynsym。\n.dynsym只保存与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。\n动态链接重定位表\nPIC 模式的共享对象也需要重定位。\n对于使用 PIC 技术的可执行文件或共享对象来说，虽然代码段不需要重定位，但是数据段还包含了绝对地址的引用，因为代码段中绝对地址相关的部分被分离出来，变成了 GOT，而 GOT 实际上是数据段的一部分。\n目标文件的重定位在静态链接时完成，共享对象的重定位在装载时完成。\n目标文件里包含专门用于重定位信息的重定位表，比如.rel.text表示是代码段重定位表，.rel.data表示数据段重定位表。\n共享对象里类似的重定位表叫做.rel.dyn和.rel.plt。.rel.dyn实际上是对数据引用的修正，它所修正的位置位于.got以及数据段；.rel.plt实际上是对代码引用的修正，它所修正的位置位于.got.plt。\n用以下命令可以查看重定位表；\n\u003c!DOCTYPE html\u003e Responsive Image printf这个重定位入口，它的类型为R_386_JUMP_SLOT，它的偏移为0x000015d8。它实际位于.got.plt中，前三项是被系统占用的，第四项开始才是真正存放导入函数地址的地方，刚好是0x000015c8 + 4 * 3 = 0x000015d4，即__gmon_start__。\n当动态链接器要进行重定位时，先查找printf的地址，假设链接器在全局符号表中找到printf的地址为0x08801234，那么链接器就会将这个地址填入.got.plt中偏移为0x000015d8的位置。从而实现了地址重定位，即动态链接最关键的一步。\n\u003c!DOCTYPE html\u003e Responsive Image 动态链接时进程堆栈初始化信息 动态链接的步骤和实现 动态链接分为三步：启动动态链接本身，装载所有的共享对象，重定位和初始化。\nQ：动态链接器本身是动态链接还是静态链接？ A：动态链接器本身应该是静态链接的，它不能依赖于其他共享对象，动态链接器本身使用来帮助其他 ELF 文件解决共享对象依赖问题的，如果它也依赖其他共享对象，那就陷入矛盾了。\nQ：动态链接器本身必须是 PIC 的吗？ A：动态链接器可以是 PIC 的也可以不是，但是往往用 PIC 会简单一些。\nQ：动态链接器可以被当做可执行文件运行，那么它的装载地址是多少？ A：ld.so 的装载地址跟一般的共享对象一样，即0x00000000。这个装载地址是一个无效的装载地址，作为一个共享库，内核在装载它时会为其选择一个合适的装载地址。\n显示运行时链接 第 10 章 内存 程序的内存布局 在 32 位操作系统里，有 4GB 的寻址能力，大部分操作系统会将一部分挪给内核使用，应用程序无法直接访问这段内存。这部分称为内核空间。Windows 默认将高地址的 2GB 分给内核，Linux 默认分 1GB 给内核。\n剩下的称为用户空间，在用户空间里也有一些特殊的地址区间：\n栈：维护函数调用上下文，通常在用户空间的最高地址处分配。 堆：用来容纳程序动态分配的内存区域，当使用 malloc 或者 new 分配内存时，得到的内存来自于堆。通常在栈下方。 可执行文件映像：存储可执行文件再内存里的映像，由装载器在装载时将可执行文件的内存读取活映射到这里。 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。比如NULL。 \u003c!DOCTYPE html\u003e Responsive Image 栈与调用惯例 栈保存了一个函数调用所需要的维护信息，通常这被称为栈帧。一般包括如下几个方面：\n函数的返回地址和参数 临时变量 保存的上下文 一个函数的调用流程：\n\u003c!DOCTYPE html\u003e Responsive Image \u003c!DOCTYPE html\u003e Responsive Image I386 标准函数进入和退出指令序列，基本形式：\npush ebp mov ebp, esp sub esp, x [push reg1] ... [push regn] 函数实际内存 [pop regn] ... [pop reg1] mov esp, ebp pop ebp ret Hot Patch Prologue 热补丁 在 Windows 函数里，有些函数尽管使用了标准的进入指令序列，但是在这些指令之前却插入了一些特殊内容：\nmov edi,edi 这条指令没有任何用，在汇编之后会成为一个占用 2 字节的机器码，纯粹为了占位符而存在，使用这条指令开头的函数整体看起来是这样的：\nnop nop nop nop nop FUNCTION: mov edi,edi push ebp mov ebp, esp 其中 nop 占 1 个字节，也是占位符，FUNCTION 为一个标号，表示函数入口，本身不占空间。\n设计成这样的函数在运行时可以很容易被其他函数替换掉，在上面的指令序列中调用的函数是 FUNCTION，但是我们可以做一些修改，可以在运行时刻意改成调用函数 REPLACEMENT_FUNCTION。首先在进程内存空间任意处写入 REPLACEMENT_FUNCTION 的定义：\nREPLACEMENT_FUNCTION: push ebp mov ebp, esp ... mov esp, ebp pop ebp ret 然后修改原函数的内容：\nLABEL: # 标号不占字节 jmp REPLACEMENT_FUNCTION # 占5字节，刚好五个nop FUNCTION: # 函数入口标号，不占字节 jmp LABEL # 近跳指令，占2字节，跳跃到上方，即使截获失败也不影响原函数执行 push ebp mov ebp, esp ... 将 5 个nop换成一个jmp指令，然后将占用两个字节的mov edi,edi换成另一个jmp指令。因为这个jmp指令跳转的距离非常近，因此被汇编器翻译成了一个“近跳”指令，这种指令只占用两个字节。但只能跳跃到当前地址前后 127 个字节范围的目标位置。\n这里的替换机制，可以实现一种叫做钩子（HOOK）的技术，允许用户在某时刻截获特定函数的调用。\n函数传递参数时压栈顺序，传递参数是寄存器传参还是栈传参等等都需要遵守一定的约定，否则函数将无法正确执行，这样的约定称为调用惯例。\n一个调用惯例一般会规定如下几个方面：\n函数参数的传递顺序和方式 调用方压栈，函数自己从栈用取参数 调用方压栈顺序：从左至右，还是从右至左？ 栈的维护方式 参数出栈，可以由调用方完成还是由函数自己完成？ 名字修饰的策略 为了链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰，不同调用惯例有不同的名字修饰策略 没有显示指定调用惯例的函数默认是cdecl惯例 int _cdecl foo(int n, float m) _cdel 是非标准关键字，在不同编译器中写法不同，在 gcc 中使用的是__attribute__((cdecl))\n附录 文件名 英文名 Linux 扩展名 英文名 Windows 扩展名 功能 DSO-Dynamic Shared Objects ELF 动态链接文件，动态共享对象，共享对象 .so DLL-Dynamic Linking Library 动态链接库 .dll 1111 Static Shared Library 静态共享库 2222 2222 2222 2222 2222 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 ","wordCount":"9668","inLanguage":"zh","datePublished":"2022-03-30T11:12:31Z","dateModified":"2022-03-30T11:12:31Z","author":{"@type":"Person","name":"Nic"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifeislife.cn/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"夜云泊","logo":{"@type":"ImageObject","url":"https://lifeislife.cn/assets/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script defer src=/static/fontawesome/fontawesome-all.js></script><header class=header><nav class=nav><div class=logo><a href=https://lifeislife.cn/ accesskey=h title="夜云泊 (Alt + H)">夜云泊</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lifeislife.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://lifeislife.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://lifeislife.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://lifeislife.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://lifeislife.cn/awesome-cycling/ title=AwesomeCycling><span>AwesomeCycling</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.travellings.cn/go.html title=开往><span><i class='fa-solid fa-train-subway'></i>开往</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lifeislife.cn/>主页</a>&nbsp;»&nbsp;<a href=https://lifeislife.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">程序员的自我修养笔记</h1><div class=post-meta><span title='2022-03-30 11:12:31 +0000 UTC'>三月 30, 2022</span>&nbsp;·&nbsp;20 分钟&nbsp;·&nbsp;9668 字&nbsp;·&nbsp;Nic</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#静态链接>静态链接</a></li><li><a href=#第三章-目标文件里有什么>第三章 目标文件里有什么</a><ul><li><a href=#目标文件的格式>目标文件的格式</a></li><li><a href=#elf-文件结构>ELF 文件结构</a></li><li><a href=#链接的接口---符号>链接的接口 - 符号</a></li></ul></li><li><a href=#第四章-静态链接>第四章 静态链接</a><ul><li><a href=#空间地址分配>空间地址分配</a></li><li><a href=#符号解析与重定位>符号解析与重定位</a></li></ul></li><li><a href=#第六章-可执行文件的装载与进程>第六章 可执行文件的装载与进程</a><ul><li><a href=#common-块>COMMON 块</a></li><li><a href=#链接的过程控制>链接的过程控制</a></li></ul></li><li><a href=#第-6-章-可执行文件的装载与进程>第 6 章 可执行文件的装载与进程</a><ul><li></li></ul></li><li><a href=#第-7-章-动态链接>第 7 章 动态链接</a></li><li><a href=#第七章-动态链接>第七章 动态链接</a><ul><li><a href=#为什么要动态链接>为什么要动态链接？</a></li><li><a href=#地址无关代码>地址无关代码</a></li><li><a href=#延迟绑定-plt>延迟绑定 PLT</a></li><li><a href=#动态链接相关结构>动态链接相关结构</a></li><li><a href=#动态链接时进程堆栈初始化信息>动态链接时进程堆栈初始化信息</a></li><li><a href=#动态链接的步骤和实现>动态链接的步骤和实现</a></li><li><a href=#显示运行时链接>显示运行时链接</a></li></ul></li><li><a href=#第-10-章-内存>第 10 章 内存</a><ul><li><a href=#程序的内存布局>程序的内存布局</a></li><li><a href=#栈与调用惯例>栈与调用惯例</a></li></ul></li><li><a href=#附录>附录</a><ul><li><a href=#文件名>文件名</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=静态链接>静态链接<a hidden class=anchor aria-hidden=true href=#静态链接>#</a></h2><p>库是一组目标文件的包，就是一些常用的代码编译成目标文件后打包存放。</p><h2 id=第三章-目标文件里有什么>第三章 目标文件里有什么<a hidden class=anchor aria-hidden=true href=#第三章-目标文件里有什么>#</a></h2><h3 id=目标文件的格式>目标文件的格式<a hidden class=anchor aria-hidden=true href=#目标文件的格式>#</a></h3><p><strong>目标文件</strong>从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。</p><p>现在 PC 平台流形的可执行文件格式，主要是 Windows 下的 PE（Portable Executable）和 Linux 下的 ELF（Executable Linkable Format）,它们都是 COFF（Common file format）格式的变种。</p><p>指令和数据分开存放的好处：</p><ul><li><p>一方面当程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被设置成可读写和只读，这样可以防止程序的指令被有意或无意地改写。</p></li><li><p>另一方面是现代 CPU 有强大的缓存体系，由于缓存很重要，所以程序必须尽量提高缓存命中率。指令区和数据区分离有利于提高程序的局部性。现代 CPU 的缓存一般都被设计成数据缓存和指令缓存，所以程序的指令和数据分开存放对于 CPU 的缓存命中率提高有好处。</p></li><li><p>第三个原因，也是最重要的原因，就是当系统中运行着多个该进程副本时，他们的指令都是一样的，所以内存中只需要保存一份程序的指令部分。</p></li></ul><p><strong>真正了牛逼的程序员对自己的程序每一个字节都了如指掌。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>objdump -h  SimpleSsection.o  # 打印elf文件各个段的信息
</span></span><span class=line><span class=cl>size SimpleSsection.o           # 查看elf文件各个段的长度
</span></span><span class=line><span class=cl>objdump -s -d SimpleSsection.o # -s将所有段内容以十六进制打印，-d将所有包含指令的段反汇编
</span></span></code></pre></div><table><thead><tr><th>段名称</th><th>内容</th></tr></thead><tbody><tr><td>.data</td><td>- 初始化的全局变量<br>- 局部静态变量</td></tr><tr><td>.rodata</td><td>只读数据段，对这个段的任何修改都是非法的，保证了程序的安全性。<br>有时候编译器会把字符串放到 data 段<br>- 只读变量 const 修饰<br>- 字符串常量</td></tr><tr><td>.bss</td><td>不占磁盘空间，<br>- 未初始化的全局变量<br>- 未初始化的局部静态变量<br>- 初始化为 0 的静态变量</td></tr><tr><td>.comment</td><td>存放编译器版本信息，比如字符串“GCC：（GNU）4.2.0”</td></tr><tr><td>.line</td><td>调试时的行号表，即源代码行号与编译后指令的对应表</td></tr><tr><td>.note</td><td>额外的编译器信息，如程序公司名，版本号</td></tr><tr><td>.symtab</td><td>Symbol Table 符号表</td></tr><tr><td>.plt</td><td>动态链接的跳转表</td></tr><tr><td>.got</td><td>动态链接的全局入口表</td></tr></tbody></table><p>段名称都是<code>.</code>前缀，表示这些表名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名称。比如可以加入一个<code>music</code>段，里面存一首 mp3 音乐，运行起来后就会播放音乐，打算自定义段不能使用<code>.</code>作为前缀，以免与系统保留段名冲突。</p><blockquote><p>Q: 如何将一个二进制文件，如图片，MP3 文件作为目标文件的一个段？
A: 可以使用 objcopy 工具，比如有一个图片 image..jpg，大小为 0x2100 字节：
$ objcopy -I binary -O elf32-i388 -B i38 image.jpg image.o</p></blockquote><p>正常情况下编译出来的目标文件，代码会放到<code>.text</code>段，但是有时候你希望变量或者某些代码能放到你指定的段中去，以实现某些特定的功能。比如为了满足某些硬件的内存和 IO 地址布局。GCC 提供了扩展机制，使得程序员可以指定变量所处的段：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>__attribute__((section(&#34;FOO&#34;))) int global = 42;
</span></span><span class=line><span class=cl>__attribute__((section(&#34;BAR&#34;))) void foo;
</span></span></code></pre></div><h3 id=elf-文件结构>ELF 文件结构<a hidden class=anchor aria-hidden=true href=#elf-文件结构>#</a></h3><p>使用<code>readelf</code>命令查看 elf 文件详细信息。</p><ul><li><p>ELF 魔数，确认文件类型。</p></li><li><p>文件类型</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>ET_REL</td><td>1</td><td>可重定位文件，一般问.o文件</td></tr><tr><td>ET_EXEC</td><td>2</td><td>可执行文件</td></tr><tr><td>ET_DYN</td><td>3</td><td>共享目标文件，一般为.so文件</td></tr></tbody></table></li><li><p>机器类型</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>EM_M32</td><td>1</td><td>AT&amp;T WE 32100</td></tr><tr><td>EM_SPARC</td><td>2</td><td>SPARC</td></tr><tr><td>EM_M386</td><td>3</td><td>Intel x86</td></tr><tr><td>EM_68K</td><td>4</td><td>Motorola 68000</td></tr><tr><td>EM_88K</td><td>5</td><td>Motorola 88000</td></tr><tr><td>EM_860</td><td>6</td><td>Intel 80860</td></tr></tbody></table></li></ul><p><strong>段表</strong>是保存各个段的基本属性的结构。段表是除文件头外最重要的结构。编译器，链接器和装载器都是依靠段表来定位和访问各个段的属性。</p><h3 id=链接的接口---符号>链接的接口 - 符号<a hidden class=anchor aria-hidden=true href=#链接的接口---符号>#</a></h3><h4 id=符号表结构>符号表结构<a hidden class=anchor aria-hidden=true href=#符号表结构>#</a></h4><p>链接过程的本质就是要把多个不同的目标文件之间相互粘到一起。</p><p>目标文件 B 要用到目标文件 A 的函数<code>foo</code>，我们称目标文件 A<strong>定义</strong>了函数<code>foo</code>，目标文件 B<strong>引用</strong>了目标文件 A 的函数<code>foo</code>。</p><p>链接中，我们将函数和变量统称为<strong>符号</strong>，函数名或变量名就是符号名。、</p><p>每一个目标文件都会有一个相应的符号表，表里记录了目标文件中所用到的所有符号。每个符号都有一个对应值，叫符号值，对于变量和函数来说，符号值就是他们的地址。</p><p>符号类型：</p><ul><li>定义在本目标文件的全局符号，可以被其他目标引用。</li><li>在本目标文件中应用的全局符号，却没有定义在本目标文件。</li><li>段名称，也就是段起始地址。</li><li>局部符号，一些静态变量等。</li><li>行号信息。</li></ul><p>最重要的就是第一类和第二类。链接只关心全局符号的相互粘合，其他都是次要的。</p><p>可以使用 <code>readelf</code> <code>objdump</code> <code>nm</code>等命令查看符号信息。</p><h4 id=特殊符号>特殊符号<a hidden class=anchor aria-hidden=true href=#特殊符号>#</a></h4><p>一些特殊符号，没有在程序中定义，但是可以直接声明并引用它：</p><ul><li><code>__executable_start</code>，程序起始地址，不是入口地址，是程序最开始的地址。</li><li><code>__etext</code> <code>__etext</code> <code>etext</code> 代码段结束地址，代码段最末尾的地址。</li><li><code>_edata</code> <code>edata</code> 数据段结束地址，数据段最末尾地址。</li><li><code>__end</code> <code>end</code> 程序结束地址。</li></ul><h4 id=符号修饰>符号修饰<a hidden class=anchor aria-hidden=true href=#符号修饰>#</a></h4><p>符号应与对应的函数或者变量同名，但是在 C 语言发明时，已经存在了很多库和目标文件，如果再用一样的函数或变量就会冲突为了避免冲突，C 语言编译后符号名前会加上下划线<code>_</code>，如<code>foo</code>变成<code>_foo</code>，Fortran 语言编译后会在符号前后加上下划线<code>_foo_</code>。</p><p>C++具有类，继承，重载等复杂机制，为了支持这些复杂特性，人们发明了<strong>符号修饰</strong>和<strong>符号改编</strong>。</p><p><strong>函数签名</strong>包含了一个函数的信息，包括函数名，参数类型，所在类和名称空间等信息。它用于识别不同的函数。在编译器和链接器处理符号时，使用某种名称修饰的方法，是的每个函数签名对应一个<strong>修饰后名称</strong>。</p><p>由于不同的编译器采用不同的名字修饰方式，必然导致由不同编译器编译产生的目标文件无法正常互相链接，这是导致不同编译器之间不能互操作的主要原因之一。</p><h4 id=extern-c>extern C<a hidden class=anchor aria-hidden=true href=#extern-c>#</a></h4><p>C++为了兼容 C，C++编译器会将在<code>extern C</code> 的大括号内部的代码当做 C 语言代码处理，这样就不会使用 C++的名称修饰机制。（也就不会在编译的时候加上下划线）</p><p>但是 C 语言并不支持<code>extern C</code>关键字，又不能为同一个库函数写两套头文件，这时候就可以用 C++的宏，<code>__cplusplus</code>。C++编译器会在编译 C++的程序时默认定义这个宏，我们可以用条件宏来判断当前编译单元是不是 C++代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>memset</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>,</span> <span class=kt>int</span> <span class=p>,</span> <span class=kt>size_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><h4 id=弱符号与强符号>弱符号与强符号<a hidden class=anchor aria-hidden=true href=#弱符号与强符号>#</a></h4><p>我们经常碰到符号重定义，多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候就会出现符号重定义的错误。比如在两个文件中定义了相同的全局变量。</p><p>对于C/C++来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。</p><p>也可以使用 GCC 的<code>__attribute__((weak))</code>来定义任何一个强符号为弱符号。</p><ul><li>不允许强符号被多次定义，如果多次定义，则链接器报重复定义错误；</li><li>如果一个符号在某文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</li><li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。</li></ul><h2 id=第四章-静态链接>第四章 静态链接<a hidden class=anchor aria-hidden=true href=#第四章-静态链接>#</a></h2><h3 id=空间地址分配>空间地址分配<a hidden class=anchor aria-hidden=true href=#空间地址分配>#</a></h3><p>可执行文件中的代码段和数据段就是多个文件合并而来的，对于多个文件链接器如何将它们合并到输出文件？</p><p>按序叠加：最简单的方式，按照输入文件顺序依次合并。这会导致大量碎片，比如 x86 的硬件，段的装载地址和空间的对齐单位是页，也就是 4096 字节，那么如果一个段的长度只有 1 字节，它在内存里也要占用 4096 字节。</p><p>相似段合并：将所有相同性质的段合并在一起。</p><p>现在的链接器基本上采用第二种。使用这种方法的链接器都采用一种叫两步链接的方法。</p><p>第一步，空间与地址分配。扫描所有的输入目标文件，并且获得各个段的长度，属性和位置，并将输入目标文件中的符号表所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步，链接器将能够获得所有输入目标文件的段长度，并且将他们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。</p><p>第二部，符号解析与重定位。使用上面收集到的信息，读取输入文件中段的数据，重定位信息。并且进行符号解析与重定位，调整代码中的地址。</p><p>VMA（Virtual Memory Address）虚拟地址，LMA（Load Memory Address）加载地址。正常情况这两个值是一样的。</p><p>链接之前目标文件的所有短 VMA 都是 0，因为虚拟空间还没有被分配，默认为 0，链接之后各个段就会被分配相应的虚拟地址。</p><p>Linux 下，ELF 可执行文件默认从地址<code>0x8048000</code>开始分配。</p><h3 id=符号解析与重定位>符号解析与重定位<a hidden class=anchor aria-hidden=true href=#符号解析与重定位>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>objdump -d  查看代码段反汇编结果
</span></span></code></pre></div><p>源代码在编译成目标文件时并不知道函数的调用地址。需要通过链接时重定位。</p><p>链接器如何知道哪些指令需要被调整？这就用到了<strong>重定位表</strong>。</p><p>重定位表就是 ELF 文件的一个段，所以其实重定位表也可以叫重定位段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>objdump -r 查看重定位表
</span></span></code></pre></div><p>每个要被重定位的地方叫一个重定位入口（Relocation Entry）。</p><p>重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，或引用到定义在其他文件的符号。重定位过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，他就要确定这个符号的目标地址。这时候链接器就会取查找由所有输入目标文件的符号表组成的全局符号表，找到对应的符号进行重定位。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>readelf -s 查看符号表
</span></span></code></pre></div><p>对于 32 位 x86 平台下的 ELF 文件的重定位入口所修正的指令寻址方式只有两种：</p><ul><li>绝对近址 32 位寻址</li><li>相对近址 32 位寻址</li></ul><p>x86 基本重定位类型</p><table><thead><tr><th>宏定义</th><th>值</th><th>重定位修正方法</th></tr></thead><tbody><tr><td>R_386_32</td><td>1</td><td>绝对寻址修正 S+A</td></tr><tr><td>R_386_PC32</td><td>2</td><td>相对寻址修正 S+A-P</td></tr></tbody></table><p>A = 保存在被修正位置的值
P = 被修正的位置 (相对于段开始的偏移量或者虚拟地址)，注意，该值可通过 r_offset 计算得到
S = 符号的实际地址，即由 <code>r_info</code>的高 24 位指定的符号的实际地址</p><h2 id=第六章-可执行文件的装载与进程>第六章 可执行文件的装载与进程<a hidden class=anchor aria-hidden=true href=#第六章-可执行文件的装载与进程>#</a></h2><p>程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。</p><h3 id=common-块>COMMON 块<a hidden class=anchor aria-hidden=true href=#common-块>#</a></h3><blockquote><p>Q:在目标文件中，编译器为什么不直接把未初始化的全局变量也当做未初始化的局部静态变量一样处理，为它在 BSS 段分配空间，而是将其标记为一个 COMMON 类型的变量？
A:当编译器将一个编译单元编译成目标文件时，如果该编译单元包含了弱符号（未初始化的全局变量就是典型），那么该弱符号最终所占大小未知，因为有可能其他编译单元中该符号所占空间比当前的大所以编译器此时无法为该符号在 BSS 段分配空间。但链接器在链接过程中可以确定弱符号大小，因为当链接器读取所有输入目标文件后，任何一个弱符号大小都可以确定，所以它可以在最终输出文件的 BSS 段为其分配空间。总体来看，未初始化全局变量最终还是被放在 BSS 段。</p></blockquote><p>GCC 的<code>-fno-common</code>吧所有未初始化的全局变量不以 COMMON 块形式处理。</p><p><code>__attribute__</code>扩展也可以实现，<code>int global __attribute__((nocommon))</code>。这样未初始化的全局变量就是强符号。</p><blockquote><p>Q: 为什么静态运行库里面一个目标文件只包含一个函数？比如 libc.o 里面 printf.o 只包含 printf() 函数，strlen.o 只有 strlen 函数？
A:因为链接器在链接静态库时是以目标文件为单位的，比如我们引用了静态库中的 printf 函数，那么链接器就会把库中包含 printf 函数的那个目标文件链接进来，如果很多函数写在一个目标文件中，就将没用到的函数一起链接进了输出结果中。</p></blockquote><h3 id=链接的过程控制>链接的过程控制<a hidden class=anchor aria-hidden=true href=#链接的过程控制>#</a></h3><h2 id=第-6-章-可执行文件的装载与进程>第 6 章 可执行文件的装载与进程<a hidden class=anchor aria-hidden=true href=#第-6-章-可执行文件的装载与进程>#</a></h2><p>程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里，这就是动态载入的基本原理。</p><p><strong>可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件又被叫做映像文件 (Image)。</strong></p><p>Segment 和 Section 很难从中文翻译上区分，ELF 文件按 Section 存储的，从装载的角度 ELF 文件又可以按照 Segment 划分。</p><h4 id=段地址对齐>段地址对齐<a hidden class=anchor aria-hidden=true href=#段地址对齐>#</a></h4><p>可执行文件需要被装载，装载一般通过虚拟内存页映射机制完成，页是映射的最小单位，对于 x86 处理器来说，默认页大小为 4096 字节，所以内存空间的长度必须是 4096 的整数倍，并且这段空间在物理内存和进程虚拟地址空间的起始地址必须是 4096 的整数倍。</p><h2 id=第-7-章-动态链接>第 7 章 动态链接<a hidden class=anchor aria-hidden=true href=#第-7-章-动态链接>#</a></h2><h2 id=第七章-动态链接>第七章 动态链接<a hidden class=anchor aria-hidden=true href=#第七章-动态链接>#</a></h2><h3 id=为什么要动态链接>为什么要动态链接？<a hidden class=anchor aria-hidden=true href=#为什么要动态链接>#</a></h3><ul><li>内存和磁盘空间：如果两个程序都用到一个静态库，链接时就会有静态库的两个副本，运行时就会占用两份内存。</li><li>程序的开发与发布：一个程序用到的静态库如果有更新，那么程序就需要重新链接，发布给用户。</li></ul><p>要解决以上问题，最简单的方法就是把程序的模块相互分割开来，形成独立的文件，而不再将它们静态链接。就是不对目标文件进行链接，而等到程序运行时再链接。这就是<strong>动态链接的基本思想</strong>。</p><p>动态链接模块的装载地址是从<code>0x00000000</code>开始的。</p><p>共享对象的最终装载地址在编译时是不确定的。</p><h3 id=地址无关代码>地址无关代码<a hidden class=anchor aria-hidden=true href=#地址无关代码>#</a></h3><p>静态共享库：将程序的各个模块交给操作系统管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。</p><p><strong>装载时重定位</strong>：程序在编译时被装载的目标地址为<code>0x1000</code>，但是在装载时操作系统发现<code>0x1000</code>这个地址已经被别的程序使用了，从<code>0x4000</code>开始有一块足够大的空间可以容纳，那么该程序就可以被装载至<code>0x4000</code>，程序指令和数据所有引用都只需要加上<code>0x3000</code>偏移量即可。因为他们在程序中的相对位置是不会改变的。</p><p>地址无关代码为了解决共享对象指令中对绝对地址的重定位问题，基本想法是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>模块中四类地址引用：</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204092152653.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204092152653.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101004886.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101004886.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101004869.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101004869.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p><strong>模块内部调用或者跳转</strong>
不需要重定位，本身就是地址无关的。</p><p><strong>模块内部数据访问</strong>
指令中不能包含数据的绝对地址，所以使用相对寻址的方式。</p><p><strong>模块间数据访问</strong>
把跟地址相关的部分放到数据段里面。ELF 的做法是在数据段里面建立一个指向这些数据的指针数据，称为<strong>全局偏移表</strong>（GOT）。当代码需要引用全局变量时，可以通过 GOT 间接引用。</p><p>链接器在装载时会查找每个变量的地址，填充 GOT 每个项，当指令中需要访问变量时，程序会先找到 GOT，根据 GOT 中对应的地址，找到对应的变量。GOT 本身放在数据段，所以他可以在模块装载时被修改，并且每个进程有独立副本，相互不影响。</p><p>以访问变量 b 为例，程序首先计算出变量 b 的地址在 GOT 中的位置，即</p><p><code>0x10000000 + 0x454 + 0x118c + 0xfffffff8 = 0x100015d8</code></p><p><code>0xfffffff8</code>为<code>-8</code>的补码表示，然后使用寄存器间接寻址方式给变量 b 赋值 2。</p><p><strong>模块间调用跳转</strong>
类似于模块机数据访问，不同的是 GOT 中相应项保存的是目标函数的地址。</p><hr><p><strong>各种地址引用方式</strong></p><table><thead><tr><th></th><th>指令跳转，调用</th><th>数据访问</th></tr></thead><tbody><tr><td>模块内部</td><td>相对跳转和调用</td><td>相对地址访问</td></tr><tr><td>模块外部</td><td>间接跳转和调用（GOT）</td><td>间接访问（GOT）</td></tr></tbody></table><hr><blockquote><p>Q : -fpic 和-fPIC 的区别？
A: 都是 GCC 产生地址无关代码的参数。<code>-fpic</code>产生的代码较小，<code>-fPIC</code>产生的代码较大。因为地址无关代码和硬件平台相关，在一些平台上<code>-fpic</code>会受到限制，比如全局符号的数量或者代码长度等，而后者没有这样的限制。</p></blockquote><blockquote><p>Q: 如果一个共享对象 lib.so 中定义了一个全局变量 G，进程 A 和进程 B 都是用了 lib.so。那么当进程 A 改变这个全局变量时，进程 B 的 G 是否受到影响？
A: 不会，应当 lib.so 被加载时，它的数据段部分在每个进程都有独立的副本。如果是同一个进程里的线程 A 和线程 B，那么他们是共享数据 G 的。</p></blockquote><p>如果代码不是地址无关的，它就不能被多个进程共享，就失去了节省内存的优点。但是装载是重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数是需要做一次计算当前地址以及间接地址寻址的过程。</p><h3 id=延迟绑定-plt>延迟绑定 PLT<a hidden class=anchor aria-hidden=true href=#延迟绑定-plt>#</a></h3><p>动态链接要比静态链接慢，一是因为动态链接下，对全局和静态数据的访问都要进行复杂的 GOT 定位，然后间接寻址。另外，程序开始执行时，动态链接器都要进行一次链接工作。</p><p>而在一个程序运行过程中，可能很多函数在程序执行完时都不会用到，如果一开始就把所有函数链接好实际就是一种浪费，所有 ELF 采用了一种叫做延迟绑定的做法，基本思想就是当函数<strong>第一次使用时</strong>才进行绑定（符号查找，重定位等）。</p><p>ELF 使用 PLT（Procedure Linkage Table）来实现延迟绑定。以调用<code>bar()</code>函数为例，之前的做法是通过 GOT 中的相应项进行跳转，而延迟绑定下，在这过程中间加了一层 PLT 间接跳转。每个外部函数在 PLT 中都有一个对应项，比如<code>bar()</code>在 PLT 中项的地址为<code>bar@plt</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>bar@plt:
</span></span><span class=line><span class=cl>    jmp *(bar@GOT)
</span></span><span class=line><span class=cl>    push n
</span></span><span class=line><span class=cl>    push moduleID
</span></span><span class=line><span class=cl>    jump _dl_runtime_resolve
</span></span></code></pre></div><p>第一条是指令通过 GOT 间接跳转的指令，如果链接器在初始化阶段已经初始化该项，并将<code>bar()</code>地址填入该项，那么就能正确跳转到<code>bar()</code>。但是为了延迟绑定，链接器初始化时并没有将<code>bar()</code>地址填入，而是将第二条指令<code>push n</code>的地址填入了<code>bar@GOT</code>中，这一步不需要查找符号，代价很低。</p><p>第一条指令的效果就是跳转到第二条指令，第二条指令将数字<code>n</code>压入堆栈，这个数字是<code>bar</code>这个符号引用在重定位表<code>.rel.plt</code>中的下标。第三条指令将模块 ID 压入堆栈，最后跳转到<code>_dl_runtime_resolve</code>。</p><p><code>_dl_runtime_resolve</code>进行一系列工作后将<code>bar()</code>真正地址填入到<code>bar@GOT</code>。</p><p>一旦<code>bar()</code>这个函数被解析完，当面再次调用<code>bar@plt</code>时，第一条<code>jump</code>指令就能跳转到<code>bar()</code>的真正地址。<code>bar()</code>函数返回时根据堆栈里保存的<code>EIP</code>直接返回到调用者，而不会执行<code>bar@plt</code>中第二条指令。<strong>那段代码只会在符号未被解析时执行一次</strong>。</p><p>PLT 在 ELF 文件中以独立段存在，段名通常叫做<code>.plt</code>，因为它本身是一些地址无关的代码，所以可以跟代码段合并成同一个可读可执行的 Segment 被装载入内存。</p><h3 id=动态链接相关结构>动态链接相关结构<a hidden class=anchor aria-hidden=true href=#动态链接相关结构>#</a></h3><p><strong>.interp 段</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>objdump -s a.out
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Contents of section .interp:
</span></span><span class=line><span class=cl>804811 2f6c6962 2f6c696d 6c696e78 782e736f  /lib/ld-linux.so.2
</span></span></code></pre></div><p>里面保存的就是可执行文件所需要的动态链接器的路径，在 Linux 下，可执行文件动态链接器几乎都是<code>/lib/ld-linux.so.2</code>。</p><p>这是个软链接，会他会指向系统中安装的动态链接器。当系统中的 Glibc 库更新时，软链接也会指向新的动态链接器，所以<code>.interp</code>段不需要修改。</p><p>可以通过以下命令查看可执行文件需要的动态链接器的路径：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ readelf -l a.out <span class=p>|</span> grep interpreter
</span></span><span class=line><span class=cl>    <span class=o>[</span>Requesting program interpreter: /lib/ld-linux.so.2<span class=o>]</span>
</span></span></code></pre></div><p><strong>.dynamic 段</strong></p><p>动态链接 ELF 中最重要的结构，这里保存了动态链接器所需要的基本信息，如依赖哪些共享对象，动态链接符号表的位置，动态链接重定位表的位置，共享对象初始化代码的地址等。</p><p><strong>动态符号表</strong></p><p><code>Program1</code>程序一来<code>Lib.so</code>，引用到了里面的<code>foobar()</code>函数，那么对于<code>Program1</code>来说，称<code>Program1</code>导入（Import）了<code>foobar</code>函数，<code>foobar</code>是<code>Program1</code>的导入函数。</p><p>而站在<code>Lib.so</code>角度来说，它定义了<code>foobar</code>函数，我们称<code>Lib.so</code>导出（Export）了<code>foobar</code>函数，<code>foobar</code>是<code>Lib.so</code>的导出函数。</p><p>为了表示动态链接这些模块之间的符号导入导出关系，ELF 专门有一个叫做动态符号表的段来保存这些信息，段名通常叫<code>.dynsym</code>。</p><p><code>.dynsym</code>只保存与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。</p><p><strong>动态链接重定位表</strong></p><p>PIC 模式的共享对象也需要重定位。</p><p>对于使用 PIC 技术的可执行文件或共享对象来说，虽然代码段不需要重定位，但是数据段还包含了绝对地址的引用，因为代码段中绝对地址相关的部分被分离出来，变成了 GOT，而 GOT 实际上是数据段的一部分。</p><p>目标文件的重定位在静态链接时完成，共享对象的重定位在装载时完成。</p><p>目标文件里包含专门用于重定位信息的重定位表，比如<code>.rel.text</code>表示是代码段重定位表，<code>.rel.data</code>表示数据段重定位表。</p><p>共享对象里类似的重定位表叫做<code>.rel.dyn</code>和<code>.rel.plt</code>。<code>.rel.dyn</code>实际上是对数据引用的修正，它所修正的位置位于<code>.got</code>以及数据段；<code>.rel.plt</code>实际上是对代码引用的修正，它所修正的位置位于<code>.got.plt</code>。</p><p>用以下命令可以查看重定位表；</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101958979.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204101958979.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p><code>printf</code>这个重定位入口，它的类型为<code>R_386_JUMP_SLOT</code>，它的偏移为<code>0x000015d8</code>。它实际位于<code>.got.plt</code>中，前三项是被系统占用的，第四项开始才是真正存放导入函数地址的地方，刚好是<code>0x000015c8 + 4 * 3 = 0x000015d4</code>，即<code>__gmon_start__</code>。</p><p>当动态链接器要进行重定位时，先查找<code>printf</code>的地址，假设链接器在全局符号表中找到<code>printf</code>的地址为<code>0x08801234</code>，那么链接器就会将这个地址填入<code>.got.plt</code>中偏移为<code>0x000015d8</code>的位置。<strong>从而实现了地址重定位，即动态链接最关键的一步</strong>。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204102010906.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204102010906.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h3 id=动态链接时进程堆栈初始化信息>动态链接时进程堆栈初始化信息<a hidden class=anchor aria-hidden=true href=#动态链接时进程堆栈初始化信息>#</a></h3><h3 id=动态链接的步骤和实现>动态链接的步骤和实现<a hidden class=anchor aria-hidden=true href=#动态链接的步骤和实现>#</a></h3><p>动态链接分为三步：启动动态链接本身，装载所有的共享对象，重定位和初始化。</p><blockquote><p>Q：动态链接器本身是动态链接还是静态链接？
A：动态链接器本身应该是静态链接的，它不能依赖于其他共享对象，动态链接器本身使用来帮助其他 ELF 文件解决共享对象依赖问题的，如果它也依赖其他共享对象，那就陷入矛盾了。</p></blockquote><blockquote><p>Q：动态链接器本身必须是 PIC 的吗？
A：动态链接器可以是 PIC 的也可以不是，但是往往用 PIC 会简单一些。</p></blockquote><blockquote><p>Q：动态链接器可以被当做可执行文件运行，那么它的装载地址是多少？
A：ld.so 的装载地址跟一般的共享对象一样，即<code>0x00000000</code>。这个装载地址是一个无效的装载地址，作为一个共享库，内核在装载它时会为其选择一个合适的装载地址。</p></blockquote><h3 id=显示运行时链接>显示运行时链接<a hidden class=anchor aria-hidden=true href=#显示运行时链接>#</a></h3><h2 id=第-10-章-内存>第 10 章 内存<a hidden class=anchor aria-hidden=true href=#第-10-章-内存>#</a></h2><h3 id=程序的内存布局>程序的内存布局<a hidden class=anchor aria-hidden=true href=#程序的内存布局>#</a></h3><p>在 32 位操作系统里，有 4GB 的寻址能力，大部分操作系统会将一部分挪给内核使用，应用程序无法直接访问这段内存。这部分称为内核空间。Windows 默认将高地址的 2GB 分给内核，Linux 默认分 1GB 给内核。</p><p>剩下的称为用户空间，在用户空间里也有一些特殊的地址区间：</p><ul><li>栈：维护函数调用上下文，通常在用户空间的最高地址处分配。</li><li>堆：用来容纳程序动态分配的内存区域，当使用 malloc 或者 new 分配内存时，得到的内存来自于堆。通常在栈下方。</li><li>可执行文件映像：存储可执行文件再内存里的映像，由装载器在装载时将可执行文件的内存读取活映射到这里。</li><li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。比如<code>NULL</code>。</li></ul><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301614683.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301614683.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h3 id=栈与调用惯例>栈与调用惯例<a hidden class=anchor aria-hidden=true href=#栈与调用惯例>#</a></h3><p>栈保存了一个函数调用所需要的维护信息，通常这被称为栈帧。一般包括如下几个方面：</p><ul><li>函数的返回地址和参数</li><li>临时变量</li><li>保存的上下文</li></ul><p>一个函数的调用流程：</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301632031.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301632031.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301632216.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202204301632216.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>I386 标准函数进入和退出指令序列，基本形式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>push ebp
</span></span><span class=line><span class=cl>mov ebp, esp
</span></span><span class=line><span class=cl>sub esp, x
</span></span><span class=line><span class=cl>[push reg1]
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>[push regn]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>函数实际内存
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[pop regn]
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>[pop reg1]
</span></span><span class=line><span class=cl>mov esp, ebp
</span></span><span class=line><span class=cl>pop ebp
</span></span><span class=line><span class=cl>ret
</span></span></code></pre></div><hr><p><strong>Hot Patch Prologue 热补丁</strong>
在 Windows 函数里，有些函数尽管使用了标准的进入指令序列，但是在这些指令之前却插入了一些特殊内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov edi,edi
</span></span></code></pre></div><p>这条指令没有任何用，在汇编之后会成为一个占用 2 字节的机器码，纯粹为了占位符而存在，使用这条指令开头的函数整体看起来是这样的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>nop
</span></span><span class=line><span class=cl>nop
</span></span><span class=line><span class=cl>nop
</span></span><span class=line><span class=cl>nop
</span></span><span class=line><span class=cl>nop
</span></span><span class=line><span class=cl>FUNCTION:
</span></span><span class=line><span class=cl>mov edi,edi
</span></span><span class=line><span class=cl>push ebp
</span></span><span class=line><span class=cl>mov ebp, esp
</span></span></code></pre></div><p>其中 nop 占 1 个字节，也是占位符，FUNCTION 为一个标号，表示函数入口，本身不占空间。</p><p>设计成这样的函数在运行时可以很容易被其他函数替换掉，在上面的指令序列中调用的函数是 FUNCTION，但是我们可以做一些修改，可以在运行时刻意改成调用函数 REPLACEMENT_FUNCTION。首先在进程内存空间任意处写入 REPLACEMENT_FUNCTION 的定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>REPLACEMENT_FUNCTION:
</span></span><span class=line><span class=cl>push ebp
</span></span><span class=line><span class=cl>mov ebp, esp
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>mov esp, ebp
</span></span><span class=line><span class=cl>pop ebp
</span></span><span class=line><span class=cl>ret
</span></span></code></pre></div><p>然后修改原函数的内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LABEL:         # 标号不占字节
</span></span><span class=line><span class=cl>jmp REPLACEMENT_FUNCTION # 占5字节，刚好五个nop
</span></span><span class=line><span class=cl>FUNCTION:      # 函数入口标号，不占字节
</span></span><span class=line><span class=cl>jmp LABEL      # 近跳指令，占2字节，跳跃到上方，即使截获失败也不影响原函数执行
</span></span><span class=line><span class=cl>push ebp
</span></span><span class=line><span class=cl>mov ebp, esp
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>将 5 个<code>nop</code>换成一个<code>jmp</code>指令，然后将占用两个字节的<code>mov edi,edi</code>换成另一个<code>jmp</code>指令。因为这个<code>jmp</code>指令跳转的距离非常近，因此被汇编器翻译成了一个“近跳”指令，这种指令只占用两个字节。但<strong>只能跳跃到当前地址前后 127 个字节范围的目标位置</strong>。</p><p>这里的替换机制，可以实现一种叫做<em>钩子</em>（HOOK）的技术，允许用户在某时刻截获特定函数的调用。</p><hr><p>函数传递参数时压栈顺序，传递参数是寄存器传参还是栈传参等等都需要遵守一定的约定，否则函数将无法正确执行，这样的约定称为<strong>调用惯例</strong>。</p><p>一个调用惯例一般会规定如下几个方面：</p><ul><li>函数参数的传递顺序和方式<ul><li>调用方压栈，函数自己从栈用取参数</li><li>调用方压栈顺序：从左至右，还是从右至左？</li></ul></li><li>栈的维护方式<ul><li>参数出栈，可以由调用方完成还是由函数自己完成？</li></ul></li><li>名字修饰的策略<ul><li>为了链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰，不同调用惯例有不同的名字修饰策略</li><li>没有显示指定调用惯例的函数默认是<code>cdecl</code>惯例</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=n>_cdecl</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>float</span> <span class=n>m</span><span class=p>)</span>
</span></span></code></pre></div><blockquote><p>_cdel 是非标准关键字，在不同编译器中写法不同，在 gcc 中使用的是<code>__attribute__((cdecl))</code></p></blockquote><h2 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h2><h3 id=文件名>文件名<a hidden class=anchor aria-hidden=true href=#文件名>#</a></h3><table><thead><tr><th>英文名</th><th>Linux</th><th style=text-align:center>扩展名</th><th>英文名</th><th>Windows</th><th style=text-align:center>扩展名</th><th>功能</th></tr></thead><tbody><tr><td>DSO-Dynamic Shared Objects</td><td>ELF 动态链接文件，动态共享对象，共享对象</td><td style=text-align:center>.so</td><td>DLL-Dynamic Linking Library</td><td>动态链接库</td><td style=text-align:center>.dll</td><td>1111</td></tr><tr><td>Static Shared Library</td><td>静态共享库</td><td style=text-align:center>2222</td><td>2222</td><td>2222</td><td style=text-align:center>2222</td><td>2222</td></tr><tr><td>1111</td><td>1111</td><td style=text-align:center>1111</td><td>1111</td><td>1111</td><td style=text-align:center>1111</td><td>1111</td></tr><tr><td>1111</td><td>1111</td><td style=text-align:center>1111</td><td>1111</td><td>1111</td><td style=text-align:center>1111</td><td>1111</td></tr><tr><td>1111</td><td>1111</td><td style=text-align:center>1111</td><td>1111</td><td>1111</td><td style=text-align:center>1111</td><td>1111</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://lifeislife.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></li></ul><nav class=paginav><a class=prev href=https://lifeislife.cn/posts/%E6%9B%BF%E6%8D%A2gitee%E5%9B%BE%E5%BA%8A%E4%B8%BA%E8%85%BE%E8%AE%AF%E4%BA%91cos/><span class=title>« 上一页</span><br><span>替换 Gitee 图床为腾讯云 COS</span>
</a><a class=next href=https://lifeislife.cn/posts/zh-%E4%BB%80%E4%B9%88%E6%98%AFdie-to-die%E6%8E%A5%E5%8F%A3/><span class=title>下一页 »</span><br><span>ZH-什么是 Die-to-Die 接口</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 程序员的自我修养笔记 on x" href="https://x.com/intent/tweet/?text=%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e8%87%aa%e6%88%91%e4%bf%ae%e5%85%bb%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;hashtags=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 程序员的自我修养笔记 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;title=%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e8%87%aa%e6%88%91%e4%bf%ae%e5%85%bb%e7%ac%94%e8%ae%b0&amp;summary=%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e8%87%aa%e6%88%91%e4%bf%ae%e5%85%bb%e7%ac%94%e8%ae%b0&amp;source=https%3a%2f%2flifeislife.cn%2fposts%2f%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 程序员的自我修养笔记 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f&title=%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e8%87%aa%e6%88%91%e4%bf%ae%e5%85%bb%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 程序员的自我修养笔记 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifeislife.cn%2fposts%2f%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 程序员的自我修养笔记 on whatsapp" href="https://api.whatsapp.com/send?text=%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e8%87%aa%e6%88%91%e4%bf%ae%e5%85%bb%e7%ac%94%e8%ae%b0%20-%20https%3a%2f%2flifeislife.cn%2fposts%2f%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 程序员的自我修养笔记 on telegram" href="https://telegram.me/share/url?text=%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e8%87%aa%e6%88%91%e4%bf%ae%e5%85%bb%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 程序员的自我修养笔记 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e8%87%aa%e6%88%91%e4%bf%ae%e5%85%bb%e7%ac%94%e8%ae%b0&u=https%3a%2f%2flifeislife.cn%2fposts%2f%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://lifeislife-1.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://lifeislife.cn/>夜云泊</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>