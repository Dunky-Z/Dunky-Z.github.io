<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RISC-V 入门-Trap | 夜云泊</title>
<meta name=keywords content="RISCV"><meta name=description content="Trap 简介
控制流（Control Flow）和 Trap

控制流（Control Flow）
从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列
$$a_0,a_1,\dotsb,a_{n-1}$$
每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。
异常控制流（Exceptional Control Flow, ECF）
系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。

exception
interrupt



RISC-V 把 ECF 统称为 Trap。"><meta name=author content="Nic"><link rel=canonical href=https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-trap%E5%92%8Cexception/><link crossorigin=anonymous href=/assets/css/stylesheet.4490366ee59f83f7324bce1d2f81fb1ebba1a551f24577c75929014495a1d9b1.css integrity="sha256-RJA2buWfg/cyS84dL4H7HruhpVHyRXfHWSkBRJWh2bE=" rel="preload stylesheet" as=style><link rel=icon href=https://lifeislife.cn/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lifeislife.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lifeislife.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://lifeislife.cn/apple-touch-icon.png><link rel=mask-icon href=https://lifeislife.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-trap%E5%92%8Cexception/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PS8L2EEEPR")}</script><meta property="og:title" content="RISC-V 入门-Trap"><meta property="og:description" content="Trap 简介
控制流（Control Flow）和 Trap

控制流（Control Flow）
从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列
$$a_0,a_1,\dotsb,a_{n-1}$$
每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。
异常控制流（Exceptional Control Flow, ECF）
系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。

exception
interrupt



RISC-V 把 ECF 统称为 Trap。"><meta property="og:type" content="article"><meta property="og:url" content="https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-trap%E5%92%8Cexception/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-30T13:42:34+00:00"><meta property="article:modified_time" content="2021-12-30T13:42:34+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="RISC-V 入门-Trap"><meta name=twitter:description content="Trap 简介
控制流（Control Flow）和 Trap

控制流（Control Flow）
从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列
$$a_0,a_1,\dotsb,a_{n-1}$$
每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。
异常控制流（Exceptional Control Flow, ECF）
系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。

exception
interrupt



RISC-V 把 ECF 统称为 Trap。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifeislife.cn/posts/"},{"@type":"ListItem","position":2,"name":"RISC-V 入门-Trap","item":"https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-trap%E5%92%8Cexception/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RISC-V 入门-Trap","name":"RISC-V 入门-Trap","description":"Trap 简介 控制流（Control Flow）和 Trap 控制流（Control Flow） 从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列 $$a_0,a_1,\\dotsb,a_{n-1}$$ 每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。 异常控制流（Exceptional Control Flow, ECF） 系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。 exception interrupt RISC-V 把 ECF 统称为 Trap。\n","keywords":["RISCV"],"articleBody":"Trap 简介 控制流（Control Flow）和 Trap 控制流（Control Flow） 从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列 $$a_0,a_1,\\dotsb,a_{n-1}$$ 每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。 异常控制流（Exceptional Control Flow, ECF） 系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。 exception interrupt RISC-V 把 ECF 统称为 Trap。\nRISC-V Trap 处理中涉及的寄存器 寄存器 全称 用途说明 mtvec Machine Trap-Vector Base-Address 它保存发生异常时处理器需要跳转到的地址。 mepc Machine Exception Program Counter 当 trap 发生时，hart 会将发生 trap 所对应的指令的地址值（pc）保存在 mepc 中。 mcause Machine Cause 当 trap 发生时，hart 会设置该寄存器通知我们 trap 发生的原因。 mtval Machine Trap Value 它保存了 exception 发生时的附加信息：譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身，对于其他异常，它的值为 0。 mstatus Machine Status 用于跟踪和控制 hart 的当前操作状态（特别地，包括关闭和打开全局中断）。 mscratch Machine Scratch Machine 模式下专用寄存器，我们可以自己定义其用法，譬如用该寄存器保存当前在 hart 上运行的 task 的上下文（context）的地址。 mtvec（Machine Trap-Vector Base-Address） \u003c!DOCTYPE html\u003e Responsive Image WARL: Write Any Values, Read Legal Values\nBASE：trap 入口函数的基地址，必须保证四字节对齐；\nMODE：进一步用于控制入口函数的地址配置方式：\nDirect，所有异常和中断发生后，PC都跳转到BASE指定的地址处；\n\u003c!DOCTYPE html\u003e Responsive Image 通常中断处理函数内部会有switch case条件语句，通过不同的中断采用不同的处理方式。\nreg_t trap_handler(reg_t epc, reg_t cause) { reg_t return_pc = epc; reg_t cause_code = cause \u0026 0xfff; if (cause \u0026 0x80000000) { /* Asynchronous trap - interrupt */ switch (cause_code) { case 3: uart_puts(\"software interruption!\\n\"); break; case 7: uart_puts(\"timer interruption!\\n\"); break; case 11: uart_puts(\"external interruption!\\n\"); break; default: uart_puts(\"unknown async exception!\\n\"); break; } } else { /* Synchronous trap - exception */ printf(\"Sync exceptions!, code = %d\\n\", cause_code); panic(\"OOPS! What can I do!\"); //return_pc += 4; } return return_pc; } Vectored，异常的处理方式同上，但是中断的入口地址以数组方式排列；\ntrap_vector: # save context(registers). csrrw t6, mscratch, t6 # swap t6 and mscratch reg_save t6 # Save the actual t6 register, which we swapped into # mscratch mv t5, t6 # t5 points to the context of current task csrr t6, mscratch # read t6 back from mscratch sw t6, 120(t5) # save t6 with t5 as base # Restore the context pointer into mscratch csrw mscratch, t5 # call the C trap handler in trap.c csrr a0, mepc csrr a1, mcause call trap_handler # trap_handler will return the return address via a0. csrw mepc, a0 # restore context(registers). csrr t6, mscratch reg_restore t6 # return to whatever we were doing before trap. mret MODE可取值如下：\n\u003c!DOCTYPE html\u003e Responsive Image 采用Vectored方式效率更高。\nmepc（Machine Exception Program Counter） \u003c!DOCTYPE html\u003e Responsive Image 当trap发生时，pc会被替换为 mtvec设定的地址，同时hart 会设置mepc为当前指令或者下一条指令的地址（处理异常时，mepc 为当前指令的地址，处理中断时，mepc 为下一条指令的地址）。\n当我们需要退出trap 时可以调用特殊的 mret 指令，该指令会将mepc中的值恢复到pc中（实现返回的效果）；\n在处理 trap 的程序中我们可以修改 mepc 的值达到改变mret 返回地址的目的。\nmcause（Machine Cause） \u003c!DOCTYPE html\u003e Responsive Image 当 trap 发生时，hart 会设置该寄存器通知我们 trap 发生的原因。\n最高位 Interrupt 为 1 时标识了当前 trap 为interrupt，否则是exception。\n剩余的 Exception Code 用于标识具体的interrupt或者exception 的种类。\n\u003c!DOCTYPE html\u003e Responsive Image mtval（Machine Trap Value） \u003c!DOCTYPE html\u003e Responsive Image 当 trap 发生时，除了通过mcause 可以获取exception的种类 code 值外，hart 还提供了 mtval 来提供exception 的其他信息来辅助我们执行更进一步的操作。\n具体的辅助信息由特定的硬件实现定义，RISC-V 规范没有定义具体的值。但规范定义了一些行为，譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身等。\nmstatus（Machine Status） \u003c!DOCTYPE html\u003e Responsive Image 寄存器各个位可以大致分为以下三类，其中x可以为U,S,M。表示用户模式以及两种特权模式。\nxIE（x=M/S/U）: 分别用于打开（1）或者关闭（0）M/S/U 模式下的全局中断。当 trap 发生时，hart会自动将 xIE 设置为 0。\nxPIE（x=M/S/U）:当 trap 发生时用于保存 trap 发生之前的 xIE 值。\nxPP（x=M/S）:当 trap 发生时用于保存 trap 发生之前的权限级别值。注意没有 UPP。因为异常只会从低权限向高权限跳转，通常低权限如user模式，会被置于上方，高权限如内核一般都会画在下方，这也解释了异常，中断处理为什么叫trap，因为是向下陷入的过程。\n其他标志位涉及内存访问权限、虚拟内存控制等，暂不考虑。\nTrap 处理流程 主要为 Exception，下一章详解 Interrupt。\n初始化 将trap的基地址写入寄存器，\n\u003c!DOCTYPE html\u003e Responsive Image Top Half 把 mstatus 的 MIE 值复制到 MPIE 中，清除 mstatus中的 MIE 标志位，效果是中断被禁止。 设置mepc，同时PC被设置为 mtvec。（需要注意的是，对于exception， mepc指向导致异常的指令；对于 interrupt，它指向被中断的指令的下一条指令的位置。） 根据 trap 的种类设置 mcause，并根据需要为mtval设置附加信息。 将 trap 发生之前的权限模式保存在 mstatus 的 MPP 域中，再把hart 权限模式更改为 M（也就是说无论在任何 Level 下触发trap，hart 首先切换到 Machine 模式）。 Bottom Half 保存（save）当前控制流的上下文信息（利用 mscratch）； 调用 C 语言的 trap handler; 从 trap handler 函数返回，mepc的值有可能需要调整； 恢复（restore）上下文的信息； 执行MRET指令返回到 trap之前的状态。 trap_vector: # save context(registers). csrrw t6, mscratch, t6 # swap t6 and mscratch reg_save t6 # Save the actual t6 register, which we swapped into # mscratch mv t5, t6 # t5 points to the context of current task csrr t6, mscratch # read t6 back from mscratch sw t6, 120(t5) # save t6 with t5 as base # Restore the context pointer into mscratch csrw mscratch, t5 # call the C trap handler in trap.c csrr a0, mepc csrr a1, mcause call trap_handler # trap_handler will return the return address via a0. csrw mepc, a0 # restore context(registers). csrr t6, mscratch reg_restore t6 # return to whatever we were doing before trap. mret 退出 trap：编程调用 MRET 指令 针对不同权限级别下如何退出 trap 有各自的返回指令xRET（x = M/S/U）。以在 M 模式下执行mret 指令为例，会执行如下操作：\n当前 Hart 的权限级别 = mstatus.MPP；mstatus.MPP = U（如果 hart 不支持 U 则为 M） mstatus.MIE = mstatus.MPIE; mstatus.MPIE = 1 pc = mepc 中断 中断分类 本地（Local）中断\n软中断software interrupt 定时器中断 timer interrupt 全局（Global）中断\n外部中断 externel interrupt RISC-V 中断编程中涉及的寄存器 寄存器 全称 用途说明 mie Machine Interrupt Enable 用于进一步控制（打开和关闭）software interrupt/timer interrupt/external interrupt mip Machine Interrupt Pending 它列出目前已发生等待处理的中断。 mie(Machine Interrupt Enable) \u003c!DOCTYPE html\u003e Responsive Image 打开（1）或者关闭（0）M/S/U 模式下对应的 External/Timer/Software 中断。\nmip(Machine Interrupt Pending) \u003c!DOCTYPE html\u003e Responsive Image 获取当前 M/S/U 模式下对应的 External/Timer/Software 中断是否发生。\n中断处理流程 中断处理 把 mstatus 的 MIE 值复制到 MPIE 中，清除 mstatus 中的 MIE 标志位，效果是中断被禁止。 当前的 PC 的下一条指令地址被复制到 mepc 中，同时 PC 被设置为mtvec。注意如果我们设置 mtvec.MODE = vetcored，PC =mtvec.BASE + 4 × exception-code。 根据 interrupt 的种类设置 mcause，并根据需要为 mtval 设置附加信息。 将 trap 发生之前的权限模式保存在 mstatus 的 MPP 域中，再把hart 权限模式更改为 M。 退出中断 以在 M 模式下执行 mret 指令为例，会执行如下操作：\n当前 Hart 的权限级别 = mstatus.MPP; mstatus.MPP= U（如果 hart 不支持 U 则为 M） mstatus.MIE = mstatus.MPIE; mstatus.MPIE = 1 pc = mepc PLIC（Platform-Level Interrupt Controller） PLIC 简介 HART 只能处理一个中断，PLIC 相当于一个控制中心，它通过中断类型，优先级等等来选出一个需要处理的中断。协调多个中断，服务一个 HART。\n\u003c!DOCTYPE html\u003e Responsive Image enum { UART0_IRQ = 10, //Interrupt Source ID RTC_IRQ = 11, VIRTIO_IRQ = 1, /* 1 to 8 */ VIRTIO_COUNT = 8, PCIE_IRQ = 0x20, /* 32 to 35 */ VIRTIO_NDEV = 0x35 /* Arbitrary maximum number of interrupts */ }; Interrupt Source ID 范围：1 ~ 53（0x35） 0 预留不用 PLIC本身也是一个外设，RISC-V 规范规定，PLIC 的寄存器编址采用内存映射（memory map）方式。每个寄存器的宽度为 32-bit。\n具体寄存器编址采用 base + offset 的格式，且 base 由各个特定platform 自己定义。针对 QEMU-virt，其 PLIC 的设计参考了FU540-C000，base 为 0x0c000000。\nstatic const MemMapEntry virt_memmap[] = { [VIRT_DEBUG] = { 0x0, 0x100 }, [VIRT_MROM] = { 0x1000, 0xf000 }, [VIRT_TEST] = { 0x100000, 0x1000 }, [VIRT_RTC] = { 0x101000, 0x1000 }, [VIRT_CLINT] = { 0x2000000, 0x10000 }, [VIRT_ACLINT_SSWI] = { 0x2F00000, 0x4000 }, [VIRT_PCIE_PIO] = { 0x3000000, 0x10000 }, [VIRT_PLIC] = { 0xc000000, VIRT_PLIC_SIZE(VIRT_CPUS_MAX * 2) }, [VIRT_UART0] = { 0x10000000, 0x100 }, [VIRT_VIRTIO] = { 0x10001000, 0x1000 }, [VIRT_FW_CFG] = { 0x10100000, 0x18 }, [VIRT_FLASH] = { 0x20000000, 0x4000000 }, [VIRT_PCIE_ECAM] = { 0x30000000, 0x10000000 }, [VIRT_PCIE_MMIO] = { 0x40000000, 0x40000000 }, [VIRT_DRAM] = { 0x80000000, 0x0 }, }; PLIC 编程接口 - 寄存器 Priority 功能：设置某一路中断源的优先级 内存映射地址：BASE + (interrupt-id) * 4\n每个 PLIC 中断源对应一个寄存器，用于配置该中断源的优先级。 QEMU-virt 支持 7 个优先级。0 表示对该中断源禁用中断。其余优先级，1 最低，7 最高。 如果两个中断源优先级相同，则根据中断源的 ID 值进一步区分优先级，ID 值越小的优先级越高。 Pending 功能：用于指示某一路中断源是否发生 内存映射地址：BASE + 0x1000 + ((interrupt-id) / 32) * 4\n每个 PLIC 包含 2 个 32 位的 Pending 寄存器，因为总共有 54 个中断源，每一个 bit 对应一个中断源，如果为 1 表示该中断源上发生了中断（进入Pending 状态），有待 hart 处理，否则表示该中断源上当前无中断发生。 Pending 寄存器中断的 Pending 状态可以通过claim 方式清除。 第一个 Pending 寄存器的第 0 位对应不存在的 0 号中断源，其值永远为 0。 Enable 功能：针对某个 hart 开启或者关闭某一路中断源 内存映射地址：BASE + 0x2000 + (hart) * 0x80\n每个 Hart 有 2 个 Enable 寄存器（Enable1 和 Enable2）用于针对该Hart 启动或者关闭某路中断源。 每个中断源对应 Enable 寄存器的一个 bit，其中Enable1 负责控制 1 ~ 31 号中断源；Enable2 负责控制 32 ~ 53 号中断源。将对应的 bit 位设置为 1 表示使能该中断源，否则表示关闭该中断源。 Threshold 功能：针对某个 hart 设置中断源优先级的阈值 内存映射地址：BASE + 0x200000 + (hart) * 0x1000\n每个 Hart 有 1 个 Threshold 寄存器用于设置中断优先级的阈值。 所有小于或者等于（\u003c=）该阈值的中断源即使发生了也会被 PLIC 丢弃。特别地，当阈值为 0 时允许所有中断源上发生的中断；当阈值为 7 时丢弃所有中断源上发生的中断。 Claim/Complete 功能：如下 内存映射地址：BASE + 0x200004 + (hart) * 0x1000\nClaim 和 Complete 是同一个寄存器，每个 Hart 一个。 对该寄存器执行读操作称之为 Claim，即获取当前发生的最高优先级的中断源ID。Claim 成功后会清除对应的 Pending 位。 对该寄存器执行写操作称之为 Complete。所谓 Complete指的是通知PLIC 对该路中断的处理已经结束。 void external_interrupt_handler() { int irq = plic_claim(); // if (irq == UART0_IRQ){ uart_isr(); } else if (irq) { printf(\"unexpected interrupt irq = %d\\n\", irq); } if (irq) { plic_complete(irq); // } } \u003c!DOCTYPE html\u003e Responsive Image CLINT （Core Local INTerruptor） 定时器中断，属于本地中断的一种，由芯片内部CLINT设备产生的中断。\nRISC-V 规范规定，CLINT 的寄存器编址采用内存映射（memory map）方式。 具体寄存器编址采用base + offset的格式，且 base 由各个特定 platform 自己定义。针对 QEMU-virt，其 CLINT 的设计参考了 SFIVE，base 为 0x2000000。 CLINT 编程接口 - 寄存器 (Timer 部分) mtime 功能：real-time 计数器（counter） 内存映射地址：BASE + 0xbff8\n由晶振产生，系统全局唯一，在 RV32 和 RV64 上都是 64-bit。系统必须保证该计数器的值始终按照一个固定的频率递增。 上电复位时，硬件负责将 mtime 的值恢复为 0。 mtimecmp 功能：定时器比较寄存器 内存映射地址：BASE + 0x4000 + (hart) * 8)\n每个 hart 一个 mtimecmp 寄存器，64-bit。\n上电复位时，系统不负责设置 mt`imecmp 的初值。\n当mtime \u003e= mtimecmp 时，CLINT 会产生一个 timer 中断。如果要使能该中断需要保证全局中断打开并且mie.MTIE 标志位置 1。\n当 timer 中断发生时，hart 会设置 mip.MTIP，程序可以在 mtimecmp 中写入新的值清除mip.MTIP。\n时钟节拍 tick 操作系统中最小的时间单位； Tick 的单位（周期）由硬件定时器的周期决定 （通常为 1 ~ 100ms）； Tick 周期越小，也就是1s内产生的中断越多，系统的精度越高，但开销越大。 ","wordCount":"4706","inLanguage":"zh","datePublished":"2021-12-30T13:42:34Z","dateModified":"2021-12-30T13:42:34Z","author":{"@type":"Person","name":"Nic"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifeislife.cn/posts/risc-v%E5%85%A5%E9%97%A8-trap%E5%92%8Cexception/"},"publisher":{"@type":"Organization","name":"夜云泊","logo":{"@type":"ImageObject","url":"https://lifeislife.cn/assets/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script defer src=/static/fontawesome/fontawesome-all.js></script><header class=header><nav class=nav><div class=logo><a href=https://lifeislife.cn/ accesskey=h title="夜云泊 (Alt + H)">夜云泊</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lifeislife.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://lifeislife.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://lifeislife.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://lifeislife.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://www.travellings.cn/go.html title=开往><span><i class='fa-solid fa-train-subway'></i>开往</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lifeislife.cn/>主页</a>&nbsp;»&nbsp;<a href=https://lifeislife.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">RISC-V 入门-Trap</h1><div class=post-meta><span title='2021-12-30 13:42:34 +0000 UTC'>十二月 30, 2021</span>&nbsp;·&nbsp;10 分钟&nbsp;·&nbsp;4706 字&nbsp;·&nbsp;Nic</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#控制流control-flow和-trap>控制流（Control Flow）和 Trap</a></li><li><a href=#risc-v-trap-处理中涉及的寄存器>RISC-V Trap 处理中涉及的寄存器</a><ul><li><a href=#mtvecmachine-trap-vector-base-address>mtvec（Machine Trap-Vector Base-Address）</a></li><li><a href=#mepcmachine-exception-program-counter>mepc（Machine Exception Program Counter）</a></li><li><a href=#mcausemachine-cause>mcause（Machine Cause）</a></li><li><a href=#mtvalmachine-trap-value>mtval（Machine Trap Value）</a></li><li><a href=#mstatusmachine-status>mstatus（Machine Status）</a></li></ul></li><li><a href=#trap-处理流程>Trap 处理流程</a><ul><li><a href=#初始化>初始化</a></li><li><a href=#top-half>Top Half</a></li><li><a href=#bottom-half>Bottom Half</a></li><li><a href=#退出-trap编程调用-mret-指令>退出 trap：编程调用 MRET 指令</a></li></ul></li></ul><ul><li><a href=#中断分类>中断分类</a></li><li><a href=#risc-v-中断编程中涉及的寄存器>RISC-V 中断编程中涉及的寄存器</a><ul><li><a href=#miemachine-interrupt-enable>mie(Machine Interrupt Enable)</a></li><li><a href=#mipmachine-interrupt-pending>mip(Machine Interrupt Pending)</a></li></ul></li><li><a href=#中断处理流程>中断处理流程</a><ul><li><a href=#中断处理>中断处理</a></li><li><a href=#退出中断>退出中断</a></li></ul></li></ul><ul><li><a href=#plic-简介>PLIC 简介</a></li><li><a href=#plic-编程接口---寄存器>PLIC 编程接口 - 寄存器</a><ul><li><a href=#priority>Priority</a></li><li><a href=#pending>Pending</a></li><li><a href=#enable>Enable</a></li><li><a href=#threshold>Threshold</a></li><li><a href=#claimcomplete>Claim/Complete</a></li></ul></li></ul><ul><li><a href=#clint-编程接口---寄存器-timer-部分>CLINT 编程接口 - 寄存器 (Timer 部分)</a><ul><li><a href=#mtime>mtime</a></li><li><a href=#mtimecmp>mtimecmp</a></li></ul></li><li><a href=#时钟节拍-tick>时钟节拍 tick</a></li></ul></nav></div></details></div><div class=post-content><h1 id=trap-简介>Trap 简介<a hidden class=anchor aria-hidden=true href=#trap-简介>#</a></h1><h2 id=控制流control-flow和-trap>控制流（Control Flow）和 Trap<a hidden class=anchor aria-hidden=true href=#控制流control-flow和-trap>#</a></h2><ul><li>控制流（Control Flow）
从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列
$$a_0,a_1,\dotsb,a_{n-1}$$
每个$a_k$都是指令的地址，每次从$a_{k}$到$a_{k+1}$的过渡称为控制转移，而这样的控制转移序列叫做处理器的控制流。</li><li>异常控制流（Exceptional Control Flow, ECF）
系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。现代系统通过使控制流发生突变来对这些情况做出反应。我们把这些突变称为异常控制流。<ul><li>exception</li><li>interrupt</li></ul></li></ul><p>RISC-V 把 <code>ECF</code> 统称为 <code>Trap</code>。</p><h2 id=risc-v-trap-处理中涉及的寄存器>RISC-V Trap 处理中涉及的寄存器<a hidden class=anchor aria-hidden=true href=#risc-v-trap-处理中涉及的寄存器>#</a></h2><table><thead><tr><th style=text-align:center>寄存器</th><th style=text-align:center>全称</th><th style=text-align:left>用途说明</th></tr></thead><tbody><tr><td style=text-align:center>mtvec</td><td style=text-align:center>Machine Trap-Vector Base-Address</td><td style=text-align:left>它保存发生异常时处理器需要跳转到的地址。</td></tr><tr><td style=text-align:center>mepc</td><td style=text-align:center>Machine Exception Program Counter</td><td style=text-align:left>当 trap 发生时，hart 会将发生 trap 所对应的指令的地址值（pc）保存在 mepc 中。</td></tr><tr><td style=text-align:center>mcause</td><td style=text-align:center>Machine Cause</td><td style=text-align:left>当 trap 发生时，hart 会设置该寄存器通知我们 trap 发生的原因。</td></tr><tr><td style=text-align:center>mtval</td><td style=text-align:center>Machine Trap Value</td><td style=text-align:left>它保存了 exception 发生时的附加信息：譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身，对于其他异常，它的值为 0。</td></tr><tr><td style=text-align:center>mstatus</td><td style=text-align:center>Machine Status</td><td style=text-align:left>用于跟踪和控制 hart 的当前操作状态（特别地，包括关闭和打开全局中断）。</td></tr><tr><td style=text-align:center>mscratch</td><td style=text-align:center>Machine Scratch</td><td style=text-align:left>Machine 模式下专用寄存器，我们可以自己定义其用法，譬如用该寄存器保存当前在 hart 上运行的 task 的上下文（context）的地址。</td></tr></tbody></table><h3 id=mtvecmachine-trap-vector-base-address>mtvec（Machine Trap-Vector Base-Address）<a hidden class=anchor aria-hidden=true href=#mtvecmachine-trap-vector-base-address>#</a></h3><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104173734.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104173734.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><blockquote><p>WARL: Write Any Values, Read Legal Values</p></blockquote><ul><li><p>BASE：trap 入口函数的基地址，必须保证四字节对齐；</p></li><li><p>MODE：进一步用于控制入口函数的地址配置方式：</p><ul><li><p>Direct，所有异常和中断发生后，PC都跳转到BASE指定的地址处；</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201041945310.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201041945310.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>通常中断处理函数内部会有<code>switch case</code>条件语句，通过不同的中断采用不同的处理方式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>reg_t</span> <span class=nf>trap_handler</span><span class=p>(</span><span class=kt>reg_t</span> <span class=n>epc</span><span class=p>,</span> <span class=kt>reg_t</span> <span class=n>cause</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>reg_t</span> <span class=n>return_pc</span> <span class=o>=</span> <span class=n>epc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>reg_t</span> <span class=n>cause_code</span> <span class=o>=</span> <span class=n>cause</span> <span class=o>&amp;</span> <span class=mh>0xfff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cause</span> <span class=o>&amp;</span> <span class=mh>0x80000000</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Asynchronous trap - interrupt */</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span> <span class=p>(</span><span class=n>cause_code</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>3</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=nf>uart_puts</span><span class=p>(</span><span class=s>&#34;software interruption!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>7</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=nf>uart_puts</span><span class=p>(</span><span class=s>&#34;timer interruption!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>11</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=nf>uart_puts</span><span class=p>(</span><span class=s>&#34;external interruption!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=nf>uart_puts</span><span class=p>(</span><span class=s>&#34;unknown async exception!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Synchronous trap - exception */</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Sync exceptions!, code = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>cause_code</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;OOPS! What can I do!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//return_pc += 4;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>return_pc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p>Vectored，异常的处理方式同上，但是中断的入口地址以数组方式排列；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>trap_vector:</span>
</span></span><span class=line><span class=cl>    <span class=c1># save context(registers).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>csrrw</span> <span class=no>t6</span><span class=p>,</span> <span class=no>mscratch</span><span class=p>,</span> <span class=no>t6</span> <span class=c1># swap t6 and mscratch
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>reg_save</span> <span class=no>t6</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Save the actual t6 register, which we swapped into
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1># mscratch
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mv</span> <span class=no>t5</span><span class=p>,</span> <span class=no>t6</span>  <span class=c1># t5 points to the context of current task
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>csrr</span> <span class=no>t6</span><span class=p>,</span> <span class=no>mscratch</span> <span class=c1># read t6 back from mscratch
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sw</span> <span class=no>t6</span><span class=p>,</span> <span class=mi>120</span><span class=p>(</span><span class=no>t5</span><span class=p>)</span> <span class=c1># save t6 with t5 as base
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1># Restore the context pointer into mscratch
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>csrw</span> <span class=no>mscratch</span><span class=p>,</span> <span class=no>t5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># call the C trap handler in trap.c
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>csrr</span> <span class=no>a0</span><span class=p>,</span> <span class=no>mepc</span>
</span></span><span class=line><span class=cl>    <span class=nf>csrr</span> <span class=no>a1</span><span class=p>,</span> <span class=no>mcause</span>
</span></span><span class=line><span class=cl>    <span class=nf>call</span> <span class=no>trap_handler</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># trap_handler will return the return address via a0.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>csrw</span> <span class=no>mepc</span><span class=p>,</span> <span class=no>a0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># restore context(registers).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>csrr</span> <span class=no>t6</span><span class=p>,</span> <span class=no>mscratch</span>
</span></span><span class=line><span class=cl>    <span class=nf>reg_restore</span> <span class=no>t6</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># return to whatever we were doing before trap.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>mret</span>
</span></span></code></pre></div><p>MODE可取值如下：</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104174219.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220104174219.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p></li></ul></li></ul><p>采用<code>Vectored</code>方式效率更高。</p><h3 id=mepcmachine-exception-program-counter>mepc（Machine Exception Program Counter）<a hidden class=anchor aria-hidden=true href=#mepcmachine-exception-program-counter>#</a></h3><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201041958237.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201041958237.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>当<code>trap</code>发生时，<code>pc</code>会被替换为 <code>mtvec</code>设定的地址，同时<code>hart</code> 会设置<code>mepc</code>为当前指令或者下一条指令的地址（处理异常时，mepc 为当前指令的地址，处理中断时，mepc 为下一条指令的地址）。</p><p>当我们需要退出<code>trap</code> 时可以调用特殊的 <code>mret</code> 指令，该指令会将<code>mepc</code>中的值恢复到<code>pc</code>中（实现返回的效果）；</p><p>在处理 <code>trap</code> 的程序中我们可以修改 <code>mepc</code> 的值达到改变<code>mret</code> 返回地址的目的。</p><h3 id=mcausemachine-cause>mcause（Machine Cause）<a hidden class=anchor aria-hidden=true href=#mcausemachine-cause>#</a></h3><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042012549.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042012549.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>当 <code>trap</code> 发生时，<code>hart</code> 会设置该寄存器通知我们 <code>trap</code> 发生的原因。</p><p>最高位 <code>Interrupt</code> 为 1 时标识了当前 <code>trap</code> 为<code>interrupt</code>，否则是<code>exception</code>。</p><p>剩余的 <code>Exception Code</code> 用于标识具体的<code>interrupt</code>或者<code>exception</code> 的种类。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042014689.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042014689.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h3 id=mtvalmachine-trap-value>mtval（Machine Trap Value）<a hidden class=anchor aria-hidden=true href=#mtvalmachine-trap-value>#</a></h3><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042016744.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042016744.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>当 <code>trap</code> 发生时，除了通过<code>mcause</code> 可以获取<code>exception</code>的种类 <code>code</code> 值外，<code>hart</code> 还提供了 <code>mtval</code> 来提供<code>exception</code> 的其他信息来辅助我们执行更进一步的操作。</p><p>具体的辅助信息由特定的硬件实现定义，RISC-V 规范没有定义具体的值。但规范定义了一些行为，譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身等。</p><h3 id=mstatusmachine-status>mstatus（Machine Status）<a hidden class=anchor aria-hidden=true href=#mstatusmachine-status>#</a></h3><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042020644.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042020644.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>寄存器各个位可以大致分为以下三类，其中<code>x</code>可以为<code>U,S,M</code>。表示用户模式以及两种特权模式。</p><ul><li><p><code>xIE</code>（x=M/S/U）: 分别用于打开（1）或者关闭（0）M/S/U 模式下的全局中断。当 <code>trap</code> 发生时，<code>hart</code>会自动将 <code>xIE</code> 设置为 0。</p></li><li><p><code>xPIE</code>（x=M/S/U）:当 <code>trap</code> 发生时用于保存 <code>trap</code> 发生之前的 <code>xIE</code> 值。</p></li><li><p><code>xPP</code>（x=M/S）:当 <code>trap</code> 发生时用于保存 <code>trap</code> 发生之前的权限级别值。注意没有 <code>UPP</code>。因为异常只会从低权限向高权限跳转，通常低权限如<code>user</code>模式，会被置于上方，高权限如内核一般都会画在下方，这也解释了异常，中断处理为什么叫<code>trap</code>，因为是向下陷入的过程。</p></li><li><p>其他标志位涉及内存访问权限、虚拟内存控制等，暂不考虑。</p></li></ul><h2 id=trap-处理流程>Trap 处理流程<a hidden class=anchor aria-hidden=true href=#trap-处理流程>#</a></h2><blockquote><p>主要为 Exception，下一章详解 Interrupt。</p></blockquote><h3 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h3><p>将<code>trap</code>的基地址写入寄存器，</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042053570.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042053570.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h3 id=top-half>Top Half<a hidden class=anchor aria-hidden=true href=#top-half>#</a></h3><ol><li>把 <code>mstatus</code> 的 <code>MIE</code> 值复制到 <code>MPIE</code> 中，清除 <code>mstatus</code>中的 <code>MIE</code> 标志位，效果是中断被禁止。</li><li>设置<code>mepc</code>，同时<code>PC</code>被设置为 <code>mtvec</code>。（需要注意的是，对于<code>exception</code>， <code>mepc</code>指向导致异常的指令；对于 <code>interrupt</code>，它指向被中断的指令的下一条指令的位置。）</li><li>根据 <code>trap</code> 的种类设置 <code>mcause</code>，并根据需要为<code>mtval</code>设置附加信息。</li><li>将 <code>trap</code> 发生之前的权限模式保存在 <code>mstatus</code> 的 <code>MPP</code> 域中，再把<code>hart</code> 权限模式更改为 <code>M</code>（也就是说无论在任何 <code>Level</code> 下触发<code>trap</code>，<code>hart</code> 首先切换到 <code>Machine</code> 模式）。</li></ol><h3 id=bottom-half>Bottom Half<a hidden class=anchor aria-hidden=true href=#bottom-half>#</a></h3><ol><li>保存（save）当前控制流的上下文信息（利用 <code>mscratch</code>）；</li><li>调用 C 语言的 <code>trap handler</code>;</li><li>从 <code>trap handler</code> 函数返回，<code>mepc</code>的值有可能需要调整；</li><li>恢复（restore）上下文的信息；</li><li>执行<code>MRET</code>指令返回到 <code>trap</code>之前的状态。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>trap_vector:
</span></span><span class=line><span class=cl> # save context(registers).
</span></span><span class=line><span class=cl> csrrw t6, mscratch, t6 # swap t6 and mscratch
</span></span><span class=line><span class=cl> reg_save t6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> # Save the actual t6 register, which we swapped into
</span></span><span class=line><span class=cl> # mscratch
</span></span><span class=line><span class=cl> mv t5, t6  # t5 points to the context of current task
</span></span><span class=line><span class=cl> csrr t6, mscratch # read t6 back from mscratch
</span></span><span class=line><span class=cl> sw t6, 120(t5) # save t6 with t5 as base
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> # Restore the context pointer into mscratch
</span></span><span class=line><span class=cl> csrw mscratch, t5
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> # call the C trap handler in trap.c
</span></span><span class=line><span class=cl> csrr a0, mepc
</span></span><span class=line><span class=cl> csrr a1, mcause
</span></span><span class=line><span class=cl> call trap_handler
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> # trap_handler will return the return address via a0.
</span></span><span class=line><span class=cl> csrw mepc, a0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> # restore context(registers).
</span></span><span class=line><span class=cl> csrr t6, mscratch
</span></span><span class=line><span class=cl> reg_restore t6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> # return to whatever we were doing before trap.
</span></span><span class=line><span class=cl> mret
</span></span></code></pre></div><h3 id=退出-trap编程调用-mret-指令>退出 trap：编程调用 MRET 指令<a hidden class=anchor aria-hidden=true href=#退出-trap编程调用-mret-指令>#</a></h3><p>针对不同权限级别下如何退出 trap 有各自的返回指令<code>xRET</code>（x = M/S/U）。以在 <code>M</code> 模式下执行<code>mret</code> 指令为例，会执行如下操作：</p><ul><li>当前 <code>Hart 的权限级别 = mstatus.MPP</code>；<code>mstatus.MPP = U</code>（如果 hart 不支持 U 则为 M）</li><li><code>mstatus.MIE = mstatus.MPIE</code>; <code>mstatus.MPIE = 1</code></li><li><code>pc = mepc</code></li></ul><h1 id=中断>中断<a hidden class=anchor aria-hidden=true href=#中断>#</a></h1><h2 id=中断分类>中断分类<a hidden class=anchor aria-hidden=true href=#中断分类>#</a></h2><ul><li><p>本地（Local）中断</p><ul><li>软中断software interrupt</li><li>定时器中断 timer interrupt</li></ul></li><li><p>全局（Global）中断</p><ul><li>外部中断 externel interrupt</li></ul></li></ul><h2 id=risc-v-中断编程中涉及的寄存器>RISC-V 中断编程中涉及的寄存器<a hidden class=anchor aria-hidden=true href=#risc-v-中断编程中涉及的寄存器>#</a></h2><table><thead><tr><th style=text-align:center>寄存器</th><th style=text-align:center>全称</th><th style=text-align:left>用途说明</th></tr></thead><tbody><tr><td style=text-align:center>mie</td><td style=text-align:center>Machine Interrupt Enable</td><td style=text-align:left>用于进一步控制（打开和关闭）software interrupt/timer interrupt/external interrupt</td></tr><tr><td style=text-align:center>mip</td><td style=text-align:center>Machine Interrupt Pending</td><td style=text-align:left>它列出目前已发生等待处理的中断。</td></tr></tbody></table><h3 id=miemachine-interrupt-enable>mie(Machine Interrupt Enable)<a hidden class=anchor aria-hidden=true href=#miemachine-interrupt-enable>#</a></h3><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042159268.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042159268.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>打开（1）或者关闭（0）M/S/U 模式下对应的 External/Timer/Software 中断。</p><h3 id=mipmachine-interrupt-pending>mip(Machine Interrupt Pending)<a hidden class=anchor aria-hidden=true href=#mipmachine-interrupt-pending>#</a></h3><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042200772.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042200772.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>获取当前 M/S/U 模式下对应的 External/Timer/Software 中断是否发生。</p><h2 id=中断处理流程>中断处理流程<a hidden class=anchor aria-hidden=true href=#中断处理流程>#</a></h2><h3 id=中断处理>中断处理<a hidden class=anchor aria-hidden=true href=#中断处理>#</a></h3><ol><li>把 <code>mstatus</code> 的 <code>MIE</code> 值复制到 <code>MPIE</code> 中，清除 <code>mstatus</code> 中的 MIE 标志位，效果是中断被禁止。</li><li>当前的 <code>PC</code> 的下一条指令地址被复制到 <code>mepc</code> 中，同时 <code>PC</code> 被设置为<code>mtvec</code>。注意如果我们设置 <code>mtvec.MODE = vetcored</code>，<code>PC =mtvec.BASE + 4 × exception-code</code>。</li><li>根据 <code>interrupt</code> 的种类设置 <code>mcause</code>，并根据需要为 <code>mtval</code> 设置附加信息。</li><li>将 <code>trap</code> 发生之前的权限模式保存在 <code>mstatus</code> 的 <code>MPP</code> 域中，再把<code>hart</code> 权限模式更改为 <code>M</code>。</li></ol><h3 id=退出中断>退出中断<a hidden class=anchor aria-hidden=true href=#退出中断>#</a></h3><p>以在 M 模式下执行 mret 指令为例，会执行如下操作：</p><ul><li>当前 Hart 的权限级别 = mstatus.MPP; mstatus.MPP= U（如果 hart 不支持 U 则为 M）</li><li>mstatus.MIE = mstatus.MPIE; mstatus.MPIE = 1</li><li>pc = mepc</li></ul><h1 id=plicplatform-level-interrupt-controller>PLIC（Platform-Level Interrupt Controller）<a hidden class=anchor aria-hidden=true href=#plicplatform-level-interrupt-controller>#</a></h1><h2 id=plic-简介>PLIC 简介<a hidden class=anchor aria-hidden=true href=#plic-简介>#</a></h2><p>HART 只能处理一个中断，PLIC 相当于一个控制中心，它通过中断类型，优先级等等来选出一个需要处理的中断。协调多个中断，服务一个 HART。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042206664.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/202201042206664.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>enum</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>UART0_IRQ</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=c1>//Interrupt Source ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>RTC_IRQ</span> <span class=o>=</span> <span class=mi>11</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>VIRTIO_IRQ</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=cm>/* 1 to 8 */</span>
</span></span><span class=line><span class=cl>    <span class=n>VIRTIO_COUNT</span> <span class=o>=</span> <span class=mi>8</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>PCIE_IRQ</span> <span class=o>=</span> <span class=mh>0x20</span><span class=p>,</span> <span class=cm>/* 32 to 35 */</span>
</span></span><span class=line><span class=cl>    <span class=n>VIRTIO_NDEV</span> <span class=o>=</span> <span class=mh>0x35</span> <span class=cm>/* Arbitrary maximum number of interrupts */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>Interrupt Source ID 范围：1 ~ 53（0x35）</li><li>0 预留不用</li></ul><p><code>PLIC</code>本身也是一个外设，RISC-V 规范规定，<code>PLIC</code> 的寄存器编址采用内存映射（memory map）方式。每个寄存器的宽度为 32-bit。</p><p>具体寄存器编址采用 <code>base + offset</code> 的格式，且 <code>base</code> 由各个特定<code>platform</code> 自己定义。针对 <code>QEMU-virt</code>，其 <code>PLIC</code> 的设计参考了<code>FU540-C000</code>，<code>base</code> 为 <code>0x0c000000</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=n>MemMapEntry</span> <span class=n>virt_memmap</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_DEBUG</span><span class=p>]</span> <span class=o>=</span>       <span class=p>{</span>        <span class=mh>0x0</span><span class=p>,</span>         <span class=mh>0x100</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_MROM</span><span class=p>]</span> <span class=o>=</span>        <span class=p>{</span>     <span class=mh>0x1000</span><span class=p>,</span>        <span class=mh>0xf000</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_TEST</span><span class=p>]</span> <span class=o>=</span>        <span class=p>{</span>   <span class=mh>0x100000</span><span class=p>,</span>        <span class=mh>0x1000</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_RTC</span><span class=p>]</span> <span class=o>=</span>         <span class=p>{</span>   <span class=mh>0x101000</span><span class=p>,</span>        <span class=mh>0x1000</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_CLINT</span><span class=p>]</span> <span class=o>=</span>       <span class=p>{</span>  <span class=mh>0x2000000</span><span class=p>,</span>       <span class=mh>0x10000</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_ACLINT_SSWI</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>  <span class=mh>0x2F00000</span><span class=p>,</span>        <span class=mh>0x4000</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_PCIE_PIO</span><span class=p>]</span> <span class=o>=</span>    <span class=p>{</span>  <span class=mh>0x3000000</span><span class=p>,</span>       <span class=mh>0x10000</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_PLIC</span><span class=p>]</span> <span class=o>=</span>        <span class=p>{</span>  <span class=mh>0xc000000</span><span class=p>,</span> <span class=nf>VIRT_PLIC_SIZE</span><span class=p>(</span><span class=n>VIRT_CPUS_MAX</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_UART0</span><span class=p>]</span> <span class=o>=</span>       <span class=p>{</span> <span class=mh>0x10000000</span><span class=p>,</span>         <span class=mh>0x100</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_VIRTIO</span><span class=p>]</span> <span class=o>=</span>      <span class=p>{</span> <span class=mh>0x10001000</span><span class=p>,</span>        <span class=mh>0x1000</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_FW_CFG</span><span class=p>]</span> <span class=o>=</span>      <span class=p>{</span> <span class=mh>0x10100000</span><span class=p>,</span>          <span class=mh>0x18</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_FLASH</span><span class=p>]</span> <span class=o>=</span>       <span class=p>{</span> <span class=mh>0x20000000</span><span class=p>,</span>     <span class=mh>0x4000000</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_PCIE_ECAM</span><span class=p>]</span> <span class=o>=</span>   <span class=p>{</span> <span class=mh>0x30000000</span><span class=p>,</span>    <span class=mh>0x10000000</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_PCIE_MMIO</span><span class=p>]</span> <span class=o>=</span>   <span class=p>{</span> <span class=mh>0x40000000</span><span class=p>,</span>    <span class=mh>0x40000000</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>VIRT_DRAM</span><span class=p>]</span> <span class=o>=</span>        <span class=p>{</span> <span class=mh>0x80000000</span><span class=p>,</span>           <span class=mh>0x0</span> <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=plic-编程接口---寄存器>PLIC 编程接口 - 寄存器<a hidden class=anchor aria-hidden=true href=#plic-编程接口---寄存器>#</a></h2><h3 id=priority>Priority<a hidden class=anchor aria-hidden=true href=#priority>#</a></h3><p>功能：设置某一路中断源的优先级
内存映射地址：<code>BASE + (interrupt-id) * 4</code></p><ul><li>每个 <code>PLIC</code> 中断源对应一个寄存器，用于配置该中断源的优先级。</li><li><code>QEMU-virt</code> 支持 7 个优先级。0 表示对该中断源禁用中断。其余优先级，1 最低，7 最高。</li><li>如果两个中断源优先级相同，则根据中断源的 ID 值进一步区分优先级，ID 值越小的优先级越高。</li></ul><h3 id=pending>Pending<a hidden class=anchor aria-hidden=true href=#pending>#</a></h3><p>功能：用于指示某一路中断源是否发生
内存映射地址：<code>BASE + 0x1000 + ((interrupt-id) / 32) * 4</code></p><ul><li>每个 <code>PLIC</code> 包含 2 个 32 位的 <code>Pending</code> 寄存器，因为总共有 54 个中断源，每一个 <code>bit</code> 对应一个中断源，如果为 1 表示该中断源上发生了中断（进入<code>Pending</code> 状态），有待 <code>hart</code> 处理，否则表示该中断源上当前无中断发生。</li><li><code>Pending</code> 寄存器中断的 <code>Pending</code> 状态可以通过<code>claim</code> 方式清除。</li><li>第一个 <code>Pending</code> 寄存器的第 0 位对应不存在的 0 号中断源，其值永远为 0。</li></ul><h3 id=enable>Enable<a hidden class=anchor aria-hidden=true href=#enable>#</a></h3><p>功能：针对某个 <code>hart</code> 开启或者关闭某一路中断源
内存映射地址：<code>BASE + 0x2000 + (hart) * 0x80</code></p><ul><li>每个 <code>Hart</code> 有 2 个 <code>Enable</code> 寄存器（<code>Enable1</code> 和 <code>Enable2</code>）用于针对该<code>Hart</code> 启动或者关闭某路中断源。</li><li>每个中断源对应 <code>Enable</code> 寄存器的一个 <code>bit</code>，其中<code>Enable1</code> 负责控制 1 ~ 31 号中断源；<code>Enable2</code> 负责控制 <code>32 ~ 53</code> 号中断源。将对应的 <code>bit</code> 位设置为 1 表示使能该中断源，否则表示关闭该中断源。</li></ul><h3 id=threshold>Threshold<a hidden class=anchor aria-hidden=true href=#threshold>#</a></h3><p>功能：针对某个 hart 设置中断源优先级的阈值
内存映射地址：<code>BASE + 0x200000 + (hart) * 0x1000</code></p><ul><li>每个 <code>Hart</code> 有 1 个 <code>Threshold</code> 寄存器用于设置中断优先级的阈值。</li><li>所有小于或者等于（&lt;=）该阈值的中断源即使发生了也会被 <code>PLIC</code> 丢弃。特别地，当阈值为 0 时允许所有中断源上发生的中断；当阈值为 7 时丢弃所有中断源上发生的中断。</li></ul><h3 id=claimcomplete>Claim/Complete<a hidden class=anchor aria-hidden=true href=#claimcomplete>#</a></h3><p>功能：如下
内存映射地址：<code>BASE + 0x200004 + (hart) * 0x1000</code></p><ul><li><code>Claim</code> 和 <code>Complete</code> 是同一个寄存器，每个 <code>Hart</code> 一个。</li><li>对该寄存器执行读操作称之为 <code>Claim</code>，即获取当前发生的最高优先级的中断源<code>ID</code>。<code>Claim</code> 成功后会清除对应的 <code>Pending</code> 位。</li><li>对该寄存器执行写操作称之为 <code>Complete</code>。所谓 <code>Complete</code>指的是通知<code>PLIC</code> 对该路中断的处理已经结束。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>external_interrupt_handler</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=kt>int</span> <span class=n>irq</span> <span class=o>=</span> <span class=nf>plic_claim</span><span class=p>();</span> <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>(</span><span class=n>irq</span> <span class=o>==</span> <span class=n>UART0_IRQ</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nf>uart_isr</span><span class=p>();</span>
</span></span><span class=line><span class=cl> <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>irq</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;unexpected interrupt irq = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>irq</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>(</span><span class=n>irq</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>plic_complete</span><span class=p>(</span><span class=n>irq</span><span class=p>);</span> <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/17-56-05-db617fc7aad1c476c3c38e4ee44a770b-20220828175604-f9d5e6.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2022/08/28/17-56-05-db617fc7aad1c476c3c38e4ee44a770b-20220828175604-f9d5e6.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h1 id=clint-core-local-interruptor>CLINT （Core Local INTerruptor）<a hidden class=anchor aria-hidden=true href=#clint-core-local-interruptor>#</a></h1><p>定时器中断，属于本地中断的一种，由芯片内部<code>CLINT</code>设备产生的中断。</p><ul><li>RISC-V 规范规定，CLINT 的寄存器编址采用内存映射（memory map）方式。</li><li>具体寄存器编址采用<code>base + offset</code>的格式，且 <code>base</code> 由各个特定 <code>platform</code> 自己定义。针对 <code>QEMU-virt</code>，其 CLINT 的设计参考了 <code>SFIVE</code>，<code>base</code> 为 <code>0x2000000</code>。</li></ul><h2 id=clint-编程接口---寄存器-timer-部分>CLINT 编程接口 - 寄存器 (Timer 部分)<a hidden class=anchor aria-hidden=true href=#clint-编程接口---寄存器-timer-部分>#</a></h2><h3 id=mtime>mtime<a hidden class=anchor aria-hidden=true href=#mtime>#</a></h3><p>功能：<code>real-time</code> 计数器（counter）
内存映射地址：<code>BASE + 0xbff8</code></p><ul><li>由晶振产生，系统全局唯一，在 <code>RV32</code> 和 <code>RV64</code> 上都是 64-bit。系统必须保证该计数器的值始终按照一个固定的频率递增。</li><li>上电复位时，硬件负责将 <code>mtime</code> 的值恢复为 0。</li></ul><h3 id=mtimecmp>mtimecmp<a hidden class=anchor aria-hidden=true href=#mtimecmp>#</a></h3><p>功能：定时器比较寄存器
内存映射地址：<code>BASE + 0x4000 + (hart) * 8)</code></p><ul><li><p>每个 <code>hart</code> 一个 <code>mtimecmp</code> 寄存器，64-bit。</p></li><li><p>上电复位时，系统不负责设置 mt`imecmp 的初值。</p></li><li><p>当<code>mtime >= mtimecmp</code> 时，<code>CLINT</code> 会产生一个 <code>timer</code> 中断。如果要使能该中断需要保证全局中断打开并且<code>mie.MTIE</code> 标志位置 <code>1</code>。</p></li><li><p>当 <code>timer</code> 中断发生时，<code>hart</code> 会设置 <code>mip.MTIP</code>，程序可以在 <code>mtimecmp</code> 中写入新的值清除<code>mip.MTIP</code>。</p></li></ul><h2 id=时钟节拍-tick>时钟节拍 tick<a hidden class=anchor aria-hidden=true href=#时钟节拍-tick>#</a></h2><ul><li>操作系统中最小的时间单位；</li><li><code>Tick</code> 的单位（周期）由硬件定时器的周期决定
（通常为 1 ~ 100ms）；</li><li><code>Tick</code> 周期越小，也就是<code>1s</code>内产生的中断越多，系统的精度越高，但开销越大。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://lifeislife.cn/tags/riscv/>RISCV</a></li></ul><nav class=paginav><a class=prev href=https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3unable-to-install-libpng12-so-0/><span class=title>« 上一页</span><br><span>解决 unable to install libpng12.so.0</span>
</a><a class=next href=https://lifeislife.cn/posts/vscode%E4%BD%BF%E7%94%A8sftp%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%87%B3%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/><span class=title>下一页 »</span><br><span>VSCode 使用 sftp 插件上传本地文件至局域网服务器</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share RISC-V 入门-Trap on x" href="https://x.com/intent/tweet/?text=RISC-V%20%e5%85%a5%e9%97%a8-Trap&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2frisc-v%25E5%2585%25A5%25E9%2597%25A8-trap%25E5%2592%258Cexception%2f&amp;hashtags=RISCV"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RISC-V 入门-Trap on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2frisc-v%25E5%2585%25A5%25E9%2597%25A8-trap%25E5%2592%258Cexception%2f&amp;title=RISC-V%20%e5%85%a5%e9%97%a8-Trap&amp;summary=RISC-V%20%e5%85%a5%e9%97%a8-Trap&amp;source=https%3a%2f%2flifeislife.cn%2fposts%2frisc-v%25E5%2585%25A5%25E9%2597%25A8-trap%25E5%2592%258Cexception%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RISC-V 入门-Trap on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifeislife.cn%2fposts%2frisc-v%25E5%2585%25A5%25E9%2597%25A8-trap%25E5%2592%258Cexception%2f&title=RISC-V%20%e5%85%a5%e9%97%a8-Trap"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RISC-V 入门-Trap on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifeislife.cn%2fposts%2frisc-v%25E5%2585%25A5%25E9%2597%25A8-trap%25E5%2592%258Cexception%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RISC-V 入门-Trap on whatsapp" href="https://api.whatsapp.com/send?text=RISC-V%20%e5%85%a5%e9%97%a8-Trap%20-%20https%3a%2f%2flifeislife.cn%2fposts%2frisc-v%25E5%2585%25A5%25E9%2597%25A8-trap%25E5%2592%258Cexception%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RISC-V 入门-Trap on telegram" href="https://telegram.me/share/url?text=RISC-V%20%e5%85%a5%e9%97%a8-Trap&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2frisc-v%25E5%2585%25A5%25E9%2597%25A8-trap%25E5%2592%258Cexception%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RISC-V 入门-Trap on ycombinator" href="https://news.ycombinator.com/submitlink?t=RISC-V%20%e5%85%a5%e9%97%a8-Trap&u=https%3a%2f%2flifeislife.cn%2fposts%2frisc-v%25E5%2585%25A5%25E9%2597%25A8-trap%25E5%2592%258Cexception%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://lifeislife-1.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://lifeislife.cn/>夜云泊</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>