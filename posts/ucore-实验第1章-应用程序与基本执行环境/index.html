<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>uCore-实验第 1 章 - 应用程序与基本执行环境 | 夜云泊</title><meta name=keywords content="RISC-V,OS,uCore,Lab,Linux"><meta name=description content="了解系统调用
操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送请求，来执行一些必须由操作系统来完成的任务，例如读取文件、创建进程、分配内存等。"><meta name=author content="Nic"><link rel=canonical href=https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC1%E7%AB%A0-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/><link crossorigin=anonymous href=/assets/css/stylesheet.4490366ee59f83f7324bce1d2f81fb1ebba1a551f24577c75929014495a1d9b1.css integrity="sha256-RJA2buWfg/cyS84dL4H7HruhpVHyRXfHWSkBRJWh2bE=" rel="preload stylesheet" as=style><link rel=icon href=https://lifeislife.cn/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lifeislife.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lifeislife.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://lifeislife.cn/apple-touch-icon.png><link rel=mask-icon href=https://lifeislife.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC1%E7%AB%A0-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PS8L2EEEPR")}</script><meta property="og:url" content="https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC1%E7%AB%A0-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"><meta property="og:site_name" content="夜云泊"><meta property="og:title" content="uCore-实验第 1 章 - 应用程序与基本执行环境"><meta property="og:description" content="了解系统调用 操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送请求，来执行一些必须由操作系统来完成的任务，例如读取文件、创建进程、分配内存等。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-08T10:45:14+00:00"><meta property="article:modified_time" content="2023-09-08T10:45:14+00:00"><meta property="article:tag" content="RISC-V"><meta property="article:tag" content="OS"><meta property="article:tag" content="UCore"><meta property="article:tag" content="Lab"><meta property="article:tag" content="Linux"><meta name=twitter:card content="summary"><meta name=twitter:title content="uCore-实验第 1 章 - 应用程序与基本执行环境"><meta name=twitter:description content="了解系统调用
操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送请求，来执行一些必须由操作系统来完成的任务，例如读取文件、创建进程、分配内存等。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifeislife.cn/posts/"},{"@type":"ListItem","position":2,"name":"uCore-实验第 1 章 - 应用程序与基本执行环境","item":"https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC1%E7%AB%A0-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"uCore-实验第 1 章 - 应用程序与基本执行环境","name":"uCore-实验第 1 章 - 应用程序与基本执行环境","description":"了解系统调用 操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送请求，来执行一些必须由操作系统来完成的任务，例如读取文件、创建进程、分配内存等。\n","keywords":["RISC-V","OS","uCore","Lab","Linux"],"articleBody":"了解系统调用 操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送请求，来执行一些必须由操作系统来完成的任务，例如读取文件、创建进程、分配内存等。\n通俗地说，可以把操作系统看作一个巨大的服务员，而应用程序就像是顾客。应用程序不能直接访问硬件或执行特权操作，因为这样可能会导致系统不稳定或不安全。所以，应用程序需要通过系统调用来与操作系统进行交互，请求操作系统代表它完成某些任务。\n当应用程序需要操作系统执行特定的功能时，它会调用适当的系统调用函数，并传递参数给它。然后操作系统会接收到这个请求，并根据请求的类型和参数来执行相应的操作。完成后，操作系统会将执行结果返回给应用程序。\n在 RISC-V 架构中，系统调用是通过使用特定的指令来实现的。具体来说，RISC-V 架构提供了一个称为 ecall（environment call）的指令来触发系统调用。\n要使用 syscall，在 RISC-V 汇编代码中可以通过以下步骤来完成：\n将系统调用编号（syscall number）放入寄存器 a7 中，该编号对应于所需的系统调用功能。 将系统调用所需的参数放入其他相应的寄存器中。例如，参数传递给文件读取系统调用可能需要将文件描述符放入 a0 寄存器，缓冲区地址放入 a1 寄存器，以及读取的字节数放入 a2 寄存器。 执行 ecall 指令。这会触发操作系统处理当前运行的程序的系统调用请求。 操作系统接收到系统调用请求后，根据寄存器 a7 中的系统调用编号和其他寄存器中的参数来执行相应的操作。 当操作系统完成系统调用请求时，它将结果放入适当的寄存器中，通常是 a0 寄存器。 程序继续执行，可以检查结果并进行后续的处理。 需要注意的是，具体的系统调用编号以及参数的传递方式会根据操作系统的实现而有所不同。所以在编写 RISC-V 汇编代码时，需要参考操作系统的相关文档来了解具体的系统调用接口和参数传递方式。\nmakr run 之后发生了什么？ 当执行make run命令后，以下是运行流程的概述：\n内核代码编译：执行make run会触发 Makefile 中的相应规则，从而编译生成内核（kernel）二进制文件。\n加载 kernel 并启动 QEMU：根据 QEMUOPTS 变量指定的参数，QEMU 加载生成的 kernel 二进制文件，并启动模拟器。\n引导代码执行：在模拟器启动后，CPU 的通用寄存器被清零，程序计数器（PC）指向 0x1000 的位置，这里有硬件固化的一小段引导代码。该引导代码会迅速跳转到 0x80000000 处的 RustSBI（Rust Supervisor Binary Interface）。\nRustSBI 完成硬件初始化：RustSBI 是一个用于与操作系统进行交互的接口层。在跳转到 RustSBI 之后，它会完成必要的硬件初始化工作。\n执行操作系统第一条指令：RustSBI 在完成硬件初始化后，会跳转到 kernel 二进制文件所在内存位置 0x80200000 处，并开始执行我们操作系统的第一条指令。\n综上所述，执行make run命令会完成内核的编译和加载，启动 QEMU 虚拟机，并经过引导代码和 RustSBI 的处理，最终开始执行操作系统的第一条指令。\n了解链接脚本 # kernel.ld BASE_ADDRESS = 0x80200000; SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) # 第一行代码 *(.text .text.*) } ... } kernel.ld 中的 BASE_ADDRESS = 0x80200000 指定了内核的加载地址，这个地址哪来的？ 以下内容摘自参考rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档：\n在 Qemu 模拟的 virt 硬件平台上，物理内存的起始物理地址为 0x80000000，物理内存的默认大小为 128MiB，它可以通过 -m 选项进行配置。如果使用默认配置的 128MiB 物理内存则对应的物理地址区间为 [0x80000000,0x88000000) 。如果使用上面给出的命令启动 Qemu，那么在 Qemu 开始执行任何指令之前，首先把两个文件加载到 Qemu 的物理内存中：即作把作为 bootloader 的 rustsbi-qemu.bin 加载到物理内存以物理地址 0x80000000 开头的区域上，同时把内核镜像 os.bin 加载到以物理地址 0x80200000 开头的区域上。\n为什么加载到这两个位置呢？这与 Qemu 模拟计算机加电启动后的运行流程有关。一般来说，计算机加电之后的启动流程可以分成若干个阶段，每个阶段均由一层软件或 固件 负责，每一层软件或固件的功能是进行它应当承担的初始化工作，并在此之后跳转到下一层软件或固件的入口地址，也就是将计算机的控制权移交给了下一层软件或固件。Qemu 模拟的启动流程则可以分为三个阶段：第一个阶段由固化在 Qemu 内的一小段汇编程序负责；第二个阶段由 bootloader 负责；第三个阶段则由内核镜像负责。\n第一阶段：将必要的文件载入到 Qemu 物理内存之后，Qemu CPU 的程序计数器（PC, Program Counter）会被初始化为 0x1000，因此 Qemu 实际执行的第一条指令位于物理地址 0x1000，接下来它将执行寥寥数条指令并跳转到物理地址 0x80000000 对应的指令处并进入第二阶段。从后面的调试过程可以看出，该地址 0x80000000 被固化在 Qemu 中，作为 Qemu 的使用者，我们在不触及 Qemu 源代码的情况下无法进行更改。\n第二阶段：由于 Qemu 的第一阶段固定跳转到 0x80000000，我们需要将负责第二阶段的 bootloader rustsbi-qemu.bin 放在以物理地址 0x80000000 开头的物理内存中，这样就能保证 0x80000000 处正好保存 bootloader 的第一条指令。在这一阶段，bootloader 负责对计算机进行一些初始化工作，并跳转到下一阶段软件的入口，在 Qemu 上即可实现将计算机控制权移交给我们的内核镜像 os.bin。这里需要注意的是，对于不同的 bootloader 而言，下一阶段软件的入口不一定相同，而且获取这一信息的方式和时间点也不同：入口地址可能是一个预先约定好的固定的值，也有可能是在 bootloader 运行期间才动态获取到的值。我们选用的 RustSBI 则是将下一阶段的入口地址预先约定为固定的 0x80200000，在 RustSBI 的初始化工作完成之后，它会跳转到该地址并将计算机控制权移交给下一阶段的软件——也即我们的内核镜像。\n第三阶段：为了正确地和上一阶段的 RustSBI 对接，我们需要保证内核的第一条指令位于物理地址 0x80200000 处。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 0x80200000 开头的区域上。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核，也就达到了本节的目标。\n以上过程是 QEMU 中的启动流程，真实计算机的加电启动流程大致如下： 第一阶段：加电后 CPU 的 PC 寄存器被设置为计算机内部只读存储器（ROM，Read-only Memory）的物理地址，随后 CPU 开始运行 ROM 内的软件。我们一般将该软件称为固件（Firmware），它的功能是对 CPU 进行一些初始化操作，将后续阶段的 bootloader 的代码、数据从硬盘载入到物理内存，最后跳转到适当的地址将计算机控制权转移给 bootloader。它大致对应于 Qemu 启动的第一阶段，即在物理地址 0x1000 处放置的若干条指令。可以看到 Qemu 上的固件非常简单，因为它并不需要负责将 bootloader 从硬盘加载到物理内存中，这个任务此前已经由 Qemu 自身完成了。 第二阶段：bootloader 同样完成一些 CPU 的初始化工作，将操作系统镜像从硬盘加载到物理内存中，最后跳转到适当地址将控制权转移给操作系统。可以看到一般情况下 bootloader 需要完成一些数据加载工作，这也就是它名字中 loader 的来源。它对应于 Qemu 启动的第二阶段。在 Qemu 中，我们使用的 RustSBI 功能较弱，它并没有能力完成加载的工作，内核镜像实际上是和 bootloader 一起在 Qemu 启动之前加载到物理内存中的。 第三阶段：控制权被转移给操作系统。由于篇幅所限后面我们就不再赘述了。 值得一提的是，为了让计算机的启动更加灵活，bootloader 目前可能非常复杂：它可能也分为多个阶段，并且能管理一些硬件资源，从复杂性上它已接近一个传统意义上的操作系统。\n终端是如何控制颜色的？ enum LOG_COLOR { RED = 31, GREEN = 32, BLUE = 34, GRAY = 90, YELLOW = 93, }; #if defined(USE_LOG_ERROR) #define errorf(fmt, ...) \\ do { \\ int tid = threadid(); \\ printf(\"\\x1b[%dm[%s %d]\" fmt \"\\x1b[0m\\n\", RED, \"ERROR\", tid, \\ ##__VA_ARGS__); \\ } while (0) #else ANSI 转义码是一种用于控制终端输出的特殊字符序列。它们由\\x1b（或\\033）开头，后面跟着一系列数字和分号组成。\nANSI 转义码中的数字部分用于指定不同的控制操作，如设置文本颜色、背景颜色、光标位置等等。其中，用于设置颜色的转义码包括三个主要的部分：\\x1b[颜色代码m。\n具体来说，\\x1b[表示开始使用控制序列，接下来的数字代表不同的颜色代码，最后的m表示结束控制序列。例如，\\x1b[31m表示将文本颜色设置为红色，而\\x1b[0m用于重置所有属性为默认值。\n当终端遇到这样的转义序列时，它会解析并执行相应的控制操作，从而实现对文本颜色、背景颜色和其他属性的控制。\n需要注意的是，不同的终端可能支持不同的 ANSI 转义码，并且不同操作系统也可能有不同的实现。因此，在编写使用 ANSI 转义码的代码时，建议先测试并确保其在目标终端上正常工作。\n更多详细解释可以参考文章：终端颜色控制 - 简书。\n应用程序输出字符会调用 SBI 服务，SBI 中发生了什么？ 因为对 Rust 语言不熟悉，所以这里的分析是基于 C 语言的 OpenSBI 来分析的，他们的逻辑是一样的。如果有熟悉 Rust 的可以查看 RustSBI 源码\n根据指导书中的解释以及阅读代码，我们知道调用了 printf 最终实际上是调用了 sbi_call。那么 sbi_call 是如何实现的呢？因为我是做驱动开发以及固件开发的，也经常需要使用 OpenSBI，所想多问一句，OpenSBI 是如何实现的呢？OpenSBI 是如何提供服务的呢？它是如何打印出字符的呢？\n内核中的 SBI 调用 我们先看一下内核中的 sbi_call 都做了写啥。\n// uCore-Tutorial-Code-2023S/os/sbi.c const uint64 SBI_CONSOLE_PUTCHAR = 1; void console_putchar(int c) { sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } // uCore-Tutorial-Code-2023S/os/sbi.c int inline sbi_call(uint64 which, uint64 arg0, uint64 arg1, uint64 arg2) { // 使用寄存器变量来保存参数值和系统调用编号 register uint64 a0 asm(\"a0\") = arg0; // 将 'arg0' 的值保存在寄存器 'a0' 中 register uint64 a1 asm(\"a1\") = arg1; // 将 'arg1' 的值保存在寄存器 'a1' 中 register uint64 a2 asm(\"a2\") = arg2; // 将 'arg2' 的值保存在寄存器 'a2' 中 register uint64 a7 asm(\"a7\") = which; // 将 'which' 的值保存在寄存器 'a7' 中 // 内联汇编代码使用 ecall 指令进行系统调用 asm volatile( \"ecall\" // 使用 ecall 指令进行系统调用 // 在这段代码中，指令 \"ecall\" 的输入参数是寄存器 a0 a1 a2 和 a7，输出参数是寄存器 a0 : \"=r\"(a0) // 输出操作数：将返回值存储在变量 'a0' 中 : \"r\"(a0), \"r\"(a1), \"r\"(a2), \"r\"(a7) // 输入操作数：传递参数和系统调用编号 : \"memory\" // \"memory\" 标志告诉编译器，这条指令可能会修改内存中的数据，需要进行内存屏障操作来保证数据的正确性。 ); return a0; // 返回存储在变量 'a0' 中的值 } 那么 OpenSBI 如何提供服务？在include/sbi/sbi_ecall.h这种定义了每个ecall服务全局变量。\n//include/sbi/sbi_ecall.h extern struct sbi_ecall_extension ecall_base; extern struct sbi_ecall_extension ecall_legacy; extern struct sbi_ecall_extension ecall_time; extern struct sbi_ecall_extension ecall_rfence; extern struct sbi_ecall_extension ecall_ipi; extern struct sbi_ecall_extension ecall_vendor; extern struct sbi_ecall_extension ecall_hsm; extern struct sbi_ecall_extension ecall_srst; 在lib/sbi/sbi_ecall.c中注册了所有的ecall服务，并将其加到链表ecall_exts_list中。\nint sbi_ecall_init(void) { int ret; struct sbi_ecall_extension *ext; unsigned long i; for (i = 0; i \u003c sbi_ecall_exts_size; i++) { ext = sbi_ecall_exts[i]; ret = sbi_ecall_register_extension(ext); if (ret) return ret; } return 0; } int sbi_ecall_register_extension(struct sbi_ecall_extension *ext) { struct sbi_ecall_extension *t; if (!ext || (ext-\u003eextid_end \u003c ext-\u003eextid_start) || !ext-\u003ehandle) return SBI_EINVAL; sbi_list_for_each_entry(t, \u0026ecall_exts_list, head) { unsigned long start = t-\u003eextid_start; unsigned long end = t-\u003eextid_end; if (end \u003c ext-\u003eextid_start || ext-\u003eextid_end \u003c start) /* no overlap */; else return SBI_EINVAL; } SBI_INIT_LIST_HEAD(\u0026ext-\u003ehead); sbi_list_add_tail(\u0026ext-\u003ehead, \u0026ecall_exts_list); return 0; } /** * Iterate over list of given type * @param pos the type * to use as a loop cursor. * @param head the head for your list. * @param member the name of the list_struct within the struct. */ #define sbi_list_for_each_entry(pos, head, member) \\ for (pos = sbi_list_entry((head)-\u003enext, typeof(*pos), member);\t\\ \u0026pos-\u003emember != (head); \\ pos = sbi_list_entry(pos-\u003emember.next, typeof(*pos), member)) 那么服务 id 如何和相对应的服务绑定的呢？以ecall_time为例，查看其结构体原型struct sbi_ecall_extension ：\n// include/sbi/sbi_ecall.h: 23 struct sbi_ecall_extension { struct sbi_dlist head; unsigned long extid_start; unsigned long extid_end; int (* probe)(unsigned long extid, unsigned long *out_val); int (* handle)(unsigned long extid, unsigned long funcid, const struct sbi_trap_regs *regs, unsigned long *out_val, struct sbi_trap_info *out_trap); }; 可以看到有 extid_start、extid_end 和 handle。\n目前 OpenSBI 逐步将每个服务的实现都放在了lib/sbi单独文件中，以ecall_time为例，其实现在lib/sbi/sbi_ecall_time.c中。单独为其绑定回调处理函数sbi_ecall_time_handler。但是还有很多服务的实现还是放在了lib/sbi/sbi_ecall_legacy.c中，后续应该会逐步迁移。我们上文使用的SBI_CONSOLE_PUTCHAR服务就是在这里实现的。\n// lib/sbi/sbi_ecall_legacy.c struct sbi_ecall_extension ecall_legacy = { .extid_start = SBI_EXT_0_1_SET_TIMER, .extid_end = SBI_EXT_0_1_SHUTDOWN, .handle = sbi_ecall_legacy_handler, }; static int sbi_ecall_legacy_handler(unsigned long extid, unsigned long funcid, const struct sbi_trap_regs *regs, unsigned long *out_val, struct sbi_trap_info *out_trap) { int ret = 0; struct sbi_tlb_info tlb_info; u32 source_hart = current_hartid(); ulong hmask = 0; switch (extid) { case SBI_EXT_0_1_SET_TIMER: sbi_timer_event_start((u64)regs-\u003ea0); break; case SBI_EXT_0_1_CONSOLE_PUTCHAR: sbi_putc(regs-\u003ea0); break; case SBI_EXT_0_1_CONSOLE_GETCHAR: ret = sbi_getc(); break; // ... }; return ret; } 这就把 id 与相应的服务函数绑定。一个extid对应一个handler。\n我们可以在找到SBI_EXT_0_1_CONSOLE_PUTCHAR的值，是与 Linux 内核里定义的值是一致的。\n// include/sbi/sbi_ecall_interface.h /* SBI Extension IDs */ #define SBI_EXT_0_1_CONSOLE_PUTCHAR\t0x1 ecall 服务调用流程 在 firmware/fw_base.S 中注册了 Machine Mode 的 trap handler，即 sbi_trap_handler；\n_start_warm: /* Setup trap handler */ la\ta4, _trap_handler csrw\tCSR_MTVEC, a4 /* CSR_MTVEC = _trap_handler */ _trap_handler: TRAP_SAVE_AND_SETUP_SP_T0 TRAP_SAVE_MEPC_MSTATUS 0 TRAP_SAVE_GENERAL_REGS_EXCEPT_SP_T0 TRAP_CALL_C_ROUTINE TRAP_RESTORE_GENERAL_REGS_EXCEPT_SP_T0 TRAP_RESTORE_MEPC_MSTATUS 0 TRAP_RESTORE_SP_T0 mret .macro\tTRAP_CALL_C_ROUTINE /* Call C routine */ add\ta0, sp, zero call\tsbi_trap_handler .endm 在 lib/sbi/sbi_trap.c 中定义了 sbi_trap_handler，处理各种 mcause，比如 Illegal Instructions，Misaligned Load \u0026 Store, Supervisor \u0026 Machine Ecall 等。\n// lib/sbi/sbi_trap.c void sbi_trap_handler(struct sbi_trap_regs *regs) { ... switch (mcause) { case CAUSE_ILLEGAL_INSTRUCTION: rc = sbi_illegal_insn_handler(mtval, regs); break; case CAUSE_MISALIGNED_LOAD: rc = sbi_misaligned_load_handler(mtval, mtval2, mtinst, regs); break; case CAUSE_MISALIGNED_STORE: rc = sbi_misaligned_store_handler(mtval, mtval2, mtinst, regs); break; case CAUSE_SUPERVISOR_ECALL: case CAUSE_MACHINE_ECALL: rc = sbi_ecall_handler(regs); break; default: /* If the trap came from S or U mode, redirect it there */ trap.epc = regs-\u003emepc; trap.cause = mcause; trap.tval = mtval; trap.tval2 = mtval2; trap.tinst = mtinst; rc = sbi_trap_redirect(regs, \u0026trap); break; }; ... 在 lib/sbi/sbi_ecall.c 中定义了处理 ecall mcause 的 sbi_ecall_handler，它遍历上面 ecall_exts_list 中注册的各种 ecall 服务。\nsbi_ecall_handler 根据 Linux 内核传递的 ext (extension id) 找到链表中对应的 ecall 服务，执行其中的 handle 函数，该函数根据 fid 执行具体的服务内容。\n// lib/sbi/sbi_ecall.c int sbi_ecall_handler(struct sbi_trap_regs *regs) { // ... unsigned long extension_id = regs-\u003ea7; unsigned long func_id = regs-\u003ea6; struct sbi_trap_info trap = {0}; unsigned long out_val = 0; // 遍历所有 ecall 服务 ext = sbi_ecall_find_extension(extension_id); if (ext \u0026\u0026 ext-\u003ehandle) { // 如果找到了就执行 ret = ext-\u003ehandle(extension_id, func_id, regs, \u0026out_val, \u0026trap); if (extension_id \u003e= SBI_EXT_0_1_SET_TIMER \u0026\u0026 extension_id \u003c= SBI_EXT_0_1_SHUTDOWN) is_0_1_spec = 1; } else { ret = SBI_ENOTSUPP; } ... } 我们可以发现 extension_id 就是 a7 寄存器，他和我们在 uCore OS 中定义的 SBI_EXT_0_1_CONSOLE_PUTCHAR 是一致的。\n程序的内存布局与编译流程 程序的内存布局 uCore 的编译系统 .PHONY: clean build user # 设置伪目标clean、build和user，可以通过命令make来执行这些目标 all: build_kernel # 默认目标为build_kernel，即执行build_kernel目标下的指令 LOG ?= error # 定义一个变量LOG，默认值是error K = os TOOLPREFIX = riscv64-unknown-elf- CC = $(TOOLPREFIX)gcc AS = $(TOOLPREFIX)gcc LD = $(TOOLPREFIX)ld OBJCOPY = $(TOOLPREFIX)objcopy OBJDUMP = $(TOOLPREFIX)objdump PY = python3 GDB = $(TOOLPREFIX)gdb CP = cp MKDIR_P = mkdir -p BUILDDIR = build C_SRCS = $(wildcard $K/*.c) # 定义一个变量C_SRCS，使用wildcard函数匹配所有以.c为后缀的文件，并存储在$K目录下 AS_SRCS = $(wildcard $K/*.S) # 定义一个变量AS_SRCS，使用wildcard函数匹配所有以.S为后缀的文件，并存储在$K目录下 C_OBJS = $(addprefix $(BUILDDIR)/, $(addsuffix .o, $(basename $(C_SRCS)))) # 定义一个变量C_OBJS，通过addprefix和addsuffix函数将$(C_SRCS)中的路径替换为$(BUILDDIR)，并将后缀修改为.o AS_OBJS = $(addprefix $(BUILDDIR)/, $(addsuffix .o, $(basename $(AS_SRCS)))) # 定义一个变量AS_OBJS，通过addprefix和addsuffix函数将$(AS_SRCS)中的路径替换为$(BUILDDIR)，并将后缀修改为.o OBJS = $(C_OBJS) $(AS_OBJS) # 定义一个变量OBJS，其值为$(C_OBJS)和$(AS_OBJS)的组合 HEADER_DEP = $(addsuffix .d, $(basename $(C_OBJS))) # 定义一个变量HEADER_DEP，通过addsuffix函数将$(C_OBJS)中的后缀修改为.d -include $(HEADER_DEP) # 包含$(HEADER_DEP)中的.d文件 CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb # 定义一个变量CFLAGS，并赋值为-Wall -Werror -O -fno-omit-frame-pointer -ggdb CFLAGS += -MD # 将-MD选项追加到CFLAGS变量中，用于自动生成依赖关系文件 CFLAGS += -mcmodel=medany # 将-mcmodel=medany选项追加到CFLAGS变量中，用于指定内存模型 CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax # 将-ffreestanding -fno-common -nostdlib -mno-relax选项追加到CFLAGS变量中，用于编译无操作系统环境下的程序 CFLAGS += -I$K # 将-I$K选项追加到CFLAGS变量中，用于指定头文件搜索路径为$K目录下 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null \u003e/dev/null 2\u003e\u00261 \u0026\u0026 echo -fno-stack-protector) # 将$(CC) -fno-stack-protector -E -x c /dev/null \u003e/dev/null 2\u003e\u00261 \u0026\u0026 echo -fno-stack-protector命令执行结果追加到CFLAGS变量中，用于禁用栈保护机制 ifeq ($(LOG), error) CFLAGS += -D LOG_LEVEL_ERROR else ifeq ($(LOG), warn) CFLAGS += -D LOG_LEVEL_WARN else ifeq ($(LOG), info) CFLAGS += -D LOG_LEVEL_INFO else ifeq ($(LOG), debug) CFLAGS += -D LOG_LEVEL_DEBUG else ifeq ($(LOG), trace) CFLAGS += -D LOG_LEVEL_TRACE endif # 根据$(LOG)变量的值，向CFLAGS变量追加相应的预处理器选项，相当于添加了一个宏定义，log.h中的LOG_LEVEL_ERROR等宏定义会根据这个宏定义来决定是否生效 # Disable PIE when possible (for Ubuntu 16.10 toolchain) ifneq ($(shell $(CC) -dumpspecs 2\u003e/dev/null | grep -e '[^f]no-pie'),) CFLAGS += -fno-pie -no-pie endif ifneq ($(shell $(CC) -dumpspecs 2\u003e/dev/null | grep -e '[^f]nopie'),) CFLAGS += -fno-pie -nopie endif # 根据系统环境判断是否支持PIE（位置无关执行）选项，并根据情况向CFLAGS变量追加相应的选项 LDFLAGS = -z max-page-size=4096 # 定义一个变量LDFLAGS，并赋值为-z max-page-size=4096 $(AS_OBJS): $(BUILDDIR)/$K/%.o : $K/%.S @mkdir -p $(@D) $(CC) $(CFLAGS) -c $\u003c -o $@ # 规则：生成$(AS_OBJS)目标所需的依赖文件$(BUILDDIR)/$K/%.o，依赖于$K/%.S，并通过$(CC)命令编译生成目标文件 $(C_OBJS): $(BUILDDIR)/$K/%.o : $K/%.c $(BUILDDIR)/$K/%.d @mkdir -p $(@D) $(CC) $(CFLAGS) -c $\u003c -o $@ # 规则：生成$(C_OBJS)目标所需的依赖文件$(BUILDDIR)/$K/%.o，依赖于$K/%.c和$(BUILDDIR)/$K/%.d，并通过$(CC)命令编译生成目标文件 $(HEADER_DEP): $(BUILDDIR)/$K/%.d : $K/%.c @mkdir -p $(@D) @set -e; rm -f $@; $(CC) -MM $\u003c $(INCLUDEFLAGS) \u003e $@.$$$$; \\ sed 's,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g' \u003c $@.$$$$ \u003e $@; \\ rm -f $@.$$$$ # 规则：生成$(HEADER_DEP)目标所需的依赖文件$(BUILDDIR)/$K/%.d，依赖于$K/%.c，并通过$(CC)命令生成依赖关系文件 build: build/kernel # 定义一个目标build，其依赖于build/kernel build/kernel: $(OBJS) $(LD) $(LDFLAGS) -T os/kernel.ld -o $(BUILDDIR)/kernel $(OBJS) $(OBJDUMP) -S $(BUILDDIR)/kernel \u003e $(BUILDDIR)/kernel.asm $(OBJDUMP) -t $(BUILDDIR)/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' \u003e $(BUILDDIR)/kernel.sym @echo 'Build kernel done' # 规则：生成build/kernel目标，依赖于$(OBJS)，通过$(LD)命令连接生成kernel，并通过$(OBJDUMP)命令生成汇编文件和符号表 clean: rm -rf $(BUILDDIR) # BOARD BOARD\t?= qemu SBI\t?= rustsbi BOOTLOADER\t:= ./bootloader/rustsbi-qemu.bin QEMU = qemu-system-riscv64 QEMUOPTS = \\ -nographic \\ -machine virt \\ -bios $(BOOTLOADER) \\ -kernel build/kernel\t\\ run: build/kernel $(QEMU) $(QEMUOPTS) # QEMU's gdb stub command line changed in 0.11 QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \\ then echo \"-gdb tcp::15234\"; \\ else echo \"-s -p 15234\"; fi) # 启动QEMU并通过GDB调试，此时QEMu会进入后台运行，并暂停执行，等待GDB连接 # 连接的GDB端口为15234 debug: build/kernel .gdbinit $(QEMU) $(QEMUOPTS) -S $(QEMUGDB) \u0026 sleep 1 $(GDB) 编译、运行 uCore 的一些常用命令有如下一些，涉及了后续章节中引入的测试用例中的命令：\nmake run make debug make clean # 编译测试用例的前四章 make user CHAPTER=4 LOG=trace # 编译测试用例的第四章 make user CHAPTER=4_only LOG=trace # 只运行测试用例的第四章 make test CHAPTER=4_only 附录 makefile 和 qemu\nAS = $(TOOLPREFIX)gas \u003e AS = $(TOOLPREFIX)as\n参考资料 终端颜色控制 - 简书 ","wordCount":"6904","inLanguage":"zh","datePublished":"2023-09-08T10:45:14Z","dateModified":"2023-09-08T10:45:14Z","author":{"@type":"Person","name":"Nic"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC1%E7%AB%A0-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"},"publisher":{"@type":"Organization","name":"夜云泊","logo":{"@type":"ImageObject","url":"https://lifeislife.cn/assets/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script defer src=/static/fontawesome/fontawesome-all.js></script><header class=header><nav class=nav><div class=logo><a href=https://lifeislife.cn/ accesskey=h title="夜云泊 (Alt + H)">夜云泊</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lifeislife.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://lifeislife.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://lifeislife.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://lifeislife.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://lifeislife.cn/awesome-cycling/ title=AwesomeCycling><span>AwesomeCycling</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.travellings.cn/go.html title=开往><span><i class='fa-solid fa-train-subway'></i>开往</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lifeislife.cn/>主页</a>&nbsp;»&nbsp;<a href=https://lifeislife.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">uCore-实验第 1 章 - 应用程序与基本执行环境</h1><div class=post-meta><span title='2023-09-08 10:45:14 +0000 UTC'>九月 8, 2023</span>&nbsp;·&nbsp;14 分钟&nbsp;·&nbsp;6904 字&nbsp;·&nbsp;Nic</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#kernelld-中的-base_address--0x80200000-指定了内核的加载地址这个地址哪来的>kernel.ld 中的 <code>BASE_ADDRESS = 0x80200000</code> 指定了内核的加载地址，这个地址哪来的？</a></li></ul><ul><li><a href=#内核中的-sbi-调用>内核中的 SBI 调用</a></li><li><a href=#ecall-服务调用流程>ecall 服务调用流程</a></li></ul><ul><li><a href=#程序的内存布局>程序的内存布局</a></li></ul></nav></div></details></div><div class=post-content><h1 id=了解系统调用>了解系统调用<a hidden class=anchor aria-hidden=true href=#了解系统调用>#</a></h1><p>操作系统的系统调用（syscall）是操作系统提供给应用程序使用的一种接口。它允许应用程序通过向操作系统发送请求，来执行一些必须由操作系统来完成的任务，例如读取文件、创建进程、分配内存等。</p><p>通俗地说，可以把操作系统看作一个巨大的服务员，而应用程序就像是顾客。应用程序不能直接访问硬件或执行特权操作，因为这样可能会导致系统不稳定或不安全。所以，应用程序需要通过系统调用来与操作系统进行交互，请求操作系统代表它完成某些任务。</p><p>当应用程序需要操作系统执行特定的功能时，它会调用适当的系统调用函数，并传递参数给它。然后操作系统会接收到这个请求，并根据请求的类型和参数来执行相应的操作。完成后，操作系统会将执行结果返回给应用程序。</p><p><strong>在 RISC-V 架构中</strong>，系统调用是通过使用特定的指令来实现的。具体来说，RISC-V 架构提供了一个称为 <code>ecall</code>（environment call）的指令来触发系统调用。</p><p>要使用 syscall，在 RISC-V 汇编代码中可以通过以下步骤来完成：</p><ol><li>将系统调用编号（syscall number）放入寄存器 a7 中，该编号对应于所需的系统调用功能。</li><li>将系统调用所需的参数放入其他相应的寄存器中。例如，参数传递给文件读取系统调用可能需要将文件描述符放入 a0 寄存器，缓冲区地址放入 a1 寄存器，以及读取的字节数放入 a2 寄存器。</li><li>执行 ecall 指令。这会触发操作系统处理当前运行的程序的系统调用请求。</li><li>操作系统接收到系统调用请求后，根据寄存器 a7 中的系统调用编号和其他寄存器中的参数来执行相应的操作。</li><li>当操作系统完成系统调用请求时，它将结果放入适当的寄存器中，通常是 a0 寄存器。</li><li>程序继续执行，可以检查结果并进行后续的处理。</li></ol><p>需要注意的是，具体的系统调用编号以及参数的传递方式会根据操作系统的实现而有所不同。所以在编写 RISC-V 汇编代码时，需要参考操作系统的相关文档来了解具体的系统调用接口和参数传递方式。</p><h1 id=makr-run-之后发生了什么>makr run 之后发生了什么？<a hidden class=anchor aria-hidden=true href=#makr-run-之后发生了什么>#</a></h1><p>当执行<code>make run</code>命令后，以下是运行流程的概述：</p><ol><li><p>内核代码编译：执行<code>make run</code>会触发 Makefile 中的相应规则，从而编译生成内核（kernel）二进制文件。</p></li><li><p>加载 kernel 并启动 QEMU：根据 QEMUOPTS 变量指定的参数，QEMU 加载生成的 kernel 二进制文件，并启动模拟器。</p></li><li><p>引导代码执行：在模拟器启动后，CPU 的通用寄存器被清零，程序计数器（PC）指向 0x1000 的位置，这里有硬件固化的一小段引导代码。该引导代码会迅速跳转到 0x80000000 处的 RustSBI（Rust Supervisor Binary Interface）。</p></li><li><p>RustSBI 完成硬件初始化：RustSBI 是一个用于与操作系统进行交互的接口层。在跳转到 RustSBI 之后，它会完成必要的硬件初始化工作。</p></li><li><p>执行操作系统第一条指令：RustSBI 在完成硬件初始化后，会跳转到 kernel 二进制文件所在内存位置 0x80200000 处，并开始执行我们操作系统的第一条指令。</p></li></ol><p>综上所述，执行<code>make run</code>命令会完成内核的编译和加载，启动 QEMU 虚拟机，并经过引导代码和 RustSBI 的处理，最终开始执行操作系统的第一条指令。</p><h1 id=了解链接脚本>了解链接脚本<a hidden class=anchor aria-hidden=true href=#了解链接脚本>#</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># kernel.ld
</span></span><span class=line><span class=cl>BASE_ADDRESS = 0x80200000;
</span></span><span class=line><span class=cl>SECTIONS
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>   . = BASE_ADDRESS;
</span></span><span class=line><span class=cl>   skernel = .;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   stext = .;
</span></span><span class=line><span class=cl>   .text : {
</span></span><span class=line><span class=cl>      *(.text.entry)   # 第一行代码
</span></span><span class=line><span class=cl>      *(.text .text.*)
</span></span><span class=line><span class=cl>   }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h2 id=kernelld-中的-base_address--0x80200000-指定了内核的加载地址这个地址哪来的>kernel.ld 中的 <code>BASE_ADDRESS = 0x80200000</code> 指定了内核的加载地址，这个地址哪来的？<a hidden class=anchor aria-hidden=true href=#kernelld-中的-base_address--0x80200000-指定了内核的加载地址这个地址哪来的>#</a></h2><p>以下内容摘自参考<a href=https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/3first-instruction-in-kernel1.html>rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</a>：</p><p>在 Qemu 模拟的 virt 硬件平台上，物理内存的起始物理地址为 <code>0x80000000</code>，物理内存的默认大小为 128MiB，它可以通过 <code>-m</code> 选项进行配置。如果使用默认配置的 128MiB 物理内存则对应的物理地址区间为 <code>[0x80000000,0x88000000)</code> 。如果使用上面给出的命令启动 Qemu，那么在 Qemu 开始执行任何指令之前，首先把两个文件加载到 Qemu 的物理内存中：即作把作为 bootloader 的 rustsbi-qemu.bin 加载到物理内存以物理地址 <code>0x80000000</code> 开头的区域上，同时把内核镜像 <code>os.bin</code> 加载到以物理地址 <code>0x80200000</code> 开头的区域上。</p><p>为什么加载到这两个位置呢？这与 Qemu 模拟计算机加电启动后的运行流程有关。一般来说，计算机加电之后的启动流程可以分成若干个阶段，每个阶段均由一层软件或 固件 负责，每一层软件或固件的功能是进行它应当承担的初始化工作，并在此之后跳转到下一层软件或固件的入口地址，也就是将计算机的控制权移交给了下一层软件或固件。Qemu 模拟的启动流程则可以分为三个阶段：第一个阶段由固化在 Qemu 内的一小段汇编程序负责；第二个阶段由 bootloader 负责；第三个阶段则由内核镜像负责。</p><p>第一阶段：将必要的文件载入到 Qemu 物理内存之后，Qemu CPU 的程序计数器（PC, Program Counter）会被初始化为 0x1000，因此 Qemu 实际执行的第一条指令位于物理地址 0x1000，接下来它将执行寥寥数条指令并跳转到物理地址 <code>0x80000000</code> 对应的指令处并进入第二阶段。从后面的调试过程可以看出，该地址 <code>0x80000000</code> 被固化在 Qemu 中，作为 Qemu 的使用者，我们在不触及 Qemu 源代码的情况下无法进行更改。</p><p>第二阶段：由于 Qemu 的第一阶段固定跳转到 <code>0x80000000</code>，我们需要将负责第二阶段的 bootloader rustsbi-qemu.bin 放在以物理地址 <code>0x80000000</code> 开头的物理内存中，这样就能保证 <code>0x80000000</code> 处正好保存 bootloader 的第一条指令。在这一阶段，bootloader 负责对计算机进行一些初始化工作，并跳转到下一阶段软件的入口，在 Qemu 上即可实现将计算机控制权移交给我们的内核镜像 os.bin。这里需要注意的是，对于不同的 bootloader 而言，下一阶段软件的入口不一定相同，而且获取这一信息的方式和时间点也不同：入口地址可能是一个预先约定好的固定的值，也有可能是在 bootloader 运行期间才动态获取到的值。我们选用的 RustSBI 则是将下一阶段的入口地址预先约定为固定的 0x80200000，在 RustSBI 的初始化工作完成之后，它会跳转到该地址并将计算机控制权移交给下一阶段的软件——也即我们的内核镜像。</p><p>第三阶段：为了正确地和上一阶段的 RustSBI 对接，我们需要保证内核的第一条指令位于物理地址 <code>0x80200000</code> 处。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 0x80200000 开头的区域上。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核，也就达到了本节的目标。</p><blockquote><p>以上过程是 QEMU 中的启动流程，真实计算机的加电启动流程大致如下：
第一阶段：加电后 CPU 的 PC 寄存器被设置为计算机内部只读存储器（ROM，Read-only Memory）的物理地址，随后 CPU 开始运行 ROM 内的软件。我们一般将该软件称为固件（Firmware），它的功能是对 CPU 进行一些初始化操作，将后续阶段的 bootloader 的代码、数据从硬盘载入到物理内存，最后跳转到适当的地址将计算机控制权转移给 bootloader。它大致对应于 Qemu 启动的第一阶段，即在物理地址 0x1000 处放置的若干条指令。可以看到 Qemu 上的固件非常简单，因为它并不需要负责将 bootloader 从硬盘加载到物理内存中，这个任务此前已经由 Qemu 自身完成了。
第二阶段：bootloader 同样完成一些 CPU 的初始化工作，将操作系统镜像从硬盘加载到物理内存中，最后跳转到适当地址将控制权转移给操作系统。可以看到一般情况下 bootloader 需要完成一些数据加载工作，这也就是它名字中 loader 的来源。它对应于 Qemu 启动的第二阶段。在 Qemu 中，我们使用的 RustSBI 功能较弱，它并没有能力完成加载的工作，内核镜像实际上是和 bootloader 一起在 Qemu 启动之前加载到物理内存中的。
第三阶段：控制权被转移给操作系统。由于篇幅所限后面我们就不再赘述了。
值得一提的是，为了让计算机的启动更加灵活，bootloader 目前可能非常复杂：它可能也分为多个阶段，并且能管理一些硬件资源，从复杂性上它已接近一个传统意义上的操作系统。</p></blockquote><h1 id=终端是如何控制颜色的>终端是如何控制颜色的？<a hidden class=anchor aria-hidden=true href=#终端是如何控制颜色的>#</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>enum</span> <span class=n>LOG_COLOR</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>RED</span> <span class=o>=</span> <span class=mi>31</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>GREEN</span> <span class=o>=</span> <span class=mi>32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>BLUE</span> <span class=o>=</span> <span class=mi>34</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>GRAY</span> <span class=o>=</span> <span class=mi>90</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>YELLOW</span> <span class=o>=</span> <span class=mi>93</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#if defined(USE_LOG_ERROR)
</span></span></span><span class=line><span class=cl><span class=cp>#define errorf(fmt, ...)                                               \
</span></span></span><span class=line><span class=cl><span class=cp>	do {                                                               \
</span></span></span><span class=line><span class=cl><span class=cp>		int tid = threadid();                                          \
</span></span></span><span class=line><span class=cl><span class=cp>		printf(&#34;\x1b[%dm[%s %d]&#34; fmt &#34;\x1b[0m\n&#34;, RED, &#34;ERROR&#34;, tid,   \
</span></span></span><span class=line><span class=cl><span class=cp>		       ##__VA_ARGS__);                                         \
</span></span></span><span class=line><span class=cl><span class=cp>	} while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span></code></pre></div><p>ANSI 转义码是一种用于控制终端输出的特殊字符序列。它们由<code>\x1b</code>（或<code>\033</code>）开头，后面跟着一系列数字和分号组成。</p><p>ANSI 转义码中的数字部分用于指定不同的控制操作，如设置文本颜色、背景颜色、光标位置等等。其中，用于设置颜色的转义码包括三个主要的部分：<code>\x1b[颜色代码m</code>。</p><p>具体来说，<code>\x1b[</code>表示开始使用控制序列，接下来的数字代表不同的颜色代码，最后的<code>m</code>表示结束控制序列。例如，<code>\x1b[31m</code>表示将文本颜色设置为红色，而<code>\x1b[0m</code>用于重置所有属性为默认值。</p><p>当终端遇到这样的转义序列时，它会解析并执行相应的控制操作，从而实现对文本颜色、背景颜色和其他属性的控制。</p><p>需要注意的是，不同的终端可能支持不同的 ANSI 转义码，并且不同操作系统也可能有不同的实现。因此，在编写使用 ANSI 转义码的代码时，建议先测试并确保其在目标终端上正常工作。</p><p>更多详细解释可以参考文章：<a href=https://www.jianshu.com/p/790fc612aaa5>终端颜色控制 - 简书</a>。</p><h1 id=应用程序输出字符会调用-sbi-服务sbi-中发生了什么>应用程序输出字符会调用 SBI 服务，SBI 中发生了什么？<a hidden class=anchor aria-hidden=true href=#应用程序输出字符会调用-sbi-服务sbi-中发生了什么>#</a></h1><blockquote><p>因为对 Rust 语言不熟悉，所以这里的分析是基于 C 语言的 OpenSBI 来分析的，他们的逻辑是一样的。如果有熟悉 Rust 的可以查看 <a href=https://github.com/rustsbi/rustsbi/blob/main/src/instance.rs>RustSBI 源码</a></p></blockquote><p>根据指导书中的解释以及阅读代码，我们知道调用了 <code>printf</code> 最终实际上是调用了 <code>sbi_call</code>。那么 <code>sbi_call</code> 是如何实现的呢？因为我是做驱动开发以及固件开发的，也经常需要使用 OpenSBI，所想多问一句，OpenSBI 是如何实现的呢？OpenSBI 是如何提供服务的呢？它是如何打印出字符的呢？</p><h2 id=内核中的-sbi-调用>内核中的 SBI 调用<a hidden class=anchor aria-hidden=true href=#内核中的-sbi-调用>#</a></h2><p>我们先看一下内核中的 <code>sbi_call</code> 都做了写啥。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// uCore-Tutorial-Code-2023S/os/sbi.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>uint64</span> <span class=n>SBI_CONSOLE_PUTCHAR</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>console_putchar</span><span class=p>(</span><span class=kt>int</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>sbi_call</span><span class=p>(</span><span class=n>SBI_CONSOLE_PUTCHAR</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// uCore-Tutorial-Code-2023S/os/sbi.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=kr>inline</span> <span class=nf>sbi_call</span><span class=p>(</span><span class=n>uint64</span> <span class=n>which</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>arg0</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>arg1</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>arg2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用寄存器变量来保存参数值和系统调用编号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>register</span> <span class=n>uint64</span> <span class=n>a0</span> <span class=k>asm</span><span class=p>(</span><span class=s>&#34;a0&#34;</span><span class=p>)</span> <span class=o>=</span> <span class=n>arg0</span><span class=p>;</span>  <span class=c1>// 将 &#39;arg0&#39; 的值保存在寄存器 &#39;a0&#39; 中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>register</span> <span class=n>uint64</span> <span class=n>a1</span> <span class=k>asm</span><span class=p>(</span><span class=s>&#34;a1&#34;</span><span class=p>)</span> <span class=o>=</span> <span class=n>arg1</span><span class=p>;</span>  <span class=c1>// 将 &#39;arg1&#39; 的值保存在寄存器 &#39;a1&#39; 中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>register</span> <span class=n>uint64</span> <span class=n>a2</span> <span class=k>asm</span><span class=p>(</span><span class=s>&#34;a2&#34;</span><span class=p>)</span> <span class=o>=</span> <span class=n>arg2</span><span class=p>;</span>  <span class=c1>// 将 &#39;arg2&#39; 的值保存在寄存器 &#39;a2&#39; 中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>register</span> <span class=n>uint64</span> <span class=n>a7</span> <span class=k>asm</span><span class=p>(</span><span class=s>&#34;a7&#34;</span><span class=p>)</span> <span class=o>=</span> <span class=n>which</span><span class=p>;</span> <span class=c1>// 将 &#39;which&#39; 的值保存在寄存器 &#39;a7&#39; 中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 内联汇编代码使用 ecall 指令进行系统调用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>asm</span> <span class=k>volatile</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;ecall&#34;</span>  <span class=c1>// 使用 ecall 指令进行系统调用
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 在这段代码中，指令 &#34;ecall&#34; 的输入参数是寄存器 a0 a1 a2 和 a7，输出参数是寄存器 a0
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>:</span> <span class=s>&#34;=r&#34;</span><span class=p>(</span><span class=n>a0</span><span class=p>)</span>  <span class=c1>// 输出操作数：将返回值存储在变量 &#39;a0&#39; 中
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>:</span> <span class=s>&#34;r&#34;</span><span class=p>(</span><span class=n>a0</span><span class=p>),</span> <span class=s>&#34;r&#34;</span><span class=p>(</span><span class=n>a1</span><span class=p>),</span> <span class=s>&#34;r&#34;</span><span class=p>(</span><span class=n>a2</span><span class=p>),</span> <span class=s>&#34;r&#34;</span><span class=p>(</span><span class=n>a7</span><span class=p>)</span>  <span class=c1>// 输入操作数：传递参数和系统调用编号
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>:</span> <span class=s>&#34;memory&#34;</span>  <span class=c1>//  &#34;memory&#34; 标志告诉编译器，这条指令可能会修改内存中的数据，需要进行内存屏障操作来保证数据的正确性。 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a0</span><span class=p>;</span>  <span class=c1>// 返回存储在变量 &#39;a0&#39; 中的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>那么 OpenSBI 如何提供服务？在<code>include/sbi/sbi_ecall.h</code>这种定义了每个<code>ecall</code>服务全局变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//include/sbi/sbi_ecall.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=n>ecall_base</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=n>ecall_legacy</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=n>ecall_time</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=n>ecall_rfence</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=n>ecall_ipi</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=n>ecall_vendor</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=n>ecall_hsm</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=n>ecall_srst</span><span class=p>;</span>
</span></span></code></pre></div><p>在<code>lib/sbi/sbi_ecall.c</code>中注册了所有的<code>ecall</code>服务，并将其加到链表<code>ecall_exts_list</code>中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sbi_ecall_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=o>*</span><span class=n>ext</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sbi_ecall_exts_size</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>ext</span> <span class=o>=</span> <span class=n>sbi_ecall_exts</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=n>ret</span> <span class=o>=</span> <span class=nf>sbi_ecall_register_extension</span><span class=p>(</span><span class=n>ext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sbi_ecall_register_extension</span><span class=p>(</span><span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=o>*</span><span class=n>ext</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=o>*</span><span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ext</span> <span class=o>||</span> <span class=p>(</span><span class=n>ext</span><span class=o>-&gt;</span><span class=n>extid_end</span> <span class=o>&lt;</span> <span class=n>ext</span><span class=o>-&gt;</span><span class=n>extid_start</span><span class=p>)</span> <span class=o>||</span> <span class=o>!</span><span class=n>ext</span><span class=o>-&gt;</span><span class=n>handle</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>SBI_EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>sbi_list_for_each_entry</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ecall_exts_list</span><span class=p>,</span> <span class=n>head</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>start</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>extid_start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>end</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>extid_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>end</span> <span class=o>&lt;</span> <span class=n>ext</span><span class=o>-&gt;</span><span class=n>extid_start</span> <span class=o>||</span> <span class=n>ext</span><span class=o>-&gt;</span><span class=n>extid_end</span> <span class=o>&lt;</span> <span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=cm>/* no overlap */</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=n>SBI_EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>SBI_INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ext</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>sbi_list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ext</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ecall_exts_list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Iterate over list of given type
</span></span></span><span class=line><span class=cl><span class=cm> * @param pos the type * to use as a loop cursor.
</span></span></span><span class=line><span class=cl><span class=cm> * @param head the head for your list.
</span></span></span><span class=line><span class=cl><span class=cm> * @param member the name of the list_struct within the struct.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=cp>#define sbi_list_for_each_entry(pos, head, member) \
</span></span></span><span class=line><span class=cl><span class=cp>	for (pos = sbi_list_entry((head)-&gt;next, typeof(*pos), member);	\
</span></span></span><span class=line><span class=cl><span class=cp>	     &amp;pos-&gt;member != (head); 	\
</span></span></span><span class=line><span class=cl><span class=cp>	     pos = sbi_list_entry(pos-&gt;member.next, typeof(*pos), member))
</span></span></span></code></pre></div><p>那么服务 id 如何和相对应的服务绑定的呢？以<code>ecall_time</code>为例，查看其结构体原型<code>struct sbi_ecall_extension</code> ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// include/sbi/sbi_ecall.h: 23
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>sbi_dlist</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>extid_start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>extid_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=p>(</span><span class=o>*</span> <span class=n>probe</span><span class=p>)(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>extid</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>out_val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=p>(</span><span class=o>*</span> <span class=n>handle</span><span class=p>)(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>extid</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>funcid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		       <span class=k>const</span> <span class=k>struct</span> <span class=n>sbi_trap_regs</span> <span class=o>*</span><span class=n>regs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		       <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>out_val</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		       <span class=k>struct</span> <span class=n>sbi_trap_info</span> <span class=o>*</span><span class=n>out_trap</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>可以看到有 <code>extid_start</code>、<code>extid_end</code> 和 <code>handle</code>。</p><p>目前 OpenSBI 逐步将每个服务的实现都放在了<code>lib/sbi</code>单独文件中，以<code>ecall_time</code>为例，其实现在<code>lib/sbi/sbi_ecall_time.c</code>中。单独为其绑定回调处理函数<code>sbi_ecall_time_handler</code>。但是还有很多服务的实现还是放在了<code>lib/sbi/sbi_ecall_legacy.c</code>中，后续应该会逐步迁移。我们上文使用的<code>SBI_CONSOLE_PUTCHAR</code>服务就是在这里实现的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// lib/sbi/sbi_ecall_legacy.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>sbi_ecall_extension</span> <span class=n>ecall_legacy</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>extid_start</span> <span class=o>=</span> <span class=n>SBI_EXT_0_1_SET_TIMER</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>extid_end</span> <span class=o>=</span> <span class=n>SBI_EXT_0_1_SHUTDOWN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>handle</span> <span class=o>=</span> <span class=n>sbi_ecall_legacy_handler</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>sbi_ecall_legacy_handler</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>extid</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>funcid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				    <span class=k>const</span> <span class=k>struct</span> <span class=n>sbi_trap_regs</span> <span class=o>*</span><span class=n>regs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>out_val</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				    <span class=k>struct</span> <span class=n>sbi_trap_info</span> <span class=o>*</span><span class=n>out_trap</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>sbi_tlb_info</span> <span class=n>tlb_info</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>u32</span> <span class=n>source_hart</span> <span class=o>=</span> <span class=nf>current_hartid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>ulong</span> <span class=n>hmask</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=p>(</span><span class=n>extid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nl>SBI_EXT_0_1_SET_TIMER</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nf>sbi_timer_event_start</span><span class=p>((</span><span class=n>u64</span><span class=p>)</span><span class=n>regs</span><span class=o>-&gt;</span><span class=n>a0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nl>SBI_EXT_0_1_CONSOLE_PUTCHAR</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nf>sbi_putc</span><span class=p>(</span><span class=n>regs</span><span class=o>-&gt;</span><span class=n>a0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nl>SBI_EXT_0_1_CONSOLE_GETCHAR</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>ret</span> <span class=o>=</span> <span class=nf>sbi_getc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这就把 <code>id</code> 与相应的服务函数绑定。一个<code>extid</code>对应一个<code>handler</code>。</p><p>我们可以在找到<code>SBI_EXT_0_1_CONSOLE_PUTCHAR</code>的值，是与 Linux 内核里定义的值是一致的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// include/sbi/sbi_ecall_interface.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/* SBI Extension IDs */</span>
</span></span><span class=line><span class=cl><span class=cp>#define SBI_EXT_0_1_CONSOLE_PUTCHAR		0x1
</span></span></span></code></pre></div><h2 id=ecall-服务调用流程>ecall 服务调用流程<a hidden class=anchor aria-hidden=true href=#ecall-服务调用流程>#</a></h2><ol><li><p>在 <code>firmware/fw_base.S</code> 中注册了 <code>Machine Mode</code> 的 <code>trap handler</code>，即 <code>sbi_trap_handler</code>；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>_start_warm:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Setup trap handler */</span>
</span></span><span class=line><span class=cl>    <span class=nf>la</span>	<span class=no>a4</span><span class=p>,</span> <span class=no>_trap_handler</span>
</span></span><span class=line><span class=cl>    <span class=nf>csrw</span>	<span class=no>CSR_MTVEC</span><span class=p>,</span> <span class=no>a4</span>  <span class=cm>/* CSR_MTVEC = _trap_handler */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>_trap_handler:</span>
</span></span><span class=line><span class=cl>    <span class=nf>TRAP_SAVE_AND_SETUP_SP_T0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>TRAP_SAVE_MEPC_MSTATUS</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>TRAP_SAVE_GENERAL_REGS_EXCEPT_SP_T0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>TRAP_CALL_C_ROUTINE</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>TRAP_RESTORE_GENERAL_REGS_EXCEPT_SP_T0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>TRAP_RESTORE_MEPC_MSTATUS</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>TRAP_RESTORE_SP_T0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>mret</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=na>.macro</span>	<span class=no>TRAP_CALL_C_ROUTINE</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Call C routine */</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span>	<span class=no>a0</span><span class=p>,</span> <span class=no>sp</span><span class=p>,</span> <span class=no>zero</span>
</span></span><span class=line><span class=cl>    <span class=nf>call</span>	<span class=no>sbi_trap_handler</span>
</span></span><span class=line><span class=cl><span class=na>.endm</span>
</span></span></code></pre></div></li><li><p>在 <code>lib/sbi/sbi_trap.c</code> 中定义了 <code>sbi_trap_handler</code>，处理各种 <code>mcause</code>，比如 <code>Illegal Instructions</code>，<code>Misaligned Load & Store</code>, <code>Supervisor & Machine Ecall</code> 等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// lib/sbi/sbi_trap.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>sbi_trap_handler</span><span class=p>(</span><span class=k>struct</span> <span class=n>sbi_trap_regs</span> <span class=o>*</span><span class=n>regs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>mcause</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>CAUSE_ILLEGAL_INSTRUCTION</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>rc</span>  <span class=o>=</span> <span class=nf>sbi_illegal_insn_handler</span><span class=p>(</span><span class=n>mtval</span><span class=p>,</span> <span class=n>regs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>CAUSE_MISALIGNED_LOAD</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>rc</span> <span class=o>=</span> <span class=nf>sbi_misaligned_load_handler</span><span class=p>(</span><span class=n>mtval</span><span class=p>,</span> <span class=n>mtval2</span><span class=p>,</span> <span class=n>mtinst</span><span class=p>,</span> <span class=n>regs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>CAUSE_MISALIGNED_STORE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>rc</span>  <span class=o>=</span> <span class=nf>sbi_misaligned_store_handler</span><span class=p>(</span><span class=n>mtval</span><span class=p>,</span> <span class=n>mtval2</span><span class=p>,</span> <span class=n>mtinst</span><span class=p>,</span> <span class=n>regs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>CAUSE_SUPERVISOR_ECALL</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>CAUSE_MACHINE_ECALL</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>rc</span>  <span class=o>=</span> <span class=nf>sbi_ecall_handler</span><span class=p>(</span><span class=n>regs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* If the trap came from S or U mode, redirect it there */</span>
</span></span><span class=line><span class=cl>        <span class=n>trap</span><span class=p>.</span><span class=n>epc</span> <span class=o>=</span> <span class=n>regs</span><span class=o>-&gt;</span><span class=n>mepc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>trap</span><span class=p>.</span><span class=n>cause</span> <span class=o>=</span> <span class=n>mcause</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>trap</span><span class=p>.</span><span class=n>tval</span> <span class=o>=</span> <span class=n>mtval</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>trap</span><span class=p>.</span><span class=n>tval2</span> <span class=o>=</span> <span class=n>mtval2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>trap</span><span class=p>.</span><span class=n>tinst</span> <span class=o>=</span> <span class=n>mtinst</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>rc</span> <span class=o>=</span> <span class=nf>sbi_trap_redirect</span><span class=p>(</span><span class=n>regs</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>trap</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span></code></pre></div></li><li><p>在 <code>lib/sbi/sbi_ecall.c</code> 中定义了处理 <code>ecall mcause</code> 的 <code>sbi_ecall_handler</code>，它遍历上面 <code>ecall_exts_list</code> 中注册的各种 <code>ecall</code> 服务。</p></li><li><p><code>sbi_ecall_handler</code> 根据 Linux 内核传递的 <code>ext (extension id)</code> 找到链表中对应的 <code>ecall</code> 服务，执行其中的 <code>handle</code> 函数，该函数根据 <code>fid</code> 执行具体的服务内容。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// lib/sbi/sbi_ecall.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sbi_ecall_handler</span><span class=p>(</span><span class=k>struct</span> <span class=n>sbi_trap_regs</span> <span class=o>*</span><span class=n>regs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>extension_id</span> <span class=o>=</span> <span class=n>regs</span><span class=o>-&gt;</span><span class=n>a7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>func_id</span> <span class=o>=</span> <span class=n>regs</span><span class=o>-&gt;</span><span class=n>a6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sbi_trap_info</span> <span class=n>trap</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>out_val</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 遍历所有 ecall 服务
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ext</span> <span class=o>=</span> <span class=nf>sbi_ecall_find_extension</span><span class=p>(</span><span class=n>extension_id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ext</span> <span class=o>&amp;&amp;</span> <span class=n>ext</span><span class=o>-&gt;</span><span class=n>handle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果找到了就执行
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ret</span> <span class=o>=</span> <span class=n>ext</span><span class=o>-&gt;</span><span class=nf>handle</span><span class=p>(</span><span class=n>extension_id</span><span class=p>,</span> <span class=n>func_id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>regs</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>out_val</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>trap</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>extension_id</span> <span class=o>&gt;=</span> <span class=n>SBI_EXT_0_1_SET_TIMER</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=n>extension_id</span> <span class=o>&lt;=</span> <span class=n>SBI_EXT_0_1_SHUTDOWN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>is_0_1_spec</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=n>SBI_ENOTSUPP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们可以发现 <code>extension_id</code> 就是 a7 寄存器，他和我们在 uCore OS 中定义的 <code>SBI_EXT_0_1_CONSOLE_PUTCHAR</code> 是一致的。</p></li></ol><h1 id=程序的内存布局与编译流程>程序的内存布局与编译流程<a hidden class=anchor aria-hidden=true href=#程序的内存布局与编译流程>#</a></h1><h2 id=程序的内存布局>程序的内存布局<a hidden class=anchor aria-hidden=true href=#程序的内存布局>#</a></h2><h1 id=ucore-的编译系统>uCore 的编译系统<a hidden class=anchor aria-hidden=true href=#ucore-的编译系统>#</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>clean</span> <span class=n>build</span> <span class=n>user</span>
</span></span><span class=line><span class=cl><span class=c># 设置伪目标clean、build和user，可以通过命令make来执行这些目标
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>build_kernel</span>
</span></span><span class=line><span class=cl><span class=c># 默认目标为build_kernel，即执行build_kernel目标下的指令
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>LOG</span> <span class=o>?=</span> error
</span></span><span class=line><span class=cl><span class=c># 定义一个变量LOG，默认值是error
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>K</span> <span class=o>=</span> os
</span></span><span class=line><span class=cl><span class=nv>TOOLPREFIX</span> <span class=o>=</span> riscv64-unknown-elf-
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>CC</span> <span class=o>=</span> <span class=k>$(</span>TOOLPREFIX<span class=k>)</span>gcc
</span></span><span class=line><span class=cl><span class=nv>AS</span> <span class=o>=</span> <span class=k>$(</span>TOOLPREFIX<span class=k>)</span>gcc
</span></span><span class=line><span class=cl><span class=nv>LD</span> <span class=o>=</span> <span class=k>$(</span>TOOLPREFIX<span class=k>)</span>ld
</span></span><span class=line><span class=cl><span class=nv>OBJCOPY</span> <span class=o>=</span> <span class=k>$(</span>TOOLPREFIX<span class=k>)</span>objcopy
</span></span><span class=line><span class=cl><span class=nv>OBJDUMP</span> <span class=o>=</span> <span class=k>$(</span>TOOLPREFIX<span class=k>)</span>objdump
</span></span><span class=line><span class=cl><span class=nv>PY</span> <span class=o>=</span> python3
</span></span><span class=line><span class=cl><span class=nv>GDB</span> <span class=o>=</span> <span class=k>$(</span>TOOLPREFIX<span class=k>)</span>gdb
</span></span><span class=line><span class=cl><span class=nv>CP</span> <span class=o>=</span> cp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>MKDIR_P</span> <span class=o>=</span> mkdir -p
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>BUILDDIR</span> <span class=o>=</span> build
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>C_SRCS</span> <span class=o>=</span> <span class=k>$(</span>wildcard <span class=nv>$K</span>/*.c<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># 定义一个变量C_SRCS，使用wildcard函数匹配所有以.c为后缀的文件，并存储在$K目录下
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>AS_SRCS</span> <span class=o>=</span> <span class=k>$(</span>wildcard <span class=nv>$K</span>/*.S<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># 定义一个变量AS_SRCS，使用wildcard函数匹配所有以.S为后缀的文件，并存储在$K目录下
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>C_OBJS</span> <span class=o>=</span> <span class=k>$(</span>addprefix <span class=k>$(</span>BUILDDIR<span class=k>)</span>/, <span class=k>$(</span>addsuffix .o, <span class=k>$(</span>basename <span class=k>$(</span>C_SRCS<span class=k>))))</span>
</span></span><span class=line><span class=cl><span class=c># 定义一个变量C_OBJS，通过addprefix和addsuffix函数将$(C_SRCS)中的路径替换为$(BUILDDIR)，并将后缀修改为.o
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>AS_OBJS</span> <span class=o>=</span> <span class=k>$(</span>addprefix <span class=k>$(</span>BUILDDIR<span class=k>)</span>/, <span class=k>$(</span>addsuffix .o, <span class=k>$(</span>basename <span class=k>$(</span>AS_SRCS<span class=k>))))</span>
</span></span><span class=line><span class=cl><span class=c># 定义一个变量AS_OBJS，通过addprefix和addsuffix函数将$(AS_SRCS)中的路径替换为$(BUILDDIR)，并将后缀修改为.o
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>OBJS</span> <span class=o>=</span> <span class=k>$(</span>C_OBJS<span class=k>)</span> <span class=k>$(</span>AS_OBJS<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># 定义一个变量OBJS，其值为$(C_OBJS)和$(AS_OBJS)的组合
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>HEADER_DEP</span> <span class=o>=</span> <span class=k>$(</span>addsuffix .d, <span class=k>$(</span>basename <span class=k>$(</span>C_OBJS<span class=k>)))</span>
</span></span><span class=line><span class=cl><span class=c># 定义一个变量HEADER_DEP，通过addsuffix函数将$(C_OBJS)中的后缀修改为.d
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=err>-include</span> <span class=k>$(</span><span class=nv>HEADER_DEP</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># 包含$(HEADER_DEP)中的.d文件
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>=</span> -Wall -Werror -O -fno-omit-frame-pointer -ggdb
</span></span><span class=line><span class=cl><span class=c># 定义一个变量CFLAGS，并赋值为-Wall -Werror -O -fno-omit-frame-pointer -ggdb
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -MD
</span></span><span class=line><span class=cl><span class=c># 将-MD选项追加到CFLAGS变量中，用于自动生成依赖关系文件
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -mcmodel<span class=o>=</span>medany
</span></span><span class=line><span class=cl><span class=c># 将-mcmodel=medany选项追加到CFLAGS变量中，用于指定内存模型
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -ffreestanding -fno-common -nostdlib -mno-relax
</span></span><span class=line><span class=cl><span class=c># 将-ffreestanding -fno-common -nostdlib -mno-relax选项追加到CFLAGS变量中，用于编译无操作系统环境下的程序
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -I<span class=nv>$K</span>
</span></span><span class=line><span class=cl><span class=c># 将-I$K选项追加到CFLAGS变量中，用于指定头文件搜索路径为$K目录下
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> <span class=k>$(</span>shell <span class=k>$(</span>CC<span class=k>)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;<span class=p>&amp;</span><span class=m>1</span> <span class=o>&amp;&amp;</span> <span class=nb>echo</span> -fno-stack-protector<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># 将$(CC) -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector命令执行结果追加到CFLAGS变量中，用于禁用栈保护机制
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>LOG</span><span class=k>)</span><span class=err>,</span> <span class=err>error)</span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -D LOG_LEVEL_ERROR
</span></span><span class=line><span class=cl><span class=err>else</span> <span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>LOG</span><span class=k>)</span><span class=err>,</span> <span class=err>warn)</span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -D LOG_LEVEL_WARN
</span></span><span class=line><span class=cl><span class=err>else</span> <span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>LOG</span><span class=k>)</span><span class=err>,</span> <span class=err>info)</span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -D LOG_LEVEL_INFO
</span></span><span class=line><span class=cl><span class=err>else</span> <span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>LOG</span><span class=k>)</span><span class=err>,</span> <span class=err>debug)</span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -D LOG_LEVEL_DEBUG
</span></span><span class=line><span class=cl><span class=err>else</span> <span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>LOG</span><span class=k>)</span><span class=err>,</span> <span class=err>trace)</span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -D LOG_LEVEL_TRACE
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span><span class=line><span class=cl><span class=c># 根据$(LOG)变量的值，向CFLAGS变量追加相应的预处理器选项，相当于添加了一个宏定义，log.h中的LOG_LEVEL_ERROR等宏定义会根据这个宏定义来决定是否生效
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=c># Disable PIE when possible (for Ubuntu 16.10 toolchain)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=err>ifneq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>shell</span> <span class=k>$(</span><span class=nv>CC</span><span class=k>)</span> -<span class=nv>dumpspecs</span> 2&gt;/<span class=nv>dev</span>/<span class=nv>null</span> | <span class=nv>grep</span> -<span class=nv>e</span> &#39;[^<span class=nv>f</span>]<span class=nv>no</span>-<span class=nv>pie</span>&#39;<span class=k>)</span><span class=err>,)</span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -fno-pie -no-pie
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span><span class=line><span class=cl><span class=err>ifneq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>shell</span> <span class=k>$(</span><span class=nv>CC</span><span class=k>)</span> -<span class=nv>dumpspecs</span> 2&gt;/<span class=nv>dev</span>/<span class=nv>null</span> | <span class=nv>grep</span> -<span class=nv>e</span> &#39;[^<span class=nv>f</span>]<span class=nv>nopie</span>&#39;<span class=k>)</span><span class=err>,)</span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>+=</span> -fno-pie -nopie
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span><span class=line><span class=cl><span class=c># 根据系统环境判断是否支持PIE（位置无关执行）选项，并根据情况向CFLAGS变量追加相应的选项
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>LDFLAGS</span> <span class=o>=</span> -z max-page-size<span class=o>=</span><span class=m>4096</span>
</span></span><span class=line><span class=cl><span class=c># 定义一个变量LDFLAGS，并赋值为-z max-page-size=4096
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>$(AS_OBJS)</span><span class=o>:</span> <span class=k>$(</span><span class=nv>BUILDDIR</span><span class=k>)</span>/$<span class=n>K</span>/%.<span class=n>o</span> : $<span class=n>K</span>/%.<span class=n>S</span>
</span></span><span class=line><span class=cl>    @mkdir -p <span class=k>$(</span>@D<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -c $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl><span class=c># 规则：生成$(AS_OBJS)目标所需的依赖文件$(BUILDDIR)/$K/%.o，依赖于$K/%.S，并通过$(CC)命令编译生成目标文件
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>$(C_OBJS)</span><span class=o>:</span> <span class=k>$(</span><span class=nv>BUILDDIR</span><span class=k>)</span>/$<span class=n>K</span>/%.<span class=n>o</span> : $<span class=n>K</span>/%.<span class=n>c</span>  <span class=k>$(</span><span class=nv>BUILDDIR</span><span class=k>)</span>/$<span class=n>K</span>/%.<span class=n>d</span>
</span></span><span class=line><span class=cl>    @mkdir -p <span class=k>$(</span>@D<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -c $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl><span class=c># 规则：生成$(C_OBJS)目标所需的依赖文件$(BUILDDIR)/$K/%.o，依赖于$K/%.c和$(BUILDDIR)/$K/%.d，并通过$(CC)命令编译生成目标文件
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>$(HEADER_DEP)</span><span class=o>:</span> <span class=k>$(</span><span class=nv>BUILDDIR</span><span class=k>)</span>/$<span class=n>K</span>/%.<span class=n>d</span> : $<span class=n>K</span>/%.<span class=n>c</span>
</span></span><span class=line><span class=cl>    @mkdir -p <span class=k>$(</span>@D<span class=k>)</span>
</span></span><span class=line><span class=cl>    @set -e<span class=p>;</span> rm -f <span class=nv>$@</span><span class=p>;</span> <span class=k>$(</span>CC<span class=k>)</span> -MM $&lt; <span class=k>$(</span>INCLUDEFLAGS<span class=k>)</span> &gt; <span class=nv>$@</span>.<span class=nv>$$$$</span><span class=p>;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        sed <span class=s1>&#39;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#39;</span> &lt; <span class=nv>$@</span>.<span class=nv>$$$$</span> &gt; <span class=nv>$@</span><span class=p>;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        rm -f <span class=nv>$@</span>.<span class=nv>$$$$</span>
</span></span><span class=line><span class=cl><span class=c># 规则：生成$(HEADER_DEP)目标所需的依赖文件$(BUILDDIR)/$K/%.d，依赖于$K/%.c，并通过$(CC)命令生成依赖关系文件
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>build</span><span class=o>:</span> <span class=n>build</span>/<span class=n>kernel</span>
</span></span><span class=line><span class=cl><span class=c># 定义一个目标build，其依赖于build/kernel
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>build/kernel</span><span class=o>:</span> <span class=k>$(</span><span class=nv>OBJS</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>LD<span class=k>)</span> <span class=k>$(</span>LDFLAGS<span class=k>)</span> -T os/kernel.ld -o <span class=k>$(</span>BUILDDIR<span class=k>)</span>/kernel <span class=k>$(</span>OBJS<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>OBJDUMP<span class=k>)</span> -S <span class=k>$(</span>BUILDDIR<span class=k>)</span>/kernel &gt; <span class=k>$(</span>BUILDDIR<span class=k>)</span>/kernel.asm
</span></span><span class=line><span class=cl>    <span class=k>$(</span>OBJDUMP<span class=k>)</span> -t <span class=k>$(</span>BUILDDIR<span class=k>)</span>/kernel <span class=p>|</span> sed <span class=s1>&#39;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#39;</span> &gt; <span class=k>$(</span>BUILDDIR<span class=k>)</span>/kernel.sym
</span></span><span class=line><span class=cl>    @echo <span class=s1>&#39;Build kernel done&#39;</span>
</span></span><span class=line><span class=cl><span class=c># 规则：生成build/kernel目标，依赖于$(OBJS)，通过$(LD)命令连接生成kernel，并通过$(OBJDUMP)命令生成汇编文件和符号表
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -rf <span class=k>$(</span>BUILDDIR<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># BOARD
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>BOARD</span>		<span class=o>?=</span> qemu
</span></span><span class=line><span class=cl><span class=nv>SBI</span>			<span class=o>?=</span> rustsbi
</span></span><span class=line><span class=cl><span class=nv>BOOTLOADER</span>	<span class=o>:=</span> ./bootloader/rustsbi-qemu.bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>QEMU</span> <span class=o>=</span> qemu-system-riscv64
</span></span><span class=line><span class=cl><span class=nv>QEMUOPTS</span> <span class=o>=</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-nographic <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-machine virt <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-bios <span class=k>$(</span>BOOTLOADER<span class=k>)</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-kernel build/kernel	<span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>
</span></span><span class=line><span class=cl><span class=nf>run</span><span class=o>:</span> <span class=n>build</span>/<span class=n>kernel</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>QEMU<span class=k>)</span> <span class=k>$(</span>QEMUOPTS<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># QEMU&#39;s gdb stub command line changed in 0.11
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>QEMUGDB</span> <span class=o>=</span> <span class=k>$(</span>shell <span class=k>if</span> <span class=k>$(</span>QEMU<span class=k>)</span> -help <span class=p>|</span> grep -q <span class=s1>&#39;^-gdb&#39;</span><span class=p>;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=k>then</span> <span class=nb>echo</span> <span class=s2>&#34;-gdb tcp::15234&#34;</span><span class=p>;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=k>else</span> <span class=nb>echo</span> <span class=s2>&#34;-s -p 15234&#34;</span><span class=p>;</span> <span class=k>fi</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 启动QEMU并通过GDB调试，此时QEMu会进入后台运行，并暂停执行，等待GDB连接
</span></span></span><span class=line><span class=cl><span class=c># 连接的GDB端口为15234
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>debug</span><span class=o>:</span> <span class=n>build</span>/<span class=n>kernel</span> .<span class=n>gdbinit</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>QEMU<span class=k>)</span> <span class=k>$(</span>QEMUOPTS<span class=k>)</span> -S <span class=k>$(</span>QEMUGDB<span class=k>)</span> <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>	sleep <span class=m>1</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>GDB<span class=k>)</span>
</span></span></code></pre></div><p>编译、运行 uCore 的一些常用命令有如下一些，涉及了后续章节中引入的测试用例中的命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>make run
</span></span><span class=line><span class=cl>make debug
</span></span><span class=line><span class=cl>make clean
</span></span><span class=line><span class=cl><span class=c1># 编译测试用例的前四章</span>
</span></span><span class=line><span class=cl>make user <span class=nv>CHAPTER</span><span class=o>=</span><span class=m>4</span> <span class=nv>LOG</span><span class=o>=</span>trace
</span></span><span class=line><span class=cl><span class=c1># 编译测试用例的第四章</span>
</span></span><span class=line><span class=cl>make user <span class=nv>CHAPTER</span><span class=o>=</span>4_only <span class=nv>LOG</span><span class=o>=</span>trace
</span></span><span class=line><span class=cl><span class=c1># 只运行测试用例的第四章</span>
</span></span><span class=line><span class=cl>make <span class=nb>test</span> <span class=nv>CHAPTER</span><span class=o>=</span>4_only    
</span></span></code></pre></div><h1 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h1><p>makefile 和 qemu</p><p>AS = $(TOOLPREFIX)gas > AS = $(TOOLPREFIX)as</p><h1 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h1><ul><li><a href=https://www.jianshu.com/p/790fc612aaa5>终端颜色控制 - 简书</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://lifeislife.cn/tags/risc-v/>RISC-V</a></li><li><a href=https://lifeislife.cn/tags/os/>OS</a></li><li><a href=https://lifeislife.cn/tags/ucore/>UCore</a></li><li><a href=https://lifeislife.cn/tags/lab/>Lab</a></li><li><a href=https://lifeislife.cn/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC0%E7%AB%A0-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/><span class=title>« 上一页</span><br><span>uCore-实验第 0 章 - 实验环境搭建</span>
</a><a class=next href=https://lifeislife.cn/posts/ucore-%E5%AE%9E%E9%AA%8C%E7%AC%AC5%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/><span class=title>下一页 »</span><br><span>uCore 实验第 5 章 - 进程及进程管理</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share uCore-实验第 1 章 - 应用程序与基本执行环境 on x" href="https://x.com/intent/tweet/?text=uCore-%e5%ae%9e%e9%aa%8c%e7%ac%ac%201%20%e7%ab%a0%20-%20%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%8e%e5%9f%ba%e6%9c%ac%e6%89%a7%e8%a1%8c%e7%8e%af%e5%a2%83&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fucore-%25E5%25AE%259E%25E9%25AA%258C%25E7%25AC%25AC1%25E7%25AB%25A0-%25E5%25BA%2594%25E7%2594%25A8%25E7%25A8%258B%25E5%25BA%258F%25E4%25B8%258E%25E5%259F%25BA%25E6%259C%25AC%25E6%2589%25A7%25E8%25A1%258C%25E7%258E%25AF%25E5%25A2%2583%2f&amp;hashtags=RISC-V%2cOS%2cuCore%2cLab%2cLinux"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share uCore-实验第 1 章 - 应用程序与基本执行环境 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fucore-%25E5%25AE%259E%25E9%25AA%258C%25E7%25AC%25AC1%25E7%25AB%25A0-%25E5%25BA%2594%25E7%2594%25A8%25E7%25A8%258B%25E5%25BA%258F%25E4%25B8%258E%25E5%259F%25BA%25E6%259C%25AC%25E6%2589%25A7%25E8%25A1%258C%25E7%258E%25AF%25E5%25A2%2583%2f&amp;title=uCore-%e5%ae%9e%e9%aa%8c%e7%ac%ac%201%20%e7%ab%a0%20-%20%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%8e%e5%9f%ba%e6%9c%ac%e6%89%a7%e8%a1%8c%e7%8e%af%e5%a2%83&amp;summary=uCore-%e5%ae%9e%e9%aa%8c%e7%ac%ac%201%20%e7%ab%a0%20-%20%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%8e%e5%9f%ba%e6%9c%ac%e6%89%a7%e8%a1%8c%e7%8e%af%e5%a2%83&amp;source=https%3a%2f%2flifeislife.cn%2fposts%2fucore-%25E5%25AE%259E%25E9%25AA%258C%25E7%25AC%25AC1%25E7%25AB%25A0-%25E5%25BA%2594%25E7%2594%25A8%25E7%25A8%258B%25E5%25BA%258F%25E4%25B8%258E%25E5%259F%25BA%25E6%259C%25AC%25E6%2589%25A7%25E8%25A1%258C%25E7%258E%25AF%25E5%25A2%2583%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share uCore-实验第 1 章 - 应用程序与基本执行环境 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifeislife.cn%2fposts%2fucore-%25E5%25AE%259E%25E9%25AA%258C%25E7%25AC%25AC1%25E7%25AB%25A0-%25E5%25BA%2594%25E7%2594%25A8%25E7%25A8%258B%25E5%25BA%258F%25E4%25B8%258E%25E5%259F%25BA%25E6%259C%25AC%25E6%2589%25A7%25E8%25A1%258C%25E7%258E%25AF%25E5%25A2%2583%2f&title=uCore-%e5%ae%9e%e9%aa%8c%e7%ac%ac%201%20%e7%ab%a0%20-%20%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%8e%e5%9f%ba%e6%9c%ac%e6%89%a7%e8%a1%8c%e7%8e%af%e5%a2%83"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share uCore-实验第 1 章 - 应用程序与基本执行环境 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifeislife.cn%2fposts%2fucore-%25E5%25AE%259E%25E9%25AA%258C%25E7%25AC%25AC1%25E7%25AB%25A0-%25E5%25BA%2594%25E7%2594%25A8%25E7%25A8%258B%25E5%25BA%258F%25E4%25B8%258E%25E5%259F%25BA%25E6%259C%25AC%25E6%2589%25A7%25E8%25A1%258C%25E7%258E%25AF%25E5%25A2%2583%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share uCore-实验第 1 章 - 应用程序与基本执行环境 on whatsapp" href="https://api.whatsapp.com/send?text=uCore-%e5%ae%9e%e9%aa%8c%e7%ac%ac%201%20%e7%ab%a0%20-%20%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%8e%e5%9f%ba%e6%9c%ac%e6%89%a7%e8%a1%8c%e7%8e%af%e5%a2%83%20-%20https%3a%2f%2flifeislife.cn%2fposts%2fucore-%25E5%25AE%259E%25E9%25AA%258C%25E7%25AC%25AC1%25E7%25AB%25A0-%25E5%25BA%2594%25E7%2594%25A8%25E7%25A8%258B%25E5%25BA%258F%25E4%25B8%258E%25E5%259F%25BA%25E6%259C%25AC%25E6%2589%25A7%25E8%25A1%258C%25E7%258E%25AF%25E5%25A2%2583%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share uCore-实验第 1 章 - 应用程序与基本执行环境 on telegram" href="https://telegram.me/share/url?text=uCore-%e5%ae%9e%e9%aa%8c%e7%ac%ac%201%20%e7%ab%a0%20-%20%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%8e%e5%9f%ba%e6%9c%ac%e6%89%a7%e8%a1%8c%e7%8e%af%e5%a2%83&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fucore-%25E5%25AE%259E%25E9%25AA%258C%25E7%25AC%25AC1%25E7%25AB%25A0-%25E5%25BA%2594%25E7%2594%25A8%25E7%25A8%258B%25E5%25BA%258F%25E4%25B8%258E%25E5%259F%25BA%25E6%259C%25AC%25E6%2589%25A7%25E8%25A1%258C%25E7%258E%25AF%25E5%25A2%2583%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share uCore-实验第 1 章 - 应用程序与基本执行环境 on ycombinator" href="https://news.ycombinator.com/submitlink?t=uCore-%e5%ae%9e%e9%aa%8c%e7%ac%ac%201%20%e7%ab%a0%20-%20%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%8e%e5%9f%ba%e6%9c%ac%e6%89%a7%e8%a1%8c%e7%8e%af%e5%a2%83&u=https%3a%2f%2flifeislife.cn%2fposts%2fucore-%25E5%25AE%259E%25E9%25AA%258C%25E7%25AC%25AC1%25E7%25AB%25A0-%25E5%25BA%2594%25E7%2594%25A8%25E7%25A8%258B%25E5%25BA%258F%25E4%25B8%258E%25E5%259F%25BA%25E6%259C%25AC%25E6%2589%25A7%25E8%25A1%258C%25E7%258E%25AF%25E5%25A2%2583%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://lifeislife-1.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://lifeislife.cn/>夜云泊</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>