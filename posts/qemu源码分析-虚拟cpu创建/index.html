<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QEMU 源码分析-虚拟 CPU 创建 | 夜云泊</title>
<meta name=keywords content="QEMU,Linux"><meta name=description content="流程图 先开个头吧，把创建流程稍微捋一下，找到创建虚拟 CPU 的模块。至于中间的流程还没有详细分析，万事开头难，先上手再说吧。 qemu_add_op"><meta name=author content="Dominic Zhang"><link rel=canonical href=https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9Fcpu%E5%88%9B%E5%BB%BA/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://lifeislife.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lifeislife.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lifeislife.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://lifeislife.cn/apple-touch-icon.png><link rel=mask-icon href=https://lifeislife.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9Fcpu%E5%88%9B%E5%BB%BA/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PS8L2EEEPR")}</script><meta property="og:title" content="QEMU 源码分析-虚拟 CPU 创建"><meta property="og:description" content="流程图 先开个头吧，把创建流程稍微捋一下，找到创建虚拟 CPU 的模块。至于中间的流程还没有详细分析，万事开头难，先上手再说吧。 qemu_add_op"><meta property="og:type" content="article"><meta property="og:url" content="https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9Fcpu%E5%88%9B%E5%BB%BA/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-01T18:22:14+00:00"><meta property="article:modified_time" content="2021-09-01T18:22:14+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="QEMU 源码分析-虚拟 CPU 创建"><meta name=twitter:description content="流程图 先开个头吧，把创建流程稍微捋一下，找到创建虚拟 CPU 的模块。至于中间的流程还没有详细分析，万事开头难，先上手再说吧。 qemu_add_op"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifeislife.cn/posts/"},{"@type":"ListItem","position":2,"name":"QEMU 源码分析-虚拟 CPU 创建","item":"https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9Fcpu%E5%88%9B%E5%BB%BA/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"QEMU 源码分析-虚拟 CPU 创建","name":"QEMU 源码分析-虚拟 CPU 创建","description":"流程图 先开个头吧，把创建流程稍微捋一下，找到创建虚拟 CPU 的模块。至于中间的流程还没有详细分析，万事开头难，先上手再说吧。 qemu_add_op","keywords":["QEMU","Linux"],"articleBody":"流程图 先开个头吧，把创建流程稍微捋一下，找到创建虚拟 CPU 的模块。至于中间的流程还没有详细分析，万事开头难，先上手再说吧。\nqemu_add_opts解析 qemu 的命令行 qemu_init函数中下面这一长串内容，就是在解析命令行的参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 qemu add opts (\u0026qemu drive opts); qemu add drive opts(\u0026qemu Legacy drive opts); qemu add drive opts (\u0026qemu common drive opts); qemu add drive opts (\u0026qemu drive opts); qemu add drive opts (sbdry runtime opts); qemu add opts (qemu chardev opts); qemu add opts (\u0026qemu device opts); qemu add opts (\u0026qemu netdev opts); qemu add opts (\u0026qemu nic opts); qemu add opts (sqemu net opts qemu add opts (\u0026qemu rtc opts) qemu add opts (\u0026qemu global_opts); qemu add opts (\u0026qemu mon opts); qemu add opts (sqemu trace opts); . . . 为什么有这么多的 opts呢？这是因为，实际运行中创建的kvm参数会复杂N倍。这里我们贴一个开源云平台软件 OpenStack 创建出来的KVM的参数，如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 qemu-system-x86_64 -enable-kvm -name instance-00000024 -machine pc-i440fx-trusty,accel=kvm,usb=off -cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme -m 2048 -smp 1,sockets=1,cores=1,threads=1 ...... -rtc base=utc,driftfix=slew -drive file=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if=none,id=drive-virtio-disk0,format=qcow2,cache=none -device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x4,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1 -netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37 -device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3 -chardev file,id=charserial0,path=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/console.log -vnc 0.0.0.0:12 -device cirrus-vga,id=video0,bus=pci.0,addr=0x2 -enable-kvm：表示启用硬件辅助虚拟化。\n-name instance-00000024：表示虚拟机的名称。\n-machine pc-i440fx-trusty,accel=kvm,usb=off：machine 是什么呢？其实就是计算机体系结构。不知道什么是体系结构的话，可以订阅极客时间的另一个专栏《深入浅出计算机组成原理》。 qemu 会模拟多种体系结构，常用的有普通 PC 机，也即 x86 的 32 位或者 64 位的体系结构、Mac 电脑 PowerPC 的体系结构、Sun 的体系结构、MIPS 的体系结构，精简指令集。如果使用 KVM hardware-assisted virtualization，也即 BIOS 中 VD-T 是打开的，则参数中 accel=kvm。如果不使用 hardware-assisted virtualization，用的是纯模拟，则有参数 accel = tcg，-no-kvm。\n-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme：表示设置 CPU，SandyBridge 是 Intel 处理器，后面的加号都是添加的 CPU 的参数，这些参数会显示在 /proc/cpuinfo 里面。\n-m 2048：表示内存。\n-smp 1,sockets=1,cores=1,threads=1：SMP 我们解析过，叫对称多处理器，和NUMA 对应。qemu 仿真了一个具有 1 个 vcpu，一个 socket，一个 core，一个 threads 的处理器。 socket、core、threads 是什么概念呢？socket 就是主板上插 CPU 的槽的数目，也即常说的“路”，core 就是我们平时说的“核”，即双核、4 核等。thread 就是每个 core 的硬件线程数，即超线程。举个具体的例子，某个服务器是：2 路 4 核超线程（一般默认为 2 个线程），通过 cat /proc/cpuinfo，我们看到的是 242=16 个processor，很多人也习惯成为 16 核了。\n-rtc base=utc,driftfix=slew：表示系统时间由参数 -rtc 指定。\n-device cirrus-vga,id=video0,bus=pci.0,addr=0x2：表示显示器用参数 -vga 设置，默认为 cirrus，它模拟了 CL-GD5446PCI VGA card。\n有关网卡，使用 -net 参数和 -device。\n从 HOST 角度：-netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37。\n从 GUEST 角度：-device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3。\n有关硬盘，使用 -hda -hdb，或者使用 -drive 和 -device。\n从 HOST 角度：-drive file=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if=none,id=drive-virtio-disk0,format=qcow2,cache=none\n从 GUEST 角度：-device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x4,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1\n-vnc 0.0.0.0:12：设置 VNC。\nmodule_call_init初始化所有模块 1 2 3 4 int main() --\u003e qemu_init() --\u003e qemu_init_subsystems() --\u003e module_call_init() 当虚拟机真的要使用物理资源的时候，对下面的物理机上的资源要进行请求，所以它的工作模式有点儿类似操作系统对接驱动。驱动要符合一定的格式，才能算操作系统的一个模块。同理，qemu 为了模拟各种各样的设备，也需要管理各种各样的模块，这些模块也需要符合一定的格式。\n定义一个 qemu 模块会调用 type_init。例如，kvm 的模块要在 accel/kvm/kvm-all.c 文件里面实现。在这个文件里面，有一行下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 static const TypeInfo kvm_accel_type = { .name = TYPE_KVM_ACCEL, .parent = TYPE_ACCEL, .instance_init = kvm_accel_instance_init, .class_init = kvm_accel_class_init, .instance_size = sizeof(KVMState), }; static void kvm_type_init(void) { type_register_static(\u0026kvm_accel_type); } type_init(kvm_type_init); 找到type_init的定义\n1 #define type_init(function) module_init(function, MODULE_INIT_QOM) 从代码里面的定义我们可以看出来，type_init 后面的参数是一个函数，调用 type_init 就相当于调用 module_init，在这里函数就是 kvm_type_init，类型就是 MODULE_INIT_QOM。\n再查看一下module_init的定义\n1 2 3 4 5 6 //include/qemu/module.h #define module_init(function, type) \\ static void __attribute__((constructor)) do_qemu_init_ ## function(void) \\ { \\ register_module_init(function, type); \\ } module_init 最终要调用 register_module_init。属于 MODULE_INIT_QOM 这种类型的，有一个 Module 列表 ModuleTypeList，列表里面是一项一项的 ModuleEntry。KVM 就是其中一项，并且会初始化每一项的 init 函数为参数表示的函数 fn，也即 KVM 这个 module 的 init 函数就是 kvm_type_init。\n当然，MODULE_INIT_QOM 这种类型会有很多很多的 module，从后面的代码我们可以看到，所有调用 type_init 的地方都注册了一个 MODULE_INIT_QOM 类型的 Module。\n了解了 Module 的注册机制，我们继续回到 qemu_init_subsystems 函数中 module_call_init 的调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void qemu_init_subsystems(void) { Error *err; os_set_line_buffering(); module_call_init(MODULE_INIT_TRACE); qemu_init_cpu_list(); qemu_init_cpu_loop(); qemu_mutex_lock_iothread(); atexit(qemu_run_exit_notifiers); module_call_init(MODULE_INIT_QOM); module_call_init(MODULE_INIT_MIGRATION); . . . } 1 2 3 4 5 6 7 8 9 10 // utils/module.c void module_call_init(module_init_type type) { ModuleTypeList *l; ModuleEntry *e; l = find_type(type); QTAILQ_FOREACH(e, l, node) { e-\u003einit(); } } 在 module_call_init 中，我们会找到 MODULE_INIT_QOM 这种类型对应的 ModuleTypeList，找出列表中所有的 ModuleEntry，然后调用每个 ModuleEntry 的 init 函数。这里需要注意的是，在 module_call_init 调用的这一步，所有 Module 的 init 函数都已经被调用过了。\n后面我们会看到很多的 Module，当我们后面再次遇到时，需要意识到，它的 init 函数在这里也被调用过了。这里我们还是以对于 kvm 这个 module 为例子，看看它的 init 函数都做了哪些事情。我们会发现，其实它调用的是 kvm_type_init。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 static void kvm_type_init(void) { type_register_static(\u0026kvm_accel_type); } TypeImpl *type_register_static(const TypeInfo *info) { return type_register(info); } TypeImpl *type_register(const TypeInfo *info) { assert(info-\u003eparent); return type_register_internal(info); } static TypeImpl *type_register_internal(const TypeInfo *info) { TypeImpl *ti; ti = type_new(info); type_table_add(ti); return ti; } static TypeImpl *type_new(const TypeInfo *info) { TypeImpl *ti = g_malloc0(sizeof(*ti)); int i; if (type_table_lookup(info-\u003ename) != NULL) { } ti-\u003ename = g_strdup(info-\u003ename); ti-\u003eparent = g_strdup(info-\u003eparent); ti-\u003eclass_size = info-\u003eclass_size; ti-\u003einstance_size = info-\u003einstance_size; ti-\u003eclass_init = info-\u003eclass_init; ti-\u003eclass_base_init = info-\u003eclass_base_init; ti-\u003eclass_data = info-\u003eclass_data; ti-\u003einstance_init = info-\u003einstance_init; ti-\u003einstance_post_init = info-\u003einstance_post_init; ti-\u003einstance_finalize = info-\u003einstance_finalize; ti-\u003eabstract = info-\u003eabstract; for (i = 0; info-\u003einterfaces \u0026\u0026 info-\u003einterfaces[i].type; i++) { ti-\u003einterfaces[i].typename = g_strdup(info-\u003einterfaces[i].type); } ti-\u003enum_interfaces = i; return ti; } static void type_table_add(TypeImpl *ti) { assert(!enumerating_types); g_hash_table_insert(type_table_get(), (void *)ti-\u003ename, ti); } static GHashTable *type_table_get(void) { static GHashTable *type_table; if (type_table == NULL) { type_table = g_hash_table_new(g_str_hash, g_str_equal); } return type_table; } static const TypeInfo kvm_accel_type = { .name = TYPE_KVM_ACCEL, .parent = TYPE_ACCEL, .class_init = kvm_accel_class_init, .instance_size = sizeof(KVMState), }; 调用流程如下：虚线表示返回\n每一个 Module 既然要模拟某种设备，那应该定义一种类型 TypeImpl 来表示这些设备，这其实是一种面向对象编程的思路，只不过这里用的是纯 C 语言的实现，所以需要变相实现一下类和对象。\nkvm_type_init 会注册 kvm_accel_type，定义上面的代码，我们可以认为这样动态定义了一个类。这个类的名字是 TYPE_KVM_ACCEL，这个类有父类 TYPE_ACCEL，这个类的初始化应该调用函数 kvm_accel_class_init。如果用这个类声明一个对象，对象的大小应该是 instance_size。\n在 type_register_internal 中，我们会根据 kvm_accel_type 这个 TypeInfo，创建一个TypeImpl 来表示这个新注册的类，也就是说，TypeImpl 才是我们想要声明的那个 class。在 qemu 里面，有一个全局的哈希表 type_table，用来存放所有定义的类。在 type_new 里面，我们先从全局表里面根据名字type_table_lookup查找找这个类。如果找到，说明这个类曾经被注册过，就报错；如果没有找到，说明这是一个新的类，则将 TypeInfo 里面信息填到 TypeImpl 里面。type_table_add 会将这个类注册到全局的表里面。到这里，我们注意，class_init 还没有被调用，也即这个类现在还处于纸面的状态。\n这点更加像 Java 的反射机制了。在 Java 里面，对于一个类，首先我们写代码的时候要写一个 class xxx 的定义，编译好就放在.class 文件中，这也是出于纸面的状态。然后，Java 会有一个 Class 对象，用于读取和表示这个纸面上的 class xxx，可以生成真正的对象。\n相同的过程在后面的代码中我们也可以看到，class_init 会生成XXXClass，就相当于 Java 里面的 Class对象，TypeImpl 还会有一个 instance_init 函数，相当于构造函数，用于根据 XXXClass 生成 Object，这就相当于 Java 反射里面最终创建的对象。和构造函数对应的还有 instance_finalize，相当于析构函数。\n这一套反射机制放在 qom 文件夹下面，全称 QEMU Object Model，也即用 C 实现了一套面向对象的反射机制。\n初始化 machine 1 2 //vl.c qemu_create_machine (select_machine()); 在创建 machine 之前，先要通过select_machine确定一个machine。select_machine又是怎么确定的呢，这就和我们命令行的输入有关，比如我们-m spike，那么这里就会选择spike作为machine。它的定义在hw/riscv/spike.c中。\n在源码最后有这么一句，会和我们上面解析的type_init 是一样的，在全局的表里面注册了一个全局的名字是spike的纸面上的 class，也即 TypeImpl。\n1 type_init(spike_machine_init_reqister_types) 现在全局表中有这个纸面上的 class 了。我们回到 select_machine。\n在 select_machine 中，有两种方式可以生成 MachineClass。一种方式是 find_default_machine，找一个默认的；另一种方式是 machine_parse，通过解析参数生成 MachineClass。无论哪种方式，都会调用 object_class_get_list 获得一个 MachineClass 的列表，然后在里面找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 static MachineClass *select_machine(void) { GSList *machines = object_class_get_list(TYPE_MACHINE, false); MachineClass *machine_class = find_default_machine(machines); const char *optarg; QemuOpts *opts; Location loc; loc_push_none(\u0026loc); opts = qemu_get_machine_opts(); qemu_opts_loc_restore(opts); optarg = qemu_opt_get(opts, \"type\"); if (optarg) { machine_class = machine_parse(optarg, machines); } if (!machine_class) { error_report(\"No machine specified, and there is no default\"); error_printf(\"Use -machine help to list supported machines\\n\"); exit(1); } loc_pop(\u0026loc); g_slist_free(machines); return machine_class; } static MachineClass *find_default_machine(GSList *machines) { GSList *el; MachineClass *default_machineclass = NULL; for (el = machines; el; el = el-\u003enext) { MachineClass *mc = el-\u003edata; if (mc-\u003eis_default) { assert(default_machineclass == NULL \u0026\u0026 \"Multiple default machines\"); default_machineclass = mc; } } return default_machineclass; } static MachineClass *machine_parse(const char *name, GSList *machines) { MachineClass *mc; GSList *el; if (is_help_option(name)) { printf(\"Supported machines are:\\n\"); machines = g_slist_sort(machines, machine_class_cmp); for (el = machines; el; el = el-\u003enext) { MachineClass *mc = el-\u003edata; if (mc-\u003ealias) { printf(\"%-20s %s (alias of %s)\\n\", mc-\u003ealias, mc-\u003edesc, mc-\u003ename); } printf(\"%-20s %s%s%s\\n\", mc-\u003ename, mc-\u003edesc, mc-\u003eis_default ? \" (default)\" : \"\", mc-\u003edeprecation_reason ? \" (deprecated)\" : \"\"); } exit(0); } mc = find_machine(name, machines); if (!mc) { error_report(\"unsupported machine type\"); error_printf(\"Use -machine help to list supported machines\\n\"); exit(1); } return mc; } object_class_get_list 定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GSList *object_class_get_list(const char *implements_type,bool include_abstract) { GSList *list = NULL; object_class_foreach(object_class_get_list_tramp, implements_type, include_abstract, \u0026list); return list; } void object_class_foreach(void (*fn)(ObjectClass *klass, void *opaque), const char *implements_type, bool include_abstract, void *opaque) { OCFData data = { fn, implements_type, include_abstract, opaque }; enumerating_types = true; g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, \u0026data); enumerating_types = false; } 在全局表 type_table_get() 中，对于每一项 TypeImpl，我们都执行 object_class_foreach_tramp。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 static void object_class_foreach_tramp(gpointer key, gpointer value, gpointer opaque) { OCFData *data = opaque; TypeImpl *type = value; ObjectClass *k; type_initialize(type); k = type-\u003eclass; if (!data-\u003einclude_abstract \u0026\u0026 type-\u003eabstract) { return; } if (data-\u003eimplements_type \u0026\u0026 !object_class_dynamic_cast(k, data-\u003eimplements_type)) { return; } data-\u003efn(k, data-\u003eopaque); } 在 object_class_foreach_tramp 中，会调用将 type_initialize，这里面会调用 class_init 将纸面上的 class 也即 TypeImpl 变为 ObjectClass，ObjectClass 是所有Class 类的祖先，MachineClass 是它的子类。\n因为在 machine 的命令行里面，我们指定了名字为spike，就肯定能够找到我们注册过了的 TypeImpl，并调用它的 class_init 函数。\n所以，当 select_machine 执行完毕后，就有一个 MachineClass 了。\n接着，我们回到 qemu_create_machine 中的object_new_with_class。这就很好理解了，MachineClass 是一个 Class 类，接下来应该通过它生成一个 Instance，也即对象，这就是 object_new_with_class 的作用。\nobject_new_with_class 中，TypeImpl 的 instance_init 会被调用，创建一个对象。current_machine 就是这个对象，它的类型是MachineState。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Object *object_new_with_class(ObjectClass *klass) { return object_new_with_type(klass-\u003etype); } static Object *object_new_with_type(Type type) { Object *obj; type_initialize(type); obj = g_malloc(type-\u003einstance_size); object_initialize_with_type(obj, type-\u003einstance_size, type); obj-\u003efree = g_free; return obj; } 至此，绕了这么大一圈，有关体系结构的对象才创建完毕，接下来很多的设备的初始化，包括 CPU 和内存的初始化，都是围绕着体系结构的对象来的，后面我们会常常看到current_machine。\n参考 Qemu CPU 虚拟化 - 人生一世，草木一秋。 - 博客园 【原创】Linux 虚拟化 KVM-Qemu 分析（四）之 CPU 虚拟化（2） - LoyenWang - 博客园\n","wordCount":"4827","inLanguage":"zh","datePublished":"2021-09-01T18:22:14Z","dateModified":"2021-09-01T18:22:14Z","author":{"@type":"Person","name":"Dominic Zhang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%99%9A%E6%8B%9Fcpu%E5%88%9B%E5%BB%BA/"},"publisher":{"@type":"Organization","name":"夜云泊","logo":{"@type":"ImageObject","url":"https://lifeislife.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lifeislife.cn/ accesskey=h title="夜云泊 (Alt + H)">夜云泊</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lifeislife.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://lifeislife.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://lifeislife.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://lifeislife.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lifeislife.cn/>主页</a>&nbsp;»&nbsp;<a href=https://lifeislife.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">QEMU 源码分析-虚拟 CPU 创建</h1><div class=post-meta><span title='2021-09-01 18:22:14 +0000 UTC'>九月 1, 2021</span>&nbsp;·&nbsp;10 分钟&nbsp;·&nbsp;4827 字&nbsp;·&nbsp;Dominic Zhang</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#流程图>流程图</a></li><li><a href=#qemu_add_opts解析-qemu-的命令行><code>qemu_add_opts</code>解析 qemu 的命令行</a></li><li><a href=#module_call_init初始化所有模块><code>module_call_init</code>初始化所有模块</a></li><li><a href=#初始化-machine>初始化 machine</a></li><li><a href=#参考>参考</a></li></ul></nav></div></details></div><div class=post-content><h2 id=流程图>流程图<a hidden class=anchor aria-hidden=true href=#流程图>#</a></h2><p>先开个头吧，把创建流程稍微捋一下，找到创建虚拟 CPU 的模块。至于中间的流程还没有详细分析，万事开头难，先上手再说吧。</p><p><img loading=lazy src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210901182329.svg alt></p><h2 id=qemu_add_opts解析-qemu-的命令行><code>qemu_add_opts</code>解析 qemu 的命令行<a hidden class=anchor aria-hidden=true href=#qemu_add_opts解析-qemu-的命令行>#</a></h2><p><code>qemu_init</code>函数中下面这一长串内容，就是在解析命令行的参数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=nf>opts</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>qemu</span> <span class=n>drive</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=n>drive</span> <span class=nf>opts</span><span class=p>(</span><span class=o>&amp;</span><span class=n>qemu</span> <span class=n>Legacy</span> <span class=n>drive</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=n>drive</span> <span class=nf>opts</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>qemu</span> <span class=n>common</span> <span class=n>drive</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=n>drive</span> <span class=nf>opts</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>qemu</span> <span class=n>drive</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=n>drive</span> <span class=nf>opts</span> <span class=p>(</span><span class=n>sbdry</span> <span class=n>runtime</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=nf>opts</span> <span class=p>(</span><span class=n>qemu</span> <span class=n>chardev</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=nf>opts</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>qemu</span> <span class=n>device</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=nf>opts</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>qemu</span> <span class=n>netdev</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=nf>opts</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>qemu</span> <span class=n>nic</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=nf>opts</span> <span class=p>(</span><span class=n>sqemu</span> <span class=n>net</span> <span class=n>opts</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=nf>opts</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>qemu</span> <span class=n>rtc</span> <span class=n>opts</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=nf>opts</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>qemu</span> <span class=n>global_opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=nf>opts</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>qemu</span> <span class=n>mon</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>qemu</span> <span class=n>add</span> <span class=nf>opts</span> <span class=p>(</span><span class=n>sqemu</span> <span class=n>trace</span> <span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>.</span>
</span></span></code></pre></td></tr></table></div></div><p>为什么有这么多的 <code>opts</code>呢？这是因为，实际运行中创建的<code>kvm</code>参数会复杂<code>N</code>倍。这里我们贴一个开源云平台软件 <code>OpenStack</code> 创建出来的<code>KVM</code>的参数，如下所示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>qemu-system-x86_64
</span></span><span class=line><span class=cl>-enable-kvm
</span></span><span class=line><span class=cl>-name instance-00000024
</span></span><span class=line><span class=cl>-machine pc-i440fx-trusty,accel<span class=o>=</span>kvm,usb<span class=o>=</span>off
</span></span><span class=line><span class=cl>-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme
</span></span><span class=line><span class=cl>-m <span class=m>2048</span>
</span></span><span class=line><span class=cl>-smp 1,sockets<span class=o>=</span>1,cores<span class=o>=</span>1,threads<span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl>......
</span></span><span class=line><span class=cl>-rtc <span class=nv>base</span><span class=o>=</span>utc,driftfix<span class=o>=</span>slew
</span></span><span class=line><span class=cl>-drive <span class=nv>file</span><span class=o>=</span>/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if<span class=o>=</span>none,id<span class=o>=</span>drive-virtio-disk0,format<span class=o>=</span>qcow2,cache<span class=o>=</span>none
</span></span><span class=line><span class=cl>-device virtio-blk-pci,scsi<span class=o>=</span>off,bus<span class=o>=</span>pci.0,addr<span class=o>=</span>0x4,drive<span class=o>=</span>drive-virtio-disk0,id<span class=o>=</span>virtio-disk0,bootindex<span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl>-netdev tap,fd<span class=o>=</span>32,id<span class=o>=</span>hostnet0,vhost<span class=o>=</span>on,vhostfd<span class=o>=</span><span class=m>37</span>
</span></span><span class=line><span class=cl>-device virtio-net-pci,netdev<span class=o>=</span>hostnet0,id<span class=o>=</span>net0,mac<span class=o>=</span>fa:16:3e:d1:2d:99,bus<span class=o>=</span>pci.0,addr<span class=o>=</span>0x3
</span></span><span class=line><span class=cl>-chardev file,id<span class=o>=</span>charserial0,path<span class=o>=</span>/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/console.log
</span></span><span class=line><span class=cl>-vnc 0.0.0.0:12
</span></span><span class=line><span class=cl>-device cirrus-vga,id<span class=o>=</span>video0,bus<span class=o>=</span>pci.0,addr<span class=o>=</span>0x2
</span></span></code></pre></td></tr></table></div></div><ul><li><p><code>-enable-kvm</code>：表示启用硬件辅助虚拟化。</p></li><li><p><code>-name instance-00000024</code>：表示虚拟机的名称。</p></li><li><p><code>-machine pc-i440fx-trusty,accel=kvm,usb=off</code>：machine 是什么呢？其实就是计算机体系结构。不知道什么是体系结构的话，可以订阅极客时间的另一个专栏《深入浅出计算机组成原理》。
qemu 会模拟多种体系结构，常用的有普通 PC 机，也即 x86 的 32 位或者 64 位的体系结构、Mac 电脑 PowerPC 的体系结构、Sun 的体系结构、MIPS 的体系结构，精简指令集。如果使用 KVM hardware-assisted virtualization，也即 BIOS 中 VD-T 是打开的，则参数中 <code>accel=kvm</code>。如果不使用 <code>hardware-assisted virtualization</code>，用的是纯模拟，则有参数 <code>accel = tcg</code>，<code>-no-kvm</code>。</p></li><li><p><code>-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme</code>：表示设置 CPU，SandyBridge 是 Intel 处理器，后面的加号都是添加的 CPU 的参数，这些参数会显示在 /proc/cpuinfo 里面。</p></li><li><p><code>-m 2048</code>：表示内存。</p></li><li><p><code>-smp 1,sockets=1,cores=1,threads=1</code>：<code>SMP</code> 我们解析过，叫对称多处理器，和<code>NUMA</code> 对应。qemu 仿真了一个具有 1 个 <code>vcpu</code>，一个 <code>socket</code>，一个 <code>core</code>，一个 <code>threads</code> 的处理器。
<code>socket</code>、<code>core</code>、<code>threads</code> 是什么概念呢？<code>socket</code> 就是主板上插 CPU 的槽的数目，也即常说的“路”，<code>core</code> 就是我们平时说的“核”，即双核、4 核等。<code>thread</code> 就是每个 core 的硬件线程数，即超线程。举个具体的例子，某个服务器是：2 路 4 核超线程（一般默认为 2 个线程），通过 <code>cat /proc/cpuinfo</code>，我们看到的是 242=16 个<code>processor</code>，很多人也习惯成为 16 核了。</p></li><li><p><code>-rtc base=utc,driftfix=slew</code>：表示系统时间由参数 <code>-rtc</code> 指定。</p></li><li><p><code>-device cirrus-vga,id=video0,bus=pci.0,addr=0x2</code>：表示显示器用参数 <code>-vga</code> 设置，默认为 <code>cirrus</code>，它模拟了 <code>CL-GD5446PCI VGA card</code>。</p></li><li><p>有关网卡，使用 <code>-net</code> 参数和 <code>-device</code>。</p></li><li><p>从 HOST 角度：<code>-netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37</code>。</p></li><li><p>从 GUEST 角度：<code>-device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3</code>。</p></li><li><p>有关硬盘，使用 <code>-hda -hdb</code>，或者使用 <code>-drive</code> 和 <code>-device</code>。</p></li><li><p>从 HOST 角度：<code>-drive file=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if=none,id=drive-virtio-disk0,format=qcow2,cache=none</code></p></li><li><p>从 GUEST 角度：<code>-device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x4,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1</code></p></li><li><p><code>-vnc 0.0.0.0:12</code>：设置 VNC。</p></li></ul><h2 id=module_call_init初始化所有模块><code>module_call_init</code>初始化所有模块<a hidden class=anchor aria-hidden=true href=#module_call_init初始化所有模块>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=o>--&gt;</span> <span class=nf>qemu_init</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=o>--&gt;</span> <span class=nf>qemu_init_subsystems</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=o>--&gt;</span> <span class=nf>module_call_init</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>当虚拟机真的要使用物理资源的时候，对下面的物理机上的资源要进行请求，所以它的工作模式有点儿类似操作系统对接驱动。驱动要符合一定的格式，才能算操作系统的一个模块。同理，qemu 为了模拟各种各样的设备，也需要管理各种各样的模块，这些模块也需要符合一定的格式。</p><p>定义一个 qemu 模块会调用 <code>type_init</code>。例如，<code>kvm</code> 的模块要在 <code>accel/kvm/kvm-all.c</code> 文件里面实现。在这个文件里面，有一行下面的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=n>TypeInfo</span> <span class=n>kvm_accel_type</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>TYPE_KVM_ACCEL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>parent</span> <span class=o>=</span> <span class=n>TYPE_ACCEL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>instance_init</span> <span class=o>=</span> <span class=n>kvm_accel_instance_init</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>class_init</span> <span class=o>=</span> <span class=n>kvm_accel_class_init</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>instance_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>KVMState</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>kvm_type_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>type_register_static</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kvm_accel_type</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>type_init</span><span class=p>(</span><span class=n>kvm_type_init</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>找到<code>type_init</code>的定义</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define type_init(function) module_init(function, MODULE_INIT_QOM)
</span></span></span></code></pre></td></tr></table></div></div><p>从代码里面的定义我们可以看出来，<code>type_init</code> 后面的参数是一个函数，调用 <code>type_init</code> 就相当于调用 <code>module_init</code>，在这里函数就是 <code>kvm_type_init</code>，类型就是 <code>MODULE_INIT_QOM</code>。</p><p>再查看一下<code>module_init</code>的定义</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//include/qemu/module.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define module_init(function, type)                                         \
</span></span></span><span class=line><span class=cl><span class=cp>static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \
</span></span></span><span class=line><span class=cl><span class=cp>{                                                                           \
</span></span></span><span class=line><span class=cl><span class=cp>    register_module_init(function, type);                                   \
</span></span></span><span class=line><span class=cl><span class=cp>}
</span></span></span></code></pre></td></tr></table></div></div><p><code>module_init</code> 最终要调用 <code>register_module_init</code>。属于 <code>MODULE_INIT_QOM</code> 这种类型的，有一个 <code>Module</code> 列表 <code>ModuleTypeList</code>，列表里面是一项一项的 <code>ModuleEntry</code>。<code>KVM</code> 就是其中一项，并且会初始化每一项的 <code>init</code> 函数为参数表示的函数 <code>fn</code>，也即 <code>KVM</code> 这个 <code>module</code> 的 <code>init</code> 函数就是 <code>kvm_type_init</code>。</p><p>当然，<code>MODULE_INIT_QOM</code> 这种类型会有很多很多的 <code>module</code>，从后面的代码我们可以看到，所有调用 <code>type_init</code> 的地方都注册了一个 <code>MODULE_INIT_QOM</code> 类型的 <code>Module</code>。</p><p>了解了 <code>Module</code> 的注册机制，我们继续回到 <code>qemu_init_subsystems</code> 函数中 <code>module_call_init</code> 的调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>qemu_init_subsystems</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Error</span> <span class=o>*</span><span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>os_set_line_buffering</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>module_call_init</span><span class=p>(</span><span class=n>MODULE_INIT_TRACE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>qemu_init_cpu_list</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>qemu_init_cpu_loop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>qemu_mutex_lock_iothread</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>atexit</span><span class=p>(</span><span class=n>qemu_run_exit_notifiers</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>module_call_init</span><span class=p>(</span><span class=n>MODULE_INIT_QOM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>module_call_init</span><span class=p>(</span><span class=n>MODULE_INIT_MIGRATION</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// utils/module.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>module_call_init</span><span class=p>(</span><span class=n>module_init_type</span> <span class=n>type</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ModuleTypeList</span> <span class=o>*</span><span class=n>l</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ModuleEntry</span> <span class=o>*</span><span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span> <span class=o>=</span> <span class=nf>find_type</span><span class=p>(</span><span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>QTAILQ_FOREACH</span><span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>e</span><span class=o>-&gt;</span><span class=nf>init</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在 <code>module_call_init</code> 中，我们会找到 <code>MODULE_INIT_QOM</code> 这种类型对应的 <code>ModuleTypeList</code>，找出列表中所有的 <code>ModuleEntry</code>，然后调用每个 <code>ModuleEntry</code> 的 <code>init</code> 函数。这里需要注意的是，在 <code>module_call_init</code> 调用的这一步，所有 <code>Module</code> 的 <code>init</code> 函数都已经被调用过了。</p><p>后面我们会看到很多的 <code>Module</code>，当我们后面再次遇到时，需要意识到，它的 <code>init</code> 函数在这里也被调用过了。这里我们还是以对于 <code>kvm</code> 这个 <code>module</code> 为例子，看看它的 <code>init</code> 函数都做了哪些事情。我们会发现，其实它调用的是 <code>kvm_type_init</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>kvm_type_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>type_register_static</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kvm_accel_type</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>TypeImpl</span> <span class=o>*</span><span class=nf>type_register_static</span><span class=p>(</span><span class=k>const</span> <span class=n>TypeInfo</span> <span class=o>*</span><span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>type_register</span><span class=p>(</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>TypeImpl</span> <span class=o>*</span><span class=nf>type_register</span><span class=p>(</span><span class=k>const</span> <span class=n>TypeInfo</span> <span class=o>*</span><span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=n>info</span><span class=o>-&gt;</span><span class=n>parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>type_register_internal</span><span class=p>(</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>TypeImpl</span> <span class=o>*</span><span class=nf>type_register_internal</span><span class=p>(</span><span class=k>const</span> <span class=n>TypeInfo</span> <span class=o>*</span><span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>TypeImpl</span> <span class=o>*</span><span class=n>ti</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span> <span class=o>=</span> <span class=nf>type_new</span><span class=p>(</span><span class=n>info</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=nf>type_table_add</span><span class=p>(</span><span class=n>ti</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ti</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>TypeImpl</span> <span class=o>*</span><span class=nf>type_new</span><span class=p>(</span><span class=k>const</span> <span class=n>TypeInfo</span> <span class=o>*</span><span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>TypeImpl</span> <span class=o>*</span><span class=n>ti</span> <span class=o>=</span> <span class=nf>g_malloc0</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>ti</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>type_table_lookup</span><span class=p>(</span><span class=n>info</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=nf>g_strdup</span><span class=p>(</span><span class=n>info</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=nf>g_strdup</span><span class=p>(</span><span class=n>info</span><span class=o>-&gt;</span><span class=n>parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>class_size</span> <span class=o>=</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>class_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>instance_size</span> <span class=o>=</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>instance_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>class_init</span> <span class=o>=</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>class_init</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>class_base_init</span> <span class=o>=</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>class_base_init</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>class_data</span> <span class=o>=</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>class_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>instance_init</span> <span class=o>=</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>instance_init</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>instance_post_init</span> <span class=o>=</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>instance_post_init</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>instance_finalize</span> <span class=o>=</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>instance_finalize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>abstract</span> <span class=o>=</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>abstract</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>interfaces</span> <span class=o>&amp;&amp;</span> <span class=n>info</span><span class=o>-&gt;</span><span class=n>interfaces</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>type</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ti</span><span class=o>-&gt;</span><span class=n>interfaces</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=kr>typename</span> <span class=o>=</span> <span class=nf>g_strdup</span><span class=p>(</span><span class=n>info</span><span class=o>-&gt;</span><span class=n>interfaces</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>ti</span><span class=o>-&gt;</span><span class=n>num_interfaces</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ti</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>type_table_add</span><span class=p>(</span><span class=n>TypeImpl</span> <span class=o>*</span><span class=n>ti</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=o>!</span><span class=n>enumerating_types</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>g_hash_table_insert</span><span class=p>(</span><span class=nf>type_table_get</span><span class=p>(),</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>ti</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>ti</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>GHashTable</span> <span class=o>*</span><span class=nf>type_table_get</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>GHashTable</span> <span class=o>*</span><span class=n>type_table</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>type_table</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>type_table</span> <span class=o>=</span> <span class=nf>g_hash_table_new</span><span class=p>(</span><span class=n>g_str_hash</span><span class=p>,</span> <span class=n>g_str_equal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>type_table</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=n>TypeInfo</span> <span class=n>kvm_accel_type</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>TYPE_KVM_ACCEL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>parent</span> <span class=o>=</span> <span class=n>TYPE_ACCEL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>class_init</span> <span class=o>=</span> <span class=n>kvm_accel_class_init</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>instance_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>KVMState</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>调用流程如下：虚线表示返回</p><p><img loading=lazy src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210907133931.svg alt></p><p>每一个 <code>Module</code> 既然要模拟某种设备，那应该定义一种类型 <code>TypeImpl</code> 来表示这些设备，这其实是一种<code>面向对象编程</code>的思路，只不过这里用的是纯 C 语言的实现，所以需要变相实现一下类和对象。</p><p><code>kvm_type_init</code> 会注册 <code>kvm_accel_type</code>，定义上面的代码，我们可以认为这样动态定义了一个类。这个类的名字是 <code>TYPE_KVM_ACCEL</code>，这个类有父类 <code>TYPE_ACCEL</code>，这个类的初始化应该调用函数 <code>kvm_accel_class_init</code>。如果用这个类声明一个对象，对象的大小应该是 <code>instance_size</code>。</p><p>在 <code>type_register_internal</code> 中，我们会根据 <code>kvm_accel_type</code> 这个 <code>TypeInfo</code>，创建一个<code>TypeImpl</code> 来表示这个新注册的类，也就是说，<code>TypeImpl</code> 才是我们想要声明的那个 <code>class</code>。在 qemu 里面，有一个全局的哈希表 <code>type_table</code>，用来存放所有定义的类。在 <code>type_new</code> 里面，我们先从全局表里面根据名字<code>type_table_lookup</code>查找找这个类。如果找到，说明这个类曾经被注册过，就报错；如果没有找到，说明这是一个新的类，则将 <code>TypeInfo</code> 里面信息填到 <code>TypeImpl</code> 里面。<code>type_table_add</code> 会将这个类注册到全局的表里面。到这里，我们注意，<code>class_init</code> 还没有被调用，也即这个类现在还处于纸面的状态。</p><p>这点更加像 Java 的反射机制了。在 Java 里面，对于一个类，首先我们写代码的时候要写一个 <code>class xxx</code> 的定义，编译好就放在<code>.class</code> 文件中，这也是出于纸面的状态。然后，Java 会有一个 <code>Class</code> 对象，用于读取和表示这个纸面上的 <code>class xxx</code>，可以生成真正的对象。</p><p>相同的过程在后面的代码中我们也可以看到，<code>class_init</code> 会生成<code>XXXClass</code>，就相当于 Java 里面的 <code>Class</code>对象，<code>TypeImpl</code> 还会有一个 <code>instance_init</code> 函数，相当于构造函数，用于根据 <code>XXXClass</code> 生成 <code>Object</code>，这就相当于 Java 反射里面最终创建的对象。和构造函数对应的还有 <code>instance_finalize</code>，相当于析构函数。</p><p>这一套反射机制放在 <code>qom</code> 文件夹下面，全称 <code>QEMU Object Model</code>，也即用 C 实现了一套<strong>面向对象的反射机制</strong>。</p><h2 id=初始化-machine>初始化 machine<a hidden class=anchor aria-hidden=true href=#初始化-machine>#</a></h2><p><img loading=lazy src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20210913115046.svg alt></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//vl.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>qemu_create_machine</span> <span class=p>(</span><span class=nf>select_machine</span><span class=p>());</span>
</span></span></code></pre></td></tr></table></div></div><p>在创建 machine 之前，先要通过<code>select_machine</code>确定一个<code>machine</code>。<code>select_machine</code>又是怎么确定的呢，这就和我们命令行的输入有关，比如我们<code>-m spike</code>，那么这里就会选择<code>spike</code>作为<code>machine</code>。它的定义在<code>hw/riscv/spike.c</code>中。</p><p>在源码最后有这么一句，会和我们上面解析的<code>type_init</code> 是一样的，在全局的表里面注册了一个全局的名字是<code>spike</code>的纸面上的 <code>class</code>，也即 <code>TypeImpl</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>type_init</span><span class=p>(</span><span class=n>spike_machine_init_reqister_types</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>现在全局表中有这个纸面上的 <code>class</code> 了。我们回到 <code>select_machine</code>。</p><p>在 <code>select_machine</code> 中，有两种方式可以生成 <code>MachineClass</code>。一种方式是 <code>find_default_machine</code>，找一个默认的；另一种方式是 <code>machine_parse</code>，通过解析参数生成 <code>MachineClass</code>。无论哪种方式，都会调用 <code>object_class_get_list</code> 获得一个 <code>MachineClass</code> 的列表，然后在里面找。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=n>MachineClass</span> <span class=o>*</span><span class=nf>select_machine</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>GSList</span> <span class=o>*</span><span class=n>machines</span> <span class=o>=</span> <span class=nf>object_class_get_list</span><span class=p>(</span><span class=n>TYPE_MACHINE</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>MachineClass</span> <span class=o>*</span><span class=n>machine_class</span> <span class=o>=</span> <span class=nf>find_default_machine</span><span class=p>(</span><span class=n>machines</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>optarg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>QemuOpts</span> <span class=o>*</span><span class=n>opts</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Location</span> <span class=n>loc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>loc_push_none</span><span class=p>(</span><span class=o>&amp;</span><span class=n>loc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>opts</span> <span class=o>=</span> <span class=nf>qemu_get_machine_opts</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>qemu_opts_loc_restore</span><span class=p>(</span><span class=n>opts</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>optarg</span> <span class=o>=</span> <span class=nf>qemu_opt_get</span><span class=p>(</span><span class=n>opts</span><span class=p>,</span> <span class=s>&#34;type&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>optarg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>machine_class</span> <span class=o>=</span> <span class=nf>machine_parse</span><span class=p>(</span><span class=n>optarg</span><span class=p>,</span> <span class=n>machines</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>machine_class</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>error_report</span><span class=p>(</span><span class=s>&#34;No machine specified, and there is no default&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>error_printf</span><span class=p>(</span><span class=s>&#34;Use -machine help to list supported machines</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>loc_pop</span><span class=p>(</span><span class=o>&amp;</span><span class=n>loc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>g_slist_free</span><span class=p>(</span><span class=n>machines</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>machine_class</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>MachineClass</span> <span class=o>*</span><span class=nf>find_default_machine</span><span class=p>(</span><span class=n>GSList</span> <span class=o>*</span><span class=n>machines</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>GSList</span> <span class=o>*</span><span class=n>el</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>MachineClass</span> <span class=o>*</span><span class=n>default_machineclass</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>el</span> <span class=o>=</span> <span class=n>machines</span><span class=p>;</span> <span class=n>el</span><span class=p>;</span> <span class=n>el</span> <span class=o>=</span> <span class=n>el</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>MachineClass</span> <span class=o>*</span><span class=n>mc</span> <span class=o>=</span> <span class=n>el</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>mc</span><span class=o>-&gt;</span><span class=n>is_default</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>assert</span><span class=p>(</span><span class=n>default_machineclass</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;Multiple default machines&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>default_machineclass</span> <span class=o>=</span> <span class=n>mc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>default_machineclass</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>MachineClass</span> <span class=o>*</span><span class=nf>machine_parse</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=n>GSList</span> <span class=o>*</span><span class=n>machines</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MachineClass</span> <span class=o>*</span><span class=n>mc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>GSList</span> <span class=o>*</span><span class=n>el</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>is_help_option</span><span class=p>(</span><span class=n>name</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Supported machines are:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>machines</span> <span class=o>=</span> <span class=nf>g_slist_sort</span><span class=p>(</span><span class=n>machines</span><span class=p>,</span> <span class=n>machine_class_cmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>el</span> <span class=o>=</span> <span class=n>machines</span><span class=p>;</span> <span class=n>el</span><span class=p>;</span> <span class=n>el</span> <span class=o>=</span> <span class=n>el</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>MachineClass</span> <span class=o>*</span><span class=n>mc</span> <span class=o>=</span> <span class=n>el</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>mc</span><span class=o>-&gt;</span><span class=n>alias</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%-20s %s (alias of %s)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>mc</span><span class=o>-&gt;</span><span class=n>alias</span><span class=p>,</span> <span class=n>mc</span><span class=o>-&gt;</span><span class=n>desc</span><span class=p>,</span> <span class=n>mc</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%-20s %s%s%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>mc</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>mc</span><span class=o>-&gt;</span><span class=n>desc</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>mc</span><span class=o>-&gt;</span><span class=n>is_default</span> <span class=o>?</span> <span class=s>&#34; (default)&#34;</span> <span class=o>:</span> <span class=s>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>mc</span><span class=o>-&gt;</span><span class=n>deprecation_reason</span> <span class=o>?</span> <span class=s>&#34; (deprecated)&#34;</span> <span class=o>:</span> <span class=s>&#34;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>mc</span> <span class=o>=</span> <span class=nf>find_machine</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>machines</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>mc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>error_report</span><span class=p>(</span><span class=s>&#34;unsupported machine type&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>error_printf</span><span class=p>(</span><span class=s>&#34;Use -machine help to list supported machines</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>mc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>object_class_get_list</code> 定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>GSList</span> <span class=o>*</span><span class=nf>object_class_get_list</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>implements_type</span><span class=p>,</span><span class=kt>bool</span> <span class=n>include_abstract</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>GSList</span> <span class=o>*</span><span class=n>list</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>object_class_foreach</span><span class=p>(</span><span class=n>object_class_get_list_tramp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=n>implements_type</span><span class=p>,</span> <span class=n>include_abstract</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>object_class_foreach</span><span class=p>(</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>fn</span><span class=p>)(</span><span class=n>ObjectClass</span> <span class=o>*</span><span class=n>klass</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>opaque</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                          <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>implements_type</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>include_abstract</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=kt>void</span> <span class=o>*</span><span class=n>opaque</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>OCFData</span> <span class=n>data</span> <span class=o>=</span> <span class=p>{</span> <span class=n>fn</span><span class=p>,</span> <span class=n>implements_type</span><span class=p>,</span> <span class=n>include_abstract</span><span class=p>,</span> <span class=n>opaque</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>enumerating_types</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>g_hash_table_foreach</span><span class=p>(</span><span class=nf>type_table_get</span><span class=p>(),</span> <span class=n>object_class_foreach_tramp</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>enumerating_types</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在全局表 <code>type_table_get()</code> 中，对于每一项 <code>TypeImpl</code>，我们都执行 <code>object_class_foreach_tramp</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>object_class_foreach_tramp</span><span class=p>(</span><span class=n>gpointer</span> <span class=n>key</span><span class=p>,</span> <span class=n>gpointer</span> <span class=n>value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                       <span class=n>gpointer</span> <span class=n>opaque</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>OCFData</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=n>opaque</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>TypeImpl</span> <span class=o>*</span><span class=n>type</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ObjectClass</span> <span class=o>*</span><span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>type_initialize</span><span class=p>(</span><span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>=</span> <span class=n>type</span><span class=o>-&gt;</span><span class=n>class</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>data</span><span class=o>-&gt;</span><span class=n>include_abstract</span> <span class=o>&amp;&amp;</span> <span class=n>type</span><span class=o>-&gt;</span><span class=n>abstract</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>data</span><span class=o>-&gt;</span><span class=n>implements_type</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>        <span class=o>!</span><span class=nf>object_class_dynamic_cast</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>data</span><span class=o>-&gt;</span><span class=n>implements_type</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=o>-&gt;</span><span class=nf>fn</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>data</span><span class=o>-&gt;</span><span class=n>opaque</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在 <code>object_class_foreach_tramp</code> 中，会调用将 <code>type_initialize</code>，这里面会调用 <code>class_init</code> 将纸面上的 <code>class</code> 也即 <code>TypeImpl</code> 变为 <code>ObjectClass</code>，<code>ObjectClass</code> 是所有<code>Class</code> 类的祖先，<code>MachineClass</code> 是它的子类。</p><p>因为在 <code>machine</code> 的命令行里面，我们指定了名字为<code>spike</code>，就肯定能够找到我们注册过了的 <code>TypeImpl</code>，并调用它的 <code>class_init</code> 函数。</p><p>所以，当 <code>select_machine</code> 执行完毕后，就有一个 <code>MachineClass</code> 了。</p><p>接着，我们回到 <code>qemu_create_machine</code> 中的<code>object_new_with_class</code>。这就很好理解了，<code>MachineClass</code> 是一个 <code>Class</code> 类，接下来应该通过它生成一个 <code>Instance</code>，也即对象，这就是 <code>object_new_with_class</code> 的作用。</p><p><code>object_new_with_class</code> 中，<code>TypeImpl</code> 的 <code>instance_init</code> 会被调用，创建一个对象。<code>current_machine</code> 就是这个对象，它的类型是<code>MachineState</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>Object</span> <span class=o>*</span><span class=nf>object_new_with_class</span><span class=p>(</span><span class=n>ObjectClass</span> <span class=o>*</span><span class=n>klass</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>object_new_with_type</span><span class=p>(</span><span class=n>klass</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>Object</span> <span class=o>*</span><span class=nf>object_new_with_type</span><span class=p>(</span><span class=n>Type</span> <span class=n>type</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Object</span> <span class=o>*</span><span class=n>obj</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>type_initialize</span><span class=p>(</span><span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>obj</span> <span class=o>=</span> <span class=nf>g_malloc</span><span class=p>(</span><span class=n>type</span><span class=o>-&gt;</span><span class=n>instance_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>object_initialize_with_type</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>type</span><span class=o>-&gt;</span><span class=n>instance_size</span><span class=p>,</span> <span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>obj</span><span class=o>-&gt;</span><span class=n>free</span> <span class=o>=</span> <span class=n>g_free</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>obj</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>至此，绕了这么大一圈，有关体系结构的对象才创建完毕，接下来很多的设备的初始化，包括 CPU 和内存的初始化，都是围绕着体系结构的对象来的，后面我们会常常看到<code>current_machine</code>。</p><p><img loading=lazy src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220308180036.png alt></p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><p><a href=https://www.cnblogs.com/nm90/p/15661202.html>Qemu CPU 虚拟化 - 人生一世，草木一秋。 - 博客园</a>
<a href=https://www.cnblogs.com/LoyenWang/p/13796537.html>【原创】Linux 虚拟化 KVM-Qemu 分析（四）之 CPU 虚拟化（2） - LoyenWang - 博客园</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://lifeislife.cn/tags/qemu/>QEMU</a></li><li><a href=https://lifeislife.cn/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3fatal-error-bits-libc-header-start-hno-such-file/><span class=title>« 上一页</span><br><span>解决 fatal error: bits/libc-header-start.h：no such file</span>
</a><a class=next href=https://lifeislife.cn/posts/qt%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/><span class=title>下一页 »</span><br><span>Qt 文件系统</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-虚拟 CPU 创建 on x" href="https://x.com/intent/tweet/?text=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e8%99%9a%e6%8b%9f%20CPU%20%e5%88%9b%e5%bb%ba&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E8%2599%259A%25E6%258B%259Fcpu%25E5%2588%259B%25E5%25BB%25BA%2f&amp;hashtags=QEMU%2cLinux"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-虚拟 CPU 创建 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E8%2599%259A%25E6%258B%259Fcpu%25E5%2588%259B%25E5%25BB%25BA%2f&amp;title=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e8%99%9a%e6%8b%9f%20CPU%20%e5%88%9b%e5%bb%ba&amp;summary=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e8%99%9a%e6%8b%9f%20CPU%20%e5%88%9b%e5%bb%ba&amp;source=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E8%2599%259A%25E6%258B%259Fcpu%25E5%2588%259B%25E5%25BB%25BA%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-虚拟 CPU 创建 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E8%2599%259A%25E6%258B%259Fcpu%25E5%2588%259B%25E5%25BB%25BA%2f&title=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e8%99%9a%e6%8b%9f%20CPU%20%e5%88%9b%e5%bb%ba"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-虚拟 CPU 创建 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E8%2599%259A%25E6%258B%259Fcpu%25E5%2588%259B%25E5%25BB%25BA%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-虚拟 CPU 创建 on whatsapp" href="https://api.whatsapp.com/send?text=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e8%99%9a%e6%8b%9f%20CPU%20%e5%88%9b%e5%bb%ba%20-%20https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E8%2599%259A%25E6%258B%259Fcpu%25E5%2588%259B%25E5%25BB%25BA%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-虚拟 CPU 创建 on telegram" href="https://telegram.me/share/url?text=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e8%99%9a%e6%8b%9f%20CPU%20%e5%88%9b%e5%bb%ba&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E8%2599%259A%25E6%258B%259Fcpu%25E5%2588%259B%25E5%25BB%25BA%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-虚拟 CPU 创建 on ycombinator" href="https://news.ycombinator.com/submitlink?t=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e8%99%9a%e6%8b%9f%20CPU%20%e5%88%9b%e5%bb%ba&u=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E8%2599%259A%25E6%258B%259Fcpu%25E5%2588%259B%25E5%25BB%25BA%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://lifeislife.cn/>夜云泊</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>