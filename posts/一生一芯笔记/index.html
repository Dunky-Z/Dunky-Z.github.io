<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>一生一芯笔记 | 夜云泊</title>
<meta name=keywords content><meta name=description content="一生一芯概述 “一生一芯”概述 _哔哩哔哩_bilibili 程序的执行和模拟器 freestanding 运行时环境 程序如何结束运行 在正常的环境中，写了一段代码retur"><meta name=author content="Dominic Zhang"><link rel=canonical href=https://lifeislife.cn/posts/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d31aa50bfd9ffd4f71bf798317bf6ae90a91854facd48984004bb3d8905fbe45.css integrity="sha256-0xqlC/2f/U9xv3mDF79q6QqRhU+s1ImEAEuz2JBfvkU=" rel="preload stylesheet" as=style><link rel=icon href=https://lifeislife.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lifeislife.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lifeislife.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://lifeislife.cn/apple-touch-icon.png><link rel=mask-icon href=https://lifeislife.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lifeislife.cn/posts/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PS8L2EEEPR")}</script><meta property="og:title" content="一生一芯笔记"><meta property="og:description" content="一生一芯概述 “一生一芯”概述 _哔哩哔哩_bilibili 程序的执行和模拟器 freestanding 运行时环境 程序如何结束运行 在正常的环境中，写了一段代码retur"><meta property="og:type" content="article"><meta property="og:url" content="https://lifeislife.cn/posts/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%AC%94%E8%AE%B0/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-12T12:58:15+00:00"><meta property="article:modified_time" content="2023-03-12T12:58:15+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="一生一芯笔记"><meta name=twitter:description content="一生一芯概述 “一生一芯”概述 _哔哩哔哩_bilibili 程序的执行和模拟器 freestanding 运行时环境 程序如何结束运行 在正常的环境中，写了一段代码retur"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifeislife.cn/posts/"},{"@type":"ListItem","position":2,"name":"一生一芯笔记","item":"https://lifeislife.cn/posts/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"一生一芯笔记","name":"一生一芯笔记","description":"一生一芯概述 “一生一芯”概述 _哔哩哔哩_bilibili 程序的执行和模拟器 freestanding 运行时环境 程序如何结束运行 在正常的环境中，写了一段代码retur","keywords":[],"articleBody":"一生一芯概述 “一生一芯”概述 _哔哩哔哩_bilibili\n程序的执行和模拟器 freestanding 运行时环境 程序如何结束运行 在正常的环境中，写了一段代码return之后，实际上调用了一个系统调用exit。但是在 freestanding 环境中，没有操作系统支持，根据 C99 手册规定，在 freestanding 环境中结束运行是由用户实现决定的。\n5.1.2.1 Freestanding environment 2 The effect of program termination in a freestanding environment is implementation-defined. 在 qemu-system-riscv64 中的 virt 机器模型中，往一个特殊的地址写入一个特殊的“暗号”即可结束 QEMU\n#include void _start() { volatile uint8_t *p = (uint8_t *)(uintptr_t)0x10000000; *p = 'A'; volatile uint32_t *exit = (uint32_t *)(uintptr_t)0x100000; *exit = 0x5555; // magic number _start(); // 递归调用，如果正常退出将不会再次打印A } 在自制 freestanding 运行时环境上运行 Hello 程序 QEMU 虽然是个开源项目，但还挺复杂，不利于我们理解细节。让我们来设计一个面向 RISC-V 程序的简单 freestanding 运行时环境，我做以下约定。\n程序从地址 0 开始执行 只支持两条指令 addi 指令 ebreak 指令 寄存器 a0=0 时，输出寄存器 a1 低 8 位的字符 寄存器 a0=1 时，结束运行 ABI Mnemonic（RISC-V 官方为每个寄存器起个名字） static void ebreak(long arg0, long arg1) { asm volatile(\"addi a0, x0, %0;\" \"addi a1, x0, %1;\" \"ebreak\" : : \"i\"(arg0), \"i\"(arg1)); } static void putch(char ch) { ebreak(0, ch); } static void halt(int code) { ebreak(1, code); while (1); } void _start() { putch('A'); halt(0); } /** * 这段代码定义了三个函数：ebreak、putch 和 halt。 * ebreak 函数是一个内联汇编函数，它执行 ebreak 指令。 * 该指令是 RISC-V 架构中的一条调试指令，可以在调试器的控制下执行。 * 该函数接受两个参数 arg0 和 arg1，它们将被存储在寄存器 a0 和 a1 中。 * putch 函数调用了 ebreak 函数，并将第一个参数设为 0， * 第二个参数设为函数参数 ch。这样做的目的可能是为了在调试器的控制下输出一个字符。 * halt 函数调用了 ebreak 函数，并将第一个参数设为 1， * 第二个参数设为函数参数 code。这样做的目的可能是为了通知调试器程序已经结束， * 并使用 code 作为结束状态。然后，halt 函数进入一个死循环，等待调试器的操作。 * 最后，_start 函数调用了 putch 函数输出字符 'A'，然后调用 halt 函数结束程序 */ riscv64-linux-gnu-gcc -march=rv64g -ffreestanding -nostdlib -static -Wl,-Ttext=0 \\ -O2 -o prog a.c riscv64-linux-gnu-gcc: 这是 GCC 的可执行文件的名称，表示使用的是 GCC 编译器。riscv64-linux-gnu 是编译器的目标平台，表示生成的代码是针对 RISC-V 架构，运行在 Linux 系统上的二进制文件。\n-march=rv64g: 这个参数指定了编译器使用的指令集。rv64g 表示使用 RISC-V 架构的 64 位指令集。\n-ffreestanding: 这个参数指示编译器生成的代码将在 freestanding 运行环境中运行。在 freestanding 运行环境中，程序不会自动链接标准 C 库，也不会自动调用 main 函数。\n-nostdlib: 这个参数表示编译器不需要链接标准 C 库。\n-static: 这个参数表示生成的代码是静态链接的。\n-Wl,-Ttext=0: 这个参数是传递给链接器的，表示设置代码段的起始地址为 0。\n-O2: 这个参数指示编译器使用优化级别为 2 的优化选项。\n-o prog: 这个参数指定生成的可执行文件的名称为 prog。\na.c: 这是要编译的 C 源文件的名称。\nllvm-objdump -d prog 反汇编结果如下：\nprog: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 \u003c_start\u003e: 0: 13 05 00 00 li a0, 0 4: 93 05 10 04 li a1, 65 8: 73 00 10 00 ebreak c: 13 05 10 00 li a0, 1 10: 93 05 00 00 li a1, 0 14: 73 00 10 00 ebreak 18: 6f 00 00 00 j 0x18 \u003c_start+0x18\u003e 我们约定中没有li指令，但是汇编中却出现了，这是因为li是一条伪指令，它的实际实现依然是addi。如果不使用伪指令可以使用以下命令反汇编：\nllvm-objdump -M no-aliases -d prog 结果如下，没有伪指令，只有我们约定的几条指令。\nprog: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 \u003c_start\u003e: 0: 13 05 00 00 addi a0, zero, 0 4: 93 05 10 04 addi a1, zero, 65 8: 73 00 10 00 ebreak c: 13 05 10 00 addi a0, zero, 1 10: 93 05 00 00 addi a1, zero, 0 14: 73 00 10 00 ebreak 18: 6f 00 00 00 jal zero, 0x18 \u003c_start+0x18\u003e YEMU 指令如何执行 ISA 手册定义了一个状态机。\n状态集合 S = {}\nR = {PC, x0, x1, x2, …} RISC-V 手册 -\u003e 2.1 Programmers’Model for Base Integer ISA PC = 程序计数器 = 当前执行的指令位置 M = 内存 RISC-V 手册 -\u003e 1.4 Memory 激励事件：执行 PC 指向的指令 状态转移规则：指令的语义 (semantics) 初始状态 S0 = 我们只要把这个状态机实现出来，就可以用它来执行指令了！\n用变量实现内存 #include uint64_t R[32], PC; // according to the RISC-V manual uint8_t M[64]; // 64-Byte memory Q: 为什么不使用 int64_t 和 int8_t?\nA: C语言标准规定, 有符号数溢出是undefined behavior, 但无符号数不会溢出\n6.5 Expressions 5 If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or not in the range of representable values for its type), the behavior is undefined. 6.2.5 Types 9 A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type.\n用语句实现指令的语义 指令周期 (instruction cycle): 执行一条指令的步骤\n取指 (fetch): 从 PC 所指示的内存位置读取一条指令 译码 (decode): 按照手册解析指令的操作码 (opcode) 和操作数 (operand) 执行 (execute): 按解析出的操作码，对操作数进行处理 更新 PC: 让 PC 指向下一条指令 状态机不断执行指令，直到结束运行：\n#include bool halt = false; while (!halt) { inst_cycle(); } 31 20 19 15 14 12 11 7 6 0 +---------------+-----+-----+-----+---------+ | imm[11:0] | rs1 | 000 | rd | 0010011 | ADDI +---------------+-----+-----+-----+---------+ +---------------+-----+-----+-----+---------+ | 000000000001 |00000| 000 |00000| 1110011 | EBREAK +---------------+-----+-----+-----+---------+ 一个简单的实现：\nvoid inst_cycle() { uint32_t inst = *(uint32_t *)\u0026M[PC]; if (((inst \u0026 0x7f) == 0x13) \u0026\u0026 ((inst \u003e\u003e 12) \u0026 0x7) == 0) { // addi if (((inst \u003e\u003e 7) \u0026 0x1f) != 0) { R[(inst \u003e\u003e 7) \u0026 0x1f] = R[(inst \u003e\u003e 15) \u0026 0x1f] + (((inst \u003e\u003e 20) \u0026 0x7ff) - ((inst \u0026 0x80000000) ? 4096 : 0)); } } else if (inst == 0x00100073) { // ebreak if (R[10] == 0) { putchar(R[11] \u0026 0xff); } else if (R[10] == 1) { halt = true; } else { printf(\"Unsupported ebreak command\\n\"); } } else { printf(\"Unsupported instuction\\n\"); } PC += 4; } NEMU 代码导读 make 项目构 # 显示make踪迹 strace make # 显示构建过程 make -d # 显示更详细的构建构过程 make --debug=v Reading makefiles... Reading makefile `Makefile'... Updating goal targets.... File `all' does not exist. File `all' does not exist. Looking for an implicit rule for `all'. Trying pattern rule with stem `all'. Trying implicit prerequisite `all.c'. Trying pattern rule with stem `all'. Trying implicit prerequisite `all.cc'. Trying pattern rule with stem `all'. Trying implicit prerequisite `all.C'. Trying pattern rule with stem `all'. Trying implicit prerequisite `all.cpp'. Trying pattern rule with stem `all'. Trying implicit prerequisite `all.CPP'. Trying pattern rule with stem `all'. Trying implicit prerequisite `all.cxx'. Trying pattern rule with stem `all'. Trying implicit prerequisite `all.CXX'. Trying pattern rule with stem `all'. Trying implicit prerequisite `all.c++'. Trying pattern rule with stem `all'. Trying implicit prerequisite `all.C++'. No implicit rule found for `all'. Finished prerequisites of target file `all'. Must remake target `all'. gcc -o all all.o Finished prerequisites of target file `all'. Must remake target `all'. gcc -o all all.o Successfully remade target file `all'. # 只打印命令不执行 make -n # 输出目标被构建的原因和执行的命令 make --trace 例如，如果您有一个 makefile，其目标 all 依赖于目标 foo 和 bar，并且您运行 make --trace all，您可能会看到如下输出：\nmake[1]: Entering directory '/path/to/project' gcc -o foo foo.c make[1]: Leaving directory '/path/to/project' make[1]: Entering directory '/path/to/project' gcc -o bar bar.c make[1]: Leaving directory '/path/to/project' make[1]: Entering directory '/path/to/project' gcc -o all foo.o bar.o make[1]: Leaving directory '/path/to/project' make -nB # -B 可以强制 make 构建所有目标，即使它们已经是最新的 make -nB | vim - 在 vim 编辑器中进行二次处理，过滤不需要的信息。\n# 只保留 gcc 或 g++开头的行 :%!grep \"^\\(gcc\\|g++\\)\" # 将环境变量$NEMU_HOME 所指示字符串替换为$NEMU_HOME :%!sed -e \"s+$NEMU_HOME+\\$NEMU_HOME+g\" # 将$NEMU_HOME/build/obj-riscv64-nemu-interpreter 替换为$OBJ_DIR :%s+\\$NEMU_HOME/build/obj-riscv64-nemu-interpreter+$OBJ_DIR+g # 将-c 之前的内容替换为$CFLAGS :%s/-O2.*=riscv64/$CFLAGS/g # 将最后一行的空格替换成换行并缩进两格 :$s/ */\\r /g 调试技巧选将 断言 在 C 程序中使用断言（assert）不会增加额外的内存空间，也不会增加数据段空间。断言是一种在运行时检查程序假设是否为真的方法，当断言失败时，程序会终止执行并显示错误信息。\n在 C 语言中，断言通常使用宏来实现。它在编译时被解释为一个简单的条件语句，因此它不会增加程序的内存空间或数据段空间。断言宏的定义通常类似于以下代码：\n#include #define assert(expression) ((void)0) 这里的 expression 是要检查的条件。如果 expression 为假，则 assert() 函数会发出错误消息并终止程序的执行。如果 expression 为真，则 assert() 函数不会产生任何操作，并且被解释为 ((void)0)。这个语句不会增加任何内存或数据段空间。\n需要注意的是，当一个程序使用大量的断言时，它可能会对程序的性能产生一些影响，因为每个断言都需要在运行时进行检查。因此，在生产环境中，应该尽可能减少使用断言，并在测试和调试阶段使用它们来确保代码的正 确性。\n// nemu/src/isa/riscv64/local-include/reg.h static inline int check_reg_idx(int idx) { IFDEF(CONFIG_RT_CHECK, assert(idx \u003e= 0 \u0026\u0026 idx \u003c 32)); return idx; } 编译器工具 sanitizer 让编译器自动插入 assert, 拦截常见的非预期行为\nAddressSanitizer - 检查指针越界，use-after-free ThreadSanitizer - 检查多线程数据竞争 LeakSanitizer - 检查内存泄漏 UndefinedBehaviorSanitizer - 检查 UB 还能检查指针的比较和相减 打开后程序运行效率有所下降\n但调试的时候非常值得，躺着就能让工具帮你找 bug man gcc 查看具体用法 使用方法 GCC 提供了多种 Sanitizer 工具，可以帮助开发者在编译时检测和修复常见的编程错误，例如内存泄漏、缓冲区溢出、使用未初始化的变量等。以下是几个 Sanitizer 工具的示例用法：\nAddress Sanitizer（ASAN）：检测内存错误，例如使用已经释放的内存、堆栈和全局缓冲区的溢出和下溢等。\ngcc -fsanitize=address -g -o Undefined Behavior Sanitizer（UBSAN）：检测未定义行为，例如除以零、使用未初始化的变量、指针溢出等。\ngcc -fsanitize=undefined -g -o Thread Sanitizer（TSAN）：检测并发问题，例如竞争条件、死锁等。\ngcc -fsanitize=thread -g -o Memory Sanitizer（MSAN）：检测使用未初始化的内存，例如读取未初始化的内存、使用已释放的内存等。\ngcc -fsanitize=memory -g -o 需要注意的是，Sanitizer 工具可能会增加程序的执行时间和内存消耗，并且可能会产生误报，因此在生产环境中应该禁用 Sanitizer 工具。通常情况下，开发者可以在开发和测试阶段启用 Sanitizer 工具，以帮助他们发现和修复代码中的问题。\n自顶向下理解程序行为 ftrace - 函数调用层次，理解程序的大体行为 itrace - 指令执行层次，理解指令级别的行为 mtrace - 访存的踪迹 dtrace - 设备访问的踪迹 sdb - 灵活细致地检查客户程序的状态 si - 细粒度的状态转移 info r/x - 检查R/M 监视点 - 捕捉某状态发生变化的时刻 sdb 与 gdb 结合使用\n先用 sdb 定位到出错点附近 再用 gdb 观察 NEMU 的细节行为 程序的运行时间都花在了哪里 Linux 的性能分析工具 perf 是一款功能强大的性能分析工具，它可以通过硬件计数器（Hardware counter）或者性能事件（Performance event）来对 Linux 系统的性能进行分析。以下是 perf 工具的安装和使用方法。\n安装 perf 工具 在大部分 Linux 发行版中，perf 工具已经预先安装，如果没有预先安装，可以通过以下命令进行安装。\nDebian/Ubuntu 系统：sudo apt-get install linux-tools-common linux-tools-generic Fedora 系统：sudo dnf install perf CentOS/RHEL 系统：sudo yum install perf 安装完毕之后，可以通过 perf version 命令来检查 perf 版本信息。\n编写一个简单的 C 代码 这里我们编写一个简单的 C 代码，用于测试 perf 工具的使用。代码如下：\n#include int main() { int i, sum = 0; for (i = 1; i \u003c= 1000000; i++) sum += i; printf(\"sum = %d\\n\", sum); return 0; } 代码的作用是计算 1 到 1000000 的和。\n使用 perf 工具 下面我们使用 perf 工具来对上述代码进行性能分析。假设代码保存在文件 test.c 中。\n统计 CPU 周期数 以下命令用于统计程序的 CPU 周期数：\nperf stat ./test 输出结果类似于：\nPerformance counter stats for './test': 19,23 msec task-clock:u # 0.988 CPUs utilized 0 context-switches:u # 0.000 K/sec 0 cpu-migrations:u # 0.000 K/sec 575 page-faults:u # 0.030 M/sec 64,013,620,231 cycles:u # 3.324 GHz (49.80%) 40,010,335,480 instructions:u # 0.62 insn per cycle (62.34%) 9,998,469,566 branches:u # 518.693 M/sec (62.27%) 763,176 branch-misses:u # 0.01% of all branches (62.32%) 0.019438122 seconds time elapsed 0.019411000 seconds user 0.000007000 seconds sys 输出结果中的 cycles 表示 CPU 周期数，instructions 表示指令数，branches 表示分支指令数。其中，cycles 和 instructions 的比例代表了 CPU 的效率，即 IPC（Instructions Per Cycle）。\n统计函数调用次数 以下命令用于统计程序中函数的调用次数：\nperf record -e cycles -g ./test 这个命令将启动 perf 工具，并使用 -g 选项记录调用关系图。我们还需要使用 sudo 权限运行该命令，以便 perf 工具可以访问系统的硬件计数器。\n成为专业码农 要熟悉项目了 -\u003e STFW/RTFM/RTFSC, 尝试理解一切细节 要写代码了 仔细 RTFM, 正确理解需求 编写可读，可维护，易验证的代码 (不言自明，不言自证) 用 lint 工具检查代码 进行充分的测试 添加充分的断言 要调试了 默念“机器永远是对的/未测试代码永远是错的” sanitizer, trace, printf, gdb, … 平时 -\u003e 用正确的工具/方法做事情 感到不爽了 -\u003e 找正确的工具/搭基础设施 总线选讲 定义 广义上讲总线就是一个通信系统，以下这些都属于广义的总线概念:TCP/IP, 以太网，网线，RTL 信号，系统调用。\n主动发起通信的叫 master，响应通信的叫 slave。\n","wordCount":"4322","inLanguage":"zh","datePublished":"2023-03-12T12:58:15Z","dateModified":"2023-03-12T12:58:15Z","author":{"@type":"Person","name":"Dominic Zhang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifeislife.cn/posts/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"夜云泊","logo":{"@type":"ImageObject","url":"https://lifeislife.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script defer src=/static/fontawesome/fontawesome-all.js></script><header class=header><nav class=nav><div class=logo><a href=https://lifeislife.cn/ accesskey=h title="夜云泊 (Alt + H)">夜云泊</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lifeislife.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://lifeislife.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://lifeislife.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://lifeislife.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://www.travellings.cn/go.html title=开往><span><i class='fa-solid fa-train-subway'></i>开往</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lifeislife.cn/>主页</a>&nbsp;»&nbsp;<a href=https://lifeislife.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">一生一芯笔记</h1><div class=post-meta><span title='2023-03-12 12:58:15 +0000 UTC'>三月 12, 2023</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;4322 字&nbsp;·&nbsp;Dominic Zhang</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#freestanding-运行时环境>freestanding 运行时环境</a><ul><li><a href=#程序如何结束运行>程序如何结束运行</a></li><li><a href=#在自制-freestanding-运行时环境上运行-hello-程序>在自制 freestanding 运行时环境上运行 Hello 程序</a></li></ul></li><li><a href=#yemu-指令如何执行>YEMU 指令如何执行</a><ul><li><a href=#用变量实现内存>用变量实现内存</a></li><li><a href=#用语句实现指令的语义>用语句实现指令的语义</a></li></ul></li></ul><ul><li><a href=#make-项目构>make 项目构</a></li></ul><ul><li><a href=#断言>断言</a></li><li><a href=#编译器工具-sanitizer>编译器工具 sanitizer</a><ul><li><a href=#使用方法>使用方法</a></li></ul></li><li><a href=#自顶向下理解程序行为>自顶向下理解程序行为</a></li><li><a href=#程序的运行时间都花在了哪里>程序的运行时间都花在了哪里</a><ul><li><a href=#安装-perf-工具>安装 perf 工具</a></li><li><a href=#编写一个简单的-c-代码>编写一个简单的 C 代码</a></li><li><a href=#使用-perf-工具>使用 perf 工具</a></li><li><a href=#统计函数调用次数>统计函数调用次数</a></li></ul></li><li><a href=#成为专业码农>成为专业码农</a></li></ul><ul><li><a href=#定义>定义</a></li></ul></nav></div></details></div><div class=post-content><h1 id=一生一芯概述>一生一芯概述<a hidden class=anchor aria-hidden=true href=#一生一芯概述>#</a></h1><p><a href="https://www.bilibili.com/video/BV12e4y1Y76i/?spm_id_from=333.788&amp;vd_source=7ff88341de4b5111bdf3db48b4e9ca44">“一生一芯”概述 _哔哩哔哩_bilibili</a></p><h1 id=程序的执行和模拟器>程序的执行和模拟器<a hidden class=anchor aria-hidden=true href=#程序的执行和模拟器>#</a></h1><h2 id=freestanding-运行时环境>freestanding 运行时环境<a hidden class=anchor aria-hidden=true href=#freestanding-运行时环境>#</a></h2><h3 id=程序如何结束运行>程序如何结束运行<a hidden class=anchor aria-hidden=true href=#程序如何结束运行>#</a></h3><p>在正常的环境中，写了一段代码<code>return</code>之后，实际上调用了一个系统调用<code>exit</code>。但是在 freestanding 环境中，没有操作系统支持，根据 C99 手册规定，在 freestanding 环境中结束运行是由用户实现决定的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>5.1.2.1 Freestanding environment
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>2 The effect of program termination in a freestanding environment is
</span></span><span class=line><span class=cl>implementation-defined.
</span></span></code></pre></div><p>在 qemu-system-riscv64 中的 virt 机器模型中，往一个特殊的地址写入一个特殊的“暗号”即可结束 QEMU</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>_start</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>volatile</span> <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)(</span><span class=kt>uintptr_t</span><span class=p>)</span><span class=mh>0x10000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=sc>&#39;A&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>volatile</span> <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>exit</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>)(</span><span class=kt>uintptr_t</span><span class=p>)</span><span class=mh>0x100000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>exit</span> <span class=o>=</span> <span class=mh>0x5555</span><span class=p>;</span>   <span class=c1>// magic number
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>_start</span><span class=p>();</span>         <span class=c1>// 递归调用，如果正常退出将不会再次打印A
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=在自制-freestanding-运行时环境上运行-hello-程序>在自制 freestanding 运行时环境上运行 Hello 程序<a hidden class=anchor aria-hidden=true href=#在自制-freestanding-运行时环境上运行-hello-程序>#</a></h3><p>QEMU 虽然是个开源项目，但还挺复杂，不利于我们理解细节。让我们来设计一个面向 RISC-V 程序的简单 freestanding 运行时环境，我做以下约定。</p><ul><li>程序从地址 0 开始执行</li><li>只支持两条指令<ul><li>addi 指令</li><li>ebreak 指令<ul><li>寄存器 a0=0 时，输出寄存器 a1 低 8 位的字符</li><li>寄存器 a0=1 时，结束运行<ul><li>ABI Mnemonic（RISC-V 官方为每个寄存器起个名字）</li></ul></li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>ebreak</span><span class=p>(</span><span class=kt>long</span> <span class=n>arg0</span><span class=p>,</span> <span class=kt>long</span> <span class=n>arg1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>asm</span> <span class=k>volatile</span><span class=p>(</span><span class=s>&#34;addi a0, x0, %0;&#34;</span>
</span></span><span class=line><span class=cl>               <span class=s>&#34;addi a1, x0, %1;&#34;</span>
</span></span><span class=line><span class=cl>               <span class=s>&#34;ebreak&#34;</span> <span class=o>:</span> <span class=o>:</span> <span class=s>&#34;i&#34;</span><span class=p>(</span><span class=n>arg0</span><span class=p>),</span> <span class=s>&#34;i&#34;</span><span class=p>(</span><span class=n>arg1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>putch</span><span class=p>(</span><span class=kt>char</span> <span class=n>ch</span><span class=p>)</span> <span class=p>{</span> <span class=nf>ebreak</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>ch</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>halt</span><span class=p>(</span><span class=kt>int</span> <span class=n>code</span><span class=p>)</span> <span class=p>{</span> <span class=nf>ebreak</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>code</span><span class=p>);</span> <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>_start</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>putch</span><span class=p>(</span><span class=sc>&#39;A&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>halt</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** 
</span></span></span><span class=line><span class=cl><span class=cm> * 这段代码定义了三个函数：ebreak、putch 和 halt。
</span></span></span><span class=line><span class=cl><span class=cm> * ebreak 函数是一个内联汇编函数，它执行 ebreak 指令。
</span></span></span><span class=line><span class=cl><span class=cm> * 该指令是 RISC-V 架构中的一条调试指令，可以在调试器的控制下执行。
</span></span></span><span class=line><span class=cl><span class=cm> * 该函数接受两个参数 arg0 和 arg1，它们将被存储在寄存器 a0 和 a1 中。
</span></span></span><span class=line><span class=cl><span class=cm> * putch 函数调用了 ebreak 函数，并将第一个参数设为 0，
</span></span></span><span class=line><span class=cl><span class=cm> * 第二个参数设为函数参数 ch。这样做的目的可能是为了在调试器的控制下输出一个字符。
</span></span></span><span class=line><span class=cl><span class=cm> * halt 函数调用了 ebreak 函数，并将第一个参数设为 1，
</span></span></span><span class=line><span class=cl><span class=cm> * 第二个参数设为函数参数 code。这样做的目的可能是为了通知调试器程序已经结束，
</span></span></span><span class=line><span class=cl><span class=cm> * 并使用 code 作为结束状态。然后，halt 函数进入一个死循环，等待调试器的操作。
</span></span></span><span class=line><span class=cl><span class=cm> * 最后，_start 函数调用了 putch 函数输出字符 &#39;A&#39;，然后调用 halt 函数结束程序 
</span></span></span><span class=line><span class=cl><span class=cm> */</span> 
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>riscv64-linux-gnu-gcc -march<span class=o>=</span>rv64g -ffreestanding -nostdlib -static -Wl,-Ttext<span class=o>=</span><span class=m>0</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -O2 -o prog a.c
</span></span></code></pre></div><ul><li><p>riscv64-linux-gnu-gcc: 这是 GCC 的可执行文件的名称，表示使用的是 GCC 编译器。riscv64-linux-gnu 是编译器的目标平台，表示生成的代码是针对 RISC-V 架构，运行在 Linux 系统上的二进制文件。</p></li><li><p>-march=rv64g: 这个参数指定了编译器使用的指令集。rv64g 表示使用 RISC-V 架构的 64 位指令集。</p></li><li><p>-ffreestanding: 这个参数指示编译器生成的代码将在 freestanding 运行环境中运行。在 freestanding 运行环境中，程序不会自动链接标准 C 库，也不会自动调用 main 函数。</p></li><li><p>-nostdlib: 这个参数表示编译器不需要链接标准 C 库。</p></li><li><p>-static: 这个参数表示生成的代码是静态链接的。</p></li><li><p>-Wl,-Ttext=0: 这个参数是传递给链接器的，表示设置代码段的起始地址为 0。</p></li><li><p>-O2: 这个参数指示编译器使用优化级别为 2 的优化选项。</p></li><li><p>-o prog: 这个参数指定生成的可执行文件的名称为 prog。</p></li><li><p>a.c: 这是要编译的 C 源文件的名称。</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>llvm-objdump -d prog
</span></span></code></pre></div><p>反汇编结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>prog:</span>   <span class=nf>file</span> <span class=no>format</span> <span class=no>elf64-littleriscv</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>Disassembly</span> <span class=no>of</span> <span class=no>section</span> <span class=no>.text</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>0000000000000000</span> <span class=err>&lt;</span><span class=nf>_start</span><span class=err>&gt;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>       <span class=err>0:</span> <span class=err>13</span> <span class=err>05</span> <span class=err>00</span> <span class=err>00</span>   <span class=nf>li</span>      <span class=no>a0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>       <span class=err>4:</span> <span class=err>93</span> <span class=err>05</span> <span class=err>10</span> <span class=err>04</span>   <span class=nf>li</span>      <span class=no>a1</span><span class=p>,</span> <span class=mi>65</span>
</span></span><span class=line><span class=cl>       <span class=err>8:</span> <span class=err>73</span> <span class=err>00</span> <span class=err>10</span> <span class=err>00</span>   <span class=nf>ebreak</span>
</span></span><span class=line><span class=cl>       <span class=nl>c:</span> <span class=err>13</span> <span class=err>05</span> <span class=err>10</span> <span class=err>00</span>   <span class=nf>li</span>      <span class=no>a0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>      <span class=err>10:</span> <span class=err>93</span> <span class=err>05</span> <span class=err>00</span> <span class=err>00</span>   <span class=nf>li</span>      <span class=no>a1</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>      <span class=err>14:</span> <span class=err>73</span> <span class=err>00</span> <span class=err>10</span> <span class=err>00</span>   <span class=nf>ebreak</span>
</span></span><span class=line><span class=cl>      <span class=err>18:</span> <span class=err>6</span><span class=nf>f</span> <span class=mi>00</span> <span class=mi>00</span> <span class=mi>00</span>   <span class=no>j</span>       <span class=mh>0x18</span> <span class=p>&lt;</span><span class=no>_start</span><span class=p>+</span><span class=mi>0x18</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>我们约定中没有<code>li</code>指令，但是汇编中却出现了，这是因为<code>li</code>是一条伪指令，它的实际实现依然是<code>addi</code>。如果不使用伪指令可以使用以下命令反汇编：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>llvm-objdump -M no-aliases -d prog
</span></span></code></pre></div><p>结果如下，没有伪指令，只有我们约定的几条指令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>prog:</span>   <span class=nf>file</span> <span class=no>format</span> <span class=no>elf64-littleriscv</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>Disassembly</span> <span class=no>of</span> <span class=no>section</span> <span class=no>.text</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>0000000000000000</span> <span class=err>&lt;</span><span class=nf>_start</span><span class=err>&gt;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>       <span class=err>0:</span> <span class=err>13</span> <span class=err>05</span> <span class=err>00</span> <span class=err>00</span>   <span class=nf>addi</span>    <span class=no>a0</span><span class=p>,</span> <span class=no>zero</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>       <span class=err>4:</span> <span class=err>93</span> <span class=err>05</span> <span class=err>10</span> <span class=err>04</span>   <span class=nf>addi</span>    <span class=no>a1</span><span class=p>,</span> <span class=no>zero</span><span class=p>,</span> <span class=mi>65</span>
</span></span><span class=line><span class=cl>       <span class=err>8:</span> <span class=err>73</span> <span class=err>00</span> <span class=err>10</span> <span class=err>00</span>   <span class=nf>ebreak</span>
</span></span><span class=line><span class=cl>       <span class=nl>c:</span> <span class=err>13</span> <span class=err>05</span> <span class=err>10</span> <span class=err>00</span>   <span class=nf>addi</span>    <span class=no>a0</span><span class=p>,</span> <span class=no>zero</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>      <span class=err>10:</span> <span class=err>93</span> <span class=err>05</span> <span class=err>00</span> <span class=err>00</span>   <span class=nf>addi</span>    <span class=no>a1</span><span class=p>,</span> <span class=no>zero</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>      <span class=err>14:</span> <span class=err>73</span> <span class=err>00</span> <span class=err>10</span> <span class=err>00</span>   <span class=nf>ebreak</span>
</span></span><span class=line><span class=cl>      <span class=err>18:</span> <span class=err>6</span><span class=nf>f</span> <span class=mi>00</span> <span class=mi>00</span> <span class=mi>00</span>   <span class=no>jal</span>     <span class=no>zero</span><span class=p>,</span> <span class=mh>0x18</span> <span class=p>&lt;</span><span class=no>_start</span><span class=p>+</span><span class=mi>0x18</span><span class=p>&gt;</span>
</span></span></code></pre></div><h2 id=yemu-指令如何执行>YEMU 指令如何执行<a hidden class=anchor aria-hidden=true href=#yemu-指令如何执行>#</a></h2><p>ISA 手册定义了一个状态机。</p><ul><li><p>状态集合 S = {&lt;R, M>}</p><ul><li>R = {PC, x0, x1, x2, &mldr;}<ul><li>RISC-V 手册 -> 2.1 Programmers’Model for Base Integer ISA</li><li>PC = 程序计数器 = 当前执行的指令位置</li></ul></li><li>M = 内存<ul><li>RISC-V 手册 -> 1.4 Memory</li></ul></li></ul></li></ul><p>激励事件：执行 PC 指向的指令
状态转移规则：指令的语义 (semantics)
初始状态 S0 = &lt;R0, M0></p><p>我们只要把这个状态机实现出来，就可以用它来执行指令了！</p><h3 id=用变量实现内存>用变量实现内存<a hidden class=anchor aria-hidden=true href=#用变量实现内存>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>uint64_t</span> <span class=n>R</span><span class=p>[</span><span class=mi>32</span><span class=p>],</span> <span class=n>PC</span><span class=p>;</span> <span class=c1>// according to the RISC-V manual
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint8_t</span> <span class=n>M</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>      <span class=c1>// 64-Byte memory
</span></span></span></code></pre></div><p>Q: 为什么不使用 <code>int64_t</code> 和 <code>int8_t</code>?</p><p>A: C语言标准规定, 有符号数溢出是undefined behavior, 但无符号数不会溢出</p><blockquote><p>6.5 Expressions
5 If an exceptional condition occurs during the evaluation of an expression (that is,
if the result is not mathematically defined or not in the range of representable
values for its type), the behavior is undefined.
6.2.5 Types
9 A computation involving unsigned operands can never overflow, because a result that
cannot be represented by the resulting unsigned integer type is reduced modulo the
number that is one greater than the largest value that can be represented by the
resulting type.</p></blockquote><h3 id=用语句实现指令的语义>用语句实现指令的语义<a hidden class=anchor aria-hidden=true href=#用语句实现指令的语义>#</a></h3><p>指令周期 (instruction cycle): 执行一条指令的步骤</p><ul><li>取指 (fetch): 从 PC 所指示的内存位置读取一条指令</li><li>译码 (decode): 按照手册解析指令的操作码 (opcode) 和操作数 (operand)</li><li>执行 (execute): 按解析出的操作码，对操作数进行处理</li><li>更新 PC: 让 PC 指向下一条指令</li></ul><p>状态机不断执行指令，直到结束运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdbool.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>bool</span> <span class=n>halt</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>halt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>inst_cycle</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl> 31           20 19 15 14 12 11  7 6       0
</span></span><span class=line><span class=cl>+---------------+-----+-----+-----+---------+
</span></span><span class=line><span class=cl>|   imm[11:0]   | rs1 | 000 | rd  | 0010011 |    ADDI
</span></span><span class=line><span class=cl>+---------------+-----+-----+-----+---------+
</span></span><span class=line><span class=cl>+---------------+-----+-----+-----+---------+
</span></span><span class=line><span class=cl>| 000000000001  |00000| 000 |00000| 1110011 |   EBREAK
</span></span><span class=line><span class=cl>+---------------+-----+-----+-----+---------+
</span></span></code></pre></div><p>一个简单的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>inst_cycle</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>inst</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>M</span><span class=p>[</span><span class=n>PC</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(((</span><span class=n>inst</span> <span class=o>&amp;</span> <span class=mh>0x7f</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0x13</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>((</span><span class=n>inst</span> <span class=o>&gt;&gt;</span> <span class=mi>12</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0x7</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// addi
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(((</span><span class=n>inst</span> <span class=o>&gt;&gt;</span> <span class=mi>7</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0x1f</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>R</span><span class=p>[(</span><span class=n>inst</span> <span class=o>&gt;&gt;</span> <span class=mi>7</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0x1f</span><span class=p>]</span> <span class=o>=</span> <span class=n>R</span><span class=p>[(</span><span class=n>inst</span> <span class=o>&gt;&gt;</span> <span class=mi>15</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0x1f</span><span class=p>]</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>        <span class=p>(((</span><span class=n>inst</span> <span class=o>&gt;&gt;</span> <span class=mi>20</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0x7ff</span><span class=p>)</span> <span class=o>-</span> <span class=p>((</span><span class=n>inst</span> <span class=o>&amp;</span> <span class=mh>0x80000000</span><span class=p>)</span> <span class=o>?</span> <span class=mi>4096</span> <span class=o>:</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>inst</span> <span class=o>==</span> <span class=mh>0x00100073</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// ebreak
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>R</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=nf>putchar</span><span class=p>(</span><span class=n>R</span><span class=p>[</span><span class=mi>11</span><span class=p>]</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>R</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span> <span class=n>halt</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Unsupported ebreak command</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Unsupported instuction</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>PC</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=nemu-代码导读>NEMU 代码导读<a hidden class=anchor aria-hidden=true href=#nemu-代码导读>#</a></h1><h2 id=make-项目构>make 项目构<a hidden class=anchor aria-hidden=true href=#make-项目构>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 显示make踪迹</span>
</span></span><span class=line><span class=cl>strace make
</span></span><span class=line><span class=cl><span class=c1># 显示构建过程</span>
</span></span><span class=line><span class=cl>make -d
</span></span><span class=line><span class=cl><span class=c1># 显示更详细的构建构过程</span>
</span></span><span class=line><span class=cl>make --debug<span class=o>=</span>v
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Reading makefiles...
</span></span><span class=line><span class=cl>Reading makefile `Makefile&#39;...
</span></span><span class=line><span class=cl>Updating goal targets....
</span></span><span class=line><span class=cl> File `all&#39; does not exist.
</span></span><span class=line><span class=cl>   File `all&#39; does not exist.
</span></span><span class=line><span class=cl>   Looking for an implicit rule for `all&#39;.
</span></span><span class=line><span class=cl>   Trying pattern rule with stem `all&#39;.
</span></span><span class=line><span class=cl>   Trying implicit prerequisite `all.c&#39;.
</span></span><span class=line><span class=cl>   Trying pattern rule with stem `all&#39;.
</span></span><span class=line><span class=cl>   Trying implicit prerequisite `all.cc&#39;.
</span></span><span class=line><span class=cl>   Trying pattern rule with stem `all&#39;.
</span></span><span class=line><span class=cl>   Trying implicit prerequisite `all.C&#39;.
</span></span><span class=line><span class=cl>   Trying pattern rule with stem `all&#39;.
</span></span><span class=line><span class=cl>   Trying implicit prerequisite `all.cpp&#39;.
</span></span><span class=line><span class=cl>   Trying pattern rule with stem `all&#39;.
</span></span><span class=line><span class=cl>   Trying implicit prerequisite `all.CPP&#39;.
</span></span><span class=line><span class=cl>   Trying pattern rule with stem `all&#39;.
</span></span><span class=line><span class=cl>   Trying implicit prerequisite `all.cxx&#39;.
</span></span><span class=line><span class=cl>   Trying pattern rule with stem `all&#39;.
</span></span><span class=line><span class=cl>   Trying implicit prerequisite `all.CXX&#39;.
</span></span><span class=line><span class=cl>   Trying pattern rule with stem `all&#39;.
</span></span><span class=line><span class=cl>   Trying implicit prerequisite `all.c++&#39;.
</span></span><span class=line><span class=cl>   Trying pattern rule with stem `all&#39;.
</span></span><span class=line><span class=cl>   Trying implicit prerequisite `all.C++&#39;.
</span></span><span class=line><span class=cl>   No implicit rule found for `all&#39;.
</span></span><span class=line><span class=cl>   Finished prerequisites of target file `all&#39;.
</span></span><span class=line><span class=cl> Must remake target `all&#39;.
</span></span><span class=line><span class=cl>gcc -o all all.o
</span></span><span class=line><span class=cl>Finished prerequisites of target file `all&#39;.
</span></span><span class=line><span class=cl>Must remake target `all&#39;.
</span></span><span class=line><span class=cl>gcc -o all all.o
</span></span><span class=line><span class=cl>Successfully remade target file `all&#39;.
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 只打印命令不执行</span>
</span></span><span class=line><span class=cl>make -n
</span></span><span class=line><span class=cl><span class=c1># 输出目标被构建的原因和执行的命令</span>
</span></span><span class=line><span class=cl>make --trace
</span></span></code></pre></div><p>例如，如果您有一个 makefile，其目标 <code>all</code> 依赖于目标 <code>foo</code> 和 <code>bar</code>，并且您运行 <code>make --trace all</code>，您可能会看到如下输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>make<span class=o>[</span>1<span class=o>]</span>: Entering directory <span class=s1>&#39;/path/to/project&#39;</span>
</span></span><span class=line><span class=cl>gcc -o foo foo.c
</span></span><span class=line><span class=cl>make<span class=o>[</span>1<span class=o>]</span>: Leaving directory <span class=s1>&#39;/path/to/project&#39;</span>
</span></span><span class=line><span class=cl>make<span class=o>[</span>1<span class=o>]</span>: Entering directory <span class=s1>&#39;/path/to/project&#39;</span>
</span></span><span class=line><span class=cl>gcc -o bar bar.c
</span></span><span class=line><span class=cl>make<span class=o>[</span>1<span class=o>]</span>: Leaving directory <span class=s1>&#39;/path/to/project&#39;</span>
</span></span><span class=line><span class=cl>make<span class=o>[</span>1<span class=o>]</span>: Entering directory <span class=s1>&#39;/path/to/project&#39;</span>
</span></span><span class=line><span class=cl>gcc -o all foo.o bar.o
</span></span><span class=line><span class=cl>make<span class=o>[</span>1<span class=o>]</span>: Leaving directory <span class=s1>&#39;/path/to/project&#39;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>make -nB  <span class=c1># -B 可以强制 make 构建所有目标，即使它们已经是最新的</span>
</span></span><span class=line><span class=cl>make -nB <span class=p>|</span> vim -
</span></span></code></pre></div><p>在 vim 编辑器中进行二次处理，过滤不需要的信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 只保留 gcc 或 g++开头的行</span>
</span></span><span class=line><span class=cl>:%!grep <span class=s2>&#34;^\(gcc\|g++\)&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将环境变量$NEMU_HOME 所指示字符串替换为$NEMU_HOME</span>
</span></span><span class=line><span class=cl>:%!sed -e <span class=s2>&#34;s+</span><span class=nv>$NEMU_HOME</span><span class=s2>+\$NEMU_HOME+g&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将$NEMU_HOME/build/obj-riscv64-nemu-interpreter 替换为$OBJ_DIR</span>
</span></span><span class=line><span class=cl>:%s+<span class=se>\$</span>NEMU_HOME/build/obj-riscv64-nemu-interpreter+<span class=nv>$OBJ_DIR</span>+g
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将-c 之前的内容替换为$CFLAGS</span>
</span></span><span class=line><span class=cl>:%s/-O2.*<span class=o>=</span>riscv64/<span class=nv>$CFLAGS</span>/g
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将最后一行的空格替换成换行并缩进两格</span>
</span></span><span class=line><span class=cl>:<span class=nv>$s</span>/  */<span class=se>\r</span>  /g
</span></span></code></pre></div><h1 id=调试技巧选将>调试技巧选将<a hidden class=anchor aria-hidden=true href=#调试技巧选将>#</a></h1><h2 id=断言>断言<a hidden class=anchor aria-hidden=true href=#断言>#</a></h2><p>在 C 程序中使用断言（assert）不会增加额外的内存空间，也不会增加数据段空间。断言是一种在运行时检查程序假设是否为真的方法，当断言失败时，程序会终止执行并显示错误信息。</p><p>在 C 语言中，断言通常使用宏来实现。它在编译时被解释为一个简单的条件语句，因此它不会增加程序的内存空间或数据段空间。断言宏的定义通常类似于以下代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define assert(expression) ((void)0)
</span></span></span></code></pre></div><p>这里的 expression 是要检查的条件。如果 <code>expression</code> 为假，则 <code>assert()</code> 函数会发出错误消息并终止程序的执行。如果 <code>expression</code> 为真，则 <code>assert()</code> 函数不会产生任何操作，并且被解释为 <code>((void)0)</code>。这个语句不会增加任何内存或数据段空间。</p><p>需要注意的是，当一个程序使用大量的断言时，它可能会对程序的性能产生一些影响，因为每个断言都需要在运行时进行检查。因此，在生产环境中，应该尽可能减少使用断言，并在测试和调试阶段使用它们来确保代码的正
确性。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// nemu/src/isa/riscv64/local-include/reg.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>check_reg_idx</span><span class=p>(</span><span class=kt>int</span> <span class=n>idx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>IFDEF</span><span class=p>(</span><span class=n>CONFIG_RT_CHECK</span><span class=p>,</span> <span class=nf>assert</span><span class=p>(</span><span class=n>idx</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>idx</span> <span class=o>&lt;</span> <span class=mi>32</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>idx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=编译器工具-sanitizer>编译器工具 sanitizer<a hidden class=anchor aria-hidden=true href=#编译器工具-sanitizer>#</a></h2><p>让编译器自动插入 assert, 拦截常见的非预期行为</p><ul><li>AddressSanitizer - 检查指针越界，use-after-free</li><li>ThreadSanitizer - 检查多线程数据竞争</li><li>LeakSanitizer - 检查内存泄漏</li><li>UndefinedBehaviorSanitizer - 检查 UB</li><li>还能检查指针的比较和相减</li></ul><p>打开后程序运行效率有所下降</p><ul><li>但调试的时候非常值得，躺着就能让工具帮你找 bug</li><li>man gcc 查看具体用法</li></ul><h3 id=使用方法>使用方法<a hidden class=anchor aria-hidden=true href=#使用方法>#</a></h3><p>GCC 提供了多种 Sanitizer 工具，可以帮助开发者在编译时检测和修复常见的编程错误，例如内存泄漏、缓冲区溢出、使用未初始化的变量等。以下是几个 Sanitizer 工具的示例用法：</p><ol><li><p>Address Sanitizer（ASAN）：检测内存错误，例如使用已经释放的内存、堆栈和全局缓冲区的溢出和下溢等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gcc -fsanitize=address -g &lt;source files&gt; -o &lt;output file&gt;
</span></span></code></pre></div></li><li><p>Undefined Behavior Sanitizer（UBSAN）：检测未定义行为，例如除以零、使用未初始化的变量、指针溢出等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gcc -fsanitize=undefined -g &lt;source files&gt; -o &lt;output file&gt;
</span></span></code></pre></div></li><li><p>Thread Sanitizer（TSAN）：检测并发问题，例如竞争条件、死锁等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gcc -fsanitize=thread -g &lt;source files&gt; -o &lt;output file&gt;
</span></span></code></pre></div></li><li><p>Memory Sanitizer（MSAN）：检测使用未初始化的内存，例如读取未初始化的内存、使用已释放的内存等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gcc -fsanitize=memory -g &lt;source files&gt; -o &lt;output file&gt;
</span></span></code></pre></div></li></ol><p>需要注意的是，Sanitizer 工具可能会增加程序的执行时间和内存消耗，并且可能会产生误报，因此在生产环境中应该禁用 Sanitizer 工具。通常情况下，开发者可以在开发和测试阶段启用 Sanitizer 工具，以帮助他们发现和修复代码中的问题。</p><h2 id=自顶向下理解程序行为>自顶向下理解程序行为<a hidden class=anchor aria-hidden=true href=#自顶向下理解程序行为>#</a></h2><pre><code>ftrace - 函数调用层次，理解程序的大体行为
itrace - 指令执行层次，理解指令级别的行为
mtrace - 访存的踪迹
dtrace - 设备访问的踪迹
sdb - 灵活细致地检查客户程序的状态
si - 细粒度的状态转移
info r/x - 检查R/M
监视点 - 捕捉某状态发生变化的时刻
</code></pre><p>sdb 与 gdb 结合使用</p><pre><code>先用 sdb 定位到出错点附近
再用 gdb 观察 NEMU 的细节行为
</code></pre><h2 id=程序的运行时间都花在了哪里>程序的运行时间都花在了哪里<a hidden class=anchor aria-hidden=true href=#程序的运行时间都花在了哪里>#</a></h2><p>Linux 的性能分析工具 perf 是一款功能强大的性能分析工具，它可以通过硬件计数器（Hardware counter）或者性能事件（Performance event）来对 Linux 系统的性能进行分析。以下是 perf 工具的安装和使用方法。</p><h3 id=安装-perf-工具>安装 perf 工具<a hidden class=anchor aria-hidden=true href=#安装-perf-工具>#</a></h3><p>在大部分 Linux 发行版中，perf 工具已经预先安装，如果没有预先安装，可以通过以下命令进行安装。</p><ul><li>Debian/Ubuntu 系统：<code>sudo apt-get install linux-tools-common linux-tools-generic</code></li><li>Fedora 系统：<code>sudo dnf install perf</code></li><li>CentOS/RHEL 系统：<code>sudo yum install perf</code></li></ul><p>安装完毕之后，可以通过 <code>perf version</code> 命令来检查 perf 版本信息。</p><h3 id=编写一个简单的-c-代码>编写一个简单的 C 代码<a hidden class=anchor aria-hidden=true href=#编写一个简单的-c-代码>#</a></h3><p>这里我们编写一个简单的 C 代码，用于测试 perf 工具的使用。代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>1000000</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=o>+=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;sum = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>sum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>代码的作用是计算 1 到 1000000 的和。</p><h3 id=使用-perf-工具>使用 perf 工具<a hidden class=anchor aria-hidden=true href=#使用-perf-工具>#</a></h3><p>下面我们使用 perf 工具来对上述代码进行性能分析。假设代码保存在文件 test.c 中。</p><p>统计 CPU 周期数
以下命令用于统计程序的 CPU 周期数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>perf stat ./test
</span></span></code></pre></div><p>输出结果类似于：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> Performance counter stats <span class=k>for</span> <span class=s1>&#39;./test&#39;</span>:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>           19,23 msec task-clock:u              <span class=c1>#    0.988 CPUs utilized          </span>
</span></span><span class=line><span class=cl>                 <span class=m>0</span>      context-switches:u        <span class=c1>#    0.000 K/sec                  </span>
</span></span><span class=line><span class=cl>                 <span class=m>0</span>      cpu-migrations:u          <span class=c1>#    0.000 K/sec                  </span>
</span></span><span class=line><span class=cl>               <span class=m>575</span>      page-faults:u             <span class=c1>#    0.030 M/sec                  </span>
</span></span><span class=line><span class=cl>    64,013,620,231      cycles:u                  <span class=c1>#    3.324 GHz                      (49.80%)</span>
</span></span><span class=line><span class=cl>    40,010,335,480      instructions:u            <span class=c1>#    0.62  insn per cycle           (62.34%)</span>
</span></span><span class=line><span class=cl>     9,998,469,566      branches:u                <span class=c1>#  518.693 M/sec                    (62.27%)</span>
</span></span><span class=line><span class=cl>           763,176      branch-misses:u           <span class=c1>#    0.01% of all branches          (62.32%)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      0.019438122 seconds <span class=nb>time</span> elapsed
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      0.019411000 seconds user
</span></span><span class=line><span class=cl>      0.000007000 seconds sys
</span></span></code></pre></div><p>输出结果中的 cycles 表示 CPU 周期数，instructions 表示指令数，branches 表示分支指令数。其中，cycles 和 instructions 的比例代表了 CPU 的效率，即 IPC（Instructions Per Cycle）。</p><h3 id=统计函数调用次数>统计函数调用次数<a hidden class=anchor aria-hidden=true href=#统计函数调用次数>#</a></h3><p>以下命令用于统计程序中函数的调用次数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>perf record -e cycles -g ./test
</span></span></code></pre></div><p>这个命令将启动 perf 工具，并使用 -g 选项记录调用关系图。我们还需要使用 sudo 权限运行该命令，以便 perf 工具可以访问系统的硬件计数器。</p><h2 id=成为专业码农>成为专业码农<a hidden class=anchor aria-hidden=true href=#成为专业码农>#</a></h2><ul><li>要熟悉项目了 -> STFW/RTFM/RTFSC, 尝试理解一切细节</li><li>要写代码了<ul><li>仔细 RTFM, 正确理解需求</li><li>编写可读，可维护，易验证的代码 (不言自明，不言自证)</li><li>用 lint 工具检查代码</li><li>进行充分的测试</li><li>添加充分的断言</li></ul></li><li>要调试了<ul><li>默念“机器永远是对的/未测试代码永远是错的”</li><li>sanitizer, trace, printf, gdb, …</li></ul></li><li>平时 -> 用正确的工具/方法做事情</li><li>感到不爽了 -> 找正确的工具/搭基础设施</li></ul><h1 id=总线选讲>总线选讲<a hidden class=anchor aria-hidden=true href=#总线选讲>#</a></h1><h2 id=定义>定义<a hidden class=anchor aria-hidden=true href=#定义>#</a></h2><p>广义上讲总线就是一个通信系统，以下这些都属于广义的总线概念:TCP/IP, 以太网，网线，RTL 信号，系统调用。</p><p>主动发起通信的叫 master，响应通信的叫 slave。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://lifeislife.cn/posts/wsl2%E5%AE%89%E8%A3%85docker/><span class=title>« 上一页</span><br><span>WSL2 安装 Docker</span>
</a><a class=next href=https://lifeislife.cn/posts/java%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0/><span class=title>下一页 »</span><br><span>JAVA 小白笔记</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 一生一芯笔记 on x" href="https://x.com/intent/tweet/?text=%e4%b8%80%e7%94%9f%e4%b8%80%e8%8a%af%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25B8%2580%25E7%2594%259F%25E4%25B8%2580%25E8%258A%25AF%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 一生一芯笔记 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25B8%2580%25E7%2594%259F%25E4%25B8%2580%25E8%258A%25AF%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;title=%e4%b8%80%e7%94%9f%e4%b8%80%e8%8a%af%e7%ac%94%e8%ae%b0&amp;summary=%e4%b8%80%e7%94%9f%e4%b8%80%e8%8a%af%e7%ac%94%e8%ae%b0&amp;source=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25B8%2580%25E7%2594%259F%25E4%25B8%2580%25E8%258A%25AF%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 一生一芯笔记 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25B8%2580%25E7%2594%259F%25E4%25B8%2580%25E8%258A%25AF%25E7%25AC%2594%25E8%25AE%25B0%2f&title=%e4%b8%80%e7%94%9f%e4%b8%80%e8%8a%af%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 一生一芯笔记 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25B8%2580%25E7%2594%259F%25E4%25B8%2580%25E8%258A%25AF%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 一生一芯笔记 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%b8%80%e7%94%9f%e4%b8%80%e8%8a%af%e7%ac%94%e8%ae%b0%20-%20https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25B8%2580%25E7%2594%259F%25E4%25B8%2580%25E8%258A%25AF%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 一生一芯笔记 on telegram" href="https://telegram.me/share/url?text=%e4%b8%80%e7%94%9f%e4%b8%80%e8%8a%af%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25B8%2580%25E7%2594%259F%25E4%25B8%2580%25E8%258A%25AF%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 一生一芯笔记 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e4%b8%80%e7%94%9f%e4%b8%80%e8%8a%af%e7%ac%94%e8%ae%b0&u=https%3a%2f%2flifeislife.cn%2fposts%2f%25E4%25B8%2580%25E7%2594%259F%25E4%25B8%2580%25E8%258A%25AF%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://lifeislife-1.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://lifeislife.cn/>夜云泊</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>