<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux 帧缓冲 | 夜云泊</title><meta name=keywords content="Linux,FrameBuffer,LCD"><meta name=description content="简介
FrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。"><meta name=author content="Nic"><link rel=canonical href=https://lifeislife.cn/posts/linux%E5%B8%A7%E7%BC%93%E5%86%B2/><link crossorigin=anonymous href=/assets/css/stylesheet.4490366ee59f83f7324bce1d2f81fb1ebba1a551f24577c75929014495a1d9b1.css integrity="sha256-RJA2buWfg/cyS84dL4H7HruhpVHyRXfHWSkBRJWh2bE=" rel="preload stylesheet" as=style><link rel=icon href=https://lifeislife.cn/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lifeislife.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lifeislife.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://lifeislife.cn/apple-touch-icon.png><link rel=mask-icon href=https://lifeislife.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lifeislife.cn/posts/linux%E5%B8%A7%E7%BC%93%E5%86%B2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PS8L2EEEPR")}</script><meta property="og:title" content="Linux 帧缓冲"><meta property="og:description" content="简介
FrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。"><meta property="og:type" content="article"><meta property="og:url" content="https://lifeislife.cn/posts/linux%E5%B8%A7%E7%BC%93%E5%86%B2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-17T17:38:04+00:00"><meta property="article:modified_time" content="2022-01-17T17:38:04+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux 帧缓冲"><meta name=twitter:description content="简介
FrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifeislife.cn/posts/"},{"@type":"ListItem","position":2,"name":"Linux 帧缓冲","item":"https://lifeislife.cn/posts/linux%E5%B8%A7%E7%BC%93%E5%86%B2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux 帧缓冲","name":"Linux 帧缓冲","description":"简介 FrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。\n","keywords":["Linux","FrameBuffer","LCD"],"articleBody":"简介 FrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。\n\u003c!DOCTYPE html\u003e Responsive Image 帧缓冲主要结构 fb_info 该结构体记录当前帧缓冲设备的状态信息，如果系统中有多个帧缓冲设备，就需要两个fb_info结构，这个结构只在内核中可以看到，对用户空间不可见。\nfb_var_screeninfo 该结构体记录指定的帧缓冲设备和显示模式中可以被修改的信息，其中包括显示器分辨率等信息。\nfb_fix_screeninfo 该结构体表示帧缓冲设备中一些不能修改的参数，包括特定的显示模式，屏幕缓冲区的物理地址，显示缓冲区的长度信息。\nfb_ops LCD底层硬件操作接口集。比如fb_open、fb_release、fb_read、fb_write、fb_ioctl、fb_mmap等：\nfb_cmap fb_cmap指定颜色映射，用于以内核可以理解的方式存储用户的颜色定义。\n\u003c!DOCTYPE html\u003e Responsive Image 帧缓冲显示原理 帧缓冲设备是一种显示抽象的设备，也可以被理解为它是一个内存区域，上面的应用程序可以直接对显示缓冲区进行读和写操作，就像访问文件的通用接口一样，用户可以认为帧缓冲是一块内存，能读取数据的内存块也可以向这个内存写入数据，因此显示器显示图形界面实际上根据根据的是指定的内存数据块内的数据。\n帧缓冲的显示缓冲区位于 Linux 内核地址空间，应用程序不能直接访问内核地址空间，在 Linux 中，只有一个内存的内核地址空间映射到用户地址空间才可以由用户访问，内存的映射是通过MMAP函数实现的在 Linux 中。对于帧缓冲，虚拟地址是通过内存映射的方法将显示缓冲区内核地址映射到用户空间的，然后用户可以通过读和写这部分的虚拟地址来访问显示缓冲区，在屏幕上绘图。\n使用流程 使用帧缓冲之前应该首先确定 Linux 系统上已安装了帧缓冲驱动，可以在目录/dev/下查找fb*如，/dev/fb0, /dev/fb1等设备来确定是否安装。如果没有需要安装一个帧缓冲驱动的模块到内核，或者重新编译内核生成一个带帧缓冲模块的镜像。\n使用帧缓冲需要进入控制台模式，即纯命令行的模式进行编程。一般可以通过快捷键CTRL+ALT+F1进入控制台模式，CTRL+ALT+F7切回图形窗口。如果控制台模式没有登录，可以CTRL+ALT+F6尝试登录。\n因硬件显示设备的物理显示区是通过帧缓存区操作，而帧缓存区是处于内核空间，应用程序不能随意操作，此时可以通过系统调用mmap把帧缓存映射到用户空间，在用户空间中创建出帧缓存映射区（用户图像数据缓存区），以后只需把用户图像数据写入到帧缓存映射区就可在硬件设备上显示图像。\n具体实现流程如下：\n打开帧缓冲设备/dev/f0 在Linux的/dev目录的寻找b*设备文件然后使用读写模式打开它，Linux 系统将使用通用的open系统调用来完成功能， open的功能原型如下：\nint open(const char *path, int oflags); Path是准备打开的文件或设备的路径参数； oflags指定打开文件时使用的参数； flags参数的指定，是通过组合文件访问模式和其他的可选模式一起的，可以支持多个模式或，参数必须是指定下列文件的访问模式。 只读：O_RDONLLY 只写：O_WRONLY 读写：O_RDWR 简而言之， open函数建立设备文件的访问路径。如果操作成功，它返回一个文件描述符，只是一个文件描述符，它将不使用其他任何正在运行的进程共享。如果两个程序同时打开相同的文件，将得到两个不同的文件描述符。如果他们执行文件写入操作，他们将操作每个文件描述符，不会发生冲突，写完之后退出。他们的数据不会互相交织在一起的，但会互相的彼此覆盖 (后写完的内容覆盖前面写的内容)，两个程序来读取和写入的文件位置看似一样但是有各自不同拷贝所以不会发生交织。如果open调用未能返回1，则将全局变量errno设置为指示失败的原因。\n通过系统调用ioctl函数获得帧设备相关信息 通过顿缓冲文件描述符，屏幕的分辨率、颜色深度等信息可以被获得，帧缓冲驱动中存放了这些对应的信息，必须使用 Linux 系统调用ioctl首先将帧缓冲的文件描述符和fb_var_screeninfo 结构体对应起来。\n结构体fb_var_screeninfo包含以下三个重要数据结构：\n屏幕的 x 方向分辨率，像素作为单位。 屏幕的 Y 方向分辨率，像素作为单位。 屏幕的像素颜色深度，每个像素用多少比特数表示。 ioctl函数原型如下：\nextern int ioctl (int __fd, unsigned long int __request, ...) __THROW; ioctl调用实现访问设备驱动各种各样的配置信息功能，它提供了一个控制设备的行为和配置底层服务接口的驱动函数，各种设备驱动程序，例如套接字和系统终端，还有磁带机都有ioctl命令可以支持。\n__fd：ioctl命令中是该帧缓冲的文件描述符； __request：ioctl函数将要执行的命令，实现参数给定的对象描述符中指定的函数操作，各种设备支持的功能是有差异的 FBIOGET_VSCREENINFO命令字返回与Framebuffer有关的固定的信息； FBIOGET_VSCREENINFO命令字返回与 Framebuffer 有关的可变的信息； 第三个参数是一个指针用来指向结构体fb_var_screeninfo。 最后使用者可以通过结构体fb_var_screeninfo来获得屏幕的分辨率和颜色位深和其他重要的屏幕信息。根据这些信息可以计算屏幕缓冲区的大小：屏幕缓冲区大小 (以字节为单位) = 屏幕宽度x高度x屏幕颜色深度/8\n帧缓冲映射 在进行帧缓冲的MMAP映射之前，要先得到帧缓冲文件描述符，才能像屏幕上面显示，必须首先将缓冲区的内核地址映射映射到用户地址空间。Linux 系统将使用MMAP系统调用完成功能，MMAP函数原型如下：\nextern void *mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off_t __offset) __THROW; __addr：返回一个指向mmap函数的内存区域的指针，与内容相关的文件指针，通过指针可以访问帧缓冲区的内存区域。\n__len：可以请求使用特定内存地址，通过设置地址参数，如果值为0，将自动分配指针，这是推荐的做法，否则会降低程序的可移植性，因为不同的系统可用的地址范围是不一样的。\n__prot：设置内存访问的权限设定，通过端口相关的参数定义，位的定义值如下：\nPORT_EXEC:允许内存段的执行。 PORT_NONE:无法访问内存段。 PORT_READ:允许读取内存段。 PORT_WRITE:允许编写内存段。 __flags：改变控制参数标志，能够影响该内存段的作用域，如下所示：\nMAP_FIXED:内存段必须位于addr中指定的地址。 MAP_SHARED:内存的修改保存到一个文件中。 MAP_PRIVATE:内存段是私人的，变化仅在本地范围内有效。 __fd：是通过一个open调用得到的访问文件的描述符。\noffset：用于指定访问数据的开始偏移量在内存段中，和访问普通文件使用方式是相同的，再指定文件描述符参数，以及访问的数据长度参数即可。\n读写帧缓冲 MMAP返回的指针，可以访问到帧缓冲内存区，可以定位到屏幕缓冲区具体为每个显示像素的位置，通过读函数调用读取对应的位置数据在帧缓冲内存中，相反写操作对应于内存的写入数据可以显示内容写到屏幕上。\n解除帧缓冲映射 在绘图完成后，帧缓冲文件描述符必须被释放之前，解除帧缓冲区的地址映射，使用 Linux 系统调用完成mmap函数的逆函数实现，即是munmap，函数的原型如下：\nextern int munmap (void *__addr, size_t __len) __THROW; addr参数应该与调用MMAP时指定的参数值一致， len参数也应该与之前调用MMAP时指定的len参数保持一致。\nmmap调用返回0成功，失败则返回1，同时将全局变量erno设置为指示失败的原因。\n调用close关闭设备 使用帧缓冲设备后，应关闭相应的文件描述符，使用 Linux 系统标准的函数完成关闭功能，close函数的原型如下：\nextern int close (int __fd); close的参数和在开始调用open时指定的参数一致，文件描述符释放后可以重用，结束调用成功返回0，失败返回1。\n帧缓冲实例 以下代码摘自xianjimli/linux-framebuffer-tools: linux framebuffer tool，演示了帧缓冲设备的使用流程。\nfb_info_t *linux_fb_open(const char *filename) { uint32_t size = 0; fb_info_t *fb = NULL; struct fb_fix_screeninfo fix; struct fb_var_screeninfo var; return_value_if_fail(filename != NULL, NULL); fb = (fb_info_t *)calloc(1, sizeof(fb_info_t)); return_value_if_fail(fb != NULL, NULL); // 打开帧缓冲设备，O_RDWR 读写模式 fb-\u003efd = open(filename, O_RDWR); if (fb-\u003efd \u003c 0) { log_debug(\"open %s failed(%d)\\n\", filename, errno); free(fb); return NULL; } // 通过系统调用 ioctl 函数获得帧设备相关信息 // FBIOGET_FSCREENINFO 命令字返回与 Framebuffer 有关的固定的信息 if (ioctl(fb-\u003efd, FBIOGET_FSCREENINFO, \u0026fix) \u003c 0) goto fail; //命令字返回与 Framebuffer 有关的可变的信息 if (ioctl(fb-\u003efd, FBIOGET_VSCREENINFO, \u0026var) \u003c 0) goto fail; var.xoffset = 0; var.yoffset = 0; // 显示 ioctl(fb-\u003efd, FBIOPAN_DISPLAY, \u0026(var)); log_debug(\"fb_info_t: %s\\n\", filename); log_debug(\"fb_info_t: xres=%d yres=%d bits_per_pixel=%d mem_size=%d\\n\", var.xres, var.yres, var.bits_per_pixel, fb_size(fb)); log_debug(\"fb_info_t: red(%d %d) green(%d %d) blue(%d %d)\\n\", var.red.offset, var.red.length, var.green.offset, var.green.length, var.blue.offset, var.blue.length); fb-\u003ew = var.xres; fb-\u003eh = var.yres; fb-\u003ebpp = var.bits_per_pixel / 8; fb-\u003eline_length = fix.line_length; size = fb_size(fb); // 帧缓冲映射 // PROT_READ | PROT_WRITE:可读写 // MAP_SHARED：内存的修改保存到一个文件 fb-\u003edata = (uint8_t *)mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fb-\u003efd, 0); if (fb-\u003edata == MAP_FAILED) { log_debug(\"map framebuffer failed.\\n\"); goto fail; } log_debug(\"line_length=%d mem_size=%d\\n\", fix.line_length, fb_size(fb)); log_debug(\"xres_virtual =%d yres_virtual=%d xpanstep=%d ywrapstep=%d\\n\", var.xres_virtual, var.yres_virtual, fix.xpanstep, fix.ywrapstep); return fb; fail: log_debug(\"%s is not a framebuffer.\\n\", filename); close(fb-\u003efd); free(fb); return NULL; } 感兴趣可以下载源码编译运行，其中/bin/fbshow可以使用帧缓冲设备显示图片。图形界面下直接运行可能提示无法运行，需要Chrtl+Alt+F1切换到控制台模式。\n\u003c!DOCTYPE html\u003e Responsive Image LCD 与 Framebuffer 的关系 \u003c!DOCTYPE html\u003e Responsive Image LCD 控制器首先通过 VDEN 信号，使能。接下来根据 VCLK 时钟信号，在像素点上“喷涂”不同的颜色（打个比方），控制器有 VD（video data）信号，传送不同颜色信息。每来一个时钟信号，就向右移动一个像素，根据行同步信号 HSYNC，就从最右边移动到最左边。当移动到右下角时根据垂直同步信号 VSYNC。\n那么问题来了，不同颜色的信息从哪里来？就是从上文介绍的 Framebuffer 中来的。\n很多人都会说操纵 LCD 显示就是操纵 FrameBuffer，表面上来看是这样的。实际上是 FrameBuffer 就是 Linux 内核驱动申请的一片内存空间，然后 LCD 内有一片 sram，CPU 内部有个 LCD 控制器，它有个单独的 dma 用来将 FrameBuffer 中的数据拷贝到 LCD 的 sram 中去 拷贝到 LCD 的 sram 中的数据就会显示在 LCD 上，LCD 驱动和 FrameBuffer 驱动没有必然的联系，它只是驱动 LCD 正常工作的，比如有信号传过来，那么 LCD 驱动负责把信号转成显示屏上的内容，至于什么内容这就是应用层要处理的。\n静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。 DMA（Direct Memory Access），直接内存访问。使用 DMA 的好处就是它不需要 CPU 的干预而直接服务外设，这样 CPU 就可以去处理别的事务，从而提高系统的效率。\nReference Linux 驱动之 Framebuffer 子系统 | 量子范式 Linux 驱动开发（9）——- framebuffer 驱动详解 | 码农家园 嵌入式系统中帧缓冲显示模块的设计与实现 - 中国知网 research/framebuffer/fivechess/fivechess-0.1 at master · tsuibin/research 五子棋 framebuffer 版 - 尚码园 FrameBuffer 驱动程序分析_深入剖析 Android 系统-CSDN 博客_framebuffer xianjimli/linux-framebuffer-tools: linux framebuffer tool 韦东山_嵌入式 Linux_第 2 期_Linux 高级驱动视频教程_免费试看版_哔哩哔哩_bilibili Linux LCD Frambuffer 基础介绍和使用（1） - 知乎\n","wordCount":"4334","inLanguage":"zh","datePublished":"2022-01-17T17:38:04Z","dateModified":"2022-01-17T17:38:04Z","author":{"@type":"Person","name":"Nic"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifeislife.cn/posts/linux%E5%B8%A7%E7%BC%93%E5%86%B2/"},"publisher":{"@type":"Organization","name":"夜云泊","logo":{"@type":"ImageObject","url":"https://lifeislife.cn/assets/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script defer src=/static/fontawesome/fontawesome-all.js></script><header class=header><nav class=nav><div class=logo><a href=https://lifeislife.cn/ accesskey=h title="夜云泊 (Alt + H)">夜云泊</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lifeislife.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://lifeislife.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://lifeislife.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://lifeislife.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://www.travellings.cn/go.html title=开往><span><i class='fa-solid fa-train-subway'></i>开往</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lifeislife.cn/>主页</a>&nbsp;»&nbsp;<a href=https://lifeislife.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Linux 帧缓冲</h1><div class=post-meta><span title='2022-01-17 17:38:04 +0000 UTC'>一月 17, 2022</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;4334 字&nbsp;·&nbsp;Nic</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#帧缓冲主要结构>帧缓冲主要结构</a></li><li><a href=#帧缓冲显示原理>帧缓冲显示原理</a></li><li><a href=#使用流程>使用流程</a><ul><li><a href=#打开帧缓冲设备devf0>打开帧缓冲设备<code>/dev/f0</code></a></li><li><a href=#通过系统调用ioctl函数获得帧设备相关信息>通过系统调用<code>ioctl</code>函数获得帧设备相关信息</a></li><li><a href=#帧缓冲映射>帧缓冲映射</a></li><li><a href=#读写帧缓冲>读写帧缓冲</a></li><li><a href=#解除帧缓冲映射>解除帧缓冲映射</a></li><li><a href=#调用close关闭设备>调用<code>close</code>关闭设备</a></li></ul></li><li><a href=#帧缓冲实例>帧缓冲实例</a></li><li><a href=#lcd-与-framebuffer-的关系>LCD 与 Framebuffer 的关系</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h2 id=简介>简介<a hidden class=anchor aria-hidden=true href=#简介>#</a></h2><p>FrameBuffer 是内核当中的一种驱动程序接口。Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏，Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220118092227.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220118092227.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h2 id=帧缓冲主要结构>帧缓冲主要结构<a hidden class=anchor aria-hidden=true href=#帧缓冲主要结构>#</a></h2><ul><li><p>fb_info
该结构体记录当前帧缓冲设备的状态信息，如果系统中有多个帧缓冲设备，就需要两个fb_info结构，这个结构只在内核中可以看到，对用户空间不可见。</p></li><li><p>fb_var_screeninfo
该结构体记录指定的帧缓冲设备和显示模式中可以被修改的信息，其中包括显示器分辨率等信息。</p></li><li><p>fb_fix_screeninfo
该结构体表示帧缓冲设备中一些不能修改的参数，包括特定的显示模式，屏幕缓冲区的物理地址，显示缓冲区的长度信息。</p></li><li><p>fb_ops
LCD底层硬件操作接口集。比如<code>fb_open</code>、<code>fb_release</code>、<code>fb_read</code>、<code>fb_write</code>、<code>fb_ioctl</code>、<code>fb_mmap</code>等：</p></li><li><p>fb_cmap
<code>fb_cmap</code>指定颜色映射，用于以内核可以理解的方式存储用户的颜色定义。</p></li></ul><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220117192106.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220117192106.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h2 id=帧缓冲显示原理>帧缓冲显示原理<a hidden class=anchor aria-hidden=true href=#帧缓冲显示原理>#</a></h2><p>帧缓冲设备是一种显示抽象的设备，也可以被理解为它是一个内存区域，上面的应用程序可以直接对显示缓冲区进行读和写操作，就像访问文件的通用接口一样，用户可以认为帧缓冲是一块内存，能读取数据的内存块也可以向这个内存写入数据，因此显示器显示图形界面实际上根据根据的是指定的内存数据块内的数据。</p><p>帧缓冲的显示缓冲区位于 Linux 内核地址空间，应用程序不能直接访问内核地址空间，在 Linux 中，只有一个内存的内核地址空间映射到用户地址空间才可以由用户访问，内存的映射是通过<code>MMAP</code>函数实现的在 Linux 中。对于帧缓冲，虚拟地址是通过内存映射的方法将显示缓冲区内核地址映射到用户空间的，然后用户可以通过读和写这部分的虚拟地址来访问显示缓冲区，在屏幕上绘图。</p><h2 id=使用流程>使用流程<a hidden class=anchor aria-hidden=true href=#使用流程>#</a></h2><p>使用帧缓冲之前应该首先确定 Linux 系统上已安装了帧缓冲驱动，可以在目录<code>/dev/</code>下查找<code>fb*</code>如，<code>/dev/fb0, /dev/fb1</code>等设备来确定是否安装。如果没有需要安装一个帧缓冲驱动的模块到内核，或者重新编译内核生成一个带帧缓冲模块的镜像。</p><p>使用帧缓冲需要进入控制台模式，即纯命令行的模式进行编程。一般可以通过快捷键<code>CTRL+ALT+F1</code>进入控制台模式，<code>CTRL+ALT+F7</code>切回图形窗口。如果控制台模式没有登录，可以<code>CTRL+ALT+F6</code>尝试登录。</p><p>因硬件显示设备的物理显示区是通过帧缓存区操作，而帧缓存区是处于内核空间，应用程序不能随意操作，此时可以通过系统调用<code>mmap</code>把帧缓存映射到用户空间，在用户空间中创建出帧缓存映射区（用户图像数据缓存区），以后只需把用户图像数据写入到帧缓存映射区就可在硬件设备上显示图像。</p><p>具体实现流程如下：</p><h3 id=打开帧缓冲设备devf0>打开帧缓冲设备<code>/dev/f0</code><a hidden class=anchor aria-hidden=true href=#打开帧缓冲设备devf0>#</a></h3><p>在Linux的/dev目录的寻找b*设备文件然后使用读写模式打开它，Linux 系统将使用通用的<code>open</code>系统调用来完成功能， <code>open</code>的功能原型如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=ne>int</span> <span class=n>open</span><span class=p>(</span><span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=ne>int</span> <span class=n>oflags</span><span class=p>);</span>
</span></span></code></pre></div><ul><li><code>Path</code>是准备打开的文件或设备的路径参数；</li><li><code>oflags</code>指定打开文件时使用的参数；</li><li><code>flags</code>参数的指定，是通过组合文件访问模式和其他的可选模式一起的，可以支持多个模式或，参数必须是指定下列文件的访问模式。<ul><li>只读：O_RDONLLY</li><li>只写：O_WRONLY</li><li>读写：O_RDWR</li></ul></li></ul><p>简而言之， <code>open</code>函数建立设备文件的访问路径。如果操作成功，它返回一个文件描述符，只是一个文件描述符，它将不使用其他任何正在运行的进程共享。如果两个程序同时打开相同的文件，将得到两个不同的文件描述符。如果他们执行文件写入操作，他们将操作每个文件描述符，不会发生冲突，写完之后退出。他们的数据不会互相交织在一起的，但会互相的彼此覆盖 (后写完的内容覆盖前面写的内容)，两个程序来读取和写入的文件位置看似一样但是有各自不同拷贝所以不会发生交织。如果<code>open</code>调用未能返回<code>1</code>，则将全局变量<code>errno</code>设置为指示失败的原因。</p><h3 id=通过系统调用ioctl函数获得帧设备相关信息>通过系统调用<code>ioctl</code>函数获得帧设备相关信息<a hidden class=anchor aria-hidden=true href=#通过系统调用ioctl函数获得帧设备相关信息>#</a></h3><p>通过顿缓冲文件描述符，屏幕的分辨率、颜色深度等信息可以被获得，帧缓冲驱动中存放了这些对应的信息，必须使用 Linux 系统调用<code>ioctl</code>首先将帧缓冲的文件描述符和<code>fb_var_screeninfo</code> 结构体对应起来。</p><p>结构体<code>fb_var_screeninfo</code>包含以下三个重要数据结构：</p><ul><li>屏幕的 x 方向分辨率，像素作为单位。</li><li>屏幕的 Y 方向分辨率，像素作为单位。</li><li>屏幕的像素颜色深度，每个像素用多少比特数表示。</li></ul><p><code>ioctl</code>函数原型如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=nf>ioctl</span> <span class=p>(</span><span class=kt>int</span> <span class=n>__fd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>__request</span><span class=p>,</span> <span class=p>...)</span> <span class=n>__THROW</span><span class=p>;</span>
</span></span></code></pre></div><p><code>ioctl</code>调用实现访问设备驱动各种各样的配置信息功能，它提供了一个控制设备的行为和配置底层服务接口的驱动函数，各种设备驱动程序，例如套接字和系统终端，还有磁带机都有<code>ioctl</code>命令可以支持。</p><ul><li><code>__fd</code>：<code>ioctl</code>命令中是该帧缓冲的文件描述符；</li><li><code>__request</code>：<code>ioctl</code>函数将要执行的命令，实现参数给定的对象描述符中指定的函数操作，各种设备支持的功能是有差异的<ul><li><code>FBIOGET_VSCREENINFO</code>命令字返回与Framebuffer有关的固定的信息；</li><li><code>FBIOGET_VSCREENINFO</code>命令字返回与 Framebuffer 有关的可变的信息；</li></ul></li><li>第三个参数是一个指针用来指向结构体<code>fb_var_screeninfo</code>。</li></ul><p>最后使用者可以通过结构体<code>fb_var_screeninfo</code>来获得屏幕的分辨率和颜色位深和其他重要的屏幕信息。根据这些信息可以计算屏幕缓冲区的大小：屏幕缓冲区大小 (以字节为单位) = 屏幕宽度x高度x屏幕颜色深度/8</p><h3 id=帧缓冲映射>帧缓冲映射<a hidden class=anchor aria-hidden=true href=#帧缓冲映射>#</a></h3><p>在进行帧缓冲的<code>MMAP</code>映射之前，要先得到帧缓冲文件描述符，才能像屏幕上面显示，必须首先将缓冲区的内核地址映射映射到用户地址空间。Linux 系统将使用<code>MMAP</code>系统调用完成功能，<code>MMAP</code>函数原型如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=kt>void</span> <span class=o>*</span><span class=nf>mmap</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>__addr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>__len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>__prot</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=kt>int</span> <span class=n>__flags</span><span class=p>,</span> <span class=kt>int</span> <span class=n>__fd</span><span class=p>,</span> <span class=n>__off_t</span> <span class=n>__offset</span><span class=p>)</span> <span class=n>__THROW</span><span class=p>;</span>
</span></span></code></pre></div><ul><li><p><code>__addr</code>：返回一个指向<code>mmap</code>函数的内存区域的指针，与内容相关的文件指针，通过指针可以访问帧缓冲区的内存区域。</p></li><li><p><code>__len</code>：可以请求使用特定内存地址，通过设置地址参数，如果值为<code>0</code>，将自动分配指针，这是推荐的做法，否则会降低程序的可移植性，因为不同的系统可用的地址范围是不一样的。</p></li><li><p><code>__prot</code>：设置内存访问的权限设定，通过端口相关的参数定义，位的定义值如下：</p><ul><li><code>PORT_EXEC</code>:允许内存段的执行。</li><li><code>PORT_NONE</code>:无法访问内存段。</li><li><code>PORT_READ</code>:允许读取内存段。</li><li><code>PORT_WRITE</code>:允许编写内存段。</li></ul></li><li><p><code>__flags</code>：改变控制参数标志，能够影响该内存段的作用域，如下所示：</p><ul><li><code>MAP_FIXED</code>:内存段必须位于addr中指定的地址。</li><li><code>MAP_SHARED</code>:内存的修改保存到一个文件中。</li><li><code>MAP_PRIVATE</code>:内存段是私人的，变化仅在本地范围内有效。</li></ul></li><li><p><code>__fd</code>：是通过一个<code>open</code>调用得到的访问文件的描述符。</p></li><li><p><code>offset</code>：用于指定访问数据的开始偏移量在内存段中，和访问普通文件使用方式是相同的，再指定文件描述符参数，以及访问的数据长度参数即可。</p></li></ul><h3 id=读写帧缓冲>读写帧缓冲<a hidden class=anchor aria-hidden=true href=#读写帧缓冲>#</a></h3><p><code>MMAP</code>返回的指针，可以访问到帧缓冲内存区，可以定位到屏幕缓冲区具体为每个显示像素的位置，通过读函数调用读取对应的位置数据在帧缓冲内存中，相反写操作对应于内存的写入数据可以显示内容写到屏幕上。</p><h3 id=解除帧缓冲映射>解除帧缓冲映射<a hidden class=anchor aria-hidden=true href=#解除帧缓冲映射>#</a></h3><p>在绘图完成后，帧缓冲文件描述符必须被释放之前，解除帧缓冲区的地址映射，使用 Linux 系统调用完成<code>mmap</code>函数的逆函数实现，即是<code>munmap</code>，函数的原型如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=nf>munmap</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>__addr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>__len</span><span class=p>)</span> <span class=n>__THROW</span><span class=p>;</span>
</span></span></code></pre></div><p><code>addr</code>参数应该与调用<code>MMAP</code>时指定的参数值一致， <code>len</code>参数也应该与之前调用<code>MMAP</code>时指定的<code>len</code>参数保持一致。</p><p><code>mmap</code>调用返回<code>0</code>成功，失败则返回<code>1</code>，同时将全局变量<code>erno</code>设置为指示失败的原因。</p><h3 id=调用close关闭设备>调用<code>close</code>关闭设备<a hidden class=anchor aria-hidden=true href=#调用close关闭设备>#</a></h3><p>使用帧缓冲设备后，应关闭相应的文件描述符，使用 Linux 系统标准的函数完成关闭功能，<code>close</code>函数的原型如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=nf>close</span> <span class=p>(</span><span class=kt>int</span> <span class=n>__fd</span><span class=p>);</span>
</span></span></code></pre></div><p><code>close</code>的参数和在开始调用<code>open</code>时指定的参数一致，文件描述符释放后可以重用，结束调用成功返回<code>0</code>，失败返回<code>1</code>。</p><h2 id=帧缓冲实例>帧缓冲实例<a hidden class=anchor aria-hidden=true href=#帧缓冲实例>#</a></h2><p>以下代码摘自<a href=https://github.com/xianjimli/linux-framebuffer-tools>xianjimli/linux-framebuffer-tools: linux framebuffer tool</a>，演示了帧缓冲设备的使用流程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>fb_info_t</span> <span class=o>*</span><span class=nf>linux_fb_open</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span>                 <span class=n>size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>fb_info_t</span>               <span class=o>*</span><span class=n>fb</span>   <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>fb_fix_screeninfo</span> <span class=n>fix</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>fb_var_screeninfo</span> <span class=n>var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>return_value_if_fail</span><span class=p>(</span><span class=n>filename</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fb</span> <span class=o>=</span> <span class=p>(</span><span class=kt>fb_info_t</span> <span class=o>*</span><span class=p>)</span><span class=nf>calloc</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>fb_info_t</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>return_value_if_fail</span><span class=p>(</span><span class=n>fb</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 打开帧缓冲设备，O_RDWR 读写模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fb</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fb</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>log_debug</span><span class=p>(</span><span class=s>&#34;open %s failed(%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>,</span> <span class=n>errno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>fb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 通过系统调用 ioctl 函数获得帧设备相关信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// FBIOGET_FSCREENINFO 命令字返回与 Framebuffer 有关的固定的信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>ioctl</span><span class=p>(</span><span class=n>fb</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>FBIOGET_FSCREENINFO</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fix</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>fail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//命令字返回与 Framebuffer 有关的可变的信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>ioctl</span><span class=p>(</span><span class=n>fb</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>FBIOGET_VSCREENINFO</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>var</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>fail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>var</span><span class=p>.</span><span class=n>xoffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span><span class=p>.</span><span class=n>yoffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 显示
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ioctl</span><span class=p>(</span><span class=n>fb</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>FBIOPAN_DISPLAY</span><span class=p>,</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>var</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>log_debug</span><span class=p>(</span><span class=s>&#34;fb_info_t: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>log_debug</span><span class=p>(</span><span class=s>&#34;fb_info_t: xres=%d yres=%d bits_per_pixel=%d mem_size=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>var</span><span class=p>.</span><span class=n>xres</span><span class=p>,</span> <span class=n>var</span><span class=p>.</span><span class=n>yres</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=n>var</span><span class=p>.</span><span class=n>bits_per_pixel</span><span class=p>,</span> <span class=nf>fb_size</span><span class=p>(</span><span class=n>fb</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>log_debug</span><span class=p>(</span><span class=s>&#34;fb_info_t: red(%d %d) green(%d %d) blue(%d %d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>var</span><span class=p>.</span><span class=n>red</span><span class=p>.</span><span class=n>offset</span><span class=p>,</span> <span class=n>var</span><span class=p>.</span><span class=n>red</span><span class=p>.</span><span class=n>length</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=n>var</span><span class=p>.</span><span class=n>green</span><span class=p>.</span><span class=n>offset</span><span class=p>,</span> <span class=n>var</span><span class=p>.</span><span class=n>green</span><span class=p>.</span><span class=n>length</span><span class=p>,</span> <span class=n>var</span><span class=p>.</span><span class=n>blue</span><span class=p>.</span><span class=n>offset</span><span class=p>,</span> <span class=n>var</span><span class=p>.</span><span class=n>blue</span><span class=p>.</span><span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fb</span><span class=o>-&gt;</span><span class=n>w</span>           <span class=o>=</span> <span class=n>var</span><span class=p>.</span><span class=n>xres</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>fb</span><span class=o>-&gt;</span><span class=n>h</span>           <span class=o>=</span> <span class=n>var</span><span class=p>.</span><span class=n>yres</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>fb</span><span class=o>-&gt;</span><span class=n>bpp</span>         <span class=o>=</span> <span class=n>var</span><span class=p>.</span><span class=n>bits_per_pixel</span> <span class=o>/</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>fb</span><span class=o>-&gt;</span><span class=n>line_length</span> <span class=o>=</span> <span class=n>fix</span><span class=p>.</span><span class=n>line_length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size</span> <span class=o>=</span> <span class=nf>fb_size</span><span class=p>(</span><span class=n>fb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 帧缓冲映射
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// PROT_READ | PROT_WRITE:可读写
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// MAP_SHARED：内存的修改保存到一个文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fb</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span><span class=nf>mmap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>fb</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fb</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>==</span> <span class=n>MAP_FAILED</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>log_debug</span><span class=p>(</span><span class=s>&#34;map framebuffer failed.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>fail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>log_debug</span><span class=p>(</span><span class=s>&#34;line_length=%d mem_size=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fix</span><span class=p>.</span><span class=n>line_length</span><span class=p>,</span> <span class=nf>fb_size</span><span class=p>(</span><span class=n>fb</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>log_debug</span><span class=p>(</span><span class=s>&#34;xres_virtual =%d yres_virtual=%d xpanstep=%d ywrapstep=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>var</span><span class=p>.</span><span class=n>xres_virtual</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=n>var</span><span class=p>.</span><span class=n>yres_virtual</span><span class=p>,</span> <span class=n>fix</span><span class=p>.</span><span class=n>xpanstep</span><span class=p>,</span> <span class=n>fix</span><span class=p>.</span><span class=n>ywrapstep</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fb</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>fail</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>log_debug</span><span class=p>(</span><span class=s>&#34;%s is not a framebuffer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>fb</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>fb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>感兴趣可以下载源码编译运行，其中<code>/bin/fbshow</code>可以使用帧缓冲设备显示图片。图形界面下直接运行可能提示无法运行，需要<code>Chrtl+Alt+F1</code>切换到控制台模式。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220120202118.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220120202118.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h2 id=lcd-与-framebuffer-的关系>LCD 与 Framebuffer 的关系<a hidden class=anchor aria-hidden=true href=#lcd-与-framebuffer-的关系>#</a></h2><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225141549.jpg><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225141549.jpg alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>LCD 控制器首先通过 VDEN 信号，使能。接下来根据 VCLK 时钟信号，在像素点上“喷涂”不同的颜色（打个比方），控制器有 VD（video data）信号，传送不同颜色信息。每来一个时钟信号，就向右移动一个像素，根据行同步信号 HSYNC，就从最右边移动到最左边。当移动到右下角时根据垂直同步信号 VSYNC。</p><p>那么问题来了，不同颜色的信息从哪里来？就是从上文介绍的 Framebuffer 中来的。</p><p>很多人都会说操纵 LCD 显示就是操纵 FrameBuffer，表面上来看是这样的。实际上是 FrameBuffer 就是 Linux 内核驱动申请的一片内存空间，然后 LCD 内有一片 sram，CPU 内部有个 LCD 控制器，它有个单独的 dma 用来将 FrameBuffer 中的数据拷贝到 LCD 的 sram 中去 拷贝到 LCD 的 sram 中的数据就会显示在 LCD 上，LCD 驱动和 FrameBuffer 驱动没有必然的联系，它只是驱动 LCD 正常工作的，比如有信号传过来，那么 LCD 驱动负责把信号转成显示屏上的内容，至于什么内容这就是应用层要处理的。</p><blockquote><p>静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。
DMA（Direct Memory Access），直接内存访问。使用 DMA 的好处就是它不需要 CPU 的干预而直接服务外设，这样 CPU 就可以去处理别的事务，从而提高系统的效率。</p></blockquote><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><p><a href=https://carlyleliu.github.io/2021/Linux%E9%A9%B1%E5%8A%A8%E4%B9%8BFramebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/>Linux 驱动之 Framebuffer 子系统 | 量子范式</a>
<a href=https://www.codenong.com/cs106598190/>Linux 驱动开发（9）——- framebuffer 驱动详解 | 码农家园</a>
<a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201502&amp;filename=1015587486.nh&amp;uniplatform=NZKPT&amp;v=KNvhApgKTzqH-mWxqP6f8BkbDR9mSjPHz8PfaxqDg2f1j30XqnHzSDsvwoqz-CbX">嵌入式系统中帧缓冲显示模块的设计与实现 - 中国知网</a>
<a href=https://github.com/tsuibin/research/tree/master/framebuffer/fivechess/fivechess-0.1>research/framebuffer/fivechess/fivechess-0.1 at master · tsuibin/research</a>
<a href=https://www.shangmayuan.com/a/f67d260756ce42258a9ed4ef.html>五子棋 framebuffer 版 - 尚码园</a>
<a href=https://blog.csdn.net/yangwen123/article/details/12096483>FrameBuffer 驱动程序分析_深入剖析 Android 系统-CSDN 博客_framebuffer</a>
<a href=https://github.com/xianjimli/linux-framebuffer-tools>xianjimli/linux-framebuffer-tools: linux framebuffer tool</a>
<a href="https://www.bilibili.com/video/BV1HW411L76t?p=2">韦东山_嵌入式 Linux_第 2 期_Linux 高级驱动视频教程_免费试看版_哔哩哔哩_bilibili</a>
<a href=https://zhuanlan.zhihu.com/p/356443723>Linux LCD Frambuffer 基础介绍和使用（1） - 知乎</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://lifeislife.cn/tags/linux/>Linux</a></li><li><a href=https://lifeislife.cn/tags/framebuffer/>FrameBuffer</a></li><li><a href=https://lifeislife.cn/tags/lcd/>LCD</a></li></ul><nav class=paginav><a class=prev href=https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8/><span class=title>« 上一页</span><br><span>解决 VSCode 配置远程连接，过程试图写入的管道不存在</span>
</a><a class=next href=https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3git-ssh-permission-deniedpublickey/><span class=title>下一页 »</span><br><span>解决 ssh permission denied(publickey)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux 帧缓冲 on x" href="https://x.com/intent/tweet/?text=Linux%20%e5%b8%a7%e7%bc%93%e5%86%b2&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2flinux%25E5%25B8%25A7%25E7%25BC%2593%25E5%2586%25B2%2f&amp;hashtags=Linux%2cFrameBuffer%2cLCD"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux 帧缓冲 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2flinux%25E5%25B8%25A7%25E7%25BC%2593%25E5%2586%25B2%2f&amp;title=Linux%20%e5%b8%a7%e7%bc%93%e5%86%b2&amp;summary=Linux%20%e5%b8%a7%e7%bc%93%e5%86%b2&amp;source=https%3a%2f%2flifeislife.cn%2fposts%2flinux%25E5%25B8%25A7%25E7%25BC%2593%25E5%2586%25B2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux 帧缓冲 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifeislife.cn%2fposts%2flinux%25E5%25B8%25A7%25E7%25BC%2593%25E5%2586%25B2%2f&title=Linux%20%e5%b8%a7%e7%bc%93%e5%86%b2"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux 帧缓冲 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifeislife.cn%2fposts%2flinux%25E5%25B8%25A7%25E7%25BC%2593%25E5%2586%25B2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux 帧缓冲 on whatsapp" href="https://api.whatsapp.com/send?text=Linux%20%e5%b8%a7%e7%bc%93%e5%86%b2%20-%20https%3a%2f%2flifeislife.cn%2fposts%2flinux%25E5%25B8%25A7%25E7%25BC%2593%25E5%2586%25B2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux 帧缓冲 on telegram" href="https://telegram.me/share/url?text=Linux%20%e5%b8%a7%e7%bc%93%e5%86%b2&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2flinux%25E5%25B8%25A7%25E7%25BC%2593%25E5%2586%25B2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux 帧缓冲 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Linux%20%e5%b8%a7%e7%bc%93%e5%86%b2&u=https%3a%2f%2flifeislife.cn%2fposts%2flinux%25E5%25B8%25A7%25E7%25BC%2593%25E5%2586%25B2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://lifeislife-1.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://lifeislife.cn/>夜云泊</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>