<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QEMU 源码分析-内存虚拟化 | 夜云泊</title>
<meta name=keywords content="QEMU,Linux"><meta name=description content="1.大部分转载自QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北 2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改 3.部分内容根"><meta name=author content="Nic"><link rel=canonical href=https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/><link crossorigin=anonymous href=/assets/css/stylesheet.4490366ee59f83f7324bce1d2f81fb1ebba1a551f24577c75929014495a1d9b1.css integrity="sha256-RJA2buWfg/cyS84dL4H7HruhpVHyRXfHWSkBRJWh2bE=" rel="preload stylesheet" as=style><link rel=icon href=https://lifeislife.cn/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lifeislife.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lifeislife.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://lifeislife.cn/apple-touch-icon.png><link rel=mask-icon href=https://lifeislife.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-PS8L2EEEPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PS8L2EEEPR")}</script><meta property="og:title" content="QEMU 源码分析-内存虚拟化"><meta property="og:description" content="1.大部分转载自QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北 2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改 3.部分内容根"><meta property="og:type" content="article"><meta property="og:url" content="https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-25T13:42:11+00:00"><meta property="article:modified_time" content="2022-01-25T13:42:11+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="QEMU 源码分析-内存虚拟化"><meta name=twitter:description content="1.大部分转载自QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北 2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改 3.部分内容根"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifeislife.cn/posts/"},{"@type":"ListItem","position":2,"name":"QEMU 源码分析-内存虚拟化","item":"https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"QEMU 源码分析-内存虚拟化","name":"QEMU 源码分析-内存虚拟化","description":"1.大部分转载自QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北 2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改 3.部分内容根","keywords":["QEMU","Linux"],"articleBody":" 1.大部分转载自QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北 2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改 3.部分内容根据自己理解补充添加\n概述 我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：\n虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间； 虚拟机里面的物理内存（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存； 物理机的虚拟内存（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间； 物理机的物理内存（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。 内存虚拟化的关键在于维护 GPA 到 HVA 的映射关系。\n页面分配和映射的两种方式 要搞清楚 QEMU system emulation 的仿真架构，首先对于 Host OS，将 QEMU 作为进程启动，然后对于 QEMU 进程，会仿真各种硬件和运行 Guest OS，在这层 OS 上运行要全系统模拟的应用程序，因此对于 Guest OS 管理的内存要实现到 QEMU 进程的虚拟空间的转换需要 softMMU（即需要对 GPA 到 HVA 进行转换）。从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。\n影子页表 Shadow Page Table，SPT 第一种方式就是软件的方式，影子页表（Shadow Page Table）。\nKVM 通过维护记录 GVA-\u003eHPA 的影子页表 SPT，减少了地址转换带来的开销，可以直接将 GVA 转换为 HPA。\n内存映射要通过页表来管理，页表地址应该放在 CR3 寄存器里面。在软件虚拟化的内存转换中，GVA 到 GPA 的转换通过查询 CR3 寄存器来完成，CR3 中保存了 Guest 的页表基地址，然后载入 MMU 中进行地址转换。\n在加入了 SPT 技术后，当 Guest 访问 CR3 时，KVM 会捕获到这个操作 EXIT_REASON_CR_ACCESS，之后 KVM 会载入特殊的 CR3 和影子页表，欺骗 Guest 这就是真实的 CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。\n本来的过程是，客户机要通过 cr3 找到客户机的页表，实现从 GVA 到 GPA 的转换，然后在宿主机上，要通过 cr3 找到宿主机的页表，实现从 HVA 到 HPA 的转换。 为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。 在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。\n\u003c!DOCTYPE html\u003e Responsive Image 为了快速检索 Guest 页表对应的影子页表，KVM 为每个客户机维护了一个 hash 表来进行客户机页表到影子页表之间的映射。对于每一个 Guest 来说，其页目录和页表都有唯一的 GPA，通过页目录/页表的 GPA 就可以在哈希链表中快速地找到对应的影子页目录/页表。\n当 Guest 切换进程时，Guest 会把待切换进程的页表基址载入 CR3，而 KVM 将会截获这一特权指令。KVM 在哈希表中找到与此页表基址对应的影子页表基址，载入 Guest CR3，使 Guest 在恢复运行时 CR3 实际指向的是新切换进程对应的影子页表。\n影子页表的引入，减少了 GVA-\u003eHPA 的转换开销，但是缺点在于需要为 Guest 的每个进程都维护一个影子页表，这将带来很大的内存开销。同时影子页表的建立是很耗时的，如果 Guest 的进程过多，将导致影子页表频繁切换。\n因此 Intel 和 AMD 在此基础上提供了基于硬件的虚拟化技术 EPT。\n扩展页表 Extent Page Table，EPT Intel 的 EPT（Extent Page Table）技术和 AMD 的 NPT（Nest Page Table）技术都对内存虚拟化提供了硬件支持。这两种技术原理类似，都是在硬件层面上实现 GVA 到 HPA 之间的转换。下面就以 EPT 为例分析一下 KVM 基于硬件辅助的内存虚拟化实现。\nEPT 在原有客户机页表对客户机虚拟地址 GVA 到客户机物理地址 GPA 映射的基础上，又引入了 EPT 页表来实现客户机物理地址 GPA 到宿主机物理地址 HPA 的另一次映射。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。\n即 EPT 技术采用了在两级页表结构，即原有 Guest OS 页表对 GVA-\u003eGPA 映射的基础上，又引入了 EPT 页表来实现 GPA-\u003eHPA 的另一次映射，这两次地址映射都是由硬件自动完成。\n有了 EPT，在GPA-\u003eHPA转换的过程中，缺页会产生 EPT 缺页异常。KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。\nKVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。\n这里，我们重点看第二种方式。因为使用了 EPT 之后，客户机里面的页表映射，也即从 GVA 到 GPA 的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而 EPT 重点帮我们解决的就是从 GPA 到 HPA 的转换问题。因为要经过两次页表，所以 EPT 又 tdp(two dimentional paging)。\nEPT 的页表结构也是分为四层，EPT Pointer（EPTP）指向 PML4 的首地址。\n\u003c!DOCTYPE html\u003e Responsive Image QEMU 的主要工作 内存虚拟化的目的就是让虚拟机能够无缝的访问内存。有了 Intel EPT 的支持后，CPU 在 VMX non-root 状态时进行内存访问会再做一次 EPT 转换。在这个过程中，QEMU 会负责以下内容：\n首先需要从自己的进程地址空间中申请内存用于 Guest 需要将上一步中申请到的内存的虚拟地址（HVA）和 Guest 的物理地址之间的映射关系传递给 KVM（kernel），即 GPA-\u003eHVA 需要组织一系列的数据结构来管理虚拟内存空间，并在内存拓扑结构更改时将最新的内存信息同步至 KVM 中\nQEMU 和 KVM 的工作分界 QEMU 和 KVM 之间是通过 KVM 提供的 ioctl() 接口进行交互的。在内核的 kvm_vm_ioctl() 中，设置虚拟机内存的系统调用【kernel 就是一系列系统调用函数接口和处理逻辑，其中有个处理”创建/设置虚拟机内存“的系统调用接口】为 VM_SET_USER_MEMORY_REGION：\nstatic long kvm_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg) { /* ... */ case KVM_SET_USER_MEMORY_REGION: { // 在 KVM 中注册用户空间传入的内存信息 struct kvm_userspace_memory_region kvm_userspace_mem; r = -EFAULT; // 将传入的数据结构复制到内核空间 if (copy_from_user(\u0026kvm_userspace_mem, argp, sizeof kvm_userspace_mem)) goto out; // 实际进行处理的函数 r = kvm_vm_ioctl_set_memory_region(kvm, \u0026kvm_userspace_mem, 1); if (r) goto out; break; } /* ... */ } 可以看到这里需要传递的参数类型为 kvm_userspace_memory_region：\n/* for KVM_SET_USER_MEMORY_REGION */ struct kvm_userspace_memory_region { __u32 slot; // slot 编号 [参考：https://www.cnblogs.com/LoyenWang/p/11922887.html] __u32 flags; // 标志位，例如是否追踪脏页、是否可用等 __u64 guest_phys_addr; // Guest 物理地址，即 GPA __u64 memory_size; // 内存大小，单位 bytes __u64 userspace_addr; // 从 QEMU 进程地址空间中分配内存的起始地址，即 HVA }; KVM_SET_USER_MEMORY_REGION这个 ioctl 主要目的就是设置GPA-\u003eHVA的映射关系，KVM 会继续调用kvm_vm_ioctl_set_memory_region()，在内核空间维护并管理 Guest 的内存。\n相关数据结构 AddressSpace 结构体定义 QEMU 用 AddressSpace 结构体表示 Guest 中 CPU/设备看到的内存【也就是Guest OS 可以在 QEMU 进程虚存中用到的所有内存，是 MemoryRegion 的集合，即 GPA 的整体】，类似于物理机中地址空间的概念，但在这里表示的是 Guest 的一段地址空间，如内存地址空间 address_space_memory 、I/O 地址空间address_space_io，它在 QEMU 源码memory.c中定义：\n/** * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects */ struct AddressSpace { /* private: */ struct rcu_head rcu; char *name; MemoryRegion *root; /* Accessed via RCU. */ struct FlatView *current_map; int ioeventfd_nb; struct MemoryRegionIoeventfd *ioeventfds; QTAILQ_HEAD(, MemoryListener) listeners; QTAILQ_ENTRY(AddressSpace) address_spaces_link; }; 每个 AddressSpace 一般包含一系列的 MemoryRegion：root指针指向根级 MemoryRegion，而 root 可能有自己的若干个 sub-regions（子节点），于是形成树状结构。这些 MemoryRegion 通过树连接起来，树的根即为 AddressSpace 的 root 域。\n全局变量 另外，QEMU 中有两个全局的静态 AddressSpace，在 memory.c 中定义：\nstatic AddressSpace address_space_memory; // 内存地址空间 static AddressSpace address_space_io; // I/O 地址空间 其 root 域分别指向之后会提到的两个 MemoryRegion 类型变量：system_memory、system_io。\nMemoryRegion 结构体定义 MemoryRegion 表示在 Guest Memory Layout 中的一段内存区域【也就是单元级 GPA 的概念，Guest OS 可以管理到的那些 Guest 物理内存单元】，它是联系 GPA 和 RAMBlocks（描述真实内存）之间的桥梁，在memory.h中定义：\nstruct MemoryRegion { /* All fields are private - violators will be prosecuted */ const MemoryRegionOps *ops; // 回调函数集合 void *opaque; MemoryRegion *parent; // 父 MemoryRegion 指针 Int128 size; // 该区域内存的大小 target_phys_addr_t addr; // 在 Address Space 中的地址，即 HVA void (*destructor)(MemoryRegion *mr); ram_addr_t ram_addr; // MemoryRegion 的起始地址，即 GPA bool subpage; bool terminates; bool readable; bool ram; // 是否表示 RAM bool readonly; /* For RAM regions */ bool enabled; // 是否已经通知 KVM 使用这段内存 bool rom_device; bool warning_printed; /* For reservations */ MemoryRegion *alias; // 是否为 MemoryRegion alias target_phys_addr_t alias_offset; // 若为 alias，在原 MemoryRegion 中的 offset unsigned priority; bool may_overlap; QTAILQ_HEAD(subregions, MemoryRegion) subregions; // 子区域链表头 QTAILQ_ENTRY(MemoryRegion) subregions_link; // 子区域链表节点 QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced; const char *name; // MemoryRegion 的名字，调试时使用 uint8_t dirty_log_mask; // 表示哪一种 dirty map 被使用，共分三种 unsigned ioeventfd_nb; MemoryRegionIoeventfd *ioeventfds; }; 全局变量 在 QEMU 的 exec.c 中也定义了两个静态的 MemoryRegion 指针变量：\nstatic MemoryRegion *system_memory; // 内存 MemoryRegion，对应 address_space_memory static MemoryRegion *system_io; // I/O MemoryRegion，对应 address_space_io 与两个全局 AddressSpace 对应，即 AddressSpace 的 root 域指向这两个 MemoryRegion。\nMemoryRegion 的类型 MemoryRegion 有多种类型，可以表示一段 RAM、ROM、MMIO、alias(别名)。\n若为 alias 则表示一个 MemoryRegion 的部分区域，例如，QEMU 会为 pc.ram 这个表示 RAM 的 MemoryRegion 添加两个 alias：ram-below-4g 和 ram-above-4g，之后会看到具体的代码实例。\n另外，MemoryRegion 也可以表示一个 container，这就表示它只是其他若干个 MemoryRegion 的容器。\n那么要如何创建不同类型的 MemoryRegion 呢？\n在 QEMU 中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将 MemoryRegion 划分为以下三种类型：\n根级 MemoryRegion：直接通过 memory_region_init 初始化，没有自己的内存，用于管理 subregion，例如 system_memory： void memory_region_init(MemoryRegion *mr, const char *name, uint64_t size) { mr-\u003eops = NULL; mr-\u003eparent = NULL; mr-\u003esize = int128_make64(size); if (size == UINT64_MAX) { mr-\u003esize = int128_2_64(); } mr-\u003eaddr = 0; mr-\u003esubpage = false; mr-\u003eenabled = true; mr-\u003eterminates = false; // 非实体 MemoryRegion，搜索时会继续前往其 subregions mr-\u003eram = false; // 根级 MemoryRegion 不分配内存 mr-\u003ereadable = true; mr-\u003ereadonly = false; mr-\u003erom_device = false; mr-\u003edestructor = memory_region_destructor_none; mr-\u003epriority = 0; mr-\u003emay_overlap = false; mr-\u003ealias = NULL; QTAILQ_INIT(\u0026mr-\u003esubregions); memset(\u0026mr-\u003esubregions_link, 0, sizeof mr-\u003esubregions_link); QTAILQ_INIT(\u0026mr-\u003ecoalesced); mr-\u003ename = g_strdup(name); mr-\u003edirty_log_mask = 0; mr-\u003eioeventfd_nb = 0; mr-\u003eioeventfds = NULL; } 可以看到 mr-\u003eaddr 被设置为 0，而 mr-\u003eram_addr 则并没有初始化。\n实体 MemoryRegion：通过memory_region_init_ram()初始化，有自己的内存（从 QEMU 进程地址空间中分配），大小为size，例如ram_memory、 pci_memory： void *pc_memory_init(MemoryRegion *system_memory, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, ram_addr_t below_4g_mem_size, ram_addr_t above_4g_mem_size, MemoryRegion *rom_memory, MemoryRegion **ram_memory) { MemoryRegion *ram, *option_rom_mr; /* ...*/ /* Allocate RAM. We allocate it as a single memory region and use * aliases to address portions of it, mostly for backwards compatibility * with older qemus that used qemu_ram_alloc(). */ ram = g_malloc(sizeof(*ram)); // 调用 memory_region_init_ram 对 ram_memory 进行初始化 memory_region_init_ram(ram, \"pc.ram\", below_4g_mem_size + above_4g_mem_size); vmstate_register_ram_global(ram); *ram_memory = ram; /* ... */ } void memory_region_init_ram(MemoryRegion *mr, const char *name, uint64_t size) { memory_region_init(mr, name, size); mr-\u003eram = true; mr-\u003eterminates = true; mr-\u003edestructor = memory_region_destructor_ram; mr-\u003eram_addr = qemu_ram_alloc(size, mr); } 可以看到这里是先调用了memory_region_init()，之后设置 RAM 属性，并继续调用qemu_ram_alloc()分配内存。\n别名 MemoryRegion：通过memory_region_init_alias() 初始化，没有自己的内存，表示实体 MemoryRegion 的一部分。通过 alias 成员指向实体 MemoryRegion，alias_offset为在实体 MemoryRegion 中的偏移量，例如ram_below_4g、ram_above_4g： void *pc_memory_init(MemoryRegion *system_memory, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, ram_addr_t below_4g_mem_size, ram_addr_t above_4g_mem_size, MemoryRegion *rom_memory, MemoryRegion **ram_memory) { MemoryRegion *ram_below_4g, *ram_above_4g; /* ... */ ram_below_4g = g_malloc(sizeof(*ram_below_4g)); // 调用 memory_region_init_alias 对 ram_below_4g 进行初始化 memory_region_init_alias(ram_below_4g, \"ram-below-4g\", ram, 0, below_4g_mem_size); /* .. void memory_region_init_alias(MemoryRegion *mr, const char *name, MemoryRegion *orig, target_phys_addr_t offset, uint64_t size) { memory_region_init(mr, name, size); mr-\u003ealias = orig; // 指向实体 MemoryRegion mr-\u003ealias_offset = offset; //通过 offset 得到实体的某一个部分 } RAMBlock 结构体定义 MemoryRegion 用来描述一段逻辑层面上的内存区域，而记录实际分配的内存地址信息的结构体则是 RAMBlock，在ramblock.h中定义：\nstruct RAMBlock { struct rcu_head rcu; struct MemoryRegion *mr; uint8_t *host; uint8_t *colo_cache; /* For colo, VM's ram cache */ ram_addr_t offset; ram_addr_t used_length; ram_addr_t max_length; void (*resized)(const char*, uint64_t length, void *host); uint32_t flags; /* Protected by iothread lock. */ char idstr[256]; /* RCU-enabled, writes protected by the ramlist lock */ QLIST_ENTRY(RAMBlock) next; QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers; int fd; size_t page_size; /* dirty bitmap used during migration */ unsigned long *bmap; /* bitmap of already received pages in postcopy */ unsigned long *receivedmap; /* * bitmap to track already cleared dirty bitmap. When the bit is * set, it means the corresponding memory chunk needs a log-clear. * Set this up to non-NULL to enable the capability to postpone * and split clearing of dirty bitmap on the remote node (e.g., * KVM). The bitmap will be set only when doing global sync. * * NOTE: this bitmap is different comparing to the other bitmaps * in that one bit can represent multiple guest pages (which is * decided by the `clear_bmap_shift' variable below). On * destination side, this should always be NULL, and the variable * `clear_bmap_shift' is meaningless. */ unsigned long *clear_bmap; uint8_t clear_bmap_shift; /* * RAM block length that corresponds to the used_length on the migration * source (after RAM block sizes were synchronized). Especially, after * starting to run the guest, used_length and postcopy_length can differ. * Used to register/unregister uffd handlers and as the size of the received * bitmap. Receiving any page beyond this length will bail out, as it * could not have been valid on the source. */ ram_addr_t postcopy_length; }; 可以看到在 RAMBlock 中 host 和 offset 域分别对应了 HVA 和GPA，因此也可以说 RAMBlock 中存储了GPA-\u003eHVA的映射关系，另外每一个 RAMBlock 都会指向其所属的 MemoryRegion。\n全局变量 ram_list QEMU 在ramlist.h中定义了一个全局变量ram_list，以链表的形式维护了所有的 RAMBlock：\ntypedef struct RAMList { QemuMutex mutex; RAMBlock *mru_block; /* RCU-enabled, writes protected by the ramlist lock. */ QLIST_HEAD(, RAMBlock) blocks; DirtyMemoryBlocks *dirty_memory[DIRTY_MEMORY_NUM]; uint32_t version; QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers; } RAMList; extern RAMList ram_list; 每一个新分配的 RAMBlock 都会被插入到ram_list的头部。如需查找地址所对应的 RAMBlock，则需要遍历ram_list，当目标地址落在当前RAMBlock的地址区间时，该 RAMBlock 即为查找目标。\nAS、MR、RAMBlock 之间的关系 \u003c!DOCTYPE html\u003e Responsive Image FlatView AddressSpace 的 root 域及其子树共同构成了 Guest 的物理地址空间，但这些都是在 QEMU 侧定义的。要传入 KVM 进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其转换为一个“平坦”的地址模型，也就是一个从零开始、只包含地址信息的数据结构，这在 QEMU 中通过 FlatView 来表示。每个 AddressSpace 都有一个与之对应的 FlatView 指针 current_map，表示其对应的平面展开视图。\n结构体定义 FlatView 在memory.c中定义：\n/* Flattened global view of current active memory hierarchy. Kept in sorted * order. */ struct FlatView { struct rcu_head rcu; unsigned ref; FlatRange *ranges; // 对应的 FlatRange 数组 unsigned nr; // FlatRange 的数目 unsigned nr_allocated; // 当前数组的项数 struct AddressSpaceDispatch *dispatch; MemoryRegion *root; }; 其中，ranges是一个数组，记录了 FlatView 下所有的 FlatRange。\nFlatRange 在 FlatView 中，FlatRange 表示在 FlatView 中的一段内存范围，同样在memory.c中定义：\n/* Range of memory in the global map. Addresses are absolute. */ struct FlatRange { MemoryRegion *mr; // 指向所属的 MemoryRegion hwaddr offset_in_region; // 在全局 MemoryRegion 中的 offset，对应 GPA AddrRange addr; // 代表的地址区间，对应 HVA uint8_t dirty_log_mask; bool romd_mode; bool readonly; bool nonvolatile; }; 每个 FlatRange 对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中，具体的地址范围由一个 AddrRange 结构来描述：\n/* * AddrRange 用于表示 FlatRange 的起始地址及大小 */ struct AddrRange { Int128 start; Int128 size; }; MemoryRegionSection 结构体定义 在 QEMU 中，还有几个起到中介作用的结构体，MemoryRegionSection 就是其中之一。\n之前介绍的 FlatRange 代表一个物理地址空间的片段，偏向于描述在 Host 侧即 AddressSpace 中的分布【Guest 的物理空间】，而 MemoryRegionSection 则代表在 Guest 侧即 MemoryRegion 中的片段。MemoryRegionSection 在memory.h中定义：\n/** * MemoryRegionSection: describes a fragment of a #MemoryRegion * * @mr: the region, or %NULL if empty * @address_space: the address space the region is mapped in * @offset_within_region: the beginning of the section, relative to @mr's start * @size: the size of the section; will not exceed @mr's boundaries * @offset_within_address_space: the address of the first byte of the section * relative to the region's address space * @readonly: writes to this section are ignored */ //只是起到描述的作用，描述了是哪个 AddressSpace 的 MemoryRegion， //并且在 MemoryRegion 中的 offset，和在 AddressSpace 展开为平坦内存的 offset struct MemoryRegionSection { MemoryRegion *mr; // 所属的 MemoryRegion MemoryRegion *address_space; // 关联的 AddressSpace target_phys_addr_t offset_within_region; // 在 MemoryRegion 内部的 offset uint64_t size; // Section 的大小 target_phys_addr_t offset_within_address_space; // 在 AddressSpace 内部的 offset bool readonly; // 是否为只读 }; offset_within_region：在所属 MemoryRegion 中的offset。一个AddressSpace 可能由多个 MemoryRegion 组成，因此该 offset 是局部的 offset_within_address_space：在所属 AddressSpace 中的 offset，它是全局的 和其他数据结构之间的关系 \u003c!DOCTYPE html\u003e Responsive Image AddressSpace 的root指向对应的根级MemoryRegion，current_map指向AddressSpace 的root通过generate_memory_topology()生成的 FlatView FlatView 中的ranges数组表示该MemoryRegion 所表示的Guest地址区间【GPA 的整个平坦物理空间】，并按照地址的顺序进行排列 MemoryRegionSection 由ranges数组中的 FlatRange 对应生成，作为注册到 KVM中的基本单位 QEMU 在用户空间申请内存后，需要将内存信息通过一系列系统调用传入内核空间的 KVM，由 KVM 侧进行管理，因此 QEMU 侧也定义了一些用于向 KVM 传递参数的结构体。\n以下为KVM相关的数据结构。\nKVMSlot 在 kvm_init.h中定义，是 KVM 中内存管理的基本单位：\ntypedef struct KVMSlot { hwaddr start_addr; // Guest 物理地址，GPA ram_addr_t memory_size; // 内存大小 void *ram; // QEMU 用户空间地址，HVA int slot; // Slot 编号 int flags; // 标志位，例如是否追踪脏页、是否可用等 /* Dirty bitmap cache for the slot */ unsigned long *dirty_bmap; unsigned long dirty_bmap_size; /* Cache of the address space ID */ int as_id; /* Cache of the offset in ram address space */ ram_addr_t ram_start_offset; } KVMSlot; KVMSlot 类似于内存插槽的概念。\nkvm_userspace_memory_region 调用ioctl(KVM_SET_USER_MEMORY_REGION)时需要向 KVM 传递的参数，在kvm.h中定义\n/* for KVM_SET_USER_MEMORY_REGION */ struct kvm_userspace_memory_region { __u32 slot; // slot 编号 __u32 flags; // 标志位，例如是否追踪脏页、是否可用等 __u64 guest_phys_addr; // Guest 物理地址，GPA __u64 memory_size; // 内存大小，bytes __u64 userspace_addr; // 从 QEMU 进程空间分配的起始地址，HVA }; MemoryListener 结构体定义 为了监控虚拟机的物理地址访问，对于每一个 AddressSpace，都会有一个 MemoryListener 与之对应。每当物理映射GPA-\u003eHVA发生改变时，就会回调这些函数。MemoryListener 是对一些事件的回调函数合集，在memory.h中定义：\n/** * MemoryListener: callbacks structure for updates to the physical memory map * * Allows a component to adjust to changes in the guest-visible memory map. * Use with memory_listener_register() and memory_listener_unregister(). */ struct MemoryListener { void (*begin)(MemoryListener *listener); void (*commit)(MemoryListener *listener); void (*region_add)(MemoryListener *listener, MemoryRegionSection *section); void (*region_del)(MemoryListener *listener, MemoryRegionSection *section); void (*region_nop)(MemoryListener *listener, MemoryRegionSection *section); void (*log_start)(MemoryListener *listener, MemoryRegionSection *section); void (*log_stop)(MemoryListener *listener, MemoryRegionSection *section); void (*log_sync)(MemoryListener *listener, MemoryRegionSection *section); void (*log_global_start)(MemoryListener *listener); void (*log_global_stop)(MemoryListener *listener); void (*eventfd_add)(MemoryListener *listener, MemoryRegionSection *section, bool match_data, uint64_t data, EventNotifier *e); void (*eventfd_del)(MemoryListener *listener, MemoryRegionSection *section, bool match_data, uint64_t data, EventNotifier *e); /* Lower = earlier (during add), later (during del) */ unsigned priority; MemoryRegion *address_space_filter; QTAILQ_ENTRY(MemoryListener) link; }; 全局变量 memory_listeners 所有的 MemoryListener 都会挂在全局变量memory_listeners链表上，在memory.c中定义：\nstatic QTAILQ_HEAD(, MemoryListener) memory_listeners = QTAILQ_HEAD_INITIALIZER(memory_listeners); 在memory.c中枚举了ListenerDirection:\nenum ListenerDirection { Forward, Reverse }; 重要数据结构总览 结构体名 说明 AddressSpace VM 能看到的一段地址空间，偏向 Host 侧【注意指的是偏向】 MemoryRegion 地址空间中一段逻辑层面的内存区域，偏向 Guest 侧 RAMBlock 记录实际分配的内存地址信息，存储了 GPA-\u003eHVA 的映射关系 FlatView MemoryRegion 对应的平面展开视图，包含一个 FlatRange 类型的 ranges 数组 FlatRange 对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中 MemoryRegionSection 表示 MemoryRegion 中的片段 MemoryListener 回调函数集合 KVMSlot KVM 中内存管理的基本单位，表示一个内存插槽 kvm_userspace_memory_region 调用 ioctl(KVM_SET_USER_MEMORY_REGION) 时需要向 KVM 传递的参数 具体实现机制 QEMU 的内存申请流程大致可分为三个部分：回调函数的注册、AddressSpace 的初始化、实际内存的分配。下面将根据在 vl.c 的 main() 函数中的调用顺序分别介绍。\n回调函数的注册 \u003c!DOCTYPE html\u003e Responsive Image int main() └─ static int configure_accelerator() └─ int kvm_init() // 初始化 KVM ├─ int kvm_ioctl(KVM_CREATE_VM) // 创建 VM ├─ int kvm_arch_init() // 针对不同的架构进行初始化 └─ void memory_listener_register() // 注册 kvm_memory_listener └─ static void listener_add_address_space() // 调用 region_add 回调 └─ static void kvm_region_add() // region_add 对应的回调实现 └─ static void kvm_set_phys_mem() // 根据传入的 section 填充 KVMSlot └─ static int kvm_set_user_memory_region() └─ int ioctl(KVM_SET_USER_MEMORY_REGION) 进入configure_accelerator()后，QEMU会先调用configure_accelerator()设置 KVM 的加速支持，之后进入kvm_init()。该函数主要完成对 KVM 的初始化，包括一些常规检查如 CPU 个数、KVM 版本等，之后通过kvm_ioctl(KVM_CREATE_VM)与内核交互，创建 KVM 虚拟机。在kvm_init()的最后，会调用memory_listener_register()注册kvm_memory_listener：\nstatic int kvm_init(MachineState *ms) { MachineClass *mc = MACHINE_GET_CLASS(ms); // 打开/dev/kvm s-\u003efd = qemu_open_old(\"/dev/kvm\", O_RDWR); // 创建 VM do { ret = kvm_ioctl(s, KVM_CREATE_VM, type); } while (ret == -EINTR); /* ... */ ret = kvm_arch_init(s); // 针对不同的架构进行初始化 // 对于以下 AddressSpace，设置其对应的 listener kvm_memory_listener_register(s, \u0026s-\u003ememory_listener, \u0026address_space_memory, 0, \"kvm-memory\"); memory_listener_register(\u0026kvm_coalesced_pio_listener, \u0026address_space_io); /* ... */ } void memory_listener_register(MemoryListener *listener, AddressSpace *as) { MemoryListener *other = NULL; /* Only one of them can be defined for a listener */ assert(!(listener-\u003elog_sync \u0026\u0026 listener-\u003elog_sync_global)); listener-\u003eaddress_space = as; if (QTAILQ_EMPTY(\u0026memory_listeners) || listener-\u003epriority \u003e= QTAILQ_LAST(\u0026memory_listeners)-\u003epriority) { QTAILQ_INSERT_TAIL(\u0026memory_listeners, listener, link); } else { QTAILQ_FOREACH(other, \u0026memory_listeners, link) { if (listener-\u003epriority \u003c other-\u003epriority) { break; } } QTAILQ_INSERT_BEFORE(other, listener, link); } if (QTAILQ_EMPTY(\u0026as-\u003elisteners) || listener-\u003epriority \u003e= QTAILQ_LAST(\u0026as-\u003elisteners)-\u003epriority) { QTAILQ_INSERT_TAIL(\u0026as-\u003elisteners, listener, link_as); } else { QTAILQ_FOREACH(other, \u0026as-\u003elisteners, link_as) { if (listener-\u003epriority \u003c other-\u003epriority) { break; } } QTAILQ_INSERT_BEFORE(other, listener, link_as); } listener_add_address_space(listener, as); } 最后的listener_add_address_space()主要是将 listener 注册到其对应的 AddressSpace 上，并根据 AddressSpace 对应的 FlatRange 数组，生成 MemoryRegionSection【MemoryRegionSection就像是为FlatRange数组设置的一种中介表示，便于传入KVM，因为传入KVM应该是对平坦内存的一种表示】，并注册到 KVM 中：\nstatic void listener_add_address_space(MemoryListener *listener, AddressSpace *as) { FlatView *view; FlatRange *fr; if (listener-\u003ebegin) { listener-\u003ebegin(listener); } /* 开启内存脏页记录 */ if (global_dirty_tracking) { if (listener-\u003elog_global_start) { listener-\u003elog_global_start(listener); } } /* 遍历 AddressSpace 对应的 FlatRange 数组，并将其转换成 MemoryRegionSection */ view = address_space_get_flatview(as); FOR_EACH_FLAT_RANGE(fr, view) { MemoryRegionSection section = section_from_flat_range(fr, view); /* 将 section 所代表的内存区域注册到 KVM 中 */ if (listener-\u003eregion_add) { listener-\u003eregion_add(listener, \u0026section); } if (fr-\u003edirty_log_mask \u0026\u0026 listener-\u003elog_start) { listener-\u003elog_start(listener, \u0026section, 0, fr-\u003edirty_log_mask); } } if (listener-\u003ecommit) { listener-\u003ecommit(listener); } flatview_unref(view); } 由于此时 AddressSapce 尚未初始化，所以此处的循环为空，仅是在全局注册了kvm_memory_listener。最后调用了kvm_memory_listener-\u003eregion_add()，对应的实现是kvm_region_add()，该函数最终会通过ioctl(KVM_SET_USER_MEMORY_REGION)，将 QEMU 侧申请的内存信息传入 KVM 进行注册，这里的流程会在下一部分进行分析。\nAddressSpace 的初始化 \u003c!DOCTYPE html\u003e Responsive Image int main() └─ void cpu_exec_init_all() ├─ static void memory_map_init() | ├─ void memory_region_init() // 初始化 system_memory/io 这两个全局 MemoryRegion | ├─ void set_system_memory_map() // address_space_memory-\u003eroot = system_memory | | └─ static void memory_region_update_topology() // 为 MemoryRegion 生成 FlatView | | └─ static void address_space_update_topology() // as-\u003ecurrent_map = new_view | | └─ static void address_space_update_topology_pass() | | └─ static void kvm_region_add() // region_add 对应的回调实现 | | └─ static void kvm_set_phys_mem() // 根据传入的 section 填充 KVMSlot | | └─ static int kvm_set_user_memory_region() | | └─ int ioctl(KVM_SET_USER_MEMORY_REGION) | | | └─ void memory_listener_register() // 注册对应的 MemoryListener | └─ static void listener_add_address_space() | └─ static void io_mem_init() └─ void memory_region_init_io() // ram/rom/unassigned/notdirty/subpage-ram/watch └─ void memory_region_init() 第一部分在全局注册了kvm_memory_listener，但由于AddressSpace 尚未初始化，实际上并未向 KVM 中注册任何实际的内存信息。QEMU 在main()函数中会继续调用cpu_exec_init_all()对AddressSpace进行初始化，该函数实际上是对两个 init 函数的封装调用：\nvoid cpu_exec_init_all(void) { qemu_mutex_init(\u0026ram_list.mutex); /* The data structures we set up here depend on knowing the page size, * so no more changes can be made after this point. * In an ideal world, nothing we did before we had finished the * machine setup would care about the target page size, and we could * do this much later, rather than requiring board models to state * up front what their requirements are. */ finalize_target_page_bits(); io_mem_init(); // 初始化六个I/O MemoryRegion memory_map_init(); // 初始化两个全局 AddressSpace，以及对应的 MemoryRegion、FlatView qemu_mutex_init(\u0026map_client_list_lock); } 先来看memory_map_init()，主要用来初始化两个全局的系统地址空间system_memory、system_io\nstatic void memory_map_init(void) { system_memory = g_malloc(sizeof(*system_memory)); // 1. 初始化 system_memory memory_region_init(system_memory, NULL, \"system\", UINT64_MAX); // 2. 设置 address_space_memory 关联 system_memory // 这两个都是全局变量，也就是把内存地址空间和 IO 地址空间于对应的 MemoryRegion 联系起来 //及其对应的 FlatView address_space_init(\u0026address_space_memory, system_memory, \"memory\"); system_io = g_malloc(sizeof(*system_io)); // 1. 初始化 system_io memory_region_init_io(system_io, NULL, \u0026unassigned_io_ops, NULL, \"io\", 65536); // 2. 设置 address_space_io 关联 system_io // 及其对应的 FlatView address_space_init(\u0026address_space_io, system_io, \"I/O\"); } 这里比较重要的是address_space_init()，先设置 AddressSpace 对应的 MemoryRegion，之后根据system_memory更新address_space_memory对应的 FlatView：\nvoid address_space_init(AddressSpace *as, MemoryRegion *root, const char *name) { memory_region_ref(root); // 将 address_space_memory 的 root 域指向 system_memory as-\u003eroot = root; as-\u003ecurrent_map = NULL; as-\u003eioeventfd_nb = 0; as-\u003eioeventfds = NULL; QTAILQ_INIT(\u0026as-\u003elisteners); QTAILQ_INSERT_TAIL(\u0026address_spaces, as, address_spaces_link); as-\u003ename = g_strdup(name ? name : \"anonymous\"); // 根据 system_memory 更新 address_space_memory 对应的 FlatView address_space_update_topology(as); address_space_update_ioeventfds(as); } address_space_update_topology()会继续调用generate_memory_topology()生成 AddressSpace 对应的 FlatView视图：\nstatic void address_space_update_topology(AddressSpace *as) { MemoryRegion *physmr = memory_region_get_flatview_root(as-\u003eroot); flatviews_init(); if (!g_hash_table_lookup(flat_views, physmr)) { generate_memory_topology(physmr); } address_space_set_flatview(as); } address_space_update_topology()会先调用generate_memory_topology()生成system_memory更新后的视图new_view，再将address_space_memory的current_map指向这个new_view，最后销毁old_view：\nstatic void address_space_set_flatview(AddressSpace *as) { FlatView *old_view = address_space_to_flatview(as); MemoryRegion *physmr = memory_region_get_flatview_root(as-\u003eroot); FlatView *new_view = g_hash_table_lookup(flat_views, physmr); assert(new_view); if (old_view == new_view) { return; } if (old_view) { flatview_ref(old_view); } flatview_ref(new_view); if (!QTAILQ_EMPTY(\u0026as-\u003elisteners)) { FlatView tmpview = { .nr = 0 }, *old_view2 = old_view; if (!old_view2) { old_view2 = \u0026tmpview; } address_space_update_topology_pass(as, old_view2, new_view, false); address_space_update_topology_pass(as, old_view2, new_view, true); } /* Writes are protected by the BQL. */ qatomic_rcu_set(\u0026as-\u003ecurrent_map, new_view); if (old_view) { flatview_unref(old_view); } /* Note that all the old MemoryRegions are still alive up to this * point. This relieves most MemoryListeners from the need to * ref/unref the MemoryRegions they get---unless they use them * outside the iothread mutex, in which case precise reference * counting is necessary. */ if (old_view) { flatview_unref(old_view); } } 在address_space_update_topology_pass()的最后，会调用MEMORY_LISTENER_UPDATE_REGION这个宏，触发region_add对应的回调函数kvm_region_add()。\n这个宏在memory.c中定义，会将 FlatView 中的 FlatRange 转换为 MemoryRegionSection，作为入参传递给kvm_region_add()：\n/* No need to ref/unref .mr, the FlatRange keeps it alive. */ #define MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...) \\ do { \\ MemoryRegionSection mrs = section_from_flat_range(fr, \\ address_space_to_flatview(as)); \\ MEMORY_LISTENER_CALL(as, callback, dir, \u0026mrs, ##_args); \\ } while(0) 而kvm_region_add()实际上是对kvm_set_phys_mem()的封装调用。该函数比较复杂，会根据传入的section填充 KVMSlot，再传递给kvm_set_user_memory_region()：\nstatic int kvm_set_user_memory_region(KVMMemoryListener *kml, KVMSlot *slot, bool new) { KVMState *s = kvm_state; struct kvm_userspace_memory_region mem; int ret; // 根据 KVMSlot 填充 kvm_userspace_memory_region mem.slot = slot-\u003eslot | (kml-\u003eas_id \u003c\u003c 16); mem.guest_phys_addr = slot-\u003estart_addr; mem.userspace_addr = (unsigned long)slot-\u003eram; mem.flags = slot-\u003eflags; if (slot-\u003ememory_size \u0026\u0026 !new \u0026\u0026 (mem.flags ^ slot-\u003eold_flags) \u0026 KVM_MEM_READONLY) { /* Set the slot size to 0 before setting the slot to the desired * value. This is needed based on KVM commit 75d61fbc. */ mem.memory_size = 0; ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, \u0026mem); if (ret \u003c 0) { goto err; } } mem.memory_size = slot-\u003ememory_size; ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, \u0026mem); slot-\u003eold_flags = mem.flags; return ret; } 可以看到这里又将 KVMSlot 转换为 kvm_userspace_memory_region，作为ioctl()的参数，交给内核中的 KVM 进行内存的注册【设置GPA-\u003eHVA的映射关系，在内核空间维护并管理 Guest 的内存】。\n至此 QEMU 侧负责管理内存的数据结构均已完成初始化，可以参考下面的图片了解各数据结构之间的对应关系\n\u003c!DOCTYPE html\u003e Responsive Image 实际内存的分配 \u003c!DOCTYPE html\u003e Responsive Image int main() └─ void machine-\u003einit(ram_size, ...) └─ static void pc_init_pci(ram_size, ...) // 初始化虚拟机 └─ static void pc_init1(system_memory, system_io, ram_size, ...) ├─ void memory_region_init(pci_memory, \"pci\", ...) // pci_memory, rom_memory └─ void pc_memory_init() // 初始化内存，分配实际的物理内存地址 ├─ void memory_region_init_ram() // 创建 pc.ram, pc.rom 并分配内存 | ├─ void memory_region_init() | └─ ram_addr_t qemu_ram_alloc() | └─ ram_addr_t qemu_ram_alloc_from_ptr() | ├─ void vmstate_register_ram_global() // 将 MR 的 name 写入 RAMBlock 的 idstr | └─ void vmstate_register_ram() | └─ void qemu_ram_set_idstr() | ├─ void memory_region_init_alias() // 初始化 ram_below_4g, ram_above_4g └─ void memory_region_add_subregion() // 在 system_memory 中添加 subregions └─ static void memory_region_add_subregion_common() └─ static void memory_region_update_topology() // 为 MemoryRegion 生成 FlatView └─ static void address_space_update_topology() // as-\u003ecurrent_map = new_view └─ static void address_space_update_topology_pass() └─ static void kvm_region_add() // region_add 对应的回调实现 └─ static void kvm_set_phys_mem() // 根据传入的 section 填充 KVMSlot └─ static int kvm_set_user_memory_region() └─ int ioctl(KVM_SET_USER_MEMORY_REGION) 之前的回调函数注册、AddressSpace 的初始化，实际上均没有对应的物理内存。【实际的内存是在 RAMBlock 中】\n我们再回到 qemu 启动的 main 函数中。接下来的初始化过程会调用 pc_init1。在这里面，对于 CPU 虚拟化，我们会调用 pc_cpus_init。另外，pc_init1 还会调用pc_memory_init，进行内存的虚拟化。\nvoid *pc_memory_init(MemoryRegion *system_memory, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, ram_addr_t below_4g_mem_size, ram_addr_t above_4g_mem_size, MemoryRegion *rom_memory, MemoryRegion **ram_memory) { MemoryRegion *ram, *option_rom_mr; // 两个实体 MR: pc.ram, pc.rom MemoryRegion *ram_below_4g, *ram_above_4g; // 两个别名 MR: ram_below_4g, ram_above_4g /* Allocate RAM. We allocate it as a single memory region and use * aliases to address portions of it, mostly for backwards compatibility * with older qemus that used qemu_ram_alloc(). */ ram = g_malloc(sizeof(*ram)); // 创建 ram // 分配具体的内存（实际上会创建一个 RAMBlock 并将其 offset 值写入 ram.ram_addr，对应 GPA） memory_region_init_ram(ram, \"pc.ram\", below_4g_mem_size + above_4g_mem_size); // 将 MR 的 name 写入 RAMBlock 的 idstr vmstate_register_ram_global(ram); *ram_memory = ram; // 创建 ram_below_4g 表示 4G 以下的内存 ram_below_4g = g_malloc(sizeof(*ram_below_4g)); memory_region_init_alias(ram_below_4g, \"ram-below-4g\", ram, 0, below_4g_mem_size); // 将 ram_below_4g 挂在 system_memory 下 memory_region_add_subregion(system_memory, 0, ram_below_4g); if (above_4g_mem_size \u003e 0) { ram_above_4g = g_malloc(sizeof(*ram_above_4g)); memory_region_init_alias(ram_above_4g, \"ram-above-4g\", ram, below_4g_mem_size, above_4g_mem_size); memory_region_add_subregion(system_memory, 0x100000000ULL, ram_above_4g); } /* ... */ } 这里的重点在于memory_region_init_ram()，它通过qemu_ram_alloc()获取 ram 这个 MemoryRegion 对应的 RAMBlock 的offset，并存入ram.ram_addr，这样就可以在ram_list中根据该字段查找 MR 对应的 RAMBlock：\nvoid memory_region_init_ram(MemoryRegion *mr, const char *name, uint64_t size) { memory_region_init(mr, name, size); // 填充字段，初始化默认值 mr-\u003eram = true; // 表示为 RAM mr-\u003eterminates = true; // 表示为实体 MemoryRegion mr-\u003edestructor = memory_region_destructor_ram; mr-\u003eram_addr = qemu_ram_alloc(size, mr); // 这里保存 RAMBlock 的 offset，即 GPA } 而 qemu_ram_alloc() 最终会调用 qemu_ram_alloc_from_ptr()，创建一个对应大小 RAMBlock 并分配内存，返回对应的 GPA 地址存入 mr-\u003eram_addr 中：\nram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host, MemoryRegion *mr) { RAMBlock *new_block; // 创建一个 RAMBlock size = TARGET_PAGE_ALIGN(size); // 页对齐 new_block = g_malloc0(sizeof(*new_block)); // 初始化 new_block new_block-\u003emr = mr; // 将 new_block-\u003e 指向入参的 MemoryRegion new_block-\u003eoffset = find_ram_offset(size); // 从 ram_list 中的 RAMBlock 之间找到一段可以满足 size 需求的 gap，并返回起始地址的 offset，对应 GPA if (host) { // 新建的 RAMBlock host 字段为空，跳过 new_block-\u003ehost = host; new_block-\u003eflags |= RAM_PREALLOC_MASK; } else { if (mem_path) { // 未指定 mem_path #if defined (__linux__) \u0026\u0026 !defined(TARGET_S390X) new_block-\u003ehost = file_ram_alloc(new_block, size, mem_path); if (!new_block-\u003ehost) { new_block-\u003ehost = qemu_vmalloc(size); qemu_madvise(new_block-\u003ehost, size, QEMU_MADV_MERGEABLE); } #else fprintf(stderr, \"-mem-path option unsupported\\n\"); exit(1); #endif } else { if (xen_enabled()) { xen_ram_alloc(new_block-\u003eoffset, size, mr); } else if (kvm_enabled()) { // 从这里继续 /* some s390/kvm configurations have special constraints */ new_block-\u003ehost = kvm_vmalloc(size); // 实际上还是调用 qemu_vmalloc(size) } else { new_block-\u003ehost = qemu_vmalloc(size); // 从 QEMU 的线性空间中分配 size 大小的内存，返回 HVA } qemu_madvise(new_block-\u003ehost, size, QEMU_MADV_MERGEABLE); } } new_block-\u003elength = size; // 将 length 设置为 size QLIST_INSERT_HEAD(\u0026ram_list.blocks, new_block, next); // 将该 RAMBlock 插入 ram_list 头部 ram_list.phys_dirty = g_realloc(ram_list.phys_dirty, // 重新分配 ram_list.phys_dirty 的内存空间 last_ram_offset() \u003e\u003e TARGET_PAGE_BITS); memset(ram_list.phys_dirty + (new_block-\u003eoffset \u003e\u003e TARGET_PAGE_BITS), 0, size \u003e\u003e TARGET_PAGE_BITS); cpu_physical_memory_set_dirty_range(new_block-\u003eoffset, size, 0xff); // 对该 RAMBlock 对应的内存标记为 dirty qemu_ram_setup_dump(new_block-\u003ehost, size); if (kvm_enabled()) kvm_setup_guest_memory(new_block-\u003ehost, size); return new_block-\u003eoffset; } 这样一来ram【其实就是system memory，整个Guest物理空间的大小】对应的 RAMBlock 中就分配好了 GPA 和 HVA，就可以将内存信息同步至 KVM 侧了。\n最后回到pc_memory_init()中，在分配完实际内存后，会先调用memory_region_init_alias()初始化ram_below_4g、ram_above_4g这两个alias，之后调用memory_region_add_subregion()将这两个 alias 指向ram这个实体 MemoryRegion。如下图，该函数最终会触发kvm_region_add()回调，将实际的内存信息传入 KVM 注册。该过程如下图所示，与之前分析的流程相同，此处不再赘述。\n\u003c!DOCTYPE html\u003e Responsive Image 总结 虚拟机的内存管理也是需要用户态的 qemu 和内核态的 KVM 共同完成。为了加速内存映射，需要借助硬件的 EPT 技术。\nQEMU 侧 创建一系列 MemoryRegion，分别表示 Guest 中的 RAM、ROM 等区域。MemoryRegion之间通过 alias 或 subregions 的方式维护相互之间的关系，从而进一步细化区域的定义\n对于一个实体 MemoryRegion（非 alias），在初始化内存的过程中 QEMU 会创建它所对应的 RAMBlock。该 RAMBlock 通过调用qemu_ram_alloc_from_ptr()从 QEMU 的进程地址空间中以 mmap 的方式分配内存，并负责维护该 MemoryRegion 对应内存的起始 GPA/HVA/size 等相关信息【在qemu_ram_alloc_from_ptr中创建的新RAMBlock有offset、host的赋值，即GPA-\u003eHVA的对应关系】\nAddressSpace 表示 Guest 的物理地址空间。如果 AddressSpace 中的 MemoryRegion 发生变化，则注册的 listener 会被触发，将所属的 MemoryRegion 树展开生成一维的 FlatView，比较 FlatRange 是否发生了变化。如果是，则调用相应的方法对 MemoryRegionSection 进行检查，更新 QEMU 中的 KVMSlot，同时填充kvm_userspace_memory_region结构体，作为ioctl()的参数更新 KVM 中的kvm_memory_slot\nKVM 侧 当 QEMU 通过ioctl()创建 vcpu 时，调用kvm_mmu_create()初始化 MMU 相关信息。 当 KVM 要进入 Guest 前，vcpu_enter_guest()=\u003ekvm_mmu_reload()会将根级页表地址加载到 VMCS，让 Guest 使用该页表\n当发生EPT Violation 时，VM-EXIT到 KVM 中。如果是缺页，则根据 GPA 算出 gfn，再根据 gfn 找到对应的 KVMSlot，从中得到对应的 HVA。然后根据 HVA 算出对应的 pfn，确保该 Page 位于内存中。填好缺失的页之后，需要更新 EPT，完善其中缺少的页表项，逐层补全页表\n\u003c!DOCTYPE html\u003e Responsive Image 虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即 mmap 分配的虚拟内存空间被访问的时候，先查看 EPT 页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。 如果没有映射过，则虚拟机会通过VM-Exit指令回到宿主机模式，通过 handle_ept_violation 补充页表映射。先是通过 handle_mm_fault为虚拟机的物理内存空间分配真正的物理页面，然后通过 __direct_map 添加 EPT 页表映射。 \u003c!DOCTYPE html\u003e Responsive Image Reference “QEMU 内存空间虚拟化及内存管理” - B10g | FΓom 许大仙 【原创】Linux 虚拟化 KVM-Qemu 分析（五）之内存虚拟化 - LoyenWang - 博客园 KVM/Qemu 工作原理系列目录_xiongwenwu 的专栏-CSDN 博客_qemu 目录结构 QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北\n","wordCount":"12427","inLanguage":"zh","datePublished":"2022-01-25T13:42:11Z","dateModified":"2022-01-25T13:42:11Z","author":{"@type":"Person","name":"Nic"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifeislife.cn/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"},"publisher":{"@type":"Organization","name":"夜云泊","logo":{"@type":"ImageObject","url":"https://lifeislife.cn/assets/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><script defer src=/static/fontawesome/fontawesome-all.js></script><header class=header><nav class=nav><div class=logo><a href=https://lifeislife.cn/ accesskey=h title="夜云泊 (Alt + H)">夜云泊</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lifeislife.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://lifeislife.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://lifeislife.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://lifeislife.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://www.travellings.cn/go.html title=开往><span><i class='fa-solid fa-train-subway'></i>开往</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lifeislife.cn/>主页</a>&nbsp;»&nbsp;<a href=https://lifeislife.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">QEMU 源码分析-内存虚拟化</h1><div class=post-meta><span title='2022-01-25 13:42:11 +0000 UTC'>一月 25, 2022</span>&nbsp;·&nbsp;25 分钟&nbsp;·&nbsp;12427 字&nbsp;·&nbsp;Nic</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#概述>概述</a></li><li><a href=#页面分配和映射的两种方式>页面分配和映射的两种方式</a><ul><li><a href=#影子页表-shadow-page-tablespt>影子页表 Shadow Page Table，SPT</a></li><li><a href=#扩展页表-extent-page-tableept>扩展页表 Extent Page Table，EPT</a></li></ul></li><li><a href=#qemu-的主要工作>QEMU 的主要工作</a></li><li><a href=#qemu-和-kvm-的工作分界>QEMU 和 KVM 的工作分界</a></li><li><a href=#相关数据结构>相关数据结构</a><ul><li><a href=#addressspace>AddressSpace</a></li><li><a href=#memoryregion>MemoryRegion</a></li><li><a href=#ramblock>RAMBlock</a></li><li><a href=#flatview>FlatView</a></li><li><a href=#memoryregionsection>MemoryRegionSection</a></li><li><a href=#kvmslot>KVMSlot</a></li><li><a href=#kvm_userspace_memory_region>kvm_userspace_memory_region</a></li><li><a href=#memorylistener>MemoryListener</a></li><li><a href=#重要数据结构总览>重要数据结构总览</a></li></ul></li><li><a href=#具体实现机制>具体实现机制</a><ul><li><a href=#回调函数的注册>回调函数的注册</a></li><li><a href=#addressspace-的初始化>AddressSpace 的初始化</a></li><li><a href=#实际内存的分配>实际内存的分配</a></li></ul></li><li><a href=#总结>总结</a><ul><li><a href=#qemu-侧>QEMU 侧</a></li><li><a href=#kvm-侧>KVM 侧</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p>1.大部分转载自<a href=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/>QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a>
2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改
3.部分内容根据自己理解补充添加</p></blockquote><h2 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h2><p>我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：</p><ul><li>虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间；</li><li>虚拟机里面的物理内存（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存；</li><li>物理机的虚拟内存（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间；</li><li>物理机的物理内存（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。</li></ul><p>内存虚拟化的关键在于维护 <code>GPA</code> 到 <code>HVA</code> 的映射关系。</p><h2 id=页面分配和映射的两种方式>页面分配和映射的两种方式<a hidden class=anchor aria-hidden=true href=#页面分配和映射的两种方式>#</a></h2><p>要搞清楚 QEMU system emulation 的仿真架构，首先对于 Host OS，将 QEMU 作为进程启动，然后对于 QEMU 进程，会仿真各种硬件和运行 Guest OS，在这层 OS 上运行要全系统模拟的应用程序，因此对于 Guest OS 管理的内存要实现到 QEMU 进程的虚拟空间的转换需要 softMMU（即需要对 GPA 到 HVA 进行转换）。从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。</p><h3 id=影子页表-shadow-page-tablespt>影子页表 Shadow Page Table，SPT<a hidden class=anchor aria-hidden=true href=#影子页表-shadow-page-tablespt>#</a></h3><p>第一种方式就是软件的方式，影子页表（Shadow Page Table）。</p><p>KVM 通过维护记录 GVA->HPA 的影子页表 SPT，减少了地址转换带来的开销，可以直接将 GVA 转换为 HPA。</p><p>内存映射要通过页表来管理，页表地址应该放在 CR3 寄存器里面。在软件虚拟化的内存转换中，GVA 到 GPA 的转换通过查询 CR3 寄存器来完成，CR3 中保存了 Guest 的页表基地址，然后载入 MMU 中进行地址转换。</p><p>在加入了 SPT 技术后，当 Guest 访问 CR3 时，KVM 会捕获到这个操作 EXIT_REASON_CR_ACCESS，之后 KVM 会载入特殊的 CR3 和影子页表，欺骗 Guest 这就是真实的 CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。</p><blockquote><p>本来的过程是，客户机要通过 cr3 找到客户机的页表，实现从 GVA 到 GPA 的转换，然后在宿主机上，要通过 cr3 找到宿主机的页表，实现从 HVA 到 HPA 的转换。
为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。
在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。</p></blockquote><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124192700.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124192700.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><p>为了快速检索 Guest 页表对应的影子页表，KVM 为每个客户机维护了一个 hash 表来进行客户机页表到影子页表之间的映射。对于每一个 Guest 来说，其页目录和页表都有唯一的 GPA，通过页目录/页表的 GPA 就可以在哈希链表中快速地找到对应的影子页目录/页表。</p><p>当 Guest 切换进程时，Guest 会把待切换进程的页表基址载入 CR3，而 KVM 将会截获这一特权指令。KVM 在哈希表中找到与此页表基址对应的影子页表基址，载入 Guest CR3，使 Guest 在恢复运行时 CR3 实际指向的是新切换进程对应的影子页表。</p><p>影子页表的引入，减少了 GVA->HPA 的转换开销，但是缺点在于需要为 Guest 的每个进程都维护一个影子页表，这将带来很大的内存开销。同时影子页表的建立是很耗时的，如果 Guest 的进程过多，将导致影子页表频繁切换。</p><p>因此 Intel 和 AMD 在此基础上提供了基于硬件的虚拟化技术 EPT。</p><h3 id=扩展页表-extent-page-tableept>扩展页表 Extent Page Table，EPT<a hidden class=anchor aria-hidden=true href=#扩展页表-extent-page-tableept>#</a></h3><p>Intel 的 EPT（Extent Page Table）技术和 AMD 的 NPT（Nest Page Table）技术都对内存虚拟化提供了硬件支持。这两种技术原理类似，都是在硬件层面上实现 GVA 到 HPA 之间的转换。下面就以 EPT 为例分析一下 KVM 基于硬件辅助的内存虚拟化实现。</p><p>EPT 在原有客户机页表对客户机虚拟地址 GVA 到客户机物理地址 GPA 映射的基础上，又引入了 EPT 页表来实现客户机物理地址 GPA 到宿主机物理地址 HPA 的另一次映射。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。</p><p>即 EPT 技术采用了在两级页表结构，即原有 Guest OS 页表对 <strong>GVA->GPA</strong> 映射的基础上，又引入了 EPT 页表来实现 <strong>GPA->HPA</strong> 的另一次映射，这<strong>两次地址映射都是由硬件自动完成</strong>。</p><p>有了 EPT，在<strong>GPA->HPA</strong>转换的过程中，缺页会产生 EPT 缺页异常。KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。</p><p>KVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。</p><p>这里，我们重点看第二种方式。因为使用了 EPT 之后，客户机里面的页表映射，也即从 GVA 到 GPA 的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而 EPT 重点帮我们解决的就是从 GPA 到 HPA 的转换问题。因为要经过两次页表，所以 EPT 又 tdp(two dimentional paging)。</p><p>EPT 的页表结构也是分为四层，EPT Pointer（EPTP）指向 PML4 的首地址。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124194059.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124194059.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h2 id=qemu-的主要工作>QEMU 的主要工作<a hidden class=anchor aria-hidden=true href=#qemu-的主要工作>#</a></h2><p>内存虚拟化的目的就是让虚拟机能够无缝的访问内存。有了 Intel EPT 的支持后，CPU 在 VMX non-root 状态时进行内存访问会再做一次 EPT 转换。在这个过程中，QEMU 会负责以下内容：</p><p>首先需要从自己的进程地址空间中申请内存用于 Guest
需要将上一步中申请到的内存的虚拟地址（HVA）和 Guest 的物理地址之间的映射关系传递给 KVM（kernel），即 GPA->HVA
需要组织一系列的数据结构来管理虚拟内存空间，并在内存拓扑结构更改时将最新的内存信息同步至 KVM 中</p><h2 id=qemu-和-kvm-的工作分界>QEMU 和 KVM 的工作分界<a hidden class=anchor aria-hidden=true href=#qemu-和-kvm-的工作分界>#</a></h2><p>QEMU 和 KVM 之间是通过 KVM 提供的 ioctl() 接口进行交互的。在内核的 kvm_vm_ioctl() 中，<strong>设置虚拟机内存</strong>的系统调用【kernel 就是一系列系统调用函数接口和处理逻辑，其中有个处理”创建/设置虚拟机内存“的系统调用接口】为 <code>VM_SET_USER_MEMORY_REGION</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>long</span> <span class=nf>kvm_vm_ioctl</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>filp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>ioctl</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>KVM_SET_USER_MEMORY_REGION</span><span class=p>:</span> <span class=p>{</span> <span class=c1>// 在 KVM 中注册用户空间传入的内存信息
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>struct</span> <span class=n>kvm_userspace_memory_region</span> <span class=n>kvm_userspace_mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>r</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=c1>// 将传入的数据结构复制到内核空间
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nf>copy_from_user</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kvm_userspace_mem</span><span class=p>,</span> <span class=n>argp</span><span class=p>,</span> <span class=k>sizeof</span> <span class=n>kvm_userspace_mem</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         <span class=c1>// 实际进行处理的函数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>r</span> <span class=o>=</span> <span class=nf>kvm_vm_ioctl_set_memory_region</span><span class=p>(</span><span class=n>kvm</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>kvm_userspace_mem</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到这里需要传递的参数类型为 <code>kvm_userspace_memory_region</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* for KVM_SET_USER_MEMORY_REGION */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>kvm_userspace_memory_region</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>__u32</span> <span class=n>slot</span><span class=p>;</span>            <span class=c1>// slot 编号 [参考：https://www.cnblogs.com/LoyenWang/p/11922887.html]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__u32</span> <span class=n>flags</span><span class=p>;</span>           <span class=c1>// 标志位，例如是否追踪脏页、是否可用等
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__u64</span> <span class=n>guest_phys_addr</span><span class=p>;</span> <span class=c1>// Guest 物理地址，即 GPA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__u64</span> <span class=n>memory_size</span><span class=p>;</span>     <span class=c1>// 内存大小，单位 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__u64</span> <span class=n>userspace_addr</span><span class=p>;</span>  <span class=c1>// 从 QEMU 进程地址空间中分配内存的起始地址，即 HVA
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p><code>KVM_SET_USER_MEMORY_REGION</code>这个 <code>ioctl</code> 主要目的就是设置<code>GPA->HVA</code>的映射关系，KVM 会继续调用<code>kvm_vm_ioctl_set_memory_region()</code>，在内核空间维护并管理 Guest 的内存。</p><h2 id=相关数据结构>相关数据结构<a hidden class=anchor aria-hidden=true href=#相关数据结构>#</a></h2><h3 id=addressspace>AddressSpace<a hidden class=anchor aria-hidden=true href=#addressspace>#</a></h3><h4 id=结构体定义>结构体定义<a hidden class=anchor aria-hidden=true href=#结构体定义>#</a></h4><p>QEMU 用 AddressSpace 结构体表示 Guest 中 CPU/设备看到的内存【也就是Guest OS 可以在 QEMU 进程虚存中用到的所有内存，是 MemoryRegion 的集合，即 GPA 的整体】，类似于物理机中地址空间的概念，但在这里表示的是 Guest 的一段地址空间，如内存地址空间 <code>address_space_memory</code> 、<code>I/O</code> 地址空间<code>address_space_io</code>，它在 QEMU 源码<code>memory.c</code>中定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>AddressSpace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* private: */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>rcu_head</span> <span class=n>rcu</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Accessed via RCU.  */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>FlatView</span> <span class=o>*</span><span class=n>current_map</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ioeventfd_nb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>MemoryRegionIoeventfd</span> <span class=o>*</span><span class=n>ioeventfds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>QTAILQ_HEAD</span><span class=p>(,</span> <span class=n>MemoryListener</span><span class=p>)</span> <span class=n>listeners</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>QTAILQ_ENTRY</span><span class=p>(</span><span class=n>AddressSpace</span><span class=p>)</span> <span class=n>address_spaces_link</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>每个 AddressSpace 一般包含一系列的 MemoryRegion：<code>root</code>指针指向根级 MemoryRegion，而 root 可能有自己的若干个 sub-regions（子节点），于是形成树状结构。这些 MemoryRegion 通过树连接起来，树的根即为 AddressSpace 的 root 域。</p><h4 id=全局变量>全局变量<a hidden class=anchor aria-hidden=true href=#全局变量>#</a></h4><p>另外，QEMU 中有两个全局的静态 AddressSpace，在 memory.c 中定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=n>AddressSpace</span> <span class=n>address_space_memory</span><span class=p>;</span> <span class=c1>// 内存地址空间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>AddressSpace</span> <span class=n>address_space_io</span><span class=p>;</span>     <span class=c1>// I/O 地址空间
</span></span></span></code></pre></div><p>其 root 域分别指向之后会提到的两个 MemoryRegion 类型变量：system_memory、system_io。</p><h3 id=memoryregion>MemoryRegion<a hidden class=anchor aria-hidden=true href=#memoryregion>#</a></h3><h4 id=结构体定义-1>结构体定义<a hidden class=anchor aria-hidden=true href=#结构体定义-1>#</a></h4><p><code>MemoryRegion</code> 表示在 <code>Guest Memory Layout</code> 中的一段内存区域【也就是单元级 GPA 的概念，Guest OS 可以管理到的那些 Guest 物理内存单元】，它是联系 <code>GPA</code> 和 <code>RAMBlocks</code>（描述真实内存）之间的桥梁，在<code>memory.h</code>中定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>MemoryRegion</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* All fields are private - violators will be prosecuted */</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>MemoryRegionOps</span> <span class=o>*</span><span class=n>ops</span><span class=p>;</span>      <span class=c1>// 回调函数集合
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>opaque</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>parent</span><span class=p>;</span>            <span class=c1>// 父 MemoryRegion 指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Int128</span> <span class=n>size</span><span class=p>;</span>                     <span class=c1>// 该区域内存的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>target_phys_addr_t</span> <span class=n>addr</span><span class=p>;</span>         <span class=c1>// 在 Address Space 中的地址，即 HVA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>destructor</span><span class=p>)(</span><span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>mr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>ram_addr_t</span> <span class=n>ram_addr</span><span class=p>;</span>             <span class=c1>// MemoryRegion 的起始地址，即 GPA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>subpage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>terminates</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>readable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ram</span><span class=p>;</span>                        <span class=c1>// 是否表示 RAM
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>readonly</span><span class=p>;</span> <span class=cm>/* For RAM regions */</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>enabled</span><span class=p>;</span>                    <span class=c1>// 是否已经通知 KVM 使用这段内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>rom_device</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>warning_printed</span><span class=p>;</span> <span class=cm>/* For reservations */</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>alias</span><span class=p>;</span>             <span class=c1>// 是否为 MemoryRegion alias
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>target_phys_addr_t</span> <span class=n>alias_offset</span><span class=p>;</span> <span class=c1>// 若为 alias，在原 MemoryRegion 中的 offset
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=n>priority</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>may_overlap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>QTAILQ_HEAD</span><span class=p>(</span><span class=n>subregions</span><span class=p>,</span> <span class=n>MemoryRegion</span><span class=p>)</span> <span class=n>subregions</span><span class=p>;</span> <span class=c1>// 子区域链表头
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>QTAILQ_ENTRY</span><span class=p>(</span><span class=n>MemoryRegion</span><span class=p>)</span> <span class=n>subregions_link</span><span class=p>;</span>       <span class=c1>// 子区域链表节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>QTAILQ_HEAD</span><span class=p>(</span><span class=n>coalesced_ranges</span><span class=p>,</span> <span class=n>CoalescedMemoryRange</span><span class=p>)</span> <span class=n>coalesced</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>       <span class=c1>// MemoryRegion 的名字，调试时使用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=n>dirty_log_mask</span><span class=p>;</span> <span class=c1>// 表示哪一种 dirty map 被使用，共分三种
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=n>ioeventfd_nb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegionIoeventfd</span> <span class=o>*</span><span class=n>ioeventfds</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h4 id=全局变量-1>全局变量<a hidden class=anchor aria-hidden=true href=#全局变量-1>#</a></h4><p>在 QEMU 的 exec.c 中也定义了两个静态的 MemoryRegion 指针变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>system_memory</span><span class=p>;</span> <span class=c1>// 内存 MemoryRegion，对应 address_space_memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>system_io</span><span class=p>;</span>     <span class=c1>// I/O MemoryRegion，对应 address_space_io
</span></span></span></code></pre></div><p>与两个全局 AddressSpace 对应，即 AddressSpace 的 root 域指向这两个 MemoryRegion。</p><h4 id=memoryregion-的类型>MemoryRegion 的类型<a hidden class=anchor aria-hidden=true href=#memoryregion-的类型>#</a></h4><p>MemoryRegion 有多种类型，可以表示一段 RAM、ROM、MMIO、alias(别名)。</p><p>若为 alias 则表示一个 MemoryRegion 的部分区域，例如，QEMU 会为 pc.ram 这个表示 RAM 的 MemoryRegion 添加两个 alias：ram-below-4g 和 ram-above-4g，之后会看到具体的代码实例。</p><p>另外，MemoryRegion 也可以表示一个 container，这就表示它只是其他若干个 MemoryRegion 的容器。</p><p>那么要如何创建不同类型的 <code>MemoryRegion</code> 呢？</p><p>在 QEMU 中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将 MemoryRegion 划分为以下三种类型：</p><ul><li>根级 MemoryRegion：直接通过 memory_region_init 初始化，没有自己的内存，用于管理 subregion，例如 system_memory：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>memory_region_init</span><span class=p>(</span><span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>mr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=kt>uint64_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>ops</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=nf>int128_make64</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>==</span> <span class=n>UINT64_MAX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>mr</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=nf>int128_2_64</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>addr</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>subpage</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>enabled</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>terminates</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// 非实体 MemoryRegion，搜索时会继续前往其 subregions
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>ram</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>        <span class=c1>// 根级 MemoryRegion 不分配内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>readable</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>readonly</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>rom_device</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>destructor</span> <span class=o>=</span> <span class=n>memory_region_destructor_none</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>may_overlap</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>alias</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>QTAILQ_INIT</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mr</span><span class=o>-&gt;</span><span class=n>subregions</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mr</span><span class=o>-&gt;</span><span class=n>subregions_link</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span> <span class=n>mr</span><span class=o>-&gt;</span><span class=n>subregions_link</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>QTAILQ_INIT</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mr</span><span class=o>-&gt;</span><span class=n>coalesced</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=nf>g_strdup</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>dirty_log_mask</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>ioeventfd_nb</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>ioeventfds</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到 mr->addr 被设置为 0，而 mr->ram_addr 则并没有初始化。</p><ul><li>实体 <code>MemoryRegion</code>：通过<code>memory_region_init_ram()</code>初始化，有自己的内存（从 QEMU 进程地址空间中分配），大小为<code>size</code>，例如<code>ram_memory</code>、 <code>pci_memory</code>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>pc_memory_init</span><span class=p>(</span><span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>system_memory</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>kernel_filename</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>kernel_cmdline</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>initrd_filename</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=kt>ram_addr_t</span> <span class=n>below_4g_mem_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=kt>ram_addr_t</span> <span class=n>above_4g_mem_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>rom_memory</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>MemoryRegion</span> <span class=o>**</span><span class=n>ram_memory</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>ram</span><span class=p>,</span> <span class=o>*</span><span class=n>option_rom_mr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ...*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Allocate RAM.  We allocate it as a single memory region and use
</span></span></span><span class=line><span class=cl><span class=cm>     * aliases to address portions of it, mostly for backwards compatibility
</span></span></span><span class=line><span class=cl><span class=cm>     * with older qemus that used qemu_ram_alloc().
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>ram</span> <span class=o>=</span> <span class=nf>g_malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>ram</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 调用 memory_region_init_ram 对 ram_memory 进行初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memory_region_init_ram</span><span class=p>(</span><span class=n>ram</span><span class=p>,</span> <span class=s>&#34;pc.ram&#34;</span><span class=p>,</span> <span class=n>below_4g_mem_size</span> <span class=o>+</span> <span class=n>above_4g_mem_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>vmstate_register_ram_global</span><span class=p>(</span><span class=n>ram</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>ram_memory</span> <span class=o>=</span> <span class=n>ram</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>memory_region_init_ram</span><span class=p>(</span><span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>mr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=kt>uint64_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>memory_region_init</span><span class=p>(</span><span class=n>mr</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>ram</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>terminates</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>destructor</span> <span class=o>=</span> <span class=n>memory_region_destructor_ram</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>ram_addr</span> <span class=o>=</span> <span class=nf>qemu_ram_alloc</span><span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=n>mr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到这里是先调用了<code>memory_region_init()</code>，之后设置 <code>RAM</code> 属性，并继续调用<code>qemu_ram_alloc()</code>分配内存。</p><ul><li>别名 <code>MemoryRegion</code>：通过<code>memory_region_init_alias()</code> 初始化，没有自己的内存，表示实体 <code>MemoryRegion</code> 的一部分。通过 <code>alias</code> 成员指向实体 <code>MemoryRegion</code>，<code>alias_offset</code>为在实体 <code>MemoryRegion</code> 中的偏移量，例如<code>ram_below_4g</code>、<code>ram_above_4g</code>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>pc_memory_init</span><span class=p>(</span><span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>system_memory</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>kernel_filename</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>kernel_cmdline</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>initrd_filename</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=kt>ram_addr_t</span> <span class=n>below_4g_mem_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=kt>ram_addr_t</span> <span class=n>above_4g_mem_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>rom_memory</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>MemoryRegion</span> <span class=o>**</span><span class=n>ram_memory</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>ram_below_4g</span><span class=p>,</span> <span class=o>*</span><span class=n>ram_above_4g</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl>    <span class=n>ram_below_4g</span> <span class=o>=</span> <span class=nf>g_malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>ram_below_4g</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 调用 memory_region_init_alias 对 ram_below_4g 进行初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memory_region_init_alias</span><span class=p>(</span><span class=n>ram_below_4g</span><span class=p>,</span> <span class=s>&#34;ram-below-4g&#34;</span><span class=p>,</span> <span class=n>ram</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>below_4g_mem_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ..
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>memory_region_init_alias</span><span class=p>(</span><span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>mr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>orig</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=kt>target_phys_addr_t</span> <span class=n>offset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=kt>uint64_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>memory_region_init</span><span class=p>(</span><span class=n>mr</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>alias</span> <span class=o>=</span> <span class=n>orig</span><span class=p>;</span> <span class=c1>// 指向实体 MemoryRegion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>alias_offset</span> <span class=o>=</span> <span class=n>offset</span><span class=p>;</span> <span class=c1>//通过 offset 得到实体的某一个部分
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=ramblock>RAMBlock<a hidden class=anchor aria-hidden=true href=#ramblock>#</a></h3><h4 id=结构体定义-2>结构体定义<a hidden class=anchor aria-hidden=true href=#结构体定义-2>#</a></h4><p><code>MemoryRegion</code> 用来描述一段逻辑层面上的内存区域，而记录实际分配的内存地址信息的结构体则是 <code>RAMBlock</code>，在<code>ramblock.h</code>中定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>RAMBlock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>rcu_head</span> <span class=n>rcu</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>mr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>host</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=o>*</span><span class=n>colo_cache</span><span class=p>;</span> <span class=cm>/* For colo, VM&#39;s ram cache */</span>
</span></span><span class=line><span class=cl>    <span class=kt>ram_addr_t</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>ram_addr_t</span> <span class=n>used_length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>ram_addr_t</span> <span class=n>max_length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>resized</span><span class=p>)(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>length</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>host</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Protected by iothread lock.  */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>idstr</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* RCU-enabled, writes protected by the ramlist lock */</span>
</span></span><span class=line><span class=cl>    <span class=nf>QLIST_ENTRY</span><span class=p>(</span><span class=n>RAMBlock</span><span class=p>)</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>QLIST_HEAD</span><span class=p>(,</span> <span class=n>RAMBlockNotifier</span><span class=p>)</span> <span class=n>ramblock_notifiers</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>page_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* dirty bitmap used during migration */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>bmap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* bitmap of already received pages in postcopy */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>receivedmap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * bitmap to track already cleared dirty bitmap.  When the bit is
</span></span></span><span class=line><span class=cl><span class=cm>     * set, it means the corresponding memory chunk needs a log-clear.
</span></span></span><span class=line><span class=cl><span class=cm>     * Set this up to non-NULL to enable the capability to postpone
</span></span></span><span class=line><span class=cl><span class=cm>     * and split clearing of dirty bitmap on the remote node (e.g.,
</span></span></span><span class=line><span class=cl><span class=cm>     * KVM).  The bitmap will be set only when doing global sync.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * NOTE: this bitmap is different comparing to the other bitmaps
</span></span></span><span class=line><span class=cl><span class=cm>     * in that one bit can represent multiple guest pages (which is
</span></span></span><span class=line><span class=cl><span class=cm>     * decided by the `clear_bmap_shift&#39; variable below).  On
</span></span></span><span class=line><span class=cl><span class=cm>     * destination side, this should always be NULL, and the variable
</span></span></span><span class=line><span class=cl><span class=cm>     * `clear_bmap_shift&#39; is meaningless.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>clear_bmap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>clear_bmap_shift</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * RAM block length that corresponds to the used_length on the migration
</span></span></span><span class=line><span class=cl><span class=cm>     * source (after RAM block sizes were synchronized). Especially, after
</span></span></span><span class=line><span class=cl><span class=cm>     * starting to run the guest, used_length and postcopy_length can differ.
</span></span></span><span class=line><span class=cl><span class=cm>     * Used to register/unregister uffd handlers and as the size of the received
</span></span></span><span class=line><span class=cl><span class=cm>     * bitmap. Receiving any page beyond this length will bail out, as it
</span></span></span><span class=line><span class=cl><span class=cm>     * could not have been valid on the source.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>ram_addr_t</span> <span class=n>postcopy_length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>可以看到在 <code>RAMBlock</code> 中 host 和 offset 域分别对应了 <code>HVA</code> 和<code>GPA</code>，因此也可以说 <code>RAMBlock</code> 中存储了<code>GPA->HVA</code>的映射关系，另外每一个 <code>RAMBlock</code> 都会指向其所属的 <code>MemoryRegion</code>。</p><h4 id=全局变量-ram_list>全局变量 ram_list<a hidden class=anchor aria-hidden=true href=#全局变量-ram_list>#</a></h4><p>QEMU 在<code>ramlist.h</code>中定义了一个全局变量<code>ram_list</code>，以链表的形式维护了所有的 <code>RAMBlock</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>RAMList</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>QemuMutex</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>RAMBlock</span> <span class=o>*</span><span class=n>mru_block</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* RCU-enabled, writes protected by the ramlist lock. */</span>
</span></span><span class=line><span class=cl>    <span class=nf>QLIST_HEAD</span><span class=p>(,</span> <span class=n>RAMBlock</span><span class=p>)</span> <span class=n>blocks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DirtyMemoryBlocks</span> <span class=o>*</span><span class=n>dirty_memory</span><span class=p>[</span><span class=n>DIRTY_MEMORY_NUM</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>version</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>QLIST_HEAD</span><span class=p>(,</span> <span class=n>RAMBlockNotifier</span><span class=p>)</span> <span class=n>ramblock_notifiers</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>RAMList</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=n>RAMList</span> <span class=n>ram_list</span><span class=p>;</span>
</span></span></code></pre></div><p>每一个新分配的 <code>RAMBlock</code> 都会被插入到<code>ram_list</code>的头部。如需查找地址所对应的 <code>RAMBlock</code>，则需要遍历<code>ram_list</code>，当目标地址落在当前<code>RAMBlock</code>的地址区间时，该 <code>RAMBlock</code> 即为查找目标。</p><h4 id=asmrramblock-之间的关系>AS、MR、RAMBlock 之间的关系<a hidden class=anchor aria-hidden=true href=#asmrramblock-之间的关系>#</a></h4><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225155936.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225155936.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h3 id=flatview>FlatView<a hidden class=anchor aria-hidden=true href=#flatview>#</a></h3><p>AddressSpace 的 root 域及其子树共同构成了 Guest 的物理地址空间，但这些都是在 QEMU 侧定义的。要传入 KVM 进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其<strong>转换为一个“平坦”的地址模</strong>型，也就是一个从零开始、只包含地址信息的数据结构，这在 QEMU 中通过 <strong>FlatView</strong> 来表示。每个 AddressSpace 都有一个与之对应的 FlatView 指针 current_map，表示其对应的平面展开视图。</p><h4 id=结构体定义-3>结构体定义<a hidden class=anchor aria-hidden=true href=#结构体定义-3>#</a></h4><p><code>FlatView</code> 在<code>memory.c</code>中定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Flattened global view of current active memory hierarchy.  Kept in sorted
</span></span></span><span class=line><span class=cl><span class=cm> * order.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>FlatView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>rcu_head</span> <span class=n>rcu</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>ref</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FlatRange</span> <span class=o>*</span><span class=n>ranges</span><span class=p>;</span>      <span class=c1>// 对应的 FlatRange 数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=n>nr</span><span class=p>;</span>            <span class=c1>// FlatRange 的数目
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=n>nr_allocated</span><span class=p>;</span>  <span class=c1>// 当前数组的项数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>AddressSpaceDispatch</span> <span class=o>*</span><span class=n>dispatch</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>其中，<code>ranges</code>是一个数组，记录了 <code>FlatView</code> 下所有的 <code>FlatRange</code>。</p><h4 id=flatrange>FlatRange<a hidden class=anchor aria-hidden=true href=#flatrange>#</a></h4><p>在 <code>FlatView</code> 中，<code>FlatRange</code> 表示在 <code>FlatView</code> 中的一段内存范围，同样在<code>memory.c</code>中定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Range of memory in the global map.  Addresses are absolute. */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>FlatRange</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>mr</span><span class=p>;</span>           <span class=c1>// 指向所属的 MemoryRegion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hwaddr</span> <span class=n>offset_in_region</span><span class=p>;</span>    <span class=c1>// 在全局 MemoryRegion 中的 offset，对应 GPA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>AddrRange</span> <span class=n>addr</span><span class=p>;</span>             <span class=c1>// 代表的地址区间，对应 HVA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint8_t</span> <span class=n>dirty_log_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>romd_mode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>readonly</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>nonvolatile</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>每个 <code>FlatRange</code> 对应一段虚拟机物理地址区间，各个 <code>FlatRange</code> 不会重叠，<strong>按照地址的顺序保存在数组中</strong>，具体的地址范围由一个 <code>AddrRange</code> 结构来描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * AddrRange 用于表示 FlatRange 的起始地址及大小
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>AddrRange</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Int128</span> <span class=n>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Int128</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=memoryregionsection>MemoryRegionSection<a hidden class=anchor aria-hidden=true href=#memoryregionsection>#</a></h3><h4 id=结构体定义-4>结构体定义<a hidden class=anchor aria-hidden=true href=#结构体定义-4>#</a></h4><p>在 <code>QEMU</code> 中，还有几个起到中介作用的结构体，<code>MemoryRegionSection</code> 就是其中之一。</p><p>之前介绍的 <code>FlatRange</code> 代表一个物理地址空间的片段，偏向于描述在 <code>Host</code> 侧即 <strong>AddressSpace 中的分布【Guest 的物理空间】</strong>，而 <code>MemoryRegionSection</code> 则代表在 <code>Guest</code> 侧即 <strong>MemoryRegion 中的片段</strong>。<code>MemoryRegionSection</code> 在<code>memory.h</code>中定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * MemoryRegionSection: describes a fragment of a #MemoryRegion
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @mr: the region, or %NULL if empty
</span></span></span><span class=line><span class=cl><span class=cm> * @address_space: the address space the region is mapped in
</span></span></span><span class=line><span class=cl><span class=cm> * @offset_within_region: the beginning of the section, relative to @mr&#39;s start
</span></span></span><span class=line><span class=cl><span class=cm> * @size: the size of the section; will not exceed @mr&#39;s boundaries
</span></span></span><span class=line><span class=cl><span class=cm> * @offset_within_address_space: the address of the first byte of the section
</span></span></span><span class=line><span class=cl><span class=cm> *     relative to the region&#39;s address space
</span></span></span><span class=line><span class=cl><span class=cm> * @readonly: writes to this section are ignored
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl> <span class=c1>//只是起到描述的作用，描述了是哪个 AddressSpace 的 MemoryRegion，
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=c1>//并且在 MemoryRegion 中的 offset，和在 AddressSpace 展开为平坦内存的 offset
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>MemoryRegionSection</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>mr</span><span class=p>;</span>                               <span class=c1>// 所属的 MemoryRegion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>address_space</span><span class=p>;</span>                    <span class=c1>// 关联的 AddressSpace
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>target_phys_addr_t</span> <span class=n>offset_within_region</span><span class=p>;</span>        <span class=c1>// 在 MemoryRegion 内部的 offset
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>size</span><span class=p>;</span>                                  <span class=c1>// Section 的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>target_phys_addr_t</span> <span class=n>offset_within_address_space</span><span class=p>;</span> <span class=c1>// 在 AddressSpace 内部的 offset
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>readonly</span><span class=p>;</span>                                  <span class=c1>// 是否为只读
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><ul><li><code>offset_within_region</code>：在所属 <code>MemoryRegion</code> 中的<code>offset</code>。一个<code>AddressSpace</code> 可能由多个 <code>MemoryRegion</code> 组成，因此该 <code>offset</code> 是局部的</li><li><code>offset_within_address_space</code>：在所属 <code>AddressSpace</code> 中的 <code>offset</code>，它是全局的</li></ul><h4 id=和其他数据结构之间的关系>和其他数据结构之间的关系<a hidden class=anchor aria-hidden=true href=#和其他数据结构之间的关系>#</a></h4><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125110422.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125110422.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><ul><li><code>AddressSpace</code> 的<code>root</code>指向对应的根级<code>MemoryRegion</code>，<code>current_map</code>指向<code>AddressSpace</code> 的<code>root</code>通过<code>generate_memory_topology()</code>生成的 <code>FlatView</code></li><li><code>FlatView</code> 中的<code>ranges</code>数组表示该<code>MemoryRegion</code> 所表示的<code>Guest</code>地址区间【GPA 的整个平坦物理空间】，并按照地址的顺序进行排列</li><li><code>MemoryRegionSection</code> 由<code>ranges</code>数组中的 <code>FlatRange</code> 对应生成，作为注册到 <code>KVM</code>中的基本单位</li></ul><hr><p><code>QEMU</code> 在用户空间申请内存后，需要将内存信息通过一系列系统调用传入内核空间的 <code>KVM</code>，由 <code>KVM</code> 侧进行管理，因此 <code>QEMU</code> 侧也定义了一些用于向 <code>KVM</code> 传递参数的结构体。</p><p>以下为<code>KVM</code>相关的数据结构。</p><h3 id=kvmslot>KVMSlot<a hidden class=anchor aria-hidden=true href=#kvmslot>#</a></h3><p><code>在 kvm_init.h</code>中定义，是 <code>KVM</code> 中内存管理的基本单位：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>KVMSlot</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>hwaddr</span> <span class=n>start_addr</span><span class=p>;</span> <span class=c1>// Guest 物理地址，GPA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>ram_addr_t</span> <span class=n>memory_size</span><span class=p>;</span>        <span class=c1>// 内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>ram</span><span class=p>;</span> <span class=c1>// QEMU 用户空间地址，HVA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>slot</span><span class=p>;</span>  <span class=c1>// Slot 编号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>flags</span><span class=p>;</span> <span class=c1>// 标志位，例如是否追踪脏页、是否可用等
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/* Dirty bitmap cache for the slot */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>dirty_bmap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>dirty_bmap_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Cache of the address space ID */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>as_id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Cache of the offset in ram address space */</span>
</span></span><span class=line><span class=cl>    <span class=kt>ram_addr_t</span> <span class=n>ram_start_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>KVMSlot</span><span class=p>;</span>
</span></span></code></pre></div><p><code>KVMSlot</code> 类似于内存插槽的概念。</p><h3 id=kvm_userspace_memory_region>kvm_userspace_memory_region<a hidden class=anchor aria-hidden=true href=#kvm_userspace_memory_region>#</a></h3><p>调用<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>时需要向 <code>KVM</code> 传递的参数，在<code>kvm.h</code>中定义</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* for KVM_SET_USER_MEMORY_REGION */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>kvm_userspace_memory_region</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>__u32</span> <span class=n>slot</span><span class=p>;</span>            <span class=c1>// slot 编号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__u32</span> <span class=n>flags</span><span class=p>;</span>           <span class=c1>// 标志位，例如是否追踪脏页、是否可用等
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__u64</span> <span class=n>guest_phys_addr</span><span class=p>;</span> <span class=c1>// Guest 物理地址，GPA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__u64</span> <span class=n>memory_size</span><span class=p>;</span>     <span class=c1>// 内存大小，bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__u64</span> <span class=n>userspace_addr</span><span class=p>;</span>  <span class=c1>// 从 QEMU 进程空间分配的起始地址，HVA
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h3 id=memorylistener>MemoryListener<a hidden class=anchor aria-hidden=true href=#memorylistener>#</a></h3><h4 id=结构体定义-5>结构体定义<a hidden class=anchor aria-hidden=true href=#结构体定义-5>#</a></h4><p>为了监控虚拟机的物理地址访问，对于每一个 <code>AddressSpace</code>，都会有一个 <code>MemoryListener</code> 与之对应。每当物理映射<code>GPA->HVA</code>发生改变时，就会回调这些函数。<strong>MemoryListener</strong> 是对一些事件的<strong>回调函数合集</strong>，在<code>memory.h</code>中定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * MemoryListener: callbacks structure for updates to the physical memory map
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * Allows a component to adjust to changes in the guest-visible memory map.
</span></span></span><span class=line><span class=cl><span class=cm> * Use with memory_listener_register() and memory_listener_unregister().
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>MemoryListener</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>begin</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>commit</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>region_add</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>,</span> <span class=n>MemoryRegionSection</span> <span class=o>*</span><span class=n>section</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>region_del</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>,</span> <span class=n>MemoryRegionSection</span> <span class=o>*</span><span class=n>section</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>region_nop</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>,</span> <span class=n>MemoryRegionSection</span> <span class=o>*</span><span class=n>section</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>log_start</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>,</span> <span class=n>MemoryRegionSection</span> <span class=o>*</span><span class=n>section</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>log_stop</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>,</span> <span class=n>MemoryRegionSection</span> <span class=o>*</span><span class=n>section</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>log_sync</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>,</span> <span class=n>MemoryRegionSection</span> <span class=o>*</span><span class=n>section</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>log_global_start</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>log_global_stop</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>eventfd_add</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>,</span> <span class=n>MemoryRegionSection</span> <span class=o>*</span><span class=n>section</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=kt>bool</span> <span class=n>match_data</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>data</span><span class=p>,</span> <span class=n>EventNotifier</span> <span class=o>*</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>eventfd_del</span><span class=p>)(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>,</span> <span class=n>MemoryRegionSection</span> <span class=o>*</span><span class=n>section</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=kt>bool</span> <span class=n>match_data</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>data</span><span class=p>,</span> <span class=n>EventNotifier</span> <span class=o>*</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Lower = earlier (during add), later (during del) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>priority</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>address_space_filter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>QTAILQ_ENTRY</span><span class=p>(</span><span class=n>MemoryListener</span><span class=p>)</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h4 id=全局变量-memory_listeners>全局变量 memory_listeners<a hidden class=anchor aria-hidden=true href=#全局变量-memory_listeners>#</a></h4><p>所有的 <code>MemoryListener</code> 都会挂在全局变量<code>memory_listeners</code>链表上，在<code>memory.c</code>中定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=nf>QTAILQ_HEAD</span><span class=p>(,</span> <span class=n>MemoryListener</span><span class=p>)</span> <span class=n>memory_listeners</span>
</span></span><span class=line><span class=cl>    <span class=o>=</span> <span class=nf>QTAILQ_HEAD_INITIALIZER</span><span class=p>(</span><span class=n>memory_listeners</span><span class=p>);</span>
</span></span></code></pre></div><p>在<code>memory.c</code>中枚举了<code>ListenerDirection</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>enum</span> <span class=n>ListenerDirection</span> <span class=p>{</span> <span class=n>Forward</span><span class=p>,</span> <span class=n>Reverse</span> <span class=p>};</span>
</span></span></code></pre></div><h3 id=重要数据结构总览>重要数据结构总览<a hidden class=anchor aria-hidden=true href=#重要数据结构总览>#</a></h3><table><thead><tr><th style=text-align:center>结构体名</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:center>AddressSpace</td><td style=text-align:left>VM 能看到的一段地址空间，偏向 Host 侧【注意指的是偏向】</td></tr><tr><td style=text-align:center>MemoryRegion</td><td style=text-align:left>地址空间中一段逻辑层面的内存区域，偏向 Guest 侧</td></tr><tr><td style=text-align:center>RAMBlock</td><td style=text-align:left>记录实际分配的内存地址信息，存储了 GPA->HVA 的映射关系</td></tr><tr><td style=text-align:center>FlatView</td><td style=text-align:left>MemoryRegion 对应的平面展开视图，包含一个 FlatRange 类型的 ranges 数组</td></tr><tr><td style=text-align:center>FlatRange</td><td style=text-align:left>对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中</td></tr><tr><td style=text-align:center>MemoryRegionSection</td><td style=text-align:left>表示 MemoryRegion 中的片段</td></tr><tr><td style=text-align:center>MemoryListener</td><td style=text-align:left>回调函数集合</td></tr><tr><td style=text-align:center>KVMSlot</td><td style=text-align:left>KVM 中内存管理的基本单位，表示一个内存插槽</td></tr><tr><td style=text-align:center>kvm_userspace_memory_region</td><td style=text-align:left>调用 ioctl(KVM_SET_USER_MEMORY_REGION) 时需要向 KVM 传递的参数</td></tr></tbody></table><h2 id=具体实现机制>具体实现机制<a hidden class=anchor aria-hidden=true href=#具体实现机制>#</a></h2><p>QEMU 的内存申请流程大致可分为三个部分：回调函数的注册、AddressSpace 的初始化、实际内存的分配。下面将根据在 vl.c 的 main() 函数中的调用顺序分别介绍。</p><h3 id=回调函数的注册>回调函数的注册<a hidden class=anchor aria-hidden=true href=#回调函数的注册>#</a></h3><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125133808.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125133808.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=err>└─</span> <span class=k>static</span> <span class=kt>int</span> <span class=nf>configure_accelerator</span><span class=p>()</span>
</span></span><span class=line><span class=cl>       <span class=err>└─</span> <span class=kt>int</span> <span class=nf>kvm_init</span><span class=p>()</span>                                     <span class=c1>// 初始化 KVM
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=err>├─</span> <span class=kt>int</span> <span class=nf>kvm_ioctl</span><span class=p>(</span><span class=n>KVM_CREATE_VM</span><span class=p>)</span>                  <span class=c1>// 创建 VM
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=err>├─</span> <span class=kt>int</span> <span class=nf>kvm_arch_init</span><span class=p>()</span>                           <span class=c1>// 针对不同的架构进行初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=err>└─</span> <span class=kt>void</span> <span class=nf>memory_listener_register</span><span class=p>()</span>               <span class=c1>// 注册 kvm_memory_listener
</span></span></span><span class=line><span class=cl><span class=c1></span>                 <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>listener_add_address_space</span><span class=p>()</span> <span class=c1>// 调用 region_add 回调
</span></span></span><span class=line><span class=cl><span class=c1></span>                      <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>kvm_region_add</span><span class=p>()</span>        <span class=c1>// region_add 对应的回调实现
</span></span></span><span class=line><span class=cl><span class=c1></span>                           <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>kvm_set_phys_mem</span><span class=p>()</span> <span class=c1>// 根据传入的 section 填充 KVMSlot
</span></span></span><span class=line><span class=cl><span class=c1></span>                                <span class=err>└─</span> <span class=k>static</span> <span class=kt>int</span> <span class=nf>kvm_set_user_memory_region</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                                     <span class=err>└─</span> <span class=kt>int</span> <span class=nf>ioctl</span><span class=p>(</span><span class=n>KVM_SET_USER_MEMORY_REGION</span><span class=p>)</span>
</span></span></code></pre></div><p>进入<code>configure_accelerator()</code>后，<code>QEMU</code>会先调用<code>configure_accelerator()</code>设置 <code>KVM</code> 的加速支持，之后进入<code>kvm_init()</code>。该函数主要完成对 KVM 的初始化，包括一些常规检查如 <code>CPU</code> 个数、<code>KVM</code> 版本等，之后通过<code>kvm_ioctl(KVM_CREATE_VM)</code>与内核交互，创建 <code>KVM</code> 虚拟机。在<code>kvm_init()</code>的最后，会调用<code>memory_listener_register()</code>注册<code>kvm_memory_listener</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>kvm_init</span><span class=p>(</span><span class=n>MachineState</span> <span class=o>*</span><span class=n>ms</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MachineClass</span> <span class=o>*</span><span class=n>mc</span> <span class=o>=</span> <span class=nf>MACHINE_GET_CLASS</span><span class=p>(</span><span class=n>ms</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 打开/dev/kvm
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>s</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=nf>qemu_open_old</span><span class=p>(</span><span class=s>&#34;/dev/kvm&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建 VM
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nf>kvm_ioctl</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>KVM_CREATE_VM</span><span class=p>,</span> <span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=n>EINTR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=nf>kvm_arch_init</span><span class=p>(</span><span class=n>s</span><span class=p>);</span> <span class=c1>// 针对不同的架构进行初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 对于以下 AddressSpace，设置其对应的 listener
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>kvm_memory_listener_register</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>memory_listener</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=o>&amp;</span><span class=n>address_space_memory</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=s>&#34;kvm-memory&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>memory_listener_register</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kvm_coalesced_pio_listener</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=o>&amp;</span><span class=n>address_space_io</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>memory_listener_register</span><span class=p>(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>,</span> <span class=n>AddressSpace</span> <span class=o>*</span><span class=n>as</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryListener</span> <span class=o>*</span><span class=n>other</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Only one of them can be defined for a listener */</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>listener</span><span class=o>-&gt;</span><span class=n>log_sync</span> <span class=o>&amp;&amp;</span> <span class=n>listener</span><span class=o>-&gt;</span><span class=n>log_sync_global</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>listener</span><span class=o>-&gt;</span><span class=n>address_space</span> <span class=o>=</span> <span class=n>as</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>QTAILQ_EMPTY</span><span class=p>(</span><span class=o>&amp;</span><span class=n>memory_listeners</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>||</span> <span class=n>listener</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;=</span> <span class=nf>QTAILQ_LAST</span><span class=p>(</span><span class=o>&amp;</span><span class=n>memory_listeners</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>QTAILQ_INSERT_TAIL</span><span class=p>(</span><span class=o>&amp;</span><span class=n>memory_listeners</span><span class=p>,</span> <span class=n>listener</span><span class=p>,</span> <span class=n>link</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>QTAILQ_FOREACH</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>memory_listeners</span><span class=p>,</span> <span class=n>link</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>listener</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&lt;</span> <span class=n>other</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>QTAILQ_INSERT_BEFORE</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>listener</span><span class=p>,</span> <span class=n>link</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>QTAILQ_EMPTY</span><span class=p>(</span><span class=o>&amp;</span><span class=n>as</span><span class=o>-&gt;</span><span class=n>listeners</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>||</span> <span class=n>listener</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&gt;=</span> <span class=nf>QTAILQ_LAST</span><span class=p>(</span><span class=o>&amp;</span><span class=n>as</span><span class=o>-&gt;</span><span class=n>listeners</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>QTAILQ_INSERT_TAIL</span><span class=p>(</span><span class=o>&amp;</span><span class=n>as</span><span class=o>-&gt;</span><span class=n>listeners</span><span class=p>,</span> <span class=n>listener</span><span class=p>,</span> <span class=n>link_as</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>QTAILQ_FOREACH</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>as</span><span class=o>-&gt;</span><span class=n>listeners</span><span class=p>,</span> <span class=n>link_as</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>listener</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&lt;</span> <span class=n>other</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>QTAILQ_INSERT_BEFORE</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>listener</span><span class=p>,</span> <span class=n>link_as</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>listener_add_address_space</span><span class=p>(</span><span class=n>listener</span><span class=p>,</span> <span class=n>as</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最后的<code>listener_add_address_space()</code>主要是将 listener 注册到其对应的 <code>AddressSpace</code> 上，并根据 <code>AddressSpace</code> 对应的 <code>FlatRange</code> 数组，生成 <code>MemoryRegionSection</code>【<code>MemoryRegionSection</code>就像是为<code>FlatRange</code>数组设置的一种中介表示，便于传入<code>KVM</code>，因为传入<code>KVM</code>应该是对平坦内存的一种表示】，并注册到 <code>KVM</code> 中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>listener_add_address_space</span><span class=p>(</span><span class=n>MemoryListener</span> <span class=o>*</span><span class=n>listener</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                       <span class=n>AddressSpace</span> <span class=o>*</span><span class=n>as</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FlatView</span> <span class=o>*</span><span class=n>view</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FlatRange</span> <span class=o>*</span><span class=n>fr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>listener</span><span class=o>-&gt;</span><span class=n>begin</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>listener</span><span class=o>-&gt;</span><span class=nf>begin</span><span class=p>(</span><span class=n>listener</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 开启内存脏页记录 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>global_dirty_tracking</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>listener</span><span class=o>-&gt;</span><span class=n>log_global_start</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>listener</span><span class=o>-&gt;</span><span class=nf>log_global_start</span><span class=p>(</span><span class=n>listener</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 遍历 AddressSpace 对应的 FlatRange 数组，并将其转换成 MemoryRegionSection */</span>
</span></span><span class=line><span class=cl>    <span class=n>view</span> <span class=o>=</span> <span class=nf>address_space_get_flatview</span><span class=p>(</span><span class=n>as</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>FOR_EACH_FLAT_RANGE</span><span class=p>(</span><span class=n>fr</span><span class=p>,</span> <span class=n>view</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>MemoryRegionSection</span> <span class=n>section</span> <span class=o>=</span> <span class=nf>section_from_flat_range</span><span class=p>(</span><span class=n>fr</span><span class=p>,</span> <span class=n>view</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 将 section 所代表的内存区域注册到 KVM 中 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>listener</span><span class=o>-&gt;</span><span class=n>region_add</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>listener</span><span class=o>-&gt;</span><span class=nf>region_add</span><span class=p>(</span><span class=n>listener</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>section</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>fr</span><span class=o>-&gt;</span><span class=n>dirty_log_mask</span> <span class=o>&amp;&amp;</span> <span class=n>listener</span><span class=o>-&gt;</span><span class=n>log_start</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>listener</span><span class=o>-&gt;</span><span class=nf>log_start</span><span class=p>(</span><span class=n>listener</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>section</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>fr</span><span class=o>-&gt;</span><span class=n>dirty_log_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>listener</span><span class=o>-&gt;</span><span class=n>commit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>listener</span><span class=o>-&gt;</span><span class=nf>commit</span><span class=p>(</span><span class=n>listener</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>flatview_unref</span><span class=p>(</span><span class=n>view</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由于此时 <code>AddressSapce</code> 尚未初始化，所以此处的循环为空，仅是在全局注册了<code>kvm_memory_listener</code>。最后调用了<code>kvm_memory_listener->region_add()</code>，对应的实现是<code>kvm_region_add()</code>，该函数最终会通过<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>，将 <code>QEMU</code> 侧申请的内存信息传入 <code>KVM</code> 进行注册，这里的流程会在下一部分进行分析。</p><h3 id=addressspace-的初始化>AddressSpace 的初始化<a hidden class=anchor aria-hidden=true href=#addressspace-的初始化>#</a></h3><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125154841.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125154841.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=err>└─</span> <span class=kt>void</span> <span class=nf>cpu_exec_init_all</span><span class=p>()</span>
</span></span><span class=line><span class=cl>       <span class=err>├─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>memory_map_init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>       <span class=o>|</span>    <span class=err>├─</span> <span class=kt>void</span> <span class=nf>memory_region_init</span><span class=p>()</span>    <span class=c1>// 初始化 system_memory/io 这两个全局 MemoryRegion
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=o>|</span>    <span class=err>├─</span> <span class=kt>void</span> <span class=nf>set_system_memory_map</span><span class=p>()</span> <span class=c1>// address_space_memory-&gt;root = system_memory
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=o>|</span>    <span class=o>|</span>    <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>memory_region_update_topology</span><span class=p>()</span>        <span class=c1>// 为 MemoryRegion 生成 FlatView
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=o>|</span>    <span class=o>|</span>         <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>address_space_update_topology</span><span class=p>()</span>   <span class=c1>// as-&gt;current_map = new_view
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=o>|</span>    <span class=o>|</span>              <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>address_space_update_topology_pass</span><span class=p>()</span>
</span></span><span class=line><span class=cl>       <span class=o>|</span>    <span class=o>|</span>                   <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>kvm_region_add</span><span class=p>()</span>        <span class=c1>// region_add 对应的回调实现
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=o>|</span>    <span class=o>|</span>                        <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>kvm_set_phys_mem</span><span class=p>()</span> <span class=c1>// 根据传入的 section 填充 KVMSlot
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=o>|</span>    <span class=o>|</span>                             <span class=err>└─</span> <span class=k>static</span> <span class=kt>int</span> <span class=nf>kvm_set_user_memory_region</span><span class=p>()</span>
</span></span><span class=line><span class=cl>       <span class=o>|</span>    <span class=o>|</span>                                  <span class=err>└─</span> <span class=kt>int</span> <span class=nf>ioctl</span><span class=p>(</span><span class=n>KVM_SET_USER_MEMORY_REGION</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=o>|</span>    <span class=o>|</span>
</span></span><span class=line><span class=cl>       <span class=o>|</span>    <span class=err>└─</span> <span class=kt>void</span> <span class=nf>memory_listener_register</span><span class=p>()</span> <span class=c1>// 注册对应的 MemoryListener
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=o>|</span>         <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>listener_add_address_space</span><span class=p>()</span>
</span></span><span class=line><span class=cl>       <span class=o>|</span>
</span></span><span class=line><span class=cl>       <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>io_mem_init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=err>└─</span> <span class=kt>void</span> <span class=nf>memory_region_init_io</span><span class=p>()</span> <span class=c1>// ram/rom/unassigned/notdirty/subpage-ram/watch
</span></span></span><span class=line><span class=cl><span class=c1></span>                 <span class=err>└─</span> <span class=kt>void</span> <span class=nf>memory_region_init</span><span class=p>()</span>
</span></span></code></pre></div><p>第一部分在全局注册了<code>kvm_memory_listener</code>，但由于<code>AddressSpace</code> 尚未初始化，实际上并未向 <code>KVM</code> 中注册任何实际的内存信息。<code>QEMU</code> 在<code>main()</code>函数中会继续调用<code>cpu_exec_init_all()</code>对<code>AddressSpace</code>进行初始化，该函数实际上是对两个 <code>init</code> 函数的封装调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cpu_exec_init_all</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>qemu_mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ram_list</span><span class=p>.</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* The data structures we set up here depend on knowing the page size,
</span></span></span><span class=line><span class=cl><span class=cm>     * so no more changes can be made after this point.
</span></span></span><span class=line><span class=cl><span class=cm>     * In an ideal world, nothing we did before we had finished the
</span></span></span><span class=line><span class=cl><span class=cm>     * machine setup would care about the target page size, and we could
</span></span></span><span class=line><span class=cl><span class=cm>     * do this much later, rather than requiring board models to state
</span></span></span><span class=line><span class=cl><span class=cm>     * up front what their requirements are.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nf>finalize_target_page_bits</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>io_mem_init</span><span class=p>();</span>      <span class=c1>// 初始化六个I/O MemoryRegion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memory_map_init</span><span class=p>();</span> <span class=c1>// 初始化两个全局 AddressSpace，以及对应的 MemoryRegion、FlatView
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>qemu_mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>map_client_list_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>先来看<code>memory_map_init()</code>，主要用来初始化两个全局的系统地址空间<code>system_memory</code>、<code>system_io</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>memory_map_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>system_memory</span> <span class=o>=</span> <span class=nf>g_malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>system_memory</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 初始化 system_memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memory_region_init</span><span class=p>(</span><span class=n>system_memory</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=s>&#34;system&#34;</span><span class=p>,</span> <span class=n>UINT64_MAX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 设置 address_space_memory 关联 system_memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 这两个都是全局变量，也就是把内存地址空间和 IO 地址空间于对应的 MemoryRegion 联系起来 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//及其对应的 FlatView
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>address_space_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>address_space_memory</span><span class=p>,</span> <span class=n>system_memory</span><span class=p>,</span> <span class=s>&#34;memory&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>system_io</span> <span class=o>=</span> <span class=nf>g_malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>system_io</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 初始化 system_io  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memory_region_init_io</span><span class=p>(</span><span class=n>system_io</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>unassigned_io_ops</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=s>&#34;io&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=mi>65536</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 设置 address_space_io 关联 system_io 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 及其对应的 FlatView
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>address_space_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>address_space_io</span><span class=p>,</span> <span class=n>system_io</span><span class=p>,</span> <span class=s>&#34;I/O&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里比较重要的是<code>address_space_init()</code>，先设置 <code>AddressSpace</code> 对应的 <code>MemoryRegion</code>，之后根据<code>system_memory</code>更新<code>address_space_memory</code>对应的 <code>FlatView</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>address_space_init</span><span class=p>(</span><span class=n>AddressSpace</span> <span class=o>*</span><span class=n>as</span><span class=p>,</span> <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>root</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>memory_region_ref</span><span class=p>(</span><span class=n>root</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将 address_space_memory 的 root 域指向 system_memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>as</span><span class=o>-&gt;</span><span class=n>root</span> <span class=o>=</span> <span class=n>root</span><span class=p>;</span>        
</span></span><span class=line><span class=cl>    <span class=n>as</span><span class=o>-&gt;</span><span class=n>current_map</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>as</span><span class=o>-&gt;</span><span class=n>ioeventfd_nb</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>as</span><span class=o>-&gt;</span><span class=n>ioeventfds</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>QTAILQ_INIT</span><span class=p>(</span><span class=o>&amp;</span><span class=n>as</span><span class=o>-&gt;</span><span class=n>listeners</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>QTAILQ_INSERT_TAIL</span><span class=p>(</span><span class=o>&amp;</span><span class=n>address_spaces</span><span class=p>,</span> <span class=n>as</span><span class=p>,</span> <span class=n>address_spaces_link</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>as</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=nf>g_strdup</span><span class=p>(</span><span class=n>name</span> <span class=o>?</span> <span class=nl>name</span> <span class=p>:</span> <span class=s>&#34;anonymous&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 根据 system_memory 更新 address_space_memory 对应的 FlatView
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>address_space_update_topology</span><span class=p>(</span><span class=n>as</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=nf>address_space_update_ioeventfds</span><span class=p>(</span><span class=n>as</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>address_space_update_topology()</code>会继续调用<code>generate_memory_topology()</code>生成 <code>AddressSpace</code> 对应的 <code>FlatView</code>视图：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>address_space_update_topology</span><span class=p>(</span><span class=n>AddressSpace</span> <span class=o>*</span><span class=n>as</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>physmr</span> <span class=o>=</span> <span class=nf>memory_region_get_flatview_root</span><span class=p>(</span><span class=n>as</span><span class=o>-&gt;</span><span class=n>root</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>flatviews_init</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>g_hash_table_lookup</span><span class=p>(</span><span class=n>flat_views</span><span class=p>,</span> <span class=n>physmr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>generate_memory_topology</span><span class=p>(</span><span class=n>physmr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>address_space_set_flatview</span><span class=p>(</span><span class=n>as</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>address_space_update_topology()</code>会先调用<code>generate_memory_topology()</code>生成<code>system_memory</code>更新后的视图<code>new_view</code>，再将<code>address_space_memory</code>的<code>current_map</code>指向这个<code>new_view</code>，最后销毁<code>old_view</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>address_space_set_flatview</span><span class=p>(</span><span class=n>AddressSpace</span> <span class=o>*</span><span class=n>as</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FlatView</span> <span class=o>*</span><span class=n>old_view</span> <span class=o>=</span> <span class=nf>address_space_to_flatview</span><span class=p>(</span><span class=n>as</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>physmr</span> <span class=o>=</span> <span class=nf>memory_region_get_flatview_root</span><span class=p>(</span><span class=n>as</span><span class=o>-&gt;</span><span class=n>root</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>FlatView</span> <span class=o>*</span><span class=n>new_view</span> <span class=o>=</span> <span class=nf>g_hash_table_lookup</span><span class=p>(</span><span class=n>flat_views</span><span class=p>,</span> <span class=n>physmr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=n>new_view</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>old_view</span> <span class=o>==</span> <span class=n>new_view</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>old_view</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>flatview_ref</span><span class=p>(</span><span class=n>old_view</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>flatview_ref</span><span class=p>(</span><span class=n>new_view</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>QTAILQ_EMPTY</span><span class=p>(</span><span class=o>&amp;</span><span class=n>as</span><span class=o>-&gt;</span><span class=n>listeners</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>FlatView</span> <span class=n>tmpview</span> <span class=o>=</span> <span class=p>{</span> <span class=p>.</span><span class=n>nr</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>},</span> <span class=o>*</span><span class=n>old_view2</span> <span class=o>=</span> <span class=n>old_view</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>old_view2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>old_view2</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>tmpview</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>address_space_update_topology_pass</span><span class=p>(</span><span class=n>as</span><span class=p>,</span> <span class=n>old_view2</span><span class=p>,</span> <span class=n>new_view</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>address_space_update_topology_pass</span><span class=p>(</span><span class=n>as</span><span class=p>,</span> <span class=n>old_view2</span><span class=p>,</span> <span class=n>new_view</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Writes are protected by the BQL.  */</span>
</span></span><span class=line><span class=cl>    <span class=nf>qatomic_rcu_set</span><span class=p>(</span><span class=o>&amp;</span><span class=n>as</span><span class=o>-&gt;</span><span class=n>current_map</span><span class=p>,</span> <span class=n>new_view</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>old_view</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>flatview_unref</span><span class=p>(</span><span class=n>old_view</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Note that all the old MemoryRegions are still alive up to this
</span></span></span><span class=line><span class=cl><span class=cm>     * point.  This relieves most MemoryListeners from the need to
</span></span></span><span class=line><span class=cl><span class=cm>     * ref/unref the MemoryRegions they get---unless they use them
</span></span></span><span class=line><span class=cl><span class=cm>     * outside the iothread mutex, in which case precise reference
</span></span></span><span class=line><span class=cl><span class=cm>     * counting is necessary.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>old_view</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>flatview_unref</span><span class=p>(</span><span class=n>old_view</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在<code>address_space_update_topology_pass()</code>的最后，会调用<code>MEMORY_LISTENER_UPDATE_REGION</code>这个宏，触发<code>region_add</code>对应的回调函数<code>kvm_region_add()</code>。</p><p>这个宏在<code>memory.c</code>中定义，会将 <code>FlatView</code> 中的 <code>FlatRange</code> 转换为 <code>MemoryRegionSection</code>，作为入参传递给<code>kvm_region_add()</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* No need to ref/unref .mr, the FlatRange keeps it alive.  */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...)  \
</span></span></span><span class=line><span class=cl><span class=cp>    do {                                                                \
</span></span></span><span class=line><span class=cl><span class=cp>        MemoryRegionSection mrs = section_from_flat_range(fr,           \
</span></span></span><span class=line><span class=cl><span class=cp>                address_space_to_flatview(as));                         \
</span></span></span><span class=line><span class=cl><span class=cp>        MEMORY_LISTENER_CALL(as, callback, dir, &amp;mrs, ##_args);         \
</span></span></span><span class=line><span class=cl><span class=cp>    } while(0)
</span></span></span></code></pre></div><p>而<code>kvm_region_add()</code>实际上是对<code>kvm_set_phys_mem()</code>的封装调用。该函数比较复杂，会根据传入的<code>section</code>填充 KVMSlot，再传递给<code>kvm_set_user_memory_region()</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>kvm_set_user_memory_region</span><span class=p>(</span><span class=n>KVMMemoryListener</span> <span class=o>*</span><span class=n>kml</span><span class=p>,</span> <span class=n>KVMSlot</span> <span class=o>*</span><span class=n>slot</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>new</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>KVMState</span> <span class=o>*</span><span class=n>s</span> <span class=o>=</span> <span class=n>kvm_state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>kvm_userspace_memory_region</span> <span class=n>mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 根据 KVMSlot 填充 kvm_userspace_memory_region
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mem</span><span class=p>.</span><span class=n>slot</span> <span class=o>=</span> <span class=n>slot</span><span class=o>-&gt;</span><span class=n>slot</span> <span class=o>|</span> <span class=p>(</span><span class=n>kml</span><span class=o>-&gt;</span><span class=n>as_id</span> <span class=o>&lt;&lt;</span> <span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mem</span><span class=p>.</span><span class=n>guest_phys_addr</span> <span class=o>=</span> <span class=n>slot</span><span class=o>-&gt;</span><span class=n>start_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mem</span><span class=p>.</span><span class=n>userspace_addr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>slot</span><span class=o>-&gt;</span><span class=n>ram</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mem</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=n>slot</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>slot</span><span class=o>-&gt;</span><span class=n>memory_size</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>new</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>mem</span><span class=p>.</span><span class=n>flags</span> <span class=o>^</span> <span class=n>slot</span><span class=o>-&gt;</span><span class=n>old_flags</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>KVM_MEM_READONLY</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Set the slot size to 0 before setting the slot to the desired
</span></span></span><span class=line><span class=cl><span class=cm>         * value. This is needed based on KVM commit 75d61fbc. */</span>
</span></span><span class=line><span class=cl>        <span class=n>mem</span><span class=p>.</span><span class=n>memory_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>=</span> <span class=nf>kvm_vm_ioctl</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>KVM_SET_USER_MEMORY_REGION</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>mem</span><span class=p>.</span><span class=n>memory_size</span> <span class=o>=</span> <span class=n>slot</span><span class=o>-&gt;</span><span class=n>memory_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=nf>kvm_vm_ioctl</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>KVM_SET_USER_MEMORY_REGION</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>slot</span><span class=o>-&gt;</span><span class=n>old_flags</span> <span class=o>=</span> <span class=n>mem</span><span class=p>.</span><span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到这里又将 <code>KVMSlot</code> 转换为 <code>kvm_userspace_memory_region</code>，作为<code>ioctl()</code>的参数，交给内核中的 <code>KVM</code> 进行内存的注册【设置<code>GPA->HVA</code>的映射关系，在内核空间维护并管理 Guest 的内存】。</p><p>至此 QEMU 侧负责管理内存的数据结构均已完成初始化，<strong>可以参考下面的图片了解各数据结构之间的对应关系</strong></p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127155506.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127155506.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h3 id=实际内存的分配>实际内存的分配<a hidden class=anchor aria-hidden=true href=#实际内存的分配>#</a></h3><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127160121.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127160121.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=err>└─</span> <span class=kt>void</span> <span class=n>machine</span><span class=o>-&gt;</span><span class=nf>init</span><span class=p>(</span><span class=n>ram_size</span><span class=p>,</span> <span class=p>...)</span>
</span></span><span class=line><span class=cl>       <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>pc_init_pci</span><span class=p>(</span><span class=n>ram_size</span><span class=p>,</span> <span class=p>...)</span> <span class=c1>// 初始化虚拟机
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>pc_init1</span><span class=p>(</span><span class=n>system_memory</span><span class=p>,</span> <span class=n>system_io</span><span class=p>,</span> <span class=n>ram_size</span><span class=p>,</span> <span class=p>...)</span>
</span></span><span class=line><span class=cl>                 <span class=err>├─</span> <span class=kt>void</span> <span class=nf>memory_region_init</span><span class=p>(</span><span class=n>pci_memory</span><span class=p>,</span> <span class=s>&#34;pci&#34;</span><span class=p>,</span> <span class=p>...)</span> <span class=c1>// pci_memory, rom_memory
</span></span></span><span class=line><span class=cl><span class=c1></span>                 <span class=err>└─</span> <span class=kt>void</span> <span class=nf>pc_memory_init</span><span class=p>()</span> <span class=c1>// 初始化内存，分配实际的物理内存地址
</span></span></span><span class=line><span class=cl><span class=c1></span>                      <span class=err>├─</span> <span class=kt>void</span> <span class=nf>memory_region_init_ram</span><span class=p>()</span> <span class=c1>// 创建 pc.ram, pc.rom 并分配内存
</span></span></span><span class=line><span class=cl><span class=c1></span>                      <span class=o>|</span>    <span class=err>├─</span> <span class=kt>void</span> <span class=nf>memory_region_init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                      <span class=o>|</span>    <span class=err>└─</span> <span class=kt>ram_addr_t</span> <span class=nf>qemu_ram_alloc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                      <span class=o>|</span>         <span class=err>└─</span> <span class=kt>ram_addr_t</span> <span class=nf>qemu_ram_alloc_from_ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                      <span class=o>|</span>
</span></span><span class=line><span class=cl>                      <span class=err>├─</span> <span class=kt>void</span> <span class=nf>vmstate_register_ram_global</span><span class=p>()</span> <span class=c1>// 将 MR 的 name 写入 RAMBlock 的 idstr
</span></span></span><span class=line><span class=cl><span class=c1></span>                      <span class=o>|</span>    <span class=err>└─</span> <span class=kt>void</span> <span class=nf>vmstate_register_ram</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                      <span class=o>|</span>         <span class=err>└─</span> <span class=kt>void</span> <span class=nf>qemu_ram_set_idstr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                      <span class=o>|</span>
</span></span><span class=line><span class=cl>                      <span class=err>├─</span> <span class=kt>void</span> <span class=nf>memory_region_init_alias</span><span class=p>()</span>    <span class=c1>// 初始化 ram_below_4g, ram_above_4g
</span></span></span><span class=line><span class=cl><span class=c1></span>                      <span class=err>└─</span> <span class=kt>void</span> <span class=nf>memory_region_add_subregion</span><span class=p>()</span> <span class=c1>// 在 system_memory 中添加 subregions
</span></span></span><span class=line><span class=cl><span class=c1></span>                           <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>memory_region_add_subregion_common</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                                <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>memory_region_update_topology</span><span class=p>()</span> <span class=c1>// 为 MemoryRegion 生成 FlatView
</span></span></span><span class=line><span class=cl><span class=c1></span>                                     <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>address_space_update_topology</span><span class=p>()</span> <span class=c1>// as-&gt;current_map = new_view
</span></span></span><span class=line><span class=cl><span class=c1></span>                                          <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>address_space_update_topology_pass</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                                               <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>kvm_region_add</span><span class=p>()</span> <span class=c1>// region_add 对应的回调实现
</span></span></span><span class=line><span class=cl><span class=c1></span>                                                    <span class=err>└─</span> <span class=k>static</span> <span class=kt>void</span> <span class=nf>kvm_set_phys_mem</span><span class=p>()</span> <span class=c1>// 根据传入的 section 填充 KVMSlot
</span></span></span><span class=line><span class=cl><span class=c1></span>                                                         <span class=err>└─</span> <span class=k>static</span> <span class=kt>int</span> <span class=nf>kvm_set_user_memory_region</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                                                              <span class=err>└─</span> <span class=kt>int</span> <span class=nf>ioctl</span><span class=p>(</span><span class=n>KVM_SET_USER_MEMORY_REGION</span><span class=p>)</span>
</span></span></code></pre></div><p>之前的回调函数注册、AddressSpace 的初始化，实际上均没有对应的物理内存。【实际的内存是在 RAMBlock 中】</p><p>我们再回到 <code>qemu</code> 启动的 <code>main</code> 函数中。接下来的初始化过程会调用 <code>pc_init1</code>。在这里面，对于 <code>CPU</code> 虚拟化，我们会调用 <code>pc_cpus_init</code>。另外，<code>pc_init1</code> 还会调用<code>pc_memory_init</code>，进行内存的虚拟化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>pc_memory_init</span><span class=p>(</span><span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>system_memory</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>kernel_filename</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>kernel_cmdline</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>initrd_filename</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=kt>ram_addr_t</span> <span class=n>below_4g_mem_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=kt>ram_addr_t</span> <span class=n>above_4g_mem_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>rom_memory</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>MemoryRegion</span> <span class=o>**</span><span class=n>ram_memory</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>ram</span><span class=p>,</span> <span class=o>*</span><span class=n>option_rom_mr</span><span class=p>;</span>         <span class=c1>// 两个实体 MR: pc.ram, pc.rom
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>ram_below_4g</span><span class=p>,</span> <span class=o>*</span><span class=n>ram_above_4g</span><span class=p>;</span> <span class=c1>// 两个别名 MR: ram_below_4g, ram_above_4g
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Allocate RAM.  We allocate it as a single memory region and use
</span></span></span><span class=line><span class=cl><span class=cm>     * aliases to address portions of it, mostly for backwards compatibility
</span></span></span><span class=line><span class=cl><span class=cm>     * with older qemus that used qemu_ram_alloc().
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>ram</span> <span class=o>=</span> <span class=nf>g_malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>ram</span><span class=p>));</span> <span class=c1>// 创建 ram
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 分配具体的内存（实际上会创建一个 RAMBlock 并将其 offset 值写入 ram.ram_addr，对应 GPA）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memory_region_init_ram</span><span class=p>(</span><span class=n>ram</span><span class=p>,</span> <span class=s>&#34;pc.ram&#34;</span><span class=p>,</span> <span class=n>below_4g_mem_size</span> <span class=o>+</span> <span class=n>above_4g_mem_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将 MR 的 name 写入 RAMBlock 的 idstr
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>vmstate_register_ram_global</span><span class=p>(</span><span class=n>ram</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>ram_memory</span> <span class=o>=</span> <span class=n>ram</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建 ram_below_4g 表示 4G 以下的内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ram_below_4g</span> <span class=o>=</span> <span class=nf>g_malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>ram_below_4g</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>memory_region_init_alias</span><span class=p>(</span><span class=n>ram_below_4g</span><span class=p>,</span> <span class=s>&#34;ram-below-4g&#34;</span><span class=p>,</span> <span class=n>ram</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>below_4g_mem_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将 ram_below_4g 挂在 system_memory 下
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memory_region_add_subregion</span><span class=p>(</span><span class=n>system_memory</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>ram_below_4g</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>above_4g_mem_size</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ram_above_4g</span> <span class=o>=</span> <span class=nf>g_malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>ram_above_4g</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=nf>memory_region_init_alias</span><span class=p>(</span><span class=n>ram_above_4g</span><span class=p>,</span> <span class=s>&#34;ram-above-4g&#34;</span><span class=p>,</span> <span class=n>ram</span><span class=p>,</span> <span class=n>below_4g_mem_size</span><span class=p>,</span> <span class=n>above_4g_mem_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>memory_region_add_subregion</span><span class=p>(</span><span class=n>system_memory</span><span class=p>,</span> <span class=mh>0x100000000ULL</span><span class=p>,</span> <span class=n>ram_above_4g</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里的重点在于<code>memory_region_init_ram()</code>，它通过<code>qemu_ram_alloc()</code>获取 ram 这个 <code>MemoryRegion</code> 对应的 <code>RAMBlock</code> 的<code>offset</code>，并存入<code>ram.ram_addr</code>，这样就可以在<code>ram_list</code>中根据该字段查找 <code>MR</code> 对应的 <code>RAMBlock</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>memory_region_init_ram</span><span class=p>(</span><span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>mr</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>memory_region_init</span><span class=p>(</span><span class=n>mr</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span> <span class=c1>// 填充字段，初始化默认值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>ram</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// 表示为 RAM
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>terminates</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// 表示为实体 MemoryRegion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>destructor</span> <span class=o>=</span> <span class=n>memory_region_destructor_ram</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mr</span><span class=o>-&gt;</span><span class=n>ram_addr</span> <span class=o>=</span> <span class=nf>qemu_ram_alloc</span><span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=n>mr</span><span class=p>);</span> <span class=c1>// 这里保存 RAMBlock 的 offset，即 GPA
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>而 qemu_ram_alloc() 最终会调用 qemu_ram_alloc_from_ptr()，创建一个对应大小 RAMBlock 并分配内存，返回对应的 GPA 地址存入 mr->ram_addr 中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>ram_addr_t</span> <span class=nf>qemu_ram_alloc_from_ptr</span><span class=p>(</span><span class=kt>ram_addr_t</span> <span class=n>size</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>host</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=n>MemoryRegion</span> <span class=o>*</span><span class=n>mr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RAMBlock</span> <span class=o>*</span><span class=n>new_block</span><span class=p>;</span> <span class=c1>// 创建一个 RAMBlock
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>size</span> <span class=o>=</span> <span class=nf>TARGET_PAGE_ALIGN</span><span class=p>(</span><span class=n>size</span><span class=p>);</span> <span class=c1>// 页对齐
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>new_block</span> <span class=o>=</span> <span class=nf>g_malloc0</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>new_block</span><span class=p>));</span> <span class=c1>// 初始化 new_block
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>new_block</span><span class=o>-&gt;</span><span class=n>mr</span> <span class=o>=</span> <span class=n>mr</span><span class=p>;</span> <span class=c1>// 将 new_block-&gt; 指向入参的 MemoryRegion
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>new_block</span><span class=o>-&gt;</span><span class=n>offset</span> <span class=o>=</span> <span class=nf>find_ram_offset</span><span class=p>(</span><span class=n>size</span><span class=p>);</span> <span class=c1>// 从 ram_list 中的 RAMBlock 之间找到一段可以满足 size 需求的 gap，并返回起始地址的 offset，对应 GPA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>host</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 新建的 RAMBlock host 字段为空，跳过
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>new_block</span><span class=o>-&gt;</span><span class=n>host</span> <span class=o>=</span> <span class=n>host</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>new_block</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>|=</span> <span class=n>RAM_PREALLOC_MASK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>mem_path</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 未指定 mem_path
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#if defined (__linux__) &amp;&amp; !defined(TARGET_S390X)
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=n>new_block</span><span class=o>-&gt;</span><span class=n>host</span> <span class=o>=</span> <span class=nf>file_ram_alloc</span><span class=p>(</span><span class=n>new_block</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>mem_path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>new_block</span><span class=o>-&gt;</span><span class=n>host</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>new_block</span><span class=o>-&gt;</span><span class=n>host</span> <span class=o>=</span> <span class=nf>qemu_vmalloc</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>qemu_madvise</span><span class=p>(</span><span class=n>new_block</span><span class=o>-&gt;</span><span class=n>host</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>QEMU_MADV_MERGEABLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;-mem-path option unsupported</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>xen_enabled</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>xen_ram_alloc</span><span class=p>(</span><span class=n>new_block</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>mr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>kvm_enabled</span><span class=p>())</span> <span class=p>{</span> <span class=c1>// 从这里继续
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=cm>/* some s390/kvm configurations have special constraints */</span>
</span></span><span class=line><span class=cl>                <span class=n>new_block</span><span class=o>-&gt;</span><span class=n>host</span> <span class=o>=</span> <span class=nf>kvm_vmalloc</span><span class=p>(</span><span class=n>size</span><span class=p>);</span> <span class=c1>// 实际上还是调用 qemu_vmalloc(size)
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>new_block</span><span class=o>-&gt;</span><span class=n>host</span> <span class=o>=</span> <span class=nf>qemu_vmalloc</span><span class=p>(</span><span class=n>size</span><span class=p>);</span> <span class=c1>// 从 QEMU 的线性空间中分配 size 大小的内存，返回 HVA
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nf>qemu_madvise</span><span class=p>(</span><span class=n>new_block</span><span class=o>-&gt;</span><span class=n>host</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>QEMU_MADV_MERGEABLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>new_block</span><span class=o>-&gt;</span><span class=n>length</span> <span class=o>=</span> <span class=n>size</span><span class=p>;</span> <span class=c1>// 将 length 设置为 size
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>QLIST_INSERT_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ram_list</span><span class=p>.</span><span class=n>blocks</span><span class=p>,</span> <span class=n>new_block</span><span class=p>,</span> <span class=n>next</span><span class=p>);</span> <span class=c1>// 将该 RAMBlock 插入 ram_list 头部
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>ram_list</span><span class=p>.</span><span class=n>phys_dirty</span> <span class=o>=</span> <span class=nf>g_realloc</span><span class=p>(</span><span class=n>ram_list</span><span class=p>.</span><span class=n>phys_dirty</span><span class=p>,</span> <span class=c1>// 重新分配 ram_list.phys_dirty 的内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span>                                       <span class=nf>last_ram_offset</span><span class=p>()</span> <span class=o>&gt;&gt;</span> <span class=n>TARGET_PAGE_BITS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>ram_list</span><span class=p>.</span><span class=n>phys_dirty</span> <span class=o>+</span> <span class=p>(</span><span class=n>new_block</span><span class=o>-&gt;</span><span class=n>offset</span> <span class=o>&gt;&gt;</span> <span class=n>TARGET_PAGE_BITS</span><span class=p>),</span>
</span></span><span class=line><span class=cl>           <span class=mi>0</span><span class=p>,</span> <span class=n>size</span> <span class=o>&gt;&gt;</span> <span class=n>TARGET_PAGE_BITS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>cpu_physical_memory_set_dirty_range</span><span class=p>(</span><span class=n>new_block</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=mh>0xff</span><span class=p>);</span> <span class=c1>// 对该 RAMBlock 对应的内存标记为 dirty
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>qemu_ram_setup_dump</span><span class=p>(</span><span class=n>new_block</span><span class=o>-&gt;</span><span class=n>host</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>kvm_enabled</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=nf>kvm_setup_guest_memory</span><span class=p>(</span><span class=n>new_block</span><span class=o>-&gt;</span><span class=n>host</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>new_block</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这样一来<code>ram</code>【其实就是<code>system memory</code>，整个<code>Guest</code>物理空间的大小】对应的 <code>RAMBlock</code> 中就分配好了 <code>GPA</code> 和 <code>HVA</code>，就可以<strong>将内存信息同步至 KVM 侧</strong>了。</p><p>最后回到<code>pc_memory_init()</code>中，在分配完实际内存后，会先调用<code>memory_region_init_alias()</code>初始化<code>ram_below_4g</code>、<code>ram_above_4g</code>这两个<code>alias</code>，之后调用<code>memory_region_add_subregion()</code>将这两个 <code>alias</code> 指向<code>ram</code>这个实体 <code>MemoryRegion</code>。如下图，该函数最终会触发<code>kvm_region_add()</code>回调，将实际的内存信息传入 <code>KVM</code> 注册。该过程如下图所示，与之前分析的流程相同，此处不再赘述。</p><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163205.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163205.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>虚拟机的内存管理也是需要用户态的 <code>qemu</code> 和内核态的 <code>KVM</code> 共同完成。为了加速内存映射，需要借助硬件的 <code>EPT</code> 技术。</p><h3 id=qemu-侧>QEMU 侧<a hidden class=anchor aria-hidden=true href=#qemu-侧>#</a></h3><ul><li><p>创建一系列 <code>MemoryRegion</code>，分别表示 <code>Guest</code> 中的 <code>RAM</code>、<code>ROM</code> 等区域。<code>MemoryRegion</code>之间通过 <code>alias</code> 或 <code>subregions</code> 的方式维护相互之间的关系，从而进一步细化区域的定义</p></li><li><p>对于一个实体 <code>MemoryRegion</code>（非 <code>alias</code>），在初始化内存的过程中 <code>QEMU</code> 会创建它所对应的 <code>RAMBlock</code>。该 <code>RAMBlock</code> 通过调用<code>qemu_ram_alloc_from_ptr()</code>从 <code>QEMU</code> 的进程地址空间中<strong>以 mmap 的方式分配内存</strong>，并负责<strong>维护该 MemoryRegion 对应内存的起始 GPA/HVA/size 等相关信息</strong>【在<code>qemu_ram_alloc_from_ptr</code>中创建的新<code>RAMBlock</code>有<code>offset</code>、<code>host</code>的赋值，即<code>GPA->HVA</code>的对应关系】</p></li><li><p><code>AddressSpace</code> 表示 <code>Guest</code> 的物理地址空间。如果 <code>AddressSpace</code> 中的 <code>MemoryRegion</code> 发生变化，则注册的 <code>listener</code> 会被触发，将所属的 <code>MemoryRegion</code> 树展开生成一维的 <code>FlatView</code>，比较 FlatRange 是否发生了变化。如果是，则调用相应的方法对 <code>MemoryRegionSection</code> 进行检查，更新 <code>QEMU</code> 中的 <code>KVMSlot</code>，同时填充<code>kvm_userspace_memory_region</code>结构体，作为<code>ioctl()</code>的参数更新 <code>KVM</code> 中的<code>kvm_memory_slot</code></p></li></ul><h3 id=kvm-侧>KVM 侧<a hidden class=anchor aria-hidden=true href=#kvm-侧>#</a></h3><ul><li><p>当 <code>QEMU</code> 通过<code>ioctl()</code>创建 <code>vcpu</code> 时，调用<code>kvm_mmu_create()</code>初始化 <code>MMU</code> 相关信息。
当 <code>KVM</code> 要进入 <code>Guest</code> 前，<code>vcpu_enter_guest()=>kvm_mmu_reload()</code>会将根级页表地址加载到 <code>VMCS</code>，让 <code>Guest</code> 使用该页表</p></li><li><p>当发生<code>EPT Violation</code> 时，<code>VM-EXIT</code>到 <code>KVM</code> 中。如果是缺页，则根据 <code>GPA</code> 算出 <code>gfn</code>，再根据 <code>gfn</code> 找到对应的 <code>KVMSlot</code>，从中得到对应的 <code>HVA</code>。然后根据 <code>HVA</code> 算出对应的 <code>pfn</code>，确保该 <code>Page</code> 位于内存中。填好缺失的页之后，需要更新 <code>EPT</code>，完善其中缺少的页表项，逐层补全页表</p></li></ul><p><!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163418.png><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163418.png alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p><blockquote><p>虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即 <code>mmap</code> 分配的虚拟内存空间被访问的时候，先查看 <code>EPT</code> 页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。
如果没有映射过，则虚拟机会通过<code>VM-Exit</code>指令回到宿主机模式，通过 <code>handle_ept_violation</code> 补充页表映射。先是通过 <code>handle_mm_fault</code>为虚拟机的物理内存空间分配真正的物理页面，然后通过 <code>__direct_map</code> 添加 <code>EPT</code> 页表映射。<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Responsive Image</title><style>.post-img-view{text-align:center}.responsive-image{display:block;margin:0 auto}</style></head><body><div class=post-img-view><a data-fancybox=gallery href=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127171031.jpg><img class=responsive-image src=https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127171031.jpg alt style="margin:0 auto"></a></div><script>document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".responsive-image"),t=window.innerHeight/3;e.forEach(function(e){e.style.maxHeight=t+"px"})})</script></body></html></p></blockquote><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><p><a href=http://xudaxian.fun/2020/09/03/QEMU%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>“QEMU 内存空间虚拟化及内存管理” - B10g | FΓom 许大仙</a>
<a href=https://www.cnblogs.com/LoyenWang/p/13943005.html>【原创】Linux 虚拟化 KVM-Qemu 分析（五）之内存虚拟化 - LoyenWang - 博客园</a>
<a href=https://blog.csdn.net/xiongwenwu/article/details/58586013>KVM/Qemu 工作原理系列目录_xiongwenwu 的专栏-CSDN 博客_qemu 目录结构</a>
<a href=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/>QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://lifeislife.cn/tags/qemu/>QEMU</a></li><li><a href=https://lifeislife.cn/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://lifeislife.cn/posts/ssh%E5%8E%9F%E7%90%86/><span class=title>« 上一页</span><br><span>SSH 原理</span>
</a><a class=next href=https://lifeislife.cn/posts/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8/><span class=title>下一页 »</span><br><span>解决 VSCode 配置远程连接，过程试图写入的管道不存在</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on x" href="https://x.com/intent/tweet/?text=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f&amp;hashtags=QEMU%2cLinux"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f&amp;title=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96&amp;summary=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96&amp;source=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f&title=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on whatsapp" href="https://api.whatsapp.com/send?text=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96%20-%20https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on telegram" href="https://telegram.me/share/url?text=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96&amp;url=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on ycombinator" href="https://news.ycombinator.com/submitlink?t=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96&u=https%3a%2f%2flifeislife.cn%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://lifeislife-1.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://lifeislife.cn/>夜云泊</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>