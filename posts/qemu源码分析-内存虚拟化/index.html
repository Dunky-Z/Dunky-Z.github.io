<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8888&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>QEMU 源码分析-内存虚拟化 | PaperMod</title>
<meta name="keywords" content="QEMU, Linux">
<meta name="description" content="1.大部分转载自QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北 2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改 3.部分内容根据自己理解补充添加
概述 我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：
虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间； 虚拟机里面的物理内存（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存； 物理机的虚拟内存（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间； 物理机的物理内存（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。 内存虚拟化的关键在于维护 GPA 到 HVA 的映射关系。
页面分配和映射的两种方式 要搞清楚 QEMU system emulation 的仿真架构，首先对于 Host OS，将 QEMU 作为进程启动，然后对于 QEMU 进程，会仿真各种硬件和运行 Guest OS，在这层 OS 上运行要全系统模拟的应用程序，因此对于 Guest OS 管理的内存要实现到 QEMU 进程的虚拟空间的转换需要 softMMU（即需要对 GPA 到 HVA 进行转换）。从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。
影子页表 Shadow Page Table，SPT 第一种方式就是软件的方式，影子页表（Shadow Page Table）。">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:8888/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:8888/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:8888/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:8888/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:8888/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:8888/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:8888/posts/qemu%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:8888/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:8888/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:8888/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:8888/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:8888/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:8888/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      QEMU 源码分析-内存虚拟化
    </h1>
    <div class="post-meta"><span title='2022-01-25 13:42:11 +0000 UTC'>January 25, 2022</span>&nbsp;·&nbsp;17 min

</div>
  </header> 
  <div class="post-content"><blockquote>
<p>1.大部分转载自<a href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a>
2.原文源码为 QEMU1.2.0，版本较旧，部分源码内容根据 QEMU6.2 版本修改
3.部分内容根据自己理解补充添加</p>
</blockquote>
<h2 id="概述">概述<a hidden class="anchor" aria-hidden="true" href="#概述">#</a></h2>
<p>我们知道操作系统给每个进程分配虚拟内存，通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：</p>
<ul>
<li>虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间；</li>
<li>虚拟机里面的物理内存（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存；</li>
<li>物理机的虚拟内存（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间；</li>
<li>物理机的物理内存（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。</li>
</ul>
<p>内存虚拟化的关键在于维护 <code>GPA</code> 到 <code>HVA</code> 的映射关系。</p>
<h2 id="页面分配和映射的两种方式">页面分配和映射的两种方式<a hidden class="anchor" aria-hidden="true" href="#页面分配和映射的两种方式">#</a></h2>
<p>要搞清楚 QEMU system emulation 的仿真架构，首先对于 Host OS，将 QEMU 作为进程启动，然后对于 QEMU 进程，会仿真各种硬件和运行 Guest OS，在这层 OS 上运行要全系统模拟的应用程序，因此对于 Guest OS 管理的内存要实现到 QEMU 进程的虚拟空间的转换需要 softMMU（即需要对 GPA 到 HVA 进行转换）。从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。</p>
<h3 id="影子页表-shadow-page-tablespt">影子页表 Shadow Page Table，SPT<a hidden class="anchor" aria-hidden="true" href="#影子页表-shadow-page-tablespt">#</a></h3>
<p>第一种方式就是软件的方式，影子页表（Shadow Page Table）。</p>
<p>KVM 通过维护记录 GVA-&gt;HPA 的影子页表 SPT，减少了地址转换带来的开销，可以直接将 GVA 转换为 HPA。</p>
<p>内存映射要通过页表来管理，页表地址应该放在 CR3 寄存器里面。在软件虚拟化的内存转换中，GVA 到 GPA 的转换通过查询 CR3 寄存器来完成，CR3 中保存了 Guest 的页表基地址，然后载入 MMU 中进行地址转换。</p>
<p>在加入了 SPT 技术后，当 Guest 访问 CR3 时，KVM 会捕获到这个操作 EXIT_REASON_CR_ACCESS，之后 KVM 会载入特殊的 CR3 和影子页表，欺骗 Guest 这就是真实的 CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。</p>
<blockquote>
<p>本来的过程是，客户机要通过 cr3 找到客户机的页表，实现从 GVA 到 GPA 的转换，然后在宿主机上，要通过 cr3 找到宿主机的页表，实现从 HVA 到 HPA 的转换。
为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。
在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。</p>
</blockquote>
<p><img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124192700.png" alt=""  />
</p>
<p>为了快速检索 Guest 页表对应的影子页表，KVM 为每个客户机维护了一个 hash 表来进行客户机页表到影子页表之间的映射。对于每一个 Guest 来说，其页目录和页表都有唯一的 GPA，通过页目录/页表的 GPA 就可以在哈希链表中快速地找到对应的影子页目录/页表。</p>
<p>当 Guest 切换进程时，Guest 会把待切换进程的页表基址载入 CR3，而 KVM 将会截获这一特权指令。KVM 在哈希表中找到与此页表基址对应的影子页表基址，载入 Guest CR3，使 Guest 在恢复运行时 CR3 实际指向的是新切换进程对应的影子页表。</p>
<p>影子页表的引入，减少了 GVA-&gt;HPA 的转换开销，但是缺点在于需要为 Guest 的每个进程都维护一个影子页表，这将带来很大的内存开销。同时影子页表的建立是很耗时的，如果 Guest 的进程过多，将导致影子页表频繁切换。</p>
<p>因此 Intel 和 AMD 在此基础上提供了基于硬件的虚拟化技术 EPT。</p>
<h3 id="扩展页表-extent-page-tableept">扩展页表 Extent Page Table，EPT<a hidden class="anchor" aria-hidden="true" href="#扩展页表-extent-page-tableept">#</a></h3>
<p>Intel 的 EPT（Extent Page Table）技术和 AMD 的 NPT（Nest Page Table）技术都对内存虚拟化提供了硬件支持。这两种技术原理类似，都是在硬件层面上实现 GVA 到 HPA 之间的转换。下面就以 EPT 为例分析一下 KVM 基于硬件辅助的内存虚拟化实现。</p>
<p>EPT 在原有客户机页表对客户机虚拟地址 GVA 到客户机物理地址 GPA 映射的基础上，又引入了 EPT 页表来实现客户机物理地址 GPA 到宿主机物理地址 HPA 的另一次映射。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。</p>
<p>即 EPT 技术采用了在两级页表结构，即原有 Guest OS 页表对 <strong>GVA-&gt;GPA</strong> 映射的基础上，又引入了 EPT 页表来实现 <strong>GPA-&gt;HPA</strong> 的另一次映射，这<strong>两次地址映射都是由硬件自动完成</strong>。</p>
<p>有了 EPT，在<strong>GPA-&gt;HPA</strong>转换的过程中，缺页会产生 EPT 缺页异常。KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。</p>
<p>KVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。</p>
<p>这里，我们重点看第二种方式。因为使用了 EPT 之后，客户机里面的页表映射，也即从 GVA 到 GPA 的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而 EPT 重点帮我们解决的就是从 GPA 到 HPA 的转换问题。因为要经过两次页表，所以 EPT 又 tdp(two dimentional paging)。</p>
<p>EPT 的页表结构也是分为四层，EPT Pointer（EPTP）指向 PML4 的首地址。</p>
<p><img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220124194059.png" alt=""  />
</p>
<h2 id="qemu-的主要工作">QEMU 的主要工作<a hidden class="anchor" aria-hidden="true" href="#qemu-的主要工作">#</a></h2>
<p>内存虚拟化的目的就是让虚拟机能够无缝的访问内存。有了 Intel EPT 的支持后，CPU 在 VMX non-root 状态时进行内存访问会再做一次 EPT 转换。在这个过程中，QEMU 会负责以下内容：</p>
<p>首先需要从自己的进程地址空间中申请内存用于 Guest
需要将上一步中申请到的内存的虚拟地址（HVA）和 Guest 的物理地址之间的映射关系传递给 KVM（kernel），即 GPA-&gt;HVA
需要组织一系列的数据结构来管理虚拟内存空间，并在内存拓扑结构更改时将最新的内存信息同步至 KVM 中</p>
<h2 id="qemu-和-kvm-的工作分界">QEMU 和 KVM 的工作分界<a hidden class="anchor" aria-hidden="true" href="#qemu-和-kvm-的工作分界">#</a></h2>
<p>QEMU 和 KVM 之间是通过 KVM 提供的 ioctl() 接口进行交互的。在内核的 kvm_vm_ioctl() 中，<strong>设置虚拟机内存</strong>的系统调用【kernel 就是一系列系统调用函数接口和处理逻辑，其中有个处理”创建/设置虚拟机内存“的系统调用接口】为  <code>VM_SET_USER_MEMORY_REGION</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">kvm_vm_ioctl</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp,
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> ioctl, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> KVM_SET_USER_MEMORY_REGION: { <span style="color:#75715e">// 在 KVM 中注册用户空间传入的内存信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> kvm_userspace_memory_region kvm_userspace_mem;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">// 将传入的数据结构复制到内核空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">copy_from_user</span>(<span style="color:#f92672">&amp;</span>kvm_userspace_mem, argp, <span style="color:#66d9ef">sizeof</span> kvm_userspace_mem))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">// 实际进行处理的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        r <span style="color:#f92672">=</span> <span style="color:#a6e22e">kvm_vm_ioctl_set_memory_region</span>(kvm, <span style="color:#f92672">&amp;</span>kvm_userspace_mem, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (r)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到这里需要传递的参数类型为 <code>kvm_userspace_memory_region</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* for KVM_SET_USER_MEMORY_REGION */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kvm_userspace_memory_region {
</span></span><span style="display:flex;"><span>    __u32 slot;            <span style="color:#75715e">// slot 编号 [参考：https://www.cnblogs.com/LoyenWang/p/11922887.html]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __u32 flags;           <span style="color:#75715e">// 标志位，例如是否追踪脏页、是否可用等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __u64 guest_phys_addr; <span style="color:#75715e">// Guest 物理地址，即 GPA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __u64 memory_size;     <span style="color:#75715e">// 内存大小，单位 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __u64 userspace_addr;  <span style="color:#75715e">// 从 QEMU 进程地址空间中分配内存的起始地址，即 HVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p><code>KVM_SET_USER_MEMORY_REGION</code>这个 <code>ioctl</code> 主要目的就是设置<code>GPA-&gt;HVA</code>的映射关系，KVM 会继续调用<code>kvm_vm_ioctl_set_memory_region()</code>，在内核空间维护并管理 Guest 的内存。</p>
<h2 id="相关数据结构">相关数据结构<a hidden class="anchor" aria-hidden="true" href="#相关数据结构">#</a></h2>
<h3 id="addressspace">AddressSpace<a hidden class="anchor" aria-hidden="true" href="#addressspace">#</a></h3>
<h4 id="结构体定义">结构体定义<a hidden class="anchor" aria-hidden="true" href="#结构体定义">#</a></h4>
<p>QEMU 用 AddressSpace 结构体表示 Guest 中 CPU/设备看到的内存【也就是Guest OS 可以在 QEMU 进程虚存中用到的所有内存，是 MemoryRegion 的集合，即 GPA 的整体】，类似于物理机中地址空间的概念，但在这里表示的是 Guest 的一段地址空间，如内存地址空间 <code>address_space_memory</code> 、<code>I/O</code> 地址空间<code>address_space_io</code>，它在 QEMU 源码<code>memory.c</code>中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> AddressSpace {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* private: */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> rcu_head rcu;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name;
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Accessed via RCU.  */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> FlatView <span style="color:#f92672">*</span>current_map;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ioeventfd_nb;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> MemoryRegionIoeventfd <span style="color:#f92672">*</span>ioeventfds;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QTAILQ_HEAD</span>(, MemoryListener) listeners;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QTAILQ_ENTRY</span>(AddressSpace) address_spaces_link;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>每个 AddressSpace 一般包含一系列的 MemoryRegion：<code>root</code>指针指向根级 MemoryRegion，而 root 可能有自己的若干个 sub-regions（子节点），于是形成树状结构。这些 MemoryRegion 通过树连接起来，树的根即为 AddressSpace 的 root 域。</p>
<h4 id="全局变量">全局变量<a hidden class="anchor" aria-hidden="true" href="#全局变量">#</a></h4>
<p>另外，QEMU 中有两个全局的静态 AddressSpace，在 memory.c 中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> AddressSpace address_space_memory; <span style="color:#75715e">// 内存地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> AddressSpace address_space_io;     <span style="color:#75715e">// I/O 地址空间
</span></span></span></code></pre></div><p>其 root 域分别指向之后会提到的两个 MemoryRegion 类型变量：system_memory、system_io。</p>
<h3 id="memoryregion">MemoryRegion<a hidden class="anchor" aria-hidden="true" href="#memoryregion">#</a></h3>
<h4 id="结构体定义-1">结构体定义<a hidden class="anchor" aria-hidden="true" href="#结构体定义-1">#</a></h4>
<p><code>MemoryRegion</code> 表示在 <code>Guest Memory Layout</code> 中的一段内存区域【也就是单元级 GPA 的概念，Guest OS 可以管理到的那些 Guest 物理内存单元】，它是联系 <code>GPA</code> 和 <code>RAMBlocks</code>（描述真实内存）之间的桥梁，在<code>memory.h</code>中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> MemoryRegion {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* All fields are private - violators will be prosecuted */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> MemoryRegionOps <span style="color:#f92672">*</span>ops;      <span style="color:#75715e">// 回调函数集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>opaque;
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>parent;            <span style="color:#75715e">// 父 MemoryRegion 指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Int128 size;                     <span style="color:#75715e">// 该区域内存的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">target_phys_addr_t</span> addr;         <span style="color:#75715e">// 在 Address Space 中的地址，即 HVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>destructor)(MemoryRegion <span style="color:#f92672">*</span>mr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ram_addr_t</span> ram_addr;             <span style="color:#75715e">// MemoryRegion 的起始地址，即 GPA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> subpage;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> terminates;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> readable;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> ram;                        <span style="color:#75715e">// 是否表示 RAM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> readonly; <span style="color:#75715e">/* For RAM regions */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> enabled;                    <span style="color:#75715e">// 是否已经通知 KVM 使用这段内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> rom_device;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> warning_printed; <span style="color:#75715e">/* For reservations */</span>
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>alias;             <span style="color:#75715e">// 是否为 MemoryRegion alias
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">target_phys_addr_t</span> alias_offset; <span style="color:#75715e">// 若为 alias，在原 MemoryRegion 中的 offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> priority;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> may_overlap;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QTAILQ_HEAD</span>(subregions, MemoryRegion) subregions; <span style="color:#75715e">// 子区域链表头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">QTAILQ_ENTRY</span>(MemoryRegion) subregions_link;       <span style="color:#75715e">// 子区域链表节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">QTAILQ_HEAD</span>(coalesced_ranges, CoalescedMemoryRange) coalesced;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name;       <span style="color:#75715e">// MemoryRegion 的名字，调试时使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> dirty_log_mask; <span style="color:#75715e">// 表示哪一种 dirty map 被使用，共分三种
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> ioeventfd_nb;
</span></span><span style="display:flex;"><span>    MemoryRegionIoeventfd <span style="color:#f92672">*</span>ioeventfds;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="全局变量-1">全局变量<a hidden class="anchor" aria-hidden="true" href="#全局变量-1">#</a></h4>
<p>在 QEMU 的 exec.c 中也定义了两个静态的 MemoryRegion 指针变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> MemoryRegion <span style="color:#f92672">*</span>system_memory; <span style="color:#75715e">// 内存 MemoryRegion，对应 address_space_memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> MemoryRegion <span style="color:#f92672">*</span>system_io;     <span style="color:#75715e">// I/O MemoryRegion，对应 address_space_io
</span></span></span></code></pre></div><p>与两个全局 AddressSpace 对应，即 AddressSpace 的 root 域指向这两个 MemoryRegion。</p>
<h4 id="memoryregion-的类型">MemoryRegion 的类型<a hidden class="anchor" aria-hidden="true" href="#memoryregion-的类型">#</a></h4>
<p>MemoryRegion 有多种类型，可以表示一段 RAM、ROM、MMIO、alias(别名)。</p>
<p>若为 alias 则表示一个 MemoryRegion 的部分区域，例如，QEMU 会为 pc.ram 这个表示 RAM 的 MemoryRegion 添加两个 alias：ram-below-4g 和 ram-above-4g，之后会看到具体的代码实例。</p>
<p>另外，MemoryRegion 也可以表示一个 container，这就表示它只是其他若干个 MemoryRegion 的容器。</p>
<p>那么要如何创建不同类型的 <code>MemoryRegion</code> 呢？</p>
<p>在 QEMU 中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将 MemoryRegion 划分为以下三种类型：</p>
<ul>
<li>根级 MemoryRegion：直接通过 memory_region_init 初始化，没有自己的内存，用于管理 subregion，例如 system_memory：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init</span>(MemoryRegion <span style="color:#f92672">*</span>mr,
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name,
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">uint64_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>ops <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> <span style="color:#a6e22e">int128_make64</span>(size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">==</span> UINT64_MAX) {
</span></span><span style="display:flex;"><span>        mr<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> <span style="color:#a6e22e">int128_2_64</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>subpage <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>enabled <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>terminates <span style="color:#f92672">=</span> false; <span style="color:#75715e">// 非实体 MemoryRegion，搜索时会继续前往其 subregions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mr<span style="color:#f92672">-&gt;</span>ram <span style="color:#f92672">=</span> false;        <span style="color:#75715e">// 根级 MemoryRegion 不分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mr<span style="color:#f92672">-&gt;</span>readable <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>readonly <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>rom_device <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>destructor <span style="color:#f92672">=</span> memory_region_destructor_none;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>priority <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>may_overlap <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>alias <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QTAILQ_INIT</span>(<span style="color:#f92672">&amp;</span>mr<span style="color:#f92672">-&gt;</span>subregions);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(<span style="color:#f92672">&amp;</span>mr<span style="color:#f92672">-&gt;</span>subregions_link, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span> mr<span style="color:#f92672">-&gt;</span>subregions_link);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QTAILQ_INIT</span>(<span style="color:#f92672">&amp;</span>mr<span style="color:#f92672">-&gt;</span>coalesced);
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>name <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_strdup</span>(name);
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>dirty_log_mask <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>ioeventfd_nb <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>ioeventfds <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到 mr-&gt;addr 被设置为 0，而 mr-&gt;ram_addr 则并没有初始化。</p>
<ul>
<li>实体 <code>MemoryRegion</code>：通过<code>memory_region_init_ram()</code>初始化，有自己的内存（从 QEMU 进程地址空间中分配），大小为<code>size</code>，例如<code>ram_memory</code>、 <code>pci_memory</code>：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pc_memory_init</span>(MemoryRegion <span style="color:#f92672">*</span>system_memory,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>kernel_filename,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>kernel_cmdline,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>initrd_filename,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">ram_addr_t</span> below_4g_mem_size,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">ram_addr_t</span> above_4g_mem_size,
</span></span><span style="display:flex;"><span>                    MemoryRegion <span style="color:#f92672">*</span>rom_memory,
</span></span><span style="display:flex;"><span>                    MemoryRegion <span style="color:#f92672">**</span>ram_memory)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>ram, <span style="color:#f92672">*</span>option_rom_mr;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ...*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Allocate RAM.  We allocate it as a single memory region and use
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * aliases to address portions of it, mostly for backwards compatibility
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * with older qemus that used qemu_ram_alloc().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    ram <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>ram));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 调用 memory_region_init_ram 对 ram_memory 进行初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memory_region_init_ram</span>(ram, <span style="color:#e6db74">&#34;pc.ram&#34;</span>, below_4g_mem_size <span style="color:#f92672">+</span> above_4g_mem_size);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">vmstate_register_ram_global</span>(ram);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>ram_memory <span style="color:#f92672">=</span> ram;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init_ram</span>(MemoryRegion <span style="color:#f92672">*</span>mr,
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name,
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">uint64_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory_region_init</span>(mr, name, size);
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>ram <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>terminates <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>destructor <span style="color:#f92672">=</span> memory_region_destructor_ram;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>ram_addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">qemu_ram_alloc</span>(size, mr);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到这里是先调用了<code>memory_region_init()</code>，之后设置 <code>RAM</code> 属性，并继续调用<code>qemu_ram_alloc()</code>分配内存。</p>
<ul>
<li>别名 <code>MemoryRegion</code>：通过<code>memory_region_init_alias()</code> 初始化，没有自己的内存，表示实体 <code>MemoryRegion</code> 的一部分。通过 <code>alias</code> 成员指向实体 <code>MemoryRegion</code>，<code>alias_offset</code>为在实体 <code>MemoryRegion</code> 中的偏移量，例如<code>ram_below_4g</code>、<code>ram_above_4g</code>：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pc_memory_init</span>(MemoryRegion <span style="color:#f92672">*</span>system_memory,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>kernel_filename,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>kernel_cmdline,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>initrd_filename,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">ram_addr_t</span> below_4g_mem_size,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">ram_addr_t</span> above_4g_mem_size,
</span></span><span style="display:flex;"><span>                    MemoryRegion <span style="color:#f92672">*</span>rom_memory,
</span></span><span style="display:flex;"><span>                    MemoryRegion <span style="color:#f92672">**</span>ram_memory)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>ram_below_4g, <span style="color:#f92672">*</span>ram_above_4g;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>    ram_below_4g <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>ram_below_4g));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 调用 memory_region_init_alias 对 ram_below_4g 进行初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memory_region_init_alias</span>(ram_below_4g, <span style="color:#e6db74">&#34;ram-below-4g&#34;</span>, ram, <span style="color:#ae81ff">0</span>, below_4g_mem_size);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ..
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init_alias</span>(MemoryRegion <span style="color:#f92672">*</span>mr,
</span></span><span style="display:flex;"><span>                              <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name,
</span></span><span style="display:flex;"><span>                              MemoryRegion <span style="color:#f92672">*</span>orig,
</span></span><span style="display:flex;"><span>                              <span style="color:#66d9ef">target_phys_addr_t</span> offset,
</span></span><span style="display:flex;"><span>                              <span style="color:#66d9ef">uint64_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory_region_init</span>(mr, name, size);
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>alias <span style="color:#f92672">=</span> orig; <span style="color:#75715e">// 指向实体 MemoryRegion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mr<span style="color:#f92672">-&gt;</span>alias_offset <span style="color:#f92672">=</span> offset; <span style="color:#75715e">//通过 offset 得到实体的某一个部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="ramblock">RAMBlock<a hidden class="anchor" aria-hidden="true" href="#ramblock">#</a></h3>
<h4 id="结构体定义-2">结构体定义<a hidden class="anchor" aria-hidden="true" href="#结构体定义-2">#</a></h4>
<p><code>MemoryRegion</code> 用来描述一段逻辑层面上的内存区域，而记录实际分配的内存地址信息的结构体则是 <code>RAMBlock</code>，在<code>ramblock.h</code>中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> RAMBlock {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> rcu_head rcu;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> MemoryRegion <span style="color:#f92672">*</span>mr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> <span style="color:#f92672">*</span>host;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> <span style="color:#f92672">*</span>colo_cache; <span style="color:#75715e">/* For colo, VM&#39;s ram cache */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ram_addr_t</span> offset;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ram_addr_t</span> used_length;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ram_addr_t</span> max_length;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>resized)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">uint64_t</span> length, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>host);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> flags;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Protected by iothread lock.  */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> idstr[<span style="color:#ae81ff">256</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* RCU-enabled, writes protected by the ramlist lock */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QLIST_ENTRY</span>(RAMBlock) next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QLIST_HEAD</span>(, RAMBlockNotifier) ramblock_notifiers;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fd;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> page_size;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* dirty bitmap used during migration */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>bmap;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* bitmap of already received pages in postcopy */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>receivedmap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * bitmap to track already cleared dirty bitmap.  When the bit is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * set, it means the corresponding memory chunk needs a log-clear.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Set this up to non-NULL to enable the capability to postpone
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * and split clearing of dirty bitmap on the remote node (e.g.,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * KVM).  The bitmap will be set only when doing global sync.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * NOTE: this bitmap is different comparing to the other bitmaps
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * in that one bit can represent multiple guest pages (which is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * decided by the `clear_bmap_shift&#39; variable below).  On
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * destination side, this should always be NULL, and the variable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * `clear_bmap_shift&#39; is meaningless.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>clear_bmap;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> clear_bmap_shift;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * RAM block length that corresponds to the used_length on the migration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * source (after RAM block sizes were synchronized). Especially, after
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * starting to run the guest, used_length and postcopy_length can differ.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Used to register/unregister uffd handlers and as the size of the received
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * bitmap. Receiving any page beyond this length will bail out, as it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * could not have been valid on the source.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ram_addr_t</span> postcopy_length;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>可以看到在 <code>RAMBlock</code> 中 host 和 offset 域分别对应了 <code>HVA</code> 和<code>GPA</code>，因此也可以说 <code>RAMBlock</code> 中存储了<code>GPA-&gt;HVA</code>的映射关系，另外每一个 <code>RAMBlock</code> 都会指向其所属的 <code>MemoryRegion</code>。</p>
<h4 id="全局变量-ram_list">全局变量 ram_list<a hidden class="anchor" aria-hidden="true" href="#全局变量-ram_list">#</a></h4>
<p>QEMU 在<code>ramlist.h</code>中定义了一个全局变量<code>ram_list</code>，以链表的形式维护了所有的 <code>RAMBlock</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> RAMList {
</span></span><span style="display:flex;"><span>    QemuMutex mutex;
</span></span><span style="display:flex;"><span>    RAMBlock <span style="color:#f92672">*</span>mru_block;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* RCU-enabled, writes protected by the ramlist lock. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QLIST_HEAD</span>(, RAMBlock) blocks;
</span></span><span style="display:flex;"><span>    DirtyMemoryBlocks <span style="color:#f92672">*</span>dirty_memory[DIRTY_MEMORY_NUM];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> version;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QLIST_HEAD</span>(, RAMBlockNotifier) ramblock_notifiers;
</span></span><span style="display:flex;"><span>} RAMList;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> RAMList ram_list;
</span></span></code></pre></div><p>每一个新分配的 <code>RAMBlock</code> 都会被插入到<code>ram_list</code>的头部。如需查找地址所对应的 <code>RAMBlock</code>，则需要遍历<code>ram_list</code>，当目标地址落在当前<code>RAMBlock</code>的地址区间时，该 <code>RAMBlock</code> 即为查找目标。</p>
<h4 id="asmrramblock-之间的关系">AS、MR、RAMBlock 之间的关系<a hidden class="anchor" aria-hidden="true" href="#asmrramblock-之间的关系">#</a></h4>
<p><img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220225155936.png" alt=""  />
</p>
<h3 id="flatview">FlatView<a hidden class="anchor" aria-hidden="true" href="#flatview">#</a></h3>
<p>AddressSpace 的 root 域及其子树共同构成了 Guest 的物理地址空间，但这些都是在 QEMU 侧定义的。要传入 KVM 进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其<strong>转换为一个“平坦”的地址模</strong>型，也就是一个从零开始、只包含地址信息的数据结构，这在 QEMU 中通过 <strong>FlatView</strong> 来表示。每个 AddressSpace 都有一个与之对应的 FlatView 指针 current_map，表示其对应的平面展开视图。</p>
<h4 id="结构体定义-3">结构体定义<a hidden class="anchor" aria-hidden="true" href="#结构体定义-3">#</a></h4>
<p><code>FlatView</code> 在<code>memory.c</code>中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Flattened global view of current active memory hierarchy.  Kept in sorted
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * order.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> FlatView {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> rcu_head rcu;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> ref;
</span></span><span style="display:flex;"><span>    FlatRange <span style="color:#f92672">*</span>ranges;      <span style="color:#75715e">// 对应的 FlatRange 数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> nr;            <span style="color:#75715e">// FlatRange 的数目
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> nr_allocated;  <span style="color:#75715e">// 当前数组的项数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> AddressSpaceDispatch <span style="color:#f92672">*</span>dispatch;
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>root;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>其中，<code>ranges</code>是一个数组，记录了 <code>FlatView</code> 下所有的 <code>FlatRange</code>。</p>
<h4 id="flatrange">FlatRange<a hidden class="anchor" aria-hidden="true" href="#flatrange">#</a></h4>
<p>在 <code>FlatView</code> 中，<code>FlatRange</code> 表示在 <code>FlatView</code> 中的一段内存范围，同样在<code>memory.c</code>中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Range of memory in the global map.  Addresses are absolute. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> FlatRange {
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>mr;           <span style="color:#75715e">// 指向所属的 MemoryRegion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    hwaddr offset_in_region;    <span style="color:#75715e">// 在全局 MemoryRegion 中的 offset，对应 GPA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    AddrRange addr;             <span style="color:#75715e">// 代表的地址区间，对应 HVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> dirty_log_mask;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> romd_mode;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> readonly;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> nonvolatile;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>每个 <code>FlatRange</code> 对应一段虚拟机物理地址区间，各个 <code>FlatRange</code> 不会重叠，<strong>按照地址的顺序保存在数组中</strong>，具体的地址范围由一个 <code>AddrRange</code> 结构来描述：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * AddrRange 用于表示 FlatRange 的起始地址及大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> AddrRange {
</span></span><span style="display:flex;"><span>    Int128 start;
</span></span><span style="display:flex;"><span>    Int128 size;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="memoryregionsection">MemoryRegionSection<a hidden class="anchor" aria-hidden="true" href="#memoryregionsection">#</a></h3>
<h4 id="结构体定义-4">结构体定义<a hidden class="anchor" aria-hidden="true" href="#结构体定义-4">#</a></h4>
<p>在 <code>QEMU</code> 中，还有几个起到中介作用的结构体，<code>MemoryRegionSection</code> 就是其中之一。</p>
<p>之前介绍的 <code>FlatRange</code> 代表一个物理地址空间的片段，偏向于描述在 <code>Host</code> 侧即 <strong>AddressSpace 中的分布【Guest 的物理空间】</strong>，而 <code>MemoryRegionSection</code> 则代表在 <code>Guest</code> 侧即 <strong>MemoryRegion 中的片段</strong>。<code>MemoryRegionSection</code> 在<code>memory.h</code>中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * MemoryRegionSection: describes a fragment of a #MemoryRegion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @mr: the region, or %NULL if empty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @address_space: the address space the region is mapped in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @offset_within_region: the beginning of the section, relative to @mr&#39;s start
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @size: the size of the section; will not exceed @mr&#39;s boundaries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @offset_within_address_space: the address of the first byte of the section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     relative to the region&#39;s address space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @readonly: writes to this section are ignored
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">//只是起到描述的作用，描述了是哪个 AddressSpace 的 MemoryRegion，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">//并且在 MemoryRegion 中的 offset，和在 AddressSpace 展开为平坦内存的 offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> MemoryRegionSection {  
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>mr;                               <span style="color:#75715e">// 所属的 MemoryRegion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MemoryRegion <span style="color:#f92672">*</span>address_space;                    <span style="color:#75715e">// 关联的 AddressSpace
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">target_phys_addr_t</span> offset_within_region;        <span style="color:#75715e">// 在 MemoryRegion 内部的 offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint64_t</span> size;                                  <span style="color:#75715e">// Section 的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">target_phys_addr_t</span> offset_within_address_space; <span style="color:#75715e">// 在 AddressSpace 内部的 offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> readonly;                                  <span style="color:#75715e">// 是否为只读
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><ul>
<li><code>offset_within_region</code>：在所属 <code>MemoryRegion</code> 中的<code>offset</code>。一个<code>AddressSpace</code> 可能由多个 <code>MemoryRegion</code> 组成，因此该 <code>offset</code> 是局部的</li>
<li><code>offset_within_address_space</code>：在所属 <code>AddressSpace</code> 中的 <code>offset</code>，它是全局的</li>
</ul>
<h4 id="和其他数据结构之间的关系">和其他数据结构之间的关系<a hidden class="anchor" aria-hidden="true" href="#和其他数据结构之间的关系">#</a></h4>
<p><img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125110422.png" alt=""  />
</p>
<ul>
<li><code>AddressSpace</code> 的<code>root</code>指向对应的根级<code>MemoryRegion</code>，<code>current_map</code>指向<code>AddressSpace</code> 的<code>root</code>通过<code>generate_memory_topology()</code>生成的 <code>FlatView</code></li>
<li><code>FlatView</code> 中的<code>ranges</code>数组表示该<code>MemoryRegion</code> 所表示的<code>Guest</code>地址区间【GPA 的整个平坦物理空间】，并按照地址的顺序进行排列</li>
<li><code>MemoryRegionSection</code> 由<code>ranges</code>数组中的 <code>FlatRange</code> 对应生成，作为注册到 <code>KVM</code>中的基本单位</li>
</ul>
<hr>
<p><code>QEMU</code> 在用户空间申请内存后，需要将内存信息通过一系列系统调用传入内核空间的 <code>KVM</code>，由 <code>KVM</code> 侧进行管理，因此 <code>QEMU</code> 侧也定义了一些用于向 <code>KVM</code> 传递参数的结构体。</p>
<p>以下为<code>KVM</code>相关的数据结构。</p>
<h3 id="kvmslot">KVMSlot<a hidden class="anchor" aria-hidden="true" href="#kvmslot">#</a></h3>
<p><code>在 kvm_init.h</code>中定义，是 <code>KVM</code> 中内存管理的基本单位：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> KVMSlot
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    hwaddr start_addr; <span style="color:#75715e">// Guest 物理地址，GPA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">ram_addr_t</span> memory_size;        <span style="color:#75715e">// 内存大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ram; <span style="color:#75715e">// QEMU 用户空间地址，HVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> slot;  <span style="color:#75715e">// Slot 编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> flags; <span style="color:#75715e">// 标志位，例如是否追踪脏页、是否可用等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/* Dirty bitmap cache for the slot */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>dirty_bmap;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> dirty_bmap_size;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Cache of the address space ID */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> as_id;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Cache of the offset in ram address space */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ram_addr_t</span> ram_start_offset;
</span></span><span style="display:flex;"><span>} KVMSlot;
</span></span></code></pre></div><p><code>KVMSlot</code> 类似于内存插槽的概念。</p>
<h3 id="kvm_userspace_memory_region">kvm_userspace_memory_region<a hidden class="anchor" aria-hidden="true" href="#kvm_userspace_memory_region">#</a></h3>
<p>调用<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>时需要向 <code>KVM</code> 传递的参数，在<code>kvm.h</code>中定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* for KVM_SET_USER_MEMORY_REGION */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kvm_userspace_memory_region {
</span></span><span style="display:flex;"><span>    __u32 slot;            <span style="color:#75715e">// slot 编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __u32 flags;           <span style="color:#75715e">// 标志位，例如是否追踪脏页、是否可用等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __u64 guest_phys_addr; <span style="color:#75715e">// Guest 物理地址，GPA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __u64 memory_size;     <span style="color:#75715e">// 内存大小，bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __u64 userspace_addr;  <span style="color:#75715e">// 从 QEMU 进程空间分配的起始地址，HVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h3 id="memorylistener">MemoryListener<a hidden class="anchor" aria-hidden="true" href="#memorylistener">#</a></h3>
<h4 id="结构体定义-5">结构体定义<a hidden class="anchor" aria-hidden="true" href="#结构体定义-5">#</a></h4>
<p>为了监控虚拟机的物理地址访问，对于每一个 <code>AddressSpace</code>，都会有一个 <code>MemoryListener</code> 与之对应。每当物理映射<code>GPA-&gt;HVA</code>发生改变时，就会回调这些函数。<strong>MemoryListener</strong> 是对一些事件的<strong>回调函数合集</strong>，在<code>memory.h</code>中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * MemoryListener: callbacks structure for updates to the physical memory map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Allows a component to adjust to changes in the guest-visible memory map.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Use with memory_listener_register() and memory_listener_unregister().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> MemoryListener {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>begin)(MemoryListener <span style="color:#f92672">*</span>listener);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>commit)(MemoryListener <span style="color:#f92672">*</span>listener);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>region_add)(MemoryListener <span style="color:#f92672">*</span>listener, MemoryRegionSection <span style="color:#f92672">*</span>section);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>region_del)(MemoryListener <span style="color:#f92672">*</span>listener, MemoryRegionSection <span style="color:#f92672">*</span>section);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>region_nop)(MemoryListener <span style="color:#f92672">*</span>listener, MemoryRegionSection <span style="color:#f92672">*</span>section);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>log_start)(MemoryListener <span style="color:#f92672">*</span>listener, MemoryRegionSection <span style="color:#f92672">*</span>section);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>log_stop)(MemoryListener <span style="color:#f92672">*</span>listener, MemoryRegionSection <span style="color:#f92672">*</span>section);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>log_sync)(MemoryListener <span style="color:#f92672">*</span>listener, MemoryRegionSection <span style="color:#f92672">*</span>section);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>log_global_start)(MemoryListener <span style="color:#f92672">*</span>listener);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>log_global_stop)(MemoryListener <span style="color:#f92672">*</span>listener);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>eventfd_add)(MemoryListener <span style="color:#f92672">*</span>listener, MemoryRegionSection <span style="color:#f92672">*</span>section,
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">bool</span> match_data, <span style="color:#66d9ef">uint64_t</span> data, EventNotifier <span style="color:#f92672">*</span>e);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>eventfd_del)(MemoryListener <span style="color:#f92672">*</span>listener, MemoryRegionSection <span style="color:#f92672">*</span>section,
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">bool</span> match_data, <span style="color:#66d9ef">uint64_t</span> data, EventNotifier <span style="color:#f92672">*</span>e);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Lower = earlier (during add), later (during del) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> priority;
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>address_space_filter;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QTAILQ_ENTRY</span>(MemoryListener) link;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="全局变量-memory_listeners">全局变量 memory_listeners<a hidden class="anchor" aria-hidden="true" href="#全局变量-memory_listeners">#</a></h4>
<p>所有的 <code>MemoryListener</code> 都会挂在全局变量<code>memory_listeners</code>链表上，在<code>memory.c</code>中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#a6e22e">QTAILQ_HEAD</span>(, MemoryListener) memory_listeners
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> <span style="color:#a6e22e">QTAILQ_HEAD_INITIALIZER</span>(memory_listeners);
</span></span></code></pre></div><p>在<code>memory.c</code>中枚举了<code>ListenerDirection</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> ListenerDirection { Forward, Reverse };
</span></span></code></pre></div><h3 id="重要数据结构总览">重要数据结构总览<a hidden class="anchor" aria-hidden="true" href="#重要数据结构总览">#</a></h3>
<table>
<thead>
<tr>
<th style="text-align:center">结构体名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AddressSpace</td>
<td style="text-align:left">VM 能看到的一段地址空间，偏向 Host 侧【注意指的是偏向】</td>
</tr>
<tr>
<td style="text-align:center">MemoryRegion</td>
<td style="text-align:left">地址空间中一段逻辑层面的内存区域，偏向 Guest 侧</td>
</tr>
<tr>
<td style="text-align:center">RAMBlock</td>
<td style="text-align:left">记录实际分配的内存地址信息，存储了 GPA-&gt;HVA 的映射关系</td>
</tr>
<tr>
<td style="text-align:center">FlatView</td>
<td style="text-align:left">MemoryRegion 对应的平面展开视图，包含一个 FlatRange 类型的 ranges 数组</td>
</tr>
<tr>
<td style="text-align:center">FlatRange</td>
<td style="text-align:left">对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中</td>
</tr>
<tr>
<td style="text-align:center">MemoryRegionSection</td>
<td style="text-align:left">表示 MemoryRegion 中的片段</td>
</tr>
<tr>
<td style="text-align:center">MemoryListener</td>
<td style="text-align:left">回调函数集合</td>
</tr>
<tr>
<td style="text-align:center">KVMSlot</td>
<td style="text-align:left">KVM 中内存管理的基本单位，表示一个内存插槽</td>
</tr>
<tr>
<td style="text-align:center">kvm_userspace_memory_region</td>
<td style="text-align:left">调用 ioctl(KVM_SET_USER_MEMORY_REGION) 时需要向 KVM 传递的参数</td>
</tr>
</tbody>
</table>
<h2 id="具体实现机制">具体实现机制<a hidden class="anchor" aria-hidden="true" href="#具体实现机制">#</a></h2>
<p>QEMU 的内存申请流程大致可分为三个部分：回调函数的注册、AddressSpace 的初始化、实际内存的分配。下面将根据在 vl.c 的 main() 函数中的调用顺序分别介绍。</p>
<h3 id="回调函数的注册">回调函数的注册<a hidden class="anchor" aria-hidden="true" href="#回调函数的注册">#</a></h3>
<p><img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125133808.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">configure_accelerator</span>()
</span></span><span style="display:flex;"><span>       <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kvm_init</span>()                                     <span style="color:#75715e">// 初始化 KVM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#960050;background-color:#1e0010">├─</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kvm_ioctl</span>(KVM_CREATE_VM)                  <span style="color:#75715e">// 创建 VM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#960050;background-color:#1e0010">├─</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kvm_arch_init</span>()                           <span style="color:#75715e">// 针对不同的架构进行初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_listener_register</span>()               <span style="color:#75715e">// 注册 kvm_memory_listener
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                 <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listener_add_address_space</span>() <span style="color:#75715e">// 调用 region_add 回调
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                      <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kvm_region_add</span>()        <span style="color:#75715e">// region_add 对应的回调实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                           <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kvm_set_phys_mem</span>() <span style="color:#75715e">// 根据传入的 section 填充 KVMSlot
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kvm_set_user_memory_region</span>()
</span></span><span style="display:flex;"><span>                                     <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ioctl</span>(KVM_SET_USER_MEMORY_REGION)
</span></span></code></pre></div><p>进入<code>configure_accelerator()</code>后，<code>QEMU</code>会先调用<code>configure_accelerator()</code>设置 <code>KVM</code> 的加速支持，之后进入<code>kvm_init()</code>。该函数主要完成对 KVM 的初始化，包括一些常规检查如 <code>CPU</code> 个数、<code>KVM</code> 版本等，之后通过<code>kvm_ioctl(KVM_CREATE_VM)</code>与内核交互，创建 <code>KVM</code> 虚拟机。在<code>kvm_init()</code>的最后，会调用<code>memory_listener_register()</code>注册<code>kvm_memory_listener</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kvm_init</span>(MachineState <span style="color:#f92672">*</span>ms)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    MachineClass <span style="color:#f92672">*</span>mc <span style="color:#f92672">=</span> <span style="color:#a6e22e">MACHINE_GET_CLASS</span>(ms);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打开/dev/kvm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">qemu_open_old</span>(<span style="color:#e6db74">&#34;/dev/kvm&#34;</span>, O_RDWR);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建 VM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">kvm_ioctl</span>(s, KVM_CREATE_VM, type);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>EINTR);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">kvm_arch_init</span>(s); <span style="color:#75715e">// 针对不同的架构进行初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对于以下 AddressSpace，设置其对应的 listener
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">kvm_memory_listener_register</span>(s, <span style="color:#f92672">&amp;</span>s<span style="color:#f92672">-&gt;</span>memory_listener,
</span></span><span style="display:flex;"><span>                                 <span style="color:#f92672">&amp;</span>address_space_memory, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;kvm-memory&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory_listener_register</span>(<span style="color:#f92672">&amp;</span>kvm_coalesced_pio_listener,
</span></span><span style="display:flex;"><span>                             <span style="color:#f92672">&amp;</span>address_space_io);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_listener_register</span>(MemoryListener <span style="color:#f92672">*</span>listener, AddressSpace <span style="color:#f92672">*</span>as)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    MemoryListener <span style="color:#f92672">*</span>other <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Only one of them can be defined for a listener */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>(<span style="color:#f92672">!</span>(listener<span style="color:#f92672">-&gt;</span>log_sync <span style="color:#f92672">&amp;&amp;</span> listener<span style="color:#f92672">-&gt;</span>log_sync_global));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listener<span style="color:#f92672">-&gt;</span>address_space <span style="color:#f92672">=</span> as;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">QTAILQ_EMPTY</span>(<span style="color:#f92672">&amp;</span>memory_listeners)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">||</span> listener<span style="color:#f92672">-&gt;</span>priority <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">QTAILQ_LAST</span>(<span style="color:#f92672">&amp;</span>memory_listeners)<span style="color:#f92672">-&gt;</span>priority) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">QTAILQ_INSERT_TAIL</span>(<span style="color:#f92672">&amp;</span>memory_listeners, listener, link);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">QTAILQ_FOREACH</span>(other, <span style="color:#f92672">&amp;</span>memory_listeners, link) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (listener<span style="color:#f92672">-&gt;</span>priority <span style="color:#f92672">&lt;</span> other<span style="color:#f92672">-&gt;</span>priority) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">QTAILQ_INSERT_BEFORE</span>(other, listener, link);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">QTAILQ_EMPTY</span>(<span style="color:#f92672">&amp;</span>as<span style="color:#f92672">-&gt;</span>listeners)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">||</span> listener<span style="color:#f92672">-&gt;</span>priority <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">QTAILQ_LAST</span>(<span style="color:#f92672">&amp;</span>as<span style="color:#f92672">-&gt;</span>listeners)<span style="color:#f92672">-&gt;</span>priority) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">QTAILQ_INSERT_TAIL</span>(<span style="color:#f92672">&amp;</span>as<span style="color:#f92672">-&gt;</span>listeners, listener, link_as);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">QTAILQ_FOREACH</span>(other, <span style="color:#f92672">&amp;</span>as<span style="color:#f92672">-&gt;</span>listeners, link_as) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (listener<span style="color:#f92672">-&gt;</span>priority <span style="color:#f92672">&lt;</span> other<span style="color:#f92672">-&gt;</span>priority) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">QTAILQ_INSERT_BEFORE</span>(other, listener, link_as);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">listener_add_address_space</span>(listener, as);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最后的<code>listener_add_address_space()</code>主要是将 listener 注册到其对应的 <code>AddressSpace</code> 上，并根据 <code>AddressSpace</code> 对应的 <code>FlatRange</code> 数组，生成 <code>MemoryRegionSection</code>【<code>MemoryRegionSection</code>就像是为<code>FlatRange</code>数组设置的一种中介表示，便于传入<code>KVM</code>，因为传入<code>KVM</code>应该是对平坦内存的一种表示】，并注册到 <code>KVM</code> 中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listener_add_address_space</span>(MemoryListener <span style="color:#f92672">*</span>listener,
</span></span><span style="display:flex;"><span>                                       AddressSpace <span style="color:#f92672">*</span>as)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    FlatView <span style="color:#f92672">*</span>view;
</span></span><span style="display:flex;"><span>    FlatRange <span style="color:#f92672">*</span>fr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (listener<span style="color:#f92672">-&gt;</span>begin) {
</span></span><span style="display:flex;"><span>        listener<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">begin</span>(listener);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 开启内存脏页记录 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (global_dirty_tracking) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (listener<span style="color:#f92672">-&gt;</span>log_global_start) {
</span></span><span style="display:flex;"><span>            listener<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">log_global_start</span>(listener);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 遍历 AddressSpace 对应的 FlatRange 数组，并将其转换成 MemoryRegionSection */</span>
</span></span><span style="display:flex;"><span>    view <span style="color:#f92672">=</span> <span style="color:#a6e22e">address_space_get_flatview</span>(as);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">FOR_EACH_FLAT_RANGE</span>(fr, view) {
</span></span><span style="display:flex;"><span>        MemoryRegionSection section <span style="color:#f92672">=</span> <span style="color:#a6e22e">section_from_flat_range</span>(fr, view);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* 将 section 所代表的内存区域注册到 KVM 中 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (listener<span style="color:#f92672">-&gt;</span>region_add) {
</span></span><span style="display:flex;"><span>            listener<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">region_add</span>(listener, <span style="color:#f92672">&amp;</span>section);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (fr<span style="color:#f92672">-&gt;</span>dirty_log_mask <span style="color:#f92672">&amp;&amp;</span> listener<span style="color:#f92672">-&gt;</span>log_start) {
</span></span><span style="display:flex;"><span>            listener<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">log_start</span>(listener, <span style="color:#f92672">&amp;</span>section, <span style="color:#ae81ff">0</span>, fr<span style="color:#f92672">-&gt;</span>dirty_log_mask);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (listener<span style="color:#f92672">-&gt;</span>commit) {
</span></span><span style="display:flex;"><span>        listener<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">commit</span>(listener);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">flatview_unref</span>(view);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由于此时 <code>AddressSapce</code> 尚未初始化，所以此处的循环为空，仅是在全局注册了<code>kvm_memory_listener</code>。最后调用了<code>kvm_memory_listener-&gt;region_add()</code>，对应的实现是<code>kvm_region_add()</code>，该函数最终会通过<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>，将 <code>QEMU</code> 侧申请的内存信息传入 <code>KVM</code> 进行注册，这里的流程会在下一部分进行分析。</p>
<h3 id="addressspace-的初始化">AddressSpace 的初始化<a hidden class="anchor" aria-hidden="true" href="#addressspace-的初始化">#</a></h3>
<p><img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220125154841.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cpu_exec_init_all</span>()
</span></span><span style="display:flex;"><span>       <span style="color:#960050;background-color:#1e0010">├─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_map_init</span>()
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">|</span>    <span style="color:#960050;background-color:#1e0010">├─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init</span>()    <span style="color:#75715e">// 初始化 system_memory/io 这两个全局 MemoryRegion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#f92672">|</span>    <span style="color:#960050;background-color:#1e0010">├─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_system_memory_map</span>() <span style="color:#75715e">// address_space_memory-&gt;root = system_memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#f92672">|</span>    <span style="color:#f92672">|</span>    <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_update_topology</span>()        <span style="color:#75715e">// 为 MemoryRegion 生成 FlatView
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#f92672">|</span>    <span style="color:#f92672">|</span>         <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">address_space_update_topology</span>()   <span style="color:#75715e">// as-&gt;current_map = new_view
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#f92672">|</span>    <span style="color:#f92672">|</span>              <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">address_space_update_topology_pass</span>()
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">|</span>    <span style="color:#f92672">|</span>                   <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kvm_region_add</span>()        <span style="color:#75715e">// region_add 对应的回调实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#f92672">|</span>    <span style="color:#f92672">|</span>                        <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kvm_set_phys_mem</span>() <span style="color:#75715e">// 根据传入的 section 填充 KVMSlot
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#f92672">|</span>    <span style="color:#f92672">|</span>                             <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kvm_set_user_memory_region</span>()
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">|</span>    <span style="color:#f92672">|</span>                                  <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ioctl</span>(KVM_SET_USER_MEMORY_REGION)
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">|</span>    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">|</span>    <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_listener_register</span>() <span style="color:#75715e">// 注册对应的 MemoryListener
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#f92672">|</span>         <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listener_add_address_space</span>()
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>       <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">io_mem_init</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init_io</span>() <span style="color:#75715e">// ram/rom/unassigned/notdirty/subpage-ram/watch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                 <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init</span>()
</span></span></code></pre></div><p>第一部分在全局注册了<code>kvm_memory_listener</code>，但由于<code>AddressSpace</code> 尚未初始化，实际上并未向 <code>KVM</code> 中注册任何实际的内存信息。<code>QEMU</code> 在<code>main()</code>函数中会继续调用<code>cpu_exec_init_all()</code>对<code>AddressSpace</code>进行初始化，该函数实际上是对两个 <code>init</code> 函数的封装调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cpu_exec_init_all</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">qemu_mutex_init</span>(<span style="color:#f92672">&amp;</span>ram_list.mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* The data structures we set up here depend on knowing the page size,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * so no more changes can be made after this point.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * In an ideal world, nothing we did before we had finished the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * machine setup would care about the target page size, and we could
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * do this much later, rather than requiring board models to state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * up front what their requirements are.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">finalize_target_page_bits</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">io_mem_init</span>();      <span style="color:#75715e">// 初始化六个I/O MemoryRegion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memory_map_init</span>(); <span style="color:#75715e">// 初始化两个全局 AddressSpace，以及对应的 MemoryRegion、FlatView
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">qemu_mutex_init</span>(<span style="color:#f92672">&amp;</span>map_client_list_lock);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>先来看<code>memory_map_init()</code>，主要用来初始化两个全局的系统地址空间<code>system_memory</code>、<code>system_io</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_map_init</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    system_memory <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>system_memory));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 初始化 system_memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memory_region_init</span>(system_memory, NULL, <span style="color:#e6db74">&#34;system&#34;</span>, UINT64_MAX);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2. 设置 address_space_memory 关联 system_memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这两个都是全局变量，也就是把内存地址空间和 IO 地址空间于对应的 MemoryRegion 联系起来 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//及其对应的 FlatView
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">address_space_init</span>(<span style="color:#f92672">&amp;</span>address_space_memory, system_memory, <span style="color:#e6db74">&#34;memory&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    system_io <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>system_io));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 初始化 system_io  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memory_region_init_io</span>(system_io, NULL, <span style="color:#f92672">&amp;</span>unassigned_io_ops, NULL, <span style="color:#e6db74">&#34;io&#34;</span>,
</span></span><span style="display:flex;"><span>                          <span style="color:#ae81ff">65536</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2. 设置 address_space_io 关联 system_io 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 及其对应的 FlatView
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">address_space_init</span>(<span style="color:#f92672">&amp;</span>address_space_io, system_io, <span style="color:#e6db74">&#34;I/O&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里比较重要的是<code>address_space_init()</code>，先设置 <code>AddressSpace</code> 对应的 <code>MemoryRegion</code>，之后根据<code>system_memory</code>更新<code>address_space_memory</code>对应的 <code>FlatView</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">address_space_init</span>(AddressSpace <span style="color:#f92672">*</span>as, MemoryRegion <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory_region_ref</span>(root);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 address_space_memory 的 root 域指向 system_memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    as<span style="color:#f92672">-&gt;</span>root <span style="color:#f92672">=</span> root;        
</span></span><span style="display:flex;"><span>    as<span style="color:#f92672">-&gt;</span>current_map <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    as<span style="color:#f92672">-&gt;</span>ioeventfd_nb <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    as<span style="color:#f92672">-&gt;</span>ioeventfds <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QTAILQ_INIT</span>(<span style="color:#f92672">&amp;</span>as<span style="color:#f92672">-&gt;</span>listeners);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QTAILQ_INSERT_TAIL</span>(<span style="color:#f92672">&amp;</span>address_spaces, as, address_spaces_link);
</span></span><span style="display:flex;"><span>    as<span style="color:#f92672">-&gt;</span>name <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_strdup</span>(name <span style="color:#f92672">?</span> name : <span style="color:#e6db74">&#34;anonymous&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 根据 system_memory 更新 address_space_memory 对应的 FlatView
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">address_space_update_topology</span>(as);  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">address_space_update_ioeventfds</span>(as);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>address_space_update_topology()</code>会继续调用<code>generate_memory_topology()</code>生成 <code>AddressSpace</code> 对应的 <code>FlatView</code>视图：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">address_space_update_topology</span>(AddressSpace <span style="color:#f92672">*</span>as)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>physmr <span style="color:#f92672">=</span> <span style="color:#a6e22e">memory_region_get_flatview_root</span>(as<span style="color:#f92672">-&gt;</span>root);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">flatviews_init</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">g_hash_table_lookup</span>(flat_views, physmr)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">generate_memory_topology</span>(physmr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">address_space_set_flatview</span>(as);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>address_space_update_topology()</code>会先调用<code>generate_memory_topology()</code>生成<code>system_memory</code>更新后的视图<code>new_view</code>，再将<code>address_space_memory</code>的<code>current_map</code>指向这个<code>new_view</code>，最后销毁<code>old_view</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">address_space_set_flatview</span>(AddressSpace <span style="color:#f92672">*</span>as)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    FlatView <span style="color:#f92672">*</span>old_view <span style="color:#f92672">=</span> <span style="color:#a6e22e">address_space_to_flatview</span>(as);
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>physmr <span style="color:#f92672">=</span> <span style="color:#a6e22e">memory_region_get_flatview_root</span>(as<span style="color:#f92672">-&gt;</span>root);
</span></span><span style="display:flex;"><span>    FlatView <span style="color:#f92672">*</span>new_view <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_hash_table_lookup</span>(flat_views, physmr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>(new_view);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (old_view <span style="color:#f92672">==</span> new_view) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (old_view) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">flatview_ref</span>(old_view);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">flatview_ref</span>(new_view);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">QTAILQ_EMPTY</span>(<span style="color:#f92672">&amp;</span>as<span style="color:#f92672">-&gt;</span>listeners)) {
</span></span><span style="display:flex;"><span>        FlatView tmpview <span style="color:#f92672">=</span> { .nr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> }, <span style="color:#f92672">*</span>old_view2 <span style="color:#f92672">=</span> old_view;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>old_view2) {
</span></span><span style="display:flex;"><span>            old_view2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>tmpview;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">address_space_update_topology_pass</span>(as, old_view2, new_view, false);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">address_space_update_topology_pass</span>(as, old_view2, new_view, true);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Writes are protected by the BQL.  */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">qatomic_rcu_set</span>(<span style="color:#f92672">&amp;</span>as<span style="color:#f92672">-&gt;</span>current_map, new_view);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (old_view) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">flatview_unref</span>(old_view);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Note that all the old MemoryRegions are still alive up to this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * point.  This relieves most MemoryListeners from the need to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * ref/unref the MemoryRegions they get---unless they use them
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * outside the iothread mutex, in which case precise reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * counting is necessary.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (old_view) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">flatview_unref</span>(old_view);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在<code>address_space_update_topology_pass()</code>的最后，会调用<code>MEMORY_LISTENER_UPDATE_REGION</code>这个宏，触发<code>region_add</code>对应的回调函数<code>kvm_region_add()</code>。</p>
<p>这个宏在<code>memory.c</code>中定义，会将 <code>FlatView</code> 中的 <code>FlatRange</code> 转换为 <code>MemoryRegionSection</code>，作为入参传递给<code>kvm_region_add()</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">/* No need to ref/unref .mr, the FlatRange keeps it alive.  */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...)  \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    do {                                                                \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        MemoryRegionSection mrs = section_from_flat_range(fr,           \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                address_space_to_flatview(as));                         \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        MEMORY_LISTENER_CALL(as, callback, dir, &amp;mrs, ##_args);         \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    } while(0)
</span></span></span></code></pre></div><p>而<code>kvm_region_add()</code>实际上是对<code>kvm_set_phys_mem()</code>的封装调用。该函数比较复杂，会根据传入的<code>section</code>填充 KVMSlot，再传递给<code>kvm_set_user_memory_region()</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kvm_set_user_memory_region</span>(KVMMemoryListener <span style="color:#f92672">*</span>kml, KVMSlot <span style="color:#f92672">*</span>slot, <span style="color:#66d9ef">bool</span> new)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    KVMState <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> kvm_state;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> kvm_userspace_memory_region mem;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 根据 KVMSlot 填充 kvm_userspace_memory_region
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mem.slot <span style="color:#f92672">=</span> slot<span style="color:#f92672">-&gt;</span>slot <span style="color:#f92672">|</span> (kml<span style="color:#f92672">-&gt;</span>as_id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span>);
</span></span><span style="display:flex;"><span>    mem.guest_phys_addr <span style="color:#f92672">=</span> slot<span style="color:#f92672">-&gt;</span>start_addr;
</span></span><span style="display:flex;"><span>    mem.userspace_addr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)slot<span style="color:#f92672">-&gt;</span>ram;
</span></span><span style="display:flex;"><span>    mem.flags <span style="color:#f92672">=</span> slot<span style="color:#f92672">-&gt;</span>flags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (slot<span style="color:#f92672">-&gt;</span>memory_size <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>new <span style="color:#f92672">&amp;&amp;</span> (mem.flags <span style="color:#f92672">^</span> slot<span style="color:#f92672">-&gt;</span>old_flags) <span style="color:#f92672">&amp;</span> KVM_MEM_READONLY) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Set the slot size to 0 before setting the slot to the desired
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * value. This is needed based on KVM commit 75d61fbc. */</span>
</span></span><span style="display:flex;"><span>        mem.memory_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">kvm_vm_ioctl</span>(s, KVM_SET_USER_MEMORY_REGION, <span style="color:#f92672">&amp;</span>mem);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mem.memory_size <span style="color:#f92672">=</span> slot<span style="color:#f92672">-&gt;</span>memory_size;
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">kvm_vm_ioctl</span>(s, KVM_SET_USER_MEMORY_REGION, <span style="color:#f92672">&amp;</span>mem);
</span></span><span style="display:flex;"><span>    slot<span style="color:#f92672">-&gt;</span>old_flags <span style="color:#f92672">=</span> mem.flags;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到这里又将 <code>KVMSlot</code> 转换为 <code>kvm_userspace_memory_region</code>，作为<code>ioctl()</code>的参数，交给内核中的 <code>KVM</code> 进行内存的注册【设置<code>GPA-&gt;HVA</code>的映射关系，在内核空间维护并管理 Guest 的内存】。</p>
<p>至此 QEMU 侧负责管理内存的数据结构均已完成初始化，<strong>可以参考下面的图片了解各数据结构之间的对应关系</strong></p>
<p><img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127155506.png" alt=""  />
</p>
<h3 id="实际内存的分配">实际内存的分配<a hidden class="anchor" aria-hidden="true" href="#实际内存的分配">#</a></h3>
<p><img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127160121.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">void</span> machine<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">init</span>(ram_size, ...)
</span></span><span style="display:flex;"><span>       <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pc_init_pci</span>(ram_size, ...) <span style="color:#75715e">// 初始化虚拟机
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pc_init1</span>(system_memory, system_io, ram_size, ...)
</span></span><span style="display:flex;"><span>                 <span style="color:#960050;background-color:#1e0010">├─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init</span>(pci_memory, <span style="color:#e6db74">&#34;pci&#34;</span>, ...) <span style="color:#75715e">// pci_memory, rom_memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                 <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pc_memory_init</span>() <span style="color:#75715e">// 初始化内存，分配实际的物理内存地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                      <span style="color:#960050;background-color:#1e0010">├─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init_ram</span>() <span style="color:#75715e">// 创建 pc.ram, pc.rom 并分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                      <span style="color:#f92672">|</span>    <span style="color:#960050;background-color:#1e0010">├─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init</span>()
</span></span><span style="display:flex;"><span>                      <span style="color:#f92672">|</span>    <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">ram_addr_t</span> <span style="color:#a6e22e">qemu_ram_alloc</span>()
</span></span><span style="display:flex;"><span>                      <span style="color:#f92672">|</span>         <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">ram_addr_t</span> <span style="color:#a6e22e">qemu_ram_alloc_from_ptr</span>()
</span></span><span style="display:flex;"><span>                      <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>                      <span style="color:#960050;background-color:#1e0010">├─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vmstate_register_ram_global</span>() <span style="color:#75715e">// 将 MR 的 name 写入 RAMBlock 的 idstr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                      <span style="color:#f92672">|</span>    <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vmstate_register_ram</span>()
</span></span><span style="display:flex;"><span>                      <span style="color:#f92672">|</span>         <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">qemu_ram_set_idstr</span>()
</span></span><span style="display:flex;"><span>                      <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>                      <span style="color:#960050;background-color:#1e0010">├─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init_alias</span>()    <span style="color:#75715e">// 初始化 ram_below_4g, ram_above_4g
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                      <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_add_subregion</span>() <span style="color:#75715e">// 在 system_memory 中添加 subregions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                           <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_add_subregion_common</span>()
</span></span><span style="display:flex;"><span>                                <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_update_topology</span>() <span style="color:#75715e">// 为 MemoryRegion 生成 FlatView
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                     <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">address_space_update_topology</span>() <span style="color:#75715e">// as-&gt;current_map = new_view
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                          <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">address_space_update_topology_pass</span>()
</span></span><span style="display:flex;"><span>                                               <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kvm_region_add</span>() <span style="color:#75715e">// region_add 对应的回调实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                                    <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kvm_set_phys_mem</span>() <span style="color:#75715e">// 根据传入的 section 填充 KVMSlot
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                                         <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kvm_set_user_memory_region</span>()
</span></span><span style="display:flex;"><span>                                                              <span style="color:#960050;background-color:#1e0010">└─</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ioctl</span>(KVM_SET_USER_MEMORY_REGION)
</span></span></code></pre></div><p>之前的回调函数注册、AddressSpace 的初始化，实际上均没有对应的物理内存。【实际的内存是在 RAMBlock 中】</p>
<p>我们再回到 <code>qemu</code> 启动的 <code>main</code> 函数中。接下来的初始化过程会调用 <code>pc_init1</code>。在这里面，对于 <code>CPU</code> 虚拟化，我们会调用 <code>pc_cpus_init</code>。另外，<code>pc_init1</code> 还会调用<code>pc_memory_init</code>，进行内存的虚拟化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pc_memory_init</span>(MemoryRegion <span style="color:#f92672">*</span>system_memory,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>kernel_filename,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>kernel_cmdline,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>initrd_filename,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">ram_addr_t</span> below_4g_mem_size,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">ram_addr_t</span> above_4g_mem_size,
</span></span><span style="display:flex;"><span>                    MemoryRegion <span style="color:#f92672">*</span>rom_memory,
</span></span><span style="display:flex;"><span>                    MemoryRegion <span style="color:#f92672">**</span>ram_memory)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    MemoryRegion <span style="color:#f92672">*</span>ram, <span style="color:#f92672">*</span>option_rom_mr;         <span style="color:#75715e">// 两个实体 MR: pc.ram, pc.rom
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MemoryRegion <span style="color:#f92672">*</span>ram_below_4g, <span style="color:#f92672">*</span>ram_above_4g; <span style="color:#75715e">// 两个别名 MR: ram_below_4g, ram_above_4g
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Allocate RAM.  We allocate it as a single memory region and use
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * aliases to address portions of it, mostly for backwards compatibility
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * with older qemus that used qemu_ram_alloc().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    ram <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>ram)); <span style="color:#75715e">// 创建 ram
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 分配具体的内存（实际上会创建一个 RAMBlock 并将其 offset 值写入 ram.ram_addr，对应 GPA）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memory_region_init_ram</span>(ram, <span style="color:#e6db74">&#34;pc.ram&#34;</span>, below_4g_mem_size <span style="color:#f92672">+</span> above_4g_mem_size);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 MR 的 name 写入 RAMBlock 的 idstr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">vmstate_register_ram_global</span>(ram);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>ram_memory <span style="color:#f92672">=</span> ram;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建 ram_below_4g 表示 4G 以下的内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ram_below_4g <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>ram_below_4g));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory_region_init_alias</span>(ram_below_4g, <span style="color:#e6db74">&#34;ram-below-4g&#34;</span>, ram, <span style="color:#ae81ff">0</span>, below_4g_mem_size);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 ram_below_4g 挂在 system_memory 下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memory_region_add_subregion</span>(system_memory, <span style="color:#ae81ff">0</span>, ram_below_4g);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (above_4g_mem_size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        ram_above_4g <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>ram_above_4g));
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memory_region_init_alias</span>(ram_above_4g, <span style="color:#e6db74">&#34;ram-above-4g&#34;</span>, ram, below_4g_mem_size, above_4g_mem_size);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memory_region_add_subregion</span>(system_memory, <span style="color:#ae81ff">0x100000000ULL</span>, ram_above_4g);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里的重点在于<code>memory_region_init_ram()</code>，它通过<code>qemu_ram_alloc()</code>获取 ram 这个 <code>MemoryRegion</code> 对应的 <code>RAMBlock</code> 的<code>offset</code>，并存入<code>ram.ram_addr</code>，这样就可以在<code>ram_list</code>中根据该字段查找 <code>MR</code> 对应的 <code>RAMBlock</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memory_region_init_ram</span>(MemoryRegion <span style="color:#f92672">*</span>mr, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name, <span style="color:#66d9ef">uint64_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memory_region_init</span>(mr, name, size); <span style="color:#75715e">// 填充字段，初始化默认值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mr<span style="color:#f92672">-&gt;</span>ram <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 表示为 RAM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mr<span style="color:#f92672">-&gt;</span>terminates <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 表示为实体 MemoryRegion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mr<span style="color:#f92672">-&gt;</span>destructor <span style="color:#f92672">=</span> memory_region_destructor_ram;
</span></span><span style="display:flex;"><span>    mr<span style="color:#f92672">-&gt;</span>ram_addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">qemu_ram_alloc</span>(size, mr); <span style="color:#75715e">// 这里保存 RAMBlock 的 offset，即 GPA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>而 qemu_ram_alloc() 最终会调用 qemu_ram_alloc_from_ptr()，创建一个对应大小 RAMBlock 并分配内存，返回对应的 GPA 地址存入 mr-&gt;ram_addr 中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">ram_addr_t</span> <span style="color:#a6e22e">qemu_ram_alloc_from_ptr</span>(<span style="color:#66d9ef">ram_addr_t</span> size, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>host,
</span></span><span style="display:flex;"><span>                                   MemoryRegion <span style="color:#f92672">*</span>mr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    RAMBlock <span style="color:#f92672">*</span>new_block; <span style="color:#75715e">// 创建一个 RAMBlock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">=</span> <span style="color:#a6e22e">TARGET_PAGE_ALIGN</span>(size); <span style="color:#75715e">// 页对齐
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    new_block <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_malloc0</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>new_block)); <span style="color:#75715e">// 初始化 new_block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    new_block<span style="color:#f92672">-&gt;</span>mr <span style="color:#f92672">=</span> mr; <span style="color:#75715e">// 将 new_block-&gt; 指向入参的 MemoryRegion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    new_block<span style="color:#f92672">-&gt;</span>offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_ram_offset</span>(size); <span style="color:#75715e">// 从 ram_list 中的 RAMBlock 之间找到一段可以满足 size 需求的 gap，并返回起始地址的 offset，对应 GPA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (host) { <span style="color:#75715e">// 新建的 RAMBlock host 字段为空，跳过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        new_block<span style="color:#f92672">-&gt;</span>host <span style="color:#f92672">=</span> host;
</span></span><span style="display:flex;"><span>        new_block<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">|=</span> RAM_PREALLOC_MASK;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (mem_path) { <span style="color:#75715e">// 未指定 mem_path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#if defined (__linux__) &amp;&amp; !defined(TARGET_S390X)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            new_block<span style="color:#f92672">-&gt;</span>host <span style="color:#f92672">=</span> <span style="color:#a6e22e">file_ram_alloc</span>(new_block, size, mem_path);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>new_block<span style="color:#f92672">-&gt;</span>host) {
</span></span><span style="display:flex;"><span>                new_block<span style="color:#f92672">-&gt;</span>host <span style="color:#f92672">=</span> <span style="color:#a6e22e">qemu_vmalloc</span>(size);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">qemu_madvise</span>(new_block<span style="color:#f92672">-&gt;</span>host, size, QEMU_MADV_MERGEABLE);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">fprintf</span>(stderr, <span style="color:#e6db74">&#34;-mem-path option unsupported</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">xen_enabled</span>()) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xen_ram_alloc</span>(new_block<span style="color:#f92672">-&gt;</span>offset, size, mr);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">kvm_enabled</span>()) { <span style="color:#75715e">// 从这里继续
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">/* some s390/kvm configurations have special constraints */</span>
</span></span><span style="display:flex;"><span>                new_block<span style="color:#f92672">-&gt;</span>host <span style="color:#f92672">=</span> <span style="color:#a6e22e">kvm_vmalloc</span>(size); <span style="color:#75715e">// 实际上还是调用 qemu_vmalloc(size)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                new_block<span style="color:#f92672">-&gt;</span>host <span style="color:#f92672">=</span> <span style="color:#a6e22e">qemu_vmalloc</span>(size); <span style="color:#75715e">// 从 QEMU 的线性空间中分配 size 大小的内存，返回 HVA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">qemu_madvise</span>(new_block<span style="color:#f92672">-&gt;</span>host, size, QEMU_MADV_MERGEABLE);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    new_block<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> size; <span style="color:#75715e">// 将 length 设置为 size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QLIST_INSERT_HEAD</span>(<span style="color:#f92672">&amp;</span>ram_list.blocks, new_block, next); <span style="color:#75715e">// 将该 RAMBlock 插入 ram_list 头部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    ram_list.phys_dirty <span style="color:#f92672">=</span> <span style="color:#a6e22e">g_realloc</span>(ram_list.phys_dirty, <span style="color:#75715e">// 重新分配 ram_list.phys_dirty 的内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                       <span style="color:#a6e22e">last_ram_offset</span>() <span style="color:#f92672">&gt;&gt;</span> TARGET_PAGE_BITS);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(ram_list.phys_dirty <span style="color:#f92672">+</span> (new_block<span style="color:#f92672">-&gt;</span>offset <span style="color:#f92672">&gt;&gt;</span> TARGET_PAGE_BITS),
</span></span><span style="display:flex;"><span>           <span style="color:#ae81ff">0</span>, size <span style="color:#f92672">&gt;&gt;</span> TARGET_PAGE_BITS);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cpu_physical_memory_set_dirty_range</span>(new_block<span style="color:#f92672">-&gt;</span>offset, size, <span style="color:#ae81ff">0xff</span>); <span style="color:#75715e">// 对该 RAMBlock 对应的内存标记为 dirty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">qemu_ram_setup_dump</span>(new_block<span style="color:#f92672">-&gt;</span>host, size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">kvm_enabled</span>())
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">kvm_setup_guest_memory</span>(new_block<span style="color:#f92672">-&gt;</span>host, size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> new_block<span style="color:#f92672">-&gt;</span>offset;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样一来<code>ram</code>【其实就是<code>system memory</code>，整个<code>Guest</code>物理空间的大小】对应的 <code>RAMBlock</code> 中就分配好了 <code>GPA</code> 和 <code>HVA</code>，就可以<strong>将内存信息同步至 KVM 侧</strong>了。</p>
<p>最后回到<code>pc_memory_init()</code>中，在分配完实际内存后，会先调用<code>memory_region_init_alias()</code>初始化<code>ram_below_4g</code>、<code>ram_above_4g</code>这两个<code>alias</code>，之后调用<code>memory_region_add_subregion()</code>将这两个 <code>alias</code> 指向<code>ram</code>这个实体 <code>MemoryRegion</code>。如下图，该函数最终会触发<code>kvm_region_add()</code>回调，将实际的内存信息传入 <code>KVM</code> 注册。该过程如下图所示，与之前分析的流程相同，此处不再赘述。</p>
<p><img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163205.png" alt=""  />
</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>虚拟机的内存管理也是需要用户态的 <code>qemu</code> 和内核态的 <code>KVM</code> 共同完成。为了加速内存映射，需要借助硬件的 <code>EPT</code> 技术。</p>
<h3 id="qemu-侧">QEMU 侧<a hidden class="anchor" aria-hidden="true" href="#qemu-侧">#</a></h3>
<ul>
<li>
<p>创建一系列 <code>MemoryRegion</code>，分别表示 <code>Guest</code> 中的 <code>RAM</code>、<code>ROM</code> 等区域。<code>MemoryRegion</code>之间通过 <code>alias</code> 或 <code>subregions</code> 的方式维护相互之间的关系，从而进一步细化区域的定义</p>
</li>
<li>
<p>对于一个实体 <code>MemoryRegion</code>（非 <code>alias</code>），在初始化内存的过程中 <code>QEMU</code> 会创建它所对应的 <code>RAMBlock</code>。该 <code>RAMBlock</code> 通过调用<code>qemu_ram_alloc_from_ptr()</code>从 <code>QEMU</code> 的进程地址空间中<strong>以 mmap 的方式分配内存</strong>，并负责<strong>维护该 MemoryRegion 对应内存的起始 GPA/HVA/size 等相关信息</strong>【在<code>qemu_ram_alloc_from_ptr</code>中创建的新<code>RAMBlock</code>有<code>offset</code>、<code>host</code>的赋值，即<code>GPA-&gt;HVA</code>的对应关系】</p>
</li>
<li>
<p><code>AddressSpace</code> 表示 <code>Guest</code> 的物理地址空间。如果 <code>AddressSpace</code> 中的 <code>MemoryRegion</code> 发生变化，则注册的 <code>listener</code> 会被触发，将所属的 <code>MemoryRegion</code> 树展开生成一维的 <code>FlatView</code>，比较 FlatRange 是否发生了变化。如果是，则调用相应的方法对 <code>MemoryRegionSection</code> 进行检查，更新 <code>QEMU</code> 中的 <code>KVMSlot</code>，同时填充<code>kvm_userspace_memory_region</code>结构体，作为<code>ioctl()</code>的参数更新 <code>KVM</code> 中的<code>kvm_memory_slot</code></p>
</li>
</ul>
<h3 id="kvm-侧">KVM 侧<a hidden class="anchor" aria-hidden="true" href="#kvm-侧">#</a></h3>
<ul>
<li>
<p>当 <code>QEMU</code> 通过<code>ioctl()</code>创建 <code>vcpu</code> 时，调用<code>kvm_mmu_create()</code>初始化 <code>MMU</code> 相关信息。
当 <code>KVM</code> 要进入 <code>Guest</code> 前，<code>vcpu_enter_guest()=&gt;kvm_mmu_reload()</code>会将根级页表地址加载到 <code>VMCS</code>，让 <code>Guest</code> 使用该页表</p>
</li>
<li>
<p>当发生<code>EPT Violation</code> 时，<code>VM-EXIT</code>到 <code>KVM</code> 中。如果是缺页，则根据 <code>GPA</code> 算出 <code>gfn</code>，再根据 <code>gfn</code> 找到对应的 <code>KVMSlot</code>，从中得到对应的 <code>HVA</code>。然后根据 <code>HVA</code> 算出对应的 <code>pfn</code>，确保该 <code>Page</code> 位于内存中。填好缺失的页之后，需要更新 <code>EPT</code>，完善其中缺少的页表项，逐层补全页表</p>
</li>
</ul>
<p><img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127163418.png" alt=""  />
</p>
<blockquote>
<p>虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即 <code>mmap</code> 分配的虚拟内存空间被访问的时候，先查看 <code>EPT</code> 页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。
如果没有映射过，则虚拟机会通过<code>VM-Exit</code>指令回到宿主机模式，通过 <code>handle_ept_violation</code> 补充页表映射。先是通过 <code>handle_mm_fault</code>为虚拟机的物理内存空间分配真正的物理页面，然后通过 <code>__direct_map</code> 添加 <code>EPT</code> 页表映射。
<img loading="lazy" src="https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img/20220127171031.jpg" alt=""  />
</p>
</blockquote>
<h2 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h2>
<p><a href="http://xudaxian.fun/2020/09/03/QEMU%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">“QEMU 内存空间虚拟化及内存管理” - B10g | FΓom 许大仙</a>
<a href="https://www.cnblogs.com/LoyenWang/p/13943005.html">【原创】Linux 虚拟化 KVM-Qemu 分析（五）之内存虚拟化 - LoyenWang - 博客园</a>
<a href="https://blog.csdn.net/xiongwenwu/article/details/58586013">KVM/Qemu 工作原理系列目录_xiongwenwu 的专栏-CSDN 博客_qemu 目录结构</a>
<a href="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/">QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:8888/tags/qemu/">QEMU</a></li>
      <li><a href="http://localhost:8888/tags/linux/">Linux</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:8888/posts/ssh%E5%8E%9F%E7%90%86/">
    <span class="title">« Prev</span>
    <br>
    <span>SSH 原理</span>
  </a>
  <a class="next" href="http://localhost:8888/posts/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%AF%95%E5%9B%BE%E5%86%99%E5%85%A5%E7%9A%84%E7%AE%A1%E9%81%93%E4%B8%8D%E5%AD%98%E5%9C%A8/">
    <span class="title">Next »</span>
    <br>
    <span>解决 VSCode 配置远程连接，过程试图写入的管道不存在</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on x"
            href="https://x.com/intent/tweet/?text=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96&amp;url=http%3a%2f%2flocalhost%3a8888%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f&amp;hashtags=QEMU%2cLinux">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a8888%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f&amp;title=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96&amp;summary=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96&amp;source=http%3a%2f%2flocalhost%3a8888%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a8888%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f&title=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a8888%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on whatsapp"
            href="https://api.whatsapp.com/send?text=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96%20-%20http%3a%2f%2flocalhost%3a8888%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on telegram"
            href="https://telegram.me/share/url?text=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96&amp;url=http%3a%2f%2flocalhost%3a8888%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share QEMU 源码分析-内存虚拟化 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=QEMU%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96&u=http%3a%2f%2flocalhost%3a8888%2fposts%2fqemu%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590-%25E5%2586%2585%25E5%25AD%2598%25E8%2599%259A%25E6%258B%259F%25E5%258C%2596%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:8888/">PaperMod</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
